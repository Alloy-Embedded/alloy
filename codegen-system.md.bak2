# CoreZero: Sistema de Geração de Código

## 1. Visão Geral

O sistema de geração de código do CoreZero é uma ferramenta **interna** e **transparente** que permite suportar centenas de microcontroladores sem complexidade para o usuário final.

### Princípios Fundamentais

1. **Invisível ao Usuário**: O usuário nunca precisa invocar o gerador manualmente
2. **Integrado ao CMake**: Geração acontece automaticamente durante a configuração
3. **Transparente**: Código gerado é C++ legível, navegável na IDE
4. **Baseado em Dados**: Usa arquivos SVD e databases JSON como entrada
5. **Extensível**: Fácil adicionar novos MCUs ou templates

### O Que é Gerado?

- **Startup Code**: Reset handler, inicialização de .data/.bss
- **Vector Tables**: Tabela de vetores de interrupção específica do MCU
- **Register Definitions**: Structs e constantes para acessar periféricos
- **Linker Scripts**: Layout de memória (Flash, RAM, seções especiais)
- **Clock Configuration**: Código para configurar PLLs e clock trees

## 2. Arquitetura do Sistema

```
┌─────────────────────────────────────────────────┐
│              User Project                       │
│         (CMakeLists.txt)                        │
│   set(COREZERO_MCU "STM32F446RE")              │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│         CMake (cmake/codegen.cmake)             │
│  - Verifica se código já foi gerado             │
│  - Invoca generator.py se necessário            │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│      tools/codegen/generator.py                 │
│  1. Carrega database do MCU                     │
│  2. Processa templates Jinja2                   │
│  3. Gera código C++ em build/generated/         │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│        build/generated/STM32F446RE/             │
│  ├── startup.cpp                                │
│  ├── vectors.cpp                                │
│  ├── registers.hpp                              │
│  └── stm32f446re.ld                             │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│         Compilador (arm-none-eabi-g++)          │
│  Compila código gerado + HAL + user app         │
└─────────────────────────────────────────────────┘
```

## 3. Database de MCUs

### Estrutura de Arquivos

```
tools/codegen/database/
├── families/
│   ├── rp2040.json          # Família RP2040 (1 MCU)
│   ├── stm32f4xx.json       # Família STM32F4 (muitos MCUs)
│   └── stm32l4xx.json       # Família STM32L4
│
└── svd/                      # Arquivos SVD originais (backup)
    ├── RP2040.svd
    ├── STM32F446.svd
    └── ...
```

### Formato do Database (JSON)

```json
{
  "family": "STM32F4",
  "mcus": {
    "STM32F446RE": {
      "core": "ARM Cortex-M4F",
      "fpu": "fpv4-sp-d16",
      "flash": {
        "size_kb": 512,
        "base_address": "0x08000000",
        "page_size_kb": 128
      },
      "ram": {
        "size_kb": 128,
        "base_address": "0x20000000"
      },
      "clock": {
        "max_freq_mhz": 180,
        "hse_freq_mhz": 8,
        "hsi_freq_mhz": 16,
        "pll_configs": {
          "180mhz": {
            "pll_m": 8,
            "pll_n": 360,
            "pll_p": 2,
            "pll_q": 7
          }
        }
      },
      "peripherals": {
        "GPIO": {
          "instances": [
            {"name": "GPIOA", "base": "0x40020000"},
            {"name": "GPIOB", "base": "0x40020400"},
            {"name": "GPIOC", "base": "0x40020800"},
            {"name": "GPIOD", "base": "0x40020C00"},
            {"name": "GPIOE", "base": "0x40021000"},
            {"name": "GPIOH", "base": "0x40021C00"}
          ],
          "pins_per_port": 16,
          "registers": {
            "MODER": {"offset": "0x00", "description": "Mode register"},
            "OTYPER": {"offset": "0x04", "description": "Output type"},
            "OSPEEDR": {"offset": "0x08", "description": "Output speed"},
            "PUPDR": {"offset": "0x0C", "description": "Pull-up/down"},
            "IDR": {"offset": "0x10", "description": "Input data"},
            "ODR": {"offset": "0x14", "description": "Output data"},
            "BSRR": {"offset": "0x18", "description": "Bit set/reset"}
          }
        },
        "USART": {
          "instances": [
            {"name": "USART1", "base": "0x40011000", "irq": 37},
            {"name": "USART2", "base": "0x40004400", "irq": 38},
            {"name": "USART3", "base": "0x40004800", "irq": 39},
            {"name": "UART4", "base": "0x40004C00", "irq": 52},
            {"name": "UART5", "base": "0x40005000", "irq": 53},
            {"name": "USART6", "base": "0x40011400", "irq": 71}
          ],
          "registers": {
            "SR": {"offset": "0x00", "description": "Status register"},
            "DR": {"offset": "0x04", "description": "Data register"},
            "BRR": {"offset": "0x08", "description": "Baud rate register"},
            "CR1": {"offset": "0x0C", "description": "Control register 1"}
          }
        }
      },
      "interrupts": {
        "vectors": [
          {"number": 0, "name": "Initial_SP"},
          {"number": 1, "name": "Reset_Handler"},
          {"number": 2, "name": "NMI_Handler"},
          {"number": 3, "name": "HardFault_Handler"},
          {"number": 4, "name": "MemManage_Handler"},
          {"number": 14, "name": "PendSV_Handler"},
          {"number": 15, "name": "SysTick_Handler"},
          {"number": 37, "name": "USART1_IRQHandler"},
          {"number": 38, "name": "USART2_IRQHandler"}
        ]
      }
    }
  }
}
```

### Como Adicionar um Novo MCU

1. **Obter o arquivo SVD** do fabricante (ARM CMSIS-SVD Repository)
2. **Converter SVD → JSON** usando o parser:
   ```bash
   python tools/codegen/svd_parser.py \
       --input STM32F446.svd \
       --output database/families/stm32f4xx.json \
       --merge
   ```
3. **Validar o JSON** gerado e ajustar se necessário
4. **Testar a geração**:
   ```bash
   python tools/codegen/generator.py \
       --mcu STM32F446RE \
       --database database/families/stm32f4xx.json \
       --output /tmp/test_gen
   ```

## 4. Templates Jinja2

### Estrutura de Templates

```
tools/codegen/templates/
├── common/
│   ├── header.j2             # Header padrão de todos os arquivos
│   └── macros.j2             # Macros reutilizáveis
│
├── startup/
│   ├── cortex_m_startup.cpp.j2
│   └── cortex_m_vectors.cpp.j2
│
├── registers/
│   ├── peripheral_struct.hpp.j2
│   └── register_map.hpp.j2
│
└── linker/
    ├── cortex_m.ld.j2
    └── memory_sections.ld.j2
```

### Exemplo: Template de Startup Code

```jinja2
{# templates/startup/cortex_m_startup.cpp.j2 #}
{% include 'common/header.j2' %}

// Startup code for {{ mcu.name }}
// Generated automatically - DO NOT EDIT

#include <cstdint>
#include <cstring>

// Declarações externas do linker script
extern uint32_t _sidata;  // Início dos dados inicializados (Flash)
extern uint32_t _sdata;   // Início da seção .data (RAM)
extern uint32_t _edata;   // Fim da seção .data
extern uint32_t _sbss;    // Início da seção .bss
extern uint32_t _ebss;    // Fim da seção .bss

// Função main do usuário
extern "C" int main();

// System initialization (opcional, implementado pelo usuário)
extern "C" void SystemInit() __attribute__((weak));

// Reset Handler
extern "C" [[noreturn]] void Reset_Handler() {
    // 1. Copiar .data de Flash para RAM
    uint32_t* src = &_sidata;
    uint32_t* dest = &_sdata;
    while (dest < &_edata) {
        *dest++ = *src++;
    }

    // 2. Zerar .bss
    dest = &_sbss;
    while (dest < &_ebss) {
        *dest++ = 0;
    }

    // 3. Chamar inicialização do sistema (clock, FPU, etc)
    if (SystemInit) {
        SystemInit();
    }

    // 4. Chamar construtores estáticos C++
    extern void (*__init_array_start[])();
    extern void (*__init_array_end[])();
    for (auto ctor = __init_array_start; ctor < __init_array_end; ++ctor) {
        (*ctor)();
    }

    // 5. Chamar main
    main();

    // 6. Se main retornar, loop infinito
    while (true) {
        __asm__("wfi");  // Wait For Interrupt
    }
}

// Default handlers (weak, podem ser sobrescritos)
extern "C" {
    {% for vector in interrupts.vectors %}
    {% if vector.name not in ['Initial_SP', 'Reset_Handler'] %}
    [[noreturn]] void {{ vector.name }}() __attribute__((weak, alias("Default_Handler")));
    {% endif %}
    {% endfor %}

    [[noreturn]] void Default_Handler() {
        // Handler padrão: loop infinito
        while (true) {}
    }
}
```

### Exemplo: Template de Registers

```jinja2
{# templates/registers/peripheral_struct.hpp.j2 #}
{% include 'common/header.j2' %}

#pragma once

#include <cstdint>

namespace cz::platform::{{ mcu.family|lower }} {

{% for peripheral_name, peripheral in peripherals.items() %}
// {{ peripheral_name }} Peripheral Register Structure
struct {{ peripheral_name }}_TypeDef {
    {% for reg_name, reg in peripheral.registers.items() %}
    volatile uint32_t {{ reg_name }};  // {{ reg.offset }} - {{ reg.description }}
    {% endfor %}
};

// {{ peripheral_name }} Instance Definitions
{% for instance in peripheral.instances %}
inline constexpr auto {{ instance.name }} = reinterpret_cast<{{ peripheral_name }}_TypeDef*>({{ instance.base }});
{% endfor %}

{% endfor %}

} // namespace cz::platform::{{ mcu.family|lower }}
```

**Saída gerada:**

```cpp
// Auto-generated - DO NOT EDIT

#pragma once

#include <cstdint>

namespace cz::platform::stm32f4 {

// GPIO Peripheral Register Structure
struct GPIO_TypeDef {
    volatile uint32_t MODER;    // 0x00 - Mode register
    volatile uint32_t OTYPER;   // 0x04 - Output type
    volatile uint32_t OSPEEDR;  // 0x08 - Output speed
    volatile uint32_t PUPDR;    // 0x0C - Pull-up/down
    volatile uint32_t IDR;      // 0x10 - Input data
    volatile uint32_t ODR;      // 0x14 - Output data
    volatile uint32_t BSRR;     // 0x18 - Bit set/reset
};

// GPIO Instance Definitions
inline constexpr auto GPIOA = reinterpret_cast<GPIO_TypeDef*>(0x40020000);
inline constexpr auto GPIOB = reinterpret_cast<GPIO_TypeDef*>(0x40020400);
inline constexpr auto GPIOC = reinterpret_cast<GPIO_TypeDef*>(0x40020800);

} // namespace cz::platform::stm32f4
```

### Exemplo: Template de Linker Script

```jinja2
{# templates/linker/cortex_m.ld.j2 #}
/* Linker script for {{ mcu.name }} */
/* Generated automatically - DO NOT EDIT */

MEMORY
{
    FLASH (rx)  : ORIGIN = {{ flash.base_address }}, LENGTH = {{ flash.size_kb }}K
    RAM (rwx)   : ORIGIN = {{ ram.base_address }}, LENGTH = {{ ram.size_kb }}K
}

ENTRY(Reset_Handler)

SECTIONS
{
    .text :
    {
        KEEP(*(.vector_table))
        *(.text*)
        *(.rodata*)
        . = ALIGN(4);
        _etext = .;
    } > FLASH

    .data :
    {
        _sdata = .;
        *(.data*)
        . = ALIGN(4);
        _edata = .;
    } > RAM AT > FLASH

    _sidata = LOADADDR(.data);

    .bss :
    {
        _sbss = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        _ebss = .;
    } > RAM

    .heap :
    {
        _sheap = .;
        . = . + {{ heap_size_kb }}K;
        _eheap = .;
    } > RAM

    _stack_top = ORIGIN(RAM) + LENGTH(RAM);
}
```

## 5. Integração com CMake

### CMake Function

```cmake
# cmake/codegen.cmake

function(corezero_generate_code)
    # Argumentos
    set(oneValueArgs MCU FAMILY OUTPUT_DIR)
    cmake_parse_arguments(GEN "" "${oneValueArgs}" "" ${ARGN})

    # Validação
    if(NOT GEN_MCU)
        message(FATAL_ERROR "MCU not specified for code generation")
    endif()

    # Paths
    set(DATABASE_FILE "${COREZERO_ROOT}/tools/codegen/database/families/${GEN_FAMILY}.json")
    set(OUTPUT_DIR "${GEN_OUTPUT_DIR}")
    set(GENERATOR_SCRIPT "${COREZERO_ROOT}/tools/codegen/generator.py")
    set(GENERATION_MARKER "${OUTPUT_DIR}/.generated_${GEN_MCU}")

    # Verificar se precisa regenerar
    set(NEEDS_GENERATION FALSE)

    if(NOT EXISTS ${GENERATION_MARKER})
        set(NEEDS_GENERATION TRUE)
        message(STATUS "First-time generation for ${GEN_MCU}")
    elseif(${DATABASE_FILE} IS_NEWER_THAN ${GENERATION_MARKER})
        set(NEEDS_GENERATION TRUE)
        message(STATUS "Database updated, regenerating for ${GEN_MCU}")
    elseif(${GENERATOR_SCRIPT} IS_NEWER_THAN ${GENERATION_MARKER})
        set(NEEDS_GENERATION TRUE)
        message(STATUS "Generator updated, regenerating for ${GEN_MCU}")
    endif()

    # Gerar se necessário
    if(NEEDS_GENERATION)
        message(STATUS "Generating platform code for ${GEN_MCU}...")

        find_package(Python3 REQUIRED COMPONENTS Interpreter)

        execute_process(
            COMMAND ${Python3_EXECUTABLE} ${GENERATOR_SCRIPT}
                --mcu ${GEN_MCU}
                --family ${GEN_FAMILY}
                --database ${DATABASE_FILE}
                --output ${OUTPUT_DIR}
                --verbose
            RESULT_VARIABLE CODEGEN_RESULT
            OUTPUT_VARIABLE CODEGEN_OUTPUT
            ERROR_VARIABLE CODEGEN_ERROR
        )

        if(NOT CODEGEN_RESULT EQUAL 0)
            message(FATAL_ERROR "Code generation failed:\n${CODEGEN_ERROR}")
        endif()

        message(STATUS "Code generation completed:\n${CODEGEN_OUTPUT}")

        # Criar marker
        file(TOUCH ${GENERATION_MARKER})
    else()
        message(STATUS "Platform code for ${GEN_MCU} is up to date")
    endif()

    # Exportar variáveis para o caller
    set(COREZERO_GENERATED_DIR ${OUTPUT_DIR} PARENT_SCOPE)
    set(COREZERO_STARTUP_FILE "${OUTPUT_DIR}/startup.cpp" PARENT_SCOPE)
    set(COREZERO_LINKER_SCRIPT "${OUTPUT_DIR}/${GEN_MCU}.ld" PARENT_SCOPE)
endfunction()
```

### Uso no CMakeLists.txt Principal do Framework

```cmake
# corezero/CMakeLists.txt

# Após carregar a configuração da board
include(cmake/boards/${COREZERO_BOARD}.cmake)

# Gerar código se necessário
include(cmake/codegen.cmake)
corezero_generate_code(
    MCU ${COREZERO_MCU}
    FAMILY ${COREZERO_MCU_FAMILY}
    OUTPUT_DIR ${CMAKE_BINARY_DIR}/generated/${COREZERO_MCU}
)

# Adicionar código gerado ao build
add_library(corezero_platform STATIC
    ${COREZERO_GENERATED_DIR}/startup.cpp
    ${COREZERO_GENERATED_DIR}/vectors.cpp
    ${COREZERO_GENERATED_DIR}/system.cpp
)

target_include_directories(corezero_platform PUBLIC
    ${COREZERO_GENERATED_DIR}
)

# Configurar linker script
set(CMAKE_EXE_LINKER_FLAGS
    "${CMAKE_EXE_LINKER_FLAGS} -T${COREZERO_LINKER_SCRIPT}"
)
```

## 6. Generator Script (Python)

### Estrutura Completa

```python
#!/usr/bin/env python3
"""
CoreZero Code Generator

Gera código específico de plataforma a partir de databases JSON.
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any
from jinja2 import Environment, FileSystemLoader, select_autoescape


class CodeGenerator:
    """Gerador de código para MCUs."""

    def __init__(
        self,
        database_path: Path,
        mcu_name: str,
        output_dir: Path,
        template_dir: Path,
        verbose: bool = False
    ):
        self.database_path = database_path
        self.mcu_name = mcu_name
        self.output_dir = output_dir
        self.verbose = verbose

        # Carregar database
        self.db = self._load_database()
        self.mcu = self._get_mcu_config()

        # Setup Jinja2
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True
        )

        # Registrar filtros customizados
        self.jinja_env.filters['hex'] = lambda x: f"0x{x:08X}"

    def _load_database(self) -> Dict[str, Any]:
        """Carrega o database JSON."""
        try:
            with open(self.database_path) as f:
                return json.load(f)
        except Exception as e:
            print(f"ERROR: Failed to load database: {e}", file=sys.stderr)
            sys.exit(1)

    def _get_mcu_config(self) -> Dict[str, Any]:
        """Obtém configuração do MCU específico."""
        mcus = self.db.get('mcus', {})
        if self.mcu_name not in mcus:
            print(f"ERROR: MCU '{self.mcu_name}' not found in database", file=sys.stderr)
            print(f"Available MCUs: {', '.join(mcus.keys())}", file=sys.stderr)
            sys.exit(1)
        return mcus[self.mcu_name]

    def _render_template(self, template_name: str, **context) -> str:
        """Renderiza um template Jinja2."""
        try:
            template = self.jinja_env.get_template(template_name)
            return template.render(
                mcu=self.mcu,
                mcu_name=self.mcu_name,
                family=self.db.get('family'),
                **context
            )
        except Exception as e:
            print(f"ERROR: Template rendering failed ({template_name}): {e}", file=sys.stderr)
            sys.exit(1)

    def _write_file(self, filename: str, content: str):
        """Escreve arquivo no output directory."""
        filepath = self.output_dir / filename
        filepath.parent.mkdir(parents=True, exist_ok=True)

        with open(filepath, 'w') as f:
            f.write(content)

        if self.verbose:
            print(f"  ✓ Generated: {filepath}")

    def generate_startup(self):
        """Gera startup code."""
        content = self._render_template(
            'startup/cortex_m_startup.cpp.j2',
            interrupts=self.mcu['interrupts']
        )
        self._write_file('startup.cpp', content)

    def generate_vectors(self):
        """Gera vector table."""
        content = self._render_template(
            'startup/cortex_m_vectors.cpp.j2',
            interrupts=self.mcu['interrupts']
        )
        self._write_file('vectors.cpp', content)

    def generate_registers(self):
        """Gera definições de registradores."""
        content = self._render_template(
            'registers/peripheral_struct.hpp.j2',
            peripherals=self.mcu['peripherals']
        )
        self._write_file('registers.hpp', content)

    def generate_linker_script(self):
        """Gera linker script."""
        content = self._render_template(
            'linker/cortex_m.ld.j2',
            flash=self.mcu['flash'],
            ram=self.mcu['ram'],
            heap_size_kb=16  # Default 16KB heap
        )
        self._write_file(f'{self.mcu_name.lower()}.ld', content)

    def generate_system_init(self):
        """Gera código de inicialização do sistema (clocks, etc)."""
        content = self._render_template(
            'system/system_init.cpp.j2',
            clock=self.mcu['clock']
        )
        self._write_file('system.cpp', content)

    def generate_all(self):
        """Gera todos os arquivos."""
        self.output_dir.mkdir(parents=True, exist_ok=True)

        if self.verbose:
            print(f"Generating code for {self.mcu_name}...")

        self.generate_startup()
        self.generate_vectors()
        self.generate_registers()
        self.generate_linker_script()
        self.generate_system_init()

        if self.verbose:
            print(f"✅ Code generation completed for {self.mcu_name}")


def main():
    parser = argparse.ArgumentParser(description='CoreZero Code Generator')
    parser.add_argument('--mcu', required=True, help='MCU name (e.g., STM32F446RE)')
    parser.add_argument('--family', required=True, help='MCU family (e.g., stm32f4xx)')
    parser.add_argument('--database', required=True, type=Path, help='Path to database JSON')
    parser.add_argument('--output', required=True, type=Path, help='Output directory')
    parser.add_argument('--templates', type=Path, help='Templates directory')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')

    args = parser.parse_args()

    # Templates dir padrão
    if not args.templates:
        script_dir = Path(__file__).parent
        args.templates = script_dir / 'templates'

    # Validações
    if not args.database.exists():
        print(f"ERROR: Database not found: {args.database}", file=sys.stderr)
        sys.exit(1)

    if not args.templates.exists():
        print(f"ERROR: Templates directory not found: {args.templates}", file=sys.stderr)
        sys.exit(1)

    # Executar geração
    generator = CodeGenerator(
        database_path=args.database,
        mcu_name=args.mcu,
        output_dir=args.output,
        template_dir=args.templates,
        verbose=args.verbose
    )

    generator.generate_all()


if __name__ == '__main__':
    main()
```

## 7. Validação e Testes

### Script de Teste

```bash
#!/bin/bash
# tools/codegen/test_generator.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEST_OUTPUT="/tmp/corezero_codegen_test"

echo "Testing CoreZero Code Generator..."

# Test 1: STM32F446RE
echo "Test 1: Generating code for STM32F446RE"
python3 "$SCRIPT_DIR/generator.py" \
    --mcu STM32F446RE \
    --family stm32f4xx \
    --database "$SCRIPT_DIR/database/families/stm32f4xx.json" \
    --output "$TEST_OUTPUT/stm32f446re" \
    --verbose

# Verificar arquivos gerados
for file in startup.cpp vectors.cpp registers.hpp system.cpp stm32f446re.ld; do
    if [ ! -f "$TEST_OUTPUT/stm32f446re/$file" ]; then
        echo "ERROR: Missing file: $file"
        exit 1
    fi
done

echo "✅ All tests passed!"
echo "Generated files in: $TEST_OUTPUT"
```

## 8. Extensão: Adicionar Novo Peripheral

### Exemplo: Adicionar ADC

1. **Atualizar database**:

```json
{
  "peripherals": {
    "ADC": {
      "instances": [
        {"name": "ADC1", "base": "0x40012000", "irq": 18}
      ],
      "channels": 16,
      "resolution_bits": [12, 10, 8, 6],
      "registers": {
        "SR": {"offset": "0x00", "description": "Status register"},
        "CR1": {"offset": "0x04", "description": "Control register 1"},
        "CR2": {"offset": "0x08", "description": "Control register 2"},
        "DR": {"offset": "0x4C", "description": "Data register"}
      }
    }
  }
}
```

2. **Template é reutilizado automaticamente** (já processa todos os peripherals)

3. **Criar HAL interface**:

```cpp
// src/hal/interface/adc.cppm
export module corezero.hal.adc;

export namespace cz::hal {

template<typename T>
concept AdcChannel = requires(T channel) {
    { channel.read() } -> std::same_as<uint16_t>;
    { channel.start_conversion() } -> std::same_as<void>;
    { channel.is_conversion_complete() } -> std::same_as<bool>;
};

} // namespace cz::hal
```

4. **Implementar para STM32**:

```cpp
// src/hal/stm32f4/adc_impl.cpp
module corezero.hal.adc:stm32f4;

import corezero.platform;  // Registros gerados!

export namespace cz::hal::stm32f4 {

template<uint8_t CHANNEL>
class AdcChannel {
    static_assert(CHANNEL < 16, "STM32F4 ADC has 16 channels");

public:
    uint16_t read() {
        using namespace cz::platform::stm32f4;

        // Usar registros gerados
        ADC1->CR2 |= (1 << 0);  // ADON
        // ... configuração ...

        start_conversion();
        while (!is_conversion_complete()) {}

        return ADC1->DR & 0xFFF;
    }

    // ...
};

} // namespace cz::hal::stm32f4
```

## 9. Roadmap do Sistema de Geração

### Phase 0 (Atual)
- [x] Design do sistema
- [ ] Generator script MVP
- [ ] 1 template funcional (startup)
- [ ] Database para RP2040

### Phase 1
- [ ] Templates completos (startup, vectors, registers, linker)
- [ ] Database para STM32F4
- [ ] Integração com CMake
- [ ] Testes automatizados

### Phase 2
- [ ] SVD parser automático
- [ ] Suporte a clock configuration generator
- [ ] Validação de configurações inválidas
- [ ] Documentação gerada automaticamente

### Phase 3
- [ ] Web UI para explorar MCUs disponíveis
- [ ] Contribuição comunitária de databases
- [ ] Geração otimizada (compile-time feature detection)

---

**Última atualização:** 2025-10-29
**Status:** Design completo, implementação pendente
