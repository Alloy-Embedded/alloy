# CoreZero: Decis√µes T√©cnicas (ADR - Architecture Decision Records)

Este documento registra as principais decis√µes t√©cnicas do projeto CoreZero, incluindo o contexto, as alternativas consideradas e a justificativa para cada escolha.

---

## ADR-001: Usar C++20 em vez de C++23

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Precisamos decidir qual vers√£o do C++ usar como base para o framework. C++23 oferece features interessantes, mas C++20 j√° est√° mais maduro.

### Decis√£o

Usaremos **C++20** como padr√£o base do projeto.

### Alternativas Consideradas

1. **C++23**: Features mais modernas (std::print, ranges melhorados, etc)
2. **C++20**: J√° tem √≥timo suporte em GCC 11+, mais est√°vel
3. **C++17**: M√°xima compatibilidade, mas perde Concepts e Ranges

### Justificativa

- **Toolchain support**: GCC 11+ tem suporte s√≥lido a C++20
- **arm-none-eabi-gcc**: GCC 11 j√° est√° dispon√≠vel para ARM embedded
- **Estabilidade**: C++23 ainda tem muitas features experimentais
- **Suficientemente moderno**: C++20 tem Concepts, Ranges, consteval - suficiente para nossas necessidades
- **Evita bleeding edge**: Reduz risco de bugs de compilador

### Consequ√™ncias

- ‚úÖ Ampla compatibilidade com toolchains embarcados
- ‚úÖ Features modernas suficientes (Concepts, Ranges)
- ‚ùå N√£o podemos usar std::print (mas podemos implementar similar)
- ‚ùå Ranges ainda n√£o tem todas as melhorias do C++23

---

## ADR-002: N√£o usar C++ Modules

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

C++20 introduziu Modules como forma de substituir headers. Modules oferecem compila√ß√£o mais r√°pida e melhor encapsulamento, mas ainda t√™m suporte experimental em muitos compiladores.

### Decis√£o

**N√ÉO** usaremos C++ Modules. Continuaremos com headers tradicionais (`.hpp`/`.h`).

### Alternativas Consideradas

1. **C++ Modules**: Compila√ß√£o r√°pida, encapsulamento melhor
2. **Headers tradicionais**: Compatibilidade total, suporte universal
3. **H√≠brido**: Modules onde dispon√≠vel, fallback para headers

### Justificativa

- **Toolchain embedded**: arm-none-eabi-gcc ainda tem suporte experimental/incompleto a modules
- **CMake**: Suporte a modules em CMake ainda est√° evoluindo
- **IDE support**: VSCode/CLion ainda t√™m limita√ß√µes com modules
- **Pragmatismo**: Headers funcionam perfeitamente, n√£o h√° necessidade urgente de modules
- **Evitar complexidade**: N√£o queremos debuggar problemas de toolchain em vez de desenvolver o framework

### Consequ√™ncias

- ‚úÖ Compatibilidade total com todos os toolchains
- ‚úÖ IDEs funcionam perfeitamente (IntelliSense, navega√ß√£o)
- ‚úÖ CMake simples e direto
- ‚ùå Compila√ß√£o um pouco mais lenta (mas aceit√°vel com ccache)
- ‚ùå Menos encapsulamento (precisamos de include guards)
- üìù **Futuro**: Podemos adicionar modules quando o suporte estiver maduro (C++26?)

---

## ADR-003: N√£o usar Coroutines

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

C++20 introduziu coroutines para programa√ß√£o ass√≠ncrona. S√£o √∫teis para opera√ß√µes I/O, mas t√™m overhead de mem√≥ria e complexidade.

### Decis√£o

**N√ÉO** usaremos coroutines. Preferimos APIs s√≠ncronas com polling e callbacks leves quando necess√°rio.

### Alternativas Consideradas

1. **Coroutines**: C√≥digo mais limpo para opera√ß√µes async (`co_await uart.read()`)
2. **Callbacks**: Padr√£o tradicional, zero overhead
3. **Polling**: Simples, direto, adequado para bare-metal

### Justificativa

- **Overhead de mem√≥ria**: Coroutines precisam de stack frames, problem√°tico em MCUs com pouca RAM
- **Complexidade**: Coroutines adicionam complexidade conceitual
- **Bare-metal first**: Em bare-metal, polling e interrupts s√£o suficientes
- **MCUs pequenos**: Muitos targets t√™m apenas 64KB ou menos de RAM
- **Performance previs√≠vel**: Polling/callbacks t√™m timing mais determin√≠stico

### Consequ√™ncias

- ‚úÖ Zero overhead de mem√≥ria para async operations
- ‚úÖ C√≥digo mais simples de entender e debugar
- ‚úÖ Performance previs√≠vel
- ‚ùå C√≥digo ass√≠ncrono pode ficar verboso (callback hell)
- ‚ùå Usu√°rios vindos de linguagens modernas podem estranhar
- üí° **Solu√ß√£o**: Fornecer helpers e patterns para simplificar c√≥digo com callbacks

### Exemplo de API

```cpp
// Em vez de (com coroutines):
auto data = co_await uart.read_async();

// Teremos:
uart.read(buffer, [](auto& data) {
    // callback quando dados chegarem
});

// Ou polling simples:
while (!uart.available()) {}
auto data = uart.read();
```

---

## ADR-004: Implementar HAL do Zero (Sem Vendor SDKs)

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Podemos usar SDKs oficiais dos fabricantes (Pico SDK, STM32 HAL) ou implementar tudo do zero.

### Decis√£o

Implementaremos toda a HAL **do zero**, sem depend√™ncias de vendor SDKs (exceto CMSIS headers).

### Alternativas Consideradas

1. **Usar vendor SDKs**: R√°pido de implementar, j√° testado
2. **Wrapper sobre vendor SDKs**: Abstrai diferen√ßas, mas ainda depende deles
3. **Implementa√ß√£o pr√≥pria**: Controle total, mas mais trabalho

### Justificativa

**Contra vendor SDKs:**
- **Inconsist√™ncia**: Cada fabricante tem API diferente (Pico SDK vs STM32 HAL vs ESP-IDF)
- **Bloat**: SDKs geralmente incluem muita coisa desnecess√°ria
- **Complexidade**: STM32 HAL, por exemplo, √© extremamente complexo
- **Nossa proposta de valor**: Queremos API consistente e moderna entre plataformas

**A favor de implementa√ß√£o pr√≥pria:**
- **Controle total**: Podemos otimizar para nosso caso de uso
- **API consistente**: Mesma interface para GPIO no RP2040 e STM32
- **C√≥digo limpo**: Sem legacy baggage dos SDKs
- **Aprendizado**: Entendemos profundamente o hardware
- **Tamanho**: C√≥digo final muito menor

### Consequ√™ncias

- ‚úÖ API perfeitamente consistente entre plataformas
- ‚úÖ C√≥digo leve e otimizado
- ‚úÖ Controle total sobre implementa√ß√£o
- ‚úÖ Nenhuma "m√°gica" acontecendo nos bastidores
- ‚ùå Muito mais trabalho inicial
- ‚ùå Precisamos ler muitas datasheets
- ‚ùå Responsabilidade por bugs √© nossa
- ‚ö†Ô∏è **Mitiga√ß√£o**: Come√ßar com 2 plataformas (RP2040 + STM32F4), expandir gradualmente

### Exce√ß√£o: CMSIS Headers

Usaremos **CMSIS headers oficiais** para defini√ß√µes de registradores em ARM Cortex-M:
- S√£o apenas defini√ß√µes (structs, constantes)
- Padr√£o da ind√∫stria
- Zero overhead
- Bem documentado

---

## ADR-005: Usar CMSIS Headers Oficiais

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Precisamos acessar registradores de perif√©ricos. Podemos gerar nossas pr√≥prias defini√ß√µes ou usar CMSIS.

### Decis√£o

Usaremos **CMSIS headers oficiais** da ARM/fabricantes para defini√ß√µes de registradores.

### Alternativas Consideradas

1. **CMSIS headers oficiais**: Padr√£o da ind√∫stria, mantidos pelos fabricantes
2. **Gerar nossas defini√ß√µes**: A partir de SVD files
3. **Defini√ß√µes inline**: Escrever nossas pr√≥prias structs manualmente

### Justificativa

- **Padr√£o da ind√∫stria**: Todos os fabricantes ARM fornecem CMSIS
- **Bem documentado**: Cada registrador tem doc oficial
- **Mantido**: Fabricantes atualizam quando h√° silicon revisions
- **Tipos corretos**: Structs com layout correto garantido
- **Zero overhead**: S√£o apenas defini√ß√µes, n√£o h√° c√≥digo execut√°vel
- **Facilita porting**: Novo MCU? S√≥ precisa do CMSIS header dele

### O que N√ÉO usaremos de CMSIS

- ‚ùå CMSIS-RTOS: Vamos bare-metal
- ‚ùå CMSIS-DSP: Podemos adicionar depois se necess√°rio
- ‚ùå CMSIS-Driver: Implementaremos nossa pr√≥pria HAL

### O que usaremos

- ‚úÖ CMSIS-Core: Defini√ß√µes de registradores do core ARM
- ‚úÖ Device headers: Defini√ß√µes espec√≠ficas do MCU (ex: `stm32f446xx.h`)

### Consequ√™ncias

- ‚úÖ N√£o precisamos gerar/manter defini√ß√µes de registradores
- ‚úÖ Compatibilidade com documenta√ß√£o oficial
- ‚úÖ F√°cil adicionar novos MCUs (s√≥ incluir o CMSIS header)
- ‚ùå Depend√™ncia externa (mas m√≠nima, s√£o s√≥ headers)
- ‚ùå Estilo de c√≥digo n√£o √© totalmente nosso (mas aceit√°vel)

---

## ADR-006: MVP no Host (Sem Hardware Inicialmente)

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Podemos come√ßar implementando direto para hardware ou criar uma vers√£o host-simulated primeiro.

### Decis√£o

O **MVP (Phase 0)** ser√° desenvolvido para **host** (Linux/macOS/Windows) com HAL mockada, antes de implementar para hardware real.

### Alternativas Consideradas

1. **Host first**: Desenvolver mocks primeiro, validar arquitetura
2. **Hardware first**: Come√ßar direto com RP2040 ou STM32
3. **Paralelo**: Desenvolver host e hardware juntos

### Justificativa

**Vantagens do host-first:**
- **Ciclo de desenvolvimento r√°pido**: Compile ‚Üí run em segundos, sem flash
- **Debugging f√°cil**: GDB, valgrind, sanitizers funcionam perfeitamente
- **Validar arquitetura**: Garantir que concepts, interfaces e padr√µes funcionam
- **Testar testabilidade**: Provar que a arquitetura realmente permite testes
- **Sem hardware necess√°rio**: Qualquer desenvolvedor pode contribuir
- **CI/CD simples**: Testes rodam em GitHub Actions sem hardware especial

**Desvantagens:**
- N√£o valida c√≥digo real de hardware at√© mais tarde
- Pode descobrir problemas de hardware depois

### Mitiga√ß√£o de Riscos

- Implementa√ß√£o host deve ser **realista** (n√£o trivial demais)
- Usar refer√™ncias reais (datasheets) mesmo no mock
- Assim que poss√≠vel, portar para hardware real (Phase 1)

### Consequ√™ncias

- ‚úÖ Desenvolvimento inicial muito mais r√°pido
- ‚úÖ F√°cil para novos contribuidores
- ‚úÖ CI/CD trivial de configurar
- ‚úÖ Prova que a arquitetura √© test√°vel
- ‚ö†Ô∏è Precisamos garantir que host mock √© realista
- üìù Phase 1 deve come√ßar LOGO ap√≥s Phase 0

---

## ADR-007: Bare-Metal First, RTOS Opcional Depois

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Muitos frameworks embarcados assumem uso de RTOS (FreeRTOS, Zephyr). Isso adiciona complexidade.

### Decis√£o

Come√ßaremos com suporte **bare-metal only**. RTOS ser√° adicionado depois como feature opcional.

### Alternativas Consideradas

1. **Bare-metal only**: Sem RTOS, apenas polling/interrupts
2. **RTOS first**: Assumir FreeRTOS desde o in√≠cio
3. **RTOS obrigat√≥rio**: Framework depende de RTOS

### Justificativa

- **Simplicidade**: Bare-metal √© mais simples de entender e debugar
- **Zero overhead**: Sem overhead de scheduler
- **Adequado para muitos casos**: Muitas aplica√ß√µes embarcadas n√£o precisam de RTOS
- **Foco**: Queremos validar a HAL primeiro, RTOS adiciona muitas vari√°veis
- **Portabilidade**: Bare-metal funciona em qualquer MCU

### Futuro: RTOS Opcional

Em Phases futuras, adicionaremos **suporte opcional** a:
- FreeRTOS
- Zephyr (talvez)

**Como funcionar√°:**
```cpp
// Bare-metal (default)
#include "hal/gpio.hpp"
auto led = make_gpio_pin<25, Output>();

// Com FreeRTOS (opcional, via compile flag)
#define COREZERO_USE_FREERTOS
#include "hal/gpio.hpp"
#include "rtos/task.hpp"

void led_task(void*) {
    auto led = make_gpio_pin<25, Output>();
    while(1) {
        led.toggle();
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}
```

### Consequ√™ncias

- ‚úÖ Escopo inicial reduzido
- ‚úÖ C√≥digo mais simples
- ‚úÖ Funciona em qualquer MCU
- ‚úÖ Usu√°rios que n√£o precisam de RTOS n√£o pagam o overhead
- ‚è≠Ô∏è Precisaremos pensar em thread-safety quando adicionar RTOS
- üí° API deve ser projetada pensando em futuro suporte a RTOS (mesmo que n√£o implementado ainda)

---

## ADR-008: CMake Puro (Sem Ferramentas Customizadas para Usu√°rio)

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

modm usa lbuild (ferramenta customizada). Podemos fazer similar ou usar CMake puro.

### Decis√£o

Usaremos **CMake 100% puro**. Qualquer ferramenta interna (codegen) ser√° **invocada automaticamente pelo CMake**, invis√≠vel ao usu√°rio.

### Alternativas Consideradas

1. **CMake puro**: Padr√£o da ind√∫stria, integra√ß√£o perfeita com IDEs
2. **Ferramenta customizada** (tipo lbuild): Mais flex√≠vel, mas barreira de ado√ß√£o
3. **Outros build systems**: Meson, Bazel, etc

### Justificativa

**Por que CMake:**
- **Padr√£o da ind√∫stria**: Todo desenvolvedor C++ conhece
- **IDE support**: VSCode, CLion, Visual Studio funcionam perfeitamente
- **Ecossistema**: Ferramentas como ccache, clang-tidy, etc funcionam nativamente
- **Sem curva de aprendizado extra**: J√° √© CMake, n√£o precisa aprender ferramenta nova
- **Transpar√™ncia**: Usu√°rio pode ver exatamente o que est√° acontecendo

**Contra ferramentas customizadas (lbuild-like):**
- Barreira de ado√ß√£o
- Break IDE integration
- Mais uma coisa para aprender
- Dificulta debugging

### Gera√ß√£o de C√≥digo

Teremos um **code generator interno** (Python), mas:
- Ser√° **invocado automaticamente pelo CMake**
- Usu√°rio nunca precisa cham√°-lo manualmente
- Transparente: c√≥digo gerado fica em `build/generated/` (vis√≠vel, naveg√°vel)

### Consequ√™ncias

- ‚úÖ Zero friction para ado√ß√£o
- ‚úÖ IDEs funcionam perfeitamente
- ‚úÖ Ferramental C++ padr√£o funciona
- ‚úÖ F√°cil integrar em projetos existentes
- ‚ö†Ô∏è Precisamos fazer CMake files muito bem documentados
- üí° Template repository com CMakeLists.txt exemplar

---

## ADR-009: Zero Dynamic Allocation na HAL

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Em sistemas embarcados, aloca√ß√£o din√¢mica (`new`/`delete`) pode ser problem√°tica (fragmenta√ß√£o, imprevisibilidade).

### Decis√£o

A **HAL n√£o far√° nenhuma aloca√ß√£o din√¢mica**. Tudo ser√° est√°tico ou em stack.

### Alternativas Consideradas

1. **Zero allocation**: Apenas stack e static storage
2. **Allocation permitida**: Usar heap normalmente
3. **Custom allocators**: std::pmr, memory pools, etc

### Justificativa

- **Previsibilidade**: Uso de mem√≥ria √© conhecido em compile-time
- **Determinismo**: Sem varia√ß√£o de timing por aloca√ß√µes
- **Safety**: Sem fragmenta√ß√£o de heap
- **MCUs pequenos**: Muitos t√™m heap limitado ou inexistente
- **Best practice**: Maioria dos embedded coding standards pro√≠be heap

### Regras

**Na HAL (nossa implementa√ß√£o):**
- ‚ùå N√£o usar `new` / `delete`
- ‚ùå N√£o usar `malloc` / `free`
- ‚ùå N√£o usar `std::vector`, `std::string` (alocam dinamicamente)
- ‚úÖ Usar `std::array` (tamanho fixo)
- ‚úÖ Usar stack allocations
- ‚úÖ Usar static storage

**Na aplica√ß√£o do usu√°rio:**
- ‚úÖ Usu√°rio PODE usar heap se quiser
- ‚úÖ √â escolha do usu√°rio, n√£o impomos
- üí° Mas documentaremos best practices

### Exemplos

```cpp
// ‚ùå N√ÉO na HAL:
class UartDriver {
    std::vector<uint8_t> rx_buffer;  // Aloca dinamicamente!
};

// ‚úÖ SIM na HAL:
template<size_t BUFFER_SIZE = 256>
class UartDriver {
    std::array<uint8_t, BUFFER_SIZE> rx_buffer;  // Tamanho fixo
};

// ‚úÖ Usu√°rio pode fazer:
std::vector<SensorReading> readings;  // OK na app
readings.push_back(sensor.read());
```

### Consequ√™ncias

- ‚úÖ Uso de mem√≥ria previs√≠vel
- ‚úÖ Zero fragmenta√ß√£o
- ‚úÖ Segue best practices embedded
- ‚ö†Ô∏è Templates com tamanhos podem poluir namespace (mitigar com defaults sensatos)
- üí° Documentar claramente que usu√°rio pode usar heap se quiser

---

## ADR-010: Google Test para Unit Tests

**Data:** 2025-10-29
**Status:** Aceito
**Decisores:** Equipe CoreZero

### Contexto

Precisamos de um framework de testes para unit tests (que rodar√£o no host).

### Decis√£o

Usaremos **Google Test (gtest)** como framework de testes.

### Alternativas Consideradas

1. **Google Test**: Padr√£o de facto em C++, muito features
2. **Catch2**: Header-only, mais leve
3. **doctest**: Ainda mais leve, compilation r√°pida
4. **Custom**: Escrever nosso pr√≥prio (n√£o vale a pena)

### Justificativa

- **Industry standard**: Google Test √© o mais usado
- **Features**: Mocking (gmock), parametrized tests, fixtures
- **IDE integration**: VSCode, CLion t√™m suporte nativo
- **CI integration**: F√°cil integrar com GitHub Actions
- **Maturidade**: Extremamente maduro e testado
- **Documenta√ß√£o**: Extensa documenta√ß√£o e exemplos

### Consequ√™ncias

- ‚úÖ Framework robusto e completo
- ‚úÖ Boa integra√ß√£o com ferramentas
- ‚úÖ Comunidade grande (f√°cil achar ajuda)
- ‚ùå Depend√™ncia externa (mas via CMake FetchContent √© trivial)
- ‚ùå Um pouco mais pesado que alternativas (mas roda s√≥ no host, ok)

---

## Resumo das Decis√µes

| # | Decis√£o | Status | Impacto |
|---|---------|--------|---------|
| 001 | C++20 (n√£o C++23) | ‚úÖ Aceito | Alto - define features dispon√≠veis |
| 002 | Sem C++ Modules | ‚úÖ Aceito | Alto - afeta organiza√ß√£o de c√≥digo |
| 003 | Sem Coroutines | ‚úÖ Aceito | M√©dio - afeta API async |
| 004 | HAL do zero | ‚úÖ Aceito | Alto - define escopo de trabalho |
| 005 | Usar CMSIS headers | ‚úÖ Aceito | M√©dio - facilita implementa√ß√£o |
| 006 | MVP no host | ‚úÖ Aceito | Alto - define Phase 0 |
| 007 | Bare-metal first | ‚úÖ Aceito | Alto - simplifica escopo inicial |
| 008 | CMake puro | ‚úÖ Aceito | Alto - define DX |
| 009 | Zero alloc na HAL | ‚úÖ Aceito | M√©dio - afeta design da API |
| 010 | Google Test | ‚úÖ Aceito | Baixo - s√≥ afeta testes |

---

## Decis√µes Pendentes (Para Discutir)

Estas decis√µes ainda precisam ser tomadas nas pr√≥ximas itera√ß√µes:

### ‚è≥ ADR-011: Formato de Logging/Debugging

**Op√ß√µes:**
- `printf`-like tradicional
- `std::format` (C++20)
- Custom logging framework
- Sem logging na HAL (deixar para usu√°rio)

### ‚è≥ ADR-012: Tratamento de Erros

**Op√ß√µes:**
- Exceptions (podem ser problem√°ticas em embedded)
- Error codes (estilo C)
- `std::expected` (C++23, mas podemos backport)
- Asserts + panic handler

### ‚è≥ ADR-013: Pol√≠tica de Interrupts

**Op√ß√µes:**
- Callbacks registrados em compile-time
- Virtual table (runtime)
- Template-based dispatch
- Direct ISR implementation pelo usu√°rio

### ‚è≥ ADR-014: Clock Configuration

**Op√ß√µes:**
- Gerado automaticamente (ferramenta tipo STM32CubeMX)
- Configura√ß√£o manual via CMake
- Runtime configuration
- Templates com valida√ß√£o compile-time

---

**√öltima atualiza√ß√£o:** 2025-10-29
**Pr√≥xima revis√£o:** Ap√≥s completar Phase 0
