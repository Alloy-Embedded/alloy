/// Auto-generated code for AE302F40C1537LE_CM55_HE_View
/// Generated by Alloy Code Generator
/// Source: alifsemi_ae302f40c1.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:08
#ifndef ALLOY_GENERATED_AE302F40C1537LE_CM55_HE_VIEW_PERIPHERALS_HPP
#define ALLOY_GENERATED_AE302F40C1537LE_CM55_HE_VIEW_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::ae302f40c1537le_cm55_he_view {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_clkctl = true;
    constexpr uint32_t num_clkctl_instances = 3;
    constexpr bool has_irqrtr = true;
    constexpr uint32_t num_irqrtr_instances = 1;
    constexpr bool has_cgu = true;
    constexpr uint32_t num_cgu_instances = 1;
    constexpr bool has_pinmux = true;
    constexpr uint32_t num_pinmux_instances = 1;
    constexpr bool has_aon = true;
    constexpr uint32_t num_aon_instances = 1;
    constexpr bool has_vbat = true;
    constexpr uint32_t num_vbat_instances = 1;
    constexpr bool has_ana = true;
    constexpr uint32_t num_ana_instances = 1;
    constexpr bool has_stop = true;
    constexpr uint32_t num_stop_instances = 1;
    constexpr bool has_mhu = true;
    constexpr uint32_t num_mhu_instances = 8;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 4;
    constexpr bool has_npu = true;
    constexpr uint32_t num_npu_instances = 1;
    constexpr bool has_evtrtr2 = true;
    constexpr uint32_t num_evtrtr2_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 17;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 7;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 5;
    constexpr bool has_lppdm = true;
    constexpr uint32_t num_lppdm_instances = 1;
    constexpr bool has_lpcpi = true;
    constexpr uint32_t num_lpcpi_instances = 1;
    constexpr bool has_m55he = true;
    constexpr uint32_t num_m55he_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 9;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 5;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 1;
    constexpr bool has_crc0 = true;
    constexpr uint32_t num_crc0_instances = 1;
    constexpr bool has_crc1 = true;
    constexpr uint32_t num_crc1_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 4;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_cmp3 = true;
    constexpr uint32_t num_cmp3_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_pdm = true;
    constexpr uint32_t num_pdm_instances = 1;
    constexpr bool has_hwsem0 = true;
    constexpr uint32_t num_hwsem0_instances = 1;
    constexpr bool has_hwsem1 = true;
    constexpr uint32_t num_hwsem1_instances = 1;
    constexpr bool has_hwsem2 = true;
    constexpr uint32_t num_hwsem2_instances = 1;
    constexpr bool has_hwsem3 = true;
    constexpr uint32_t num_hwsem3_instances = 1;
    constexpr bool has_hwsem4 = true;
    constexpr uint32_t num_hwsem4_instances = 1;
    constexpr bool has_hwsem5 = true;
    constexpr uint32_t num_hwsem5_instances = 1;
    constexpr bool has_hwsem6 = true;
    constexpr uint32_t num_hwsem6_instances = 1;
    constexpr bool has_hwsem7 = true;
    constexpr uint32_t num_hwsem7_instances = 1;
    constexpr bool has_hwsem8 = true;
    constexpr uint32_t num_hwsem8_instances = 1;
    constexpr bool has_hwsem9 = true;
    constexpr uint32_t num_hwsem9_instances = 1;
    constexpr bool has_hwsem10 = true;
    constexpr uint32_t num_hwsem10_instances = 1;
    constexpr bool has_hwsem11 = true;
    constexpr uint32_t num_hwsem11_instances = 1;
    constexpr bool has_hwsem12 = true;
    constexpr uint32_t num_hwsem12_instances = 1;
    constexpr bool has_hwsem13 = true;
    constexpr uint32_t num_hwsem13_instances = 1;
    constexpr bool has_hwsem14 = true;
    constexpr uint32_t num_hwsem14_instances = 1;
    constexpr bool has_hwsem15 = true;
    constexpr uint32_t num_hwsem15_instances = 1;
    constexpr bool has_cpi = true;
    constexpr uint32_t num_cpi_instances = 1;
    constexpr bool has_cdc = true;
    constexpr uint32_t num_cdc_instances = 1;
    constexpr bool has_dsi = true;
    constexpr uint32_t num_dsi_instances = 1;
    constexpr bool has_csi = true;
    constexpr uint32_t num_csi_instances = 1;
    constexpr bool has_i3c = true;
    constexpr uint32_t num_i3c_instances = 1;
    constexpr bool has_evtrtr0 = true;
    constexpr uint32_t num_evtrtr0_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_gpu2d = true;
    constexpr uint32_t num_gpu2d_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct clkctl_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct irqrtr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cgu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pinmux_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ana_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct stop_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mhu_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct npu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct evtrtr2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 17;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct lppdm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lpcpi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct m55he_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem8_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem9_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem10_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem11_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem12_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem13_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem14_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hwsem15_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cpi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dsi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i3c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct evtrtr0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpu2d_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 17;
    constexpr uint32_t max_gpio_pins = 272;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart = true;
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_uart6 = true;
    constexpr bool has_uart7 = true;
}

// ============================================================================
// CLKCTL Peripheral
// ============================================================================

namespace clkctl {
    /// Base addresses
    constexpr uint32_t CLKCTL_SYS_BASE = 0x1A010000;
    constexpr uint32_t CLKCTL_PER_SLV_BASE = 0x4902F000;
    constexpr uint32_t CLKCTL_PER_MST_BASE = 0x4903F000;

    /// CLKCTL Register structure
    struct Registers {
        volatile uint32_t SYS_LCTRL_ST;  ///< Offset: 0x500 - System Lock Control Status Register
        volatile uint32_t SYS_LCTRL_SET;  ///< Offset: 0x504 - System Lock Control Set Register
        volatile uint32_t SYS_LCTRL_CLR;  ///< Offset: 0x508 - System Lock Control Clear Register
        volatile uint32_t ACLK_CTRL;  ///< Offset: 0x820 - SYST_ACLK Clock Control Register
        volatile uint32_t ACLK_DIV0;  ///< Offset: 0x824 - SYST_ACLK Clock Divider 0 Register
    };

    /// Peripheral instances
    inline Registers* CLKCTL_SYS = reinterpret_cast<Registers*>(CLKCTL_SYS_BASE);
    inline Registers* CLKCTL_PER_SLV = reinterpret_cast<Registers*>(CLKCTL_PER_SLV_BASE);
    inline Registers* CLKCTL_PER_MST = reinterpret_cast<Registers*>(CLKCTL_PER_MST_BASE);

}

// ============================================================================
// IRQRTR Peripheral
// ============================================================================

namespace irqrtr {
    /// Base addresses
    constexpr uint32_t IRQRTR_BASE = 0x1A500000;

    /// IRQRTR Register structure
    struct Registers {
        volatile uint32_t IRQRTR_CTRL;  ///< Offset: 0x00 - IRQRTR Control Register
        volatile uint32_t IRQRTR_LD_CTRL;  ///< Offset: 0x10 - IRQRTR Lockdown Control Register
        volatile uint32_t IRQRTR_SHD_INT_INFO;  ///< Offset: 0x100 - IRQRTR Shared Interrupt Information Register
        volatile uint32_t IRQRTR_SHD_INT_CFG;  ///< Offset: 0x104 - IRQRTR Shared Interrupt Configuration Register
        volatile uint32_t IRQRTR_SHD_INT_LCTRL;  ///< Offset: 0x108 - IRQRTR Shared Interrupt Lock Control Register
        volatile uint32_t IRQRTR_SHD_INT_SEL;  ///< Offset: 0x10C - IRQRTR Shared Interrupt Select Register
        volatile uint32_t IRQRTR_TMP_ST;  ///< Offset: 0xE90 - IRQRTR Tamper Status Register
        volatile uint32_t IRQRTR_CAP;  ///< Offset: 0xFA0 - IRQRTR Capability Register
        volatile uint32_t IRQRTR_CFG;  ///< Offset: 0xFB0 - IRQRTR Configuration Register
    };

    /// Peripheral instances
    inline Registers* IRQRTR = reinterpret_cast<Registers*>(IRQRTR_BASE);

}

// ============================================================================
// CGU Peripheral
// ============================================================================

namespace cgu {
    /// Base addresses
    constexpr uint32_t CGU_BASE = 0x1A602000;

    /// CGU Register structure
    struct Registers {
        volatile uint32_t OSC_CTRL;  ///< Offset: 0x00 - Oscillator Control Register
        volatile uint32_t PLL_LOCK_CTRL;  ///< Offset: 0x04 - PLL Lock Control Register
        volatile uint32_t PLL_CLK_SEL;  ///< Offset: 0x08 - PLL Clock Select Register
        volatile uint32_t ESCLK_SEL;  ///< Offset: 0x10 - Clock Select Register for M55-HP and M55-HE
        volatile uint32_t CLK_ENA;  ///< Offset: 0x14 - Clock Enable Register
        volatile uint32_t CGU_IRQ;  ///< Offset: 0x20 - CGU Interrupt Status Register
    };

    /// Peripheral instances
    inline Registers* CGU = reinterpret_cast<Registers*>(CGU_BASE);

}

// ============================================================================
// PINMUX Peripheral
// ============================================================================

namespace pinmux {
    /// Base addresses
    constexpr uint32_t PINMUX_BASE = 0x1A603000;

    /// PINMUX Register structure
    struct Registers {
        volatile uint32_t P_0;  ///< Offset: 0x00 - Control Register for Port n, Pin 0
        volatile uint32_t P_1;  ///< Offset: 0x04 - Control Register for Port n, Pin 1
        volatile uint32_t P_2;  ///< Offset: 0x08 - Control Register for Port n, Pin 2
        volatile uint32_t P_3;  ///< Offset: 0x0C - Control Register for Port n, Pin 3
        volatile uint32_t P_4;  ///< Offset: 0x10 - Control Register for Port n, Pin 4
        volatile uint32_t P_5;  ///< Offset: 0x14 - Control Register for Port n, Pin 5
        volatile uint32_t P_6;  ///< Offset: 0x18 - Control Register for Port n, Pin 6
        volatile uint32_t P_7;  ///< Offset: 0x1C - Control Register for Port n, Pin 7
    };

    /// Peripheral instances
    inline Registers* PINMUX = reinterpret_cast<Registers*>(PINMUX_BASE);

}

// ============================================================================
// AON Peripheral
// ============================================================================

namespace aon {
    /// Base addresses
    constexpr uint32_t AON_BASE = 0x1A604000;

    /// AON Register structure
    struct Registers {
        volatile uint32_t RTSS_HP_CTRL;  ///< Offset: 0x00 - M55-HP Control Register
        volatile uint32_t RTSS_HP_RESET;  ///< Offset: 0x04 - M55-HP Reset Status Register
        volatile uint32_t RTSS_HE_CTRL;  ///< Offset: 0x10 - M55-HE Control Register
        volatile uint32_t RTSS_HE_RESET;  ///< Offset: 0x14 - M55-HE Reset Status Register
        volatile uint32_t RTSS_HE_LPUART_CKEN;  ///< Offset: 0x1C - LPUART Clock Enable Register
        volatile uint32_t SYSTOP_CLK_DIV;  ///< Offset: 0x20 - System Bus Clock Divider Control Register
        volatile uint32_t MISC_REG1;  ///< Offset: 0x30 - HFXO Divider Control Register
        volatile uint32_t PMU_PERIPH;  ///< Offset: 0x40 - ADC Control Register
    };

    /// Peripheral instances
    inline Registers* AON = reinterpret_cast<Registers*>(AON_BASE);

}

// ============================================================================
// VBAT Peripheral
// ============================================================================

namespace vbat {
    /// Base addresses
    constexpr uint32_t VBAT_BASE = 0x1A609000;

    /// VBAT Register structure
    struct Registers {
        volatile uint32_t GPIO_CTRL;  ///< Offset: 0x00 - GPIO 1.8 V / 3.3 V Power Control Register
        volatile uint32_t TIMER_CLKSEL;  ///< Offset: 0x04 - LPTIMER Clock Select Register
        volatile uint32_t PWR_CTRL;  ///< Offset: 0x08 - Power Control Register
        volatile uint32_t RET_CTRL;  ///< Offset: 0x0C - Memory Retention Control Register
        volatile uint32_t RTC_CLK_EN;  ///< Offset: 0x10 - LPRTC Clock Enable Register
    };

    /// Peripheral instances
    inline Registers* VBAT = reinterpret_cast<Registers*>(VBAT_BASE);

}

// ============================================================================
// ANA Peripheral
// ============================================================================

namespace ana {
    /// Base addresses
    constexpr uint32_t ANA_BASE = 0x1A60A000;

    /// ANA Register structure
    struct Registers {
        volatile uint32_t MISC_CTRL;  ///< Offset: 0x00 - VBAT Misc Control Register
        volatile uint32_t WKUP_CTRL;  ///< Offset: 0x08 - VBAT Wake-up Source Control Register
        volatile uint32_t DCDC_REG1;  ///< Offset: 0x30 - DC/DC Control Register 1
        volatile uint32_t DCDC_REG2;  ///< Offset: 0x34 - DC/DC Control Register 2
        volatile uint32_t VBAT_ANA_REG1;  ///< Offset: 0x38 - VBAT Analog Control Register 1
        volatile uint32_t VBAT_ANA_REG2;  ///< Offset: 0x3C - VBAT Analog Control Register 2
        volatile uint32_t VBAT_ANA_REG3;  ///< Offset: 0x40 - VBAT Analog Control Register 3
    };

    /// Peripheral instances
    inline Registers* ANA = reinterpret_cast<Registers*>(ANA_BASE);

}

// ============================================================================
// STOP Peripheral
// ============================================================================

namespace stop {
    /// Base addresses
    constexpr uint32_t STOP_MODE_BASE = 0x1A60F000;

    /// STOP Register structure
    struct Registers {
        volatile uint32_t VBAT_STOP_MODE_REG;  ///< Offset: 0x00 - VBAT Stop Mode Control and Status Register
    };

    /// Peripheral instances
    inline Registers* STOP_MODE = reinterpret_cast<Registers*>(STOP_MODE_BASE);

}

// ============================================================================
// MHU Peripheral
// ============================================================================

namespace mhu {
    /// Base addresses
    constexpr uint32_t MHU_SECPU_M55HE_0_RX_BASE = 0x40040000;
    constexpr uint32_t MHU_M55HE_SECPU_0_TX_BASE = 0x40050000;
    constexpr uint32_t MHU_SECPU_M55HE_1_RX_BASE = 0x40060000;
    constexpr uint32_t MHU_M55HE_SECPU_1_TX_BASE = 0x40070000;
    constexpr uint32_t MHU_M55HP_M55HE_0_RX_BASE = 0x40080000;
    constexpr uint32_t MHU_M55HE_M55HP_0_TX_BASE = 0x40090000;
    constexpr uint32_t MHU_M55HP_M55HE_1_RX_BASE = 0x400A0000;
    constexpr uint32_t MHU_M55HE_M55HP_1_TX_BASE = 0x400B0000;

    /// MHU Register structure
    struct Registers {
        volatile uint32_t MHU_CH_ST;  ///< Offset: 0x00 - Channel (n) Status Register
        volatile uint32_t MHU_CH_ST_MSK;  ///< Offset: 0x04 - Channel (n) Status Masked Register
        volatile uint32_t MHU_CH_CLR;  ///< Offset: 0x08 - Channel Clear Register
        volatile uint32_t MHU_CH_MSK_ST;  ///< Offset: 0x10 - Channel (n) Mask Status Register
        volatile uint32_t MHU_CH_MSK_SET;  ///< Offset: 0x14 - Channel (n) Mask Set Register
        volatile uint32_t MHU_CH_MSK_CLR;  ///< Offset: 0x18 - Channel (n) Mask Clear Register
        volatile uint32_t MHU_CFG;  ///< Offset: 0xF80 - Module Configuration Register
        volatile uint32_t MHU_INT_ST;  ///< Offset: 0xF90 - Interrupt Status Register
        volatile uint32_t MHU_INT_CLR;  ///< Offset: 0xF94 - Interrupt Clear Register
        volatile uint32_t MHU_INT_EN;  ///< Offset: 0xF98 - Interrupt Enable Register
        volatile uint32_t MHU_CHCOMB_INT_ST0;  ///< Offset: 0xFA0 - Channel Combined Interrupt Status Register for Channels 0-31
        volatile uint32_t MHU_CHCOMB_INT_ST1;  ///< Offset: 0xFA4 - Channel Combined Interrupt Status Register for Channels 32-63
        volatile uint32_t MHU_CHCOMB_INT_ST2;  ///< Offset: 0xFA8 - Channel Combined Interrupt Status Register for Channels 64-95
        volatile uint32_t MHU_CHCOMB_INT_ST3;  ///< Offset: 0xFAC - Channel Combined Interrupt Status Register for Channels 96-123
        volatile uint32_t MHU_IIDR;  ///< Offset: 0xFC8 - Implementer Identification Register
        volatile uint32_t MHU_AIDR;  ///< Offset: 0xFCC - Architecture Identification Register
        volatile uint32_t MHU_PID4;  ///< Offset: 0xFD0 - Peripheral ID 4 Register
        volatile uint32_t MHU_PID0;  ///< Offset: 0xFE0 - Peripheral ID 0 Register
        volatile uint32_t MHU_PID1;  ///< Offset: 0xFE4 - Peripheral ID 1 Register
        volatile uint32_t MHU_PID2;  ///< Offset: 0xFE8 - Peripheral ID 2 Register
        volatile uint32_t MHU_PID3;  ///< Offset: 0xFEC - Peripheral ID 3 Register
        volatile uint32_t MHU_CID0;  ///< Offset: 0xFF0 - Component ID 0 Register
        volatile uint32_t MHU_CID1;  ///< Offset: 0xFF4 - Component ID 1 Register
        volatile uint32_t MHU_CID2;  ///< Offset: 0xFF8 - Component ID 2 Register
        volatile uint32_t MHU_CID3;  ///< Offset: 0xFFC - Component ID 3 Register
    };

    /// Peripheral instances
    inline Registers* MHU_SECPU_M55HE_0_RX = reinterpret_cast<Registers*>(MHU_SECPU_M55HE_0_RX_BASE);
    inline Registers* MHU_M55HE_SECPU_0_TX = reinterpret_cast<Registers*>(MHU_M55HE_SECPU_0_TX_BASE);
    inline Registers* MHU_SECPU_M55HE_1_RX = reinterpret_cast<Registers*>(MHU_SECPU_M55HE_1_RX_BASE);
    inline Registers* MHU_M55HE_SECPU_1_TX = reinterpret_cast<Registers*>(MHU_M55HE_SECPU_1_TX_BASE);
    inline Registers* MHU_M55HP_M55HE_0_RX = reinterpret_cast<Registers*>(MHU_M55HP_M55HE_0_RX_BASE);
    inline Registers* MHU_M55HE_M55HP_0_TX = reinterpret_cast<Registers*>(MHU_M55HE_M55HP_0_TX_BASE);
    inline Registers* MHU_M55HP_M55HE_1_RX = reinterpret_cast<Registers*>(MHU_M55HP_M55HE_1_RX_BASE);
    inline Registers* MHU_M55HE_M55HP_1_TX = reinterpret_cast<Registers*>(MHU_M55HE_M55HP_1_TX_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA2_SEC_BASE = 0x400C0000;
    constexpr uint32_t DMA2_NS_BASE = 0x400E0000;
    constexpr uint32_t DMA0_SEC_BASE = 0x49080000;
    constexpr uint32_t DMA0_NS_BASE = 0x490A0000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMA_DSR;  ///< Offset: 0x00 - DMA Manager Status Register
        volatile uint32_t DMA_DPC;  ///< Offset: 0x04 - DMA Program Counter Register
        volatile uint32_t DMA_INTEN;  ///< Offset: 0x20 - Interrupt Enable Register
        volatile uint32_t DMA_INT_EVENT_RIS;  ///< Offset: 0x24 - Event-Interrupt Raw Status Register
        volatile uint32_t DMA_INTMIS;  ///< Offset: 0x28 - Interrupt Status Register
        volatile uint32_t DMA_INTCLR;  ///< Offset: 0x2C - Interrupt Clear Register
        volatile uint32_t DMA_FSRD;  ///< Offset: 0x30 - Fault Status DMA Manager Register
        volatile uint32_t DMA_FSRC;  ///< Offset: 0x34 - Fault Status DMA Channel Register
        volatile uint32_t DMA_FTRD;  ///< Offset: 0x38 - Fault Type DMA Manager Register
        volatile uint32_t DMA_FTR__;  ///< Offset: 0x40 - Fault Type for DMA Channel (n) Register (renamed from DMA_FTR__)
        volatile uint32_t DMA_CSR;  ///< Offset: 0x00 - Channel Status for DMA Channel (n) Register
        volatile uint32_t DMA_CPC;  ///< Offset: 0x04 - Channel PC for DMA Channel (n) Register
        volatile uint32_t DMA_SAR;  ///< Offset: 0x00 - Source Address for DMA Channel (n) Register
        volatile uint32_t DMA_DAR;  ///< Offset: 0x04 - Destination Address for DMA Channel (n) Register
        volatile uint32_t DMA_CCR;  ///< Offset: 0x08 - Channel Control for DMA Channel (n) Register
        volatile uint32_t DMA_LC0;  ///< Offset: 0x0C - Loop Counter 0 for DMA Channel (n) Register
        volatile uint32_t DMA_LC1;  ///< Offset: 0x10 - Loop Counter 1 for DMA Channel (n) Register
        volatile uint32_t DMA_DBGSTATUS;  ///< Offset: 0xD00 - Debug Status Register
        volatile uint32_t DMA_DBGCMD;  ///< Offset: 0xD04 - Debug Command Register
        volatile uint32_t DMA_DBGINST0;  ///< Offset: 0xD08 - Debug Instruction Register 0
        volatile uint32_t DMA_DBGINST1;  ///< Offset: 0xD0C - Debug Instruction Register 1
        volatile uint32_t DMA_CR0;  ///< Offset: 0xE00 - Configuration Register 0
        volatile uint32_t DMA_CR1;  ///< Offset: 0xE04 - Configuration Register 1
        volatile uint32_t DMA_CR2;  ///< Offset: 0xE08 - Configuration Register 2
        volatile uint32_t DMA_CR3;  ///< Offset: 0xE0C - Configuration Register 3
        volatile uint32_t DMA_CR4;  ///< Offset: 0xE10 - Configuration Register 4
        volatile uint32_t DMA_CRD;  ///< Offset: 0xE14 - DMA Configuration Register
        volatile uint32_t DMA_WD;  ///< Offset: 0xE80 - Watchdog Register
        volatile uint32_t DMA_PERIPH_ID_0;  ///< Offset: 0xFE0 - Peripheral ID Register 0
        volatile uint32_t DMA_PERIPH_ID_1;  ///< Offset: 0xFE4 - Peripheral ID Register 1
        volatile uint32_t DMA_PERIPH_ID_2;  ///< Offset: 0xFE8 - Peripheral ID Register 2
        volatile uint32_t DMA_PERIPH_ID_3;  ///< Offset: 0xFEC - Peripheral ID Register 3
        volatile uint32_t DMA_PCELL_ID_0;  ///< Offset: 0xFF0 - Component Identification Register 0
        volatile uint32_t DMA_PCELL_ID_1;  ///< Offset: 0xFF4 - Component Identification Register 1
        volatile uint32_t DMA_PCELL_ID_2;  ///< Offset: 0xFF8 - Component Identification Register 2
        volatile uint32_t DMA_PCELL_ID_3;  ///< Offset: 0xFFC - Component Identification Register 3
    };

    /// Peripheral instances
    inline Registers* DMA2_SEC = reinterpret_cast<Registers*>(DMA2_SEC_BASE);
    inline Registers* DMA2_NS = reinterpret_cast<Registers*>(DMA2_NS_BASE);
    inline Registers* DMA0_SEC = reinterpret_cast<Registers*>(DMA0_SEC_BASE);
    inline Registers* DMA0_NS = reinterpret_cast<Registers*>(DMA0_NS_BASE);

}

// ============================================================================
// NPU Peripheral
// ============================================================================

namespace npu {
    /// Base addresses
    constexpr uint32_t NPU_HE_BASE = 0x400E1000;

    /// NPU Register structure
    struct Registers {
        volatile uint32_t NPUHE_ID;  ///< Offset: 0x00 - ID Register
        volatile uint32_t NPUHE_STATUS;  ///< Offset: 0x04 - Status Register
        volatile uint32_t NPUHE_CMD;  ///< Offset: 0x08 - Command Register
        volatile uint32_t NPUHE_RESET;  ///< Offset: 0x0C - Reset Register
        volatile uint32_t NPUHE_QBASE0;  ///< Offset: 0x10 - Queue Base Register 0
        volatile uint32_t NPUHE_QBASE1;  ///< Offset: 0x14 - Queue Base Register 1
        volatile uint32_t NPUHE_QREAD;  ///< Offset: 0x18 - Queue Read Register
        volatile uint32_t NPUHE_QCONFIG;  ///< Offset: 0x1C - Queue Configuration Register
        volatile uint32_t NPUHE_QSIZE;  ///< Offset: 0x20 - Queue Size Register
        volatile uint32_t NPUHE_PROT;  ///< Offset: 0x24 - Protection Register
        volatile uint32_t NPUHE_CONFIG;  ///< Offset: 0x28 - Module Configuration Register
        volatile uint32_t NPUHE_LOCK;  ///< Offset: 0x2C - Lock Register
        volatile uint32_t NPUHE_REGIONCFG;  ///< Offset: 0x3C - Region Configuration Register
        volatile uint32_t NPUHE_AXI_LIMIT0;  ///< Offset: 0x40 - AXI Limit Register 0
        volatile uint32_t NPUHE_AXI_LIMIT1;  ///< Offset: 0x44 - AXI Limit Register 1
        volatile uint32_t NPUHE_AXI_LIMIT2;  ///< Offset: 0x48 - AXI Limit Register 2
        volatile uint32_t NPUHE_AXI_LIMIT3;  ///< Offset: 0x4C - AXI Limit Register 3
        volatile uint32_t NPUHE_BASEP0;  ///< Offset: 0x80 - Base Pointer Register 0
        volatile uint32_t NPUHE_BASEP1;  ///< Offset: 0x84 - Base Pointer Register 1
        volatile uint32_t NPUHE_BASEP2;  ///< Offset: 0x88 - Base Pointer Register 2
        volatile uint32_t NPUHE_BASEP3;  ///< Offset: 0x8C - Base Pointer Register 3
        volatile uint32_t NPUHE_BASEP4;  ///< Offset: 0x90 - Base Pointer Register 4
        volatile uint32_t NPUHE_BASEP5;  ///< Offset: 0x94 - Base Pointer Register 5
        volatile uint32_t NPUHE_BASEP6;  ///< Offset: 0x98 - Base Pointer Register 6
        volatile uint32_t NPUHE_BASEP7;  ///< Offset: 0x9C - Base Pointer Register 7
        volatile uint32_t NPUHE_BASEP8;  ///< Offset: 0xA0 - Base Pointer Register 8
        volatile uint32_t NPUHE_BASEP9;  ///< Offset: 0xA4 - Base Pointer Register 9
        volatile uint32_t NPUHE_BASEP10;  ///< Offset: 0xA8 - Base Pointer Register 10
        volatile uint32_t NPUHE_BASEP11;  ///< Offset: 0xAC - Base Pointer Register 11
        volatile uint32_t NPUHE_BASEP12;  ///< Offset: 0xB0 - Base Pointer Register 12
        volatile uint32_t NPUHE_BASEP13;  ///< Offset: 0xB4 - Base Pointer Register 13
        volatile uint32_t NPUHE_BASEP14;  ///< Offset: 0xB8 - Base Pointer Register 14
        volatile uint32_t NPUHE_BASEP15;  ///< Offset: 0xBC - Base Pointer Register 15
        volatile uint32_t NPUHE_PMCR;  ///< Offset: 0x180 - Performance Monitor Control Register
        volatile uint32_t NPUHE_PMCNTENSET;  ///< Offset: 0x184 - Performance Monitor Count Enable Set Register
        volatile uint32_t NPUHE_PMCNTENCLR;  ///< Offset: 0x188 - Performance Monitor Count Enable Clear Register
        volatile uint32_t NPUHE_PMOVSSET;  ///< Offset: 0x18C - Performance Monitor Overflow Status Set Register
        volatile uint32_t NPUHE_PMOVSCLR;  ///< Offset: 0x190 - Performance Monitor Overflow Status Clear Register
        volatile uint32_t NPUHE_PMINTSET;  ///< Offset: 0x194 - Performance Monitor Interrupt Set Register
        volatile uint32_t NPUHE_PMINTCLR;  ///< Offset: 0x198 - Performance Monitor Interrupt Clear Register
        volatile uint32_t NPUHE_PMCCNTR_LO;  ///< Offset: 0x1A0 - Performance Monitor Cycle Count Low Register
        volatile uint32_t NPUHE_PMCCNTR_HI;  ///< Offset: 0x1A4 - Performance Monitor Cycle Count High Register
        volatile uint32_t NPUHE_PMCAXI_CHAN;  ///< Offset: 0x1AC - Performance Monitor AXI Channel Select Register
        volatile uint32_t NPUHE_PMEVCNTR0;  ///< Offset: 0x300 - Performance Monitor Event Count Register 0
        volatile uint32_t NPUHE_PMEVCNTR1;  ///< Offset: 0x304 - Performance Monitor Event Count Register 1
        volatile uint32_t NPUHE_PMEVCNTR2;  ///< Offset: 0x308 - Performance Monitor Event Count Register 2
        volatile uint32_t NPUHE_PMEVCNTR3;  ///< Offset: 0x30C - Performance Monitor Event Count Register 3
        volatile uint32_t NPUHE_PMEVTYPER0;  ///< Offset: 0x380 - Performance Monitor Event Type Register 0
        volatile uint32_t NPUHE_PMEVTYPER1;  ///< Offset: 0x384 - Performance Monitor Event Type Register 1
        volatile uint32_t NPUHE_PMEVTYPER2;  ///< Offset: 0x388 - Performance Monitor Event Type Register 2
        volatile uint32_t NPUHE_PMEVTYPER3;  ///< Offset: 0x38C - Performance Monitor Event Type Register 3
        volatile uint32_t NPUHE_PID4;  ///< Offset: 0xFD0 - Peripheral ID Register 4
        volatile uint32_t NPUHE_PID5;  ///< Offset: 0xFD4 - Peripheral ID Register 5
        volatile uint32_t NPUHE_PID6;  ///< Offset: 0xFD8 - Peripheral ID Register 6
        volatile uint32_t NPUHE_PID7;  ///< Offset: 0xFDC - Peripheral ID Register 7
        volatile uint32_t NPUHE_PID0;  ///< Offset: 0xFE0 - Peripheral ID Register 0
        volatile uint32_t NPUHE_PID1;  ///< Offset: 0xFE4 - Peripheral ID Register 1
        volatile uint32_t NPUHE_PID2;  ///< Offset: 0xFE8 - Peripheral ID Register 2
        volatile uint32_t NPUHE_PID3;  ///< Offset: 0xFEC - Peripheral ID Register 3
        volatile uint32_t NPUHE_CID0;  ///< Offset: 0xFF0 - Component ID Register 0
        volatile uint32_t NPUHE_CID1;  ///< Offset: 0xFF4 - Component ID Register 1
        volatile uint32_t NPUHE_CID2;  ///< Offset: 0xFF8 - Component ID Register 2
        volatile uint32_t NPUHE_CID3;  ///< Offset: 0xFFC - Component ID Register 3
    };

    /// Peripheral instances
    inline Registers* NPU_HE = reinterpret_cast<Registers*>(NPU_HE_BASE);

}

// ============================================================================
// EVTRTR2 Peripheral
// ============================================================================

namespace evtrtr2 {
    /// Base addresses
    constexpr uint32_t EVTRTR2_BASE = 0x400E2000;

    /// EVTRTR2 Register structure
    struct Registers {
        volatile uint32_t DMA_CTRL__;  ///< Offset: 0x00 - DMA/Event Router Control and Status Register (n) (renamed from DMA_CTRL__)
        volatile uint32_t DMA_REQ_CTRL;  ///< Offset: 0x80 - DMA REQ Control Register
        volatile uint32_t DMA_ACK_TYPE0;  ///< Offset: 0x90 - DMA Handshake Type Register 0
        volatile uint32_t DMA_ACK_TYPE1;  ///< Offset: 0x94 - DMA Handshake Type Register 1
        volatile uint32_t DMA_ACK_TYPE2;  ///< Offset: 0x98 - DMA Handshake Type Register 2
        volatile uint32_t DMA_ACK_TYPE3;  ///< Offset: 0x9C - DMA Handshake Type Register 3
    };

    /// Peripheral instances
    inline Registers* EVTRTR2 = reinterpret_cast<Registers*>(EVTRTR2_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_HE_CTRL_BASE = 0x40100000;
    constexpr uint32_t WDT_HE_REFRESH_BASE = 0x40101000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDT_WDOGLOAD;  ///< Offset: 0x00 - Watchdog Load Register
        volatile uint32_t WDT_WDOGVALUE;  ///< Offset: 0x04 - Watchdog Value Register
        volatile uint32_t WDT_WDOGCONTROL;  ///< Offset: 0x08 - Watchdog Control Register
        volatile uint32_t WDT_WDOGINTCLR;  ///< Offset: 0x0C - Watchdog Clear Interrupt Register
        volatile uint32_t WDT_WDOGRIS;  ///< Offset: 0x10 - Watchdog Raw Interrupt Status Register
        volatile uint32_t WDT_WDOGMIS;  ///< Offset: 0x14 - Watchdog Interrupt Status Register
        volatile uint32_t WDT_WDOGLOCK;  ///< Offset: 0xC00 - Watchdog Lock Register
        volatile uint32_t WDT_WDOGPERIPHID4;  ///< Offset: 0xFD0 - Peripheral ID Register 4
        volatile uint32_t WDT_WDOGPERIPHID0;  ///< Offset: 0xFE0 - Peripheral ID Register 0
        volatile uint32_t WDT_WDOGPERIPHID1;  ///< Offset: 0xFE4 - Peripheral ID Register 1
        volatile uint32_t WDT_WDOGPERIPHID2;  ///< Offset: 0xFE8 - Peripheral ID Register 2
        volatile uint32_t WDT_WDOGPERIPHID3;  ///< Offset: 0xFEC - Peripheral ID Register 3
        volatile uint32_t WDT_WDOGPCELLID0;  ///< Offset: 0xFF0 - Component ID Register 0
        volatile uint32_t WDT_WDOGPCELLID1;  ///< Offset: 0xFF4 - Component ID Register 1
        volatile uint32_t WDT_WDOGPCELLID2;  ///< Offset: 0xFF8 - Component ID Register 2
        volatile uint32_t WDT_WDOGPCELLID3;  ///< Offset: 0xFFC - Component ID Register 3
    };

    /// Peripheral instances
    inline Registers* WDT_HE_CTRL = reinterpret_cast<Registers*>(WDT_HE_CTRL_BASE);
    inline Registers* WDT_HE_REFRESH = reinterpret_cast<Registers*>(WDT_HE_REFRESH_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t LPRTC_BASE = 0x42000000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t LPRTC_CCVR;  ///< Offset: 0x00 - Current Counter Value Register
        volatile uint32_t LPRTC_CMR;  ///< Offset: 0x04 - Counter Match Register
        volatile uint32_t LPRTC_CLR;  ///< Offset: 0x08 - Counter Load Register
        volatile uint32_t LPRTC_CCR;  ///< Offset: 0x0C - Counter Control Register
        volatile uint32_t LPRTC_STAT;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t LPRTC_RSTAT;  ///< Offset: 0x14 - Interrupt Raw Status Register
        volatile uint32_t LPRTC_EOI;  ///< Offset: 0x18 - End-of-Interrupt Register
        volatile uint32_t LPRTC_COMP_VERSION;  ///< Offset: 0x1C - LPRTC Component Version Register
        volatile uint32_t LPRTC_CPSR;  ///< Offset: 0x20 - Counter Prescaler Register
        volatile uint32_t LPRTC_CPCVR;  ///< Offset: 0x24 - Current Prescaler Counter Value Register
    };

    /// Peripheral instances
    inline Registers* LPRTC = reinterpret_cast<Registers*>(LPRTC_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIMER_BASE = 0x42001000;
    constexpr uint32_t UTIMER_BASE = 0x48000000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t LPTIMER_LOADCOUNT;  ///< Offset: 0x00 - Timer (n) Load Count Register
        volatile uint32_t LPTIMER_CURRENTVAL;  ///< Offset: 0x04 - Timer (n) Current Value Register
        volatile uint32_t LPTIMER_CONTROLREG;  ///< Offset: 0x08 - Timer (n) Control Register
        volatile uint32_t LPTIMER_EOI;  ///< Offset: 0x0C - Timer (n) End-of-Interrupt Register
        volatile uint32_t LPTIMER_INTSTAT;  ///< Offset: 0x10 - Timer (n) Interrupt Status Register
        volatile uint32_t LPTIMERS_INTSTATUS;  ///< Offset: 0xA0 - Timers Interrupt Status Register
        volatile uint32_t LPTIMERS_EOI;  ///< Offset: 0xA4 - Timers End-of-Interrupt Register
        volatile uint32_t LPTIMERS_RAWINTSTATUS;  ///< Offset: 0xA8 - Timers Raw Interrupt Status Register
        volatile uint32_t LPTIMERS_COMP_VERSION;  ///< Offset: 0xAC - LPTIMER Component Version
    };

    /// Peripheral instances
    inline Registers* LPTIMER = reinterpret_cast<Registers*>(LPTIMER_BASE);
    inline Registers* UTIMER = reinterpret_cast<Registers*>(UTIMER_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t LPGPIO_BASE = 0x42002000;
    constexpr uint32_t LPGPIO_CTRL_BASE = 0x42007000;
    constexpr uint32_t GPIO0_BASE = 0x49000000;
    constexpr uint32_t GPIO1_BASE = 0x49001000;
    constexpr uint32_t GPIO2_BASE = 0x49002000;
    constexpr uint32_t GPIO3_BASE = 0x49003000;
    constexpr uint32_t GPIO4_BASE = 0x49004000;
    constexpr uint32_t GPIO5_BASE = 0x49005000;
    constexpr uint32_t GPIO6_BASE = 0x49006000;
    constexpr uint32_t GPIO7_BASE = 0x49007000;
    constexpr uint32_t GPIO8_BASE = 0x49008000;
    constexpr uint32_t GPIO9_BASE = 0x49009000;
    constexpr uint32_t GPIO10_BASE = 0x4900A000;
    constexpr uint32_t GPIO11_BASE = 0x4900B000;
    constexpr uint32_t GPIO12_BASE = 0x4900C000;
    constexpr uint32_t GPIO13_BASE = 0x4900D000;
    constexpr uint32_t GPIO14_BASE = 0x4900E000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIO_SWPORTA_DR;  ///< Offset: 0x00 - GPIO Port Data Register
        volatile uint32_t GPIO_SWPORTA_DDR;  ///< Offset: 0x04 - GPIO Port Data Direction Register
        volatile uint32_t GPIO_SWPORTA_CTL;  ///< Offset: 0x08 - GPIO Port Data Source Register
        volatile uint32_t GPIO_INTEN;  ///< Offset: 0x30 - GPIO Port Interrupt Enable Register
        volatile uint32_t GPIO_INTMASK;  ///< Offset: 0x34 - GPIO Port Interrupt Mask Register
        volatile uint32_t GPIO_INTTYPE_LEVEL;  ///< Offset: 0x38 - GPIO Port Interrupt Level Register
        volatile uint32_t GPIO_INT_POLARITY;  ///< Offset: 0x3C - GPIO Port Interrupt Polarity Register
        volatile uint32_t GPIO_INTSTATUS;  ///< Offset: 0x40 - GPIO Port Interrupt Status Register
        volatile uint32_t GPIO_RAW_INTSTATUS;  ///< Offset: 0x44 - GPIO Port Raw Interrupt Status Register
        volatile uint32_t GPIO_DEBOUNCE;  ///< Offset: 0x48 - GPIO Port Debounce Enable Register
        volatile uint32_t GPIO_PORTA_EOI;  ///< Offset: 0x4C - GPIO Port End Of Interrupt Register
        volatile uint32_t GPIO_EXT_PORTA;  ///< Offset: 0x50 - GPIO External Port Read Register
        volatile uint32_t GPIO_LS_SYNC;  ///< Offset: 0x60 - Synchronization Level Register
        volatile uint32_t GPIO_INT_BOTHEDGE;  ///< Offset: 0x68 - GPIO Port Interrupt Both Edge Type Register
        volatile uint32_t GPIO_VER_ID_CODE;  ///< Offset: 0x6C - GPIO Version ID Register
        volatile uint32_t GPIO_CONFIG_REG2;  ///< Offset: 0x70 - Module Configuration Register 2
        volatile uint32_t GPIO_CONFIG_REG1;  ///< Offset: 0x74 - Module Configuration Register 1
    };

    /// Peripheral instances
    inline Registers* LPGPIO = reinterpret_cast<Registers*>(LPGPIO_BASE);
    inline Registers* LPGPIO_CTRL = reinterpret_cast<Registers*>(LPGPIO_CTRL_BASE);
    inline Registers* GPIO0 = reinterpret_cast<Registers*>(GPIO0_BASE);
    inline Registers* GPIO1 = reinterpret_cast<Registers*>(GPIO1_BASE);
    inline Registers* GPIO2 = reinterpret_cast<Registers*>(GPIO2_BASE);
    inline Registers* GPIO3 = reinterpret_cast<Registers*>(GPIO3_BASE);
    inline Registers* GPIO4 = reinterpret_cast<Registers*>(GPIO4_BASE);
    inline Registers* GPIO5 = reinterpret_cast<Registers*>(GPIO5_BASE);
    inline Registers* GPIO6 = reinterpret_cast<Registers*>(GPIO6_BASE);
    inline Registers* GPIO7 = reinterpret_cast<Registers*>(GPIO7_BASE);
    inline Registers* GPIO8 = reinterpret_cast<Registers*>(GPIO8_BASE);
    inline Registers* GPIO9 = reinterpret_cast<Registers*>(GPIO9_BASE);
    inline Registers* GPIO10 = reinterpret_cast<Registers*>(GPIO10_BASE);
    inline Registers* GPIO11 = reinterpret_cast<Registers*>(GPIO11_BASE);
    inline Registers* GPIO12 = reinterpret_cast<Registers*>(GPIO12_BASE);
    inline Registers* GPIO13 = reinterpret_cast<Registers*>(GPIO13_BASE);
    inline Registers* GPIO14 = reinterpret_cast<Registers*>(GPIO14_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t LPSPI_BASE = 0x43000000;
    constexpr uint32_t SPI0_BASE = 0x48103000;
    constexpr uint32_t SPI1_BASE = 0x48104000;
    constexpr uint32_t SPI2_BASE = 0x48105000;
    constexpr uint32_t SPI3_BASE = 0x48106000;
    constexpr uint32_t OSPI0_BASE = 0x83000000;
    constexpr uint32_t OSPI1_BASE = 0x83002000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CTRLR0;  ///< Offset: 0x00 - Control Register 0
        volatile uint32_t SPI_CTRLR1;  ///< Offset: 0x04 - Control Register 1
        volatile uint32_t SPI_ENR;  ///< Offset: 0x08 - SPI Enable Register
        volatile uint32_t SPI_MWCR;  ///< Offset: 0x0C - Microwire Control Register
        volatile uint32_t SPI_SER;  ///< Offset: 0x10 - Slave Enable Register
        volatile uint32_t SPI_BAUDR;  ///< Offset: 0x14 - Baud Rate Select Register
        volatile uint32_t SPI_TXFTLR;  ///< Offset: 0x18 - Transmit FIFO Threshold Level Register
        volatile uint32_t SPI_RXFTLR;  ///< Offset: 0x1C - Receive FIFO Threshold Level Register
        volatile uint32_t SPI_TXFLR;  ///< Offset: 0x20 - Transmit FIFO Level Register
        volatile uint32_t SPI_RXFLR;  ///< Offset: 0x24 - Receive FIFO Level Register
        volatile uint32_t SPI_SR;  ///< Offset: 0x28 - Status Register
        volatile uint32_t SPI_IMR;  ///< Offset: 0x2C - Interrupt Mask Register
        volatile uint32_t SPI_ISR;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t SPI_RISR;  ///< Offset: 0x34 - Raw Interrupt Status Register
        volatile uint32_t SPI_TXOICR;  ///< Offset: 0x38 - Transmit FIFO Overflow Interrupt Clear Register
        volatile uint32_t SPI_RXOICR;  ///< Offset: 0x3C - Receive FIFO Overflow Interrupt Clear Register
        volatile uint32_t SPI_RXUICR;  ///< Offset: 0x40 - Receive FIFO Underflow Interrupt Clear Register
        volatile uint32_t SPI_MSTICR;  ///< Offset: 0x44 - Multi-Master Interrupt Clear Register
        volatile uint32_t SPI_ICR;  ///< Offset: 0x48 - Interrupt Clear Register
        volatile uint32_t SPI_DMACR;  ///< Offset: 0x4C - DMA Control Register
        volatile uint32_t SPI_DMATDLR;  ///< Offset: 0x50 - DMA Transmit Data Level Register
        volatile uint32_t SPI_DMARDLR;  ///< Offset: 0x54 - DMA Receive Data Level Register
        volatile uint32_t SPI_IDR;  ///< Offset: 0x58 - Reserved
        volatile uint32_t SPI_VERSION_ID;  ///< Offset: 0x5C - Reserved
        volatile uint32_t SPI_DR__;  ///< Offset: 0x60 - SPI Data Register (n) (renamed from SPI_DR__)
        volatile uint32_t SPI_RX_SAMPLE_DELAY;  ///< Offset: 0xF0 - RX Sample Delay Register
    };

    /// Peripheral instances
    inline Registers* LPSPI = reinterpret_cast<Registers*>(LPSPI_BASE);
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* OSPI0 = reinterpret_cast<Registers*>(OSPI0_BASE);
    inline Registers* OSPI1 = reinterpret_cast<Registers*>(OSPI1_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t LPI2S_BASE = 0x43001000;
    constexpr uint32_t I2S0_BASE = 0x49014000;
    constexpr uint32_t I2S1_BASE = 0x49015000;
    constexpr uint32_t I2S2_BASE = 0x49016000;
    constexpr uint32_t I2S3_BASE = 0x49017000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t I2S_IER;  ///< Offset: 0x00 - I2S Enable Register
        volatile uint32_t I2S_IRER;  ///< Offset: 0x04 - I2S Receiver Block Enable Register
        volatile uint32_t I2S_ITER;  ///< Offset: 0x08 - I2S Transmitter Block Enable Register
        volatile uint32_t I2S_CER;  ///< Offset: 0x0C - Clock Enable Register
        volatile uint32_t I2S_CCR;  ///< Offset: 0x10 - Clock Configuration Register
        volatile uint32_t I2S_RXFFR;  ///< Offset: 0x14 - Receiver Block FIFO Reset Register
        volatile uint32_t I2S_TXFFR;  ///< Offset: 0x18 - Transmitter Block FIFO Reset Register
        volatile uint32_t I2S_LRBR0;  ///< Offset: 0x20 - Left Receive Buffer Register 0
        volatile uint32_t I2S_LTHR0;  ///< Offset: 0x20 - Left Transmit Holding Register 0
        volatile uint32_t I2S_RRBR0;  ///< Offset: 0x24 - Right Transmit Holding Register 0
        volatile uint32_t I2S_RTHR0;  ///< Offset: 0x24 - Specifies the Right Transmit Holding Register
        volatile uint32_t I2S_RER0;  ///< Offset: 0x28 - Receive Enable Register 0
        volatile uint32_t I2S_TER0;  ///< Offset: 0x2C - Transmit Enable Register 0
        volatile uint32_t I2S_RCR0;  ///< Offset: 0x30 - Receive Configuration Register 0
        volatile uint32_t I2S_TCR0;  ///< Offset: 0x34 - Transmit Configuration Register 0
        volatile uint32_t I2S_ISR0;  ///< Offset: 0x38 - Interrupt Status Register 0
        volatile uint32_t I2S_IMR0;  ///< Offset: 0x3C - Interrupt Mask Register 0
        volatile uint32_t I2S_ROR0;  ///< Offset: 0x40 - Receive Overrun Register 0
        volatile uint32_t I2S_TOR0;  ///< Offset: 0x44 - Transmit Overrun Register 0
        volatile uint32_t I2S_RFCR0;  ///< Offset: 0x48 - Receive FIFO Configuration Register 0
        volatile uint32_t I2S_TFCR0;  ///< Offset: 0x4C - Transmit FIFO Configuration Register 0
        volatile uint32_t I2S_RFF0;  ///< Offset: 0x50 - Receive FIFO Flush Register 0
        volatile uint32_t I2S_TFF0;  ///< Offset: 0x54 - Transmit FIFO Flush Register 0
        volatile uint32_t I2S_RXDMA;  ///< Offset: 0x1C0 - Receiver Block DMA Register
        volatile uint32_t I2S_TXDMA;  ///< Offset: 0x1C8 - Transmitter Block DMA Register
        volatile uint32_t I2S_COMP_PARAM_2;  ///< Offset: 0x1F0 - Module Configuration Register 2
        volatile uint32_t I2S_COMP_PARAM_1;  ///< Offset: 0x1F4 - Module Configuration Register 1
        volatile uint32_t I2S_COMP_VERSION;  ///< Offset: 0x1F8 - Component Parameter Register
        volatile uint32_t I2S_COMP_TYPE;  ///< Offset: 0x1FC - Component Type Register
        volatile uint32_t I2S_DMACR;  ///< Offset: 0x200 - DMA Control Register
    };

    /// Peripheral instances
    inline Registers* LPI2S = reinterpret_cast<Registers*>(LPI2S_BASE);
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);
    inline Registers* I2S2 = reinterpret_cast<Registers*>(I2S2_BASE);
    inline Registers* I2S3 = reinterpret_cast<Registers*>(I2S3_BASE);

}

// ============================================================================
// LPPDM Peripheral
// ============================================================================

namespace lppdm {
    /// Base addresses
    constexpr uint32_t LPPDM_BASE = 0x43002000;

    /// LPPDM Register structure
    struct Registers {
        volatile uint32_t PDM_CTL0;  ///< Offset: 0x00 - PDM Audio Control Register 0
        volatile uint32_t PDM_CTL1;  ///< Offset: 0x04 - PDM Audio Control Register 1
        volatile uint32_t PDM_FIFO_WATERMARK_H;  ///< Offset: 0x08 - FIFO Watermark Register
        volatile uint32_t PDM_FIFO_STAT;  ///< Offset: 0x0C - FIFO Status Register
        volatile uint32_t PDM_ERROR_IRQ;  ///< Offset: 0x10 - FIFO Error Interrupt Status Register
        volatile uint32_t PDM_WARN_IRQ;  ///< Offset: 0x14 - FIFO Warning Interrupt Status Register
        volatile uint32_t PDM_AUDIO_DETECT_IRQ;  ///< Offset: 0x18 - Audio Detection Interrupt Status Register
        volatile uint32_t PDM_IRQ_ENABLE;  ///< Offset: 0x1C - Interrupt Enable Register
        volatile uint32_t PDM_CH0_CH1_AUDIO_OUT;  ///< Offset: 0x20 - Channels 0 and 1 Audio Output Register
        volatile uint32_t PDM_CH2_CH3_AUDIO_OUT;  ///< Offset: 0x24 - Channels 2 and 3 Audio Output Register
        volatile uint32_t PDM_CH4_CH5_AUDIO_OUT;  ///< Offset: 0x28 - Channels 4 and 5 Audio Output Register
        volatile uint32_t PDM_CH6_CH7_AUDIO_OUT;  ///< Offset: 0x2C - Channels 6 and 7 Audio Output Register
        volatile uint32_t PDM_CH_FIR_COEF_0;  ///< Offset: 0x00 - Channel (n) FIR Filter Coefficient 0 Register
        volatile uint32_t PDM_CH_FIR_COEF_1;  ///< Offset: 0x04 - Channel (n) FIR Filter Coefficient 1 Register
        volatile uint32_t PDM_CH_FIR_COEF_2;  ///< Offset: 0x08 - Channel (n) FIR Filter Coefficient 2 Register
        volatile uint32_t PDM_CH_FIR_COEF_3;  ///< Offset: 0x0C - Channel (n) FIR Filter Coefficient 3 Register
        volatile uint32_t PDM_CH_FIR_COEF_4;  ///< Offset: 0x10 - Channel (n) FIR Filter Coefficient 4 Register
        volatile uint32_t PDM_CH_FIR_COEF_5;  ///< Offset: 0x14 - Channel (n) FIR Filter Coefficient 5 Register
        volatile uint32_t PDM_CH_FIR_COEF_6;  ///< Offset: 0x18 - Channel (n) FIR Filter Coefficient 6 Register
        volatile uint32_t PDM_CH_FIR_COEF_7;  ///< Offset: 0x1C - Channel (n) FIR Filter Coefficient 7 Register
        volatile uint32_t PDM_CH_FIR_COEF_8;  ///< Offset: 0x20 - Channel (n) FIR Filter Coefficient 8 Register
        volatile uint32_t PDM_CH_FIR_COEF_9;  ///< Offset: 0x24 - Channel (n) FIR Filter Coefficient 9 Register
        volatile uint32_t PDM_CH_FIR_COEF_10;  ///< Offset: 0x28 - Channel (n) FIR Filter Coefficient 10 Register
        volatile uint32_t PDM_CH_FIR_COEF_11;  ///< Offset: 0x2C - Channel (n) FIR Filter Coefficient 11 Register
        volatile uint32_t PDM_CH_FIR_COEF_12;  ///< Offset: 0x30 - Channel (n) FIR Filter Coefficient 12 Register
        volatile uint32_t PDM_CH_FIR_COEF_13;  ///< Offset: 0x34 - Channel (n) FIR Filter Coefficient 13 Register
        volatile uint32_t PDM_CH_FIR_COEF_14;  ///< Offset: 0x38 - Channel (n) FIR Filter Coefficient 14 Register
        volatile uint32_t PDM_CH_FIR_COEF_15;  ///< Offset: 0x3C - Channel (n) FIR Filter Coefficient 15 Register
        volatile uint32_t PDM_CH_FIR_COEF_16;  ///< Offset: 0x40 - Channel (n) FIR Filter Coefficient 16 Register
        volatile uint32_t PDM_CH_FIR_COEF_17;  ///< Offset: 0x44 - Channel (n) FIR Filter Coefficient 17 Register
        volatile uint32_t PDM_CH_IIR_COEF_SEL;  ///< Offset: 0x80 - Channel (n) IIR Filter Coefficient Selection Register
        volatile uint32_t PDM_CH_PHASE;  ///< Offset: 0x84 - Channel (n) Phase Control Register
        volatile uint32_t PDM_CH_GAIN;  ///< Offset: 0x88 - Channel (n) Gain Control Register
        volatile uint32_t PDM_CH_PKDET_TH;  ///< Offset: 0x8C - Channel (n) Peak Detector Threshold Register
        volatile uint32_t PDM_CH_PKDET_ITV;  ///< Offset: 0x90 - Channel (n) Peak Detector Interval Register
        volatile uint32_t PDM_CH_PKDET_STAT;  ///< Offset: 0x94 - Channel (n) Peak Detector Status Register
    };

    /// Peripheral instances
    inline Registers* LPPDM = reinterpret_cast<Registers*>(LPPDM_BASE);

}

// ============================================================================
// LPCPI Peripheral
// ============================================================================

namespace lpcpi {
    /// Base addresses
    constexpr uint32_t LPCPI_BASE = 0x43003000;

    /// LPCPI Register structure
    struct Registers {
        volatile uint32_t CAM_CTRL;  ///< Offset: 0x00 - Camera Control Register
        volatile uint32_t CAM_INTR;  ///< Offset: 0x04 - Camera Interrupt Status Register
        volatile uint32_t CAM_INTR_ENA;  ///< Offset: 0x08 - Camera Interrupt Enable Register
        volatile uint32_t CAM_CFG;  ///< Offset: 0x10 - Camera Configuration Register
        volatile uint32_t CAM_FIFO_CTRL;  ///< Offset: 0x14 - Camera FIFO Control Register
        volatile uint32_t CAM_AXI_ERR_STAT;  ///< Offset: 0x18 - Camera AXI Error Status Register
        volatile uint32_t CAM_VIDEO_FCFG;  ///< Offset: 0x28 - Camera Video Frame Configuration Register
        volatile uint32_t CAM_CSI_CMCFG;  ///< Offset: 0x2C - Camera MIPI CSI Color Mode Configuration Register
        volatile uint32_t CAM_FRAME_ADDR;  ///< Offset: 0x30 - Camera Video Frame Start Address Register
    };

    /// Peripheral instances
    inline Registers* LPCPI = reinterpret_cast<Registers*>(LPCPI_BASE);

}

// ============================================================================
// M55HE Peripheral
// ============================================================================

namespace m55he {
    /// Base addresses
    constexpr uint32_t M55HE_CFG_BASE = 0x43007000;
    constexpr uint32_t M55HE_NVIC_S_BASE = 0xE000E100;
    constexpr uint32_t M55HE_NVIC_NS_BASE = 0xE002E100;

    /// M55HE Register structure
    struct Registers {
        volatile uint32_t HE_DMA_CTRL;  ///< Offset: 0x00 - DMA2 Boot Control Register
        volatile uint32_t HE_DMA_IRQ;  ///< Offset: 0x04 - DMA2 Boot IRQ Non-Secure Register
        volatile uint32_t HE_DMA_PERIPH;  ///< Offset: 0x08 - DMA2 Boot Peripheral Non-Secure Register
        volatile uint32_t HE_DMA_SEL;  ///< Offset: 0x0C - DMA2 Select Register
        volatile uint32_t HE_CLK_ENA;  ///< Offset: 0x10 - Peripheral Clock Enable Register
        volatile uint32_t HE_I2S_CTRL;  ///< Offset: 0x14 - LPI2S Control Register
        volatile uint32_t HE_CAMERA_PIXCLK;  ///< Offset: 0x20 - LPCPI Pixel Clock Control Register
    };

    /// Peripheral instances
    inline Registers* M55HE_CFG = reinterpret_cast<Registers*>(M55HE_CFG_BASE);
    inline Registers* M55HE_NVIC_S = reinterpret_cast<Registers*>(M55HE_NVIC_S_BASE);
    inline Registers* M55HE_NVIC_NS = reinterpret_cast<Registers*>(M55HE_NVIC_NS_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART_BASE = 0x43008000;
    constexpr uint32_t UART0_BASE = 0x49018000;
    constexpr uint32_t UART1_BASE = 0x49019000;
    constexpr uint32_t UART2_BASE = 0x4901A000;
    constexpr uint32_t UART3_BASE = 0x4901B000;
    constexpr uint32_t UART4_BASE = 0x4901C000;
    constexpr uint32_t UART5_BASE = 0x4901D000;
    constexpr uint32_t UART6_BASE = 0x4901E000;
    constexpr uint32_t UART7_BASE = 0x4901F000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t UART_RBR;  ///< Offset: 0x00 - Receive Buffer Register
        volatile uint32_t UART_DLL;  ///< Offset: 0x00 - Divisor Latch Low Register
        volatile uint32_t UART_THR;  ///< Offset: 0x00 - Transmit Holding Register
        volatile uint32_t UART_DLH;  ///< Offset: 0x04 - Divisor Latch High Register
        volatile uint32_t UART_IER;  ///< Offset: 0x04 - Interrupt Enable Register
        volatile uint32_t UART_FCR;  ///< Offset: 0x08 - FIFO Control Register
        volatile uint32_t UART_IIR;  ///< Offset: 0x08 - Interrupt Identification Register
        volatile uint32_t UART_LCR;  ///< Offset: 0x0C - Line Control Register
        volatile uint32_t UART_MCR;  ///< Offset: 0x10 - Modem Control Register
        volatile uint32_t UART_LSR;  ///< Offset: 0x14 - Line Status Register
        volatile uint32_t UART_MSR;  ///< Offset: 0x18 - Modem Status Register
        volatile uint32_t UART_SCR;  ///< Offset: 0x1C - Scratchpad Register
        volatile uint32_t UART_SRBR__;  ///< Offset: 0x30 - Shadow Receive Buffer Register (n) (renamed from UART_SRBR__)
        volatile uint32_t UART_STHR__;  ///< Offset: 0x30 - Shadow Transmit Holding Register (n) (renamed from UART_STHR__)
        volatile uint32_t UART_FAR;  ///< Offset: 0x70 - FIFO Access Register
        volatile uint32_t UART_TFR;  ///< Offset: 0x74 - Tx FIFO Read Register
        volatile uint32_t UART_RFW;  ///< Offset: 0x78 - Rx FIFO Write Register
        volatile uint32_t UART_USR;  ///< Offset: 0x7C - UART Status Register
        volatile uint32_t UART_TFL;  ///< Offset: 0x80 - Tx FIFO Level Register
        volatile uint32_t UART_RFL;  ///< Offset: 0x84 - Rx FIFO Level Register
        volatile uint32_t UART_SRR;  ///< Offset: 0x88 - Software Reset Register
        volatile uint32_t UART_SRTS;  ///< Offset: 0x8C - Shadow Request to Send Register
        volatile uint32_t UART_SBCR;  ///< Offset: 0x90 - Shadow Break Control Register
        volatile uint32_t UART_SDMAM;  ///< Offset: 0x94 - Shadow DMA Mode Register
        volatile uint32_t UART_SFE;  ///< Offset: 0x98 - Shadow FIFO Enable Register
        volatile uint32_t UART_SRT;  ///< Offset: 0x9C - Shadow RCVR Trigger Register
        volatile uint32_t UART_STET;  ///< Offset: 0xA0 - Shadow Tx Empty Trigger Register
        volatile uint32_t UART_HTX;  ///< Offset: 0xA4 - Halt Tx Register
        volatile uint32_t UART_DMASA;  ///< Offset: 0xA8 - DMA Software Acknowledge Register
        volatile uint32_t UART_TCR;  ///< Offset: 0xAC - Transceiver Control Register
        volatile uint32_t UART_DE_EN;  ///< Offset: 0xB0 - Driver Output Enable Register
        volatile uint32_t UART_RE_EN;  ///< Offset: 0xB4 - Receiver Output Enable Register
        volatile uint32_t UART_DET;  ///< Offset: 0xB8 - Driver Output Enable Timing Register
        volatile uint32_t UART_TAT;  ///< Offset: 0xBC - Turnaround Timing Register
        volatile uint32_t UART_DLF;  ///< Offset: 0xC0 - Divisor Latch Fraction Register
        volatile uint32_t UART_RAR;  ///< Offset: 0xC4 - Receive Address Register
        volatile uint32_t UART_TAR;  ///< Offset: 0xC8 - Transmit Address Register
        volatile uint32_t UART_LCR_EXT;  ///< Offset: 0xCC - Line Extended Control Register
        volatile uint32_t UART_REG_TIMEOUT_RST;  ///< Offset: 0xD4 - Timeout Counter Reset Value Register
        volatile uint32_t UART_CPR;  ///< Offset: 0xF4 - Module Configuration Register
        volatile uint32_t UART_UCV;  ///< Offset: 0xF8 - Reserved
        volatile uint32_t UART_CTR;  ///< Offset: 0xFC - Reserved
    };

    /// Peripheral instances
    inline Registers* LPUART = reinterpret_cast<Registers*>(LPUART_BASE);
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* UART6 = reinterpret_cast<Registers*>(UART6_BASE);
    inline Registers* UART7 = reinterpret_cast<Registers*>(UART7_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C_BASE = 0x43009000;
    constexpr uint32_t I2C0_BASE = 0x49010000;
    constexpr uint32_t I2C1_BASE = 0x49011000;
    constexpr uint32_t I2C2_BASE = 0x49012000;
    constexpr uint32_t I2C3_BASE = 0x49013000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t LPI2C_READWRITE_DATA;  ///< Offset: 0x00 - Read/Write Data Register
        volatile uint32_t LPI2C_INFIFO_STATUS;  ///< Offset: 0x10 - Inbound FIFO Status Register
        volatile uint32_t LPI2C_OUTFIFO_STATUS;  ///< Offset: 0x20 - Outbound FIFO Status Register
    };

    /// Peripheral instances
    inline Registers* LPI2C = reinterpret_cast<Registers*>(LPI2C_BASE);
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t ETH_BASE = 0x48100000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t ETH_MAC_CONFIGURATION;  ///< Offset: 0x00 - MAC Configuration Register
        volatile uint32_t ETH_MAC_EXT_CONFIGURATION;  ///< Offset: 0x04 - MAC Extended Configuration Register
        volatile uint32_t ETH_MAC_PACKET_FILTER;  ///< Offset: 0x08 - MAC Packet Filter Register
        volatile uint32_t ETH_MAC_WATCHDOG_TIMEOUT;  ///< Offset: 0x0C - Watchdog Timeout Register
        volatile uint32_t ETH_MAC_VLAN_TAG;  ///< Offset: 0x50 - VLAN Tag Register
        volatile uint32_t ETH_MAC_Q0_TX_FLOW_CTRL;  ///< Offset: 0x70 - Flow Control Register
        volatile uint32_t ETH_MAC_RX_FLOW_CTRL;  ///< Offset: 0x90 - Receive Flow Control Register
        volatile uint32_t ETH_MAC_INTERRUPT_STATUS;  ///< Offset: 0xB0 - Interrupt Status Register
        volatile uint32_t ETH_MAC_INTERRUPT_ENABLE;  ///< Offset: 0xB4 - Interrupt Enable Register
        volatile uint32_t ETH_MAC_RX_TX_STATUS;  ///< Offset: 0xB8 - Receive Transmit Status Register
        volatile uint32_t ETH_MAC_PMT_CONTROL_STATUS;  ///< Offset: 0xC0 - PMT Control and Status Register
        volatile uint32_t ETH_RWK_FILTER_BYTE_MASK;  ///< Offset: 0xC4 - Remote Wakeup Filter Byte Mask Register
        volatile uint32_t ETH_RWK_FILTER_COMMAND;  ///< Offset: 0xC4 - Remote Wakeup Filter Command Register
        volatile uint32_t ETH_RWK_FILTER_OFFSET;  ///< Offset: 0xC4 - Remote Wakeup Filter Offset Register
        volatile uint32_t ETH_RWK_FILTER_CRC;  ///< Offset: 0xC4 - Remote Wakeup Filter CRC-16 Register
        volatile uint32_t ETH_MAC_VERSION;  ///< Offset: 0x110 - Module Version Register
        volatile uint32_t ETH_MAC_DEBUG;  ///< Offset: 0x114 - Debug Register
        volatile uint32_t ETH_MAC_HW_FEATURE0;  ///< Offset: 0x11C - ETH Hardware Feature Register 0
        volatile uint32_t ETH_MAC_HW_FEATURE1;  ///< Offset: 0x120 - ETH Hardware Feature Register 1
        volatile uint32_t ETH_MAC_HW_FEATURE2;  ///< Offset: 0x124 - ETH Hardware Feature Register 2
        volatile uint32_t ETH_MAC_HW_FEATURE3;  ///< Offset: 0x128 - ETH Hardware Feature Register 3
        volatile uint32_t ETH_MAC_MDIO_ADDRESS;  ///< Offset: 0x200 - MDIO Address Register
        volatile uint32_t ETH_MAC_MDIO_DATA;  ///< Offset: 0x204 - MDIO Data Register
        volatile uint32_t ETH_MAC_ARP_ADDRESS;  ///< Offset: 0x210 - ARP Address Register
        volatile uint32_t ETH_MAC_CSR_SW_CTRL;  ///< Offset: 0x230 - CSR Software Control Register
        volatile uint32_t ETH_MAC_ADDRESS0_HIGH;  ///< Offset: 0x300 - MAC Address 0 High Register
        volatile uint32_t ETH_MAC_ADDRESS0_LOW;  ///< Offset: 0x304 - MAC Address 0 Low Register
        volatile uint32_t ETH_MAC_TIMESTAMP_CONTROL;  ///< Offset: 0xB00 - Timestamp Control Register
        volatile uint32_t ETH_MAC_SUB_SECOND_INCREMENT;  ///< Offset: 0xB04 - Sub-second Increment Register
        volatile uint32_t ETH_MAC_SYSTEM_TIME_SECONDS;  ///< Offset: 0xB08 - System Time Seconds Register
        volatile uint32_t ETH_MAC_SYSTEM_TIME_NANOSECONDS;  ///< Offset: 0xB0C - System Time Nanoseconds Register
        volatile uint32_t ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE;  ///< Offset: 0xB10 - System Time Seconds Update Register
        volatile uint32_t ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE;  ///< Offset: 0xB14 - System Time Nanoseconds Update Register
        volatile uint32_t ETH_MAC_TIMESTAMP_ADDEND;  ///< Offset: 0xB18 - Timestamp Addend Register
        volatile uint32_t ETH_MAC_TIMESTAMP_STATUS;  ///< Offset: 0xB20 - Timestamp Status Register
        volatile uint32_t ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS;  ///< Offset: 0xB30 - Transmit Timestamp Status Nanoseconds Register
        volatile uint32_t ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS;  ///< Offset: 0xB34 - Transmit Timestamp Status Seconds Register
        volatile uint32_t ETH_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND;  ///< Offset: 0xB58 - Timestamp Ingress Correction Nanoseconds Register
        volatile uint32_t ETH_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND;  ///< Offset: 0xB5C - Timestamp Egress Correction Nanoseconds Register
        volatile uint32_t ETH_MAC_TIMESTAMP_INGRESS_LATENCY;  ///< Offset: 0xB68 - Ingress MAC latency Register
        volatile uint32_t ETH_MAC_TIMESTAMP_EGRESS_LATENCY;  ///< Offset: 0xB6C - Egress MAC latency Register
        volatile uint32_t ETH_MAC_PPS_CONTROL;  ///< Offset: 0xB70 - PPS Control Register
        volatile uint32_t ETH_MAC_PPS0_TARGET_TIME_SECONDS;  ///< Offset: 0xB80 - PPS0 Target Time Seconds Register
        volatile uint32_t ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS;  ///< Offset: 0xB84 - PPS0 Target Time Nanoseconds Register
        volatile uint32_t ETH_MTL_OPERATION_MODE;  ///< Offset: 0xC00 - Operation Mode Register
        volatile uint32_t ETH_MTL_DBG_CTL;  ///< Offset: 0xC08 - FIFO Debug Access Control and Status Register
        volatile uint32_t ETH_MTL_DBG_STS;  ///< Offset: 0xC0C - FIFO Debug Status Register
        volatile uint32_t ETH_MTL_FIFO_DEBUG_DATA;  ///< Offset: 0xC10 - FIFO Debug Data Register
        volatile uint32_t ETH_MTL_INTERRUPT_STATUS;  ///< Offset: 0xC20 - MTL Interrupt Status Register
        volatile uint32_t ETH_MTL_TXQ0_OPERATION_MODE;  ///< Offset: 0xD00 - Queue 0 Transmit Operation Mode Register
        volatile uint32_t ETH_MTL_TXQ0_UNDERFLOW;  ///< Offset: 0xD04 - Queue 0 Underflow Counter Register
        volatile uint32_t ETH_MTL_TXQ0_DEBUG;  ///< Offset: 0xD08 - Queue 0 Transmit Debug Register
        volatile uint32_t ETH_MTL_Q0_INTERRUPT_CONTROL_STATUS;  ///< Offset: 0xD2C - Queue 0 Interrupt Enable and Status Register
        volatile uint32_t ETH_MTL_RXQ0_OPERATION_MODE;  ///< Offset: 0xD30 - Queue 0 Receive Operation Mode Register
        volatile uint32_t ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT;  ///< Offset: 0xD34 - Queue 0 Missed Packet and Overflow Counter Register
        volatile uint32_t ETH_MTL_RXQ0_DEBUG;  ///< Offset: 0xD38 - Queue 0 Receive Debug Register
        volatile uint32_t ETH_DMA_MODE;  ///< Offset: 0x1000 - Bus Mode Register
        volatile uint32_t ETH_DMA_SYSBUS_MODE;  ///< Offset: 0x1004 - System Bus Mode Register
        volatile uint32_t ETH_DMA_INTERRUPT_STATUS;  ///< Offset: 0x1008 - DMA, MTL, and MAC Interrupt Status Register
        volatile uint32_t ETH_DMA_DEBUG_STATUS0;  ///< Offset: 0x100C - Debug Status 0 Register
        volatile uint32_t ETH_AXI_LPI_ENTRY_INTERVAL;  ///< Offset: 0x1040 - AXI LPI Entry Interval Register
        volatile uint32_t ETH_DMA_CH0_CONTROL;  ///< Offset: 0x1100 - DMA Channel 0 Control Register
        volatile uint32_t ETH_DMA_CH0_TX_CONTROL;  ///< Offset: 0x1104 - DMA Channel 0 Transmit Control Register
        volatile uint32_t ETH_DMA_CH0_RX_CONTROL;  ///< Offset: 0x1108 - DMA Channel 0 Receive Control Register
        volatile uint32_t ETH_DMA_CH0_TXDESC_LIST_ADDRESS;  ///< Offset: 0x1114 - DMA Channel 0 Transmit Descriptor List Address Register
        volatile uint32_t ETH_DMA_CH0_RXDESC_LIST_ADDRESS;  ///< Offset: 0x111C - DMA Channel 0 Receive Descriptor List Address Register
        volatile uint32_t ETH_DMA_CH0_TXDESC_TAIL_POINTER;  ///< Offset: 0x1120 - DMA Channel 0 Transmit Descriptor Tail Pointer Register
        volatile uint32_t ETH_DMA_CH0_RXDESC_TAIL_POINTER;  ///< Offset: 0x1128 - DMA Channel 0 Receive Descriptor Tail Pointer Register
        volatile uint32_t ETH_DMA_CH0_TXDESC_RING_LENGTH;  ///< Offset: 0x112C - DMA Channel 0 Transmit Descriptor Ring Length Register
        volatile uint32_t ETH_DMA_CH0_RXDESC_RING_LENGTH;  ///< Offset: 0x1130 - DMA Channel 0 Receive Descriptor Ring Length Register
        volatile uint32_t ETH_DMA_CH0_INTERRUPT_ENABLE;  ///< Offset: 0x1134 - DMA Channel 0 Interrupt Enable Register
        volatile uint32_t ETH_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER;  ///< Offset: 0x1138 - DMA Channel 0 Receive Interrupt Watchdog Timer Register
        volatile uint32_t ETH_DMA_CH0_CURRENT_APP_TXDESC;  ///< Offset: 0x1144 - DMA Channel 0 Current Application Transmit Descriptor Register
        volatile uint32_t ETH_DMA_CH0_CURRENT_APP_RXDESC;  ///< Offset: 0x114C - DMA Channel 0 Current Application Receive Descriptor Register
        volatile uint32_t ETH_DMA_CH0_CURRENT_APP_TXBUFFER;  ///< Offset: 0x1154 - DMA Channel 0 Current Application Transmit Buffer...
        volatile uint32_t ETH_DMA_CH0_CURRENT_APP_RXBUFFER;  ///< Offset: 0x115C - DMA Channel 0 Current Application Receive Buffer Address Register
        volatile uint32_t ETH_DMA_CH0_STATUS;  ///< Offset: 0x1160 - DMA Channel 0 Status Register
        volatile uint32_t ETH_DMA_CH0_MISS_FRAME_CNT;  ///< Offset: 0x1164 - DMA Channel 0 Dropped Packet Counter Register
        volatile uint32_t ETH_DMA_CH0_RX_ERI_CNT;  ///< Offset: 0x1168 - DMA Channel 0 Receive ERI Counter Register
    };

    /// Peripheral instances
    inline Registers* ETH = reinterpret_cast<Registers*>(ETH_BASE);

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC_BASE = 0x48102000;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t SDMMC_SDMASA_R;  ///< Offset: 0x00 - SDMA System Address Register
        volatile uint32_t SDMMC_BLOCKSIZE_R;  ///< Offset: 0x04 - Block Size Register
        volatile uint32_t SDMMC_BLOCKCOUNT_R;  ///< Offset: 0x06 - 16-bit Block Count Register
        volatile uint32_t SDMMC_ARGUMENT_R;  ///< Offset: 0x08 - Argument Register
        volatile uint32_t SDMMC_XFER_MODE_R;  ///< Offset: 0x0C - Transfer Mode Register
        volatile uint32_t SDMMC_CMD_R;  ///< Offset: 0x0E - Command Register
        volatile uint32_t SDMMC_RESP01_R;  ///< Offset: 0x10 - Response Register 0/1
        volatile uint32_t SDMMC_RESP23_R;  ///< Offset: 0x14 - Response Register 2/3
        volatile uint32_t SDMMC_RESP45_R;  ///< Offset: 0x18 - Response Register 4/5
        volatile uint32_t SDMMC_RESP67_R;  ///< Offset: 0x1C - Response Register 6/7
        volatile uint32_t SDMMC_BUF_DATA_R;  ///< Offset: 0x20 - Buffer Data Port Register
        volatile uint32_t SDMMC_PSTATE_REG;  ///< Offset: 0x24 - Present State Register
        volatile uint32_t SDMMC_HOST_CTRL1_R;  ///< Offset: 0x28 - Host Control 1 Register
        volatile uint32_t SDMMC_PWR_CTRL_R;  ///< Offset: 0x29 - Power Control Register
        volatile uint32_t SDMMC_BGAP_CTRL_R;  ///< Offset: 0x2A - Block Gap Control Register
        volatile uint32_t SDMMC_WUP_CTRL_R;  ///< Offset: 0x2B - Wakeup Control Register
        volatile uint32_t SDMMC_CLK_CTRL_R;  ///< Offset: 0x2C - Clock Control Register
        volatile uint32_t SDMMC_TOUT_CTRL_R;  ///< Offset: 0x2E - Timeout Control Register
        volatile uint32_t SDMMC_SW_RST_R;  ///< Offset: 0x2F - Software Reset Register
        volatile uint32_t SDMMC_NORMAL_INT_STAT_R;  ///< Offset: 0x30 - Normal Interrupt Status Register
        volatile uint32_t SDMMC_ERROR_INT_STAT_R;  ///< Offset: 0x32 - Error Interrupt Status Register
        volatile uint32_t SDMMC_NORMAL_INT_STAT_EN_R;  ///< Offset: 0x34 - Normal Interrupt Status Enable Register
        volatile uint32_t SDMMC_ERROR_INT_STAT_EN_R;  ///< Offset: 0x36 - Error Interrupt Status Enable Register
        volatile uint32_t SDMMC_NORMAL_INT_SIGNAL_EN_R;  ///< Offset: 0x38 - Normal Interrupt Signal Enable Register
        volatile uint32_t SDMMC_ERROR_INT_SIGNAL_EN_R;  ///< Offset: 0x3A - Error Interrupt Signal Enable Register
        volatile uint32_t SDMMC_AUTO_CMD_STAT_R;  ///< Offset: 0x3C - Auto CMD Status Register
        volatile uint32_t SDMMC_HOST_CTRL2_R;  ///< Offset: 0x3E - Host Control 2 Register
        volatile uint32_t SDMMC_CAPABILITIES1_R;  ///< Offset: 0x40 - Capabilities 1 Register (0 to 31)
        volatile uint32_t SDMMC_CAPABILITIES2_R;  ///< Offset: 0x44 - Capabilities 2 Register (32 to 63)
        volatile uint32_t SDMMC_CURR_CAPABILITIES1_R;  ///< Offset: 0x48 - Maximum Current Capabilities 1 Register (0 to 31)
        volatile uint32_t SDMMC_FORCE_AUTO_CMD_STAT_R;  ///< Offset: 0x50 - Force Event Register for Auto CMD Error Status
        volatile uint32_t SDMMC_FORCE_ERROR_INT_STAT_R;  ///< Offset: 0x52 - Force Event Register for Error Interrupt Status
        volatile uint32_t SDMMC_ADMA_ERR_STAT_R;  ///< Offset: 0x54 - ADMA Error Status Register
        volatile uint32_t SDMMC_ADMA_SA_LOW_R;  ///< Offset: 0x58 - ADMA System Address Register (Low)
        volatile uint32_t SDMMC_PRESET_INIT_R;  ///< Offset: 0x60 - Register with Preset Value for Initialization
        volatile uint32_t SDMMC_PRESET_DS_R;  ///< Offset: 0x62 - Register with Preset Value for Default Speed
        volatile uint32_t SDMMC_PRESET_HS_R;  ///< Offset: 0x64 - Register with Preset Value for High Speed
        volatile uint32_t SDMMC_PRESET_SDR12_R;  ///< Offset: 0x66 - Register with Preset Value for SDR12
        volatile uint32_t SDMMC_PRESET_SDR25_R;  ///< Offset: 0x68 - Register with Preset Value for SDR25
        volatile uint32_t SDMMC_PRESET_SDR50_R;  ///< Offset: 0x6A - Register with Preset Value for SDR50
        volatile uint32_t SDMMC_ADMA_ID_LOW_R;  ///< Offset: 0x78 - ADMA3 Integrated Descriptor Address Register (Low)
        volatile uint32_t SDMMC_P_VENDOR_SPECIFIC_AREA;  ///< Offset: 0xE8 - Pointer for Vendor Specific Area 1
        volatile uint32_t SDMMC_SLOT_INTR_STATUS_R;  ///< Offset: 0xFC - Slot Interrupt Status Register
        volatile uint32_t SDMMC_HOST_CNTRL_VERS_R;  ///< Offset: 0xFE - Host Controller Version Register
        volatile uint32_t SDMMC_MSHC_VER_ID_R;  ///< Offset: 0x500 - MSHC Version ID Register
        volatile uint32_t SDMMC_MSHC_VER_TYPE_R;  ///< Offset: 0x504 - MSHC Version Type Register
        volatile uint32_t SDMMC_MSHC_CTRL_R;  ///< Offset: 0x508 - SDMMC Host Controller Control Register
        volatile uint32_t SDMMC_MBIU_CTRL_R;  ///< Offset: 0x510 - Master Bus Interface Unit Control Register
        volatile uint32_t SDMMC_EMMC_CTRL_R;  ///< Offset: 0x52C - eMMC Control Register
        volatile uint32_t SDMMC_BOOT_CTRL_R;  ///< Offset: 0x52E - eMMC Boot Control Register
        volatile uint32_t SDMMC_EMBEDDED_CTRL_R;  ///< Offset: 0xF6C - Embedded Control Register
    };

    /// Peripheral instances
    inline Registers* SDMMC = reinterpret_cast<Registers*>(SDMMC_BASE);

}

// ============================================================================
// CRC0 Peripheral
// ============================================================================

namespace crc0 {
    /// Base addresses
    constexpr uint32_t CRC0_BASE = 0x48107000;

    /// CRC0 Register structure
    struct Registers {
        volatile uint32_t CRC_CONTROL;  ///< Offset: 0x00 - CRC Calculation Setup Register
        volatile uint32_t CRC_SEED;  ///< Offset: 0x10 - Seed Value Register
        volatile uint32_t CRC_POLY_CUSTOM;  ///< Offset: 0x14 - Custom Polynomial Register
        volatile uint32_t CRC_OUT;  ///< Offset: 0x18 - Accumulated CRC Register
        volatile uint32_t CRC_DATA_IN_8___;  ///< Offset: 0x20 - 8-bit Values Register n (renamed from CRC_DATA_IN_8___)
        volatile uint32_t CRC_DATA_IN_32___;  ///< Offset: 0x60 - 32-bit Values Register n (renamed from CRC_DATA_IN_32___)
    };

    /// Peripheral instances
    inline Registers* CRC0 = reinterpret_cast<Registers*>(CRC0_BASE);

}

// ============================================================================
// CRC1 Peripheral
// ============================================================================

namespace crc1 {
    /// Base addresses
    constexpr uint32_t CRC1_BASE = 0x48108000;

    /// CRC1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CRC1 = reinterpret_cast<Registers*>(CRC1_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_BASE = 0x48200000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CAPLENGTH;  ///< Offset: 0x00 - Capability Registers Length
        volatile uint32_t HCSPARAMS1;  ///< Offset: 0x04 - Structural Parameters 1 Register
        volatile uint32_t HCSPARAMS2;  ///< Offset: 0x08 - Structural Parameters 2 Register
        volatile uint32_t HCSPARAMS3;  ///< Offset: 0x0C - Structural Parameters 3 Register
        volatile uint32_t HCCPARAMS1;  ///< Offset: 0x10 - Capability Parameters 1 Register
        volatile uint32_t DBOFF;  ///< Offset: 0x14 - Doorbell Offset
        volatile uint32_t RTSOFF;  ///< Offset: 0x18 - Run-time Register Space Offset
        volatile uint32_t HCCPARAMS2;  ///< Offset: 0x1C - Host Controller Capability Parameters 2
        volatile uint32_t GSBUSCFG0;  ///< Offset: 0xC100 - Global SoC Bus Configuration Register 0
        volatile uint32_t GSBUSCFG1;  ///< Offset: 0xC104 - Global SoC Bus Configuration Register 1
        volatile uint32_t GCTL;  ///< Offset: 0xC110 - Global Core Control Register
        volatile uint32_t GSTS;  ///< Offset: 0xC118 - Global Status Register
        volatile uint32_t GUCTL1;  ///< Offset: 0xC11C - Global User Control Register 1
        volatile uint32_t GSNPSID;  ///< Offset: 0xC120 - Global Controller ID Register
        volatile uint32_t GUID;  ///< Offset: 0xC128 - Global User ID Register
        volatile uint32_t GUCTL;  ///< Offset: 0xC12C - Global User Control Register
        volatile uint32_t GBUSERRADDRLO;  ///< Offset: 0xC130 - Global SoC Bus Error Address Register-Low
        volatile uint32_t GBUSERRADDRHI;  ///< Offset: 0xC134 - Global SoC Bus Error Address Register-High
        volatile uint32_t GHWPARAMS0;  ///< Offset: 0xC140 - Global Hardware Parameters Register 0
        volatile uint32_t GHWPARAMS1;  ///< Offset: 0xC144 - Global Hardware Parameters Register 1
        volatile uint32_t GHWPARAMS2;  ///< Offset: 0xC148 - Global Hardware Parameters Register 2
        volatile uint32_t GHWPARAMS3;  ///< Offset: 0xC14C - Global Hardware Parameters Register 3
        volatile uint32_t GHWPARAMS4;  ///< Offset: 0xC150 - Global Hardware Parameters Register 4
        volatile uint32_t GHWPARAMS5;  ///< Offset: 0xC154 - Global Hardware Parameters Register 5
        volatile uint32_t GHWPARAMS6;  ///< Offset: 0xC158 - Global Hardware Parameters Register 6
        volatile uint32_t GHWPARAMS7;  ///< Offset: 0xC15C - Global Hardware Parameters Register 7
        volatile uint32_t GPRTBIMAP_HSLO;  ///< Offset: 0xC180 - Global High-Speed Port to Bus Instance Mapping (Low)
        volatile uint32_t GPRTBIMAP_HSHI;  ///< Offset: 0xC184 - Global High-Speed Port to Bus Instance Mapping (High)
        volatile uint32_t GPRTBIMAP_FSLO;  ///< Offset: 0xC188 - Global Full-Speed Port to Bus Instance Mapping (Low)
        volatile uint32_t GPRTBIMAP_FSHI;  ///< Offset: 0xC18C - Global Full-Speed Port to Bus Instance Mapping (High)
        volatile uint32_t GUCTL2;  ///< Offset: 0xC19C - Global User Control Register 2
        volatile uint32_t GUSB2PHYCFG0;  ///< Offset: 0xC200 - Global USB2 PHY Configuration Register
        volatile uint32_t GTXFIFOSIZ__;  ///< Offset: 0xC300 - Global Transmit FIFO Size Register n (renamed from GTXFIFOSIZ__)
        volatile uint32_t GRXFIFOSIZ__;  ///< Offset: 0xC380 - Global Receive FIFO Size Register n (renamed from GRXFIFOSIZ__)
        volatile uint32_t GEVNTADRLO0;  ///< Offset: 0xC400 - Global Event Buffer Address (Low)
        volatile uint32_t GEVNTADRHI0;  ///< Offset: 0xC404 - Global Event Buffer Address (High)
        volatile uint32_t GEVNTSIZ0;  ///< Offset: 0xC408 - Global Event Buffer Size Register
        volatile uint32_t GEVNTCOUNT0;  ///< Offset: 0xC40C - Global Event Buffer Count Register
        volatile uint32_t GHWPARAMS8;  ///< Offset: 0xC600 - Global Hardware Parameters Register 8
        volatile uint32_t GTXFIFOPRIDEV;  ///< Offset: 0xC610 - Global Device TX FIFO DMA Priority Register
        volatile uint32_t GTXFIFOPRIHST;  ///< Offset: 0xC618 - Global Host TX FIFO DMA Priority Register
        volatile uint32_t GRXFIFOPRIHST;  ///< Offset: 0xC61C - Global Host RX FIFO DMA Priority Register
        volatile uint32_t GFLADJ;  ///< Offset: 0xC630 - Global Frame Length Adjustment Register
        volatile uint32_t GUSB2RHBCTL0;  ///< Offset: 0xC640 - Global USB 2.0 Root Hub Control Register
        volatile uint32_t DCFG;  ///< Offset: 0xC700 - Device Configuration Register
        volatile uint32_t DCTL;  ///< Offset: 0xC704 - Device Control Register
        volatile uint32_t DEVTEN;  ///< Offset: 0xC708 - Device Event Enable Register
        volatile uint32_t DSTS;  ///< Offset: 0xC70C - Device Status Register
        volatile uint32_t DGCMDPAR;  ///< Offset: 0xC710 - Device Generic Command Parameter Register
        volatile uint32_t DGCMD;  ///< Offset: 0xC714 - Device Generic Command Register
        volatile uint32_t DALEPENA;  ///< Offset: 0xC720 - Device Active USB Endpoint Enable Register
        volatile uint32_t DEPCMDPAR2;  ///< Offset: 0x00 - Device Physical Endpoint-n Command Parameter 2 Register
        volatile uint32_t DEPCMDPAR1;  ///< Offset: 0x04 - Device Physical Endpoint-n Command Parameter 1 Register
        volatile uint32_t DEPCMDPAR0;  ///< Offset: 0x08 - Device Physical Endpoint-n Command Parameter 0 Register
        volatile uint32_t DEPCMD;  ///< Offset: 0x0C - Device Physical Endpoint-n Command Register
        volatile uint32_t DEV_IMOD0;  ///< Offset: 0xCA00 - Device Interrupt Moderation Register
    };

    /// Peripheral instances
    inline Registers* USB = reinterpret_cast<Registers*>(USB_BASE);

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC120_BASE = 0x49020000;
    constexpr uint32_t ADC121_BASE = 0x49021000;
    constexpr uint32_t ADC122_BASE = 0x49022000;
    constexpr uint32_t ADC24_BASE = 0x49027000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_START_SRC;  ///< Offset: 0x00 - ADC Start-of-Conversion Source Register
        volatile uint32_t ADC_COMP_THRESH_A;  ///< Offset: 0x04 - ADC Comparator Threshold A Register
        volatile uint32_t ADC_COMP_THRESH_B;  ///< Offset: 0x08 - ADC Comparator Threshold B Register
        volatile uint32_t ADC_CLK_DIVISOR;  ///< Offset: 0x0C - ADC Clock Divider Value Register
        volatile uint32_t ADC_INTERRUPT;  ///< Offset: 0x10 - ADC Interrupt Status and Clear Register
        volatile uint32_t ADC_INTERRUPT_MASK;  ///< Offset: 0x14 - ADC Interrupt Mask Register
        volatile uint32_t ADC_SAMPLE_WIDTH;  ///< Offset: 0x18 - ADC Sampling Signal Duration Register
        volatile uint32_t ADC_AVG_NUM;  ///< Offset: 0x20 - ADC Number of Samples for Averaging Register
        volatile uint32_t ADC_SHIFT_CONTROL;  ///< Offset: 0x24 - ADC Data Shift Select Register
        volatile uint32_t ADC_CONTROL;  ///< Offset: 0x30 - ADC Single-shot Conversion Start and Comparator...
        volatile uint32_t ADC_SEQUENCER_CTRL;  ///< Offset: 0x34 - ADC Sequencer Control Register
        volatile uint32_t ADC_REG1;  ///< Offset: 0x38 - ADC Analog Control Register for ADC12 Modules
        volatile uint32_t ADC_SEL;  ///< Offset: 0x3C - ADC Sample Register Selected (read-only value of n)
        volatile uint32_t ADC_SAMPLE_REG___;  ///< Offset: 0x50 - ADC Sampled Value From Input n Register (renamed from ADC_SAMPLE_REG___)
    };

    /// Peripheral instances
    inline Registers* ADC120 = reinterpret_cast<Registers*>(ADC120_BASE);
    inline Registers* ADC121 = reinterpret_cast<Registers*>(ADC121_BASE);
    inline Registers* ADC122 = reinterpret_cast<Registers*>(ADC122_BASE);
    inline Registers* ADC24 = reinterpret_cast<Registers*>(ADC24_BASE);

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x49023000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CMP_COMP_REG1;  ///< Offset: 0x00 - Comparator Register 1
        volatile uint32_t CMP_COMP_REG2;  ///< Offset: 0x04 - Comparator Register 2
        volatile uint32_t CMP_POLARITY_CTRL;  ///< Offset: 0x08 - CMP Polarity Control Register
        volatile uint32_t CMP_WINDOW_CTRL;  ///< Offset: 0x0C - CMP Window Control Register
        volatile uint32_t CMP_FILTER_CTRL;  ///< Offset: 0x10 - CMP Filter Control Register
        volatile uint32_t CMP_PRESCALER_CTRL;  ///< Offset: 0x14 - CMP Prescaler Control Register
        volatile uint32_t CMP_INTERRUPT_STATUS;  ///< Offset: 0x20 - CMP Interrupt Status and Clear Register
        volatile uint32_t CMP_INTERRUPT_MASK;  ///< Offset: 0x24 - CMP Interrupt Mask Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x49024000;

    /// CMP1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x49025000;

    /// CMP2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

}

// ============================================================================
// CMP3 Peripheral
// ============================================================================

namespace cmp3 {
    /// Base addresses
    constexpr uint32_t CMP3_BASE = 0x49026000;

    /// CMP3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CMP3 = reinterpret_cast<Registers*>(CMP3_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC120_BASE = 0x49028000;
    constexpr uint32_t DAC121_BASE = 0x49029000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_REG1;  ///< Offset: 0x00 - REG1 DAC Control Register
        volatile uint32_t DAC_IN;  ///< Offset: 0x04 - DAC Input Value Register
    };

    /// Peripheral instances
    inline Registers* DAC120 = reinterpret_cast<Registers*>(DAC120_BASE);
    inline Registers* DAC121 = reinterpret_cast<Registers*>(DAC121_BASE);

}

// ============================================================================
// PDM Peripheral
// ============================================================================

namespace pdm {
    /// Base addresses
    constexpr uint32_t PDM_BASE = 0x4902D000;

    /// PDM Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* PDM = reinterpret_cast<Registers*>(PDM_BASE);

}

// ============================================================================
// HWSEM0 Peripheral
// ============================================================================

namespace hwsem0 {
    /// Base addresses
    constexpr uint32_t HWSEM0_BASE = 0x4902E000;

    /// HWSEM0 Register structure
    struct Registers {
        volatile uint32_t HWSEM_REQ_REG;  ///< Offset: 0x00 - Request register
        volatile uint32_t HWSEM_REL_REG;  ///< Offset: 0x04 - Release register
        volatile uint32_t HWSEM_RST_REG;  ///< Offset: 0x08 - Reset register
    };

    /// Peripheral instances
    inline Registers* HWSEM0 = reinterpret_cast<Registers*>(HWSEM0_BASE);

}

// ============================================================================
// HWSEM1 Peripheral
// ============================================================================

namespace hwsem1 {
    /// Base addresses
    constexpr uint32_t HWSEM1_BASE = 0x4902E010;

    /// HWSEM1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM1 = reinterpret_cast<Registers*>(HWSEM1_BASE);

}

// ============================================================================
// HWSEM2 Peripheral
// ============================================================================

namespace hwsem2 {
    /// Base addresses
    constexpr uint32_t HWSEM2_BASE = 0x4902E020;

    /// HWSEM2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM2 = reinterpret_cast<Registers*>(HWSEM2_BASE);

}

// ============================================================================
// HWSEM3 Peripheral
// ============================================================================

namespace hwsem3 {
    /// Base addresses
    constexpr uint32_t HWSEM3_BASE = 0x4902E030;

    /// HWSEM3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM3 = reinterpret_cast<Registers*>(HWSEM3_BASE);

}

// ============================================================================
// HWSEM4 Peripheral
// ============================================================================

namespace hwsem4 {
    /// Base addresses
    constexpr uint32_t HWSEM4_BASE = 0x4902E040;

    /// HWSEM4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM4 = reinterpret_cast<Registers*>(HWSEM4_BASE);

}

// ============================================================================
// HWSEM5 Peripheral
// ============================================================================

namespace hwsem5 {
    /// Base addresses
    constexpr uint32_t HWSEM5_BASE = 0x4902E050;

    /// HWSEM5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM5 = reinterpret_cast<Registers*>(HWSEM5_BASE);

}

// ============================================================================
// HWSEM6 Peripheral
// ============================================================================

namespace hwsem6 {
    /// Base addresses
    constexpr uint32_t HWSEM6_BASE = 0x4902E060;

    /// HWSEM6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM6 = reinterpret_cast<Registers*>(HWSEM6_BASE);

}

// ============================================================================
// HWSEM7 Peripheral
// ============================================================================

namespace hwsem7 {
    /// Base addresses
    constexpr uint32_t HWSEM7_BASE = 0x4902E070;

    /// HWSEM7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM7 = reinterpret_cast<Registers*>(HWSEM7_BASE);

}

// ============================================================================
// HWSEM8 Peripheral
// ============================================================================

namespace hwsem8 {
    /// Base addresses
    constexpr uint32_t HWSEM8_BASE = 0x4902E080;

    /// HWSEM8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM8 = reinterpret_cast<Registers*>(HWSEM8_BASE);

}

// ============================================================================
// HWSEM9 Peripheral
// ============================================================================

namespace hwsem9 {
    /// Base addresses
    constexpr uint32_t HWSEM9_BASE = 0x4902E090;

    /// HWSEM9 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM9 = reinterpret_cast<Registers*>(HWSEM9_BASE);

}

// ============================================================================
// HWSEM10 Peripheral
// ============================================================================

namespace hwsem10 {
    /// Base addresses
    constexpr uint32_t HWSEM10_BASE = 0x4902E0A0;

    /// HWSEM10 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM10 = reinterpret_cast<Registers*>(HWSEM10_BASE);

}

// ============================================================================
// HWSEM11 Peripheral
// ============================================================================

namespace hwsem11 {
    /// Base addresses
    constexpr uint32_t HWSEM11_BASE = 0x4902E0B0;

    /// HWSEM11 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM11 = reinterpret_cast<Registers*>(HWSEM11_BASE);

}

// ============================================================================
// HWSEM12 Peripheral
// ============================================================================

namespace hwsem12 {
    /// Base addresses
    constexpr uint32_t HWSEM12_BASE = 0x4902E0C0;

    /// HWSEM12 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM12 = reinterpret_cast<Registers*>(HWSEM12_BASE);

}

// ============================================================================
// HWSEM13 Peripheral
// ============================================================================

namespace hwsem13 {
    /// Base addresses
    constexpr uint32_t HWSEM13_BASE = 0x4902E0D0;

    /// HWSEM13 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM13 = reinterpret_cast<Registers*>(HWSEM13_BASE);

}

// ============================================================================
// HWSEM14 Peripheral
// ============================================================================

namespace hwsem14 {
    /// Base addresses
    constexpr uint32_t HWSEM14_BASE = 0x4902E0E0;

    /// HWSEM14 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM14 = reinterpret_cast<Registers*>(HWSEM14_BASE);

}

// ============================================================================
// HWSEM15 Peripheral
// ============================================================================

namespace hwsem15 {
    /// Base addresses
    constexpr uint32_t HWSEM15_BASE = 0x4902E0F0;

    /// HWSEM15 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* HWSEM15 = reinterpret_cast<Registers*>(HWSEM15_BASE);

}

// ============================================================================
// CPI Peripheral
// ============================================================================

namespace cpi {
    /// Base addresses
    constexpr uint32_t CPI_BASE = 0x49030000;

    /// CPI Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* CPI = reinterpret_cast<Registers*>(CPI_BASE);

}

// ============================================================================
// CDC Peripheral
// ============================================================================

namespace cdc {
    /// Base addresses
    constexpr uint32_t CDC_BASE = 0x49031000;

    /// CDC Register structure
    struct Registers {
        volatile uint32_t CDC_HW_VER;  ///< Offset: 0x00 - HW Version Register
        volatile uint32_t CDC_LCNT;  ///< Offset: 0x04 - Layer Count Register
        volatile uint32_t CDC_SYNC_SIZE_CFG;  ///< Offset: 0x08 - Sync Size Register
        volatile uint32_t CDC_BP_CFG;  ///< Offset: 0x0C - Back Porch Register
        volatile uint32_t CDC_ACTW_CFG;  ///< Offset: 0x10 - Active Width Register
        volatile uint32_t CDC_TOTALW_CFG;  ///< Offset: 0x14 - Total Width Register
        volatile uint32_t CDC_GLB_CTRL;  ///< Offset: 0x18 - Global Control Register
        volatile uint32_t CDC_CFG1;  ///< Offset: 0x1C - Global Configuration 1 Register
        volatile uint32_t CDC_CFG2;  ///< Offset: 0x20 - Global Configuration 2 Register
        volatile uint32_t CDC_SRCTRL;  ///< Offset: 0x24 - Shadow Reload Control Register
        volatile uint32_t CDC_GAMMA_CORR;  ///< Offset: 0x28 - Gamma Correction Register
        volatile uint32_t CDC_BACKGND_COLOR;  ///< Offset: 0x2C - Background Color Register
        volatile uint32_t CDC_IRQ_MASK0;  ///< Offset: 0x34 - IRQ Enable 1 Register
        volatile uint32_t CDC_IRQ_STATUS0;  ///< Offset: 0x38 - IRQ Status 1 Register
        volatile uint32_t CDC_IRQ_CLEAR0;  ///< Offset: 0x3C - IRQ Clear Register
        volatile uint32_t CDC_LINE_IRQ_POS;  ///< Offset: 0x40 - Line Number IRQ Control Register
        volatile uint32_t CDC_POS_STAT;  ///< Offset: 0x44 - Position Status Register
        volatile uint32_t CDC_SYNC_BLANK_STAT;  ///< Offset: 0x48 - Sync/Blank Status Register
        volatile uint32_t CDC_SLINE_IRQ_POS;  ///< Offset: 0x70 - Secure Line IRQ Position Control Register
        volatile uint32_t CDC_L_CFG1;  ///< Offset: 0x00 - Layer (n) Configuration 1 Register
        volatile uint32_t CDC_L_CFG2;  ///< Offset: 0x04 - Layer (n) Configuration 2 Register
        volatile uint32_t CDC_L_REL_CTRL;  ///< Offset: 0x08 - Layer (n) Shadow Reload Control Register
        volatile uint32_t CDC_L_CTRL;  ///< Offset: 0x0C - Layer (n) Control Register
        volatile uint32_t CDC_L_WIN_HPOS;  ///< Offset: 0x10 - Layer (n) Window Horizontal Position Register
        volatile uint32_t CDC_L_WIN_VPOS;  ///< Offset: 0x14 - Layer (n) Window Vertical Position Register
        volatile uint32_t CDC_L_CKEY;  ///< Offset: 0x18 - Layer (n) Color Key Register
        volatile uint32_t CDC_L_PIX_FORMAT;  ///< Offset: 0x1C - Layer (n) Pixel Format Register
        volatile uint32_t CDC_L_CONST_ALPHA;  ///< Offset: 0x20 - Layer (n) Constant Alpha Register
        volatile uint32_t CDC_L_DFLT_COLOR;  ///< Offset: 0x24 - Layer (n) Default Color Register
        volatile uint32_t CDC_L_BLEND_CFG;  ///< Offset: 0x28 - Layer (n) Blending Factors Register
        volatile uint32_t CDC_L_FB_BCTRL;  ///< Offset: 0x2C - Layer (n) FB Bus Control Register
        volatile uint32_t CDC_L_CFB_ADDR;  ///< Offset: 0x34 - Layer (n) Color FB Address Register
        volatile uint32_t CDC_L_CFB_LENGTH;  ///< Offset: 0x38 - Layer (n) Color FB Length Register
        volatile uint32_t CDC_L_CFB_LINES;  ///< Offset: 0x3C - Layer (n) Color FB Lines Register
        volatile uint32_t CDC_L_CLUT_WRACC;  ///< Offset: 0x50 - Layer (n) CLUT Write Access Register
    };

    /// Peripheral instances
    inline Registers* CDC = reinterpret_cast<Registers*>(CDC_BASE);

}

// ============================================================================
// DSI Peripheral
// ============================================================================

namespace dsi {
    /// Base addresses
    constexpr uint32_t DSI_BASE = 0x49032000;

    /// DSI Register structure
    struct Registers {
        volatile uint32_t DSI_VERSION;  ///< Offset: 0x00 - DSI Host Controller Version Register
        volatile uint32_t DSI_PWR_UP;  ///< Offset: 0x04 - Power-up Control Register
        volatile uint32_t DSI_CLKMGR_CFG;  ///< Offset: 0x08 - Clock Control Register
        volatile uint32_t DSI_DPI_VCID;  ///< Offset: 0x0C - VC ID Configuration Register
        volatile uint32_t DSI_DPI_COLOR_CODING;  ///< Offset: 0x10 - DPI Color Coding Register
        volatile uint32_t DSI_DPI_CFG_POL;  ///< Offset: 0x14 - DPI Polarity Configuration Register
        volatile uint32_t DSI_DPI_LP_CMD_TIM;  ///< Offset: 0x18 - DPI Low-Power Mode Configuration Register
        volatile uint32_t DSI_PCKHDL_CFG;  ///< Offset: 0x2C - Protocol Configuration Register
        volatile uint32_t DSI_GEN_VCID;  ///< Offset: 0x30 - Generic VC ID Configuration Register
        volatile uint32_t DSI_MODE_CFG;  ///< Offset: 0x34 - Mode Configuration Register
        volatile uint32_t DSI_VID_MODE_CFG;  ///< Offset: 0x38 - Video Mode Configuration Register
        volatile uint32_t DSI_VID_PKT_SIZE;  ///< Offset: 0x3C - Video Packet Size Register
        volatile uint32_t DSI_VID_NUM_CHUNKS;  ///< Offset: 0x40 - Video Chunks Configuration Register
        volatile uint32_t DSI_VID_NULL_SIZE;  ///< Offset: 0x44 - Video Null Packet Configuration Register
        volatile uint32_t DSI_VID_HSA_TIME;  ///< Offset: 0x48 - Video HSA Configuration Register
        volatile uint32_t DSI_VID_HBP_TIME;  ///< Offset: 0x4C - Video HBP Configuration Register
        volatile uint32_t DSI_VID_HLINE_TIME;  ///< Offset: 0x50 - Video Line Configuration Register
        volatile uint32_t DSI_VID_VSA_LINES;  ///< Offset: 0x54 - Video VSA Configuration Register
        volatile uint32_t DSI_VID_VBP_LINES;  ///< Offset: 0x58 - Video VBP Configuration Register
        volatile uint32_t DSI_VID_VFP_LINES;  ///< Offset: 0x5C - Video VFP Configuration Register
        volatile uint32_t DSI_VID_VACTIVE_LINES;  ///< Offset: 0x60 - Video VA Configuration Register
        volatile uint32_t DSI_CMD_MODE_CFG;  ///< Offset: 0x68 - Generic Packet Command Configuration Register
        volatile uint32_t DSI_GEN_HDR;  ///< Offset: 0x6C - Generic Header Configuration Register
        volatile uint32_t DSI_GEN_PLD_DATA;  ///< Offset: 0x70 - Generic Payload Data Register
        volatile uint32_t DSI_CMD_PKT_STATUS;  ///< Offset: 0x74 - Generic Packet Status Register
        volatile uint32_t DSI_TO_CNT_CFG;  ///< Offset: 0x78 - Timeout Counter Configuration Register
        volatile uint32_t DSI_HS_RD_TO_CNT;  ///< Offset: 0x7C - HS Read Timeout Configuration Register
        volatile uint32_t DSI_LP_RD_TO_CNT;  ///< Offset: 0x80 - LP Read Timeout Configuration Register
        volatile uint32_t DSI_HS_WR_TO_CNT;  ///< Offset: 0x84 - HS Write Timeout Configuration Register
        volatile uint32_t DSI_LP_WR_TO_CNT;  ///< Offset: 0x88 - LP Write Timeout Configuration Register
        volatile uint32_t DSI_BTA_TO_CNT;  ///< Offset: 0x8C - BTA Timeout Configuration Register
        volatile uint32_t DSI_SDF_3D;  ///< Offset: 0x90 - 3D Control Register
        volatile uint32_t DSI_LPCLK_CTRL;  ///< Offset: 0x94 - Clock Lane Power Control Register
        volatile uint32_t DSI_PHY_TMR_LPCLK_CFG;  ///< Offset: 0x98 - Clock Lane Timer Configuration Register
        volatile uint32_t DSI_PHY_TMR_CFG;  ///< Offset: 0x9C - Data Lane Timer Configuration Register
        volatile uint32_t DSI_PHY_RSTZ;  ///< Offset: 0xA0 - PHY Control Register
        volatile uint32_t DSI_PHY_IF_CFG;  ///< Offset: 0xA4 - PHY Configuration Register
        volatile uint32_t DSI_PHY_ULPS_CTRL;  ///< Offset: 0xA8 - PHY ULPS Control Register
        volatile uint32_t DSI_PHY_TX_TRIGGERS;  ///< Offset: 0xAC - PHY TX Trigger Configuration Register
        volatile uint32_t DSI_PHY_STATUS;  ///< Offset: 0xB0 - PHY Status Register
        volatile uint32_t DSI_PHY_TST_CTRL0;  ///< Offset: 0xB4 - PHY Test Interface Control Register 0
        volatile uint32_t DSI_PHY_TST_CTRL1;  ///< Offset: 0xB8 - PHY Test Interface Control Register 1
        volatile uint32_t DSI_INT_ST0;  ///< Offset: 0xBC - Interrupt Status Register 0
        volatile uint32_t DSI_INT_ST1;  ///< Offset: 0xC0 - Interrupt Status Register 1
        volatile uint32_t DSI_INT_MSK0;  ///< Offset: 0xC4 - Interrupt Mask Register 0
        volatile uint32_t DSI_INT_MSK1;  ///< Offset: 0xC8 - Interrupt Mask Register 1
        volatile uint32_t DSI_PHY_CAL;  ///< Offset: 0xCC - PHY skew calibration control
        volatile uint32_t DSI_INT_FORCE0;  ///< Offset: 0xD8 - Force Interrupt Register 0
        volatile uint32_t DSI_INT_FORCE1;  ///< Offset: 0xDC - Force Interrupt Register 1
        volatile uint32_t DSI_PHY_TMR_RD_CFG;  ///< Offset: 0xF4 - Data Lane Timer Read Configuration Register
        volatile uint32_t DSI_VID_SHADOW_CTRL;  ///< Offset: 0x100 - Video Shadow Control Register
        volatile uint32_t DSI_DPI_VCID_ACT;  ///< Offset: 0x10C - Current VC ID Register
        volatile uint32_t DSI_DPI_COLOR_CODING_ACT;  ///< Offset: 0x110 - Current Color Coding Register
        volatile uint32_t DSI_DPI_LP_CMD_TIM_ACT;  ///< Offset: 0x118 - Low-Power Mode Current Configuration Register
        volatile uint32_t DSI_VID_MODE_CFG_ACT;  ///< Offset: 0x138 - Video Mode Current Configuration Register
        volatile uint32_t DSI_VID_PKT_SIZE_ACT;  ///< Offset: 0x13C - Video Packet Size Current Configuration Register
        volatile uint32_t DSI_VID_NUM_CHUNKS_ACT;  ///< Offset: 0x140 - Video Chunks Current Configuration Register
        volatile uint32_t DSI_VID_NULL_SIZE_ACT;  ///< Offset: 0x144 - Video Null Packet Size Current Configuration Register
        volatile uint32_t DSI_VID_HSA_TIME_ACT;  ///< Offset: 0x148 - Video HSA Current Configuration Register
        volatile uint32_t DSI_VID_HBP_TIME_ACT;  ///< Offset: 0x14C - Video HBP Current Configuration Register
        volatile uint32_t DSI_VID_HLINE_TIME_ACT;  ///< Offset: 0x150 - Video Line Current Configuration Register
        volatile uint32_t DSI_VID_VSA_LINES_ACT;  ///< Offset: 0x154 - Video VSA Current Configuration Register
        volatile uint32_t DSI_VID_VBP_LINES_ACT;  ///< Offset: 0x158 - Video VBP Current Configuration Register
        volatile uint32_t DSI_VID_VFP_LINES_ACT;  ///< Offset: 0x15C - Video VFP Current Configuration Register
        volatile uint32_t DSI_VID_VACTIVE_LINES_ACT;  ///< Offset: 0x160 - Video VA Current Configuration Register
        volatile uint32_t DSI_VID_PKT_STATUS;  ///< Offset: 0x168 - Video Packet Status Register
        volatile uint32_t DSI_SDF_3D_ACT;  ///< Offset: 0x190 - 3D Current Configuration Register
    };

    /// Peripheral instances
    inline Registers* DSI = reinterpret_cast<Registers*>(DSI_BASE);

}

// ============================================================================
// CSI Peripheral
// ============================================================================

namespace csi {
    /// Base addresses
    constexpr uint32_t CSI_BASE = 0x49033000;

    /// CSI Register structure
    struct Registers {
        volatile uint32_t CSI_VERSION;  ///< Offset: 0x00 - Module Version Code Register
        volatile uint32_t CSI_N_LANES;  ///< Offset: 0x04 - Lane Configuration Register
        volatile uint32_t CSI_CSI2_RESETN;  ///< Offset: 0x08 - CSI Controller Reset Control Register
        volatile uint32_t CSI_INT_ST_MAIN;  ///< Offset: 0x0C - Main Interrupt Status Register
        volatile uint32_t CSI_DATA_IDS_1;  ///< Offset: 0x10 - DT Data ID Monitors Configuration Register
        volatile uint32_t CSI_DATA_IDS_VC_1;  ///< Offset: 0x30 - VC Data ID Monitors Configuration Register
        volatile uint32_t CSI_PHY_SHUTDOWNZ;  ///< Offset: 0x40 - PHY Shutdown Control Register
        volatile uint32_t CSI_DPHY_RSTZ;  ///< Offset: 0x44 - PHY Reset Control Register
        volatile uint32_t CSI_PHY_RX;  ///< Offset: 0x48 - PHY RX Signals Status Register
        volatile uint32_t CSI_PHY_STOPSTATE;  ///< Offset: 0x4C - PHY STOPSTATE Signal Status Register
        volatile uint32_t CSI_PHY_TEST_CTRL0;  ///< Offset: 0x50 - PHY Test Control 0 Register
        volatile uint32_t CSI_PHY_TEST_CTRL1;  ///< Offset: 0x54 - PHY Test Control 1 Register
        volatile uint32_t CSI_IPI_MODE;  ///< Offset: 0x80 - IPI Mode Selection Register
        volatile uint32_t CSI_IPI_VCID;  ///< Offset: 0x84 - IPI VC Selection Register
        volatile uint32_t CSI_IPI_DATA_TYPE;  ///< Offset: 0x88 - IPI DT Selection Register
        volatile uint32_t CSI_IPI_MEM_FLUSH;  ///< Offset: 0x8C - IPI Memory Flush Control Register
        volatile uint32_t CSI_IPI_HSA_TIME;  ///< Offset: 0x90 - IPI HSA Configuration Register
        volatile uint32_t CSI_IPI_HBP_TIME;  ///< Offset: 0x94 - IPI HBP Configuration Register
        volatile uint32_t CSI_IPI_HSD_TIME;  ///< Offset: 0x98 - IPI HSD Configuration Register
        volatile uint32_t CSI_IPI_HLINE_TIME;  ///< Offset: 0x9C - IPI HLINE Configuration Register
        volatile uint32_t CSI_IPI_SOFTRSTN;  ///< Offset: 0xA0 - IPI Reset Control Register
        volatile uint32_t CSI_IPI_ADV_FEATURES;  ///< Offset: 0xAC - IPI Advanced Features Configuration Register
        volatile uint32_t CSI_IPI_VSA_LINES;  ///< Offset: 0xB0 - IPI VSA Configuration Register
        volatile uint32_t CSI_IPI_VBP_LINES;  ///< Offset: 0xB4 - IPI VBP Configuration Register
        volatile uint32_t CSI_IPI_VFP_LINES;  ///< Offset: 0xB8 - IPI VFP Configuration Register
        volatile uint32_t CSI_IPI_VACTIVE_LINES;  ///< Offset: 0xBC - IPI VACTIVE Configuration Register
        volatile uint32_t CSI_VC_EXTENSION;  ///< Offset: 0xC8 - VC Extension Configuration Register
        volatile uint32_t CSI_PHY_CAL;  ///< Offset: 0xCC - PHY CALIBRATION Signal Status Register
        volatile uint32_t CSI_INT_ST_PHY_FATAL;  ///< Offset: 0xE0 - PHY Packet Discarded Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_PHY_FATAL;  ///< Offset: 0xE4 - PHY Packet Discarded Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_PHY_FATAL;  ///< Offset: 0xE8 - PHY Packet Discarded Interrupt Force Register
        volatile uint32_t CSI_INT_ST_PKT_FATAL;  ///< Offset: 0xF0 - PHY Packet Construction Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_PKT_FATAL;  ///< Offset: 0xF4 - PHY Packet Construction Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_PKT_FATAL;  ///< Offset: 0xF8 - PHY Packet Construction Interrupt Force Register
        volatile uint32_t CSI_INT_ST_PHY;  ///< Offset: 0x110 - PHY Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_PHY;  ///< Offset: 0x114 - PHY Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_PHY;  ///< Offset: 0x118 - PHY Interrupt Force Register
        volatile uint32_t CSI_INT_ST_LINE;  ///< Offset: 0x130 - PHY Line Construction Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_LINE;  ///< Offset: 0x134 - PHY Line Construction Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_LINE;  ///< Offset: 0x138 - PHY Line Construction Interrupt Force Register
        volatile uint32_t CSI_INT_ST_IPI_FATAL;  ///< Offset: 0x140 - IPI Interface Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_IPI_FATAL;  ///< Offset: 0x144 - IPI Interface Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_IPI_FATAL;  ///< Offset: 0x148 - IPI Interface Interrupt Force Register
        volatile uint32_t CSI_INT_ST_BNDRY_FRAME_FATAL;  ///< Offset: 0x280 - Frame Boundary Error Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_BNDRY_FRAME_FATAL;  ///< Offset: 0x284 - Frame Boundary Error Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_BNDRY_FRAME_FATAL;  ///< Offset: 0x288 - Frame Boundary Error Interrupt Force Register
        volatile uint32_t CSI_INT_ST_SEQ_FRAME_FATAL;  ///< Offset: 0x290 - Frame Sequence Error Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_SEQ_FRAME_FATAL;  ///< Offset: 0x294 - Frame Sequence Error Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_SEQ_FRAME_FATAL;  ///< Offset: 0x298 - Frame Sequence Error Interrupt Force Register
        volatile uint32_t CSI_INT_ST_CRC_FRAME_FATAL;  ///< Offset: 0x2A0 - Frame CRC Error Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_CRC_FRAME_FATAL;  ///< Offset: 0x2A4 - Frame CRC Error Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_CRC_FRAME_FATAL;  ///< Offset: 0x2A8 - Frame CRC Error Interrupt Force Register
        volatile uint32_t CSI_INT_ST_PLD_CRC_FATAL;  ///< Offset: 0x2B0 - Frame Payload Error Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_PLD_CRC_FATAL;  ///< Offset: 0x2B4 - Frame Payload Error Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_PLD_CRC_FATAL;  ///< Offset: 0x2B8 - Frame Payload Error Interrupt Force Register
        volatile uint32_t CSI_INT_ST_DATA_ID;  ///< Offset: 0x2C0 - DT Error Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_DATA_ID;  ///< Offset: 0x2C4 - DT Error Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_DATA_ID;  ///< Offset: 0x2C8 - DT Error Interrupt Force Register
        volatile uint32_t CSI_INT_ST_ECC_CORRECT;  ///< Offset: 0x2D0 - ECC Interrupt Status Register
        volatile uint32_t CSI_INT_MSK_ECC_CORRECT;  ///< Offset: 0x2D4 - ECC Interrupt Mask Register
        volatile uint32_t CSI_INT_FORCE_ECC_CORRECT;  ///< Offset: 0x2D8 - ECC Interrupt Force Register
        volatile uint32_t CSI_SCRAMBLING;  ///< Offset: 0x300 - Descrambling Control Register
        volatile uint32_t CSI_SCRAMBLING_SEED1;  ///< Offset: 0x304 - Descrambling Seed Configuration Lane 0 Register
        volatile uint32_t CSI_SCRAMBLING_SEED2;  ///< Offset: 0x308 - Descrambling Seed Configuration Lane 1 Register
    };

    /// Peripheral instances
    inline Registers* CSI = reinterpret_cast<Registers*>(CSI_BASE);

}

// ============================================================================
// I3C Peripheral
// ============================================================================

namespace i3c {
    /// Base addresses
    constexpr uint32_t I3C_BASE = 0x49034000;

    /// I3C Register structure
    struct Registers {
        volatile uint32_t I3C_DEVICE_CTRL;  ///< Offset: 0x00 - Device Control Register
        volatile uint32_t I3C_DEVICE_ADDR;  ///< Offset: 0x04 - Device Address Register
        volatile uint32_t I3C_HW_CAPABILITY;  ///< Offset: 0x08 - Hardware Capability Register
        volatile uint32_t I3C_COMMAND_QUEUE_PORT;  ///< Offset: 0x0C - Command Queue Port Register
        volatile uint32_t I3C_RESPONSE_QUEUE_PORT;  ///< Offset: 0x10 - Response Queue Port Register
        volatile uint32_t I3C_RX_DATA_PORT;  ///< Offset: 0x14 - Receive Data Port Register
        volatile uint32_t I3C_TX_DATA_PORT;  ///< Offset: 0x14 - Transmit Data Port Register
        volatile uint32_t I3C_IBI_QUEUE_DATA;  ///< Offset: 0x18 - In-Band Interrupt Queue Data Register
        volatile uint32_t I3C_IBI_QUEUE_STATUS;  ///< Offset: 0x18 - In-Band Interrupt Queue Status Register
        volatile uint32_t I3C_QUEUE_THLD_CTRL;  ///< Offset: 0x1C - Queue Threshold Control Register
        volatile uint32_t I3C_DATA_BUFFER_THLD_CTRL;  ///< Offset: 0x20 - Data Buffer Threshold Control Register
        volatile uint32_t I3C_IBI_QUEUE_CTRL;  ///< Offset: 0x24 - IBI Queue Control Register
        volatile uint32_t I3C_IBI_MR_REQ_REJECT;  ///< Offset: 0x2C - IBI MR Request Rejection Control Register
        volatile uint32_t I3C_IBI_SIR_REQ_REJECT;  ///< Offset: 0x30 - IBI SIR Request Rejection Control Register
        volatile uint32_t I3C_RESET_CTRL;  ///< Offset: 0x34 - Reset Control Register
        volatile uint32_t I3C_SLV_EVENT_STATUS;  ///< Offset: 0x38 - Slave Event Status Register
        volatile uint32_t I3C_INTR_STATUS;  ///< Offset: 0x3C - Interrupt Status Register
        volatile uint32_t I3C_INTR_STATUS_EN;  ///< Offset: 0x40 - Interrupt Status Enable Register
        volatile uint32_t I3C_INTR_SIGNAL_EN;  ///< Offset: 0x44 - Interrupt Signal Enable Register
        volatile uint32_t I3C_INTR_FORCE;  ///< Offset: 0x48 - Interrupt Force Enable Register
        volatile uint32_t I3C_QUEUE_STATUS_LEVEL;  ///< Offset: 0x4C - Queue Status Level Register
        volatile uint32_t I3C_DATA_BUFFER_STATUS_LEVEL;  ///< Offset: 0x50 - Data Buffer Status Level Register
        volatile uint32_t I3C_PRESENT_STATE;  ///< Offset: 0x54 - Present State Register
        volatile uint32_t I3C_CCC_DEVICE_STATUS;  ///< Offset: 0x58 - Device Operating Status Register
        volatile uint32_t I3C_DEVICE_ADDR_TABLE_POINTER;  ///< Offset: 0x5C - Pointer for Device Address Table Registers
        volatile uint32_t I3C_DEV_CHAR_TABLE_POINTER;  ///< Offset: 0x60 - Pointer for Device Characteristics Table Register
        volatile uint32_t I3C_VENDOR_SPECIFIC_REG_POINTER;  ///< Offset: 0x6C - Pointer for Vendor Specific Registers
        volatile uint32_t I3C_SLV_MIPI_ID_VALUE;  ///< Offset: 0x70 - Provisional ID Register
        volatile uint32_t I3C_SLV_PID_VALUE;  ///< Offset: 0x74 - Provisional ID Register
        volatile uint32_t I3C_SLV_CHAR_CTRL;  ///< Offset: 0x78 - I3C Slave Characteristic Register
        volatile uint32_t I3C_SLV_MAX_LEN;  ///< Offset: 0x7C - I3C Max Write/Read Length Register
        volatile uint32_t I3C_MAX_READ_TURNAROUND;  ///< Offset: 0x80 - MXDS Maximum Read Turnaround Time Register
        volatile uint32_t I3C_MAX_DATA_SPEED;  ///< Offset: 0x84 - MXDS Maximum Data Speed Register
        volatile uint32_t I3C_SLV_INTR_REQ;  ///< Offset: 0x8C - Slave Interrupt Request Register
        volatile uint32_t I3C_DEVICE_CTRL_EXTENDED;  ///< Offset: 0xB0 - Device Control Extended Register
        volatile uint32_t I3C_SCL_I3C_OD_TIMING;  ///< Offset: 0xB4 - SCL I3C Open Drain Timing Register
        volatile uint32_t I3C_SCL_I3C_PP_TIMING;  ///< Offset: 0xB8 - SCL I3C Push Pull Timing Register
        volatile uint32_t I3C_SCL_I2C_FM_TIMING;  ///< Offset: 0xBC - SCL I2C Fast Mode Timing Register
        volatile uint32_t I3C_SCL_I2C_FMP_TIMING;  ///< Offset: 0xC0 - SCL I2C Fast Mode Plus Timing Register
        volatile uint32_t I3C_SCL_EXT_LCNT_TIMING;  ///< Offset: 0xC8 - SCL Extended Low Count Timing Register
        volatile uint32_t I3C_SCL_EXT_TERMN_LCNT_TIMING;  ///< Offset: 0xCC - SCL Termination Bit Low Count Timing Register
        volatile uint32_t I3C_SDA_HOLD_SWITCH_DLY_TIMING;  ///< Offset: 0xD0 - SDA Hold and Mode Switch Delay Timing Register
        volatile uint32_t I3C_BUS_FREE_AVAIL_TIMING;  ///< Offset: 0xD4 - Bus Free Timing Register
        volatile uint32_t I3C_BUS_IDLE_TIMING;  ///< Offset: 0xD8 - Bus Idle Timing Register
        volatile uint32_t I3C_SCL_LOW_MST_EXT_TIMEOUT;  ///< Offset: 0xDC - SCL Low Master Extended Timeout Register
        volatile uint32_t I3C_VER_ID;  ///< Offset: 0xE0 - Version ID Register
        volatile uint32_t I3C_VER_TYPE;  ///< Offset: 0xE4 - Version Type Register
        volatile uint32_t I3C_QUEUE_SIZE_CAPABILITY;  ///< Offset: 0xE8 - I3C Queue Size Capability Register
        volatile uint32_t I3C_DEV_CHAR_TABLE1_LOC1;  ///< Offset: 0x200 - Device Characteristic Table Location 1 Register
        volatile uint32_t I3C_SEC_DEV_CHAR_TABLE1;  ///< Offset: 0x200 - Secondary Master Device Characteristic Table Location Register
        volatile uint32_t I3C_DEV_CHAR_TABLE1_LOC2;  ///< Offset: 0x204 - Device Characteristic Table Location 2 Register
        volatile uint32_t I3C_DEV_CHAR_TABLE1_LOC3;  ///< Offset: 0x208 - Device Characteristic Table Location 3 Register
        volatile uint32_t I3C_DEV_CHAR_TABLE1_LOC4;  ///< Offset: 0x20C - Device Characteristic Table Location 4 Register
        volatile uint32_t I3C_DEV_ADDR_TABLE_LOC1;  ///< Offset: 0x220 - Device Address Table Location 1 Register
    };

    /// Peripheral instances
    inline Registers* I3C = reinterpret_cast<Registers*>(I3C_BASE);

}

// ============================================================================
// EVTRTR0 Peripheral
// ============================================================================

namespace evtrtr0 {
    /// Base addresses
    constexpr uint32_t EVTRTR0_BASE = 0x49035000;

    /// EVTRTR0 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* EVTRTR0 = reinterpret_cast<Registers*>(EVTRTR0_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CANFD_BASE = 0x49036000;
    constexpr uint32_t CAN_CNT_BASE = 0x49037000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t CANFD_RBUF__;  ///< Offset: 0x00 - Receive Buffer Register (renamed from CANFD_RBUF__)
        volatile uint32_t CANFD_TBUF__;  ///< Offset: 0x50 - Transmit Buffer Register (renamed from CANFD_TBUF__)
        volatile uint32_t CANFD_TTS;  ///< Offset: 0x98 - Transmission Time Stamp Register
        volatile uint32_t CANFD_CFG_STAT;  ///< Offset: 0xA0 - Configuration and Status Register
        volatile uint32_t CANFD_TCMD;  ///< Offset: 0xA1 - Command Register
        volatile uint32_t CANFD_TCTRL;  ///< Offset: 0xA2 - Transmit Control Register
        volatile uint32_t CANFD_RCTRL;  ///< Offset: 0xA3 - Receive Control Register
        volatile uint32_t CANFD_RTIE;  ///< Offset: 0xA4 - Receive and Transmit Interrupt Enable Register
        volatile uint32_t CANFD_RTIF;  ///< Offset: 0xA5 - Receive and Transmit Interrupt Flag Register
        volatile uint32_t CANFD_ERRINT;  ///< Offset: 0xA6 - Error Interrupt Enable and Flag Register
        volatile uint32_t CANFD_LIMIT;  ///< Offset: 0xA7 - Warning Limits Register
        volatile uint32_t CANFD_S_SEG_1;  ///< Offset: 0xA8 - Slow Speed Bit Timing 1 Register (Segment 1)
        volatile uint32_t CANFD_S_SEG_2;  ///< Offset: 0xA9 - Slow Speed Bit Timing 2 Register (Segment 2)
        volatile uint32_t CANFD_S_SJW;  ///< Offset: 0xAA - Slow Speed Bit Timing 3 Register (Synchronization Jump Width)
        volatile uint32_t CANFD_S_PRESC;  ///< Offset: 0xAB - Slow Speed Prescaler Register
        volatile uint32_t CANFD_F_SEG_1;  ///< Offset: 0xAC - Fast Speed Bit Timing 1 Register (Segment 1)
        volatile uint32_t CANFD_F_SEG_2;  ///< Offset: 0xAD - Fast Speed Bit Timing 2 Register (Segment 2)
        volatile uint32_t CANFD_F_SJW;  ///< Offset: 0xAE - Fast Speed Bit Timing 3 Register (Synchronization Jump Width)
        volatile uint32_t CANFD_F_PRESC;  ///< Offset: 0xAF - Fast Speed Prescaler Register
        volatile uint32_t CANFD_EALCAP;  ///< Offset: 0xB0 - Error and Arbitration Lost Capture Register
        volatile uint32_t CANFD_TDC;  ///< Offset: 0xB1 - Transmitter Delay Compensation Register
        volatile uint32_t CANFD_RECNT;  ///< Offset: 0xB2 - Receive Error Counter Register
        volatile uint32_t CANFD_TECNT;  ///< Offset: 0xB3 - Transmit Error Counter Register
        volatile uint32_t CANFD_ACFCTRL;  ///< Offset: 0xB4 - Acceptance Filter Control Register
        volatile uint32_t CANFD_TIMECFG;  ///< Offset: 0xB5 - CiA 603 Time-Stamping Register
        volatile uint32_t CANFD_ACF_EN_0;  ///< Offset: 0xB6 - Acceptance Filter Enable 0 Register
        volatile uint32_t CANFD_ACF_EN_1;  ///< Offset: 0xB7 - Acceptance Filter Enable 1 Register
        volatile uint32_t CANFD_ACF_0_3_CODE;  ///< Offset: 0xB8 - Acceptance CODE Register
        volatile uint32_t CANFD_ACF_0_3_MASK;  ///< Offset: 0xB8 - Acceptance MASK Register
        volatile uint32_t CANFD_VER_0;  ///< Offset: 0xBC - Version Information 0 Register
        volatile uint32_t CANFD_VER_1;  ///< Offset: 0xBD - Version Information 1 Register
        volatile uint32_t CANFD_MEM_PROT;  ///< Offset: 0xCA - Memory Protection Register
        volatile uint32_t CANFD_MEM_STAT;  ///< Offset: 0xCB - Memory Status Register
        volatile uint32_t CANFD_MEM_ES_0;  ///< Offset: 0xCC - Memory Error Stimulation 0 Register
        volatile uint32_t CANFD_MEM_ES_1;  ///< Offset: 0xCD - Memory Error Stimulation 1 Register
        volatile uint32_t CANFD_MEM_ES_2;  ///< Offset: 0xCE - Memory Error Stimulation 2 Register
        volatile uint32_t CANFD_MEM_ES_3;  ///< Offset: 0xCF - Memory Error Stimulation 3 Register
        volatile uint32_t CANFD_SRCFG;  ///< Offset: 0xD0 - Spatial Redundancy Configuration Register
    };

    /// Peripheral instances
    inline Registers* CANFD = reinterpret_cast<Registers*>(CANFD_BASE);
    inline Registers* CAN_CNT = reinterpret_cast<Registers*>(CAN_CNT_BASE);

}

// ============================================================================
// GPU2D Peripheral
// ============================================================================

namespace gpu2d {
    /// Base addresses
    constexpr uint32_t GPU2D_BASE = 0x49040000;

    /// GPU2D Register structure
    struct Registers {
        volatile uint32_t GPU2D_CONTROL;  ///< Offset: 0x00 - Geometry Control Register
        volatile uint32_t GPU2D_STATUS;  ///< Offset: 0x00 - Status Control Register
        volatile uint32_t GPU2D_CONTROL2;  ///< Offset: 0x04 - Surface Control Register
        volatile uint32_t GPU2D_HWREVISION;  ///< Offset: 0x04 - Hardware Version and Feature Set ID Register
        volatile uint32_t GPU2D_L1START;  ///< Offset: 0x10 - Geometry Register
        volatile uint32_t GPU2D_L2START;  ///< Offset: 0x14 - Geometry Register
        volatile uint32_t GPU2D_L3START;  ///< Offset: 0x18 - Geometry Register
        volatile uint32_t GPU2D_L4START;  ///< Offset: 0x1C - Geometry Register
        volatile uint32_t GPU2D_L5START;  ///< Offset: 0x20 - Geometry Register
        volatile uint32_t GPU2D_L6START;  ///< Offset: 0x24 - Geometry Register
        volatile uint32_t GPU2D_L1XADD;  ///< Offset: 0x28 - Geometry Register
        volatile uint32_t GPU2D_L2XADD;  ///< Offset: 0x2C - Geometry Register
        volatile uint32_t GPU2D_L3XADD;  ///< Offset: 0x30 - Geometry Register
        volatile uint32_t GPU2D_L4XADD;  ///< Offset: 0x34 - Geometry Register
        volatile uint32_t GPU2D_L5XADD;  ///< Offset: 0x38 - Geometry Register
        volatile uint32_t GPU2D_L6XADD;  ///< Offset: 0x3C - Geometry Register
        volatile uint32_t GPU2D_L1YADD;  ///< Offset: 0x40 - Geometry Register
        volatile uint32_t GPU2D_L2YADD;  ///< Offset: 0x44 - Geometry Register
        volatile uint32_t GPU2D_L3YADD;  ///< Offset: 0x48 - Geometry Register
        volatile uint32_t GPU2D_L4YADD;  ///< Offset: 0x4C - Geometry Register
        volatile uint32_t GPU2D_L5YADD;  ///< Offset: 0x50 - Geometry Register
        volatile uint32_t GPU2D_L6YADD;  ///< Offset: 0x54 - Geometry Register
        volatile uint32_t GPU2D_L1BAND;  ///< Offset: 0x58 - Geometry Register
        volatile uint32_t GPU2D_L2BAND;  ///< Offset: 0x5C - Geometry Register
        volatile uint32_t GPU2D_COLOR1;  ///< Offset: 0x64 - Base Color Register
        volatile uint32_t GPU2D_COLOR2;  ///< Offset: 0x68 - Secondary Color Register
        volatile uint32_t GPU2D_PATTERN;  ///< Offset: 0x70 - Pattern Register
        volatile uint32_t GPU2D_SIZE;  ///< Offset: 0x78 - Bounding Box Dimension Register
        volatile uint32_t GPU2D_PITCH;  ///< Offset: 0x7C - Framebuffer Pitch and Spanstore Delay Register
        volatile uint32_t GPU2D_ORIGIN;  ///< Offset: 0x80 - Address of the First Pixel in Framebuffer Register
        volatile uint32_t GPU2D_LUSTART;  ///< Offset: 0x90 - Texture Mapping Register
        volatile uint32_t GPU2D_LUXADD;  ///< Offset: 0x94 - Texture Mapping Register
        volatile uint32_t GPU2D_LUYADD;  ///< Offset: 0x98 - Texture Mapping Register
        volatile uint32_t GPU2D_LVSTARTI;  ///< Offset: 0x9C - Texture Mapping Register
        volatile uint32_t GPU2D_LVSTARTF;  ///< Offset: 0xA0 - Texture Mapping Register
        volatile uint32_t GPU2D_LVXADDI;  ///< Offset: 0xA4 - Texture Mapping Register
        volatile uint32_t GPU2D_LVYADDI;  ///< Offset: 0xA8 - Texture Mapping Register
        volatile uint32_t GPU2D_LVYXADDF;  ///< Offset: 0xAC - Texture Mapping Register
        volatile uint32_t GPU2D_TEXPITCH;  ///< Offset: 0xB4 - Texels per Texture Line Register
        volatile uint32_t GPU2D_TEXMASK;  ///< Offset: 0xB8 - U/V Texture Mask Register
        volatile uint32_t GPU2D_TEXORIGIN;  ///< Offset: 0xBC - Texture Base Address Register
        volatile uint32_t GPU2D_IRQCTL;  ///< Offset: 0xC0 - Interrupt Control Register
        volatile uint32_t GPU2D_CACHECTL;  ///< Offset: 0xC4 - Cache Control Register
        volatile uint32_t GPU2D_DLISTSTART;  ///< Offset: 0xC8 - Display List Start Address Register
        volatile uint32_t GPU2D_PERFCOUNT1;  ///< Offset: 0xCC - Performance Counter 1 Register
        volatile uint32_t GPU2D_PERFCOUNT2;  ///< Offset: 0xD0 - Performance Counter 2 Register
        volatile uint32_t GPU2D_PERFTRIGGER;  ///< Offset: 0xD4 - Performance Counter Control Register
        volatile uint32_t GPU2D_TEXCLUT;  ///< Offset: 0xD8 - CLUT Index Texture Format Register
        volatile uint32_t GPU2D_TEXCLUT_ADDR;  ///< Offset: 0xDC - CLUT Write Address Register
        volatile uint32_t GPU2D_TEXCLUT_DATA;  ///< Offset: 0xE0 - CLUT Write Data Register
        volatile uint32_t GPU2D_TEXCLUT_OFFSET;  ///< Offset: 0xE4 - CLUT Offset Access for Index of Texture Register
        volatile uint32_t GPU2D_COLKEY;  ///< Offset: 0xE8 - Color Keying Register
    };

    /// Peripheral instances
    inline Registers* GPU2D = reinterpret_cast<Registers*>(GPU2D_BASE);

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES0_BASE = 0x83001000;
    constexpr uint32_t AES1_BASE = 0x83003000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t AES_CONTROL;  ///< Offset: 0x00 - AES Control Register
        volatile uint32_t AES_INTERRUPT;  ///< Offset: 0x04 - AES Interrupt Control Register
        volatile uint32_t AES_INTERRUPT_MASK;  ///< Offset: 0x08 - AES Interrupt Mask Register
        volatile uint32_t AES_RXDS_DELAY;  ///< Offset: 0x20 - OSPI RXDS Delay Register
    };

    /// Peripheral instances
    inline Registers* AES0 = reinterpret_cast<Registers*>(AES0_BASE);
    inline Registers* AES1 = reinterpret_cast<Registers*>(AES1_BASE);

}


} // namespace alloy::generated::ae302f40c1537le_cm55_he_view

#endif // ALLOY_GENERATED_AE302F40C1537LE_CM55_HE_VIEW_PERIPHERALS_HPP