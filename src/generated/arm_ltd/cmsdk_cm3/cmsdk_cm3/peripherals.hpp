/// Auto-generated code for CMSDK_CM3
/// Generated by Alloy Code Generator
/// Source: arm_sample_cmsdk.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:52
#ifndef ALLOY_GENERATED_CMSDK_CM3_PERIPHERALS_HPP
#define ALLOY_GENERATED_CMSDK_CM3_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::cmsdk_cm3 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 5;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_fpgaio = true;
    constexpr uint32_t num_fpgaio_instances = 1;
    constexpr bool has_scc = true;
    constexpr uint32_t num_scc_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fpgaio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scc_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x40000000;
    constexpr uint32_t TIMER1_BASE = 0x40001000;
    constexpr uint32_t DUALTIMER_BASE = 0x40002000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t VALUE;  ///< Offset: 0x04 - Current Timer Counter Value
        volatile uint32_t RELOAD;  ///< Offset: 0x08 - Counter Reload Value
        volatile uint32_t INTSTATUS;  ///< Offset: 0x0C - Timer Interrupt status register
        volatile uint32_t INTCLEAR;  ///< Offset: 0x0C - Timer Interrupt clear register
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* DUALTIMER = reinterpret_cast<Registers*>(DUALTIMER_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x40004000;
    constexpr uint32_t UART1_BASE = 0x40005000;
    constexpr uint32_t UART2_BASE = 0x40006000;
    constexpr uint32_t UART3_BASE = 0x40007000;
    constexpr uint32_t UART4_BASE = 0x40009000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - Recieve and Transmit Data Value
        volatile uint32_t STATE;  ///< Offset: 0x04 - UART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - UART Control Register
        volatile uint32_t INTSTATUS;  ///< Offset: 0x0C - UART Interrupt Status Register
        volatile uint32_t INTCLEAR;  ///< Offset: 0x0C - UART Interrupt CLEAR Register
        volatile uint32_t BAUDDIV;  ///< Offset: 0x10 - Baudrate Divider
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO0_BASE = 0x40010000;
    constexpr uint32_t GPIO1_BASE = 0x40011000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - Data Register
        volatile uint32_t DATAOUT;  ///< Offset: 0x04 - Data Output Register
        volatile uint32_t OUTENSET;  ///< Offset: 0x10 - Ouptut enable set Register
        volatile uint32_t OUTENCLR;  ///< Offset: 0x14 - Ouptut enable clear Register
        volatile uint32_t ALTFUNCSET;  ///< Offset: 0x18 - Alternate function set Register
        volatile uint32_t ALTFUNCCLR;  ///< Offset: 0x1C - Alternate function clear Register
        volatile uint32_t INTENSET;  ///< Offset: 0x20 - Interrupt enable set Register
        volatile uint32_t INTENCLR;  ///< Offset: 0x24 - Interrupt enable clear Register
        volatile uint32_t INTTYPESET;  ///< Offset: 0x28 - Interrupt type set Register
        volatile uint32_t INTTYPECLR;  ///< Offset: 0x2C - Interrupt type clear Register
        volatile uint32_t INTPOLSET;  ///< Offset: 0x30 - Polarity-level, edge interrupt configuration set Register
        volatile uint32_t INTPOLCLR;  ///< Offset: 0x34 - Polarity-level, edge interrupt configuration clear Register
        volatile uint32_t INTSTATUS;  ///< Offset: 0x38 - Interrupt Status Register
        volatile uint32_t INTCLEAR;  ///< Offset: 0x38 - Interrupt CLEAR Register
    };

    /// Peripheral instances
    inline Registers* GPIO0 = reinterpret_cast<Registers*>(GPIO0_BASE);
    inline Registers* GPIO1 = reinterpret_cast<Registers*>(GPIO1_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI_BASE = 0x40027000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPSTAT;  ///< Offset: 0x00 - SPI Status
        volatile uint32_t SPDAT;  ///< Offset: 0x02 - SPI Data
        volatile uint32_t SPCLK;  ///< Offset: 0x04 - SPI Clock Configuration
        volatile uint32_t SPCON;  ///< Offset: 0x06 - SPI Configuration
    };

    /// Peripheral instances
    inline Registers* SPI = reinterpret_cast<Registers*>(SPI_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT_BASE = 0x40008000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDOGLOAD;  ///< Offset: 0x00 - Watchdog Load Register
        volatile uint32_t WDOGVALUE;  ///< Offset: 0x04 - Watchdog Value Register
        volatile uint32_t WDOGCONTROL;  ///< Offset: 0x08 - Watchdog Control Register
        volatile uint32_t WDOGINTCLR;  ///< Offset: 0x0C - Watchdog Interrupt Clear Register
        volatile uint32_t WDOGRIS;  ///< Offset: 0x10 - Watchdog Raw Interrupt Status Register
        volatile uint32_t WDOGMIS;  ///< Offset: 0x14 - Watchdog Mask Interrupt Status Register
        volatile uint32_t WDOGLOCK;  ///< Offset: 0xC00 - Watchdog Lock Register
    };

    /// Peripheral instances
    inline Registers* WDT = reinterpret_cast<Registers*>(WDT_BASE);

    // Bit definitions
    /// WDOGCONTROL Register bits
    namespace wdogcontrol_bits {
        constexpr uint32_t INTEN = (1U << 0);  ///< Enable the interrupt event
        constexpr uint32_t RESEN = (1U << 1);  ///< Enable watchdog reset output
    }

    /// WDOGINTCLR Register bits
    namespace wdogintclr_bits {
        constexpr uint32_t INT_ = (1U << 0);  ///< Interrupt (renamed from INT_)
    }

    /// WDOGRIS Register bits
    namespace wdogris_bits {
        constexpr uint32_t RIS = (1U << 0);  ///< Raw watchdog Interrupt
    }

    /// WDOGMIS Register bits
    namespace wdogmis_bits {
        constexpr uint32_t MIS = (1U << 0);  ///< Masked Watchdog Interrupt
    }

}

// ============================================================================
// FPGAIO Peripheral
// ============================================================================

namespace fpgaio {
    /// Base addresses
    constexpr uint32_t FPGAIO_BASE = 0x40028000;

    /// FPGAIO Register structure
    struct Registers {
        volatile uint32_t LED;  ///< Offset: 0x00 - LED Connections
        volatile uint32_t BUTTON;  ///< Offset: 0x08 - Button Connections
        volatile uint32_t CLK1HZ;  ///< Offset: 0x10 - 1Hz Up Counter
        volatile uint32_t CLK100HZ;  ///< Offset: 0x14 - 100Hz Up Counter
        volatile uint32_t COUNTER;  ///< Offset: 0x18 - Cycle up counter
        volatile uint32_t PRESCALER;  ///< Offset: 0x1C - Reload value for prescaler counter
        volatile uint32_t PSCNTR;  ///< Offset: 0x20 - Prescale Counter
        volatile uint32_t MISC;  ///< Offset: 0x4C - Misc. Control
    };

    /// Peripheral instances
    inline Registers* FPGAIO = reinterpret_cast<Registers*>(FPGAIO_BASE);

}

// ============================================================================
// SCC Peripheral
// ============================================================================

namespace scc {
    /// Base addresses
    constexpr uint32_t SCC_BASE = 0x4002F000;

    /// SCC Register structure
    struct Registers {
        volatile uint32_t CFG_REG0;  ///< Offset: 0x00 - 1 = REMAP Block RAM to ZBT
        volatile uint32_t CFG_REG1;  ///< Offset: 0x04 - MCC LEDs: 0 = OFF 1 = ON
        volatile uint32_t CFG_REG2;  ///< Offset: 0x08 - 
        volatile uint32_t CFG_REG3;  ///< Offset: 0x0C - MCC SWITCHES: 0 = OFF 1 = ON
        volatile uint32_t CFG_REG4;  ///< Offset: 0x10 - Board Revision
        volatile uint32_t CFG_REG5;  ///< Offset: 0x14 - Debug: 0 = Serial Wire Debug 1 = JTAG
        volatile uint32_t CFG_REG6;  ///< Offset: 0x18 - 
        volatile uint32_t CFG_REG7;  ///< Offset: 0x1C - 
        volatile uint32_t SYS_CFGDATA_RTN;  ///< Offset: 0xA0 - 
        volatile uint32_t SYS_CFGDATA_OUT;  ///< Offset: 0xA4 - 
        volatile uint32_t SYS_CFGCTRL;  ///< Offset: 0xA8 - Start: generates interrupt on write to this bit
        volatile uint32_t SYS_CFGSTAT;  ///< Offset: 0xAC - Error Flag
        volatile uint32_t DLL;  ///< Offset: 0x100 - DLL Lock Register
        volatile uint32_t AID;  ///< Offset: 0xFF8 - FPGA Build Number
        volatile uint32_t ID;  ///< Offset: 0xFFC - Implementer ID: 0x41 = ARM
    };

    /// Peripheral instances
    inline Registers* SCC = reinterpret_cast<Registers*>(SCC_BASE);

}


} // namespace alloy::generated::cmsdk_cm3

#endif // ALLOY_GENERATED_CMSDK_CM3_PERIPHERALS_HPP