/// Auto-generated code for K210
/// Generated by Alloy Code Generator
/// Source: kendryte-community_k210.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:40
#ifndef ALLOY_GENERATED_K210_PERIPHERALS_HPP
#define ALLOY_GENERATED_K210_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::k210 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_clint = true;
    constexpr uint32_t num_clint_instances = 1;
    constexpr bool has_plic = true;
    constexpr uint32_t num_plic_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 4;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_kpu = true;
    constexpr uint32_t num_kpu_instances = 1;
    constexpr bool has_fft = true;
    constexpr uint32_t num_fft_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 3;
    constexpr bool has_apu = true;
    constexpr uint32_t num_apu_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_fpioa = true;
    constexpr uint32_t num_fpioa_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 2;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 2;
    constexpr bool has_otp = true;
    constexpr uint32_t num_otp_instances = 1;
    constexpr bool has_dvp = true;
    constexpr uint32_t num_dvp_instances = 1;
    constexpr bool has_sysctl = true;
    constexpr uint32_t num_sysctl_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct clint_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct plic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct kpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fft_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct apu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct fpioa_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct otp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dvp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sysctl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uarths = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
}

// ============================================================================
// CLINT Peripheral
// ============================================================================

namespace clint {
    /// Base addresses
    constexpr uint32_t CLINT_BASE = 0x02000000;

    /// CLINT Register structure
    struct Registers {
        volatile uint32_t msip[%s];  ///< Offset: 0x00 - Hart software interrupt register
        volatile uint32_t mtimecmp[%s];  ///< Offset: 0x4000 - Hart time comparator register
        volatile uint32_t mtime;  ///< Offset: 0xBFF8 - Timer register
    };

    /// Peripheral instances
    inline Registers* CLINT = reinterpret_cast<Registers*>(CLINT_BASE);

}

// ============================================================================
// PLIC Peripheral
// ============================================================================

namespace plic {
    /// Base addresses
    constexpr uint32_t PLIC_BASE = 0x0C000000;

    /// PLIC Register structure
    struct Registers {
        volatile uint32_t priority[%s];  ///< Offset: 0x00 - Interrupt Source Priority Register
        volatile uint32_t pending[%s];  ///< Offset: 0x1000 - Interrupt Pending Register
        volatile uint32_t enable[%s];  ///< Offset: 0x00 - Interrupt Enable Register
        volatile uint32_t threshold;  ///< Offset: 0x00 - Priority Threshold Register
        volatile uint32_t claim;  ///< Offset: 0x04 - Claim/Complete Register
        volatile uint32_t _reserved;  ///< Offset: 0xFFC - Padding to make sure targets is an array
    };

    /// Peripheral instances
    inline Registers* PLIC = reinterpret_cast<Registers*>(PLIC_BASE);

    // Bit definitions
    /// threshold Register bits
    namespace threshold_bits {
        constexpr uint32_t priority = (3 << 0);  ///< Never interrupt
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UARTHS_BASE = 0x38000000;
    constexpr uint32_t UART1_BASE = 0x50210000;
    constexpr uint32_t UART2_BASE = 0x50220000;
    constexpr uint32_t UART3_BASE = 0x50230000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t txdata;  ///< Offset: 0x00 - Transmit Data Register
        volatile uint32_t rxdata;  ///< Offset: 0x04 - Receive Data Register
        volatile uint32_t txctrl;  ///< Offset: 0x08 - Transmit Control Register
        volatile uint32_t rxctrl;  ///< Offset: 0x0C - Receive Control Register
        volatile uint32_t ie;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t ip;  ///< Offset: 0x14 - Interrupt Pending Register
        volatile uint32_t div;  ///< Offset: 0x18 - Baud Rate Divisor Register
    };

    /// Peripheral instances
    inline Registers* UARTHS = reinterpret_cast<Registers*>(UARTHS_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOHS_BASE = 0x38001000;
    constexpr uint32_t GPIO_BASE = 0x50200000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t input_val;  ///< Offset: 0x00 - Input Value Register
        volatile uint32_t input_en;  ///< Offset: 0x04 - Pin Input Enable Register
        volatile uint32_t output_en;  ///< Offset: 0x08 - Pin Output Enable Register
        volatile uint32_t output_val;  ///< Offset: 0x0C - Output Value Register
        volatile uint32_t pullup_en;  ///< Offset: 0x10 - Internal Pull-Up Enable Register
        volatile uint32_t drive;  ///< Offset: 0x14 - Drive Strength Register
        volatile uint32_t rise_ie;  ///< Offset: 0x18 - Rise Interrupt Enable Register
        volatile uint32_t rise_ip;  ///< Offset: 0x1C - Rise Interrupt Pending Register
        volatile uint32_t fall_ie;  ///< Offset: 0x20 - Fall Interrupt Enable Register
        volatile uint32_t fall_ip;  ///< Offset: 0x24 - Fall Interrupt Pending Register
        volatile uint32_t high_ie;  ///< Offset: 0x28 - High Interrupt Enable Register
        volatile uint32_t high_ip;  ///< Offset: 0x2C - High Interrupt Pending Register
        volatile uint32_t low_ie;  ///< Offset: 0x30 - Low Interrupt Enable Register
        volatile uint32_t low_ip;  ///< Offset: 0x34 - Low Interrupt Pending Register
        volatile uint32_t iof_en;  ///< Offset: 0x38 - HW I/O Function Enable Register
        volatile uint32_t iof_sel;  ///< Offset: 0x3C - HW I/O Function Select Register
        volatile uint32_t output_xor;  ///< Offset: 0x40 - Output XOR (invert) Register
    };

    /// Peripheral instances
    inline Registers* GPIOHS = reinterpret_cast<Registers*>(GPIOHS_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// input_val Register bits
    namespace input_val_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// input_en Register bits
    namespace input_en_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// output_en Register bits
    namespace output_en_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// output_val Register bits
    namespace output_val_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// pullup_en Register bits
    namespace pullup_en_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// drive Register bits
    namespace drive_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// rise_ie Register bits
    namespace rise_ie_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// rise_ip Register bits
    namespace rise_ip_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// fall_ie Register bits
    namespace fall_ie_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// fall_ip Register bits
    namespace fall_ip_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// high_ie Register bits
    namespace high_ie_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// high_ip Register bits
    namespace high_ip_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// low_ie Register bits
    namespace low_ie_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// low_ip Register bits
    namespace low_ip_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// iof_en Register bits
    namespace iof_en_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// iof_sel Register bits
    namespace iof_sel_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

    /// output_xor Register bits
    namespace output_xor_bits {
        constexpr uint32_t pin%s = (1U << 0);  ///< pin%s
    }

}

// ============================================================================
// KPU Peripheral
// ============================================================================

namespace kpu {
    /// Base addresses
    constexpr uint32_t KPU_BASE = 0x40800000;

    /// KPU Register structure
    struct Registers {
        volatile uint32_t layer_argument_fifo;  ///< Offset: 0x00 - Layer arguments FIFO: each layer is defined by writing...
        volatile uint32_t interrupt_status;  ///< Offset: 0x08 - Interrupt status
        volatile uint32_t interrupt_raw;  ///< Offset: 0x10 - Interrupt raw
        volatile uint32_t interrupt_mask;  ///< Offset: 0x18 - Interrupt mask: 0 enables the interrupt, 1 masks the interrupt
        volatile uint32_t interrupt_clear;  ///< Offset: 0x20 - Interrupt clear: write 1 to a bit to clear interrupt
        volatile uint32_t fifo_threshold;  ///< Offset: 0x28 - FIFO threshold
        volatile uint32_t fifo_data_out;  ///< Offset: 0x30 - FIFO data output
        volatile uint32_t fifo_ctrl;  ///< Offset: 0x38 - FIFO control
        volatile uint32_t eight_bit_mode;  ///< Offset: 0x40 - Eight bit mode
    };

    /// Peripheral instances
    inline Registers* KPU = reinterpret_cast<Registers*>(KPU_BASE);

}

// ============================================================================
// FFT Peripheral
// ============================================================================

namespace fft {
    /// Base addresses
    constexpr uint32_t FFT_BASE = 0x42000000;

    /// FFT Register structure
    struct Registers {
        volatile uint32_t input_fifo;  ///< Offset: 0x00 - FFT input data fifo
        volatile uint32_t ctrl;  ///< Offset: 0x08 - FFT control register
        volatile uint32_t fifo_ctrl;  ///< Offset: 0x10 - FIFO control
        volatile uint32_t intr_mask;  ///< Offset: 0x18 - interrupt mask
        volatile uint32_t intr_clear;  ///< Offset: 0x20 - Interrupt clear
        volatile uint32_t status;  ///< Offset: 0x28 - FFT status register
        volatile uint32_t status_raw;  ///< Offset: 0x30 - FFT status raw
        volatile uint32_t output_fifo;  ///< Offset: 0x38 - FFT output FIFO
    };

    /// Peripheral instances
    inline Registers* FFT = reinterpret_cast<Registers*>(FFT_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMAC_BASE = 0x50000000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t id;  ///< Offset: 0x00 - ID Register
        volatile uint32_t compver;  ///< Offset: 0x08 - COMPVER Register
        volatile uint32_t cfg;  ///< Offset: 0x20 - Configure Register
        volatile uint32_t chen;  ///< Offset: 0x18 - Channel Enable Register
        volatile uint32_t intstatus;  ///< Offset: 0x88 - Channel Interrupt Status Register
        volatile uint32_t com_intclear;  ///< Offset: 0x38 - Common Interrupt Clear Register
        volatile uint32_t com_intstatus_en;  ///< Offset: 0x40 - Common Interrupt Status Enable Register
        volatile uint32_t com_intsignal_en;  ///< Offset: 0x48 - Common Interrupt Signal Enable Register
        volatile uint32_t com_intstatus;  ///< Offset: 0x50 - Common Interrupt Status
        volatile uint32_t reset;  ///< Offset: 0x58 - Reset register
        volatile uint32_t sar;  ///< Offset: 0x00 - SAR Address Register
        volatile uint32_t dar;  ///< Offset: 0x08 - DAR Address Register
        volatile uint32_t block_ts;  ///< Offset: 0x10 - Block Transfer Size Register
        volatile uint32_t ctl;  ///< Offset: 0x18 - Control Register
        volatile uint32_t llp;  ///< Offset: 0x28 - Linked List Pointer register
        volatile uint32_t status;  ///< Offset: 0x30 - Channel Status Register
        volatile uint32_t swhssrc;  ///< Offset: 0x38 - Channel Software handshake Source Register
        volatile uint32_t swhsdst;  ///< Offset: 0x40 - Channel Software handshake Destination Register
        volatile uint32_t blk_tfr;  ///< Offset: 0x48 - Channel Block Transfer Resume Request Register
        volatile uint32_t axi_id;  ///< Offset: 0x50 - Channel AXI ID Register
        volatile uint32_t axi_qos;  ///< Offset: 0x58 - AXI QOS Register
        volatile uint32_t intstatus_en;  ///< Offset: 0x80 - Interrupt Status Enable Register
        volatile uint32_t intsignal_en;  ///< Offset: 0x90 - Interrupt Signal Enable Register
        volatile uint32_t intclear;  ///< Offset: 0x98 - Interrupt Clear Register
        volatile uint32_t _reserved;  ///< Offset: 0xF8 - Padding to make structure size 256 bytes so that...
    };

    /// Peripheral instances
    inline Registers* DMAC = reinterpret_cast<Registers*>(DMAC_BASE);

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x52000000;
    constexpr uint32_t SPI1_BASE = 0x53000000;
    constexpr uint32_t SPI2_BASE = 0x50240000;
    constexpr uint32_t SPI3_BASE = 0x54000000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t ctrlr0;  ///< Offset: 0x00 - Control Register 0
        volatile uint32_t ctrlr1;  ///< Offset: 0x04 - Control Register 1
        volatile uint32_t ssienr;  ///< Offset: 0x08 - Enable Register
        volatile uint32_t mwcr;  ///< Offset: 0x0C - Microwire Control Register
        volatile uint32_t ser;  ///< Offset: 0x10 - Slave Enable Register
        volatile uint32_t baudr;  ///< Offset: 0x14 - Baud Rate Select
        volatile uint32_t txftlr;  ///< Offset: 0x18 - Transmit FIFO Threshold Level
        volatile uint32_t rxftlr;  ///< Offset: 0x1C - Receive FIFO Threshold Level
        volatile uint32_t txflr;  ///< Offset: 0x20 - Transmit FIFO Level Register
        volatile uint32_t rxflr;  ///< Offset: 0x24 - Receive FIFO Level Register
        volatile uint32_t sr;  ///< Offset: 0x28 - Status Register
        volatile uint32_t imr;  ///< Offset: 0x2C - Interrupt Mask Register
        volatile uint32_t isr;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t risr;  ///< Offset: 0x34 - Raw Interrupt Status Register
        volatile uint32_t txoicr;  ///< Offset: 0x38 - Transmit FIFO Overflow Interrupt Clear Register
        volatile uint32_t rxoicr;  ///< Offset: 0x3C - Receive FIFO Overflow Interrupt Clear Register
        volatile uint32_t rxuicr;  ///< Offset: 0x40 - Receive FIFO Underflow Interrupt Clear Register
        volatile uint32_t msticr;  ///< Offset: 0x44 - Multi-Master Interrupt Clear Register
        volatile uint32_t icr;  ///< Offset: 0x48 - Interrupt Clear Register
        volatile uint32_t dmacr;  ///< Offset: 0x4C - DMA Control Register
        volatile uint32_t dmatdlr;  ///< Offset: 0x50 - DMA Transmit Data Level
        volatile uint32_t dmardlr;  ///< Offset: 0x54 - DMA Receive Data Level
        volatile uint32_t idr;  ///< Offset: 0x58 - Identification Register
        volatile uint32_t ssic_version_id;  ///< Offset: 0x5C - DWC_ssi component version
        volatile uint32_t dr%s;  ///< Offset: 0x60 - Data Register
        volatile uint32_t rx_sample_delay;  ///< Offset: 0xF0 - RX Sample Delay Register
        volatile uint32_t spi_ctrlr0;  ///< Offset: 0xF4 - SPI Control Register
        volatile uint32_t xip_mode_bits;  ///< Offset: 0xFC - XIP Mode bits
        volatile uint32_t xip_incr_inst;  ///< Offset: 0x100 - XIP INCR transfer opcode
        volatile uint32_t xip_wrap_inst;  ///< Offset: 0x104 - XIP WRAP transfer opcode
        volatile uint32_t xip_ctrl;  ///< Offset: 0x108 - XIP Control Register
        volatile uint32_t xip_ser;  ///< Offset: 0x10C - XIP Slave Enable Register
        volatile uint32_t xrxoicr;  ///< Offset: 0x110 - XIP Receive FIFO Overflow Interrupt Clear Register
        volatile uint32_t xip_cnt_time_out;  ///< Offset: 0x114 - XIP time out register for continuous transfers
        volatile uint32_t endian;  ///< Offset: 0x118 - ENDIAN
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x50250000;
    constexpr uint32_t I2S1_BASE = 0x50260000;
    constexpr uint32_t I2S2_BASE = 0x50270000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t ier;  ///< Offset: 0x00 - Enable Register
        volatile uint32_t irer;  ///< Offset: 0x04 - Receiver Block Enable Register
        volatile uint32_t iter;  ///< Offset: 0x08 - Transmitter Block Enable Register
        volatile uint32_t cer;  ///< Offset: 0x0C - Clock Generation enable
        volatile uint32_t ccr;  ///< Offset: 0x10 - Clock Configuration Register
        volatile uint32_t rxffr;  ///< Offset: 0x14 - Receiver Block FIFO Reset Register
        volatile uint32_t txffr;  ///< Offset: 0x18 - Transmitter Block FIFO Reset Register
        volatile uint32_t left_rxtx;  ///< Offset: 0x00 - Left Receive or Left Transmit Register
        volatile uint32_t right_rxtx;  ///< Offset: 0x04 - Right Receive or Right Transmit Register
        volatile uint32_t rer;  ///< Offset: 0x08 - Receive Enable Register
        volatile uint32_t ter;  ///< Offset: 0x0C - Transmit Enable Register
        volatile uint32_t rcr;  ///< Offset: 0x10 - Receive Configuration Register
        volatile uint32_t tcr;  ///< Offset: 0x14 - Transmit Configuration Register
        volatile uint32_t isr;  ///< Offset: 0x18 - Interrupt Status Register
        volatile uint32_t imr;  ///< Offset: 0x1C - Interrupt Mask Register
        volatile uint32_t ror;  ///< Offset: 0x20 - Receive Overrun Register
        volatile uint32_t tor;  ///< Offset: 0x24 - Transmit Overrun Register
        volatile uint32_t rfcr;  ///< Offset: 0x28 - Receive FIFO Configuration Register
        volatile uint32_t tfcr;  ///< Offset: 0x2C - Transmit FIFO Configuration Register
        volatile uint32_t rff;  ///< Offset: 0x30 - Receive FIFO Flush Register
        volatile uint32_t tff;  ///< Offset: 0x34 - Transmit FIFO Flush Register
        volatile uint32_t _reserved%s;  ///< Offset: 0x38 - _RESERVED0
        volatile uint32_t rxdma;  ///< Offset: 0x1C0 - Receiver Block DMA Register
        volatile uint32_t rrxdma;  ///< Offset: 0x1C4 - Reset Receiver Block DMA Register
        volatile uint32_t txdma;  ///< Offset: 0x1C8 - Transmitter Block DMA Register
        volatile uint32_t rtxdma;  ///< Offset: 0x1CC - Reset Transmitter Block DMA Register
        volatile uint32_t i2s_comp_param_2;  ///< Offset: 0x1F0 - Component Parameter Register 2
        volatile uint32_t i2s_comp_param_1;  ///< Offset: 0x1F4 - Component Parameter Register 1
        volatile uint32_t i2s_comp_version_1;  ///< Offset: 0x1F8 - Component Version Register
        volatile uint32_t i2s_comp_type;  ///< Offset: 0x1FC - Component Type Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);
    inline Registers* I2S2 = reinterpret_cast<Registers*>(I2S2_BASE);

}

// ============================================================================
// APU Peripheral
// ============================================================================

namespace apu {
    /// Base addresses
    constexpr uint32_t APU_BASE = 0x50250200;

    /// APU Register structure
    struct Registers {
        volatile uint32_t ch_cfg;  ///< Offset: 0x00 - Channel Config Register
        volatile uint32_t ctl;  ///< Offset: 0x04 - Control Register
        volatile uint32_t dir_bidx[%s];  ///< Offset: 0x08 - Direction Sample Buffer Read Index Configure Register...
        volatile uint32_t pre_fir0_coef[%s];  ///< Offset: 0x88 - FIR0 pre-filter coefficients
        volatile uint32_t post_fir0_coef[%s];  ///< Offset: 0xAC - FIR0 post-filter coefficients
        volatile uint32_t pre_fir1_coef[%s];  ///< Offset: 0xD0 - FIR1 pre-filter coeffecients
        volatile uint32_t post_fir1_coef[%s];  ///< Offset: 0xF4 - FIR1 post-filter coefficients
        volatile uint32_t dwsz_cfg;  ///< Offset: 0x118 - Downsize Config Register
        volatile uint32_t fft_cfg;  ///< Offset: 0x11C - FFT Config Register
        volatile uint32_t sobuf_dma_rdata;  ///< Offset: 0x120 - Read register for DMA to sample-out buffers
        volatile uint32_t vobuf_dma_rdata;  ///< Offset: 0x124 - Read register for DMA to voice-out buffers
        volatile uint32_t int_stat;  ///< Offset: 0x128 - Interrupt Status Register
        volatile uint32_t int_mask;  ///< Offset: 0x12C - Interrupt Mask Register
        volatile uint32_t sat_counter;  ///< Offset: 0x130 - Saturation Counter
        volatile uint32_t sat_limits;  ///< Offset: 0x134 - Saturation Limits
    };

    /// Peripheral instances
    inline Registers* APU = reinterpret_cast<Registers*>(APU_BASE);

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x50280000;
    constexpr uint32_t I2C1_BASE = 0x50290000;
    constexpr uint32_t I2C2_BASE = 0x502A0000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t con;  ///< Offset: 0x00 - Control Register
        volatile uint32_t tar;  ///< Offset: 0x04 - Target Address Register
        volatile uint32_t sar;  ///< Offset: 0x08 - Slave Address Register
        volatile uint32_t data_cmd;  ///< Offset: 0x10 - Data Buffer and Command Register
        volatile uint32_t ss_scl_hcnt;  ///< Offset: 0x14 - Standard Speed Clock SCL High Count Register
        volatile uint32_t ss_scl_lcnt;  ///< Offset: 0x18 - Standard Speed Clock SCL Low Count Register
        volatile uint32_t intr_stat;  ///< Offset: 0x2C - Interrupt Status Register
        volatile uint32_t intr_mask;  ///< Offset: 0x30 - Interrupt Mask Register
        volatile uint32_t raw_intr_stat;  ///< Offset: 0x34 - Raw Interrupt Status Register
        volatile uint32_t rx_tl;  ///< Offset: 0x38 - Receive FIFO Threshold Register
        volatile uint32_t tx_tl;  ///< Offset: 0x3C - Transmit FIFO Threshold Register
        volatile uint32_t clr_intr;  ///< Offset: 0x40 - Clear Combined and Individual Interrupt Register
        volatile uint32_t clr_rx_under;  ///< Offset: 0x44 - Clear RX_UNDER Interrupt Register
        volatile uint32_t clr_rx_over;  ///< Offset: 0x48 - Clear RX_OVER Interrupt Register
        volatile uint32_t clr_tx_over;  ///< Offset: 0x4C - Clear TX_OVER Interrupt Register
        volatile uint32_t clr_rd_req;  ///< Offset: 0x50 - Clear RD_REQ Interrupt Register
        volatile uint32_t clr_tx_abrt;  ///< Offset: 0x54 - Clear TX_ABRT Interrupt Register
        volatile uint32_t clr_rx_done;  ///< Offset: 0x58 - Clear RX_DONE Interrupt Register
        volatile uint32_t clr_activity;  ///< Offset: 0x5C - Clear ACTIVITY Interrupt Register
        volatile uint32_t clr_stop_det;  ///< Offset: 0x60 - Clear STOP_DET Interrupt Register
        volatile uint32_t clr_start_det;  ///< Offset: 0x64 - Clear START_DET Interrupt Register
        volatile uint32_t clr_gen_call;  ///< Offset: 0x68 - I2C Clear GEN_CALL Interrupt Register
        volatile uint32_t enable;  ///< Offset: 0x6C - Enable Register
        volatile uint32_t status;  ///< Offset: 0x70 - Status Register
        volatile uint32_t txflr;  ///< Offset: 0x74 - Transmit FIFO Level Register
        volatile uint32_t rxflr;  ///< Offset: 0x78 - Receive FIFO Level Register
        volatile uint32_t sda_hold;  ///< Offset: 0x7C - SDA Hold Time Length Register
        volatile uint32_t tx_abrt_source;  ///< Offset: 0x80 - Transmit Abort Source Register
        volatile uint32_t dma_cr;  ///< Offset: 0x88 - I2C DMA Control Register
        volatile uint32_t dma_tdlr;  ///< Offset: 0x8C - DMA Transmit Data Level Register
        volatile uint32_t dma_rdlr;  ///< Offset: 0x90 - DMA Receive Data Level Register
        volatile uint32_t sda_setup;  ///< Offset: 0x94 - SDA Setup Register
        volatile uint32_t general_call;  ///< Offset: 0x98 - ACK General Call Register
        volatile uint32_t enable_status;  ///< Offset: 0x9C - Enable Status Register
        volatile uint32_t fs_spklen;  ///< Offset: 0xA0 - SS, FS or FM+ spike suppression limit
        volatile uint32_t comp_param_1;  ///< Offset: 0xF4 - Component Parameter Register 1
        volatile uint32_t comp_version;  ///< Offset: 0xF8 - Component Version Register
        volatile uint32_t comp_type;  ///< Offset: 0xFC - Component Type Register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

}

// ============================================================================
// FPIOA Peripheral
// ============================================================================

namespace fpioa {
    /// Base addresses
    constexpr uint32_t FPIOA_BASE = 0x502B0000;

    /// FPIOA Register structure
    struct Registers {
        volatile uint32_t io[%s];  ///< Offset: 0x00 - FPIOA GPIO multiplexer io array
        volatile uint32_t tie_en[%s];  ///< Offset: 0xC0 - FPIOA GPIO multiplexer tie enable array
        volatile uint32_t tie_val[%s];  ///< Offset: 0xE0 - FPIOA GPIO multiplexer tie value array
    };

    /// Peripheral instances
    inline Registers* FPIOA = reinterpret_cast<Registers*>(FPIOA_BASE);

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t SHA256_BASE = 0x502C0000;
    constexpr uint32_t AES_BASE = 0x50450000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t result[%s];  ///< Offset: 0x00 - Calculated SHA256 return value
        volatile uint32_t data_in;  ///< Offset: 0x20 - SHA256 input data is written to this register
        volatile uint32_t num_reg;  ///< Offset: 0x28 - Counters register
        volatile uint32_t function_reg_0;  ///< Offset: 0x2C - Function configuration register 0
        volatile uint32_t function_reg_1;  ///< Offset: 0x34 - Function configuration register 1
    };

    /// Peripheral instances
    inline Registers* SHA256 = reinterpret_cast<Registers*>(SHA256_BASE);
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIMER0_BASE = 0x502D0000;
    constexpr uint32_t TIMER1_BASE = 0x502E0000;
    constexpr uint32_t TIMER2_BASE = 0x502F0000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t load_count;  ///< Offset: 0x00 - Load Count Register
        volatile uint32_t current_value;  ///< Offset: 0x04 - Current Value Register
        volatile uint32_t control;  ///< Offset: 0x08 - Control Register
        volatile uint32_t eoi;  ///< Offset: 0xA4 - Interrupt Clear Register
        volatile uint32_t intr_stat;  ///< Offset: 0xA0 - Interrupt Status Register
        volatile uint32_t raw_intr_stat;  ///< Offset: 0xA8 - Raw Interrupt Status Register
        volatile uint32_t comp_version;  ///< Offset: 0xAC - Component Version Register
        volatile uint32_t load_count2%s;  ///< Offset: 0xB0 - Load Count2 Register
    };

    /// Peripheral instances
    inline Registers* TIMER0 = reinterpret_cast<Registers*>(TIMER0_BASE);
    inline Registers* TIMER1 = reinterpret_cast<Registers*>(TIMER1_BASE);
    inline Registers* TIMER2 = reinterpret_cast<Registers*>(TIMER2_BASE);

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDT0_BASE = 0x50400000;
    constexpr uint32_t WDT1_BASE = 0x50410000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t cr;  ///< Offset: 0x00 - Control Register
        volatile uint32_t torr;  ///< Offset: 0x04 - Timeout Range Register
        volatile uint32_t ccvr;  ///< Offset: 0x08 - Current Counter Value Register
        volatile uint32_t crr;  ///< Offset: 0x0C - Counter Restart Register
        volatile uint32_t stat;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t eoi;  ///< Offset: 0x14 - Interrupt Clear Register
        volatile uint32_t prot_level;  ///< Offset: 0x1C - Protection level Register
        volatile uint32_t comp_param_5;  ///< Offset: 0xE4 - Component Parameters Register 5
        volatile uint32_t comp_param_4;  ///< Offset: 0xE8 - Component Parameters Register 4
        volatile uint32_t comp_param_3;  ///< Offset: 0xEC - Component Parameters Register 3
        volatile uint32_t comp_param_2;  ///< Offset: 0xF0 - Component Parameters Register 2
        volatile uint32_t comp_param_1;  ///< Offset: 0xF4 - Component Parameters Register 1
        volatile uint32_t comp_version;  ///< Offset: 0xF8 - Component Version Register
        volatile uint32_t comp_type;  ///< Offset: 0xFC - Component Type Register
    };

    /// Peripheral instances
    inline Registers* WDT0 = reinterpret_cast<Registers*>(WDT0_BASE);
    inline Registers* WDT1 = reinterpret_cast<Registers*>(WDT1_BASE);

}

// ============================================================================
// OTP Peripheral
// ============================================================================

namespace otp {
    /// Base addresses
    constexpr uint32_t OTP_BASE = 0x50420000;

    /// OTP Register structure
    struct Registers {
        volatile uint32_t dummy;  ///< Offset: 0x00 - Dummy register: this peripheral is not implemented yet
    };

    /// Peripheral instances
    inline Registers* OTP = reinterpret_cast<Registers*>(OTP_BASE);

}

// ============================================================================
// DVP Peripheral
// ============================================================================

namespace dvp {
    /// Base addresses
    constexpr uint32_t DVP_BASE = 0x50430000;

    /// DVP Register structure
    struct Registers {
        volatile uint32_t dvp_cfg;  ///< Offset: 0x00 - Config Register
        volatile uint32_t r_addr;  ///< Offset: 0x04 - R_ADDR
        volatile uint32_t g_addr;  ///< Offset: 0x08 - G_ADDR
        volatile uint32_t b_addr;  ///< Offset: 0x0C - B_ADDR
        volatile uint32_t cmos_cfg;  ///< Offset: 0x10 - CMOS Config Register
        volatile uint32_t sccb_cfg;  ///< Offset: 0x14 - SCCB Config Register
        volatile uint32_t sccb_ctl;  ///< Offset: 0x18 - SCCB Control Register
        volatile uint32_t axi;  ///< Offset: 0x1C - AXI Register
        volatile uint32_t sts;  ///< Offset: 0x20 - STS Register
        volatile uint32_t reverse;  ///< Offset: 0x24 - REVERSE
        volatile uint32_t rgb_addr;  ///< Offset: 0x28 - RGB_ADDR
    };

    /// Peripheral instances
    inline Registers* DVP = reinterpret_cast<Registers*>(DVP_BASE);

}

// ============================================================================
// SYSCTL Peripheral
// ============================================================================

namespace sysctl {
    /// Base addresses
    constexpr uint32_t SYSCTL_BASE = 0x50440000;

    /// SYSCTL Register structure
    struct Registers {
        volatile uint32_t git_id;  ///< Offset: 0x00 - Git short commit id
        volatile uint32_t clk_freq;  ///< Offset: 0x04 - System clock base frequency
        volatile uint32_t pll0;  ///< Offset: 0x08 - PLL0 controller
        volatile uint32_t pll1;  ///< Offset: 0x0C - PLL1 controller
        volatile uint32_t pll2;  ///< Offset: 0x10 - PLL2 controller
        volatile uint32_t pll_lock;  ///< Offset: 0x18 - PLL lock tester
        volatile uint32_t rom_error;  ///< Offset: 0x1C - AXI ROM detector
        volatile uint32_t clk_sel0;  ///< Offset: 0x20 - Clock select controller 0
        volatile uint32_t clk_sel1;  ///< Offset: 0x24 - Clock select controller 1
        volatile uint32_t clk_en_cent;  ///< Offset: 0x28 - Central clock enable
        volatile uint32_t clk_en_peri;  ///< Offset: 0x2C - Peripheral clock enable
        volatile uint32_t soft_reset;  ///< Offset: 0x30 - Soft reset ctrl
        volatile uint32_t peri_reset;  ///< Offset: 0x34 - Peripheral reset controller
        volatile uint32_t clk_th0;  ///< Offset: 0x38 - Clock threshold controller 0
        volatile uint32_t clk_th1;  ///< Offset: 0x3C - Clock threshold controller 1
        volatile uint32_t clk_th2;  ///< Offset: 0x40 - Clock threshold controller 2
        volatile uint32_t clk_th3;  ///< Offset: 0x44 - Clock threshold controller 3
        volatile uint32_t clk_th4;  ///< Offset: 0x48 - Clock threshold controller 4
        volatile uint32_t clk_th5;  ///< Offset: 0x4C - Clock threshold controller 5
        volatile uint32_t clk_th6;  ///< Offset: 0x50 - Clock threshold controller 6
        volatile uint32_t misc;  ///< Offset: 0x54 - Miscellaneous controller
        volatile uint32_t peri;  ///< Offset: 0x58 - Peripheral controller
        volatile uint32_t spi_sleep;  ///< Offset: 0x5C - SPI sleep controller
        volatile uint32_t reset_status;  ///< Offset: 0x60 - Reset source status
        volatile uint32_t dma_sel0;  ///< Offset: 0x64 - DMA handshake selector
        volatile uint32_t dma_sel1;  ///< Offset: 0x68 - DMA handshake selector
        volatile uint32_t power_sel;  ///< Offset: 0x6C - IO Power Mode Select controller
    };

    /// Peripheral instances
    inline Registers* SYSCTL = reinterpret_cast<Registers*>(SYSCTL_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x50460000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t date;  ///< Offset: 0x00 - Timer date information
        volatile uint32_t time;  ///< Offset: 0x04 - Timer time information
        volatile uint32_t alarm_date;  ///< Offset: 0x08 - Alarm date information
        volatile uint32_t alarm_time;  ///< Offset: 0x0C - Alarm time information
        volatile uint32_t initial_count;  ///< Offset: 0x10 - Timer counter initial value
        volatile uint32_t current_count;  ///< Offset: 0x14 - Timer counter current value
        volatile uint32_t interrupt_ctrl;  ///< Offset: 0x18 - RTC interrupt settings
        volatile uint32_t register_ctrl;  ///< Offset: 0x1C - RTC register settings
        volatile uint32_t extended;  ///< Offset: 0x28 - Timer extended information
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

}


} // namespace alloy::generated::k210

#endif // ALLOY_GENERATED_K210_PERIPHERALS_HPP