/// Auto-generated code for psoc63
/// Generated by Alloy Code Generator
/// Source: cypress_psoc63.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:14
#ifndef ALLOY_GENERATED_PSOC63_PERIPHERALS_HPP
#define ALLOY_GENERATED_PSOC63_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::psoc63 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_peri = true;
    constexpr uint32_t num_peri_instances = 1;
    constexpr bool has_cpuss = true;
    constexpr uint32_t num_cpuss_instances = 1;
    constexpr bool has_fault = true;
    constexpr uint32_t num_fault_instances = 1;
    constexpr bool has_ipc = true;
    constexpr uint32_t num_ipc_instances = 1;
    constexpr bool has_prot = true;
    constexpr uint32_t num_prot_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_srss = true;
    constexpr uint32_t num_srss_instances = 1;
    constexpr bool has_backup = true;
    constexpr uint32_t num_backup_instances = 1;
    constexpr bool has_dw0 = true;
    constexpr uint32_t num_dw0_instances = 1;
    constexpr bool has_dw1 = true;
    constexpr uint32_t num_dw1_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_profile = true;
    constexpr uint32_t num_profile_instances = 1;
    constexpr bool has_hsiom = true;
    constexpr uint32_t num_hsiom_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_smartio = true;
    constexpr uint32_t num_smartio_instances = 1;
    constexpr bool has_lpcomp = true;
    constexpr uint32_t num_lpcomp_instances = 1;
    constexpr bool has_csd0 = true;
    constexpr uint32_t num_csd0_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 2;
    constexpr bool has_lcd0 = true;
    constexpr uint32_t num_lcd0_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_smif0 = true;
    constexpr uint32_t num_smif0_instances = 1;
    constexpr bool has_scb0 = true;
    constexpr uint32_t num_scb0_instances = 1;
    constexpr bool has_scb1 = true;
    constexpr uint32_t num_scb1_instances = 1;
    constexpr bool has_scb2 = true;
    constexpr uint32_t num_scb2_instances = 1;
    constexpr bool has_scb3 = true;
    constexpr uint32_t num_scb3_instances = 1;
    constexpr bool has_scb4 = true;
    constexpr uint32_t num_scb4_instances = 1;
    constexpr bool has_scb5 = true;
    constexpr uint32_t num_scb5_instances = 1;
    constexpr bool has_scb6 = true;
    constexpr uint32_t num_scb6_instances = 1;
    constexpr bool has_scb7 = true;
    constexpr uint32_t num_scb7_instances = 1;
    constexpr bool has_scb8 = true;
    constexpr uint32_t num_scb8_instances = 1;
    constexpr bool has_ctbm0 = true;
    constexpr uint32_t num_ctbm0_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_sar = true;
    constexpr uint32_t num_sar_instances = 1;
    constexpr bool has_pass = true;
    constexpr uint32_t num_pass_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_pdm0 = true;
    constexpr uint32_t num_pdm0_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct peri_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cpuss_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fault_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ipc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct prot_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct srss_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct backup_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dw0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dw1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct profile_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hsiom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smartio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lpcomp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct csd0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct lcd0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smif0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb4_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb5_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb6_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb7_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scb8_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ctbm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sar_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pass_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdm0_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
}

// ============================================================================
// PERI Peripheral
// ============================================================================

namespace peri {
    /// Base addresses
    constexpr uint32_t PERI_BASE = 0x40010000;

    /// PERI Register structure
    struct Registers {
        volatile uint32_t CLOCK_CTL;  ///< Offset: 0x00 - Clock control
        volatile uint32_t SL_CTL;  ///< Offset: 0x20 - Slave control
        volatile uint32_t TIMEOUT_CTL;  ///< Offset: 0x24 - Timeout control
        volatile uint32_t DIV_CMD;  ///< Offset: 0x400 - Divider command register
        volatile uint32_t DIV_8_CTL__;  ///< Offset: 0x800 - Divider control register (for 8.0 divider) (renamed from DIV_8_CTL__)
        volatile uint32_t DIV_16_CTL__;  ///< Offset: 0x900 - Divider control register (for 16.0 divider) (renamed from DIV_16_CTL__)
        volatile uint32_t DIV_16_5_CTL__;  ///< Offset: 0xA00 - Divider control register (for 16.5 divider) (renamed from DIV_16_5_CTL__)
        volatile uint32_t DIV_24_5_CTL__;  ///< Offset: 0xB00 - Divider control register (for 24.5 divider) (renamed from DIV_24_5_CTL__)
        volatile uint32_t CLOCK_CTL__;  ///< Offset: 0xC00 - Clock control register (renamed from CLOCK_CTL__)
        volatile uint32_t TR_CMD;  ///< Offset: 0x1000 - Trigger command register
        volatile uint32_t TR_OUT_CTL__;  ///< Offset: 0x00 - Trigger control register (renamed from TR_OUT_CTL__)
        volatile uint32_t ADDR0;  ///< Offset: 0x00 - PPU region address 0 (slave structure)
        volatile uint32_t ATT0;  ///< Offset: 0x04 - PPU region attributes 0 (slave structure)
        volatile uint32_t ADDR1;  ///< Offset: 0x20 - PPU region address 1 (master structure)
        volatile uint32_t ATT1;  ///< Offset: 0x24 - PPU region attributes 1 (master structure)
    };

    /// Peripheral instances
    inline Registers* PERI = reinterpret_cast<Registers*>(PERI_BASE);

}

// ============================================================================
// CPUSS Peripheral
// ============================================================================

namespace cpuss {
    /// Base addresses
    constexpr uint32_t CPUSS_BASE = 0x40210000;

    /// CPUSS Register structure
    struct Registers {
        volatile uint32_t CM0_CTL;  ///< Offset: 0x00 - CM0+ control
        volatile uint32_t CM0_STATUS;  ///< Offset: 0x08 - CM0+ status
        volatile uint32_t CM0_CLOCK_CTL;  ///< Offset: 0x10 - CM0+ clock control
        volatile uint32_t CM0_INT_CTL0;  ///< Offset: 0x20 - CM0+ interrupt control 0
        volatile uint32_t CM0_INT_CTL1;  ///< Offset: 0x24 - CM0+ interrupt control 1
        volatile uint32_t CM0_INT_CTL2;  ///< Offset: 0x28 - CM0+ interrupt control 2
        volatile uint32_t CM0_INT_CTL3;  ///< Offset: 0x2C - CM0+ interrupt control 3
        volatile uint32_t CM0_INT_CTL4;  ///< Offset: 0x30 - CM0+ interrupt control 4
        volatile uint32_t CM0_INT_CTL5;  ///< Offset: 0x34 - CM0+ interrupt control 5
        volatile uint32_t CM0_INT_CTL6;  ///< Offset: 0x38 - CM0+ interrupt control 6
        volatile uint32_t CM0_INT_CTL7;  ///< Offset: 0x3C - CM0+ interrupt control 7
        volatile uint32_t CM4_PWR_CTL;  ///< Offset: 0x80 - CM4 power control
        volatile uint32_t CM4_PWR_DELAY_CTL;  ///< Offset: 0x84 - CM4 power control
        volatile uint32_t CM4_STATUS;  ///< Offset: 0x88 - CM4 status
        volatile uint32_t CM4_CLOCK_CTL;  ///< Offset: 0x90 - CM4 clock control
        volatile uint32_t CM4_NMI_CTL;  ///< Offset: 0xA0 - CM4 NMI control
        volatile uint32_t RAM0_CTL0;  ///< Offset: 0x100 - RAM 0 control 0
        volatile uint32_t RAM0_PWR_MACRO_CTL__;  ///< Offset: 0x140 - RAM 0 power control (renamed from RAM0_PWR_MACRO_CTL__)
        volatile uint32_t RAM1_CTL0;  ///< Offset: 0x180 - RAM 1 control 0
        volatile uint32_t RAM1_PWR_CTL;  ///< Offset: 0x190 - RAM1 power control
        volatile uint32_t RAM2_CTL0;  ///< Offset: 0x1A0 - RAM 2 control 0
        volatile uint32_t RAM2_PWR_CTL;  ///< Offset: 0x1B0 - RAM2 power control
        volatile uint32_t RAM_PWR_DELAY_CTL;  ///< Offset: 0x1C0 - Power up delay used for all SRAM power domains
        volatile uint32_t ROM_CTL;  ///< Offset: 0x1D0 - ROM control
        volatile uint32_t UDB_PWR_CTL;  ///< Offset: 0x1F0 - UDB power control
        volatile uint32_t UDB_PWR_DELAY_CTL;  ///< Offset: 0x1F4 - UDB power control
        volatile uint32_t DP_STATUS;  ///< Offset: 0x208 - Debug port status
        volatile uint32_t BUFF_CTL;  ///< Offset: 0x220 - Buffer control
        volatile uint32_t DDFT_CTL;  ///< Offset: 0x230 - DDFT control
        volatile uint32_t SYSTICK_CTL;  ///< Offset: 0x240 - SysTick timer control
        volatile uint32_t CM0_VECTOR_TABLE_BASE;  ///< Offset: 0x2B0 - CM0+ vector table base
        volatile uint32_t CM4_VECTOR_TABLE_BASE;  ///< Offset: 0x2C0 - CM4 vector table base
        volatile uint32_t CM0_PC0_HANDLER;  ///< Offset: 0x320 - CM0+ protection context 0 handler
        volatile uint32_t IDENTITY;  ///< Offset: 0x400 - Identity
        volatile uint32_t PROTECTION;  ///< Offset: 0x500 - Protection status
        volatile uint32_t CM0_NMI_CTL;  ///< Offset: 0x520 - CM0+ NMI control
        volatile uint32_t MBIST_STAT;  ///< Offset: 0x5A0 - Memory BIST status
        volatile uint32_t TRIM_ROM_CTL;  ///< Offset: 0xF000 - ROM trim control
        volatile uint32_t TRIM_RAM_CTL;  ///< Offset: 0xF004 - RAM trim control
    };

    /// Peripheral instances
    inline Registers* CPUSS = reinterpret_cast<Registers*>(CPUSS_BASE);

}

// ============================================================================
// FAULT Peripheral
// ============================================================================

namespace fault {
    /// Base addresses
    constexpr uint32_t FAULT_BASE = 0x40220000;

    /// FAULT Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Fault control
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Fault status
        volatile uint32_t DATA__;  ///< Offset: 0x10 - Fault data (renamed from DATA__)
        volatile uint32_t PENDING0;  ///< Offset: 0x40 - Fault pending 0
        volatile uint32_t PENDING1;  ///< Offset: 0x44 - Fault pending 1
        volatile uint32_t PENDING2;  ///< Offset: 0x48 - Fault pending 2
        volatile uint32_t MASK0;  ///< Offset: 0x50 - Fault mask 0
        volatile uint32_t MASK1;  ///< Offset: 0x54 - Fault mask 1
        volatile uint32_t MASK2;  ///< Offset: 0x58 - Fault mask 2
        volatile uint32_t INTR;  ///< Offset: 0xC0 - Interrupt
        volatile uint32_t INTR_SET;  ///< Offset: 0xC4 - Interrupt set
        volatile uint32_t INTR_MASK;  ///< Offset: 0xC8 - Interrupt mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0xCC - Interrupt masked
    };

    /// Peripheral instances
    inline Registers* FAULT = reinterpret_cast<Registers*>(FAULT_BASE);

}

// ============================================================================
// IPC Peripheral
// ============================================================================

namespace ipc {
    /// Base addresses
    constexpr uint32_t IPC_BASE = 0x40230000;

    /// IPC Register structure
    struct Registers {
        volatile uint32_t ACQUIRE;  ///< Offset: 0x00 - IPC acquire
        volatile uint32_t RELEASE;  ///< Offset: 0x04 - IPC release
        volatile uint32_t NOTIFY;  ///< Offset: 0x08 - IPC notification
        volatile uint32_t DATA;  ///< Offset: 0x0C - IPC data
        volatile uint32_t LOCK_STATUS;  ///< Offset: 0x10 - IPC lock status
        volatile uint32_t INTR;  ///< Offset: 0x00 - Interrupt
        volatile uint32_t INTR_SET;  ///< Offset: 0x04 - Interrupt set
        volatile uint32_t INTR_MASK;  ///< Offset: 0x08 - Interrupt mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x0C - Interrupt masked
    };

    /// Peripheral instances
    inline Registers* IPC = reinterpret_cast<Registers*>(IPC_BASE);

}

// ============================================================================
// PROT Peripheral
// ============================================================================

namespace prot {
    /// Base addresses
    constexpr uint32_t PROT_BASE = 0x40240000;

    /// PROT Register structure
    struct Registers {
        volatile uint32_t MS0_CTL;  ///< Offset: 0x00 - Master 0 protection context control
        volatile uint32_t MS1_CTL;  ///< Offset: 0x04 - Master 1 protection context control
        volatile uint32_t MS2_CTL;  ///< Offset: 0x08 - Master 2 protection context control
        volatile uint32_t MS3_CTL;  ///< Offset: 0x0C - Master 3 protection context control
        volatile uint32_t MS4_CTL;  ///< Offset: 0x10 - Master 4 protection context control
        volatile uint32_t MS5_CTL;  ///< Offset: 0x14 - Master 5 protection context control
        volatile uint32_t MS6_CTL;  ///< Offset: 0x18 - Master 6 protection context control
        volatile uint32_t MS7_CTL;  ///< Offset: 0x1C - Master 7 protection context control
        volatile uint32_t MS8_CTL;  ///< Offset: 0x20 - Master 8 protection context control
        volatile uint32_t MS9_CTL;  ///< Offset: 0x24 - Master 9 protection context control
        volatile uint32_t MS10_CTL;  ///< Offset: 0x28 - Master 10 protection context control
        volatile uint32_t MS11_CTL;  ///< Offset: 0x2C - Master 11 protection context control
        volatile uint32_t MS12_CTL;  ///< Offset: 0x30 - Master 12 protection context control
        volatile uint32_t MS13_CTL;  ///< Offset: 0x34 - Master 13 protection context control
        volatile uint32_t MS14_CTL;  ///< Offset: 0x38 - Master 14 protection context control
        volatile uint32_t MS15_CTL;  ///< Offset: 0x3C - Master 15 protection context control
        volatile uint32_t ADDR0;  ///< Offset: 0x00 - SMPU region address 0 (slave structure)
        volatile uint32_t ATT0;  ///< Offset: 0x04 - SMPU region attributes 0 (slave structure)
        volatile uint32_t ADDR1;  ///< Offset: 0x20 - SMPU region address 1 (master structure)
        volatile uint32_t ATT1;  ///< Offset: 0x24 - SMPU region attributes 1 (master structure)
        volatile uint32_t MS_CTL;  ///< Offset: 0x00 - Master control
        volatile uint32_t ADDR;  ///< Offset: 0x00 - MPU region address
        volatile uint32_t ATT;  ///< Offset: 0x04 - MPU region attrributes
    };

    /// Peripheral instances
    inline Registers* PROT = reinterpret_cast<Registers*>(PROT_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASHC_BASE = 0x40250000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t FLASH_PWR_CTL;  ///< Offset: 0x04 - Flash power control
        volatile uint32_t FLASH_CMD;  ///< Offset: 0x08 - Command
        volatile uint32_t BIST_CTL;  ///< Offset: 0x100 - BIST control
        volatile uint32_t BIST_CMD;  ///< Offset: 0x104 - BIST command
        volatile uint32_t BIST_ADDR_START;  ///< Offset: 0x108 - BIST address start register
        volatile uint32_t BIST_DATA__;  ///< Offset: 0x10C - BIST data register(s) (renamed from BIST_DATA__)
        volatile uint32_t BIST_DATA_ACT__;  ///< Offset: 0x12C - BIST data actual register(s) (renamed from BIST_DATA_ACT__)
        volatile uint32_t BIST_DATA_EXP__;  ///< Offset: 0x14C - BIST data expected register(s) (renamed from BIST_DATA_EXP__)
        volatile uint32_t BIST_ADDR;  ///< Offset: 0x16C - BIST address register
        volatile uint32_t BIST_STATUS;  ///< Offset: 0x170 - BIST status register
        volatile uint32_t CM0_CA_CTL0;  ///< Offset: 0x400 - CM0+ cache control
        volatile uint32_t CM0_CA_CTL1;  ///< Offset: 0x404 - CM0+ cache control
        volatile uint32_t CM0_CA_CTL2;  ///< Offset: 0x408 - CM0+ cache control
        volatile uint32_t CM0_CA_CMD;  ///< Offset: 0x40C - CM0+ cache command
        volatile uint32_t CM0_CA_STATUS0;  ///< Offset: 0x440 - CM0+ cache status 0
        volatile uint32_t CM0_CA_STATUS1;  ///< Offset: 0x444 - CM0+ cache status 1
        volatile uint32_t CM0_CA_STATUS2;  ///< Offset: 0x448 - CM0+ cache status 2
        volatile uint32_t CM4_CA_CTL0;  ///< Offset: 0x480 - CM4 cache control
        volatile uint32_t CM4_CA_CTL1;  ///< Offset: 0x484 - CM4 cache control
        volatile uint32_t CM4_CA_CTL2;  ///< Offset: 0x488 - CM4 cache control
        volatile uint32_t CM4_CA_CMD;  ///< Offset: 0x48C - CM4 cache command
        volatile uint32_t CM4_CA_STATUS0;  ///< Offset: 0x4C0 - CM4 cache status 0
        volatile uint32_t CM4_CA_STATUS1;  ///< Offset: 0x4C4 - CM4 cache status 1
        volatile uint32_t CM4_CA_STATUS2;  ///< Offset: 0x4C8 - CM4 cache status 2
        volatile uint32_t CRYPTO_BUFF_CTL;  ///< Offset: 0x500 - Cryptography buffer control
        volatile uint32_t CRYPTO_BUFF_CMD;  ///< Offset: 0x508 - Cryptography buffer command
        volatile uint32_t DW0_BUFF_CTL;  ///< Offset: 0x580 - Datawire 0 buffer control
        volatile uint32_t DW0_BUFF_CMD;  ///< Offset: 0x588 - Datawire 0 buffer command
        volatile uint32_t DW1_BUFF_CTL;  ///< Offset: 0x600 - Datawire 1 buffer control
        volatile uint32_t DW1_BUFF_CMD;  ///< Offset: 0x608 - Datawire 1 buffer command
        volatile uint32_t DAP_BUFF_CTL;  ///< Offset: 0x680 - Debug access port buffer control
        volatile uint32_t DAP_BUFF_CMD;  ///< Offset: 0x688 - Debug access port buffer command
        volatile uint32_t EXT_MS0_BUFF_CTL;  ///< Offset: 0x700 - External master 0 buffer control
        volatile uint32_t EXT_MS0_BUFF_CMD;  ///< Offset: 0x708 - External master 0 buffer command
        volatile uint32_t EXT_MS1_BUFF_CTL;  ///< Offset: 0x780 - External master 1 buffer control
        volatile uint32_t EXT_MS1_BUFF_CMD;  ///< Offset: 0x788 - External master 1 buffer command
        volatile uint32_t FM_CTL;  ///< Offset: 0x00 - Flash macro control
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Status
        volatile uint32_t FM_ADDR;  ///< Offset: 0x08 - Flash macro address
        volatile uint32_t GEOMETRY;  ///< Offset: 0x0C - Regular flash geometry
        volatile uint32_t GEOMETRY_SUPERVISORY;  ///< Offset: 0x10 - Supervisory flash geometry
        volatile uint32_t TIMER_CTL;  ///< Offset: 0x14 - Timer control
        volatile uint32_t ANA_CTL0;  ///< Offset: 0x18 - Analog control 0
        volatile uint32_t ANA_CTL1;  ///< Offset: 0x1C - Analog control 1
        volatile uint32_t GEOMETRY_GEN;  ///< Offset: 0x20 - N/A, DNU
        volatile uint32_t TEST_CTL;  ///< Offset: 0x24 - Test mode control
        volatile uint32_t WAIT_CTL;  ///< Offset: 0x28 - Wiat State control
        volatile uint32_t MONITOR_STATUS;  ///< Offset: 0x2C - Monitor Status
        volatile uint32_t SCRATCH_CTL;  ///< Offset: 0x30 - Scratch Control
        volatile uint32_t HV_CTL;  ///< Offset: 0x34 - High voltage control
        volatile uint32_t ACLK_CTL;  ///< Offset: 0x38 - Aclk control
        volatile uint32_t INTR;  ///< Offset: 0x3C - Interrupt
        volatile uint32_t INTR_SET;  ///< Offset: 0x40 - Interrupt set
        volatile uint32_t INTR_MASK;  ///< Offset: 0x44 - Interrupt mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x48 - Interrupt masked
        volatile uint32_t FM_HV_DATA_ALL;  ///< Offset: 0x4C - Flash macro high Voltage page latches data (for all page latches)
        volatile uint32_t CAL_CTL0;  ///< Offset: 0x50 - Cal control BG LO trim bits
        volatile uint32_t CAL_CTL1;  ///< Offset: 0x54 - Cal control BG HI trim bits
        volatile uint32_t CAL_CTL2;  ///< Offset: 0x58 - Cal control BG LO&HI ipref trim, ref sel, fm_active, turbo_ext
        volatile uint32_t CAL_CTL3;  ///< Offset: 0x5C - Cal control osc trim bits, idac, sdac, itim, bdac.
        volatile uint32_t BOOKMARK;  ///< Offset: 0x60 - Bookmark register - keeps the current FW HV seq
        volatile uint32_t RED_CTL01;  ///< Offset: 0x80 - Redundancy Control normal sectors 0,1
        volatile uint32_t RED_CTL23;  ///< Offset: 0x84 - Redundancy Controll normal sectors 2,3
        volatile uint32_t RED_CTL45;  ///< Offset: 0x88 - Redundancy Controll normal sectors 4,5
        volatile uint32_t RED_CTL67;  ///< Offset: 0x8C - Redundancy Controll normal sectors 6,7
        volatile uint32_t RED_CTL_SM01;  ///< Offset: 0x90 - Redundancy Controll special sectors 0,1
        volatile uint32_t TM_CMPR__;  ///< Offset: 0x100 - Do Not Use (renamed from TM_CMPR__)
        volatile uint32_t FM_HV_DATA__;  ///< Offset: 0x800 - Flash macro high Voltage page latches data (renamed from FM_HV_DATA__)
        volatile uint32_t FM_MEM_DATA__;  ///< Offset: 0xC00 - Flash macro memory sense amplifier and column decoder data (renamed from FM_MEM_DATA__)
    };

    /// Peripheral instances
    inline Registers* FLASHC = reinterpret_cast<Registers*>(FLASHC_BASE);

}

// ============================================================================
// SRSS Peripheral
// ============================================================================

namespace srss {
    /// Base addresses
    constexpr uint32_t SRSS_BASE = 0x40260000;

    /// SRSS Register structure
    struct Registers {
        volatile uint32_t PWR_CTL;  ///< Offset: 0x00 - Power Mode Control
        volatile uint32_t PWR_HIBERNATE;  ///< Offset: 0x04 - HIBERNATE Mode Register
        volatile uint32_t PWR_LVD_CTL;  ///< Offset: 0x08 - Low Voltage Detector (LVD) Configuration Register
        volatile uint32_t PWR_BUCK_CTL;  ///< Offset: 0x14 - Buck Control Register
        volatile uint32_t PWR_BUCK_CTL2;  ///< Offset: 0x18 - Buck Control Register 2
        volatile uint32_t PWR_LVD_STATUS;  ///< Offset: 0x1C - Low Voltage Detector (LVD) Status Register
        volatile uint32_t PWR_HIB_DATA__;  ///< Offset: 0x80 - HIBERNATE Data Register (renamed from PWR_HIB_DATA__)
        volatile uint32_t WDT_CTL;  ///< Offset: 0x180 - Watchdog Counter Control Register
        volatile uint32_t WDT_CNT;  ///< Offset: 0x184 - Watchdog Counter Count Register
        volatile uint32_t WDT_MATCH;  ///< Offset: 0x188 - Watchdog Counter Match Register
        volatile uint32_t MCWDT_CNTLOW;  ///< Offset: 0x04 - Multi-Counter Watchdog Sub-counters 0/1
        volatile uint32_t MCWDT_CNTHIGH;  ///< Offset: 0x08 - Multi-Counter Watchdog Sub-counter 2
        volatile uint32_t MCWDT_MATCH;  ///< Offset: 0x0C - Multi-Counter Watchdog Counter Match Register
        volatile uint32_t MCWDT_CONFIG;  ///< Offset: 0x10 - Multi-Counter Watchdog Counter Configuration
        volatile uint32_t MCWDT_CTL;  ///< Offset: 0x14 - Multi-Counter Watchdog Counter Control
        volatile uint32_t MCWDT_INTR;  ///< Offset: 0x18 - Multi-Counter Watchdog Counter Interrupt Register
        volatile uint32_t MCWDT_INTR_SET;  ///< Offset: 0x1C - Multi-Counter Watchdog Counter Interrupt Set Register
        volatile uint32_t MCWDT_INTR_MASK;  ///< Offset: 0x20 - Multi-Counter Watchdog Counter Interrupt Mask Register
        volatile uint32_t MCWDT_INTR_MASKED;  ///< Offset: 0x24 - Multi-Counter Watchdog Counter Interrupt Masked Register
        volatile uint32_t MCWDT_LOCK;  ///< Offset: 0x28 - Multi-Counter Watchdog Counter Lock Register
        volatile uint32_t CLK_DSI_SELECT__;  ///< Offset: 0x300 - Clock DSI Select Register (renamed from CLK_DSI_SELECT__)
        volatile uint32_t CLK_PATH_SELECT__;  ///< Offset: 0x340 - Clock Path Select Register (renamed from CLK_PATH_SELECT__)
        volatile uint32_t CLK_ROOT_SELECT__;  ///< Offset: 0x380 - Clock Root Select Register (renamed from CLK_ROOT_SELECT__)
        volatile uint32_t CLK_SELECT;  ///< Offset: 0x500 - Clock selection register
        volatile uint32_t CLK_TIMER_CTL;  ///< Offset: 0x504 - Timer Clock Control Register
        volatile uint32_t CLK_ILO_CONFIG;  ///< Offset: 0x50C - ILO Configuration
        volatile uint32_t CLK_IMO_CONFIG;  ///< Offset: 0x510 - IMO Configuration
        volatile uint32_t CLK_OUTPUT_FAST;  ///< Offset: 0x514 - Fast Clock Output Select Register
        volatile uint32_t CLK_OUTPUT_SLOW;  ///< Offset: 0x518 - Slow Clock Output Select Register
        volatile uint32_t CLK_CAL_CNT1;  ///< Offset: 0x51C - Clock Calibration Counter 1
        volatile uint32_t CLK_CAL_CNT2;  ///< Offset: 0x520 - Clock Calibration Counter 2
        volatile uint32_t CLK_ECO_CONFIG;  ///< Offset: 0x52C - ECO Configuration Register
        volatile uint32_t CLK_ECO_STATUS;  ///< Offset: 0x530 - ECO Status Register
        volatile uint32_t CLK_PILO_CONFIG;  ///< Offset: 0x53C - Precision ILO Configuration Register
        volatile uint32_t CLK_FLL_CONFIG;  ///< Offset: 0x580 - FLL Configuration Register
        volatile uint32_t CLK_FLL_CONFIG2;  ///< Offset: 0x584 - FLL Configuration Register 2
        volatile uint32_t CLK_FLL_CONFIG3;  ///< Offset: 0x588 - FLL Configuration Register 3
        volatile uint32_t CLK_FLL_CONFIG4;  ///< Offset: 0x58C - FLL Configuration Register 4
        volatile uint32_t CLK_FLL_STATUS;  ///< Offset: 0x590 - FLL Status Register
        volatile uint32_t CLK_PLL_CONFIG__;  ///< Offset: 0x600 - PLL Configuration Register (renamed from CLK_PLL_CONFIG__)
        volatile uint32_t CLK_PLL_STATUS__;  ///< Offset: 0x640 - PLL Status Register (renamed from CLK_PLL_STATUS__)
        volatile uint32_t SRSS_INTR;  ///< Offset: 0x700 - SRSS Interrupt Register
        volatile uint32_t SRSS_INTR_SET;  ///< Offset: 0x704 - SRSS Interrupt Set Register
        volatile uint32_t SRSS_INTR_MASK;  ///< Offset: 0x708 - SRSS Interrupt Mask Register
        volatile uint32_t SRSS_INTR_MASKED;  ///< Offset: 0x70C - SRSS Interrupt Masked Register
        volatile uint32_t SRSS_INTR_CFG;  ///< Offset: 0x710 - SRSS Interrupt Configuration Register
        volatile uint32_t RES_CAUSE;  ///< Offset: 0x800 - Reset Cause Observation Register
        volatile uint32_t RES_CAUSE2;  ///< Offset: 0x804 - Reset Cause Observation Register 2
        volatile uint32_t PWR_TRIM_REF_CTL;  ///< Offset: 0x7F00 - Reference Trim Register
        volatile uint32_t PWR_TRIM_BODOVP_CTL;  ///< Offset: 0x7F04 - BOD/OVP Trim Register
        volatile uint32_t CLK_TRIM_CCO_CTL;  ///< Offset: 0x7F08 - CCO Trim Register
        volatile uint32_t CLK_TRIM_CCO_CTL2;  ///< Offset: 0x7F0C - CCO Trim Register 2
        volatile uint32_t PWR_TRIM_WAKE_CTL;  ///< Offset: 0x7F30 - Wakeup Trim Register
        volatile uint32_t PWR_TRIM_LVD_CTL;  ///< Offset: 0xFF10 - LVD Trim Register
        volatile uint32_t CLK_TRIM_ILO_CTL;  ///< Offset: 0xFF18 - ILO Trim Register
        volatile uint32_t PWR_TRIM_PWRSYS_CTL;  ///< Offset: 0xFF1C - Power System Trim Register
        volatile uint32_t CLK_TRIM_ECO_CTL;  ///< Offset: 0xFF20 - ECO Trim Register
        volatile uint32_t CLK_TRIM_PILO_CTL;  ///< Offset: 0xFF24 - PILO Trim Register
        volatile uint32_t CLK_TRIM_PILO_CTL2;  ///< Offset: 0xFF28 - PILO Trim Register 2
        volatile uint32_t CLK_TRIM_PILO_CTL3;  ///< Offset: 0xFF2C - PILO Trim Register 3
    };

    /// Peripheral instances
    inline Registers* SRSS = reinterpret_cast<Registers*>(SRSS_BASE);

}

// ============================================================================
// BACKUP Peripheral
// ============================================================================

namespace backup {
    /// Base addresses
    constexpr uint32_t BACKUP_BASE = 0x40270000;

    /// BACKUP Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t RTC_RW;  ///< Offset: 0x08 - RTC Read Write register
        volatile uint32_t CAL_CTL;  ///< Offset: 0x0C - Oscillator calibration for absolute frequency
        volatile uint32_t STATUS;  ///< Offset: 0x10 - Status
        volatile uint32_t RTC_TIME;  ///< Offset: 0x14 - Calendar Seconds, Minutes, Hours, Day of Week
        volatile uint32_t RTC_DATE;  ///< Offset: 0x18 - Calendar Day of Month, Month, Year
        volatile uint32_t ALM1_TIME;  ///< Offset: 0x1C - Alarm 1 Seconds, Minute, Hours, Day of Week
        volatile uint32_t ALM1_DATE;  ///< Offset: 0x20 - Alarm 1 Day of Month, Month
        volatile uint32_t ALM2_TIME;  ///< Offset: 0x24 - Alarm 2 Seconds, Minute, Hours, Day of Week
        volatile uint32_t ALM2_DATE;  ///< Offset: 0x28 - Alarm 2 Day of Month, Month
        volatile uint32_t INTR;  ///< Offset: 0x2C - Interrupt request register
        volatile uint32_t INTR_SET;  ///< Offset: 0x30 - Interrupt set request register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x34 - Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x38 - Interrupt masked request register
        volatile uint32_t OSCCNT;  ///< Offset: 0x3C - 32kHz oscillator counter
        volatile uint32_t TICKS;  ///< Offset: 0x40 - 128Hz tick counter
        volatile uint32_t PMIC_CTL;  ///< Offset: 0x44 - PMIC control register
        volatile uint32_t RESET;  ///< Offset: 0x48 - Backup reset register
        volatile uint32_t BREG__;  ///< Offset: 0x1000 - Backup register region (renamed from BREG__)
        volatile uint32_t TRIM;  ///< Offset: 0xFF00 - Trim Register
    };

    /// Peripheral instances
    inline Registers* BACKUP = reinterpret_cast<Registers*>(BACKUP_BASE);

}

// ============================================================================
// DW0 Peripheral
// ============================================================================

namespace dw0 {
    /// Base addresses
    constexpr uint32_t DW0_BASE = 0x40280000;

    /// DW0 Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Status
        volatile uint32_t PENDING;  ///< Offset: 0x08 - Pending channels
        volatile uint32_t STATUS_INTR;  ///< Offset: 0x10 - System interrupt control
        volatile uint32_t STATUS_INTR_MASKED;  ///< Offset: 0x14 - Status of interrupts masked
        volatile uint32_t ACT_DESCR_CTL;  ///< Offset: 0x20 - Active descriptor control
        volatile uint32_t ACT_DESCR_SRC;  ///< Offset: 0x24 - Active descriptor source
        volatile uint32_t ACT_DESCR_DST;  ///< Offset: 0x28 - Active descriptor destination
        volatile uint32_t ACT_DESCR_X_CTL;  ///< Offset: 0x30 - Active descriptor X loop control
        volatile uint32_t ACT_DESCR_Y_CTL;  ///< Offset: 0x34 - Active descriptor Y loop control
        volatile uint32_t ACT_DESCR_NEXT_PTR;  ///< Offset: 0x38 - Active descriptor next pointer
        volatile uint32_t ACT_SRC;  ///< Offset: 0x40 - Active source
        volatile uint32_t ACT_DST;  ///< Offset: 0x44 - Active destination
        volatile uint32_t CH_CTL;  ///< Offset: 0x00 - Channel control
        volatile uint32_t CH_STATUS;  ///< Offset: 0x04 - Channel status
        volatile uint32_t CH_IDX;  ///< Offset: 0x08 - Channel current indices
        volatile uint32_t CH_CURR_PTR;  ///< Offset: 0x0C - Channel current descriptor pointer
        volatile uint32_t INTR;  ///< Offset: 0x10 - Interrupt
        volatile uint32_t INTR_SET;  ///< Offset: 0x14 - Interrupt set
        volatile uint32_t INTR_MASK;  ///< Offset: 0x18 - Interrupt mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x1C - Interrupt masked
    };

    /// Peripheral instances
    inline Registers* DW0 = reinterpret_cast<Registers*>(DW0_BASE);

}

// ============================================================================
// DW1 Peripheral
// ============================================================================

namespace dw1 {
    /// Base addresses
    constexpr uint32_t DW1_BASE = 0x40281000;

    /// DW1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DW1 = reinterpret_cast<Registers*>(DW1_BASE);

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x402C0000;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t CMD;  ///< Offset: 0x10 - Command
        volatile uint32_t SEQ_DEFAULT;  ///< Offset: 0x20 - Sequencer Default value
        volatile uint32_t SEQ_READ_CTL_0;  ///< Offset: 0x40 - Sequencer read control 0
        volatile uint32_t SEQ_READ_CTL_1;  ///< Offset: 0x44 - Sequencer read control 1
        volatile uint32_t SEQ_READ_CTL_2;  ///< Offset: 0x48 - Sequencer read control 2
        volatile uint32_t SEQ_READ_CTL_3;  ///< Offset: 0x4C - Sequencer read control 3
        volatile uint32_t SEQ_READ_CTL_4;  ///< Offset: 0x50 - Sequencer read control 4
        volatile uint32_t SEQ_READ_CTL_5;  ///< Offset: 0x54 - Sequencer read control 5
        volatile uint32_t SEQ_PROGRAM_CTL_0;  ///< Offset: 0x60 - Sequencer program control 0
        volatile uint32_t SEQ_PROGRAM_CTL_1;  ///< Offset: 0x64 - Sequencer program control 1
        volatile uint32_t SEQ_PROGRAM_CTL_2;  ///< Offset: 0x68 - Sequencer program control 2
        volatile uint32_t SEQ_PROGRAM_CTL_3;  ///< Offset: 0x6C - Sequencer program control 3
        volatile uint32_t SEQ_PROGRAM_CTL_4;  ///< Offset: 0x70 - Sequencer program control 4
        volatile uint32_t SEQ_PROGRAM_CTL_5;  ///< Offset: 0x74 - Sequencer program control 5
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

}

// ============================================================================
// PROFILE Peripheral
// ============================================================================

namespace profile {
    /// Base addresses
    constexpr uint32_t PROFILE_BASE = 0x402D0000;

    /// PROFILE Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Profile counter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Profile status
        volatile uint32_t CMD;  ///< Offset: 0x10 - Profile command
        volatile uint32_t INTR;  ///< Offset: 0x7C0 - Profile interrupt
        volatile uint32_t INTR_SET;  ///< Offset: 0x7C4 - Profile interrupt set
        volatile uint32_t INTR_MASK;  ///< Offset: 0x7C8 - Profile interrupt mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x7CC - Profile interrupt masked
        volatile uint32_t CNT;  ///< Offset: 0x08 - Profile counter value
    };

    /// Peripheral instances
    inline Registers* PROFILE = reinterpret_cast<Registers*>(PROFILE_BASE);

}

// ============================================================================
// HSIOM Peripheral
// ============================================================================

namespace hsiom {
    /// Base addresses
    constexpr uint32_t HSIOM_BASE = 0x40310000;

    /// HSIOM Register structure
    struct Registers {
        volatile uint32_t PORT_SEL0;  ///< Offset: 0x00 - Port selection 0
        volatile uint32_t PORT_SEL1;  ///< Offset: 0x04 - Port selection 1
        volatile uint32_t AMUX_SPLIT_CTL__;  ///< Offset: 0x2000 - AMUX splitter cell control (renamed from AMUX_SPLIT_CTL__)
    };

    /// Peripheral instances
    inline Registers* HSIOM = reinterpret_cast<Registers*>(HSIOM_BASE);

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x40320000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT;  ///< Offset: 0x00 - Port output data register
        volatile uint32_t OUT_CLR;  ///< Offset: 0x04 - Port output data set register
        volatile uint32_t OUT_SET;  ///< Offset: 0x08 - Port output data clear register
        volatile uint32_t OUT_INV;  ///< Offset: 0x0C - Port output data invert register
        volatile uint32_t IN;  ///< Offset: 0x10 - Port input state register
        volatile uint32_t INTR;  ///< Offset: 0x14 - Port interrupt status register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x18 - Port interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x1C - Port interrupt masked status register
        volatile uint32_t INTR_SET;  ///< Offset: 0x20 - Port interrupt set register
        volatile uint32_t INTR_CFG;  ///< Offset: 0x24 - Port interrupt configuration register
        volatile uint32_t CFG;  ///< Offset: 0x28 - Port configuration register
        volatile uint32_t CFG_IN;  ///< Offset: 0x2C - Port input buffer configuration register
        volatile uint32_t CFG_OUT;  ///< Offset: 0x30 - Port output buffer configuration register
        volatile uint32_t CFG_SIO;  ///< Offset: 0x34 - Port SIO configuration register
        volatile uint32_t CFG_IN_GPIO5V;  ///< Offset: 0x3C - Port GPIO5V input buffer configuration register
        volatile uint32_t INTR_CAUSE0;  ///< Offset: 0x4000 - Interrupt port cause register 0
        volatile uint32_t INTR_CAUSE1;  ///< Offset: 0x4004 - Interrupt port cause register 1
        volatile uint32_t INTR_CAUSE2;  ///< Offset: 0x4008 - Interrupt port cause register 2
        volatile uint32_t INTR_CAUSE3;  ///< Offset: 0x400C - Interrupt port cause register 3
        volatile uint32_t VDD_ACTIVE;  ///< Offset: 0x4010 - Extern power supply detection register
        volatile uint32_t VDD_INTR;  ///< Offset: 0x4014 - Supply detection interrupt register
        volatile uint32_t VDD_INTR_MASK;  ///< Offset: 0x4018 - Supply detection interrupt mask register
        volatile uint32_t VDD_INTR_MASKED;  ///< Offset: 0x401C - Supply detection interrupt masked register
        volatile uint32_t VDD_INTR_SET;  ///< Offset: 0x4020 - Supply detection interrupt set register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

}

// ============================================================================
// SMARTIO Peripheral
// ============================================================================

namespace smartio {
    /// Base addresses
    constexpr uint32_t SMARTIO_BASE = 0x40330000;

    /// SMARTIO Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control register
        volatile uint32_t SYNC_CTL;  ///< Offset: 0x10 - Synchronization control register
        volatile uint32_t LUT_SEL__;  ///< Offset: 0x20 - LUT component input selection (renamed from LUT_SEL__)
        volatile uint32_t LUT_CTL__;  ///< Offset: 0x40 - LUT component control register (renamed from LUT_CTL__)
        volatile uint32_t DU_SEL;  ///< Offset: 0xC0 - Data unit component input selection
        volatile uint32_t DU_CTL;  ///< Offset: 0xC4 - Data unit component control register
        volatile uint32_t DATA;  ///< Offset: 0xF0 - Data register
    };

    /// Peripheral instances
    inline Registers* SMARTIO = reinterpret_cast<Registers*>(SMARTIO_BASE);

}

// ============================================================================
// LPCOMP Peripheral
// ============================================================================

namespace lpcomp {
    /// Base addresses
    constexpr uint32_t LPCOMP_BASE = 0x40350000;

    /// LPCOMP Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - LPCOMP Configuration Register
        volatile uint32_t STATUS;  ///< Offset: 0x04 - LPCOMP Status Register
        volatile uint32_t INTR;  ///< Offset: 0x10 - LPCOMP Interrupt request register
        volatile uint32_t INTR_SET;  ///< Offset: 0x14 - LPCOMP Interrupt set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x18 - LPCOMP Interrupt request mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x1C - LPCOMP Interrupt request masked
        volatile uint32_t CMP0_CTRL;  ///< Offset: 0x40 - Comparator 0 control Register
        volatile uint32_t CMP0_SW;  ///< Offset: 0x50 - Comparator 0 switch control
        volatile uint32_t CMP0_SW_CLEAR;  ///< Offset: 0x54 - Comparator 0 switch control clear
        volatile uint32_t CMP1_CTRL;  ///< Offset: 0x80 - Comparator 1 control Register
        volatile uint32_t CMP1_SW;  ///< Offset: 0x90 - Comparator 1 switch control
        volatile uint32_t CMP1_SW_CLEAR;  ///< Offset: 0x94 - Comparator 1 switch control clear
    };

    /// Peripheral instances
    inline Registers* LPCOMP = reinterpret_cast<Registers*>(LPCOMP_BASE);

}

// ============================================================================
// CSD0 Peripheral
// ============================================================================

namespace csd0 {
    /// Base addresses
    constexpr uint32_t CSD0_BASE = 0x40360000;

    /// CSD0 Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - Configuration and Control
        volatile uint32_t SPARE;  ///< Offset: 0x04 - Spare MMIO
        volatile uint32_t STATUS;  ///< Offset: 0x80 - Status Register
        volatile uint32_t STAT_SEQ;  ///< Offset: 0x84 - Current Sequencer status
        volatile uint32_t STAT_CNTS;  ///< Offset: 0x88 - Current status counts
        volatile uint32_t STAT_HCNT;  ///< Offset: 0x8C - Current count of the HSCMP counter
        volatile uint32_t RESULT_VAL1;  ///< Offset: 0xD0 - Result CSD/CSX accumulation counter value 1
        volatile uint32_t RESULT_VAL2;  ///< Offset: 0xD4 - Result CSX accumulation counter value 2
        volatile uint32_t ADC_RES;  ///< Offset: 0xE0 - ADC measurement
        volatile uint32_t INTR;  ///< Offset: 0xF0 - CSD Interrupt Request Register
        volatile uint32_t INTR_SET;  ///< Offset: 0xF4 - CSD Interrupt set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0xF8 - CSD Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0xFC - CSD Interrupt masked register
        volatile uint32_t HSCMP;  ///< Offset: 0x180 - High Speed Comparator configuration
        volatile uint32_t AMBUF;  ///< Offset: 0x184 - Reference Generator configuration
        volatile uint32_t REFGEN;  ///< Offset: 0x188 - Reference Generator configuration
        volatile uint32_t CSDCMP;  ///< Offset: 0x18C - CSD Comparator configuration
        volatile uint32_t SW_RES;  ///< Offset: 0x1F0 - Switch Resistance configuration
        volatile uint32_t SENSE_PERIOD;  ///< Offset: 0x200 - Sense clock period
        volatile uint32_t SENSE_DUTY;  ///< Offset: 0x204 - Sense clock duty cycle
        volatile uint32_t SW_HS_P_SEL;  ///< Offset: 0x280 - HSCMP Pos input switch Waveform selection
        volatile uint32_t SW_HS_N_SEL;  ///< Offset: 0x284 - HSCMP Neg input switch Waveform selection
        volatile uint32_t SW_SHIELD_SEL;  ///< Offset: 0x288 - Shielding switches Waveform selection
        volatile uint32_t SW_AMUXBUF_SEL;  ///< Offset: 0x290 - Amuxbuffer switches Waveform selection
        volatile uint32_t SW_BYP_SEL;  ///< Offset: 0x294 - AMUXBUS bypass switches Waveform selection
        volatile uint32_t SW_CMP_P_SEL;  ///< Offset: 0x2A0 - CSDCMP Pos Switch Waveform selection
        volatile uint32_t SW_CMP_N_SEL;  ///< Offset: 0x2A4 - CSDCMP Neg Switch Waveform selection
        volatile uint32_t SW_REFGEN_SEL;  ///< Offset: 0x2A8 - Reference Generator Switch Waveform selection
        volatile uint32_t SW_FW_MOD_SEL;  ///< Offset: 0x2B0 - Full Wave Cmod Switch Waveform selection
        volatile uint32_t SW_FW_TANK_SEL;  ///< Offset: 0x2B4 - Full Wave Csh_tank Switch Waveform selection
        volatile uint32_t SW_DSI_SEL;  ///< Offset: 0x2C0 - DSI output switch control Waveform selection
        volatile uint32_t IO_SEL;  ///< Offset: 0x2D0 - IO output control Waveform selection
        volatile uint32_t SEQ_TIME;  ///< Offset: 0x300 - Sequencer Timing
        volatile uint32_t SEQ_INIT_CNT;  ///< Offset: 0x310 - Sequencer Initial conversion and sample counts
        volatile uint32_t SEQ_NORM_CNT;  ///< Offset: 0x314 - Sequencer Normal conversion and sample counts
        volatile uint32_t ADC_CTL;  ///< Offset: 0x320 - ADC Control
        volatile uint32_t SEQ_START;  ///< Offset: 0x340 - Sequencer start
        volatile uint32_t IDACA;  ///< Offset: 0x400 - IDACA Configuration
        volatile uint32_t IDACB;  ///< Offset: 0x500 - IDACB Configuration
    };

    /// Peripheral instances
    inline Registers* CSD0 = reinterpret_cast<Registers*>(CSD0_BASE);

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t TCPWM0_BASE = 0x40380000;
    constexpr uint32_t TCPWM1_BASE = 0x40390000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Counter control register
        volatile uint32_t CTRL_CLR;  ///< Offset: 0x04 - TCPWM control clear register
        volatile uint32_t CTRL_SET;  ///< Offset: 0x08 - TCPWM control set register
        volatile uint32_t CMD_CAPTURE;  ///< Offset: 0x0C - TCPWM capture command register
        volatile uint32_t CMD_RELOAD;  ///< Offset: 0x10 - TCPWM reload command register
        volatile uint32_t CMD_STOP;  ///< Offset: 0x14 - TCPWM stop command register
        volatile uint32_t CMD_START;  ///< Offset: 0x18 - TCPWM start command register
        volatile uint32_t INTR_CAUSE;  ///< Offset: 0x1C - TCPWM Counter interrupt cause register
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Counter status register
        volatile uint32_t COUNTER;  ///< Offset: 0x08 - Counter count register
        volatile uint32_t CC;  ///< Offset: 0x0C - Counter compare/capture register
        volatile uint32_t CC_BUFF;  ///< Offset: 0x10 - Counter buffered compare/capture register
        volatile uint32_t PERIOD;  ///< Offset: 0x14 - Counter period register
        volatile uint32_t PERIOD_BUFF;  ///< Offset: 0x18 - Counter buffered period register
        volatile uint32_t TR_CTRL0;  ///< Offset: 0x20 - Counter trigger control register 0
        volatile uint32_t TR_CTRL1;  ///< Offset: 0x24 - Counter trigger control register 1
        volatile uint32_t TR_CTRL2;  ///< Offset: 0x28 - Counter trigger control register 2
        volatile uint32_t INTR;  ///< Offset: 0x30 - Interrupt request register
        volatile uint32_t INTR_SET;  ///< Offset: 0x34 - Interrupt set request register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x38 - Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x3C - Interrupt masked request register
    };

    /// Peripheral instances
    inline Registers* TCPWM0 = reinterpret_cast<Registers*>(TCPWM0_BASE);
    inline Registers* TCPWM1 = reinterpret_cast<Registers*>(TCPWM1_BASE);

}

// ============================================================================
// LCD0 Peripheral
// ============================================================================

namespace lcd0 {
    /// Base addresses
    constexpr uint32_t LCD0_BASE = 0x403B0000;

    /// LCD0 Register structure
    struct Registers {
        volatile uint32_t ID;  ///< Offset: 0x00 - ID & Revision
        volatile uint32_t DIVIDER;  ///< Offset: 0x04 - LCD Divider Register
        volatile uint32_t CONTROL;  ///< Offset: 0x08 - LCD Configuration Register
        volatile uint32_t DATA0__;  ///< Offset: 0x100 - LCD Pin Data Registers (renamed from DATA0__)
        volatile uint32_t DATA1__;  ///< Offset: 0x200 - LCD Pin Data Registers (renamed from DATA1__)
        volatile uint32_t DATA2__;  ///< Offset: 0x300 - LCD Pin Data Registers (renamed from DATA2__)
        volatile uint32_t DATA3__;  ///< Offset: 0x400 - LCD Pin Data Registers (renamed from DATA3__)
    };

    /// Peripheral instances
    inline Registers* LCD0 = reinterpret_cast<Registers*>(LCD0_BASE);

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t BLE_BASE = 0x403C0000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - RCB LL control register.
        volatile uint32_t STATUS;  ///< Offset: 0x04 - RCB status register.
        volatile uint32_t TX_CTRL;  ///< Offset: 0x10 - Transmitter control register.
        volatile uint32_t TX_FIFO_CTRL;  ///< Offset: 0x14 - Transmitter FIFO control register.
        volatile uint32_t TX_FIFO_STATUS;  ///< Offset: 0x18 - Transmitter FIFO status register.
        volatile uint32_t TX_FIFO_WR;  ///< Offset: 0x1C - Transmitter FIFO write register.
        volatile uint32_t RX_CTRL;  ///< Offset: 0x20 - Receiver control register.
        volatile uint32_t RX_FIFO_CTRL;  ///< Offset: 0x24 - Receiver FIFO control register.
        volatile uint32_t RX_FIFO_STATUS;  ///< Offset: 0x28 - Receiver FIFO status register.
        volatile uint32_t RX_FIFO_RD;  ///< Offset: 0x2C - Receiver FIFO read register.
        volatile uint32_t RX_FIFO_RD_SILENT;  ///< Offset: 0x30 - Receiver FIFO read register.
        volatile uint32_t INTR;  ///< Offset: 0x10 - Master interrupt request register.
        volatile uint32_t INTR_SET;  ///< Offset: 0x14 - Master interrupt set request register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x6C - Link Layer interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x1C - Master interrupt masked request register
        volatile uint32_t RADIO_REG1_ADDR;  ///< Offset: 0x20 - Address of Register#1 in Radio (MDON)
        volatile uint32_t RADIO_REG2_ADDR;  ///< Offset: 0x24 - Address of Register#2 in Radio (RSSI)
        volatile uint32_t RADIO_REG3_ADDR;  ///< Offset: 0x28 - Address of Register#3 in Radio (ACCL)
        volatile uint32_t RADIO_REG4_ADDR;  ///< Offset: 0x2C - Address of Register#4 in Radio (ACCH)
        volatile uint32_t RADIO_REG5_ADDR;  ///< Offset: 0x30 - Address of Register#5 in Radio (RSSI ENERGY)
        volatile uint32_t CPU_WRITE_REG;  ///< Offset: 0x40 - N/A
        volatile uint32_t CPU_READ_REG;  ///< Offset: 0x44 - N/A
        volatile uint32_t COMMAND_REGISTER;  ///< Offset: 0x00 - Instruction Register
        volatile uint32_t EVENT_INTR;  ///< Offset: 0x08 - Event(Interrupt) status and Clear register
        volatile uint32_t EVENT_ENABLE;  ///< Offset: 0x10 - Event indications enable.
        volatile uint32_t ADV_PARAMS;  ///< Offset: 0x18 - Advertising parameters register.
        volatile uint32_t ADV_INTERVAL_TIMEOUT;  ///< Offset: 0x1C - Advertising interval register.
        volatile uint32_t ADV_INTR;  ///< Offset: 0x20 - Advertising interrupt status and Clear register
        volatile uint32_t ADV_NEXT_INSTANT;  ///< Offset: 0x24 - Advertising next instant.
        volatile uint32_t SCAN_INTERVAL;  ///< Offset: 0x28 - Scan Interval Register
        volatile uint32_t SCAN_WINDOW;  ///< Offset: 0x2C - Scan window Register
        volatile uint32_t SCAN_PARAM;  ///< Offset: 0x30 - Scanning parameters register
        volatile uint32_t SCAN_INTR;  ///< Offset: 0x38 - Scan interrupt status and Clear register
        volatile uint32_t SCAN_NEXT_INSTANT;  ///< Offset: 0x3C - Advertising next instant.
        volatile uint32_t INIT_INTERVAL;  ///< Offset: 0x40 - Initiator Interval Register
        volatile uint32_t INIT_WINDOW;  ///< Offset: 0x44 - Initiator window Register
        volatile uint32_t INIT_PARAM;  ///< Offset: 0x48 - Initiator parameters register
        volatile uint32_t INIT_INTR;  ///< Offset: 0x50 - Scan interrupt status and Clear register
        volatile uint32_t INIT_NEXT_INSTANT;  ///< Offset: 0x54 - Initiator next instant.
        volatile uint32_t DEVICE_RAND_ADDR_L;  ///< Offset: 0x58 - Lower 16 bit random address of the device.
        volatile uint32_t DEVICE_RAND_ADDR_M;  ///< Offset: 0x5C - Middle 16 bit random address of the device.
        volatile uint32_t DEVICE_RAND_ADDR_H;  ///< Offset: 0x60 - Higher 16 bit random address of the device.
        volatile uint32_t PEER_ADDR_L;  ///< Offset: 0x68 - Lower 16 bit address of the peer device.
        volatile uint32_t PEER_ADDR_M;  ///< Offset: 0x6C - Middle 16 bit address of the peer device.
        volatile uint32_t PEER_ADDR_H;  ///< Offset: 0x70 - Higher 16 bit address of the peer device.
        volatile uint32_t WL_ADDR_TYPE;  ///< Offset: 0x78 - whitelist address type
        volatile uint32_t WL_ENABLE;  ///< Offset: 0x7C - whitelist valid entry bit
        volatile uint32_t TRANSMIT_WINDOW_OFFSET;  ///< Offset: 0x80 - Transmit window offset
        volatile uint32_t TRANSMIT_WINDOW_SIZE;  ///< Offset: 0x84 - Transmit window size
        volatile uint32_t DATA_CHANNELS_L0;  ///< Offset: 0x88 - Data channel map 0 (lower word)
        volatile uint32_t DATA_CHANNELS_M0;  ///< Offset: 0x8C - Data channel map 0 (middle word)
        volatile uint32_t DATA_CHANNELS_H0;  ///< Offset: 0x90 - Data channel map 0 (upper word)
        volatile uint32_t DATA_CHANNELS_L1;  ///< Offset: 0x98 - Data channel map 1 (lower word)
        volatile uint32_t DATA_CHANNELS_M1;  ///< Offset: 0x9C - Data channel map 1 (middle word)
        volatile uint32_t DATA_CHANNELS_H1;  ///< Offset: 0xA0 - Data channel map 1 (upper word)
        volatile uint32_t CONN_INTR;  ///< Offset: 0xA8 - Connection interrupt status and Clear register
        volatile uint32_t CONN_STATUS;  ///< Offset: 0xAC - Connection channel status
        volatile uint32_t CONN_INDEX;  ///< Offset: 0xB0 - Connection Index register
        volatile uint32_t WAKEUP_CONFIG;  ///< Offset: 0xB8 - Wakeup configuration
        volatile uint32_t WAKEUP_CONTROL;  ///< Offset: 0xC0 - Wakeup control
        volatile uint32_t CLOCK_CONFIG;  ///< Offset: 0xC4 - Clock control
        volatile uint32_t TIM_COUNTER_L;  ///< Offset: 0xC8 - Reference Clock
        volatile uint32_t WAKEUP_CONFIG_EXTD;  ///< Offset: 0xCC - Wakeup configuration extended
        volatile uint32_t POC_REG__TIM_CONTROL;  ///< Offset: 0xD8 - BLE Time Control
        volatile uint32_t ADV_TX_DATA_FIFO;  ///< Offset: 0xE0 - Advertising data transmit FIFO. Access ADVCH_TX_FIFO.
        volatile uint32_t ADV_SCN_RSP_TX_FIFO;  ///< Offset: 0xE8 - Advertising scan response data transmit FIFO. Access...
        volatile uint32_t INIT_SCN_ADV_RX_FIFO;  ///< Offset: 0xF8 - advertising scan response data receive data FIFO. Access...
        volatile uint32_t CONN_INTERVAL;  ///< Offset: 0x100 - Connection Interval
        volatile uint32_t SUP_TIMEOUT;  ///< Offset: 0x104 - Supervision timeout
        volatile uint32_t SLAVE_LATENCY;  ///< Offset: 0x108 - Slave Latency
        volatile uint32_t CE_LENGTH;  ///< Offset: 0x10C - Connection event length
        volatile uint32_t PDU_ACCESS_ADDR_L_REGISTER;  ///< Offset: 0x110 - Access address (lower)
        volatile uint32_t PDU_ACCESS_ADDR_H_REGISTER;  ///< Offset: 0x114 - Access address (upper)
        volatile uint32_t CONN_CE_INSTANT;  ///< Offset: 0x118 - Connection event instant
        volatile uint32_t CE_CNFG_STS_REGISTER;  ///< Offset: 0x11C - connection configuration & status register
        volatile uint32_t NEXT_CE_INSTANT;  ///< Offset: 0x120 - Next connection event instant
        volatile uint32_t CONN_CE_COUNTER;  ///< Offset: 0x124 - connection event counter
        volatile uint32_t DATA_LIST_SENT_UPDATE__STATUS;  ///< Offset: 0x128 - data list sent update and status
        volatile uint32_t DATA_LIST_ACK_UPDATE__STATUS;  ///< Offset: 0x12C - data list ack update and status
        volatile uint32_t CE_CNFG_STS_REGISTER_EXT;  ///< Offset: 0x130 - connection configuration & status register
        volatile uint32_t CONN_EXT_INTR;  ///< Offset: 0x134 - Connection extended interrupt status and Clear register
        volatile uint32_t CONN_EXT_INTR_MASK;  ///< Offset: 0x138 - Connection Extended Interrupt mask
        volatile uint32_t DATA_MEM_DESCRIPTOR__;  ///< Offset: 0x140 - Data buffer descriptor 0 to 4 (renamed from DATA_MEM_DESCRIPTOR__)
        volatile uint32_t WINDOW_WIDEN_INTVL;  ///< Offset: 0x160 - Window widen for interval
        volatile uint32_t WINDOW_WIDEN_WINOFF;  ///< Offset: 0x164 - Window widen for offset
        volatile uint32_t LE_RF_TEST_MODE;  ///< Offset: 0x170 - Direct Test Mode control
        volatile uint32_t DTM_RX_PKT_COUNT;  ///< Offset: 0x174 - Direct Test Mode receive packet count
        volatile uint32_t LE_RF_TEST_MODE_EXT;  ///< Offset: 0x178 - Direct Test Mode control
        volatile uint32_t TXRX_HOP;  ///< Offset: 0x188 - Channel Address register
        volatile uint32_t TX_RX_ON_DELAY;  ///< Offset: 0x190 - Transmit/Receive data delay
        volatile uint32_t ADV_ACCADDR_L;  ///< Offset: 0x1A8 - ADV packet access code low word
        volatile uint32_t ADV_ACCADDR_H;  ///< Offset: 0x1AC - ADV packet access code high word
        volatile uint32_t ADV_CH_TX_POWER_LVL_LS;  ///< Offset: 0x1B0 - Advertising channel transmit power setting
        volatile uint32_t ADV_CH_TX_POWER_LVL_MS;  ///< Offset: 0x1B4 - Advertising channel transmit power setting extension
        volatile uint32_t CONN_CH_TX_POWER_LVL_LS;  ///< Offset: 0x1B8 - Connection channel transmit power setting
        volatile uint32_t CONN_CH_TX_POWER_LVL_MS;  ///< Offset: 0x1BC - Connection channel transmit power setting extension
        volatile uint32_t DEV_PUB_ADDR_L;  ///< Offset: 0x1C0 - Device public address lower register
        volatile uint32_t DEV_PUB_ADDR_M;  ///< Offset: 0x1C4 - Device public address middle register
        volatile uint32_t DEV_PUB_ADDR_H;  ///< Offset: 0x1C8 - Device public address higher register
        volatile uint32_t OFFSET_TO_FIRST_INSTANT;  ///< Offset: 0x1D0 - Offset to first instant
        volatile uint32_t ADV_CONFIG;  ///< Offset: 0x1D4 - Advertiser configuration register
        volatile uint32_t SCAN_CONFIG;  ///< Offset: 0x1D8 - Scan configuration register
        volatile uint32_t INIT_CONFIG;  ///< Offset: 0x1DC - Initiator configuration register
        volatile uint32_t CONN_CONFIG;  ///< Offset: 0x1E0 - Connection configuration register
        volatile uint32_t CONN_PARAM1;  ///< Offset: 0x1E8 - Connection parameter 1
        volatile uint32_t CONN_PARAM2;  ///< Offset: 0x1EC - Connection parameter 2
        volatile uint32_t CONN_INTR_MASK;  ///< Offset: 0x1F0 - Connection Interrupt mask
        volatile uint32_t SLAVE_TIMING_CONTROL;  ///< Offset: 0x1F4 - slave timing control
        volatile uint32_t RECEIVE_TRIG_CTRL;  ///< Offset: 0x1F8 - Receive trigger control
        volatile uint32_t LL_DBG_1;  ///< Offset: 0x200 - LL debug register 1
        volatile uint32_t LL_DBG_2;  ///< Offset: 0x204 - LL debug register 2
        volatile uint32_t LL_DBG_3;  ///< Offset: 0x208 - LL debug register 3
        volatile uint32_t LL_DBG_4;  ///< Offset: 0x20C - LL debug register 4
        volatile uint32_t LL_DBG_5;  ///< Offset: 0x210 - LL debug register 5
        volatile uint32_t LL_DBG_6;  ///< Offset: 0x214 - LL debug register 6
        volatile uint32_t LL_DBG_7;  ///< Offset: 0x218 - LL debug register 7
        volatile uint32_t LL_DBG_8;  ///< Offset: 0x21C - LL debug register 8
        volatile uint32_t LL_DBG_9;  ///< Offset: 0x220 - LL debug register 9
        volatile uint32_t LL_DBG_10;  ///< Offset: 0x224 - LL debug register 10
        volatile uint32_t PEER_ADDR_INIT_L;  ///< Offset: 0x230 - Lower 16 bit address of the peer device for INIT.
        volatile uint32_t PEER_ADDR_INIT_M;  ///< Offset: 0x234 - Middle 16 bit address of the peer device for INIT.
        volatile uint32_t PEER_ADDR_INIT_H;  ///< Offset: 0x238 - Higher 16 bit address of the peer device for INIT.
        volatile uint32_t PEER_SEC_ADDR_ADV_L;  ///< Offset: 0x23C - Lower 16 bits of the secondary address of the peer...
        volatile uint32_t PEER_SEC_ADDR_ADV_M;  ///< Offset: 0x240 - Middle 16 bits of the secondary address of the peer...
        volatile uint32_t PEER_SEC_ADDR_ADV_H;  ///< Offset: 0x244 - Higher 16 bits of the secondary address of the peer...
        volatile uint32_t INIT_WINDOW_TIMER_CTRL;  ///< Offset: 0x248 - Initiator Window NI timer control
        volatile uint32_t CONN_CONFIG_EXT;  ///< Offset: 0x24C - Connection extended configuration register
        volatile uint32_t DPLL_CONFIG;  ///< Offset: 0x258 - DPLL & CY Correlator configuration register
        volatile uint32_t INIT_NI_VAL;  ///< Offset: 0x260 - Initiator Window NI instant
        volatile uint32_t INIT_WINDOW_OFFSET;  ///< Offset: 0x264 - Initiator Window offset captured at conn request
        volatile uint32_t INIT_WINDOW_NI_ANCHOR_PT;  ///< Offset: 0x268 - Initiator Window NI anchor point captured at conn request
        volatile uint32_t CONN_UPDATE_NEW_INTERVAL;  ///< Offset: 0x3A4 - Connection update new interval
        volatile uint32_t CONN_UPDATE_NEW_LATENCY;  ///< Offset: 0x3A8 - Connection update new latency
        volatile uint32_t CONN_UPDATE_NEW_SUP_TO;  ///< Offset: 0x3AC - Connection update new supervision timeout
        volatile uint32_t CONN_UPDATE_NEW_SL_INTERVAL;  ///< Offset: 0x3B0 - Connection update new Slave Latency X Conn interval Value
        volatile uint32_t CONN_REQ_WORD0;  ///< Offset: 0x3C0 - Connection request address word 0
        volatile uint32_t CONN_REQ_WORD1;  ///< Offset: 0x3C4 - Connection request address word 1
        volatile uint32_t CONN_REQ_WORD2;  ///< Offset: 0x3C8 - Connection request address word 2
        volatile uint32_t CONN_REQ_WORD3;  ///< Offset: 0x3CC - Connection request address word 3
        volatile uint32_t CONN_REQ_WORD4;  ///< Offset: 0x3D0 - Connection request address word 4
        volatile uint32_t CONN_REQ_WORD5;  ///< Offset: 0x3D4 - Connection request address word 5
        volatile uint32_t CONN_REQ_WORD6;  ///< Offset: 0x3D8 - Connection request address word 6
        volatile uint32_t CONN_REQ_WORD7;  ///< Offset: 0x3DC - Connection request address word 7
        volatile uint32_t CONN_REQ_WORD8;  ///< Offset: 0x3E0 - Connection request address word 8
        volatile uint32_t CONN_REQ_WORD9;  ///< Offset: 0x3E4 - Connection request address word 9
        volatile uint32_t CONN_REQ_WORD10;  ///< Offset: 0x3E8 - Connection request address word 10
        volatile uint32_t CONN_REQ_WORD11;  ///< Offset: 0x3EC - Connection request address word 11
        volatile uint32_t PDU_RESP_TIMER;  ///< Offset: 0xA04 - PDU response timer/Generic Timer (MMMS mode)
        volatile uint32_t NEXT_RESP_TIMER_EXP;  ///< Offset: 0xA08 - Next response timeout instant
        volatile uint32_t NEXT_SUP_TO;  ///< Offset: 0xA0C - Next supervision timeout instant
        volatile uint32_t LLH_FEATURE_CONFIG;  ///< Offset: 0xA10 - Feature enable
        volatile uint32_t WIN_MIN_STEP_SIZE;  ///< Offset: 0xA14 - Window minimum step size
        volatile uint32_t SLV_WIN_ADJ;  ///< Offset: 0xA18 - Slave window adjustment
        volatile uint32_t SL_CONN_INTERVAL;  ///< Offset: 0xA1C - Slave Latency X Conn Interval Value
        volatile uint32_t LE_PING_TIMER_ADDR;  ///< Offset: 0xA20 - LE Ping connection timer address
        volatile uint32_t LE_PING_TIMER_OFFSET;  ///< Offset: 0xA24 - LE Ping connection timer offset
        volatile uint32_t LE_PING_TIMER_NEXT_EXP;  ///< Offset: 0xA28 - LE Ping timer next expiry instant
        volatile uint32_t LE_PING_TIMER_WRAP_COUNT;  ///< Offset: 0xA2C - LE Ping Timer wrap count
        volatile uint32_t TX_EN_EXT_DELAY;  ///< Offset: 0xE00 - Transmit enable extension delay
        volatile uint32_t TX_RX_SYNTH_DELAY;  ///< Offset: 0xE04 - Transmit/Receive enable delay
        volatile uint32_t EXT_PA_LNA_DLY_CNFG;  ///< Offset: 0xE08 - External TX PA and RX LNA delay configuration
        volatile uint32_t LL_CONFIG;  ///< Offset: 0xE10 - Link Layer additional configuration
        volatile uint32_t LL_CONTROL;  ///< Offset: 0xF00 - LL Backward compatibility
        volatile uint32_t DEV_PA_ADDR_L;  ///< Offset: 0xF04 - Device Resolvable/Non-Resolvable Private address lower register
        volatile uint32_t DEV_PA_ADDR_M;  ///< Offset: 0xF08 - Device Resolvable/Non-Resolvable Private address middle register
        volatile uint32_t DEV_PA_ADDR_H;  ///< Offset: 0xF0C - Device Resolvable/Non-Resolvable Private address higher register
        volatile uint32_t RSLV_LIST_ENABLE__;  ///< Offset: 0xF10 - Resolving list entry control bit (renamed from RSLV_LIST_ENABLE__)
        volatile uint32_t WL_CONNECTION_STATUS;  ///< Offset: 0xFA0 - whitelist valid entry bit
        volatile uint32_t CONN_RXMEM_BASE_ADDR_DLE;  ///< Offset: 0x1800 - DLE Connection RX memory base address
        volatile uint32_t CONN_TXMEM_BASE_ADDR_DLE;  ///< Offset: 0x2800 - DLE Connection TX memory base address
        volatile uint32_t CONN_1_PARAM_MEM_BASE_ADDR;  ///< Offset: 0x12800 - Connection Parameter memory base address for connection 1
        volatile uint32_t CONN_2_PARAM_MEM_BASE_ADDR;  ///< Offset: 0x12880 - Connection Parameter memory base address for connection 2
        volatile uint32_t CONN_3_PARAM_MEM_BASE_ADDR;  ///< Offset: 0x12900 - Connection Parameter memory base address for connection 3
        volatile uint32_t CONN_4_PARAM_MEM_BASE_ADDR;  ///< Offset: 0x12980 - Connection Parameter memory base address for connection 4
        volatile uint32_t NI_TIMER;  ///< Offset: 0x14000 - Next Instant Timer
        volatile uint32_t US_OFFSET;  ///< Offset: 0x14004 - Micro-second Offset
        volatile uint32_t NEXT_CONN;  ///< Offset: 0x14008 - Next Connection
        volatile uint32_t NI_ABORT;  ///< Offset: 0x1400C - Abort next scheduled connection
        volatile uint32_t CONN_NI_STATUS;  ///< Offset: 0x14020 - Connection NI Status
        volatile uint32_t NEXT_SUP_TO_STATUS;  ///< Offset: 0x14024 - Next Supervision timeout Status
        volatile uint32_t MMMS_CONN_STATUS;  ///< Offset: 0x14028 - Connection Status
        volatile uint32_t BT_SLOT_CAPT_STATUS;  ///< Offset: 0x1402C - BT Slot Captured Status
        volatile uint32_t US_CAPT_STATUS;  ///< Offset: 0x14030 - Micro-second Capture Status
        volatile uint32_t US_OFFSET_STATUS;  ///< Offset: 0x14034 - Micro-second Offset Status
        volatile uint32_t ACCU_WINDOW_WIDEN_STATUS;  ///< Offset: 0x14038 - Accumulated Window Widen Status
        volatile uint32_t EARLY_INTR_STATUS;  ///< Offset: 0x1403C - Status when early interrupt is raised
        volatile uint32_t MMMS_CONFIG;  ///< Offset: 0x14040 - Multi-Master Multi-Slave Config
        volatile uint32_t US_COUNTER;  ///< Offset: 0x14044 - Running US of the current BT Slot
        volatile uint32_t US_CAPT_PREV;  ///< Offset: 0x14048 - Previous captured US of the BT Slot
        volatile uint32_t EARLY_INTR_NI;  ///< Offset: 0x1404C - NI at early interrupt
        volatile uint32_t MMMS_MASTER_CREATE_BT_CAPT;  ///< Offset: 0x14080 - BT slot capture for master connection creation
        volatile uint32_t MMMS_SLAVE_CREATE_BT_CAPT;  ///< Offset: 0x14084 - BT slot capture for slave connection creation
        volatile uint32_t MMMS_SLAVE_CREATE_US_CAPT;  ///< Offset: 0x14088 - Micro second capture for slave connection creation
        volatile uint32_t MMMS_DATA_MEM_DESCRIPTOR__;  ///< Offset: 0x14100 - Data buffer descriptor 0 to 15 (renamed from MMMS_DATA_MEM_DESCRIPTOR__)
        volatile uint32_t CONN_1_DATA_LIST_SENT;  ///< Offset: 0x14200 - data list sent update and status for connection 1
        volatile uint32_t CONN_1_DATA_LIST_ACK;  ///< Offset: 0x14204 - data list ack update and status for connection 1
        volatile uint32_t CONN_1_CE_DATA_LIST_CFG;  ///< Offset: 0x14208 - Connection specific pause resume for connection 1
        volatile uint32_t CONN_2_DATA_LIST_SENT;  ///< Offset: 0x14210 - data list sent update and status for connection 2
        volatile uint32_t CONN_2_DATA_LIST_ACK;  ///< Offset: 0x14214 - data list ack update and status for connection 2
        volatile uint32_t CONN_2_CE_DATA_LIST_CFG;  ///< Offset: 0x14218 - Connection specific pause resume for connection 2
        volatile uint32_t CONN_3_DATA_LIST_SENT;  ///< Offset: 0x14220 - data list sent update and status for connection 3
        volatile uint32_t CONN_3_DATA_LIST_ACK;  ///< Offset: 0x14224 - data list ack update and status for connection 3
        volatile uint32_t CONN_3_CE_DATA_LIST_CFG;  ///< Offset: 0x14228 - Connection specific pause resume for connection 3
        volatile uint32_t CONN_4_DATA_LIST_SENT;  ///< Offset: 0x14230 - data list sent update and status for connection 4
        volatile uint32_t CONN_4_DATA_LIST_ACK;  ///< Offset: 0x14234 - data list ack update and status for connection 4
        volatile uint32_t CONN_4_CE_DATA_LIST_CFG;  ///< Offset: 0x14238 - Connection specific pause resume for connection 4
        volatile uint32_t MMMS_ADVCH_NI_ENABLE;  ///< Offset: 0x14400 - Enable bits for ADV_NI, SCAN_NI and INIT_NI
        volatile uint32_t MMMS_ADVCH_NI_VALID;  ///< Offset: 0x14404 - Next instant valid for ADV, SCAN, INIT
        volatile uint32_t MMMS_ADVCH_NI_ABORT;  ///< Offset: 0x14408 - Abort the next instant of ADV, SCAN, INIT
        volatile uint32_t CONN_PARAM_NEXT_SUP_TO;  ///< Offset: 0x14410 - Register to configure the supervision timeout for next...
        volatile uint32_t CONN_PARAM_ACC_WIN_WIDEN;  ///< Offset: 0x14414 - Register to configure Accumulated window widening for...
        volatile uint32_t HW_LOAD_OFFSET;  ///< Offset: 0x14420 - Register to configure offset from connection anchor...
        volatile uint32_t ADV_RAND;  ///< Offset: 0x14424 - Random number generated by Hardware for ADV NI calculation
        volatile uint32_t MMMS_RX_PKT_CNTR;  ///< Offset: 0x14428 - Packet Counter of packets in RX FIFO in MMMS mode
        volatile uint32_t CONN_RX_PKT_CNTR__;  ///< Offset: 0x14430 - Packet Counter for Individual connection index (renamed from CONN_RX_PKT_CNTR__)
        volatile uint32_t WHITELIST_BASE_ADDR;  ///< Offset: 0x14800 - Whitelist base address
        volatile uint32_t RSLV_LIST_PEER_IDNTT_BASE_ADDR;  ///< Offset: 0x148C0 - Resolving list base address for storing Peer Identity address
        volatile uint32_t RSLV_LIST_PEER_RPA_BASE_ADDR;  ///< Offset: 0x14980 - Resolving list base address for storing resolved Peer RPA address
        volatile uint32_t RSLV_LIST_RCVD_INIT_RPA_BASE_ADDR;  ///< Offset: 0x14A40 - Resolving list base address for storing Resolved...
        volatile uint32_t RSLV_LIST_TX_INIT_RPA_BASE_ADDR;  ///< Offset: 0x14B00 - Resolving list base address for storing generated TX INITA RPA
        volatile uint32_t DDFT_CONFIG;  ///< Offset: 0x60 - BLESS DDFT configuration register
        volatile uint32_t XTAL_CLK_DIV_CONFIG;  ///< Offset: 0x64 - Crystal clock divider configuration register
        volatile uint32_t INTR_STAT;  ///< Offset: 0x68 - Link Layer interrupt status register
        volatile uint32_t LL_CLK_EN;  ///< Offset: 0x70 - Link Layer primary clock enable
        volatile uint32_t LF_CLK_CTRL;  ///< Offset: 0x74 - BLESS LF clock control and BLESS revision ID indicator
        volatile uint32_t EXT_PA_LNA_CTRL;  ///< Offset: 0x78 - External TX PA and RX LNA control
        volatile uint32_t LL_PKT_RSSI_CH_ENERGY;  ///< Offset: 0x80 - Link Layer Last Received packet RSSI/Channel energy and...
        volatile uint32_t BT_CLOCK_CAPT;  ///< Offset: 0x84 - BT clock captured on an LL DSM exit
        volatile uint32_t MT_CFG;  ///< Offset: 0xA0 - MT Configuration Register
        volatile uint32_t MT_DELAY_CFG;  ///< Offset: 0xA4 - MT Delay configuration for state transitions
        volatile uint32_t MT_DELAY_CFG2;  ///< Offset: 0xA8 - MT Delay configuration for state transitions
        volatile uint32_t MT_DELAY_CFG3;  ///< Offset: 0xAC - MT Delay configuration for state transitions
        volatile uint32_t MT_VIO_CTRL;  ///< Offset: 0xB0 - MT Configuration Register to control VIO switches
        volatile uint32_t MT_STATUS;  ///< Offset: 0xB4 - MT Status Register
        volatile uint32_t PWR_CTRL_SM_ST;  ///< Offset: 0xB8 - Link Layer Power Control FSM Status Register
        volatile uint32_t HVLDO_CTRL;  ///< Offset: 0xC0 - HVLDO Configuration register
        volatile uint32_t MISC_EN_CTRL;  ///< Offset: 0xC4 - Radio Buck and Active regulator enable control
        volatile uint32_t EFUSE_CONFIG;  ///< Offset: 0xD0 - EFUSE mode configuration register
        volatile uint32_t EFUSE_TIM_CTRL1;  ///< Offset: 0xD4 - EFUSE timing control register (common for Program and Read modes)
        volatile uint32_t EFUSE_TIM_CTRL2;  ///< Offset: 0xD8 - EFUSE timing control Register (for Read)
        volatile uint32_t EFUSE_TIM_CTRL3;  ///< Offset: 0xDC - EFUSE timing control Register (for Program)
        volatile uint32_t EFUSE_RDATA_L;  ///< Offset: 0xE0 - EFUSE Lower read data
        volatile uint32_t EFUSE_RDATA_H;  ///< Offset: 0xE4 - EFUSE higher read data
        volatile uint32_t EFUSE_WDATA_L;  ///< Offset: 0xE8 - EFUSE lower write word
        volatile uint32_t EFUSE_WDATA_H;  ///< Offset: 0xEC - EFUSE higher write word
        volatile uint32_t DIV_BY_625_CFG;  ///< Offset: 0xF0 - Divide by 625 for FW Use
        volatile uint32_t DIV_BY_625_STS;  ///< Offset: 0xF4 - Output of divide by 625 divider
        volatile uint32_t PACKET_COUNTER0;  ///< Offset: 0x100 - Packet counter 0
        volatile uint32_t PACKET_COUNTER2;  ///< Offset: 0x104 - Packet counter 2
        volatile uint32_t IV_MASTER0;  ///< Offset: 0x108 - Master Initialization Vector 0
        volatile uint32_t IV_SLAVE0;  ///< Offset: 0x10C - Slave Initialization Vector 0
        volatile uint32_t ENC_KEY__;  ///< Offset: 0x110 - Encryption Key register 0-3 (renamed from ENC_KEY__)
        volatile uint32_t MIC_IN0;  ///< Offset: 0x120 - MIC input register
        volatile uint32_t MIC_OUT0;  ///< Offset: 0x124 - MIC output register
        volatile uint32_t ENC_PARAMS;  ///< Offset: 0x128 - Encryption Parameter register
        volatile uint32_t ENC_CONFIG;  ///< Offset: 0x12C - Encryption Configuration
        volatile uint32_t ENC_INTR_EN;  ///< Offset: 0x130 - Encryption Interrupt enable
        volatile uint32_t ENC_INTR;  ///< Offset: 0x134 - Encryption Interrupt status and clear register
        volatile uint32_t B1_DATA_REG__;  ///< Offset: 0x140 - Programmable B1 Data register (0-3) (renamed from B1_DATA_REG__)
        volatile uint32_t ENC_MEM_BASE_ADDR;  ///< Offset: 0x150 - Encryption memory base address
        volatile uint32_t TRIM_LDO_0;  ///< Offset: 0xF00 - LDO Trim register 0
        volatile uint32_t TRIM_LDO_1;  ///< Offset: 0xF04 - LDO Trim register 1
        volatile uint32_t TRIM_LDO_2;  ///< Offset: 0xF08 - LDO Trim register 2
        volatile uint32_t TRIM_LDO_3;  ///< Offset: 0xF0C - LDO Trim register 3
        volatile uint32_t TRIM_MXD__;  ///< Offset: 0xF10 - MXD die Trim registers (renamed from TRIM_MXD__)
        volatile uint32_t TRIM_LDO_4;  ///< Offset: 0xF30 - LDO Trim register 4
        volatile uint32_t TRIM_LDO_5;  ///< Offset: 0xF34 - LDO Trim register 5
    };

    /// Peripheral instances
    inline Registers* BLE = reinterpret_cast<Registers*>(BLE_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBFS0_BASE = 0x403F0000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP0_DR__;  ///< Offset: 0x00 - Control End point EP0 Data Register (renamed from EP0_DR__)
        volatile uint32_t CR0;  ///< Offset: 0x20 - USB control 0 Register
        volatile uint32_t CR1;  ///< Offset: 0x24 - USB control 1 Register
        volatile uint32_t SIE_EP_INT_EN;  ///< Offset: 0x28 - USB SIE Data Endpoints Interrupt Enable Register
        volatile uint32_t SIE_EP_INT_SR;  ///< Offset: 0x2C - USB SIE Data Endpoint Interrupt Status
        volatile uint32_t SIE_EP1_CNT0;  ///< Offset: 0x30 - Non-control endpoint count register
        volatile uint32_t SIE_EP1_CNT1;  ///< Offset: 0x34 - Non-control endpoint count register
        volatile uint32_t SIE_EP1_CR0;  ///< Offset: 0x38 - Non-control endpoint's control Register
        volatile uint32_t USBIO_CR0;  ///< Offset: 0x40 - USBIO Control 0 Register
        volatile uint32_t USBIO_CR2;  ///< Offset: 0x44 - USBIO control 2 Register
        volatile uint32_t USBIO_CR1;  ///< Offset: 0x48 - USBIO control 1 Register
        volatile uint32_t DYN_RECONFIG;  ///< Offset: 0x50 - USB Dynamic reconfiguration register
        volatile uint32_t SOF0;  ///< Offset: 0x60 - Start Of Frame Register
        volatile uint32_t SOF1;  ///< Offset: 0x64 - Start Of Frame Register
        volatile uint32_t SIE_EP2_CNT0;  ///< Offset: 0x70 - Non-control endpoint count register
        volatile uint32_t SIE_EP2_CNT1;  ///< Offset: 0x74 - Non-control endpoint count register
        volatile uint32_t SIE_EP2_CR0;  ///< Offset: 0x78 - Non-control endpoint's control Register
        volatile uint32_t OSCLK_DR0;  ///< Offset: 0x80 - Oscillator lock data register 0
        volatile uint32_t OSCLK_DR1;  ///< Offset: 0x84 - Oscillator lock data register 1
        volatile uint32_t EP0_CR;  ///< Offset: 0xA0 - Endpoint0 control Register
        volatile uint32_t EP0_CNT;  ///< Offset: 0xA4 - Endpoint0 count Register
        volatile uint32_t SIE_EP3_CNT0;  ///< Offset: 0xB0 - Non-control endpoint count register
        volatile uint32_t SIE_EP3_CNT1;  ///< Offset: 0xB4 - Non-control endpoint count register
        volatile uint32_t SIE_EP3_CR0;  ///< Offset: 0xB8 - Non-control endpoint's control Register
        volatile uint32_t SIE_EP4_CNT0;  ///< Offset: 0xF0 - Non-control endpoint count register
        volatile uint32_t SIE_EP4_CNT1;  ///< Offset: 0xF4 - Non-control endpoint count register
        volatile uint32_t SIE_EP4_CR0;  ///< Offset: 0xF8 - Non-control endpoint's control Register
        volatile uint32_t SIE_EP5_CNT0;  ///< Offset: 0x130 - Non-control endpoint count register
        volatile uint32_t SIE_EP5_CNT1;  ///< Offset: 0x134 - Non-control endpoint count register
        volatile uint32_t SIE_EP5_CR0;  ///< Offset: 0x138 - Non-control endpoint's control Register
        volatile uint32_t SIE_EP6_CNT0;  ///< Offset: 0x170 - Non-control endpoint count register
        volatile uint32_t SIE_EP6_CNT1;  ///< Offset: 0x174 - Non-control endpoint count register
        volatile uint32_t SIE_EP6_CR0;  ///< Offset: 0x178 - Non-control endpoint's control Register
        volatile uint32_t SIE_EP7_CNT0;  ///< Offset: 0x1B0 - Non-control endpoint count register
        volatile uint32_t SIE_EP7_CNT1;  ///< Offset: 0x1B4 - Non-control endpoint count register
        volatile uint32_t SIE_EP7_CR0;  ///< Offset: 0x1B8 - Non-control endpoint's control Register
        volatile uint32_t SIE_EP8_CNT0;  ///< Offset: 0x1F0 - Non-control endpoint count register
        volatile uint32_t SIE_EP8_CNT1;  ///< Offset: 0x1F4 - Non-control endpoint count register
        volatile uint32_t SIE_EP8_CR0;  ///< Offset: 0x1F8 - Non-control endpoint's control Register
        volatile uint32_t ARB_EP1_CFG;  ///< Offset: 0x200 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP1_INT_EN;  ///< Offset: 0x204 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP1_SR;  ///< Offset: 0x208 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW1_WA;  ///< Offset: 0x210 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW1_WA_MSB;  ///< Offset: 0x214 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW1_RA;  ///< Offset: 0x218 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW1_RA_MSB;  ///< Offset: 0x21C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW1_DR;  ///< Offset: 0x220 - Endpoint Data Register
        volatile uint32_t BUF_SIZE;  ///< Offset: 0x230 - Dedicated Endpoint Buffer Size Register *1
        volatile uint32_t EP_ACTIVE;  ///< Offset: 0x238 - Endpoint Active Indication Register *1
        volatile uint32_t EP_TYPE;  ///< Offset: 0x23C - Endpoint Type (IN/OUT) Indication *1
        volatile uint32_t ARB_EP2_CFG;  ///< Offset: 0x240 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP2_INT_EN;  ///< Offset: 0x244 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP2_SR;  ///< Offset: 0x248 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW2_WA;  ///< Offset: 0x250 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW2_WA_MSB;  ///< Offset: 0x254 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW2_RA;  ///< Offset: 0x258 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW2_RA_MSB;  ///< Offset: 0x25C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW2_DR;  ///< Offset: 0x260 - Endpoint Data Register
        volatile uint32_t ARB_CFG;  ///< Offset: 0x270 - Arbiter Configuration Register *1
        volatile uint32_t USB_CLK_EN;  ///< Offset: 0x274 - USB Block Clock Enable Register
        volatile uint32_t ARB_INT_EN;  ///< Offset: 0x278 - Arbiter Interrupt Enable *1
        volatile uint32_t ARB_INT_SR;  ///< Offset: 0x27C - Arbiter Interrupt Status *1
        volatile uint32_t ARB_EP3_CFG;  ///< Offset: 0x280 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP3_INT_EN;  ///< Offset: 0x284 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP3_SR;  ///< Offset: 0x288 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW3_WA;  ///< Offset: 0x290 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW3_WA_MSB;  ///< Offset: 0x294 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW3_RA;  ///< Offset: 0x298 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW3_RA_MSB;  ///< Offset: 0x29C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW3_DR;  ///< Offset: 0x2A0 - Endpoint Data Register
        volatile uint32_t CWA;  ///< Offset: 0x2B0 - Common Area Write Address *1
        volatile uint32_t CWA_MSB;  ///< Offset: 0x2B4 - Endpoint Read Address value *1
        volatile uint32_t ARB_EP4_CFG;  ///< Offset: 0x2C0 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP4_INT_EN;  ///< Offset: 0x2C4 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP4_SR;  ///< Offset: 0x2C8 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW4_WA;  ///< Offset: 0x2D0 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW4_WA_MSB;  ///< Offset: 0x2D4 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW4_RA;  ///< Offset: 0x2D8 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW4_RA_MSB;  ///< Offset: 0x2DC - Endpoint Read Address value *1
        volatile uint32_t ARB_RW4_DR;  ///< Offset: 0x2E0 - Endpoint Data Register
        volatile uint32_t DMA_THRES;  ///< Offset: 0x2F0 - DMA Burst / Threshold Configuration
        volatile uint32_t DMA_THRES_MSB;  ///< Offset: 0x2F4 - DMA Burst / Threshold Configuration
        volatile uint32_t ARB_EP5_CFG;  ///< Offset: 0x300 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP5_INT_EN;  ///< Offset: 0x304 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP5_SR;  ///< Offset: 0x308 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW5_WA;  ///< Offset: 0x310 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW5_WA_MSB;  ///< Offset: 0x314 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW5_RA;  ///< Offset: 0x318 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW5_RA_MSB;  ///< Offset: 0x31C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW5_DR;  ///< Offset: 0x320 - Endpoint Data Register
        volatile uint32_t BUS_RST_CNT;  ///< Offset: 0x330 - Bus Reset Count Register
        volatile uint32_t ARB_EP6_CFG;  ///< Offset: 0x340 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP6_INT_EN;  ///< Offset: 0x344 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP6_SR;  ///< Offset: 0x348 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW6_WA;  ///< Offset: 0x350 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW6_WA_MSB;  ///< Offset: 0x354 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW6_RA;  ///< Offset: 0x358 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW6_RA_MSB;  ///< Offset: 0x35C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW6_DR;  ///< Offset: 0x360 - Endpoint Data Register
        volatile uint32_t ARB_EP7_CFG;  ///< Offset: 0x380 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP7_INT_EN;  ///< Offset: 0x384 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP7_SR;  ///< Offset: 0x388 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW7_WA;  ///< Offset: 0x390 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW7_WA_MSB;  ///< Offset: 0x394 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW7_RA;  ///< Offset: 0x398 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW7_RA_MSB;  ///< Offset: 0x39C - Endpoint Read Address value *1
        volatile uint32_t ARB_RW7_DR;  ///< Offset: 0x3A0 - Endpoint Data Register
        volatile uint32_t ARB_EP8_CFG;  ///< Offset: 0x3C0 - Endpoint Configuration Register *1
        volatile uint32_t ARB_EP8_INT_EN;  ///< Offset: 0x3C4 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_EP8_SR;  ///< Offset: 0x3C8 - Endpoint Interrupt Enable Register *1
        volatile uint32_t ARB_RW8_WA;  ///< Offset: 0x3D0 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW8_WA_MSB;  ///< Offset: 0x3D4 - Endpoint Write Address value *1
        volatile uint32_t ARB_RW8_RA;  ///< Offset: 0x3D8 - Endpoint Read Address value *1
        volatile uint32_t ARB_RW8_RA_MSB;  ///< Offset: 0x3DC - Endpoint Read Address value *1
        volatile uint32_t ARB_RW8_DR;  ///< Offset: 0x3E0 - Endpoint Data Register
        volatile uint32_t MEM_DATA__;  ///< Offset: 0x400 - DATA (renamed from MEM_DATA__)
        volatile uint32_t SOF16;  ///< Offset: 0x1060 - Start Of Frame Register
        volatile uint32_t OSCLK_DR16;  ///< Offset: 0x1080 - Oscillator lock data register
        volatile uint32_t ARB_RW1_WA16;  ///< Offset: 0x1210 - Endpoint Write Address value
        volatile uint32_t ARB_RW1_RA16;  ///< Offset: 0x1218 - Endpoint Read Address value
        volatile uint32_t ARB_RW1_DR16;  ///< Offset: 0x1220 - Endpoint Data Register
        volatile uint32_t ARB_RW2_WA16;  ///< Offset: 0x1250 - Endpoint Write Address value
        volatile uint32_t ARB_RW2_RA16;  ///< Offset: 0x1258 - Endpoint Read Address value
        volatile uint32_t ARB_RW2_DR16;  ///< Offset: 0x1260 - Endpoint Data Register
        volatile uint32_t ARB_RW3_WA16;  ///< Offset: 0x1290 - Endpoint Write Address value
        volatile uint32_t ARB_RW3_RA16;  ///< Offset: 0x1298 - Endpoint Read Address value
        volatile uint32_t ARB_RW3_DR16;  ///< Offset: 0x12A0 - Endpoint Data Register
        volatile uint32_t CWA16;  ///< Offset: 0x12B0 - Common Area Write Address
        volatile uint32_t ARB_RW4_WA16;  ///< Offset: 0x12D0 - Endpoint Write Address value
        volatile uint32_t ARB_RW4_RA16;  ///< Offset: 0x12D8 - Endpoint Read Address value
        volatile uint32_t ARB_RW4_DR16;  ///< Offset: 0x12E0 - Endpoint Data Register
        volatile uint32_t DMA_THRES16;  ///< Offset: 0x12F0 - DMA Burst / Threshold Configuration
        volatile uint32_t ARB_RW5_WA16;  ///< Offset: 0x1310 - Endpoint Write Address value
        volatile uint32_t ARB_RW5_RA16;  ///< Offset: 0x1318 - Endpoint Read Address value
        volatile uint32_t ARB_RW5_DR16;  ///< Offset: 0x1320 - Endpoint Data Register
        volatile uint32_t ARB_RW6_WA16;  ///< Offset: 0x1350 - Endpoint Write Address value
        volatile uint32_t ARB_RW6_RA16;  ///< Offset: 0x1358 - Endpoint Read Address value
        volatile uint32_t ARB_RW6_DR16;  ///< Offset: 0x1360 - Endpoint Data Register
        volatile uint32_t ARB_RW7_WA16;  ///< Offset: 0x1390 - Endpoint Write Address value
        volatile uint32_t ARB_RW7_RA16;  ///< Offset: 0x1398 - Endpoint Read Address value
        volatile uint32_t ARB_RW7_DR16;  ///< Offset: 0x13A0 - Endpoint Data Register
        volatile uint32_t ARB_RW8_WA16;  ///< Offset: 0x13D0 - Endpoint Write Address value
        volatile uint32_t ARB_RW8_RA16;  ///< Offset: 0x13D8 - Endpoint Read Address value
        volatile uint32_t ARB_RW8_DR16;  ///< Offset: 0x13E0 - Endpoint Data Register
        volatile uint32_t POWER_CTL;  ///< Offset: 0x00 - Power Control Register
        volatile uint32_t USBIO_CTL;  ///< Offset: 0x08 - USB IO Control Register
        volatile uint32_t FLOW_CTL;  ///< Offset: 0x0C - Flow Control Register
        volatile uint32_t LPM_CTL;  ///< Offset: 0x10 - LPM Control Register
        volatile uint32_t LPM_STAT;  ///< Offset: 0x14 - LPM Status register
        volatile uint32_t INTR_SIE;  ///< Offset: 0x20 - USB SOF, BUS RESET and EP0 Interrupt Status
        volatile uint32_t INTR_SIE_SET;  ///< Offset: 0x24 - USB SOF, BUS RESET and EP0 Interrupt Set
        volatile uint32_t INTR_SIE_MASK;  ///< Offset: 0x28 - USB SOF, BUS RESET and EP0 Interrupt Mask
        volatile uint32_t INTR_SIE_MASKED;  ///< Offset: 0x2C - USB SOF, BUS RESET and EP0 Interrupt Masked
        volatile uint32_t INTR_LVL_SEL;  ///< Offset: 0x30 - Select interrupt level for each interrupt source
        volatile uint32_t INTR_CAUSE_HI;  ///< Offset: 0x34 - High priority interrupt Cause register
        volatile uint32_t INTR_CAUSE_MED;  ///< Offset: 0x38 - Medium priority interrupt Cause register
        volatile uint32_t INTR_CAUSE_LO;  ///< Offset: 0x3C - Low priority interrupt Cause register
        volatile uint32_t DFT_CTL;  ///< Offset: 0x70 - DFT control
        volatile uint32_t HOST_CTL0;  ///< Offset: 0x00 - Host Control 0 Register.
        volatile uint32_t HOST_CTL1;  ///< Offset: 0x10 - Host Control 1 Register.
        volatile uint32_t HOST_CTL2;  ///< Offset: 0x100 - Host Control 2 Register.
        volatile uint32_t HOST_ERR;  ///< Offset: 0x104 - Host Error Status Register.
        volatile uint32_t HOST_STATUS;  ///< Offset: 0x108 - Host Status Register.
        volatile uint32_t HOST_FCOMP;  ///< Offset: 0x10C - Host SOF Interrupt Frame Compare Register
        volatile uint32_t HOST_RTIMER;  ///< Offset: 0x110 - Host Retry Timer Setup Register
        volatile uint32_t HOST_ADDR;  ///< Offset: 0x114 - Host Address Register
        volatile uint32_t HOST_EOF;  ///< Offset: 0x118 - Host EOF Setup Register
        volatile uint32_t HOST_FRAME;  ///< Offset: 0x11C - Host Frame Setup Register
        volatile uint32_t HOST_TOKEN;  ///< Offset: 0x120 - Host Token Endpoint Register
        volatile uint32_t HOST_EP1_CTL;  ///< Offset: 0x400 - Host Endpoint 1 Control Register
        volatile uint32_t HOST_EP1_STATUS;  ///< Offset: 0x404 - Host Endpoint 1 Status Register
        volatile uint32_t HOST_EP1_RW1_DR;  ///< Offset: 0x408 - Host Endpoint 1 Data 1-Byte Register
        volatile uint32_t HOST_EP1_RW2_DR;  ///< Offset: 0x40C - Host Endpoint 1 Data 2-Byte Register
        volatile uint32_t HOST_EP2_CTL;  ///< Offset: 0x500 - Host Endpoint 2 Control Register
        volatile uint32_t HOST_EP2_STATUS;  ///< Offset: 0x504 - Host Endpoint 2 Status Register
        volatile uint32_t HOST_EP2_RW1_DR;  ///< Offset: 0x508 - Host Endpoint 2 Data 1-Byte Register
        volatile uint32_t HOST_EP2_RW2_DR;  ///< Offset: 0x50C - Host Endpoint 2 Data 2-Byte Register
        volatile uint32_t HOST_LVL1_SEL;  ///< Offset: 0x800 - Host Interrupt Level 1 Selection Register
        volatile uint32_t HOST_LVL2_SEL;  ///< Offset: 0x804 - Host Interrupt Level 2 Selection Register
        volatile uint32_t INTR_USBHOST_CAUSE_HI;  ///< Offset: 0x900 - Interrupt USB Host Cause High Register
        volatile uint32_t INTR_USBHOST_CAUSE_MED;  ///< Offset: 0x904 - Interrupt USB Host Cause Medium Register
        volatile uint32_t INTR_USBHOST_CAUSE_LO;  ///< Offset: 0x908 - Interrupt USB Host Cause Low Register
        volatile uint32_t INTR_HOST_EP_CAUSE_HI;  ///< Offset: 0x920 - Interrupt USB Host Endpoint Cause High Register
        volatile uint32_t INTR_HOST_EP_CAUSE_MED;  ///< Offset: 0x924 - Interrupt USB Host Endpoint Cause Medium Register
        volatile uint32_t INTR_HOST_EP_CAUSE_LO;  ///< Offset: 0x928 - Interrupt USB Host Endpoint Cause Low Register
        volatile uint32_t INTR_USBHOST;  ///< Offset: 0x940 - Interrupt USB Host Register
        volatile uint32_t INTR_USBHOST_SET;  ///< Offset: 0x944 - Interrupt USB Host Set Register
        volatile uint32_t INTR_USBHOST_MASK;  ///< Offset: 0x948 - Interrupt USB Host Mask Register
        volatile uint32_t INTR_USBHOST_MASKED;  ///< Offset: 0x94C - Interrupt USB Host Masked Register
        volatile uint32_t INTR_HOST_EP;  ///< Offset: 0xA00 - Interrupt USB Host Endpoint Register
        volatile uint32_t INTR_HOST_EP_SET;  ///< Offset: 0xA04 - Interrupt USB Host Endpoint Set Register
        volatile uint32_t INTR_HOST_EP_MASK;  ///< Offset: 0xA08 - Interrupt USB Host Endpoint Mask Register
        volatile uint32_t INTR_HOST_EP_MASKED;  ///< Offset: 0xA0C - Interrupt USB Host Endpoint Masked Register
        volatile uint32_t HOST_DMA_ENBL;  ///< Offset: 0xB00 - Host DMA Enable Register
        volatile uint32_t HOST_EP1_BLK;  ///< Offset: 0xB20 - Host Endpoint 1 Block Register
        volatile uint32_t HOST_EP2_BLK;  ///< Offset: 0xB30 - Host Endpoint 2 Block Register
    };

    /// Peripheral instances
    inline Registers* USBFS0 = reinterpret_cast<Registers*>(USBFS0_BASE);

}

// ============================================================================
// SMIF0 Peripheral
// ============================================================================

namespace smif0 {
    /// Base addresses
    constexpr uint32_t SMIF0_BASE = 0x40420000;

    /// SMIF0 Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Status
        volatile uint32_t TX_CMD_FIFO_STATUS;  ///< Offset: 0x44 - Transmitter command FIFO status
        volatile uint32_t TX_CMD_FIFO_WR;  ///< Offset: 0x50 - Transmitter command FIFO write
        volatile uint32_t TX_DATA_FIFO_CTL;  ///< Offset: 0x80 - Transmitter data FIFO control
        volatile uint32_t TX_DATA_FIFO_STATUS;  ///< Offset: 0x84 - Transmitter data FIFO status
        volatile uint32_t TX_DATA_FIFO_WR1;  ///< Offset: 0x90 - Transmitter data FIFO write
        volatile uint32_t TX_DATA_FIFO_WR2;  ///< Offset: 0x94 - Transmitter data FIFO write
        volatile uint32_t TX_DATA_FIFO_WR4;  ///< Offset: 0x98 - Transmitter data FIFO write
        volatile uint32_t RX_DATA_FIFO_CTL;  ///< Offset: 0xC0 - Receiver data FIFO control
        volatile uint32_t RX_DATA_FIFO_STATUS;  ///< Offset: 0xC4 - Receiver data FIFO status
        volatile uint32_t RX_DATA_FIFO_RD1;  ///< Offset: 0xD0 - Receiver data FIFO read
        volatile uint32_t RX_DATA_FIFO_RD2;  ///< Offset: 0xD4 - Receiver data FIFO read
        volatile uint32_t RX_DATA_FIFO_RD4;  ///< Offset: 0xD8 - Receiver data FIFO read
        volatile uint32_t RX_DATA_FIFO_RD1_SILENT;  ///< Offset: 0xE0 - Receiver data FIFO silent read
        volatile uint32_t SLOW_CA_CTL;  ///< Offset: 0x100 - Slow cache control
        volatile uint32_t SLOW_CA_CMD;  ///< Offset: 0x108 - Slow cache command
        volatile uint32_t FAST_CA_CTL;  ///< Offset: 0x180 - Fast cache control
        volatile uint32_t FAST_CA_CMD;  ///< Offset: 0x188 - Fast cache command
        volatile uint32_t CRYPTO_CMD;  ///< Offset: 0x200 - Cryptography Command
        volatile uint32_t CRYPTO_INPUT0;  ///< Offset: 0x220 - Cryptography input 0
        volatile uint32_t CRYPTO_INPUT1;  ///< Offset: 0x224 - Cryptography input 1
        volatile uint32_t CRYPTO_INPUT2;  ///< Offset: 0x228 - Cryptography input 2
        volatile uint32_t CRYPTO_INPUT3;  ///< Offset: 0x22C - Cryptography input 3
        volatile uint32_t CRYPTO_KEY0;  ///< Offset: 0x240 - Cryptography key 0
        volatile uint32_t CRYPTO_KEY1;  ///< Offset: 0x244 - Cryptography key 1
        volatile uint32_t CRYPTO_KEY2;  ///< Offset: 0x248 - Cryptography key 2
        volatile uint32_t CRYPTO_KEY3;  ///< Offset: 0x24C - Cryptography key 3
        volatile uint32_t CRYPTO_OUTPUT0;  ///< Offset: 0x260 - Cryptography output 0
        volatile uint32_t CRYPTO_OUTPUT1;  ///< Offset: 0x264 - Cryptography output 1
        volatile uint32_t CRYPTO_OUTPUT2;  ///< Offset: 0x268 - Cryptography output 2
        volatile uint32_t CRYPTO_OUTPUT3;  ///< Offset: 0x26C - Cryptography output 3
        volatile uint32_t INTR;  ///< Offset: 0x7C0 - Interrupt register
        volatile uint32_t INTR_SET;  ///< Offset: 0x7C4 - Interrupt set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x7C8 - Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x7CC - Interrupt masked register
        volatile uint32_t ADDR;  ///< Offset: 0x08 - Device region base address
        volatile uint32_t MASK;  ///< Offset: 0x0C - Device region mask
        volatile uint32_t ADDR_CTL;  ///< Offset: 0x20 - Address control
        volatile uint32_t RD_CMD_CTL;  ///< Offset: 0x40 - Read command control
        volatile uint32_t RD_ADDR_CTL;  ///< Offset: 0x44 - Read address control
        volatile uint32_t RD_MODE_CTL;  ///< Offset: 0x48 - Read mode control
        volatile uint32_t RD_DUMMY_CTL;  ///< Offset: 0x4C - Read dummy control
        volatile uint32_t RD_DATA_CTL;  ///< Offset: 0x50 - Read data control
        volatile uint32_t WR_CMD_CTL;  ///< Offset: 0x60 - Write command control
        volatile uint32_t WR_ADDR_CTL;  ///< Offset: 0x64 - Write address control
        volatile uint32_t WR_MODE_CTL;  ///< Offset: 0x68 - Write mode control
        volatile uint32_t WR_DUMMY_CTL;  ///< Offset: 0x6C - Write dummy control
        volatile uint32_t WR_DATA_CTL;  ///< Offset: 0x70 - Write data control
    };

    /// Peripheral instances
    inline Registers* SMIF0 = reinterpret_cast<Registers*>(SMIF0_BASE);

}

// ============================================================================
// SCB0 Peripheral
// ============================================================================

namespace scb0 {
    /// Base addresses
    constexpr uint32_t SCB0_BASE = 0x40610000;

    /// SCB0 Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Generic control
        volatile uint32_t STATUS;  ///< Offset: 0x04 - Generic status
        volatile uint32_t CMD_RESP_CTRL;  ///< Offset: 0x08 - Command/response control
        volatile uint32_t CMD_RESP_STATUS;  ///< Offset: 0x0C - Command/response status
        volatile uint32_t SPI_CTRL;  ///< Offset: 0x20 - SPI control
        volatile uint32_t SPI_STATUS;  ///< Offset: 0x24 - SPI status
        volatile uint32_t UART_CTRL;  ///< Offset: 0x40 - UART control
        volatile uint32_t UART_TX_CTRL;  ///< Offset: 0x44 - UART transmitter control
        volatile uint32_t UART_RX_CTRL;  ///< Offset: 0x48 - UART receiver control
        volatile uint32_t UART_RX_STATUS;  ///< Offset: 0x4C - UART receiver status
        volatile uint32_t UART_FLOW_CTRL;  ///< Offset: 0x50 - UART flow control
        volatile uint32_t I2C_CTRL;  ///< Offset: 0x60 - I2C control
        volatile uint32_t I2C_STATUS;  ///< Offset: 0x64 - I2C status
        volatile uint32_t I2C_M_CMD;  ///< Offset: 0x68 - I2C master command
        volatile uint32_t I2C_S_CMD;  ///< Offset: 0x6C - I2C slave command
        volatile uint32_t I2C_CFG;  ///< Offset: 0x70 - I2C configuration
        volatile uint32_t DDFT_CTRL;  ///< Offset: 0x100 - Digital DfT control
        volatile uint32_t TX_CTRL;  ///< Offset: 0x200 - Transmitter control
        volatile uint32_t TX_FIFO_CTRL;  ///< Offset: 0x204 - Transmitter FIFO control
        volatile uint32_t TX_FIFO_STATUS;  ///< Offset: 0x208 - Transmitter FIFO status
        volatile uint32_t TX_FIFO_WR;  ///< Offset: 0x240 - Transmitter FIFO write
        volatile uint32_t RX_CTRL;  ///< Offset: 0x300 - Receiver control
        volatile uint32_t RX_FIFO_CTRL;  ///< Offset: 0x304 - Receiver FIFO control
        volatile uint32_t RX_FIFO_STATUS;  ///< Offset: 0x308 - Receiver FIFO status
        volatile uint32_t RX_MATCH;  ///< Offset: 0x310 - Slave address and mask
        volatile uint32_t RX_FIFO_RD;  ///< Offset: 0x340 - Receiver FIFO read
        volatile uint32_t RX_FIFO_RD_SILENT;  ///< Offset: 0x344 - Receiver FIFO read silent
        volatile uint32_t INTR_CAUSE;  ///< Offset: 0xE00 - Active clocked interrupt signal
        volatile uint32_t INTR_I2C_EC;  ///< Offset: 0xE80 - Externally clocked I2C interrupt request
        volatile uint32_t INTR_I2C_EC_MASK;  ///< Offset: 0xE88 - Externally clocked I2C interrupt mask
        volatile uint32_t INTR_I2C_EC_MASKED;  ///< Offset: 0xE8C - Externally clocked I2C interrupt masked
        volatile uint32_t INTR_SPI_EC;  ///< Offset: 0xEC0 - Externally clocked SPI interrupt request
        volatile uint32_t INTR_SPI_EC_MASK;  ///< Offset: 0xEC8 - Externally clocked SPI interrupt mask
        volatile uint32_t INTR_SPI_EC_MASKED;  ///< Offset: 0xECC - Externally clocked SPI interrupt masked
        volatile uint32_t INTR_M;  ///< Offset: 0xF00 - Master interrupt request
        volatile uint32_t INTR_M_SET;  ///< Offset: 0xF04 - Master interrupt set request
        volatile uint32_t INTR_M_MASK;  ///< Offset: 0xF08 - Master interrupt mask
        volatile uint32_t INTR_M_MASKED;  ///< Offset: 0xF0C - Master interrupt masked request
        volatile uint32_t INTR_S;  ///< Offset: 0xF40 - Slave interrupt request
        volatile uint32_t INTR_S_SET;  ///< Offset: 0xF44 - Slave interrupt set request
        volatile uint32_t INTR_S_MASK;  ///< Offset: 0xF48 - Slave interrupt mask
        volatile uint32_t INTR_S_MASKED;  ///< Offset: 0xF4C - Slave interrupt masked request
        volatile uint32_t INTR_TX;  ///< Offset: 0xF80 - Transmitter interrupt request
        volatile uint32_t INTR_TX_SET;  ///< Offset: 0xF84 - Transmitter interrupt set request
        volatile uint32_t INTR_TX_MASK;  ///< Offset: 0xF88 - Transmitter interrupt mask
        volatile uint32_t INTR_TX_MASKED;  ///< Offset: 0xF8C - Transmitter interrupt masked request
        volatile uint32_t INTR_RX;  ///< Offset: 0xFC0 - Receiver interrupt request
        volatile uint32_t INTR_RX_SET;  ///< Offset: 0xFC4 - Receiver interrupt set request
        volatile uint32_t INTR_RX_MASK;  ///< Offset: 0xFC8 - Receiver interrupt mask
        volatile uint32_t INTR_RX_MASKED;  ///< Offset: 0xFCC - Receiver interrupt masked request
    };

    /// Peripheral instances
    inline Registers* SCB0 = reinterpret_cast<Registers*>(SCB0_BASE);

}

// ============================================================================
// SCB1 Peripheral
// ============================================================================

namespace scb1 {
    /// Base addresses
    constexpr uint32_t SCB1_BASE = 0x40620000;

    /// SCB1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB1 = reinterpret_cast<Registers*>(SCB1_BASE);

}

// ============================================================================
// SCB2 Peripheral
// ============================================================================

namespace scb2 {
    /// Base addresses
    constexpr uint32_t SCB2_BASE = 0x40630000;

    /// SCB2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB2 = reinterpret_cast<Registers*>(SCB2_BASE);

}

// ============================================================================
// SCB3 Peripheral
// ============================================================================

namespace scb3 {
    /// Base addresses
    constexpr uint32_t SCB3_BASE = 0x40640000;

    /// SCB3 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB3 = reinterpret_cast<Registers*>(SCB3_BASE);

}

// ============================================================================
// SCB4 Peripheral
// ============================================================================

namespace scb4 {
    /// Base addresses
    constexpr uint32_t SCB4_BASE = 0x40650000;

    /// SCB4 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB4 = reinterpret_cast<Registers*>(SCB4_BASE);

}

// ============================================================================
// SCB5 Peripheral
// ============================================================================

namespace scb5 {
    /// Base addresses
    constexpr uint32_t SCB5_BASE = 0x40660000;

    /// SCB5 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB5 = reinterpret_cast<Registers*>(SCB5_BASE);

}

// ============================================================================
// SCB6 Peripheral
// ============================================================================

namespace scb6 {
    /// Base addresses
    constexpr uint32_t SCB6_BASE = 0x40670000;

    /// SCB6 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB6 = reinterpret_cast<Registers*>(SCB6_BASE);

}

// ============================================================================
// SCB7 Peripheral
// ============================================================================

namespace scb7 {
    /// Base addresses
    constexpr uint32_t SCB7_BASE = 0x40680000;

    /// SCB7 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB7 = reinterpret_cast<Registers*>(SCB7_BASE);

}

// ============================================================================
// SCB8 Peripheral
// ============================================================================

namespace scb8 {
    /// Base addresses
    constexpr uint32_t SCB8_BASE = 0x40690000;

    /// SCB8 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SCB8 = reinterpret_cast<Registers*>(SCB8_BASE);

}

// ============================================================================
// CTBM0 Peripheral
// ============================================================================

namespace ctbm0 {
    /// Base addresses
    constexpr uint32_t CTBM0_BASE = 0x41100000;

    /// CTBM0 Register structure
    struct Registers {
        volatile uint32_t CTB_CTRL;  ///< Offset: 0x00 - global CTB and power control
        volatile uint32_t OA_RES0_CTRL;  ///< Offset: 0x04 - Opamp0 and resistor0 control
        volatile uint32_t OA_RES1_CTRL;  ///< Offset: 0x08 - Opamp1 and resistor1 control
        volatile uint32_t COMP_STAT;  ///< Offset: 0x0C - Comparator status
        volatile uint32_t INTR;  ///< Offset: 0x20 - Interrupt request register
        volatile uint32_t INTR_SET;  ///< Offset: 0x24 - Interrupt request set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x28 - Interrupt request mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x2C - Interrupt request masked
        volatile uint32_t OA0_SW;  ///< Offset: 0x80 - Opamp0 switch control
        volatile uint32_t OA0_SW_CLEAR;  ///< Offset: 0x84 - Opamp0 switch control clear
        volatile uint32_t OA1_SW;  ///< Offset: 0x88 - Opamp1 switch control
        volatile uint32_t OA1_SW_CLEAR;  ///< Offset: 0x8C - Opamp1 switch control clear
        volatile uint32_t CTD_SW;  ///< Offset: 0xA0 - CTDAC connection switch control
        volatile uint32_t CTD_SW_CLEAR;  ///< Offset: 0xA4 - CTDAC connection switch control clear
        volatile uint32_t CTB_SW_DS_CTRL;  ///< Offset: 0xC0 - CTB bus switch control
        volatile uint32_t CTB_SW_SQ_CTRL;  ///< Offset: 0xC4 - CTB bus switch Sar Sequencer control
        volatile uint32_t CTB_SW_STATUS;  ///< Offset: 0xC8 - CTB bus switch control status
        volatile uint32_t OA0_OFFSET_TRIM;  ///< Offset: 0xF00 - Opamp0 trim control
        volatile uint32_t OA0_SLOPE_OFFSET_TRIM;  ///< Offset: 0xF04 - Opamp0 trim control
        volatile uint32_t OA0_COMP_TRIM;  ///< Offset: 0xF08 - Opamp0 trim control
        volatile uint32_t OA1_OFFSET_TRIM;  ///< Offset: 0xF0C - Opamp1 trim control
        volatile uint32_t OA1_SLOPE_OFFSET_TRIM;  ///< Offset: 0xF10 - Opamp1 trim control
        volatile uint32_t OA1_COMP_TRIM;  ///< Offset: 0xF14 - Opamp1 trim control
    };

    /// Peripheral instances
    inline Registers* CTBM0 = reinterpret_cast<Registers*>(CTBM0_BASE);

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t CTDAC0_BASE = 0x41140000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t CTDAC_CTRL;  ///< Offset: 0x00 - Global CTDAC control
        volatile uint32_t INTR;  ///< Offset: 0x20 - Interrupt request register
        volatile uint32_t INTR_SET;  ///< Offset: 0x24 - Interrupt request set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x28 - Interrupt request mask
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x2C - Interrupt request masked
        volatile uint32_t CTDAC_SW;  ///< Offset: 0xB0 - CTDAC switch control
        volatile uint32_t CTDAC_SW_CLEAR;  ///< Offset: 0xB4 - CTDAC switch control clear
        volatile uint32_t CTDAC_VAL;  ///< Offset: 0x100 - DAC Value
        volatile uint32_t CTDAC_VAL_NXT;  ///< Offset: 0x104 - Next DAC value (double buffering)
    };

    /// Peripheral instances
    inline Registers* CTDAC0 = reinterpret_cast<Registers*>(CTDAC0_BASE);

}

// ============================================================================
// SAR Peripheral
// ============================================================================

namespace sar {
    /// Base addresses
    constexpr uint32_t SAR_BASE = 0x411D0000;

    /// SAR Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Analog control register.
        volatile uint32_t SAMPLE_CTRL;  ///< Offset: 0x04 - Sample control register.
        volatile uint32_t SAMPLE_TIME01;  ///< Offset: 0x10 - Sample time specification ST0 and ST1
        volatile uint32_t SAMPLE_TIME23;  ///< Offset: 0x14 - Sample time specification ST2 and ST3
        volatile uint32_t RANGE_THRES;  ///< Offset: 0x18 - Global range detect threshold register.
        volatile uint32_t RANGE_COND;  ///< Offset: 0x1C - Global range detect mode register.
        volatile uint32_t CHAN_EN;  ///< Offset: 0x20 - Enable bits for the channels
        volatile uint32_t START_CTRL;  ///< Offset: 0x24 - Start control register (firmware trigger).
        volatile uint32_t CHAN_CONFIG__;  ///< Offset: 0x80 - Channel configuration register. (renamed from CHAN_CONFIG__)
        volatile uint32_t CHAN_WORK__;  ///< Offset: 0x100 - Channel working data register (renamed from CHAN_WORK__)
        volatile uint32_t CHAN_RESULT__;  ///< Offset: 0x180 - Channel result data register (renamed from CHAN_RESULT__)
        volatile uint32_t CHAN_WORK_UPDATED;  ///< Offset: 0x200 - Channel working data register 'updated' bits
        volatile uint32_t CHAN_RESULT_UPDATED;  ///< Offset: 0x204 - Channel result data register 'updated' bits
        volatile uint32_t CHAN_WORK_NEWVALUE;  ///< Offset: 0x208 - Channel working data register 'new value' bits
        volatile uint32_t CHAN_RESULT_NEWVALUE;  ///< Offset: 0x20C - Channel result data register 'new value' bits
        volatile uint32_t INTR;  ///< Offset: 0x210 - Interrupt request register.
        volatile uint32_t INTR_SET;  ///< Offset: 0x214 - Interrupt set request register
        volatile uint32_t INTR_MASK;  ///< Offset: 0x218 - Interrupt mask register.
        volatile uint32_t INTR_MASKED;  ///< Offset: 0x21C - Interrupt masked request register
        volatile uint32_t SATURATE_INTR;  ///< Offset: 0x220 - Saturate interrupt request register.
        volatile uint32_t SATURATE_INTR_SET;  ///< Offset: 0x224 - Saturate interrupt set request register
        volatile uint32_t SATURATE_INTR_MASK;  ///< Offset: 0x228 - Saturate interrupt mask register.
        volatile uint32_t SATURATE_INTR_MASKED;  ///< Offset: 0x22C - Saturate interrupt masked request register
        volatile uint32_t RANGE_INTR;  ///< Offset: 0x230 - Range detect interrupt request register.
        volatile uint32_t RANGE_INTR_SET;  ///< Offset: 0x234 - Range detect interrupt set request register
        volatile uint32_t RANGE_INTR_MASK;  ///< Offset: 0x238 - Range detect interrupt mask register.
        volatile uint32_t RANGE_INTR_MASKED;  ///< Offset: 0x23C - Range interrupt masked request register
        volatile uint32_t INTR_CAUSE;  ///< Offset: 0x240 - Interrupt cause register
        volatile uint32_t INJ_CHAN_CONFIG;  ///< Offset: 0x280 - Injection channel configuration register.
        volatile uint32_t INJ_RESULT;  ///< Offset: 0x290 - Injection channel result register
        volatile uint32_t STATUS;  ///< Offset: 0x2A0 - Current status of internal SAR registers (mostly for debug)
        volatile uint32_t AVG_STAT;  ///< Offset: 0x2A4 - Current averaging status (for debug)
        volatile uint32_t MUX_SWITCH0;  ///< Offset: 0x300 - SARMUX Firmware switch controls
        volatile uint32_t MUX_SWITCH_CLEAR0;  ///< Offset: 0x304 - SARMUX Firmware switch control clear
        volatile uint32_t MUX_SWITCH_DS_CTRL;  ///< Offset: 0x340 - SARMUX switch DSI control
        volatile uint32_t MUX_SWITCH_SQ_CTRL;  ///< Offset: 0x344 - SARMUX switch Sar Sequencer control
        volatile uint32_t MUX_SWITCH_STATUS;  ///< Offset: 0x348 - SARMUX switch status
        volatile uint32_t ANA_TRIM0;  ///< Offset: 0xF00 - Analog trim register.
        volatile uint32_t ANA_TRIM1;  ///< Offset: 0xF04 - Analog trim register.
    };

    /// Peripheral instances
    inline Registers* SAR = reinterpret_cast<Registers*>(SAR_BASE);

}

// ============================================================================
// PASS Peripheral
// ============================================================================

namespace pass {
    /// Base addresses
    constexpr uint32_t PASS_BASE = 0x411F0000;

    /// PASS Register structure
    struct Registers {
        volatile uint32_t INTR_CAUSE;  ///< Offset: 0x00 - Interrupt cause register
        volatile uint32_t AREF_CTRL;  ///< Offset: 0x00 - global AREF control
        volatile uint32_t VREF_TRIM0;  ///< Offset: 0xF00 - VREF Trim bits
        volatile uint32_t VREF_TRIM1;  ///< Offset: 0xF04 - VREF Trim bits
        volatile uint32_t VREF_TRIM2;  ///< Offset: 0xF08 - VREF Trim bits
        volatile uint32_t VREF_TRIM3;  ///< Offset: 0xF0C - VREF Trim bits
        volatile uint32_t IZTAT_TRIM0;  ///< Offset: 0xF10 - IZTAT Trim bits
        volatile uint32_t IZTAT_TRIM1;  ///< Offset: 0xF14 - IZTAT Trim bits
        volatile uint32_t IPTAT_TRIM0;  ///< Offset: 0xF18 - IPTAT Trim bits
        volatile uint32_t ICTAT_TRIM0;  ///< Offset: 0xF1C - ICTAT Trim bits
    };

    /// Peripheral instances
    inline Registers* PASS = reinterpret_cast<Registers*>(PASS_BASE);

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x42A10000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t CLOCK_CTL;  ///< Offset: 0x10 - Clock control
        volatile uint32_t CMD;  ///< Offset: 0x20 - Command
        volatile uint32_t TR_CTL;  ///< Offset: 0x40 - Trigger control
        volatile uint32_t TX_CTL;  ///< Offset: 0x80 - Transmitter control
        volatile uint32_t TX_WATCHDOG;  ///< Offset: 0x84 - Transmitter watchdog
        volatile uint32_t RX_CTL;  ///< Offset: 0xA0 - Receiver control
        volatile uint32_t RX_WATCHDOG;  ///< Offset: 0xA4 - Receiver watchdog
        volatile uint32_t TX_FIFO_CTL;  ///< Offset: 0x200 - TX FIFO control
        volatile uint32_t TX_FIFO_STATUS;  ///< Offset: 0x204 - TX FIFO status
        volatile uint32_t TX_FIFO_WR;  ///< Offset: 0x208 - TX FIFO write
        volatile uint32_t RX_FIFO_CTL;  ///< Offset: 0x300 - RX FIFO control
        volatile uint32_t RX_FIFO_STATUS;  ///< Offset: 0x304 - RX FIFO status
        volatile uint32_t RX_FIFO_RD;  ///< Offset: 0x308 - RX FIFO read
        volatile uint32_t RX_FIFO_RD_SILENT;  ///< Offset: 0x30C - RX FIFO silent read
        volatile uint32_t INTR;  ///< Offset: 0xF00 - Interrupt register
        volatile uint32_t INTR_SET;  ///< Offset: 0xF04 - Interrupt set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0xF08 - Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0xF0C - Interrupt masked register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

}

// ============================================================================
// PDM0 Peripheral
// ============================================================================

namespace pdm0 {
    /// Base addresses
    constexpr uint32_t PDM0_BASE = 0x42A20000;

    /// PDM0 Register structure
    struct Registers {
        volatile uint32_t CTL;  ///< Offset: 0x00 - Control
        volatile uint32_t CLOCK_CTL;  ///< Offset: 0x10 - Clock control
        volatile uint32_t MODE_CTL;  ///< Offset: 0x14 - Mode control
        volatile uint32_t DATA_CTL;  ///< Offset: 0x18 - Data control
        volatile uint32_t CMD;  ///< Offset: 0x20 - Command
        volatile uint32_t TR_CTL;  ///< Offset: 0x40 - Trigger control
        volatile uint32_t RX_FIFO_CTL;  ///< Offset: 0x300 - RX FIFO control
        volatile uint32_t RX_FIFO_STATUS;  ///< Offset: 0x304 - RX FIFO status
        volatile uint32_t RX_FIFO_RD;  ///< Offset: 0x308 - RX FIFO read
        volatile uint32_t RX_FIFO_RD_SILENT;  ///< Offset: 0x30C - RX FIFO silent read
        volatile uint32_t INTR;  ///< Offset: 0xF00 - Interrupt register
        volatile uint32_t INTR_SET;  ///< Offset: 0xF04 - Interrupt set register
        volatile uint32_t INTR_MASK;  ///< Offset: 0xF08 - Interrupt mask register
        volatile uint32_t INTR_MASKED;  ///< Offset: 0xF0C - Interrupt masked register
    };

    /// Peripheral instances
    inline Registers* PDM0 = reinterpret_cast<Registers*>(PDM0_BASE);

}


} // namespace alloy::generated::psoc63

#endif // ALLOY_GENERATED_PSOC63_PERIPHERALS_HPP