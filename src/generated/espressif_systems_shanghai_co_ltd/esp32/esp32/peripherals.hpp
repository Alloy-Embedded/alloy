/// Auto-generated code for ESP32
/// Generated by Alloy Code Generator
/// Source: espressif_esp32.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:16
#ifndef ALLOY_GENERATED_ESP32_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 3;
    constexpr bool has_apb = true;
    constexpr uint32_t num_apb_instances = 1;
    constexpr bool has_bb = true;
    constexpr uint32_t num_bb_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_eth = true;
    constexpr uint32_t num_eth_instances = 2;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_hinf = true;
    constexpr uint32_t num_hinf_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 3;
    constexpr bool has_nrx = true;
    constexpr uint32_t num_nrx_instances = 1;
    constexpr bool has_pcnt = true;
    constexpr uint32_t num_pcnt_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sdhost = true;
    constexpr uint32_t num_sdhost_instances = 1;
    constexpr bool has_sens = true;
    constexpr uint32_t num_sens_instances = 1;
    constexpr bool has_slc = true;
    constexpr uint32_t num_slc_instances = 1;
    constexpr bool has_slchost = true;
    constexpr uint32_t num_slchost_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_uhci1 = true;
    constexpr uint32_t num_uhci1_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct apb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct eth_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct hinf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct nrx_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcnt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdhost_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sens_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct slc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct slchost_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uhci1_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x3FF01000;
    constexpr uint32_t RSA_BASE = 0x3FF02000;
    constexpr uint32_t SHA_BASE = 0x3FF03000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t START;  ///< Offset: 0x00 - Write 1 to start the AES operation.
        volatile uint32_t IDLE;  ///< Offset: 0x04 - AES Idle register. Reads ’zero’ while the AES...
        volatile uint32_t MODE;  ///< Offset: 0x08 - Selects the AES accelerator mode of operation. See Table...
        volatile uint32_t KEY_%s;  ///< Offset: 0x10 - AES key material register.
        volatile uint32_t TEXT_%s;  ///< Offset: 0x30 - Plaintext and ciphertext register.
        volatile uint32_t ENDIAN;  ///< Offset: 0x40 - Endianness selection register. See Table 22-2 for details.
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);

    // Bit definitions
    /// START Register bits
    namespace start_bits {
        constexpr uint32_t START = (1U << 0);  ///< Write 1 to start the AES operation.
    }

    /// IDLE Register bits
    namespace idle_bits {
        constexpr uint32_t IDLE = (1U << 0);  ///< AES Idle register. Reads ’zero’ while the AES Accelerator is busy processing; reads ’one’ otherwise.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (8 << 0);  ///< Selects the AES accelerator mode of operation. See Table 22-1 for details.
    }

    /// KEY_%s Register bits
    namespace key_%s_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< AES key material register.
    }

    /// TEXT_%s Register bits
    namespace text_%s_bits {
        constexpr uint32_t TEXT = (8 << 0);  ///< Plaintext and ciphertext register.
    }

    /// ENDIAN Register bits
    namespace endian_bits {
        constexpr uint32_t ENDIAN = (2 << 0);  ///< Endianness selection register. See Table 22-2 for details.
    }

}

// ============================================================================
// APB Peripheral
// ============================================================================

namespace apb {
    /// Base addresses
    constexpr uint32_t APB_CTRL_BASE = 0x3FF66000;

    /// APB Register structure
    struct Registers {
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x00 - 
        volatile uint32_t XTAL_TICK_CONF;  ///< Offset: 0x04 - 
        volatile uint32_t PLL_TICK_CONF;  ///< Offset: 0x08 - 
        volatile uint32_t CK8M_TICK_CONF;  ///< Offset: 0x0C - 
        volatile uint32_t APB_SARADC_CTRL;  ///< Offset: 0x10 - 1: SAR ADC2 is controlled by DIG ADC2 CTRL 0: SAR ADC2...
        volatile uint32_t APB_SARADC_CTRL2;  ///< Offset: 0x14 - max conversion number
        volatile uint32_t APB_SARADC_FSM;  ///< Offset: 0x18 - sample cycles
        volatile uint32_t APB_SARADC_SAR1_PATT_TAB%s;  ///< Offset: 0x1C - item 0 ~ 3 for pattern table 1 (each item one byte)
        volatile uint32_t APB_SARADC_SAR2_PATT_TAB%s;  ///< Offset: 0x2C - item 0 ~ 3 for pattern table 2 (each item one byte)
        volatile uint32_t APLL_TICK_CONF;  ///< Offset: 0x3C - 
        volatile uint32_t DATE;  ///< Offset: 0x7C - 
    };

    /// Peripheral instances
    inline Registers* APB_CTRL = reinterpret_cast<Registers*>(APB_CTRL_BASE);

    // Bit definitions
    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< PRE_DIV_CNT
        constexpr uint32_t CLK_320M_EN = (1U << 10);  ///< CLK_320M_EN
        constexpr uint32_t CLK_EN = (1U << 11);  ///< CLK_EN
        constexpr uint32_t RST_TICK_CNT = (1U << 12);  ///< RST_TICK_CNT
        constexpr uint32_t QUICK_CLK_CHNG = (1U << 13);  ///< QUICK_CLK_CHNG
    }

    /// XTAL_TICK_CONF Register bits
    namespace xtal_tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< XTAL_TICK_NUM
    }

    /// PLL_TICK_CONF Register bits
    namespace pll_tick_conf_bits {
        constexpr uint32_t PLL_TICK_NUM = (8 << 0);  ///< PLL_TICK_NUM
    }

    /// CK8M_TICK_CONF Register bits
    namespace ck8m_tick_conf_bits {
        constexpr uint32_t CK8M_TICK_NUM = (8 << 0);  ///< CK8M_TICK_NUM
    }

    /// APB_SARADC_CTRL Register bits
    namespace apb_saradc_ctrl_bits {
        constexpr uint32_t SARADC_START_FORCE = (1U << 0);  ///< SARADC_START_FORCE
        constexpr uint32_t SARADC_START = (1U << 1);  ///< SARADC_START
        constexpr uint32_t SARADC_SAR2_MUX = (1U << 2);  ///< 1: SAR ADC2 is controlled by DIG ADC2 CTRL 0: SAR ADC2 is controlled by PWDET CTRL
        constexpr uint32_t SARADC_WORK_MODE = (2 << 3);  ///< 0: single mode 1: double mode 2: alternate mode
        constexpr uint32_t SARADC_SAR_SEL = (1U << 5);  ///< 0: SAR1 1: SAR2 only work for single SAR mode
        constexpr uint32_t SARADC_SAR_CLK_GATED = (1U << 6);  ///< SARADC_SAR_CLK_GATED
        constexpr uint32_t SARADC_SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SARADC_SAR1_PATT_LEN = (4 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR2_PATT_LEN = (4 << 19);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR1_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SARADC_SAR2_PATT_P_CLEAR = (1U << 24);  ///< clear the pointer of pattern table for DIG ADC2 CTRL
        constexpr uint32_t SARADC_DATA_SAR_SEL = (1U << 25);  ///< 1: sar_sel will be coded by the MSB of the 16-bit output data in this case the resolution should not be larger than 11 bits.
        constexpr uint32_t SARADC_DATA_TO_I2S = (1U << 26);  ///< 1: I2S input data is from SAR ADC (for DMA) 0: I2S input data is from GPIO matrix
    }

    /// APB_SARADC_CTRL2 Register bits
    namespace apb_saradc_ctrl2_bits {
        constexpr uint32_t SARADC_MEAS_NUM_LIMIT = (1U << 0);  ///< SARADC_MEAS_NUM_LIMIT
        constexpr uint32_t SARADC_MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SARADC_SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted otherwise not
        constexpr uint32_t SARADC_SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted otherwise not
    }

    /// APB_SARADC_FSM Register bits
    namespace apb_saradc_fsm_bits {
        constexpr uint32_t SARADC_RSTB_WAIT = (8 << 0);  ///< SARADC_RSTB_WAIT
        constexpr uint32_t SARADC_STANDBY_WAIT = (8 << 8);  ///< SARADC_STANDBY_WAIT
        constexpr uint32_t SARADC_START_WAIT = (8 << 16);  ///< SARADC_START_WAIT
        constexpr uint32_t SARADC_SAMPLE_CYCLE = (8 << 24);  ///< sample cycles
    }

    /// APB_SARADC_SAR1_PATT_TAB%s Register bits
    namespace apb_saradc_sar1_patt_tab%s_bits {
        constexpr uint32_t SARADC_SAR1_PATT_TAB1 = (32 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// APB_SARADC_SAR2_PATT_TAB%s Register bits
    namespace apb_saradc_sar2_patt_tab%s_bits {
        constexpr uint32_t SARADC_SAR2_PATT_TAB1 = (32 << 0);  ///< item 0 ~ 3 for pattern table 2 (each item one byte)
    }

    /// APLL_TICK_CONF Register bits
    namespace apll_tick_conf_bits {
        constexpr uint32_t APLL_TICK_NUM = (8 << 0);  ///< APLL_TICK_NUM
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

}

// ============================================================================
// BB Peripheral
// ============================================================================

namespace bb {
    /// Base addresses
    constexpr uint32_t BB_BASE = 0x3FF5D000;

    /// BB Register structure
    struct Registers {
        volatile uint32_t BBPD_CTRL;  ///< Offset: 0x54 - Baseband control register
    };

    /// Peripheral instances
    inline Registers* BB = reinterpret_cast<Registers*>(BB_BASE);

    // Bit definitions
    /// BBPD_CTRL Register bits
    namespace bbpd_ctrl_bits {
        constexpr uint32_t DC_EST_FORCE_PD = (1U << 0);  ///< DC_EST_FORCE_PD
        constexpr uint32_t DC_EST_FORCE_PU = (1U << 1);  ///< DC_EST_FORCE_PU
        constexpr uint32_t FFT_FORCE_PD = (1U << 2);  ///< FFT_FORCE_PD
        constexpr uint32_t FFT_FORCE_PU = (1U << 3);  ///< FFT_FORCE_PU
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t DPORT_BASE = 0x3FF00000;
    constexpr uint32_t GPIO_BASE = 0x3FF44000;
    constexpr uint32_t GPIO_SD_BASE = 0x3FF44F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PRO_BOOT_REMAP_CTRL;  ///< Offset: 0x00 - 
        volatile uint32_t APP_BOOT_REMAP_CTRL;  ///< Offset: 0x04 - 
        volatile uint32_t ACCESS_CHECK;  ///< Offset: 0x08 - 
        volatile uint32_t PRO_DPORT_APB_MASK0;  ///< Offset: 0x0C - 
        volatile uint32_t PRO_DPORT_APB_MASK1;  ///< Offset: 0x10 - 
        volatile uint32_t APP_DPORT_APB_MASK0;  ///< Offset: 0x14 - 
        volatile uint32_t APP_DPORT_APB_MASK1;  ///< Offset: 0x18 - 
        volatile uint32_t PERI_CLK_EN;  ///< Offset: 0x1C - 
        volatile uint32_t PERI_RST_EN;  ///< Offset: 0x20 - 
        volatile uint32_t WIFI_BB_CFG;  ///< Offset: 0x24 - 
        volatile uint32_t WIFI_BB_CFG_2;  ///< Offset: 0x28 - 
        volatile uint32_t APPCPU_CTRL_A;  ///< Offset: 0x2C - 
        volatile uint32_t APPCPU_CTRL_B;  ///< Offset: 0x30 - 
        volatile uint32_t APPCPU_CTRL_C;  ///< Offset: 0x34 - 
        volatile uint32_t APPCPU_CTRL_D;  ///< Offset: 0x38 - 
        volatile uint32_t CPU_PER_CONF;  ///< Offset: 0x3C - 
        volatile uint32_t PRO_CACHE_CTRL;  ///< Offset: 0x40 - 
        volatile uint32_t PRO_CACHE_CTRL1;  ///< Offset: 0x44 - 
        volatile uint32_t PRO_CACHE_LOCK_0_ADDR;  ///< Offset: 0x48 - 
        volatile uint32_t PRO_CACHE_LOCK_1_ADDR;  ///< Offset: 0x4C - 
        volatile uint32_t PRO_CACHE_LOCK_2_ADDR;  ///< Offset: 0x50 - 
        volatile uint32_t PRO_CACHE_LOCK_3_ADDR;  ///< Offset: 0x54 - 
        volatile uint32_t APP_CACHE_CTRL;  ///< Offset: 0x58 - 
        volatile uint32_t APP_CACHE_CTRL1;  ///< Offset: 0x5C - 
        volatile uint32_t APP_CACHE_LOCK_0_ADDR;  ///< Offset: 0x60 - 
        volatile uint32_t APP_CACHE_LOCK_1_ADDR;  ///< Offset: 0x64 - 
        volatile uint32_t APP_CACHE_LOCK_2_ADDR;  ///< Offset: 0x68 - 
        volatile uint32_t APP_CACHE_LOCK_3_ADDR;  ///< Offset: 0x6C - 
        volatile uint32_t TRACEMEM_MUX_MODE;  ///< Offset: 0x70 - 
        volatile uint32_t PRO_TRACEMEM_ENA;  ///< Offset: 0x74 - 
        volatile uint32_t APP_TRACEMEM_ENA;  ///< Offset: 0x78 - 
        volatile uint32_t CACHE_MUX_MODE;  ///< Offset: 0x7C - 
        volatile uint32_t IMMU_PAGE_MODE;  ///< Offset: 0x80 - 
        volatile uint32_t DMMU_PAGE_MODE;  ///< Offset: 0x84 - 
        volatile uint32_t ROM_MPU_ENA;  ///< Offset: 0x88 - 
        volatile uint32_t MEM_PD_MASK;  ///< Offset: 0x8C - 
        volatile uint32_t ROM_PD_CTRL;  ///< Offset: 0x90 - 
        volatile uint32_t ROM_FO_CTRL;  ///< Offset: 0x94 - 
        volatile uint32_t SRAM_PD_CTRL_0;  ///< Offset: 0x98 - 
        volatile uint32_t SRAM_PD_CTRL_1;  ///< Offset: 0x9C - 
        volatile uint32_t SRAM_FO_CTRL_0;  ///< Offset: 0xA0 - 
        volatile uint32_t SRAM_FO_CTRL_1;  ///< Offset: 0xA4 - 
        volatile uint32_t IRAM_DRAM_AHB_SEL;  ///< Offset: 0xA8 - 
        volatile uint32_t TAG_FO_CTRL;  ///< Offset: 0xAC - 
        volatile uint32_t AHB_LITE_MASK;  ///< Offset: 0xB0 - 
        volatile uint32_t AHB_MPU_TABLE_0;  ///< Offset: 0xB4 - 
        volatile uint32_t AHB_MPU_TABLE_1;  ///< Offset: 0xB8 - 
        volatile uint32_t HOST_INF_SEL;  ///< Offset: 0xBC - 
        volatile uint32_t PERIP_CLK_EN;  ///< Offset: 0xC0 - 
        volatile uint32_t PERIP_RST_EN;  ///< Offset: 0xC4 - 
        volatile uint32_t SLAVE_SPI_CONFIG;  ///< Offset: 0xC8 - 
        volatile uint32_t WIFI_CLK_EN;  ///< Offset: 0xCC - 
        volatile uint32_t CORE_RST_EN;  ///< Offset: 0xD0 - 
        volatile uint32_t BT_LPCK_DIV_INT;  ///< Offset: 0xD4 - 
        volatile uint32_t BT_LPCK_DIV_FRAC;  ///< Offset: 0xD8 - 
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0xDC - 
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0xE0 - 
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0xE4 - 
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0xE8 - 
        volatile uint32_t PRO_INTR_STATUS_0;  ///< Offset: 0xEC - 
        volatile uint32_t PRO_INTR_STATUS_1;  ///< Offset: 0xF0 - 
        volatile uint32_t PRO_INTR_STATUS_2;  ///< Offset: 0xF4 - 
        volatile uint32_t APP_INTR_STATUS_0;  ///< Offset: 0xF8 - 
        volatile uint32_t APP_INTR_STATUS_1;  ///< Offset: 0xFC - 
        volatile uint32_t APP_INTR_STATUS_2;  ///< Offset: 0x100 - 
        volatile uint32_t PRO_MAC_INTR_MAP;  ///< Offset: 0x104 - 
        volatile uint32_t PRO_MAC_NMI_MAP;  ///< Offset: 0x108 - 
        volatile uint32_t PRO_BB_INT_MAP;  ///< Offset: 0x10C - 
        volatile uint32_t PRO_BT_MAC_INT_MAP;  ///< Offset: 0x110 - 
        volatile uint32_t PRO_BT_BB_INT_MAP;  ///< Offset: 0x114 - 
        volatile uint32_t PRO_BT_BB_NMI_MAP;  ///< Offset: 0x118 - 
        volatile uint32_t PRO_RWBT_IRQ_MAP;  ///< Offset: 0x11C - 
        volatile uint32_t PRO_RWBLE_IRQ_MAP;  ///< Offset: 0x120 - 
        volatile uint32_t PRO_RWBT_NMI_MAP;  ///< Offset: 0x124 - 
        volatile uint32_t PRO_RWBLE_NMI_MAP;  ///< Offset: 0x128 - 
        volatile uint32_t PRO_SLC0_INTR_MAP;  ///< Offset: 0x12C - 
        volatile uint32_t PRO_SLC1_INTR_MAP;  ///< Offset: 0x130 - 
        volatile uint32_t PRO_UHCI0_INTR_MAP;  ///< Offset: 0x134 - 
        volatile uint32_t PRO_UHCI1_INTR_MAP;  ///< Offset: 0x138 - 
        volatile uint32_t PRO_TG_T0_LEVEL_INT_MAP;  ///< Offset: 0x13C - 
        volatile uint32_t PRO_TG_T1_LEVEL_INT_MAP;  ///< Offset: 0x140 - 
        volatile uint32_t PRO_TG_WDT_LEVEL_INT_MAP;  ///< Offset: 0x144 - 
        volatile uint32_t PRO_TG_LACT_LEVEL_INT_MAP;  ///< Offset: 0x148 - 
        volatile uint32_t PRO_TG1_T0_LEVEL_INT_MAP;  ///< Offset: 0x14C - 
        volatile uint32_t PRO_TG1_T1_LEVEL_INT_MAP;  ///< Offset: 0x150 - 
        volatile uint32_t PRO_TG1_WDT_LEVEL_INT_MAP;  ///< Offset: 0x154 - 
        volatile uint32_t PRO_TG1_LACT_LEVEL_INT_MAP;  ///< Offset: 0x158 - 
        volatile uint32_t PRO_GPIO_INTERRUPT_MAP;  ///< Offset: 0x15C - 
        volatile uint32_t PRO_GPIO_INTERRUPT_NMI_MAP;  ///< Offset: 0x160 - 
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x164 - 
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x168 - 
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x16C - 
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x170 - 
        volatile uint32_t PRO_SPI_INTR_0_MAP;  ///< Offset: 0x174 - 
        volatile uint32_t PRO_SPI_INTR_1_MAP;  ///< Offset: 0x178 - 
        volatile uint32_t PRO_SPI_INTR_2_MAP;  ///< Offset: 0x17C - 
        volatile uint32_t PRO_SPI_INTR_3_MAP;  ///< Offset: 0x180 - 
        volatile uint32_t PRO_I2S0_INT_MAP;  ///< Offset: 0x184 - 
        volatile uint32_t PRO_I2S1_INT_MAP;  ///< Offset: 0x188 - 
        volatile uint32_t PRO_UART_INTR_MAP;  ///< Offset: 0x18C - 
        volatile uint32_t PRO_UART1_INTR_MAP;  ///< Offset: 0x190 - 
        volatile uint32_t PRO_UART2_INTR_MAP;  ///< Offset: 0x194 - 
        volatile uint32_t PRO_SDIO_HOST_INTERRUPT_MAP;  ///< Offset: 0x198 - 
        volatile uint32_t PRO_EMAC_INT_MAP;  ///< Offset: 0x19C - 
        volatile uint32_t PRO_PWM0_INTR_MAP;  ///< Offset: 0x1A0 - 
        volatile uint32_t PRO_PWM1_INTR_MAP;  ///< Offset: 0x1A4 - 
        volatile uint32_t PRO_PWM2_INTR_MAP;  ///< Offset: 0x1A8 - 
        volatile uint32_t PRO_PWM3_INTR_MAP;  ///< Offset: 0x1AC - 
        volatile uint32_t PRO_LEDC_INT_MAP;  ///< Offset: 0x1B0 - 
        volatile uint32_t PRO_EFUSE_INT_MAP;  ///< Offset: 0x1B4 - 
        volatile uint32_t PRO_CAN_INT_MAP;  ///< Offset: 0x1B8 - 
        volatile uint32_t PRO_RTC_CORE_INTR_MAP;  ///< Offset: 0x1BC - 
        volatile uint32_t PRO_RMT_INTR_MAP;  ///< Offset: 0x1C0 - 
        volatile uint32_t PRO_PCNT_INTR_MAP;  ///< Offset: 0x1C4 - 
        volatile uint32_t PRO_I2C_EXT0_INTR_MAP;  ///< Offset: 0x1C8 - 
        volatile uint32_t PRO_I2C_EXT1_INTR_MAP;  ///< Offset: 0x1CC - 
        volatile uint32_t PRO_RSA_INTR_MAP;  ///< Offset: 0x1D0 - 
        volatile uint32_t PRO_SPI1_DMA_INT_MAP;  ///< Offset: 0x1D4 - 
        volatile uint32_t PRO_SPI2_DMA_INT_MAP;  ///< Offset: 0x1D8 - 
        volatile uint32_t PRO_SPI3_DMA_INT_MAP;  ///< Offset: 0x1DC - 
        volatile uint32_t PRO_WDG_INT_MAP;  ///< Offset: 0x1E0 - 
        volatile uint32_t PRO_TIMER_INT1_MAP;  ///< Offset: 0x1E4 - 
        volatile uint32_t PRO_TIMER_INT2_MAP;  ///< Offset: 0x1E8 - 
        volatile uint32_t PRO_TG_T0_EDGE_INT_MAP;  ///< Offset: 0x1EC - 
        volatile uint32_t PRO_TG_T1_EDGE_INT_MAP;  ///< Offset: 0x1F0 - 
        volatile uint32_t PRO_TG_WDT_EDGE_INT_MAP;  ///< Offset: 0x1F4 - 
        volatile uint32_t PRO_TG_LACT_EDGE_INT_MAP;  ///< Offset: 0x1F8 - 
        volatile uint32_t PRO_TG1_T0_EDGE_INT_MAP;  ///< Offset: 0x1FC - 
        volatile uint32_t PRO_TG1_T1_EDGE_INT_MAP;  ///< Offset: 0x200 - 
        volatile uint32_t PRO_TG1_WDT_EDGE_INT_MAP;  ///< Offset: 0x204 - 
        volatile uint32_t PRO_TG1_LACT_EDGE_INT_MAP;  ///< Offset: 0x208 - 
        volatile uint32_t PRO_MMU_IA_INT_MAP;  ///< Offset: 0x20C - 
        volatile uint32_t PRO_MPU_IA_INT_MAP;  ///< Offset: 0x210 - 
        volatile uint32_t PRO_CACHE_IA_INT_MAP;  ///< Offset: 0x214 - 
        volatile uint32_t APP_MAC_INTR_MAP;  ///< Offset: 0x218 - 
        volatile uint32_t APP_MAC_NMI_MAP;  ///< Offset: 0x21C - 
        volatile uint32_t APP_BB_INT_MAP;  ///< Offset: 0x220 - 
        volatile uint32_t APP_BT_MAC_INT_MAP;  ///< Offset: 0x224 - 
        volatile uint32_t APP_BT_BB_INT_MAP;  ///< Offset: 0x228 - 
        volatile uint32_t APP_BT_BB_NMI_MAP;  ///< Offset: 0x22C - 
        volatile uint32_t APP_RWBT_IRQ_MAP;  ///< Offset: 0x230 - 
        volatile uint32_t APP_RWBLE_IRQ_MAP;  ///< Offset: 0x234 - 
        volatile uint32_t APP_RWBT_NMI_MAP;  ///< Offset: 0x238 - 
        volatile uint32_t APP_RWBLE_NMI_MAP;  ///< Offset: 0x23C - 
        volatile uint32_t APP_SLC0_INTR_MAP;  ///< Offset: 0x240 - 
        volatile uint32_t APP_SLC1_INTR_MAP;  ///< Offset: 0x244 - 
        volatile uint32_t APP_UHCI0_INTR_MAP;  ///< Offset: 0x248 - 
        volatile uint32_t APP_UHCI1_INTR_MAP;  ///< Offset: 0x24C - 
        volatile uint32_t APP_TG_T0_LEVEL_INT_MAP;  ///< Offset: 0x250 - 
        volatile uint32_t APP_TG_T1_LEVEL_INT_MAP;  ///< Offset: 0x254 - 
        volatile uint32_t APP_TG_WDT_LEVEL_INT_MAP;  ///< Offset: 0x258 - 
        volatile uint32_t APP_TG_LACT_LEVEL_INT_MAP;  ///< Offset: 0x25C - 
        volatile uint32_t APP_TG1_T0_LEVEL_INT_MAP;  ///< Offset: 0x260 - 
        volatile uint32_t APP_TG1_T1_LEVEL_INT_MAP;  ///< Offset: 0x264 - 
        volatile uint32_t APP_TG1_WDT_LEVEL_INT_MAP;  ///< Offset: 0x268 - 
        volatile uint32_t APP_TG1_LACT_LEVEL_INT_MAP;  ///< Offset: 0x26C - 
        volatile uint32_t APP_GPIO_INTERRUPT_MAP;  ///< Offset: 0x270 - 
        volatile uint32_t APP_GPIO_INTERRUPT_NMI_MAP;  ///< Offset: 0x274 - 
        volatile uint32_t APP_CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x278 - 
        volatile uint32_t APP_CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x27C - 
        volatile uint32_t APP_CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x280 - 
        volatile uint32_t APP_CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x284 - 
        volatile uint32_t APP_SPI_INTR_0_MAP;  ///< Offset: 0x288 - 
        volatile uint32_t APP_SPI_INTR_1_MAP;  ///< Offset: 0x28C - 
        volatile uint32_t APP_SPI_INTR_2_MAP;  ///< Offset: 0x290 - 
        volatile uint32_t APP_SPI_INTR_3_MAP;  ///< Offset: 0x294 - 
        volatile uint32_t APP_I2S0_INT_MAP;  ///< Offset: 0x298 - 
        volatile uint32_t APP_I2S1_INT_MAP;  ///< Offset: 0x29C - 
        volatile uint32_t APP_UART_INTR_MAP;  ///< Offset: 0x2A0 - 
        volatile uint32_t APP_UART1_INTR_MAP;  ///< Offset: 0x2A4 - 
        volatile uint32_t APP_UART2_INTR_MAP;  ///< Offset: 0x2A8 - 
        volatile uint32_t APP_SDIO_HOST_INTERRUPT_MAP;  ///< Offset: 0x2AC - 
        volatile uint32_t APP_EMAC_INT_MAP;  ///< Offset: 0x2B0 - 
        volatile uint32_t APP_PWM0_INTR_MAP;  ///< Offset: 0x2B4 - 
        volatile uint32_t APP_PWM1_INTR_MAP;  ///< Offset: 0x2B8 - 
        volatile uint32_t APP_PWM2_INTR_MAP;  ///< Offset: 0x2BC - 
        volatile uint32_t APP_PWM3_INTR_MAP;  ///< Offset: 0x2C0 - 
        volatile uint32_t APP_LEDC_INT_MAP;  ///< Offset: 0x2C4 - 
        volatile uint32_t APP_EFUSE_INT_MAP;  ///< Offset: 0x2C8 - 
        volatile uint32_t APP_CAN_INT_MAP;  ///< Offset: 0x2CC - 
        volatile uint32_t APP_RTC_CORE_INTR_MAP;  ///< Offset: 0x2D0 - 
        volatile uint32_t APP_RMT_INTR_MAP;  ///< Offset: 0x2D4 - 
        volatile uint32_t APP_PCNT_INTR_MAP;  ///< Offset: 0x2D8 - 
        volatile uint32_t APP_I2C_EXT0_INTR_MAP;  ///< Offset: 0x2DC - 
        volatile uint32_t APP_I2C_EXT1_INTR_MAP;  ///< Offset: 0x2E0 - 
        volatile uint32_t APP_RSA_INTR_MAP;  ///< Offset: 0x2E4 - 
        volatile uint32_t APP_SPI1_DMA_INT_MAP;  ///< Offset: 0x2E8 - 
        volatile uint32_t APP_SPI2_DMA_INT_MAP;  ///< Offset: 0x2EC - 
        volatile uint32_t APP_SPI3_DMA_INT_MAP;  ///< Offset: 0x2F0 - 
        volatile uint32_t APP_WDG_INT_MAP;  ///< Offset: 0x2F4 - 
        volatile uint32_t APP_TIMER_INT1_MAP;  ///< Offset: 0x2F8 - 
        volatile uint32_t APP_TIMER_INT2_MAP;  ///< Offset: 0x2FC - 
        volatile uint32_t APP_TG_T0_EDGE_INT_MAP;  ///< Offset: 0x300 - 
        volatile uint32_t APP_TG_T1_EDGE_INT_MAP;  ///< Offset: 0x304 - 
        volatile uint32_t APP_TG_WDT_EDGE_INT_MAP;  ///< Offset: 0x308 - 
        volatile uint32_t APP_TG_LACT_EDGE_INT_MAP;  ///< Offset: 0x30C - 
        volatile uint32_t APP_TG1_T0_EDGE_INT_MAP;  ///< Offset: 0x310 - 
        volatile uint32_t APP_TG1_T1_EDGE_INT_MAP;  ///< Offset: 0x314 - 
        volatile uint32_t APP_TG1_WDT_EDGE_INT_MAP;  ///< Offset: 0x318 - 
        volatile uint32_t APP_TG1_LACT_EDGE_INT_MAP;  ///< Offset: 0x31C - 
        volatile uint32_t APP_MMU_IA_INT_MAP;  ///< Offset: 0x320 - 
        volatile uint32_t APP_MPU_IA_INT_MAP;  ///< Offset: 0x324 - 
        volatile uint32_t APP_CACHE_IA_INT_MAP;  ///< Offset: 0x328 - 
        volatile uint32_t AHBLITE_MPU_TABLE_UART;  ///< Offset: 0x32C - 
        volatile uint32_t AHBLITE_MPU_TABLE_SPI1;  ///< Offset: 0x330 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SPI0;  ///< Offset: 0x334 - 
        volatile uint32_t AHBLITE_MPU_TABLE_GPIO;  ///< Offset: 0x338 - 
        volatile uint32_t AHBLITE_MPU_TABLE_FE2;  ///< Offset: 0x33C - 
        volatile uint32_t AHBLITE_MPU_TABLE_FE;  ///< Offset: 0x340 - 
        volatile uint32_t AHBLITE_MPU_TABLE_TIMER;  ///< Offset: 0x344 - 
        volatile uint32_t AHBLITE_MPU_TABLE_RTC;  ///< Offset: 0x348 - 
        volatile uint32_t AHBLITE_MPU_TABLE_IO_MUX;  ///< Offset: 0x34C - 
        volatile uint32_t AHBLITE_MPU_TABLE_WDG;  ///< Offset: 0x350 - 
        volatile uint32_t AHBLITE_MPU_TABLE_HINF;  ///< Offset: 0x354 - 
        volatile uint32_t AHBLITE_MPU_TABLE_UHCI1;  ///< Offset: 0x358 - 
        volatile uint32_t AHBLITE_MPU_TABLE_MISC;  ///< Offset: 0x35C - 
        volatile uint32_t AHBLITE_MPU_TABLE_I2C;  ///< Offset: 0x360 - 
        volatile uint32_t AHBLITE_MPU_TABLE_I2S0;  ///< Offset: 0x364 - 
        volatile uint32_t AHBLITE_MPU_TABLE_UART1;  ///< Offset: 0x368 - 
        volatile uint32_t AHBLITE_MPU_TABLE_BT;  ///< Offset: 0x36C - 
        volatile uint32_t AHBLITE_MPU_TABLE_BT_BUFFER;  ///< Offset: 0x370 - 
        volatile uint32_t AHBLITE_MPU_TABLE_I2C_EXT0;  ///< Offset: 0x374 - 
        volatile uint32_t AHBLITE_MPU_TABLE_UHCI0;  ///< Offset: 0x378 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SLCHOST;  ///< Offset: 0x37C - 
        volatile uint32_t AHBLITE_MPU_TABLE_RMT;  ///< Offset: 0x380 - 
        volatile uint32_t AHBLITE_MPU_TABLE_PCNT;  ///< Offset: 0x384 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SLC;  ///< Offset: 0x388 - 
        volatile uint32_t AHBLITE_MPU_TABLE_LEDC;  ///< Offset: 0x38C - 
        volatile uint32_t AHBLITE_MPU_TABLE_EFUSE;  ///< Offset: 0x390 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SPI_ENCRYPT;  ///< Offset: 0x394 - 
        volatile uint32_t AHBLITE_MPU_TABLE_BB;  ///< Offset: 0x398 - 
        volatile uint32_t AHBLITE_MPU_TABLE_PWM0;  ///< Offset: 0x39C - 
        volatile uint32_t AHBLITE_MPU_TABLE_TIMERGROUP;  ///< Offset: 0x3A0 - 
        volatile uint32_t AHBLITE_MPU_TABLE_TIMERGROUP1;  ///< Offset: 0x3A4 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SPI2;  ///< Offset: 0x3A8 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SPI3;  ///< Offset: 0x3AC - 
        volatile uint32_t AHBLITE_MPU_TABLE_APB_CTRL;  ///< Offset: 0x3B0 - 
        volatile uint32_t AHBLITE_MPU_TABLE_I2C_EXT1;  ///< Offset: 0x3B4 - 
        volatile uint32_t AHBLITE_MPU_TABLE_SDIO_HOST;  ///< Offset: 0x3B8 - 
        volatile uint32_t AHBLITE_MPU_TABLE_EMAC;  ///< Offset: 0x3BC - 
        volatile uint32_t AHBLITE_MPU_TABLE_CAN;  ///< Offset: 0x3C0 - 
        volatile uint32_t AHBLITE_MPU_TABLE_PWM1;  ///< Offset: 0x3C4 - 
        volatile uint32_t AHBLITE_MPU_TABLE_I2S1;  ///< Offset: 0x3C8 - 
        volatile uint32_t AHBLITE_MPU_TABLE_UART2;  ///< Offset: 0x3CC - 
        volatile uint32_t AHBLITE_MPU_TABLE_PWM2;  ///< Offset: 0x3D0 - 
        volatile uint32_t AHBLITE_MPU_TABLE_PWM3;  ///< Offset: 0x3D4 - 
        volatile uint32_t AHBLITE_MPU_TABLE_RWBT;  ///< Offset: 0x3D8 - 
        volatile uint32_t AHBLITE_MPU_TABLE_BTMAC;  ///< Offset: 0x3DC - 
        volatile uint32_t AHBLITE_MPU_TABLE_WIFIMAC;  ///< Offset: 0x3E0 - 
        volatile uint32_t AHBLITE_MPU_TABLE_PWR;  ///< Offset: 0x3E4 - 
        volatile uint32_t MEM_ACCESS_DBUG0;  ///< Offset: 0x3E8 - 
        volatile uint32_t MEM_ACCESS_DBUG1;  ///< Offset: 0x3EC - 
        volatile uint32_t PRO_DCACHE_DBUG0;  ///< Offset: 0x3F0 - 
        volatile uint32_t PRO_DCACHE_DBUG1;  ///< Offset: 0x3F4 - 
        volatile uint32_t PRO_DCACHE_DBUG2;  ///< Offset: 0x3F8 - 
        volatile uint32_t PRO_DCACHE_DBUG3;  ///< Offset: 0x3FC - 
        volatile uint32_t PRO_DCACHE_DBUG4;  ///< Offset: 0x400 - 
        volatile uint32_t PRO_DCACHE_DBUG5;  ///< Offset: 0x404 - 
        volatile uint32_t PRO_DCACHE_DBUG6;  ///< Offset: 0x408 - 
        volatile uint32_t PRO_DCACHE_DBUG7;  ///< Offset: 0x40C - 
        volatile uint32_t PRO_DCACHE_DBUG8;  ///< Offset: 0x410 - 
        volatile uint32_t PRO_DCACHE_DBUG9;  ///< Offset: 0x414 - 
        volatile uint32_t APP_DCACHE_DBUG0;  ///< Offset: 0x418 - 
        volatile uint32_t APP_DCACHE_DBUG1;  ///< Offset: 0x41C - 
        volatile uint32_t APP_DCACHE_DBUG2;  ///< Offset: 0x420 - 
        volatile uint32_t APP_DCACHE_DBUG3;  ///< Offset: 0x424 - 
        volatile uint32_t APP_DCACHE_DBUG4;  ///< Offset: 0x428 - 
        volatile uint32_t APP_DCACHE_DBUG5;  ///< Offset: 0x42C - 
        volatile uint32_t APP_DCACHE_DBUG6;  ///< Offset: 0x430 - 
        volatile uint32_t APP_DCACHE_DBUG7;  ///< Offset: 0x434 - 
        volatile uint32_t APP_DCACHE_DBUG8;  ///< Offset: 0x438 - 
        volatile uint32_t APP_DCACHE_DBUG9;  ///< Offset: 0x43C - 
        volatile uint32_t PRO_CPU_RECORD_CTRL;  ///< Offset: 0x440 - 
        volatile uint32_t PRO_CPU_RECORD_STATUS;  ///< Offset: 0x444 - 
        volatile uint32_t PRO_CPU_RECORD_PID;  ///< Offset: 0x448 - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGINST;  ///< Offset: 0x44C - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGSTATUS;  ///< Offset: 0x450 - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGDATA;  ///< Offset: 0x454 - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGPC;  ///< Offset: 0x458 - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGLS0STAT;  ///< Offset: 0x45C - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGLS0ADDR;  ///< Offset: 0x460 - 
        volatile uint32_t PRO_CPU_RECORD_PDEBUGLS0DATA;  ///< Offset: 0x464 - 
        volatile uint32_t APP_CPU_RECORD_CTRL;  ///< Offset: 0x468 - 
        volatile uint32_t APP_CPU_RECORD_STATUS;  ///< Offset: 0x46C - 
        volatile uint32_t APP_CPU_RECORD_PID;  ///< Offset: 0x470 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGINST;  ///< Offset: 0x474 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGSTATUS;  ///< Offset: 0x478 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGDATA;  ///< Offset: 0x47C - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGPC;  ///< Offset: 0x480 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGLS0STAT;  ///< Offset: 0x484 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGLS0ADDR;  ///< Offset: 0x488 - 
        volatile uint32_t APP_CPU_RECORD_PDEBUGLS0DATA;  ///< Offset: 0x48C - 
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x490 - 
        volatile uint32_t ROM_MPU_TABLE0;  ///< Offset: 0x494 - 
        volatile uint32_t ROM_MPU_TABLE1;  ///< Offset: 0x498 - 
        volatile uint32_t ROM_MPU_TABLE2;  ///< Offset: 0x49C - 
        volatile uint32_t ROM_MPU_TABLE3;  ///< Offset: 0x4A0 - 
        volatile uint32_t SHROM_MPU_TABLE0;  ///< Offset: 0x4A4 - 
        volatile uint32_t SHROM_MPU_TABLE1;  ///< Offset: 0x4A8 - 
        volatile uint32_t SHROM_MPU_TABLE2;  ///< Offset: 0x4AC - 
        volatile uint32_t SHROM_MPU_TABLE3;  ///< Offset: 0x4B0 - 
        volatile uint32_t SHROM_MPU_TABLE4;  ///< Offset: 0x4B4 - 
        volatile uint32_t SHROM_MPU_TABLE5;  ///< Offset: 0x4B8 - 
        volatile uint32_t SHROM_MPU_TABLE6;  ///< Offset: 0x4BC - 
        volatile uint32_t SHROM_MPU_TABLE7;  ///< Offset: 0x4C0 - 
        volatile uint32_t SHROM_MPU_TABLE8;  ///< Offset: 0x4C4 - 
        volatile uint32_t SHROM_MPU_TABLE9;  ///< Offset: 0x4C8 - 
        volatile uint32_t SHROM_MPU_TABLE10;  ///< Offset: 0x4CC - 
        volatile uint32_t SHROM_MPU_TABLE11;  ///< Offset: 0x4D0 - 
        volatile uint32_t SHROM_MPU_TABLE12;  ///< Offset: 0x4D4 - 
        volatile uint32_t SHROM_MPU_TABLE13;  ///< Offset: 0x4D8 - 
        volatile uint32_t SHROM_MPU_TABLE14;  ///< Offset: 0x4DC - 
        volatile uint32_t SHROM_MPU_TABLE15;  ///< Offset: 0x4E0 - 
        volatile uint32_t SHROM_MPU_TABLE16;  ///< Offset: 0x4E4 - 
        volatile uint32_t SHROM_MPU_TABLE17;  ///< Offset: 0x4E8 - 
        volatile uint32_t SHROM_MPU_TABLE18;  ///< Offset: 0x4EC - 
        volatile uint32_t SHROM_MPU_TABLE19;  ///< Offset: 0x4F0 - 
        volatile uint32_t SHROM_MPU_TABLE20;  ///< Offset: 0x4F4 - 
        volatile uint32_t SHROM_MPU_TABLE21;  ///< Offset: 0x4F8 - 
        volatile uint32_t SHROM_MPU_TABLE22;  ///< Offset: 0x4FC - 
        volatile uint32_t SHROM_MPU_TABLE23;  ///< Offset: 0x500 - 
        volatile uint32_t IMMU_TABLE0;  ///< Offset: 0x504 - 
        volatile uint32_t IMMU_TABLE1;  ///< Offset: 0x508 - 
        volatile uint32_t IMMU_TABLE2;  ///< Offset: 0x50C - 
        volatile uint32_t IMMU_TABLE3;  ///< Offset: 0x510 - 
        volatile uint32_t IMMU_TABLE4;  ///< Offset: 0x514 - 
        volatile uint32_t IMMU_TABLE5;  ///< Offset: 0x518 - 
        volatile uint32_t IMMU_TABLE6;  ///< Offset: 0x51C - 
        volatile uint32_t IMMU_TABLE7;  ///< Offset: 0x520 - 
        volatile uint32_t IMMU_TABLE8;  ///< Offset: 0x524 - 
        volatile uint32_t IMMU_TABLE9;  ///< Offset: 0x528 - 
        volatile uint32_t IMMU_TABLE10;  ///< Offset: 0x52C - 
        volatile uint32_t IMMU_TABLE11;  ///< Offset: 0x530 - 
        volatile uint32_t IMMU_TABLE12;  ///< Offset: 0x534 - 
        volatile uint32_t IMMU_TABLE13;  ///< Offset: 0x538 - 
        volatile uint32_t IMMU_TABLE14;  ///< Offset: 0x53C - 
        volatile uint32_t IMMU_TABLE15;  ///< Offset: 0x540 - 
        volatile uint32_t DMMU_TABLE0;  ///< Offset: 0x544 - 
        volatile uint32_t DMMU_TABLE1;  ///< Offset: 0x548 - 
        volatile uint32_t DMMU_TABLE2;  ///< Offset: 0x54C - 
        volatile uint32_t DMMU_TABLE3;  ///< Offset: 0x550 - 
        volatile uint32_t DMMU_TABLE4;  ///< Offset: 0x554 - 
        volatile uint32_t DMMU_TABLE5;  ///< Offset: 0x558 - 
        volatile uint32_t DMMU_TABLE6;  ///< Offset: 0x55C - 
        volatile uint32_t DMMU_TABLE7;  ///< Offset: 0x560 - 
        volatile uint32_t DMMU_TABLE8;  ///< Offset: 0x564 - 
        volatile uint32_t DMMU_TABLE9;  ///< Offset: 0x568 - 
        volatile uint32_t DMMU_TABLE10;  ///< Offset: 0x56C - 
        volatile uint32_t DMMU_TABLE11;  ///< Offset: 0x570 - 
        volatile uint32_t DMMU_TABLE12;  ///< Offset: 0x574 - 
        volatile uint32_t DMMU_TABLE13;  ///< Offset: 0x578 - 
        volatile uint32_t DMMU_TABLE14;  ///< Offset: 0x57C - 
        volatile uint32_t DMMU_TABLE15;  ///< Offset: 0x580 - 
        volatile uint32_t PRO_INTRUSION_CTRL;  ///< Offset: 0x584 - 
        volatile uint32_t PRO_INTRUSION_STATUS;  ///< Offset: 0x588 - 
        volatile uint32_t APP_INTRUSION_CTRL;  ///< Offset: 0x58C - 
        volatile uint32_t APP_INTRUSION_STATUS;  ///< Offset: 0x590 - 
        volatile uint32_t FRONT_END_MEM_PD;  ///< Offset: 0x594 - 
        volatile uint32_t MMU_IA_INT_EN;  ///< Offset: 0x598 - 
        volatile uint32_t MPU_IA_INT_EN;  ///< Offset: 0x59C - 
        volatile uint32_t CACHE_IA_INT_EN;  ///< Offset: 0x5A0 - Interrupt enable bits for various invalid cache access reasons
        volatile uint32_t SECURE_BOOT_CTRL;  ///< Offset: 0x5A4 - 
        volatile uint32_t SPI_DMA_CHAN_SEL;  ///< Offset: 0x5A8 - 
        volatile uint32_t PRO_VECBASE_CTRL;  ///< Offset: 0x5AC - 
        volatile uint32_t PRO_VECBASE_SET;  ///< Offset: 0x5B0 - 
        volatile uint32_t APP_VECBASE_CTRL;  ///< Offset: 0x5B4 - 
        volatile uint32_t APP_VECBASE_SET;  ///< Offset: 0x5B8 - 
        volatile uint32_t DATE;  ///< Offset: 0xFFC - 
    };

    /// Peripheral instances
    inline Registers* DPORT = reinterpret_cast<Registers*>(DPORT_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);

    // Bit definitions
    /// PRO_BOOT_REMAP_CTRL Register bits
    namespace pro_boot_remap_ctrl_bits {
        constexpr uint32_t PRO_BOOT_REMAP = (1U << 0);  ///< PRO_BOOT_REMAP
    }

    /// APP_BOOT_REMAP_CTRL Register bits
    namespace app_boot_remap_ctrl_bits {
        constexpr uint32_t APP_BOOT_REMAP = (1U << 0);  ///< APP_BOOT_REMAP
    }

    /// ACCESS_CHECK Register bits
    namespace access_check_bits {
        constexpr uint32_t PRO = (1U << 0);  ///< PRO
        constexpr uint32_t APP = (1U << 8);  ///< APP
    }

    /// PRO_DPORT_APB_MASK0 Register bits
    namespace pro_dport_apb_mask0_bits {
        constexpr uint32_t PRODPORT_APB_MASK0 = (32 << 0);  ///< PRODPORT_APB_MASK0
    }

    /// PRO_DPORT_APB_MASK1 Register bits
    namespace pro_dport_apb_mask1_bits {
        constexpr uint32_t PRODPORT_APB_MASK1 = (32 << 0);  ///< PRODPORT_APB_MASK1
    }

    /// APP_DPORT_APB_MASK0 Register bits
    namespace app_dport_apb_mask0_bits {
        constexpr uint32_t APPDPORT_APB_MASK0 = (32 << 0);  ///< APPDPORT_APB_MASK0
    }

    /// APP_DPORT_APB_MASK1 Register bits
    namespace app_dport_apb_mask1_bits {
        constexpr uint32_t APPDPORT_APB_MASK1 = (32 << 0);  ///< APPDPORT_APB_MASK1
    }

    /// PERI_CLK_EN Register bits
    namespace peri_clk_en_bits {
        constexpr uint32_t PERI_CLK_EN = (32 << 0);  ///< PERI_CLK_EN
    }

    /// PERI_RST_EN Register bits
    namespace peri_rst_en_bits {
        constexpr uint32_t PERI_RST_EN = (32 << 0);  ///< PERI_RST_EN
    }

    /// WIFI_BB_CFG Register bits
    namespace wifi_bb_cfg_bits {
        constexpr uint32_t WIFI_BB_CFG = (32 << 0);  ///< WIFI_BB_CFG
    }

    /// WIFI_BB_CFG_2 Register bits
    namespace wifi_bb_cfg_2_bits {
        constexpr uint32_t WIFI_BB_CFG_2 = (32 << 0);  ///< WIFI_BB_CFG_2
    }

    /// APPCPU_CTRL_A Register bits
    namespace appcpu_ctrl_a_bits {
        constexpr uint32_t APPCPU_RESETTING = (1U << 0);  ///< APPCPU_RESETTING
    }

    /// APPCPU_CTRL_B Register bits
    namespace appcpu_ctrl_b_bits {
        constexpr uint32_t APPCPU_CLKGATE_EN = (1U << 0);  ///< APPCPU_CLKGATE_EN
    }

    /// APPCPU_CTRL_C Register bits
    namespace appcpu_ctrl_c_bits {
        constexpr uint32_t APPCPU_RUNSTALL = (1U << 0);  ///< APPCPU_RUNSTALL
    }

    /// APPCPU_CTRL_D Register bits
    namespace appcpu_ctrl_d_bits {
        constexpr uint32_t APPCPU_BOOT_ADDR = (32 << 0);  ///< APPCPU_BOOT_ADDR
    }

    /// CPU_PER_CONF Register bits
    namespace cpu_per_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< CPUPERIOD_SEL
        constexpr uint32_t LOWSPEED_CLK_SEL = (1U << 2);  ///< LOWSPEED_CLK_SEL
        constexpr uint32_t FAST_CLK_RTC_SEL = (1U << 3);  ///< FAST_CLK_RTC_SEL
    }

    /// PRO_CACHE_CTRL Register bits
    namespace pro_cache_ctrl_bits {
        constexpr uint32_t PRO_CACHE_MODE = (1U << 2);  ///< PRO_CACHE_MODE
        constexpr uint32_t PRO_CACHE_ENABLE = (1U << 3);  ///< PRO_CACHE_ENABLE
        constexpr uint32_t PRO_CACHE_FLUSH_ENA = (1U << 4);  ///< PRO_CACHE_FLUSH_ENA
        constexpr uint32_t PRO_CACHE_FLUSH_DONE = (1U << 5);  ///< PRO_CACHE_FLUSH_DONE
        constexpr uint32_t PRO_CACHE_LOCK_0_EN = (1U << 6);  ///< PRO_CACHE_LOCK_0_EN
        constexpr uint32_t PRO_CACHE_LOCK_1_EN = (1U << 7);  ///< PRO_CACHE_LOCK_1_EN
        constexpr uint32_t PRO_CACHE_LOCK_2_EN = (1U << 8);  ///< PRO_CACHE_LOCK_2_EN
        constexpr uint32_t PRO_CACHE_LOCK_3_EN = (1U << 9);  ///< PRO_CACHE_LOCK_3_EN
        constexpr uint32_t PRO_SINGLE_IRAM_ENA = (1U << 10);  ///< PRO_SINGLE_IRAM_ENA
        constexpr uint32_t PRO_DRAM_SPLIT = (1U << 11);  ///< PRO_DRAM_SPLIT
        constexpr uint32_t PRO_AHB_SPI_REQ = (1U << 12);  ///< PRO_AHB_SPI_REQ
        constexpr uint32_t PRO_SLAVE_REQ = (1U << 13);  ///< PRO_SLAVE_REQ
        constexpr uint32_t AHB_SPI_REQ = (1U << 14);  ///< AHB_SPI_REQ
        constexpr uint32_t SLAVE_REQ = (1U << 15);  ///< SLAVE_REQ
        constexpr uint32_t PRO_DRAM_HL = (1U << 16);  ///< PRO_DRAM_HL
    }

    /// PRO_CACHE_CTRL1 Register bits
    namespace pro_cache_ctrl1_bits {
        constexpr uint32_t PRO_CACHE_MASK_IRAM0 = (1U << 0);  ///< PRO_CACHE_MASK_IRAM0
        constexpr uint32_t PRO_CACHE_MASK_IRAM1 = (1U << 1);  ///< PRO_CACHE_MASK_IRAM1
        constexpr uint32_t PRO_CACHE_MASK_IROM0 = (1U << 2);  ///< PRO_CACHE_MASK_IROM0
        constexpr uint32_t PRO_CACHE_MASK_DRAM1 = (1U << 3);  ///< PRO_CACHE_MASK_DRAM1
        constexpr uint32_t PRO_CACHE_MASK_DROM0 = (1U << 4);  ///< PRO_CACHE_MASK_DROM0
        constexpr uint32_t PRO_CACHE_MASK_OPSDRAM = (1U << 5);  ///< PRO_CACHE_MASK_OPSDRAM
        constexpr uint32_t PRO_CMMU_SRAM_PAGE_MODE = (3 << 6);  ///< PRO_CMMU_SRAM_PAGE_MODE
        constexpr uint32_t PRO_CMMU_FLASH_PAGE_MODE = (2 << 9);  ///< PRO_CMMU_FLASH_PAGE_MODE
        constexpr uint32_t PRO_CMMU_FORCE_ON = (1U << 11);  ///< PRO_CMMU_FORCE_ON
        constexpr uint32_t PRO_CMMU_PD = (1U << 12);  ///< PRO_CMMU_PD
        constexpr uint32_t PRO_CACHE_MMU_IA_CLR = (1U << 13);  ///< PRO_CACHE_MMU_IA_CLR
    }

    /// PRO_CACHE_LOCK_0_ADDR Register bits
    namespace pro_cache_lock_0_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// PRO_CACHE_LOCK_1_ADDR Register bits
    namespace pro_cache_lock_1_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// PRO_CACHE_LOCK_2_ADDR Register bits
    namespace pro_cache_lock_2_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// PRO_CACHE_LOCK_3_ADDR Register bits
    namespace pro_cache_lock_3_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// APP_CACHE_CTRL Register bits
    namespace app_cache_ctrl_bits {
        constexpr uint32_t APP_CACHE_MODE = (1U << 2);  ///< APP_CACHE_MODE
        constexpr uint32_t APP_CACHE_ENABLE = (1U << 3);  ///< APP_CACHE_ENABLE
        constexpr uint32_t APP_CACHE_FLUSH_ENA = (1U << 4);  ///< APP_CACHE_FLUSH_ENA
        constexpr uint32_t APP_CACHE_FLUSH_DONE = (1U << 5);  ///< APP_CACHE_FLUSH_DONE
        constexpr uint32_t APP_CACHE_LOCK_0_EN = (1U << 6);  ///< APP_CACHE_LOCK_0_EN
        constexpr uint32_t APP_CACHE_LOCK_1_EN = (1U << 7);  ///< APP_CACHE_LOCK_1_EN
        constexpr uint32_t APP_CACHE_LOCK_2_EN = (1U << 8);  ///< APP_CACHE_LOCK_2_EN
        constexpr uint32_t APP_CACHE_LOCK_3_EN = (1U << 9);  ///< APP_CACHE_LOCK_3_EN
        constexpr uint32_t APP_SINGLE_IRAM_ENA = (1U << 10);  ///< APP_SINGLE_IRAM_ENA
        constexpr uint32_t APP_DRAM_SPLIT = (1U << 11);  ///< APP_DRAM_SPLIT
        constexpr uint32_t APP_AHB_SPI_REQ = (1U << 12);  ///< APP_AHB_SPI_REQ
        constexpr uint32_t APP_SLAVE_REQ = (1U << 13);  ///< APP_SLAVE_REQ
        constexpr uint32_t APP_DRAM_HL = (1U << 14);  ///< APP_DRAM_HL
    }

    /// APP_CACHE_CTRL1 Register bits
    namespace app_cache_ctrl1_bits {
        constexpr uint32_t APP_CACHE_MASK_IRAM0 = (1U << 0);  ///< APP_CACHE_MASK_IRAM0
        constexpr uint32_t APP_CACHE_MASK_IRAM1 = (1U << 1);  ///< APP_CACHE_MASK_IRAM1
        constexpr uint32_t APP_CACHE_MASK_IROM0 = (1U << 2);  ///< APP_CACHE_MASK_IROM0
        constexpr uint32_t APP_CACHE_MASK_DRAM1 = (1U << 3);  ///< APP_CACHE_MASK_DRAM1
        constexpr uint32_t APP_CACHE_MASK_DROM0 = (1U << 4);  ///< APP_CACHE_MASK_DROM0
        constexpr uint32_t APP_CACHE_MASK_OPSDRAM = (1U << 5);  ///< APP_CACHE_MASK_OPSDRAM
        constexpr uint32_t APP_CMMU_SRAM_PAGE_MODE = (3 << 6);  ///< APP_CMMU_SRAM_PAGE_MODE
        constexpr uint32_t APP_CMMU_FLASH_PAGE_MODE = (2 << 9);  ///< APP_CMMU_FLASH_PAGE_MODE
        constexpr uint32_t APP_CMMU_FORCE_ON = (1U << 11);  ///< APP_CMMU_FORCE_ON
        constexpr uint32_t APP_CMMU_PD = (1U << 12);  ///< APP_CMMU_PD
        constexpr uint32_t APP_CACHE_MMU_IA_CLR = (1U << 13);  ///< APP_CACHE_MMU_IA_CLR
    }

    /// APP_CACHE_LOCK_0_ADDR Register bits
    namespace app_cache_lock_0_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// APP_CACHE_LOCK_1_ADDR Register bits
    namespace app_cache_lock_1_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// APP_CACHE_LOCK_2_ADDR Register bits
    namespace app_cache_lock_2_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// APP_CACHE_LOCK_3_ADDR Register bits
    namespace app_cache_lock_3_addr_bits {
        constexpr uint32_t PRE = (14 << 0);  ///< PRE
        constexpr uint32_t MIN = (4 << 14);  ///< MIN
        constexpr uint32_t MAX = (4 << 18);  ///< MAX
    }

    /// TRACEMEM_MUX_MODE Register bits
    namespace tracemem_mux_mode_bits {
        constexpr uint32_t TRACEMEM_MUX_MODE = (2 << 0);  ///< TRACEMEM_MUX_MODE
    }

    /// PRO_TRACEMEM_ENA Register bits
    namespace pro_tracemem_ena_bits {
        constexpr uint32_t PRO_TRACEMEM_ENA = (1U << 0);  ///< PRO_TRACEMEM_ENA
    }

    /// APP_TRACEMEM_ENA Register bits
    namespace app_tracemem_ena_bits {
        constexpr uint32_t APP_TRACEMEM_ENA = (1U << 0);  ///< APP_TRACEMEM_ENA
    }

    /// CACHE_MUX_MODE Register bits
    namespace cache_mux_mode_bits {
        constexpr uint32_t CACHE_MUX_MODE = (2 << 0);  ///< CACHE_MUX_MODE
    }

    /// IMMU_PAGE_MODE Register bits
    namespace immu_page_mode_bits {
        constexpr uint32_t INTERNAL_SRAM_IMMU_ENA = (1U << 0);  ///< INTERNAL_SRAM_IMMU_ENA
        constexpr uint32_t IMMU_PAGE_MODE = (2 << 1);  ///< IMMU_PAGE_MODE
    }

    /// DMMU_PAGE_MODE Register bits
    namespace dmmu_page_mode_bits {
        constexpr uint32_t INTERNAL_SRAM_DMMU_ENA = (1U << 0);  ///< INTERNAL_SRAM_DMMU_ENA
        constexpr uint32_t DMMU_PAGE_MODE = (2 << 1);  ///< DMMU_PAGE_MODE
    }

    /// ROM_MPU_ENA Register bits
    namespace rom_mpu_ena_bits {
        constexpr uint32_t SHARE_ROM_MPU_ENA = (1U << 0);  ///< SHARE_ROM_MPU_ENA
        constexpr uint32_t PRO_ROM_MPU_ENA = (1U << 1);  ///< PRO_ROM_MPU_ENA
        constexpr uint32_t APP_ROM_MPU_ENA = (1U << 2);  ///< APP_ROM_MPU_ENA
    }

    /// MEM_PD_MASK Register bits
    namespace mem_pd_mask_bits {
        constexpr uint32_t LSLP_MEM_PD_MASK = (1U << 0);  ///< LSLP_MEM_PD_MASK
    }

    /// ROM_PD_CTRL Register bits
    namespace rom_pd_ctrl_bits {
        constexpr uint32_t PRO_ROM_PD = (1U << 0);  ///< PRO_ROM_PD
        constexpr uint32_t APP_ROM_PD = (1U << 1);  ///< APP_ROM_PD
        constexpr uint32_t SHARE_ROM_PD = (6 << 2);  ///< SHARE_ROM_PD
    }

    /// ROM_FO_CTRL Register bits
    namespace rom_fo_ctrl_bits {
        constexpr uint32_t PRO_ROM_FO = (1U << 0);  ///< PRO_ROM_FO
        constexpr uint32_t APP_ROM_FO = (1U << 1);  ///< APP_ROM_FO
        constexpr uint32_t SHARE_ROM_FO = (6 << 2);  ///< SHARE_ROM_FO
    }

    /// SRAM_PD_CTRL_0 Register bits
    namespace sram_pd_ctrl_0_bits {
        constexpr uint32_t SRAM_PD_0 = (32 << 0);  ///< SRAM_PD_0
    }

    /// SRAM_PD_CTRL_1 Register bits
    namespace sram_pd_ctrl_1_bits {
        constexpr uint32_t SRAM_PD_1 = (1U << 0);  ///< SRAM_PD_1
    }

    /// SRAM_FO_CTRL_0 Register bits
    namespace sram_fo_ctrl_0_bits {
        constexpr uint32_t SRAM_FO_0 = (32 << 0);  ///< SRAM_FO_0
    }

    /// SRAM_FO_CTRL_1 Register bits
    namespace sram_fo_ctrl_1_bits {
        constexpr uint32_t SRAM_FO_1 = (1U << 0);  ///< SRAM_FO_1
    }

    /// IRAM_DRAM_AHB_SEL Register bits
    namespace iram_dram_ahb_sel_bits {
        constexpr uint32_t MASK_PRO_IRAM = (1U << 0);  ///< MASK_PRO_IRAM
        constexpr uint32_t MASK_APP_IRAM = (1U << 1);  ///< MASK_APP_IRAM
        constexpr uint32_t MASK_PRO_DRAM = (1U << 2);  ///< MASK_PRO_DRAM
        constexpr uint32_t MASK_APP_DRAM = (1U << 3);  ///< MASK_APP_DRAM
        constexpr uint32_t MASK_AHB = (1U << 4);  ///< MASK_AHB
        constexpr uint32_t MAC_DUMP_MODE = (2 << 5);  ///< MAC_DUMP_MODE
    }

    /// TAG_FO_CTRL Register bits
    namespace tag_fo_ctrl_bits {
        constexpr uint32_t PRO_CACHE_TAG_FORCE_ON = (1U << 0);  ///< PRO_CACHE_TAG_FORCE_ON
        constexpr uint32_t PRO_CACHE_TAG_PD = (1U << 1);  ///< PRO_CACHE_TAG_PD
        constexpr uint32_t APP_CACHE_TAG_FORCE_ON = (1U << 8);  ///< APP_CACHE_TAG_FORCE_ON
        constexpr uint32_t APP_CACHE_TAG_PD = (1U << 9);  ///< APP_CACHE_TAG_PD
    }

    /// AHB_LITE_MASK Register bits
    namespace ahb_lite_mask_bits {
        constexpr uint32_t PRO = (1U << 0);  ///< PRO
        constexpr uint32_t APP = (1U << 4);  ///< APP
        constexpr uint32_t SDIO = (1U << 8);  ///< SDIO
        constexpr uint32_t PRODPORT = (1U << 9);  ///< PRODPORT
        constexpr uint32_t APPDPORT = (1U << 10);  ///< APPDPORT
        constexpr uint32_t AHB_LITE_SDHOST_PID = (3 << 11);  ///< AHB_LITE_SDHOST_PID
    }

    /// AHB_MPU_TABLE_0 Register bits
    namespace ahb_mpu_table_0_bits {
        constexpr uint32_t AHB_ACCESS_GRANT_0 = (32 << 0);  ///< AHB_ACCESS_GRANT_0
    }

    /// AHB_MPU_TABLE_1 Register bits
    namespace ahb_mpu_table_1_bits {
        constexpr uint32_t AHB_ACCESS_GRANT_1 = (9 << 0);  ///< AHB_ACCESS_GRANT_1
    }

    /// HOST_INF_SEL Register bits
    namespace host_inf_sel_bits {
        constexpr uint32_t PERI_IO_SWAP = (8 << 0);  ///< PERI_IO_SWAP
        constexpr uint32_t LINK_DEVICE_SEL = (8 << 8);  ///< LINK_DEVICE_SEL
    }

    /// PERIP_CLK_EN Register bits
    namespace perip_clk_en_bits {
        constexpr uint32_t TIMERS_CLK_EN = (1U << 0);  ///< TIMERS_CLK_EN
        constexpr uint32_t SPI01_CLK_EN = (1U << 1);  ///< SPI01_CLK_EN
        constexpr uint32_t UART_CLK_EN = (1U << 2);  ///< UART_CLK_EN
        constexpr uint32_t WDG_CLK_EN = (1U << 3);  ///< WDG_CLK_EN
        constexpr uint32_t I2S0_CLK_EN = (1U << 4);  ///< I2S0_CLK_EN
        constexpr uint32_t UART1_CLK_EN = (1U << 5);  ///< UART1_CLK_EN
        constexpr uint32_t SPI2_CLK_EN = (1U << 6);  ///< SPI2_CLK_EN
        constexpr uint32_t I2C0_EXT0_CLK_EN = (1U << 7);  ///< I2C0_EXT0_CLK_EN
        constexpr uint32_t UHCI0_CLK_EN = (1U << 8);  ///< UHCI0_CLK_EN
        constexpr uint32_t RMT_CLK_EN = (1U << 9);  ///< RMT_CLK_EN
        constexpr uint32_t PCNT_CLK_EN = (1U << 10);  ///< PCNT_CLK_EN
        constexpr uint32_t LEDC_CLK_EN = (1U << 11);  ///< LEDC_CLK_EN
        constexpr uint32_t UHCI1_CLK_EN = (1U << 12);  ///< UHCI1_CLK_EN
        constexpr uint32_t TIMERGROUP_CLK_EN = (1U << 13);  ///< TIMERGROUP_CLK_EN
        constexpr uint32_t EFUSE_CLK_EN = (1U << 14);  ///< EFUSE_CLK_EN
        constexpr uint32_t TIMERGROUP1_CLK_EN = (1U << 15);  ///< TIMERGROUP1_CLK_EN
        constexpr uint32_t SPI3_CLK_EN = (1U << 16);  ///< SPI3_CLK_EN
        constexpr uint32_t PWM0_CLK_EN = (1U << 17);  ///< PWM0_CLK_EN
        constexpr uint32_t I2C_EXT1_CLK_EN = (1U << 18);  ///< I2C_EXT1_CLK_EN
        constexpr uint32_t TWAI_CLK_EN = (1U << 19);  ///< TWAI_CLK_EN
        constexpr uint32_t PWM1_CLK_EN = (1U << 20);  ///< PWM1_CLK_EN
        constexpr uint32_t I2S1_CLK_EN = (1U << 21);  ///< I2S1_CLK_EN
        constexpr uint32_t SPI_DMA_CLK_EN = (1U << 22);  ///< SPI_DMA_CLK_EN
        constexpr uint32_t UART2_CLK_EN = (1U << 23);  ///< UART2_CLK_EN
        constexpr uint32_t UART_MEM_CLK_EN = (1U << 24);  ///< UART_MEM_CLK_EN
        constexpr uint32_t PWM2_CLK_EN = (1U << 25);  ///< PWM2_CLK_EN
        constexpr uint32_t PWM3_CLK_EN = (1U << 26);  ///< PWM3_CLK_EN
    }

    /// PERIP_RST_EN Register bits
    namespace perip_rst_en_bits {
        constexpr uint32_t TIMERS_RST = (1U << 0);  ///< TIMERS_RST
        constexpr uint32_t SPI01_RST = (1U << 1);  ///< SPI01_RST
        constexpr uint32_t UART_RST = (1U << 2);  ///< UART_RST
        constexpr uint32_t WDG_RST = (1U << 3);  ///< WDG_RST
        constexpr uint32_t I2S0_RST = (1U << 4);  ///< I2S0_RST
        constexpr uint32_t UART1_RST = (1U << 5);  ///< UART1_RST
        constexpr uint32_t SPI2_RST = (1U << 6);  ///< SPI2_RST
        constexpr uint32_t I2C0_EXT0_RST = (1U << 7);  ///< I2C0_EXT0_RST
        constexpr uint32_t UHCI0_RST = (1U << 8);  ///< UHCI0_RST
        constexpr uint32_t RMT_RST = (1U << 9);  ///< RMT_RST
        constexpr uint32_t PCNT_RST = (1U << 10);  ///< PCNT_RST
        constexpr uint32_t LEDC_RST = (1U << 11);  ///< LEDC_RST
        constexpr uint32_t UHCI1_RST = (1U << 12);  ///< UHCI1_RST
        constexpr uint32_t TIMERGROUP_RST = (1U << 13);  ///< TIMERGROUP_RST
        constexpr uint32_t EFUSE_RST = (1U << 14);  ///< EFUSE_RST
        constexpr uint32_t TIMERGROUP1_RST = (1U << 15);  ///< TIMERGROUP1_RST
        constexpr uint32_t SPI3_RST = (1U << 16);  ///< SPI3_RST
        constexpr uint32_t PWM0_RST = (1U << 17);  ///< PWM0_RST
        constexpr uint32_t I2C_EXT1_RST = (1U << 18);  ///< I2C_EXT1_RST
        constexpr uint32_t TWAI_RST = (1U << 19);  ///< TWAI_RST
        constexpr uint32_t PWM1_RST = (1U << 20);  ///< PWM1_RST
        constexpr uint32_t I2S1_RST = (1U << 21);  ///< I2S1_RST
        constexpr uint32_t SPI_DMA_RST = (1U << 22);  ///< SPI_DMA_RST
        constexpr uint32_t UART2_RST = (1U << 23);  ///< UART2_RST
        constexpr uint32_t UART_MEM_RST = (1U << 24);  ///< UART_MEM_RST
        constexpr uint32_t PWM2_RST = (1U << 25);  ///< PWM2_RST
        constexpr uint32_t PWM3_RST = (1U << 26);  ///< PWM3_RST
    }

    /// SLAVE_SPI_CONFIG Register bits
    namespace slave_spi_config_bits {
        constexpr uint32_t SLAVE_SPI_MASK_PRO = (1U << 0);  ///< SLAVE_SPI_MASK_PRO
        constexpr uint32_t SLAVE_SPI_MASK_APP = (1U << 4);  ///< SLAVE_SPI_MASK_APP
        constexpr uint32_t SPI_ENCRYPT_ENABLE = (1U << 8);  ///< SPI_ENCRYPT_ENABLE
        constexpr uint32_t SPI_DECRYPT_ENABLE = (1U << 12);  ///< SPI_DECRYPT_ENABLE
    }

    /// WIFI_CLK_EN Register bits
    namespace wifi_clk_en_bits {
        constexpr uint32_t WIFI_CLK_EN = (32 << 0);  ///< WIFI_CLK_EN
        constexpr uint32_t WIFI_CLK_WIFI_EN = (3 << 0);  ///< WIFI_CLK_WIFI_EN
        constexpr uint32_t WIFI_CLK_WIFI_BT_COMMON = (6 << 0);  ///< WIFI_CLK_WIFI_BT_COMMON
        constexpr uint32_t WIFI_CLK_BT_EN = (3 << 11);  ///< WIFI_CLK_BT_EN
    }

    /// CORE_RST_EN Register bits
    namespace core_rst_en_bits {
        constexpr uint32_t CORE_RST = (8 << 0);  ///< CORE_RST
    }

    /// BT_LPCK_DIV_INT Register bits
    namespace bt_lpck_div_int_bits {
        constexpr uint32_t BT_LPCK_DIV_NUM = (12 << 0);  ///< BT_LPCK_DIV_NUM
        constexpr uint32_t BTEXTWAKEUP_REQ = (1U << 12);  ///< BTEXTWAKEUP_REQ
    }

    /// BT_LPCK_DIV_FRAC Register bits
    namespace bt_lpck_div_frac_bits {
        constexpr uint32_t BT_LPCK_DIV_B = (12 << 0);  ///< BT_LPCK_DIV_B
        constexpr uint32_t BT_LPCK_DIV_A = (12 << 12);  ///< BT_LPCK_DIV_A
        constexpr uint32_t LPCLK_SEL_RTC_SLOW = (1U << 24);  ///< LPCLK_SEL_RTC_SLOW
        constexpr uint32_t LPCLK_SEL_8M = (1U << 25);  ///< LPCLK_SEL_8M
        constexpr uint32_t LPCLK_SEL_XTAL = (1U << 26);  ///< LPCLK_SEL_XTAL
        constexpr uint32_t LPCLK_SEL_XTAL32K = (1U << 27);  ///< LPCLK_SEL_XTAL32K
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< CPU_INTR_FROM_CPU_0
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< CPU_INTR_FROM_CPU_1
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< CPU_INTR_FROM_CPU_2
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< CPU_INTR_FROM_CPU_3
    }

    /// PRO_INTR_STATUS_0 Register bits
    namespace pro_intr_status_0_bits {
        constexpr uint32_t PRO_INTR_STATUS_0 = (32 << 0);  ///< PRO_INTR_STATUS_0
    }

    /// PRO_INTR_STATUS_1 Register bits
    namespace pro_intr_status_1_bits {
        constexpr uint32_t PRO_INTR_STATUS_1 = (32 << 0);  ///< PRO_INTR_STATUS_1
    }

    /// PRO_INTR_STATUS_2 Register bits
    namespace pro_intr_status_2_bits {
        constexpr uint32_t PRO_INTR_STATUS_2 = (32 << 0);  ///< PRO_INTR_STATUS_2
    }

    /// APP_INTR_STATUS_0 Register bits
    namespace app_intr_status_0_bits {
        constexpr uint32_t APP_INTR_STATUS_0 = (32 << 0);  ///< APP_INTR_STATUS_0
    }

    /// APP_INTR_STATUS_1 Register bits
    namespace app_intr_status_1_bits {
        constexpr uint32_t APP_INTR_STATUS_1 = (32 << 0);  ///< APP_INTR_STATUS_1
    }

    /// APP_INTR_STATUS_2 Register bits
    namespace app_intr_status_2_bits {
        constexpr uint32_t APP_INTR_STATUS_2 = (32 << 0);  ///< APP_INTR_STATUS_2
    }

    /// PRO_MAC_INTR_MAP Register bits
    namespace pro_mac_intr_map_bits {
        constexpr uint32_t PRO_MAC_INTR_MAP = (5 << 0);  ///< PRO_MAC_INTR_MAP
    }

    /// PRO_MAC_NMI_MAP Register bits
    namespace pro_mac_nmi_map_bits {
        constexpr uint32_t PRO_MAC_NMI_MAP = (5 << 0);  ///< PRO_MAC_NMI_MAP
    }

    /// PRO_BB_INT_MAP Register bits
    namespace pro_bb_int_map_bits {
        constexpr uint32_t PRO_BB_INT_MAP = (5 << 0);  ///< PRO_BB_INT_MAP
    }

    /// PRO_BT_MAC_INT_MAP Register bits
    namespace pro_bt_mac_int_map_bits {
        constexpr uint32_t PRO_BT_MAC_INT_MAP = (5 << 0);  ///< PRO_BT_MAC_INT_MAP
    }

    /// PRO_BT_BB_INT_MAP Register bits
    namespace pro_bt_bb_int_map_bits {
        constexpr uint32_t PRO_BT_BB_INT_MAP = (5 << 0);  ///< PRO_BT_BB_INT_MAP
    }

    /// PRO_BT_BB_NMI_MAP Register bits
    namespace pro_bt_bb_nmi_map_bits {
        constexpr uint32_t PRO_BT_BB_NMI_MAP = (5 << 0);  ///< PRO_BT_BB_NMI_MAP
    }

    /// PRO_RWBT_IRQ_MAP Register bits
    namespace pro_rwbt_irq_map_bits {
        constexpr uint32_t PRO_RWBT_IRQ_MAP = (5 << 0);  ///< PRO_RWBT_IRQ_MAP
    }

    /// PRO_RWBLE_IRQ_MAP Register bits
    namespace pro_rwble_irq_map_bits {
        constexpr uint32_t PRO_RWBLE_IRQ_MAP = (5 << 0);  ///< PRO_RWBLE_IRQ_MAP
    }

    /// PRO_RWBT_NMI_MAP Register bits
    namespace pro_rwbt_nmi_map_bits {
        constexpr uint32_t PRO_RWBT_NMI_MAP = (5 << 0);  ///< PRO_RWBT_NMI_MAP
    }

    /// PRO_RWBLE_NMI_MAP Register bits
    namespace pro_rwble_nmi_map_bits {
        constexpr uint32_t PRO_RWBLE_NMI_MAP = (5 << 0);  ///< PRO_RWBLE_NMI_MAP
    }

    /// PRO_SLC0_INTR_MAP Register bits
    namespace pro_slc0_intr_map_bits {
        constexpr uint32_t PRO_SLC0_INTR_MAP = (5 << 0);  ///< PRO_SLC0_INTR_MAP
    }

    /// PRO_SLC1_INTR_MAP Register bits
    namespace pro_slc1_intr_map_bits {
        constexpr uint32_t PRO_SLC1_INTR_MAP = (5 << 0);  ///< PRO_SLC1_INTR_MAP
    }

    /// PRO_UHCI0_INTR_MAP Register bits
    namespace pro_uhci0_intr_map_bits {
        constexpr uint32_t PRO_UHCI0_INTR_MAP = (5 << 0);  ///< PRO_UHCI0_INTR_MAP
    }

    /// PRO_UHCI1_INTR_MAP Register bits
    namespace pro_uhci1_intr_map_bits {
        constexpr uint32_t PRO_UHCI1_INTR_MAP = (5 << 0);  ///< PRO_UHCI1_INTR_MAP
    }

    /// PRO_TG_T0_LEVEL_INT_MAP Register bits
    namespace pro_tg_t0_level_int_map_bits {
        constexpr uint32_t PRO_TG_T0_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG_T0_LEVEL_INT_MAP
    }

    /// PRO_TG_T1_LEVEL_INT_MAP Register bits
    namespace pro_tg_t1_level_int_map_bits {
        constexpr uint32_t PRO_TG_T1_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG_T1_LEVEL_INT_MAP
    }

    /// PRO_TG_WDT_LEVEL_INT_MAP Register bits
    namespace pro_tg_wdt_level_int_map_bits {
        constexpr uint32_t PRO_TG_WDT_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG_WDT_LEVEL_INT_MAP
    }

    /// PRO_TG_LACT_LEVEL_INT_MAP Register bits
    namespace pro_tg_lact_level_int_map_bits {
        constexpr uint32_t PRO_TG_LACT_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG_LACT_LEVEL_INT_MAP
    }

    /// PRO_TG1_T0_LEVEL_INT_MAP Register bits
    namespace pro_tg1_t0_level_int_map_bits {
        constexpr uint32_t PRO_TG1_T0_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG1_T0_LEVEL_INT_MAP
    }

    /// PRO_TG1_T1_LEVEL_INT_MAP Register bits
    namespace pro_tg1_t1_level_int_map_bits {
        constexpr uint32_t PRO_TG1_T1_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG1_T1_LEVEL_INT_MAP
    }

    /// PRO_TG1_WDT_LEVEL_INT_MAP Register bits
    namespace pro_tg1_wdt_level_int_map_bits {
        constexpr uint32_t PRO_TG1_WDT_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG1_WDT_LEVEL_INT_MAP
    }

    /// PRO_TG1_LACT_LEVEL_INT_MAP Register bits
    namespace pro_tg1_lact_level_int_map_bits {
        constexpr uint32_t PRO_TG1_LACT_LEVEL_INT_MAP = (5 << 0);  ///< PRO_TG1_LACT_LEVEL_INT_MAP
    }

    /// PRO_GPIO_INTERRUPT_MAP Register bits
    namespace pro_gpio_interrupt_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< PRO_GPIO_INTERRUPT_PRO_MAP
    }

    /// PRO_GPIO_INTERRUPT_NMI_MAP Register bits
    namespace pro_gpio_interrupt_nmi_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< PRO_GPIO_INTERRUPT_PRO_NMI_MAP
    }

    /// PRO_CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace pro_cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< PRO_CPU_INTR_FROM_CPU_0_MAP
    }

    /// PRO_CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace pro_cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< PRO_CPU_INTR_FROM_CPU_1_MAP
    }

    /// PRO_CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace pro_cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< PRO_CPU_INTR_FROM_CPU_2_MAP
    }

    /// PRO_CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace pro_cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< PRO_CPU_INTR_FROM_CPU_3_MAP
    }

    /// PRO_SPI_INTR_0_MAP Register bits
    namespace pro_spi_intr_0_map_bits {
        constexpr uint32_t PRO_SPI_INTR_0_MAP = (5 << 0);  ///< PRO_SPI_INTR_0_MAP
    }

    /// PRO_SPI_INTR_1_MAP Register bits
    namespace pro_spi_intr_1_map_bits {
        constexpr uint32_t PRO_SPI_INTR_1_MAP = (5 << 0);  ///< PRO_SPI_INTR_1_MAP
    }

    /// PRO_SPI_INTR_2_MAP Register bits
    namespace pro_spi_intr_2_map_bits {
        constexpr uint32_t PRO_SPI_INTR_2_MAP = (5 << 0);  ///< PRO_SPI_INTR_2_MAP
    }

    /// PRO_SPI_INTR_3_MAP Register bits
    namespace pro_spi_intr_3_map_bits {
        constexpr uint32_t PRO_SPI_INTR_3_MAP = (5 << 0);  ///< PRO_SPI_INTR_3_MAP
    }

    /// PRO_I2S0_INT_MAP Register bits
    namespace pro_i2s0_int_map_bits {
        constexpr uint32_t PRO_I2S0_INT_MAP = (5 << 0);  ///< PRO_I2S0_INT_MAP
    }

    /// PRO_I2S1_INT_MAP Register bits
    namespace pro_i2s1_int_map_bits {
        constexpr uint32_t PRO_I2S1_INT_MAP = (5 << 0);  ///< PRO_I2S1_INT_MAP
    }

    /// PRO_UART_INTR_MAP Register bits
    namespace pro_uart_intr_map_bits {
        constexpr uint32_t PRO_UART_INTR_MAP = (5 << 0);  ///< PRO_UART_INTR_MAP
    }

    /// PRO_UART1_INTR_MAP Register bits
    namespace pro_uart1_intr_map_bits {
        constexpr uint32_t PRO_UART1_INTR_MAP = (5 << 0);  ///< PRO_UART1_INTR_MAP
    }

    /// PRO_UART2_INTR_MAP Register bits
    namespace pro_uart2_intr_map_bits {
        constexpr uint32_t PRO_UART2_INTR_MAP = (5 << 0);  ///< PRO_UART2_INTR_MAP
    }

    /// PRO_SDIO_HOST_INTERRUPT_MAP Register bits
    namespace pro_sdio_host_interrupt_map_bits {
        constexpr uint32_t PRO_SDIO_HOST_INTERRUPT_MAP = (5 << 0);  ///< PRO_SDIO_HOST_INTERRUPT_MAP
    }

    /// PRO_EMAC_INT_MAP Register bits
    namespace pro_emac_int_map_bits {
        constexpr uint32_t PRO_EMAC_INT_MAP = (5 << 0);  ///< PRO_EMAC_INT_MAP
    }

    /// PRO_PWM0_INTR_MAP Register bits
    namespace pro_pwm0_intr_map_bits {
        constexpr uint32_t PRO_PWM0_INTR_MAP = (5 << 0);  ///< PRO_PWM0_INTR_MAP
    }

    /// PRO_PWM1_INTR_MAP Register bits
    namespace pro_pwm1_intr_map_bits {
        constexpr uint32_t PRO_PWM1_INTR_MAP = (5 << 0);  ///< PRO_PWM1_INTR_MAP
    }

    /// PRO_PWM2_INTR_MAP Register bits
    namespace pro_pwm2_intr_map_bits {
        constexpr uint32_t PRO_PWM2_INTR_MAP = (5 << 0);  ///< PRO_PWM2_INTR_MAP
    }

    /// PRO_PWM3_INTR_MAP Register bits
    namespace pro_pwm3_intr_map_bits {
        constexpr uint32_t PRO_PWM3_INTR_MAP = (5 << 0);  ///< PRO_PWM3_INTR_MAP
    }

    /// PRO_LEDC_INT_MAP Register bits
    namespace pro_ledc_int_map_bits {
        constexpr uint32_t PRO_LEDC_INT_MAP = (5 << 0);  ///< PRO_LEDC_INT_MAP
    }

    /// PRO_EFUSE_INT_MAP Register bits
    namespace pro_efuse_int_map_bits {
        constexpr uint32_t PRO_EFUSE_INT_MAP = (5 << 0);  ///< PRO_EFUSE_INT_MAP
    }

    /// PRO_CAN_INT_MAP Register bits
    namespace pro_can_int_map_bits {
        constexpr uint32_t PRO_CAN_INT_MAP = (5 << 0);  ///< PRO_CAN_INT_MAP
    }

    /// PRO_RTC_CORE_INTR_MAP Register bits
    namespace pro_rtc_core_intr_map_bits {
        constexpr uint32_t PRO_RTC_CORE_INTR_MAP = (5 << 0);  ///< PRO_RTC_CORE_INTR_MAP
    }

    /// PRO_RMT_INTR_MAP Register bits
    namespace pro_rmt_intr_map_bits {
        constexpr uint32_t PRO_RMT_INTR_MAP = (5 << 0);  ///< PRO_RMT_INTR_MAP
    }

    /// PRO_PCNT_INTR_MAP Register bits
    namespace pro_pcnt_intr_map_bits {
        constexpr uint32_t PRO_PCNT_INTR_MAP = (5 << 0);  ///< PRO_PCNT_INTR_MAP
    }

    /// PRO_I2C_EXT0_INTR_MAP Register bits
    namespace pro_i2c_ext0_intr_map_bits {
        constexpr uint32_t PRO_I2C_EXT0_INTR_MAP = (5 << 0);  ///< PRO_I2C_EXT0_INTR_MAP
    }

    /// PRO_I2C_EXT1_INTR_MAP Register bits
    namespace pro_i2c_ext1_intr_map_bits {
        constexpr uint32_t PRO_I2C_EXT1_INTR_MAP = (5 << 0);  ///< PRO_I2C_EXT1_INTR_MAP
    }

    /// PRO_RSA_INTR_MAP Register bits
    namespace pro_rsa_intr_map_bits {
        constexpr uint32_t PRO_RSA_INTR_MAP = (5 << 0);  ///< PRO_RSA_INTR_MAP
    }

    /// PRO_SPI1_DMA_INT_MAP Register bits
    namespace pro_spi1_dma_int_map_bits {
        constexpr uint32_t PRO_SPI1_DMA_INT_MAP = (5 << 0);  ///< PRO_SPI1_DMA_INT_MAP
    }

    /// PRO_SPI2_DMA_INT_MAP Register bits
    namespace pro_spi2_dma_int_map_bits {
        constexpr uint32_t PRO_SPI2_DMA_INT_MAP = (5 << 0);  ///< PRO_SPI2_DMA_INT_MAP
    }

    /// PRO_SPI3_DMA_INT_MAP Register bits
    namespace pro_spi3_dma_int_map_bits {
        constexpr uint32_t PRO_SPI3_DMA_INT_MAP = (5 << 0);  ///< PRO_SPI3_DMA_INT_MAP
    }

    /// PRO_WDG_INT_MAP Register bits
    namespace pro_wdg_int_map_bits {
        constexpr uint32_t PRO_WDG_INT_MAP = (5 << 0);  ///< PRO_WDG_INT_MAP
    }

    /// PRO_TIMER_INT1_MAP Register bits
    namespace pro_timer_int1_map_bits {
        constexpr uint32_t PRO_TIMER_INT1_MAP = (5 << 0);  ///< PRO_TIMER_INT1_MAP
    }

    /// PRO_TIMER_INT2_MAP Register bits
    namespace pro_timer_int2_map_bits {
        constexpr uint32_t PRO_TIMER_INT2_MAP = (5 << 0);  ///< PRO_TIMER_INT2_MAP
    }

    /// PRO_TG_T0_EDGE_INT_MAP Register bits
    namespace pro_tg_t0_edge_int_map_bits {
        constexpr uint32_t PRO_TG_T0_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG_T0_EDGE_INT_MAP
    }

    /// PRO_TG_T1_EDGE_INT_MAP Register bits
    namespace pro_tg_t1_edge_int_map_bits {
        constexpr uint32_t PRO_TG_T1_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG_T1_EDGE_INT_MAP
    }

    /// PRO_TG_WDT_EDGE_INT_MAP Register bits
    namespace pro_tg_wdt_edge_int_map_bits {
        constexpr uint32_t PRO_TG_WDT_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG_WDT_EDGE_INT_MAP
    }

    /// PRO_TG_LACT_EDGE_INT_MAP Register bits
    namespace pro_tg_lact_edge_int_map_bits {
        constexpr uint32_t PRO_TG_LACT_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG_LACT_EDGE_INT_MAP
    }

    /// PRO_TG1_T0_EDGE_INT_MAP Register bits
    namespace pro_tg1_t0_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_T0_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG1_T0_EDGE_INT_MAP
    }

    /// PRO_TG1_T1_EDGE_INT_MAP Register bits
    namespace pro_tg1_t1_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_T1_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG1_T1_EDGE_INT_MAP
    }

    /// PRO_TG1_WDT_EDGE_INT_MAP Register bits
    namespace pro_tg1_wdt_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_WDT_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG1_WDT_EDGE_INT_MAP
    }

    /// PRO_TG1_LACT_EDGE_INT_MAP Register bits
    namespace pro_tg1_lact_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_LACT_EDGE_INT_MAP = (5 << 0);  ///< PRO_TG1_LACT_EDGE_INT_MAP
    }

    /// PRO_MMU_IA_INT_MAP Register bits
    namespace pro_mmu_ia_int_map_bits {
        constexpr uint32_t PRO_MMU_IA_INT_MAP = (5 << 0);  ///< PRO_MMU_IA_INT_MAP
    }

    /// PRO_MPU_IA_INT_MAP Register bits
    namespace pro_mpu_ia_int_map_bits {
        constexpr uint32_t PRO_MPU_IA_INT_MAP = (5 << 0);  ///< PRO_MPU_IA_INT_MAP
    }

    /// PRO_CACHE_IA_INT_MAP Register bits
    namespace pro_cache_ia_int_map_bits {
        constexpr uint32_t PRO_CACHE_IA_INT_MAP = (5 << 0);  ///< PRO_CACHE_IA_INT_MAP
    }

    /// APP_MAC_INTR_MAP Register bits
    namespace app_mac_intr_map_bits {
        constexpr uint32_t APP_MAC_INTR_MAP = (5 << 0);  ///< APP_MAC_INTR_MAP
    }

    /// APP_MAC_NMI_MAP Register bits
    namespace app_mac_nmi_map_bits {
        constexpr uint32_t APP_MAC_NMI_MAP = (5 << 0);  ///< APP_MAC_NMI_MAP
    }

    /// APP_BB_INT_MAP Register bits
    namespace app_bb_int_map_bits {
        constexpr uint32_t APP_BB_INT_MAP = (5 << 0);  ///< APP_BB_INT_MAP
    }

    /// APP_BT_MAC_INT_MAP Register bits
    namespace app_bt_mac_int_map_bits {
        constexpr uint32_t APP_BT_MAC_INT_MAP = (5 << 0);  ///< APP_BT_MAC_INT_MAP
    }

    /// APP_BT_BB_INT_MAP Register bits
    namespace app_bt_bb_int_map_bits {
        constexpr uint32_t APP_BT_BB_INT_MAP = (5 << 0);  ///< APP_BT_BB_INT_MAP
    }

    /// APP_BT_BB_NMI_MAP Register bits
    namespace app_bt_bb_nmi_map_bits {
        constexpr uint32_t APP_BT_BB_NMI_MAP = (5 << 0);  ///< APP_BT_BB_NMI_MAP
    }

    /// APP_RWBT_IRQ_MAP Register bits
    namespace app_rwbt_irq_map_bits {
        constexpr uint32_t APP_RWBT_IRQ_MAP = (5 << 0);  ///< APP_RWBT_IRQ_MAP
    }

    /// APP_RWBLE_IRQ_MAP Register bits
    namespace app_rwble_irq_map_bits {
        constexpr uint32_t APP_RWBLE_IRQ_MAP = (5 << 0);  ///< APP_RWBLE_IRQ_MAP
    }

    /// APP_RWBT_NMI_MAP Register bits
    namespace app_rwbt_nmi_map_bits {
        constexpr uint32_t APP_RWBT_NMI_MAP = (5 << 0);  ///< APP_RWBT_NMI_MAP
    }

    /// APP_RWBLE_NMI_MAP Register bits
    namespace app_rwble_nmi_map_bits {
        constexpr uint32_t APP_RWBLE_NMI_MAP = (5 << 0);  ///< APP_RWBLE_NMI_MAP
    }

    /// APP_SLC0_INTR_MAP Register bits
    namespace app_slc0_intr_map_bits {
        constexpr uint32_t APP_SLC0_INTR_MAP = (5 << 0);  ///< APP_SLC0_INTR_MAP
    }

    /// APP_SLC1_INTR_MAP Register bits
    namespace app_slc1_intr_map_bits {
        constexpr uint32_t APP_SLC1_INTR_MAP = (5 << 0);  ///< APP_SLC1_INTR_MAP
    }

    /// APP_UHCI0_INTR_MAP Register bits
    namespace app_uhci0_intr_map_bits {
        constexpr uint32_t APP_UHCI0_INTR_MAP = (5 << 0);  ///< APP_UHCI0_INTR_MAP
    }

    /// APP_UHCI1_INTR_MAP Register bits
    namespace app_uhci1_intr_map_bits {
        constexpr uint32_t APP_UHCI1_INTR_MAP = (5 << 0);  ///< APP_UHCI1_INTR_MAP
    }

    /// APP_TG_T0_LEVEL_INT_MAP Register bits
    namespace app_tg_t0_level_int_map_bits {
        constexpr uint32_t APP_TG_T0_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG_T0_LEVEL_INT_MAP
    }

    /// APP_TG_T1_LEVEL_INT_MAP Register bits
    namespace app_tg_t1_level_int_map_bits {
        constexpr uint32_t APP_TG_T1_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG_T1_LEVEL_INT_MAP
    }

    /// APP_TG_WDT_LEVEL_INT_MAP Register bits
    namespace app_tg_wdt_level_int_map_bits {
        constexpr uint32_t APP_TG_WDT_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG_WDT_LEVEL_INT_MAP
    }

    /// APP_TG_LACT_LEVEL_INT_MAP Register bits
    namespace app_tg_lact_level_int_map_bits {
        constexpr uint32_t APP_TG_LACT_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG_LACT_LEVEL_INT_MAP
    }

    /// APP_TG1_T0_LEVEL_INT_MAP Register bits
    namespace app_tg1_t0_level_int_map_bits {
        constexpr uint32_t APP_TG1_T0_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG1_T0_LEVEL_INT_MAP
    }

    /// APP_TG1_T1_LEVEL_INT_MAP Register bits
    namespace app_tg1_t1_level_int_map_bits {
        constexpr uint32_t APP_TG1_T1_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG1_T1_LEVEL_INT_MAP
    }

    /// APP_TG1_WDT_LEVEL_INT_MAP Register bits
    namespace app_tg1_wdt_level_int_map_bits {
        constexpr uint32_t APP_TG1_WDT_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG1_WDT_LEVEL_INT_MAP
    }

    /// APP_TG1_LACT_LEVEL_INT_MAP Register bits
    namespace app_tg1_lact_level_int_map_bits {
        constexpr uint32_t APP_TG1_LACT_LEVEL_INT_MAP = (5 << 0);  ///< APP_TG1_LACT_LEVEL_INT_MAP
    }

    /// APP_GPIO_INTERRUPT_MAP Register bits
    namespace app_gpio_interrupt_map_bits {
        constexpr uint32_t APP_GPIO_INTERRUPT_APP_MAP = (5 << 0);  ///< APP_GPIO_INTERRUPT_APP_MAP
    }

    /// APP_GPIO_INTERRUPT_NMI_MAP Register bits
    namespace app_gpio_interrupt_nmi_map_bits {
        constexpr uint32_t APP_GPIO_INTERRUPT_APP_NMI_MAP = (5 << 0);  ///< APP_GPIO_INTERRUPT_APP_NMI_MAP
    }

    /// APP_CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace app_cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t APP_CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< APP_CPU_INTR_FROM_CPU_0_MAP
    }

    /// APP_CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace app_cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t APP_CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< APP_CPU_INTR_FROM_CPU_1_MAP
    }

    /// APP_CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace app_cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t APP_CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< APP_CPU_INTR_FROM_CPU_2_MAP
    }

    /// APP_CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace app_cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t APP_CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< APP_CPU_INTR_FROM_CPU_3_MAP
    }

    /// APP_SPI_INTR_0_MAP Register bits
    namespace app_spi_intr_0_map_bits {
        constexpr uint32_t APP_SPI_INTR_0_MAP = (5 << 0);  ///< APP_SPI_INTR_0_MAP
    }

    /// APP_SPI_INTR_1_MAP Register bits
    namespace app_spi_intr_1_map_bits {
        constexpr uint32_t APP_SPI_INTR_1_MAP = (5 << 0);  ///< APP_SPI_INTR_1_MAP
    }

    /// APP_SPI_INTR_2_MAP Register bits
    namespace app_spi_intr_2_map_bits {
        constexpr uint32_t APP_SPI_INTR_2_MAP = (5 << 0);  ///< APP_SPI_INTR_2_MAP
    }

    /// APP_SPI_INTR_3_MAP Register bits
    namespace app_spi_intr_3_map_bits {
        constexpr uint32_t APP_SPI_INTR_3_MAP = (5 << 0);  ///< APP_SPI_INTR_3_MAP
    }

    /// APP_I2S0_INT_MAP Register bits
    namespace app_i2s0_int_map_bits {
        constexpr uint32_t APP_I2S0_INT_MAP = (5 << 0);  ///< APP_I2S0_INT_MAP
    }

    /// APP_I2S1_INT_MAP Register bits
    namespace app_i2s1_int_map_bits {
        constexpr uint32_t APP_I2S1_INT_MAP = (5 << 0);  ///< APP_I2S1_INT_MAP
    }

    /// APP_UART_INTR_MAP Register bits
    namespace app_uart_intr_map_bits {
        constexpr uint32_t APP_UART_INTR_MAP = (5 << 0);  ///< APP_UART_INTR_MAP
    }

    /// APP_UART1_INTR_MAP Register bits
    namespace app_uart1_intr_map_bits {
        constexpr uint32_t APP_UART1_INTR_MAP = (5 << 0);  ///< APP_UART1_INTR_MAP
    }

    /// APP_UART2_INTR_MAP Register bits
    namespace app_uart2_intr_map_bits {
        constexpr uint32_t APP_UART2_INTR_MAP = (5 << 0);  ///< APP_UART2_INTR_MAP
    }

    /// APP_SDIO_HOST_INTERRUPT_MAP Register bits
    namespace app_sdio_host_interrupt_map_bits {
        constexpr uint32_t APP_SDIO_HOST_INTERRUPT_MAP = (5 << 0);  ///< APP_SDIO_HOST_INTERRUPT_MAP
    }

    /// APP_EMAC_INT_MAP Register bits
    namespace app_emac_int_map_bits {
        constexpr uint32_t APP_EMAC_INT_MAP = (5 << 0);  ///< APP_EMAC_INT_MAP
    }

    /// APP_PWM0_INTR_MAP Register bits
    namespace app_pwm0_intr_map_bits {
        constexpr uint32_t APP_PWM0_INTR_MAP = (5 << 0);  ///< APP_PWM0_INTR_MAP
    }

    /// APP_PWM1_INTR_MAP Register bits
    namespace app_pwm1_intr_map_bits {
        constexpr uint32_t APP_PWM1_INTR_MAP = (5 << 0);  ///< APP_PWM1_INTR_MAP
    }

    /// APP_PWM2_INTR_MAP Register bits
    namespace app_pwm2_intr_map_bits {
        constexpr uint32_t APP_PWM2_INTR_MAP = (5 << 0);  ///< APP_PWM2_INTR_MAP
    }

    /// APP_PWM3_INTR_MAP Register bits
    namespace app_pwm3_intr_map_bits {
        constexpr uint32_t APP_PWM3_INTR_MAP = (5 << 0);  ///< APP_PWM3_INTR_MAP
    }

    /// APP_LEDC_INT_MAP Register bits
    namespace app_ledc_int_map_bits {
        constexpr uint32_t APP_LEDC_INT_MAP = (5 << 0);  ///< APP_LEDC_INT_MAP
    }

    /// APP_EFUSE_INT_MAP Register bits
    namespace app_efuse_int_map_bits {
        constexpr uint32_t APP_EFUSE_INT_MAP = (5 << 0);  ///< APP_EFUSE_INT_MAP
    }

    /// APP_CAN_INT_MAP Register bits
    namespace app_can_int_map_bits {
        constexpr uint32_t APP_CAN_INT_MAP = (5 << 0);  ///< APP_CAN_INT_MAP
    }

    /// APP_RTC_CORE_INTR_MAP Register bits
    namespace app_rtc_core_intr_map_bits {
        constexpr uint32_t APP_RTC_CORE_INTR_MAP = (5 << 0);  ///< APP_RTC_CORE_INTR_MAP
    }

    /// APP_RMT_INTR_MAP Register bits
    namespace app_rmt_intr_map_bits {
        constexpr uint32_t APP_RMT_INTR_MAP = (5 << 0);  ///< APP_RMT_INTR_MAP
    }

    /// APP_PCNT_INTR_MAP Register bits
    namespace app_pcnt_intr_map_bits {
        constexpr uint32_t APP_PCNT_INTR_MAP = (5 << 0);  ///< APP_PCNT_INTR_MAP
    }

    /// APP_I2C_EXT0_INTR_MAP Register bits
    namespace app_i2c_ext0_intr_map_bits {
        constexpr uint32_t APP_I2C_EXT0_INTR_MAP = (5 << 0);  ///< APP_I2C_EXT0_INTR_MAP
    }

    /// APP_I2C_EXT1_INTR_MAP Register bits
    namespace app_i2c_ext1_intr_map_bits {
        constexpr uint32_t APP_I2C_EXT1_INTR_MAP = (5 << 0);  ///< APP_I2C_EXT1_INTR_MAP
    }

    /// APP_RSA_INTR_MAP Register bits
    namespace app_rsa_intr_map_bits {
        constexpr uint32_t APP_RSA_INTR_MAP = (5 << 0);  ///< APP_RSA_INTR_MAP
    }

    /// APP_SPI1_DMA_INT_MAP Register bits
    namespace app_spi1_dma_int_map_bits {
        constexpr uint32_t APP_SPI1_DMA_INT_MAP = (5 << 0);  ///< APP_SPI1_DMA_INT_MAP
    }

    /// APP_SPI2_DMA_INT_MAP Register bits
    namespace app_spi2_dma_int_map_bits {
        constexpr uint32_t APP_SPI2_DMA_INT_MAP = (5 << 0);  ///< APP_SPI2_DMA_INT_MAP
    }

    /// APP_SPI3_DMA_INT_MAP Register bits
    namespace app_spi3_dma_int_map_bits {
        constexpr uint32_t APP_SPI3_DMA_INT_MAP = (5 << 0);  ///< APP_SPI3_DMA_INT_MAP
    }

    /// APP_WDG_INT_MAP Register bits
    namespace app_wdg_int_map_bits {
        constexpr uint32_t APP_WDG_INT_MAP = (5 << 0);  ///< APP_WDG_INT_MAP
    }

    /// APP_TIMER_INT1_MAP Register bits
    namespace app_timer_int1_map_bits {
        constexpr uint32_t APP_TIMER_INT1_MAP = (5 << 0);  ///< APP_TIMER_INT1_MAP
    }

    /// APP_TIMER_INT2_MAP Register bits
    namespace app_timer_int2_map_bits {
        constexpr uint32_t APP_TIMER_INT2_MAP = (5 << 0);  ///< APP_TIMER_INT2_MAP
    }

    /// APP_TG_T0_EDGE_INT_MAP Register bits
    namespace app_tg_t0_edge_int_map_bits {
        constexpr uint32_t APP_TG_T0_EDGE_INT_MAP = (5 << 0);  ///< APP_TG_T0_EDGE_INT_MAP
    }

    /// APP_TG_T1_EDGE_INT_MAP Register bits
    namespace app_tg_t1_edge_int_map_bits {
        constexpr uint32_t APP_TG_T1_EDGE_INT_MAP = (5 << 0);  ///< APP_TG_T1_EDGE_INT_MAP
    }

    /// APP_TG_WDT_EDGE_INT_MAP Register bits
    namespace app_tg_wdt_edge_int_map_bits {
        constexpr uint32_t APP_TG_WDT_EDGE_INT_MAP = (5 << 0);  ///< APP_TG_WDT_EDGE_INT_MAP
    }

    /// APP_TG_LACT_EDGE_INT_MAP Register bits
    namespace app_tg_lact_edge_int_map_bits {
        constexpr uint32_t APP_TG_LACT_EDGE_INT_MAP = (5 << 0);  ///< APP_TG_LACT_EDGE_INT_MAP
    }

    /// APP_TG1_T0_EDGE_INT_MAP Register bits
    namespace app_tg1_t0_edge_int_map_bits {
        constexpr uint32_t APP_TG1_T0_EDGE_INT_MAP = (5 << 0);  ///< APP_TG1_T0_EDGE_INT_MAP
    }

    /// APP_TG1_T1_EDGE_INT_MAP Register bits
    namespace app_tg1_t1_edge_int_map_bits {
        constexpr uint32_t APP_TG1_T1_EDGE_INT_MAP = (5 << 0);  ///< APP_TG1_T1_EDGE_INT_MAP
    }

    /// APP_TG1_WDT_EDGE_INT_MAP Register bits
    namespace app_tg1_wdt_edge_int_map_bits {
        constexpr uint32_t APP_TG1_WDT_EDGE_INT_MAP = (5 << 0);  ///< APP_TG1_WDT_EDGE_INT_MAP
    }

    /// APP_TG1_LACT_EDGE_INT_MAP Register bits
    namespace app_tg1_lact_edge_int_map_bits {
        constexpr uint32_t APP_TG1_LACT_EDGE_INT_MAP = (5 << 0);  ///< APP_TG1_LACT_EDGE_INT_MAP
    }

    /// APP_MMU_IA_INT_MAP Register bits
    namespace app_mmu_ia_int_map_bits {
        constexpr uint32_t APP_MMU_IA_INT_MAP = (5 << 0);  ///< APP_MMU_IA_INT_MAP
    }

    /// APP_MPU_IA_INT_MAP Register bits
    namespace app_mpu_ia_int_map_bits {
        constexpr uint32_t APP_MPU_IA_INT_MAP = (5 << 0);  ///< APP_MPU_IA_INT_MAP
    }

    /// APP_CACHE_IA_INT_MAP Register bits
    namespace app_cache_ia_int_map_bits {
        constexpr uint32_t APP_CACHE_IA_INT_MAP = (5 << 0);  ///< APP_CACHE_IA_INT_MAP
    }

    /// AHBLITE_MPU_TABLE_UART Register bits
    namespace ahblite_mpu_table_uart_bits {
        constexpr uint32_t UART_ACCESS_GRANT_CONFIG = (6 << 0);  ///< UART_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SPI1 Register bits
    namespace ahblite_mpu_table_spi1_bits {
        constexpr uint32_t SPI1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SPI1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SPI0 Register bits
    namespace ahblite_mpu_table_spi0_bits {
        constexpr uint32_t SPI0_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SPI0_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_GPIO Register bits
    namespace ahblite_mpu_table_gpio_bits {
        constexpr uint32_t GPIO_ACCESS_GRANT_CONFIG = (6 << 0);  ///< GPIO_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_FE2 Register bits
    namespace ahblite_mpu_table_fe2_bits {
        constexpr uint32_t FE2_ACCESS_GRANT_CONFIG = (6 << 0);  ///< FE2_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_FE Register bits
    namespace ahblite_mpu_table_fe_bits {
        constexpr uint32_t FE_ACCESS_GRANT_CONFIG = (6 << 0);  ///< FE_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_TIMER Register bits
    namespace ahblite_mpu_table_timer_bits {
        constexpr uint32_t TIMER_ACCESS_GRANT_CONFIG = (6 << 0);  ///< TIMER_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_RTC Register bits
    namespace ahblite_mpu_table_rtc_bits {
        constexpr uint32_t RTC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< RTC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_IO_MUX Register bits
    namespace ahblite_mpu_table_io_mux_bits {
        constexpr uint32_t IOMUX_ACCESS_GRANT_CONFIG = (6 << 0);  ///< IOMUX_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_WDG Register bits
    namespace ahblite_mpu_table_wdg_bits {
        constexpr uint32_t WDG_ACCESS_GRANT_CONFIG = (6 << 0);  ///< WDG_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_HINF Register bits
    namespace ahblite_mpu_table_hinf_bits {
        constexpr uint32_t HINF_ACCESS_GRANT_CONFIG = (6 << 0);  ///< HINF_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_UHCI1 Register bits
    namespace ahblite_mpu_table_uhci1_bits {
        constexpr uint32_t UHCI1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< UHCI1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_MISC Register bits
    namespace ahblite_mpu_table_misc_bits {
        constexpr uint32_t MISC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< MISC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_I2C Register bits
    namespace ahblite_mpu_table_i2c_bits {
        constexpr uint32_t I2C_ACCESS_GRANT_CONFIG = (6 << 0);  ///< I2C_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_I2S0 Register bits
    namespace ahblite_mpu_table_i2s0_bits {
        constexpr uint32_t I2S0_ACCESS_GRANT_CONFIG = (6 << 0);  ///< I2S0_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_UART1 Register bits
    namespace ahblite_mpu_table_uart1_bits {
        constexpr uint32_t UART1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< UART1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_BT Register bits
    namespace ahblite_mpu_table_bt_bits {
        constexpr uint32_t BT_ACCESS_GRANT_CONFIG = (6 << 0);  ///< BT_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_BT_BUFFER Register bits
    namespace ahblite_mpu_table_bt_buffer_bits {
        constexpr uint32_t BTBUFFER_ACCESS_GRANT_CONFIG = (6 << 0);  ///< BTBUFFER_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_I2C_EXT0 Register bits
    namespace ahblite_mpu_table_i2c_ext0_bits {
        constexpr uint32_t I2CEXT0_ACCESS_GRANT_CONFIG = (6 << 0);  ///< I2CEXT0_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_UHCI0 Register bits
    namespace ahblite_mpu_table_uhci0_bits {
        constexpr uint32_t UHCI0_ACCESS_GRANT_CONFIG = (6 << 0);  ///< UHCI0_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SLCHOST Register bits
    namespace ahblite_mpu_table_slchost_bits {
        constexpr uint32_t SLCHOST_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SLCHOST_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_RMT Register bits
    namespace ahblite_mpu_table_rmt_bits {
        constexpr uint32_t RMT_ACCESS_GRANT_CONFIG = (6 << 0);  ///< RMT_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PCNT Register bits
    namespace ahblite_mpu_table_pcnt_bits {
        constexpr uint32_t PCNT_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PCNT_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SLC Register bits
    namespace ahblite_mpu_table_slc_bits {
        constexpr uint32_t SLC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SLC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_LEDC Register bits
    namespace ahblite_mpu_table_ledc_bits {
        constexpr uint32_t LEDC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< LEDC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_EFUSE Register bits
    namespace ahblite_mpu_table_efuse_bits {
        constexpr uint32_t EFUSE_ACCESS_GRANT_CONFIG = (6 << 0);  ///< EFUSE_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SPI_ENCRYPT Register bits
    namespace ahblite_mpu_table_spi_encrypt_bits {
        constexpr uint32_t SPI_ENCRYPY_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SPI_ENCRYPY_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_BB Register bits
    namespace ahblite_mpu_table_bb_bits {
        constexpr uint32_t BB_ACCESS_GRANT_CONFIG = (6 << 0);  ///< BB_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PWM0 Register bits
    namespace ahblite_mpu_table_pwm0_bits {
        constexpr uint32_t PWM0_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PWM0_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_TIMERGROUP Register bits
    namespace ahblite_mpu_table_timergroup_bits {
        constexpr uint32_t TIMERGROUP_ACCESS_GRANT_CONFIG = (6 << 0);  ///< TIMERGROUP_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_TIMERGROUP1 Register bits
    namespace ahblite_mpu_table_timergroup1_bits {
        constexpr uint32_t TIMERGROUP1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< TIMERGROUP1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SPI2 Register bits
    namespace ahblite_mpu_table_spi2_bits {
        constexpr uint32_t SPI2_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SPI2_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SPI3 Register bits
    namespace ahblite_mpu_table_spi3_bits {
        constexpr uint32_t SPI3_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SPI3_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_APB_CTRL Register bits
    namespace ahblite_mpu_table_apb_ctrl_bits {
        constexpr uint32_t APBCTRL_ACCESS_GRANT_CONFIG = (6 << 0);  ///< APBCTRL_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_I2C_EXT1 Register bits
    namespace ahblite_mpu_table_i2c_ext1_bits {
        constexpr uint32_t I2CEXT1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< I2CEXT1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_SDIO_HOST Register bits
    namespace ahblite_mpu_table_sdio_host_bits {
        constexpr uint32_t SDIOHOST_ACCESS_GRANT_CONFIG = (6 << 0);  ///< SDIOHOST_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_EMAC Register bits
    namespace ahblite_mpu_table_emac_bits {
        constexpr uint32_t EMAC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< EMAC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_CAN Register bits
    namespace ahblite_mpu_table_can_bits {
        constexpr uint32_t CAN_ACCESS_GRANT_CONFIG = (6 << 0);  ///< CAN_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PWM1 Register bits
    namespace ahblite_mpu_table_pwm1_bits {
        constexpr uint32_t PWM1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PWM1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_I2S1 Register bits
    namespace ahblite_mpu_table_i2s1_bits {
        constexpr uint32_t I2S1_ACCESS_GRANT_CONFIG = (6 << 0);  ///< I2S1_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_UART2 Register bits
    namespace ahblite_mpu_table_uart2_bits {
        constexpr uint32_t UART2_ACCESS_GRANT_CONFIG = (6 << 0);  ///< UART2_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PWM2 Register bits
    namespace ahblite_mpu_table_pwm2_bits {
        constexpr uint32_t PWM2_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PWM2_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PWM3 Register bits
    namespace ahblite_mpu_table_pwm3_bits {
        constexpr uint32_t PWM3_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PWM3_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_RWBT Register bits
    namespace ahblite_mpu_table_rwbt_bits {
        constexpr uint32_t RWBT_ACCESS_GRANT_CONFIG = (6 << 0);  ///< RWBT_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_BTMAC Register bits
    namespace ahblite_mpu_table_btmac_bits {
        constexpr uint32_t BTMAC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< BTMAC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_WIFIMAC Register bits
    namespace ahblite_mpu_table_wifimac_bits {
        constexpr uint32_t WIFIMAC_ACCESS_GRANT_CONFIG = (6 << 0);  ///< WIFIMAC_ACCESS_GRANT_CONFIG
    }

    /// AHBLITE_MPU_TABLE_PWR Register bits
    namespace ahblite_mpu_table_pwr_bits {
        constexpr uint32_t PWR_ACCESS_GRANT_CONFIG = (6 << 0);  ///< PWR_ACCESS_GRANT_CONFIG
    }

    /// MEM_ACCESS_DBUG0 Register bits
    namespace mem_access_dbug0_bits {
        constexpr uint32_t PRO_ROM_MPU_AD = (1U << 0);  ///< PRO_ROM_MPU_AD
        constexpr uint32_t PRO_ROM_IA = (1U << 1);  ///< PRO_ROM_IA
        constexpr uint32_t APP_ROM_MPU_AD = (1U << 2);  ///< APP_ROM_MPU_AD
        constexpr uint32_t APP_ROM_IA = (1U << 3);  ///< APP_ROM_IA
        constexpr uint32_t SHARE_ROM_MPU_AD = (2 << 4);  ///< SHARE_ROM_MPU_AD
        constexpr uint32_t SHARE_ROM_IA = (4 << 6);  ///< SHARE_ROM_IA
        constexpr uint32_t INTERNAL_SRAM_MMU_AD = (4 << 10);  ///< INTERNAL_SRAM_MMU_AD
        constexpr uint32_t INTERNAL_SRAM_IA = (12 << 14);  ///< INTERNAL_SRAM_IA
        constexpr uint32_t INTERNAL_SRAM_MMU_MULTI_HIT = (4 << 26);  ///< INTERNAL_SRAM_MMU_MULTI_HIT
    }

    /// MEM_ACCESS_DBUG1 Register bits
    namespace mem_access_dbug1_bits {
        constexpr uint32_t INTERNAL_SRAM_MMU_MISS = (4 << 0);  ///< INTERNAL_SRAM_MMU_MISS
        constexpr uint32_t ARB_IA = (2 << 4);  ///< ARB_IA
        constexpr uint32_t PIDGEN_IA = (2 << 6);  ///< PIDGEN_IA
        constexpr uint32_t AHB_ACCESS_DENY = (1U << 8);  ///< AHB_ACCESS_DENY
        constexpr uint32_t AHBLITE_ACCESS_DENY = (1U << 9);  ///< AHBLITE_ACCESS_DENY
        constexpr uint32_t AHBLITE_IA = (1U << 10);  ///< AHBLITE_IA
    }

    /// PRO_DCACHE_DBUG0 Register bits
    namespace pro_dcache_dbug0_bits {
        constexpr uint32_t PRO_SLAVE_WDATA = (1U << 0);  ///< PRO_SLAVE_WDATA
        constexpr uint32_t PRO_CACHE_MMU_IA = (1U << 0);  ///< PRO_CACHE_MMU_IA
        constexpr uint32_t PRO_CACHE_IA = (6 << 1);  ///< PRO_CACHE_IA
        constexpr uint32_t PRO_CACHE_STATE = (12 << 7);  ///< PRO_CACHE_STATE
        constexpr uint32_t PRO_WR_BAK_TO_READ = (1U << 19);  ///< PRO_WR_BAK_TO_READ
        constexpr uint32_t PRO_TX_END = (1U << 20);  ///< PRO_TX_END
        constexpr uint32_t PRO_SLAVE_WR = (1U << 21);  ///< PRO_SLAVE_WR
        constexpr uint32_t PRO_SLAVE_WDATA_V = (1U << 22);  ///< PRO_SLAVE_WDATA_V
        constexpr uint32_t PRO_RX_END = (1U << 23);  ///< PRO_RX_END
    }

    /// PRO_DCACHE_DBUG1 Register bits
    namespace pro_dcache_dbug1_bits {
        constexpr uint32_t PRO_CTAG_RAM_RDATA = (32 << 0);  ///< PRO_CTAG_RAM_RDATA
    }

    /// PRO_DCACHE_DBUG2 Register bits
    namespace pro_dcache_dbug2_bits {
        constexpr uint32_t PRO_CACHE_VADDR = (27 << 0);  ///< PRO_CACHE_VADDR
    }

    /// PRO_DCACHE_DBUG3 Register bits
    namespace pro_dcache_dbug3_bits {
        constexpr uint32_t PRO_MMU_RDATA = (9 << 0);  ///< PRO_MMU_RDATA
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA = (6 << 9);  ///< PRO_CPU_DISABLED_CACHE_IA
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_OPPOSITE = (1U << 9);  ///< PRO_CPU_DISABLED_CACHE_IA_OPPOSITE
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_DRAM1 = (1U << 10);  ///< PRO_CPU_DISABLED_CACHE_IA_DRAM1
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_IROM0 = (1U << 11);  ///< PRO_CPU_DISABLED_CACHE_IA_IROM0
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_IRAM1 = (1U << 12);  ///< PRO_CPU_DISABLED_CACHE_IA_IRAM1
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_IRAM0 = (1U << 13);  ///< PRO_CPU_DISABLED_CACHE_IA_IRAM0
        constexpr uint32_t PRO_CPU_DISABLED_CACHE_IA_DROM0 = (1U << 14);  ///< PRO_CPU_DISABLED_CACHE_IA_DROM0
        constexpr uint32_t PRO_CACHE_IRAM0_PID_ERROR = (1U << 15);  ///< PRO_CACHE_IRAM0_PID_ERROR
    }

    /// PRO_DCACHE_DBUG4 Register bits
    namespace pro_dcache_dbug4_bits {
        constexpr uint32_t PRO_DRAM1ADDR0_IA = (20 << 0);  ///< PRO_DRAM1ADDR0_IA
    }

    /// PRO_DCACHE_DBUG5 Register bits
    namespace pro_dcache_dbug5_bits {
        constexpr uint32_t PRO_DROM0ADDR0_IA = (20 << 0);  ///< PRO_DROM0ADDR0_IA
    }

    /// PRO_DCACHE_DBUG6 Register bits
    namespace pro_dcache_dbug6_bits {
        constexpr uint32_t PRO_IRAM0ADDR_IA = (20 << 0);  ///< PRO_IRAM0ADDR_IA
    }

    /// PRO_DCACHE_DBUG7 Register bits
    namespace pro_dcache_dbug7_bits {
        constexpr uint32_t PRO_IRAM1ADDR_IA = (20 << 0);  ///< PRO_IRAM1ADDR_IA
    }

    /// PRO_DCACHE_DBUG8 Register bits
    namespace pro_dcache_dbug8_bits {
        constexpr uint32_t PRO_IROM0ADDR_IA = (20 << 0);  ///< PRO_IROM0ADDR_IA
    }

    /// PRO_DCACHE_DBUG9 Register bits
    namespace pro_dcache_dbug9_bits {
        constexpr uint32_t PRO_OPSDRAMADDR_IA = (20 << 0);  ///< PRO_OPSDRAMADDR_IA
    }

    /// APP_DCACHE_DBUG0 Register bits
    namespace app_dcache_dbug0_bits {
        constexpr uint32_t APP_SLAVE_WDATA = (1U << 0);  ///< APP_SLAVE_WDATA
        constexpr uint32_t APP_CACHE_MMU_IA = (1U << 0);  ///< APP_CACHE_MMU_IA
        constexpr uint32_t APP_CACHE_IA = (6 << 1);  ///< APP_CACHE_IA
        constexpr uint32_t APP_CACHE_STATE = (12 << 7);  ///< APP_CACHE_STATE
        constexpr uint32_t APP_WR_BAK_TO_READ = (1U << 19);  ///< APP_WR_BAK_TO_READ
        constexpr uint32_t APP_TX_END = (1U << 20);  ///< APP_TX_END
        constexpr uint32_t APP_SLAVE_WR = (1U << 21);  ///< APP_SLAVE_WR
        constexpr uint32_t APP_SLAVE_WDATA_V = (1U << 22);  ///< APP_SLAVE_WDATA_V
        constexpr uint32_t APP_RX_END = (1U << 23);  ///< APP_RX_END
    }

    /// APP_DCACHE_DBUG1 Register bits
    namespace app_dcache_dbug1_bits {
        constexpr uint32_t APP_CTAG_RAM_RDATA = (32 << 0);  ///< APP_CTAG_RAM_RDATA
    }

    /// APP_DCACHE_DBUG2 Register bits
    namespace app_dcache_dbug2_bits {
        constexpr uint32_t APP_CACHE_VADDR = (27 << 0);  ///< APP_CACHE_VADDR
    }

    /// APP_DCACHE_DBUG3 Register bits
    namespace app_dcache_dbug3_bits {
        constexpr uint32_t APP_MMU_RDATA = (9 << 0);  ///< APP_MMU_RDATA
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA = (6 << 9);  ///< APP_CPU_DISABLED_CACHE_IA
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_OPPOSITE = (1U << 9);  ///< APP_CPU_DISABLED_CACHE_IA_OPPOSITE
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_DRAM1 = (1U << 10);  ///< APP_CPU_DISABLED_CACHE_IA_DRAM1
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_IROM0 = (1U << 11);  ///< APP_CPU_DISABLED_CACHE_IA_IROM0
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_IRAM1 = (1U << 12);  ///< APP_CPU_DISABLED_CACHE_IA_IRAM1
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_IRAM0 = (1U << 13);  ///< APP_CPU_DISABLED_CACHE_IA_IRAM0
        constexpr uint32_t APP_CPU_DISABLED_CACHE_IA_DROM0 = (1U << 14);  ///< APP_CPU_DISABLED_CACHE_IA_DROM0
        constexpr uint32_t APP_CACHE_IRAM0_PID_ERROR = (1U << 15);  ///< APP_CACHE_IRAM0_PID_ERROR
    }

    /// APP_DCACHE_DBUG4 Register bits
    namespace app_dcache_dbug4_bits {
        constexpr uint32_t APP_DRAM1ADDR0_IA = (20 << 0);  ///< APP_DRAM1ADDR0_IA
    }

    /// APP_DCACHE_DBUG5 Register bits
    namespace app_dcache_dbug5_bits {
        constexpr uint32_t APP_DROM0ADDR0_IA = (20 << 0);  ///< APP_DROM0ADDR0_IA
    }

    /// APP_DCACHE_DBUG6 Register bits
    namespace app_dcache_dbug6_bits {
        constexpr uint32_t APP_IRAM0ADDR_IA = (20 << 0);  ///< APP_IRAM0ADDR_IA
    }

    /// APP_DCACHE_DBUG7 Register bits
    namespace app_dcache_dbug7_bits {
        constexpr uint32_t APP_IRAM1ADDR_IA = (20 << 0);  ///< APP_IRAM1ADDR_IA
    }

    /// APP_DCACHE_DBUG8 Register bits
    namespace app_dcache_dbug8_bits {
        constexpr uint32_t APP_IROM0ADDR_IA = (20 << 0);  ///< APP_IROM0ADDR_IA
    }

    /// APP_DCACHE_DBUG9 Register bits
    namespace app_dcache_dbug9_bits {
        constexpr uint32_t APP_OPSDRAMADDR_IA = (20 << 0);  ///< APP_OPSDRAMADDR_IA
    }

    /// PRO_CPU_RECORD_CTRL Register bits
    namespace pro_cpu_record_ctrl_bits {
        constexpr uint32_t PRO_CPU_RECORD_ENABLE = (1U << 0);  ///< PRO_CPU_RECORD_ENABLE
        constexpr uint32_t PRO_CPU_RECORD_DISABLE = (1U << 4);  ///< PRO_CPU_RECORD_DISABLE
        constexpr uint32_t PRO_CPU_PDEBUG_ENABLE = (1U << 8);  ///< PRO_CPU_PDEBUG_ENABLE
    }

    /// PRO_CPU_RECORD_STATUS Register bits
    namespace pro_cpu_record_status_bits {
        constexpr uint32_t PRO_CPU_RECORDING = (1U << 0);  ///< PRO_CPU_RECORDING
    }

    /// PRO_CPU_RECORD_PID Register bits
    namespace pro_cpu_record_pid_bits {
        constexpr uint32_t RECORD_PRO_PID = (3 << 0);  ///< RECORD_PRO_PID
    }

    /// PRO_CPU_RECORD_PDEBUGINST Register bits
    namespace pro_cpu_record_pdebuginst_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGINST = (32 << 0);  ///< RECORD_PRO_PDEBUGINST
        constexpr uint32_t RECORD_PDEBUGINST_SZ = (8 << 0);  ///< RECORD_PDEBUGINST_SZ
        constexpr uint32_t RECORD_PDEBUGINST_ISRC = (3 << 12);  ///< RECORD_PDEBUGINST_ISRC
        constexpr uint32_t RECORD_PDEBUGINST_LOOP_REP = (1U << 20);  ///< RECORD_PDEBUGINST_LOOP_REP
        constexpr uint32_t RECORD_PDEBUGINST_LOOP = (1U << 21);  ///< RECORD_PDEBUGINST_LOOP
        constexpr uint32_t RECORD_PDEBUGINST_CINTL = (4 << 24);  ///< RECORD_PDEBUGINST_CINTL
    }

    /// PRO_CPU_RECORD_PDEBUGSTATUS Register bits
    namespace pro_cpu_record_pdebugstatus_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGSTATUS = (8 << 0);  ///< RECORD_PRO_PDEBUGSTATUS
        constexpr uint32_t RECORD_PDEBUGSTATUS_BBCAUSE = (6 << 0);  ///< RECORD_PDEBUGSTATUS_BBCAUSE
        constexpr uint32_t RECORD_PDEBUGSTATUS_INSNTYPE = (6 << 0);  ///< RECORD_PDEBUGSTATUS_INSNTYPE
    }

    /// PRO_CPU_RECORD_PDEBUGDATA Register bits
    namespace pro_cpu_record_pdebugdata_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGDATA = (32 << 0);  ///< RECORD_PRO_PDEBUGDATA
        constexpr uint32_t RECORD_PDEBUGDATA_DEP_OTHER = (1U << 0);  ///< RECORD_PDEBUGDATA_DEP_OTHER
        constexpr uint32_t RECORD_PDEBUGDATA_EXCVEC = (5 << 0);  ///< RECORD_PDEBUGDATA_EXCVEC
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_SR = (8 << 0);  ///< RECORD_PDEBUGDATA_INSNTYPE_SR
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_RER = (1U << 0);  ///< RECORD_PDEBUGDATA_INSNTYPE_RER
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_BUFF = (1U << 1);  ///< RECORD_PDEBUGDATA_STALL_BUFF
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_WER = (1U << 1);  ///< RECORD_PDEBUGDATA_INSNTYPE_WER
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_BUFFCONFL = (1U << 2);  ///< RECORD_PDEBUGDATA_STALL_BUFFCONFL
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_ER = (12 << 2);  ///< RECORD_PDEBUGDATA_INSNTYPE_ER
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_DCM = (1U << 3);  ///< RECORD_PDEBUGDATA_STALL_DCM
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_LSU = (1U << 4);  ///< RECORD_PDEBUGDATA_STALL_LSU
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_ICM = (1U << 6);  ///< RECORD_PDEBUGDATA_STALL_ICM
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_IRAMBUSY = (1U << 7);  ///< RECORD_PDEBUGDATA_STALL_IRAMBUSY
        constexpr uint32_t RECORD_PDEBUGDATA_DEP_LSU = (1U << 8);  ///< RECORD_PDEBUGDATA_DEP_LSU
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_IPIF = (1U << 8);  ///< RECORD_PDEBUGDATA_STALL_IPIF
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_RSR = (1U << 8);  ///< RECORD_PDEBUGDATA_INSNTYPE_RSR
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_TIE = (1U << 9);  ///< RECORD_PDEBUGDATA_STALL_TIE
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_WSR = (1U << 9);  ///< RECORD_PDEBUGDATA_INSNTYPE_WSR
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_RUN = (1U << 10);  ///< RECORD_PDEBUGDATA_STALL_RUN
        constexpr uint32_t RECORD_PDEBUGDATA_INSNTYPE_XSR = (1U << 10);  ///< RECORD_PDEBUGDATA_INSNTYPE_XSR
        constexpr uint32_t RECORD_PDEBUGDATA_DEP_STR = (1U << 11);  ///< RECORD_PDEBUGDATA_DEP_STR
        constexpr uint32_t RECORD_PDEBUGDATA_DEP = (1U << 12);  ///< RECORD_PDEBUGDATA_DEP
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_BPIFETCH = (1U << 12);  ///< RECORD_PDEBUGDATA_STALL_BPIFETCH
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_L32R = (1U << 13);  ///< RECORD_PDEBUGDATA_STALL_L32R
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_LSPROC = (1U << 14);  ///< RECORD_PDEBUGDATA_STALL_LSPROC
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_BPLOAD = (1U << 15);  ///< RECORD_PDEBUGDATA_STALL_BPLOAD
        constexpr uint32_t RECORD_PDEBUGDATA_DEP_MEMW = (1U << 16);  ///< RECORD_PDEBUGDATA_DEP_MEMW
        constexpr uint32_t RECORD_PDEBUGDATA_EXCCAUSE = (6 << 16);  ///< RECORD_PDEBUGDATA_EXCCAUSE
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_BANKCONFL = (1U << 16);  ///< RECORD_PDEBUGDATA_STALL_BANKCONFL
        constexpr uint32_t RECORD_PDEBUGDATA_DEP_HALT = (1U << 17);  ///< RECORD_PDEBUGDATA_DEP_HALT
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_ITERMUL = (1U << 18);  ///< RECORD_PDEBUGDATA_STALL_ITERMUL
        constexpr uint32_t RECORD_PDEBUGDATA_STALL_ITERDIV = (1U << 19);  ///< RECORD_PDEBUGDATA_STALL_ITERDIV
    }

    /// PRO_CPU_RECORD_PDEBUGPC Register bits
    namespace pro_cpu_record_pdebugpc_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGPC = (32 << 0);  ///< RECORD_PRO_PDEBUGPC
    }

    /// PRO_CPU_RECORD_PDEBUGLS0STAT Register bits
    namespace pro_cpu_record_pdebugls0stat_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGLS0STAT = (32 << 0);  ///< RECORD_PRO_PDEBUGLS0STAT
        constexpr uint32_t RECORD_PDEBUGLS0STAT_TYPE = (4 << 0);  ///< RECORD_PDEBUGLS0STAT_TYPE
        constexpr uint32_t RECORD_PDEBUGLS0STAT_SZ = (4 << 4);  ///< RECORD_PDEBUGLS0STAT_SZ
        constexpr uint32_t RECORD_PDEBUGLS0STAT_DTLBM = (1U << 8);  ///< RECORD_PDEBUGLS0STAT_DTLBM
        constexpr uint32_t RECORD_PDEBUGLS0STAT_DCM = (1U << 9);  ///< RECORD_PDEBUGLS0STAT_DCM
        constexpr uint32_t RECORD_PDEBUGLS0STAT_DCH = (1U << 10);  ///< RECORD_PDEBUGLS0STAT_DCH
        constexpr uint32_t RECORD_PDEBUGLS0STAT_UC = (1U << 12);  ///< RECORD_PDEBUGLS0STAT_UC
        constexpr uint32_t RECORD_PDEBUGLS0STAT_WB = (1U << 13);  ///< RECORD_PDEBUGLS0STAT_WB
        constexpr uint32_t RECORD_PDEBUGLS0STAT_COH = (1U << 16);  ///< RECORD_PDEBUGLS0STAT_COH
        constexpr uint32_t RECORD_PDEBUGLS0STAT_STCOH = (2 << 17);  ///< RECORD_PDEBUGLS0STAT_STCOH
        constexpr uint32_t RECORD_PDEBUGLS0STAT_TGT = (4 << 20);  ///< RECORD_PDEBUGLS0STAT_TGT
    }

    /// PRO_CPU_RECORD_PDEBUGLS0ADDR Register bits
    namespace pro_cpu_record_pdebugls0addr_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGLS0ADDR = (32 << 0);  ///< RECORD_PRO_PDEBUGLS0ADDR
    }

    /// PRO_CPU_RECORD_PDEBUGLS0DATA Register bits
    namespace pro_cpu_record_pdebugls0data_bits {
        constexpr uint32_t RECORD_PRO_PDEBUGLS0DATA = (32 << 0);  ///< RECORD_PRO_PDEBUGLS0DATA
    }

    /// APP_CPU_RECORD_CTRL Register bits
    namespace app_cpu_record_ctrl_bits {
        constexpr uint32_t APP_CPU_RECORD_ENABLE = (1U << 0);  ///< APP_CPU_RECORD_ENABLE
        constexpr uint32_t APP_CPU_RECORD_DISABLE = (1U << 4);  ///< APP_CPU_RECORD_DISABLE
        constexpr uint32_t APP_CPU_PDEBUG_ENABLE = (1U << 8);  ///< APP_CPU_PDEBUG_ENABLE
    }

    /// APP_CPU_RECORD_STATUS Register bits
    namespace app_cpu_record_status_bits {
        constexpr uint32_t APP_CPU_RECORDING = (1U << 0);  ///< APP_CPU_RECORDING
    }

    /// APP_CPU_RECORD_PID Register bits
    namespace app_cpu_record_pid_bits {
        constexpr uint32_t RECORD_APP_PID = (3 << 0);  ///< RECORD_APP_PID
    }

    /// APP_CPU_RECORD_PDEBUGINST Register bits
    namespace app_cpu_record_pdebuginst_bits {
        constexpr uint32_t RECORD_APP_PDEBUGINST = (32 << 0);  ///< RECORD_APP_PDEBUGINST
    }

    /// APP_CPU_RECORD_PDEBUGSTATUS Register bits
    namespace app_cpu_record_pdebugstatus_bits {
        constexpr uint32_t RECORD_APP_PDEBUGSTATUS = (8 << 0);  ///< RECORD_APP_PDEBUGSTATUS
    }

    /// APP_CPU_RECORD_PDEBUGDATA Register bits
    namespace app_cpu_record_pdebugdata_bits {
        constexpr uint32_t RECORD_APP_PDEBUGDATA = (32 << 0);  ///< RECORD_APP_PDEBUGDATA
    }

    /// APP_CPU_RECORD_PDEBUGPC Register bits
    namespace app_cpu_record_pdebugpc_bits {
        constexpr uint32_t RECORD_APP_PDEBUGPC = (32 << 0);  ///< RECORD_APP_PDEBUGPC
    }

    /// APP_CPU_RECORD_PDEBUGLS0STAT Register bits
    namespace app_cpu_record_pdebugls0stat_bits {
        constexpr uint32_t RECORD_APP_PDEBUGLS0STAT = (32 << 0);  ///< RECORD_APP_PDEBUGLS0STAT
    }

    /// APP_CPU_RECORD_PDEBUGLS0ADDR Register bits
    namespace app_cpu_record_pdebugls0addr_bits {
        constexpr uint32_t RECORD_APP_PDEBUGLS0ADDR = (32 << 0);  ///< RECORD_APP_PDEBUGLS0ADDR
    }

    /// APP_CPU_RECORD_PDEBUGLS0DATA Register bits
    namespace app_cpu_record_pdebugls0data_bits {
        constexpr uint32_t RECORD_APP_PDEBUGLS0DATA = (32 << 0);  ///< RECORD_APP_PDEBUGLS0DATA
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_PD = (1U << 0);  ///< RSA_PD
    }

    /// ROM_MPU_TABLE0 Register bits
    namespace rom_mpu_table0_bits {
        constexpr uint32_t ROM_MPU_TABLE0 = (2 << 0);  ///< ROM_MPU_TABLE0
    }

    /// ROM_MPU_TABLE1 Register bits
    namespace rom_mpu_table1_bits {
        constexpr uint32_t ROM_MPU_TABLE1 = (2 << 0);  ///< ROM_MPU_TABLE1
    }

    /// ROM_MPU_TABLE2 Register bits
    namespace rom_mpu_table2_bits {
        constexpr uint32_t ROM_MPU_TABLE2 = (2 << 0);  ///< ROM_MPU_TABLE2
    }

    /// ROM_MPU_TABLE3 Register bits
    namespace rom_mpu_table3_bits {
        constexpr uint32_t ROM_MPU_TABLE3 = (2 << 0);  ///< ROM_MPU_TABLE3
    }

    /// SHROM_MPU_TABLE0 Register bits
    namespace shrom_mpu_table0_bits {
        constexpr uint32_t SHROM_MPU_TABLE0 = (2 << 0);  ///< SHROM_MPU_TABLE0
    }

    /// SHROM_MPU_TABLE1 Register bits
    namespace shrom_mpu_table1_bits {
        constexpr uint32_t SHROM_MPU_TABLE1 = (2 << 0);  ///< SHROM_MPU_TABLE1
    }

    /// SHROM_MPU_TABLE2 Register bits
    namespace shrom_mpu_table2_bits {
        constexpr uint32_t SHROM_MPU_TABLE2 = (2 << 0);  ///< SHROM_MPU_TABLE2
    }

    /// SHROM_MPU_TABLE3 Register bits
    namespace shrom_mpu_table3_bits {
        constexpr uint32_t SHROM_MPU_TABLE3 = (2 << 0);  ///< SHROM_MPU_TABLE3
    }

    /// SHROM_MPU_TABLE4 Register bits
    namespace shrom_mpu_table4_bits {
        constexpr uint32_t SHROM_MPU_TABLE4 = (2 << 0);  ///< SHROM_MPU_TABLE4
    }

    /// SHROM_MPU_TABLE5 Register bits
    namespace shrom_mpu_table5_bits {
        constexpr uint32_t SHROM_MPU_TABLE5 = (2 << 0);  ///< SHROM_MPU_TABLE5
    }

    /// SHROM_MPU_TABLE6 Register bits
    namespace shrom_mpu_table6_bits {
        constexpr uint32_t SHROM_MPU_TABLE6 = (2 << 0);  ///< SHROM_MPU_TABLE6
    }

    /// SHROM_MPU_TABLE7 Register bits
    namespace shrom_mpu_table7_bits {
        constexpr uint32_t SHROM_MPU_TABLE7 = (2 << 0);  ///< SHROM_MPU_TABLE7
    }

    /// SHROM_MPU_TABLE8 Register bits
    namespace shrom_mpu_table8_bits {
        constexpr uint32_t SHROM_MPU_TABLE8 = (2 << 0);  ///< SHROM_MPU_TABLE8
    }

    /// SHROM_MPU_TABLE9 Register bits
    namespace shrom_mpu_table9_bits {
        constexpr uint32_t SHROM_MPU_TABLE9 = (2 << 0);  ///< SHROM_MPU_TABLE9
    }

    /// SHROM_MPU_TABLE10 Register bits
    namespace shrom_mpu_table10_bits {
        constexpr uint32_t SHROM_MPU_TABLE10 = (2 << 0);  ///< SHROM_MPU_TABLE10
    }

    /// SHROM_MPU_TABLE11 Register bits
    namespace shrom_mpu_table11_bits {
        constexpr uint32_t SHROM_MPU_TABLE11 = (2 << 0);  ///< SHROM_MPU_TABLE11
    }

    /// SHROM_MPU_TABLE12 Register bits
    namespace shrom_mpu_table12_bits {
        constexpr uint32_t SHROM_MPU_TABLE12 = (2 << 0);  ///< SHROM_MPU_TABLE12
    }

    /// SHROM_MPU_TABLE13 Register bits
    namespace shrom_mpu_table13_bits {
        constexpr uint32_t SHROM_MPU_TABLE13 = (2 << 0);  ///< SHROM_MPU_TABLE13
    }

    /// SHROM_MPU_TABLE14 Register bits
    namespace shrom_mpu_table14_bits {
        constexpr uint32_t SHROM_MPU_TABLE14 = (2 << 0);  ///< SHROM_MPU_TABLE14
    }

    /// SHROM_MPU_TABLE15 Register bits
    namespace shrom_mpu_table15_bits {
        constexpr uint32_t SHROM_MPU_TABLE15 = (2 << 0);  ///< SHROM_MPU_TABLE15
    }

    /// SHROM_MPU_TABLE16 Register bits
    namespace shrom_mpu_table16_bits {
        constexpr uint32_t SHROM_MPU_TABLE16 = (2 << 0);  ///< SHROM_MPU_TABLE16
    }

    /// SHROM_MPU_TABLE17 Register bits
    namespace shrom_mpu_table17_bits {
        constexpr uint32_t SHROM_MPU_TABLE17 = (2 << 0);  ///< SHROM_MPU_TABLE17
    }

    /// SHROM_MPU_TABLE18 Register bits
    namespace shrom_mpu_table18_bits {
        constexpr uint32_t SHROM_MPU_TABLE18 = (2 << 0);  ///< SHROM_MPU_TABLE18
    }

    /// SHROM_MPU_TABLE19 Register bits
    namespace shrom_mpu_table19_bits {
        constexpr uint32_t SHROM_MPU_TABLE19 = (2 << 0);  ///< SHROM_MPU_TABLE19
    }

    /// SHROM_MPU_TABLE20 Register bits
    namespace shrom_mpu_table20_bits {
        constexpr uint32_t SHROM_MPU_TABLE20 = (2 << 0);  ///< SHROM_MPU_TABLE20
    }

    /// SHROM_MPU_TABLE21 Register bits
    namespace shrom_mpu_table21_bits {
        constexpr uint32_t SHROM_MPU_TABLE21 = (2 << 0);  ///< SHROM_MPU_TABLE21
    }

    /// SHROM_MPU_TABLE22 Register bits
    namespace shrom_mpu_table22_bits {
        constexpr uint32_t SHROM_MPU_TABLE22 = (2 << 0);  ///< SHROM_MPU_TABLE22
    }

    /// SHROM_MPU_TABLE23 Register bits
    namespace shrom_mpu_table23_bits {
        constexpr uint32_t SHROM_MPU_TABLE23 = (2 << 0);  ///< SHROM_MPU_TABLE23
    }

    /// IMMU_TABLE0 Register bits
    namespace immu_table0_bits {
        constexpr uint32_t IMMU_TABLE0 = (7 << 0);  ///< IMMU_TABLE0
    }

    /// IMMU_TABLE1 Register bits
    namespace immu_table1_bits {
        constexpr uint32_t IMMU_TABLE1 = (7 << 0);  ///< IMMU_TABLE1
    }

    /// IMMU_TABLE2 Register bits
    namespace immu_table2_bits {
        constexpr uint32_t IMMU_TABLE2 = (7 << 0);  ///< IMMU_TABLE2
    }

    /// IMMU_TABLE3 Register bits
    namespace immu_table3_bits {
        constexpr uint32_t IMMU_TABLE3 = (7 << 0);  ///< IMMU_TABLE3
    }

    /// IMMU_TABLE4 Register bits
    namespace immu_table4_bits {
        constexpr uint32_t IMMU_TABLE4 = (7 << 0);  ///< IMMU_TABLE4
    }

    /// IMMU_TABLE5 Register bits
    namespace immu_table5_bits {
        constexpr uint32_t IMMU_TABLE5 = (7 << 0);  ///< IMMU_TABLE5
    }

    /// IMMU_TABLE6 Register bits
    namespace immu_table6_bits {
        constexpr uint32_t IMMU_TABLE6 = (7 << 0);  ///< IMMU_TABLE6
    }

    /// IMMU_TABLE7 Register bits
    namespace immu_table7_bits {
        constexpr uint32_t IMMU_TABLE7 = (7 << 0);  ///< IMMU_TABLE7
    }

    /// IMMU_TABLE8 Register bits
    namespace immu_table8_bits {
        constexpr uint32_t IMMU_TABLE8 = (7 << 0);  ///< IMMU_TABLE8
    }

    /// IMMU_TABLE9 Register bits
    namespace immu_table9_bits {
        constexpr uint32_t IMMU_TABLE9 = (7 << 0);  ///< IMMU_TABLE9
    }

    /// IMMU_TABLE10 Register bits
    namespace immu_table10_bits {
        constexpr uint32_t IMMU_TABLE10 = (7 << 0);  ///< IMMU_TABLE10
    }

    /// IMMU_TABLE11 Register bits
    namespace immu_table11_bits {
        constexpr uint32_t IMMU_TABLE11 = (7 << 0);  ///< IMMU_TABLE11
    }

    /// IMMU_TABLE12 Register bits
    namespace immu_table12_bits {
        constexpr uint32_t IMMU_TABLE12 = (7 << 0);  ///< IMMU_TABLE12
    }

    /// IMMU_TABLE13 Register bits
    namespace immu_table13_bits {
        constexpr uint32_t IMMU_TABLE13 = (7 << 0);  ///< IMMU_TABLE13
    }

    /// IMMU_TABLE14 Register bits
    namespace immu_table14_bits {
        constexpr uint32_t IMMU_TABLE14 = (7 << 0);  ///< IMMU_TABLE14
    }

    /// IMMU_TABLE15 Register bits
    namespace immu_table15_bits {
        constexpr uint32_t IMMU_TABLE15 = (7 << 0);  ///< IMMU_TABLE15
    }

    /// DMMU_TABLE0 Register bits
    namespace dmmu_table0_bits {
        constexpr uint32_t DMMU_TABLE0 = (7 << 0);  ///< DMMU_TABLE0
    }

    /// DMMU_TABLE1 Register bits
    namespace dmmu_table1_bits {
        constexpr uint32_t DMMU_TABLE1 = (7 << 0);  ///< DMMU_TABLE1
    }

    /// DMMU_TABLE2 Register bits
    namespace dmmu_table2_bits {
        constexpr uint32_t DMMU_TABLE2 = (7 << 0);  ///< DMMU_TABLE2
    }

    /// DMMU_TABLE3 Register bits
    namespace dmmu_table3_bits {
        constexpr uint32_t DMMU_TABLE3 = (7 << 0);  ///< DMMU_TABLE3
    }

    /// DMMU_TABLE4 Register bits
    namespace dmmu_table4_bits {
        constexpr uint32_t DMMU_TABLE4 = (7 << 0);  ///< DMMU_TABLE4
    }

    /// DMMU_TABLE5 Register bits
    namespace dmmu_table5_bits {
        constexpr uint32_t DMMU_TABLE5 = (7 << 0);  ///< DMMU_TABLE5
    }

    /// DMMU_TABLE6 Register bits
    namespace dmmu_table6_bits {
        constexpr uint32_t DMMU_TABLE6 = (7 << 0);  ///< DMMU_TABLE6
    }

    /// DMMU_TABLE7 Register bits
    namespace dmmu_table7_bits {
        constexpr uint32_t DMMU_TABLE7 = (7 << 0);  ///< DMMU_TABLE7
    }

    /// DMMU_TABLE8 Register bits
    namespace dmmu_table8_bits {
        constexpr uint32_t DMMU_TABLE8 = (7 << 0);  ///< DMMU_TABLE8
    }

    /// DMMU_TABLE9 Register bits
    namespace dmmu_table9_bits {
        constexpr uint32_t DMMU_TABLE9 = (7 << 0);  ///< DMMU_TABLE9
    }

    /// DMMU_TABLE10 Register bits
    namespace dmmu_table10_bits {
        constexpr uint32_t DMMU_TABLE10 = (7 << 0);  ///< DMMU_TABLE10
    }

    /// DMMU_TABLE11 Register bits
    namespace dmmu_table11_bits {
        constexpr uint32_t DMMU_TABLE11 = (7 << 0);  ///< DMMU_TABLE11
    }

    /// DMMU_TABLE12 Register bits
    namespace dmmu_table12_bits {
        constexpr uint32_t DMMU_TABLE12 = (7 << 0);  ///< DMMU_TABLE12
    }

    /// DMMU_TABLE13 Register bits
    namespace dmmu_table13_bits {
        constexpr uint32_t DMMU_TABLE13 = (7 << 0);  ///< DMMU_TABLE13
    }

    /// DMMU_TABLE14 Register bits
    namespace dmmu_table14_bits {
        constexpr uint32_t DMMU_TABLE14 = (7 << 0);  ///< DMMU_TABLE14
    }

    /// DMMU_TABLE15 Register bits
    namespace dmmu_table15_bits {
        constexpr uint32_t DMMU_TABLE15 = (7 << 0);  ///< DMMU_TABLE15
    }

    /// PRO_INTRUSION_CTRL Register bits
    namespace pro_intrusion_ctrl_bits {
        constexpr uint32_t PRO_INTRUSION_RECORD_RESET_N = (1U << 0);  ///< PRO_INTRUSION_RECORD_RESET_N
    }

    /// PRO_INTRUSION_STATUS Register bits
    namespace pro_intrusion_status_bits {
        constexpr uint32_t PRO_INTRUSION_RECORD = (4 << 0);  ///< PRO_INTRUSION_RECORD
    }

    /// APP_INTRUSION_CTRL Register bits
    namespace app_intrusion_ctrl_bits {
        constexpr uint32_t APP_INTRUSION_RECORD_RESET_N = (1U << 0);  ///< APP_INTRUSION_RECORD_RESET_N
    }

    /// APP_INTRUSION_STATUS Register bits
    namespace app_intrusion_status_bits {
        constexpr uint32_t APP_INTRUSION_RECORD = (4 << 0);  ///< APP_INTRUSION_RECORD
    }

    /// FRONT_END_MEM_PD Register bits
    namespace front_end_mem_pd_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 0);  ///< AGC_MEM_FORCE_PU
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 1);  ///< AGC_MEM_FORCE_PD
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 2);  ///< PBUS_MEM_FORCE_PU
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 3);  ///< PBUS_MEM_FORCE_PD
    }

    /// MMU_IA_INT_EN Register bits
    namespace mmu_ia_int_en_bits {
        constexpr uint32_t MMU_IA_INT_EN = (24 << 0);  ///< MMU_IA_INT_EN
    }

    /// MPU_IA_INT_EN Register bits
    namespace mpu_ia_int_en_bits {
        constexpr uint32_t MPU_IA_INT_EN = (17 << 0);  ///< MPU_IA_INT_EN
    }

    /// CACHE_IA_INT_EN Register bits
    namespace cache_ia_int_en_bits {
        constexpr uint32_t CACHE_IA_INT_EN = (28 << 0);  ///< Interrupt enable bits for various invalid cache access reasons
        constexpr uint32_t CACHE_IA_INT_APP_DROM0 = (1U << 0);  ///< APP CPU invalid access to DROM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_APP_IRAM0 = (1U << 1);  ///< APP CPU invalid access to IRAM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_APP_IRAM1 = (1U << 2);  ///< APP CPU invalid access to IRAM1 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_APP_IROM0 = (1U << 3);  ///< APP CPU invalid access to IROM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_APP_DRAM1 = (1U << 4);  ///< APP CPU invalid access to DRAM1 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_APP_OPPOSITE = (1U << 5);  ///< APP CPU invalid access to APP CPU cache when cache disabled
        constexpr uint32_t CACHE_IA_INT_PRO_DROM0 = (1U << 14);  ///< PRO CPU invalid access to DROM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_PRO_IRAM0 = (1U << 15);  ///< PRO CPU invalid access to IRAM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_PRO_IRAM1 = (1U << 16);  ///< PRO CPU invalid access to IRAM1 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_PRO_IROM0 = (1U << 17);  ///< PRO CPU invalid access to IROM0 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_PRO_DRAM1 = (1U << 18);  ///< PRO CPU invalid access to DRAM1 when cache is disabled
        constexpr uint32_t CACHE_IA_INT_PRO_OPPOSITE = (1U << 19);  ///< PRO CPU invalid access to APP CPU cache when cache disabled
    }

    /// SECURE_BOOT_CTRL Register bits
    namespace secure_boot_ctrl_bits {
        constexpr uint32_t SW_BOOTLOADER_SEL = (1U << 0);  ///< SW_BOOTLOADER_SEL
    }

    /// SPI_DMA_CHAN_SEL Register bits
    namespace spi_dma_chan_sel_bits {
        constexpr uint32_t SPI1_DMA_CHAN_SEL = (2 << 0);  ///< SPI1_DMA_CHAN_SEL
        constexpr uint32_t SPI2_DMA_CHAN_SEL = (2 << 2);  ///< SPI2_DMA_CHAN_SEL
        constexpr uint32_t SPI3_DMA_CHAN_SEL = (2 << 4);  ///< SPI3_DMA_CHAN_SEL
    }

    /// PRO_VECBASE_CTRL Register bits
    namespace pro_vecbase_ctrl_bits {
        constexpr uint32_t PRO_OUT_VECBASE_SEL = (2 << 0);  ///< PRO_OUT_VECBASE_SEL
    }

    /// PRO_VECBASE_SET Register bits
    namespace pro_vecbase_set_bits {
        constexpr uint32_t PRO_OUT_VECBASE = (22 << 0);  ///< PRO_OUT_VECBASE
    }

    /// APP_VECBASE_CTRL Register bits
    namespace app_vecbase_ctrl_bits {
        constexpr uint32_t APP_OUT_VECBASE_SEL = (2 << 0);  ///< APP_OUT_VECBASE_SEL
    }

    /// APP_VECBASE_SET Register bits
    namespace app_vecbase_set_bits {
        constexpr uint32_t APP_OUT_VECBASE = (22 << 0);  ///< APP_OUT_VECBASE
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< DATE
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x3FF5A000;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t BLK0_RDATA0;  ///< Offset: 0x00 - 
        volatile uint32_t BLK0_RDATA1;  ///< Offset: 0x04 - 
        volatile uint32_t BLK0_RDATA2;  ///< Offset: 0x08 - 
        volatile uint32_t BLK0_RDATA3;  ///< Offset: 0x0C - 
        volatile uint32_t BLK0_RDATA4;  ///< Offset: 0x10 - 
        volatile uint32_t BLK0_RDATA5;  ///< Offset: 0x14 - 
        volatile uint32_t BLK0_RDATA6;  ///< Offset: 0x18 - 
        volatile uint32_t BLK0_WDATA0;  ///< Offset: 0x1C - 
        volatile uint32_t BLK0_WDATA1;  ///< Offset: 0x20 - 
        volatile uint32_t BLK0_WDATA2;  ///< Offset: 0x24 - 
        volatile uint32_t BLK0_WDATA3;  ///< Offset: 0x28 - 
        volatile uint32_t BLK0_WDATA4;  ///< Offset: 0x2C - 
        volatile uint32_t BLK0_WDATA5;  ///< Offset: 0x30 - 
        volatile uint32_t BLK0_WDATA6;  ///< Offset: 0x34 - 
        volatile uint32_t BLK1_RDATA0;  ///< Offset: 0x38 - 
        volatile uint32_t BLK1_RDATA1;  ///< Offset: 0x3C - 
        volatile uint32_t BLK1_RDATA2;  ///< Offset: 0x40 - 
        volatile uint32_t BLK1_RDATA3;  ///< Offset: 0x44 - 
        volatile uint32_t BLK1_RDATA4;  ///< Offset: 0x48 - 
        volatile uint32_t BLK1_RDATA5;  ///< Offset: 0x4C - 
        volatile uint32_t BLK1_RDATA6;  ///< Offset: 0x50 - 
        volatile uint32_t BLK1_RDATA7;  ///< Offset: 0x54 - 
        volatile uint32_t BLK2_RDATA0;  ///< Offset: 0x58 - 
        volatile uint32_t BLK2_RDATA1;  ///< Offset: 0x5C - 
        volatile uint32_t BLK2_RDATA2;  ///< Offset: 0x60 - 
        volatile uint32_t BLK2_RDATA3;  ///< Offset: 0x64 - 
        volatile uint32_t BLK2_RDATA4;  ///< Offset: 0x68 - 
        volatile uint32_t BLK2_RDATA5;  ///< Offset: 0x6C - 
        volatile uint32_t BLK2_RDATA6;  ///< Offset: 0x70 - 
        volatile uint32_t BLK2_RDATA7;  ///< Offset: 0x74 - 
        volatile uint32_t BLK3_RDATA0;  ///< Offset: 0x78 - 
        volatile uint32_t BLK3_RDATA1;  ///< Offset: 0x7C - 
        volatile uint32_t BLK3_RDATA2;  ///< Offset: 0x80 - 
        volatile uint32_t BLK3_RDATA3;  ///< Offset: 0x84 - 
        volatile uint32_t BLK3_RDATA4;  ///< Offset: 0x88 - 
        volatile uint32_t BLK3_RDATA5;  ///< Offset: 0x8C - 
        volatile uint32_t BLK3_RDATA6;  ///< Offset: 0x90 - 
        volatile uint32_t BLK3_RDATA7;  ///< Offset: 0x94 - 
        volatile uint32_t BLK1_WDATA0;  ///< Offset: 0x98 - 
        volatile uint32_t BLK1_WDATA1;  ///< Offset: 0x9C - 
        volatile uint32_t BLK1_WDATA2;  ///< Offset: 0xA0 - 
        volatile uint32_t BLK1_WDATA3;  ///< Offset: 0xA4 - 
        volatile uint32_t BLK1_WDATA4;  ///< Offset: 0xA8 - 
        volatile uint32_t BLK1_WDATA5;  ///< Offset: 0xAC - 
        volatile uint32_t BLK1_WDATA6;  ///< Offset: 0xB0 - 
        volatile uint32_t BLK1_WDATA7;  ///< Offset: 0xB4 - 
        volatile uint32_t BLK2_WDATA0;  ///< Offset: 0xB8 - 
        volatile uint32_t BLK2_WDATA1;  ///< Offset: 0xBC - 
        volatile uint32_t BLK2_WDATA2;  ///< Offset: 0xC0 - 
        volatile uint32_t BLK2_WDATA3;  ///< Offset: 0xC4 - 
        volatile uint32_t BLK2_WDATA4;  ///< Offset: 0xC8 - 
        volatile uint32_t BLK2_WDATA5;  ///< Offset: 0xCC - 
        volatile uint32_t BLK2_WDATA6;  ///< Offset: 0xD0 - 
        volatile uint32_t BLK2_WDATA7;  ///< Offset: 0xD4 - 
        volatile uint32_t BLK3_WDATA0;  ///< Offset: 0xD8 - 
        volatile uint32_t BLK3_WDATA1;  ///< Offset: 0xDC - 
        volatile uint32_t BLK3_WDATA2;  ///< Offset: 0xE0 - 
        volatile uint32_t BLK3_WDATA3;  ///< Offset: 0xE4 - 
        volatile uint32_t BLK3_WDATA4;  ///< Offset: 0xE8 - 
        volatile uint32_t BLK3_WDATA5;  ///< Offset: 0xEC - 
        volatile uint32_t BLK3_WDATA6;  ///< Offset: 0xF0 - 
        volatile uint32_t BLK3_WDATA7;  ///< Offset: 0xF4 - 
        volatile uint32_t CLK;  ///< Offset: 0xF8 - 
        volatile uint32_t CONF;  ///< Offset: 0xFC - 
        volatile uint32_t STATUS;  ///< Offset: 0x100 - 
        volatile uint32_t CMD;  ///< Offset: 0x104 - 
        volatile uint32_t INT_RAW;  ///< Offset: 0x108 - 
        volatile uint32_t INT_ST;  ///< Offset: 0x10C - 
        volatile uint32_t INT_ENA;  ///< Offset: 0x110 - 
        volatile uint32_t INT_CLR;  ///< Offset: 0x114 - 
        volatile uint32_t DAC_CONF;  ///< Offset: 0x118 - 
        volatile uint32_t DEC_STATUS;  ///< Offset: 0x11C - 
        volatile uint32_t DATE;  ///< Offset: 0x1FC - 
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// BLK0_RDATA0 Register bits
    namespace blk0_rdata0_bits {
        constexpr uint32_t RD_EFUSE_WR_DIS = (16 << 0);  ///< RD_EFUSE_WR_DIS
        constexpr uint32_t RD_EFUSE_RD_DIS = (4 << 16);  ///< RD_EFUSE_RD_DIS
        constexpr uint32_t RD_FLASH_CRYPT_CNT = (7 << 20);  ///< RD_FLASH_CRYPT_CNT
        constexpr uint32_t RD_UART_DOWNLOAD_DIS = (1U << 27);  ///< RD_UART_DOWNLOAD_DIS
        constexpr uint32_t RESERVED_0_28 = (4 << 28);  ///< RESERVED_0_28
    }

    /// BLK0_RDATA1 Register bits
    namespace blk0_rdata1_bits {
        constexpr uint32_t RD_MAC = (32 << 0);  ///< RD_MAC
    }

    /// BLK0_RDATA2 Register bits
    namespace blk0_rdata2_bits {
        constexpr uint32_t RD_MAC_1 = (16 << 0);  ///< RD_MAC_1
        constexpr uint32_t RD_MAC_CRC = (8 << 16);  ///< RD_MAC_CRC
        constexpr uint32_t RD_RESERVE_0_88 = (8 << 24);  ///< RD_RESERVE_0_88
    }

    /// BLK0_RDATA3 Register bits
    namespace blk0_rdata3_bits {
        constexpr uint32_t RD_DISABLE_APP_CPU = (1U << 0);  ///< RD_DISABLE_APP_CPU
        constexpr uint32_t RD_DISABLE_BT = (1U << 1);  ///< RD_DISABLE_BT
        constexpr uint32_t RD_CHIP_PACKAGE_4BIT = (1U << 2);  ///< RD_CHIP_PACKAGE_4BIT
        constexpr uint32_t RD_DIS_CACHE = (1U << 3);  ///< RD_DIS_CACHE
        constexpr uint32_t RD_SPI_PAD_CONFIG_HD = (5 << 4);  ///< RD_SPI_PAD_CONFIG_HD
        constexpr uint32_t RD_CHIP_PACKAGE = (3 << 9);  ///< RD_CHIP_PACKAGE
        constexpr uint32_t RD_CHIP_CPU_FREQ_LOW = (1U << 12);  ///< RD_CHIP_CPU_FREQ_LOW
        constexpr uint32_t RD_CHIP_CPU_FREQ_RATED = (1U << 13);  ///< RD_CHIP_CPU_FREQ_RATED
        constexpr uint32_t RD_BLK3_PART_RESERVE = (1U << 14);  ///< RD_BLK3_PART_RESERVE
        constexpr uint32_t RD_CHIP_VER_REV1 = (1U << 15);  ///< RD_CHIP_VER_REV1
        constexpr uint32_t RD_RESERVE_0_112 = (16 << 16);  ///< RD_RESERVE_0_112
    }

    /// BLK0_RDATA4 Register bits
    namespace blk0_rdata4_bits {
        constexpr uint32_t RD_CLK8M_FREQ = (8 << 0);  ///< RD_CLK8M_FREQ
        constexpr uint32_t RD_ADC_VREF = (5 << 8);  ///< RD_ADC_VREF
        constexpr uint32_t RD_RESERVE_0_141 = (1U << 13);  ///< RD_RESERVE_0_141
        constexpr uint32_t RD_XPD_SDIO = (1U << 14);  ///< RD_XPD_SDIO
        constexpr uint32_t RD_XPD_SDIO_TIEH = (1U << 15);  ///< RD_XPD_SDIO_TIEH
        constexpr uint32_t RD_XPD_SDIO_FORCE = (1U << 16);  ///< RD_XPD_SDIO_FORCE
        constexpr uint32_t RD_RESERVE_0_145 = (15 << 17);  ///< RD_RESERVE_0_145
    }

    /// BLK0_RDATA5 Register bits
    namespace blk0_rdata5_bits {
        constexpr uint32_t RD_SPI_PAD_CONFIG_CLK = (5 << 0);  ///< RD_SPI_PAD_CONFIG_CLK
        constexpr uint32_t RD_SPI_PAD_CONFIG_Q = (5 << 5);  ///< RD_SPI_PAD_CONFIG_Q
        constexpr uint32_t RD_SPI_PAD_CONFIG_D = (5 << 10);  ///< RD_SPI_PAD_CONFIG_D
        constexpr uint32_t RD_SPI_PAD_CONFIG_CS0 = (5 << 15);  ///< RD_SPI_PAD_CONFIG_CS0
        constexpr uint32_t RD_CHIP_VER_REV2 = (1U << 20);  ///< RD_CHIP_VER_REV2
        constexpr uint32_t RD_RESERVE_0_181 = (1U << 21);  ///< RD_RESERVE_0_181
        constexpr uint32_t RD_VOL_LEVEL_HP_INV = (2 << 22);  ///< RD_VOL_LEVEL_HP_INV
        constexpr uint32_t RD_WAFER_VERSION_MINOR = (2 << 24);  ///< RD_WAFER_VERSION_MINOR
        constexpr uint32_t RD_RESERVE_0_186 = (2 << 26);  ///< RD_RESERVE_0_186
        constexpr uint32_t RD_FLASH_CRYPT_CONFIG = (4 << 28);  ///< RD_FLASH_CRYPT_CONFIG
    }

    /// BLK0_RDATA6 Register bits
    namespace blk0_rdata6_bits {
        constexpr uint32_t RD_CODING_SCHEME = (2 << 0);  ///< RD_CODING_SCHEME
        constexpr uint32_t RD_CONSOLE_DEBUG_DISABLE = (1U << 2);  ///< RD_CONSOLE_DEBUG_DISABLE
        constexpr uint32_t RD_DISABLE_SDIO_HOST = (1U << 3);  ///< RD_DISABLE_SDIO_HOST
        constexpr uint32_t RD_ABS_DONE_0 = (1U << 4);  ///< RD_ABS_DONE_0
        constexpr uint32_t RD_ABS_DONE_1 = (1U << 5);  ///< RD_ABS_DONE_1
        constexpr uint32_t RD_JTAG_DISABLE = (1U << 6);  ///< RD_JTAG_DISABLE
        constexpr uint32_t RD_DISABLE_DL_ENCRYPT = (1U << 7);  ///< RD_DISABLE_DL_ENCRYPT
        constexpr uint32_t RD_DISABLE_DL_DECRYPT = (1U << 8);  ///< RD_DISABLE_DL_DECRYPT
        constexpr uint32_t RD_DISABLE_DL_CACHE = (1U << 9);  ///< RD_DISABLE_DL_CACHE
        constexpr uint32_t RD_KEY_STATUS = (1U << 10);  ///< RD_KEY_STATUS
        constexpr uint32_t RD_RESERVE_0_203 = (21 << 11);  ///< RD_RESERVE_0_203
    }

    /// BLK0_WDATA0 Register bits
    namespace blk0_wdata0_bits {
        constexpr uint32_t WR_DIS = (16 << 0);  ///< WR_DIS
        constexpr uint32_t RD_DIS = (4 << 16);  ///< RD_DIS
        constexpr uint32_t FLASH_CRYPT_CNT = (7 << 20);  ///< FLASH_CRYPT_CNT
    }

    /// BLK0_WDATA1 Register bits
    namespace blk0_wdata1_bits {
        constexpr uint32_t WIFI_MAC_CRC_LOW = (32 << 0);  ///< WIFI_MAC_CRC_LOW
    }

    /// BLK0_WDATA2 Register bits
    namespace blk0_wdata2_bits {
        constexpr uint32_t WIFI_MAC_CRC_HIGH = (24 << 0);  ///< WIFI_MAC_CRC_HIGH
    }

    /// BLK0_WDATA3 Register bits
    namespace blk0_wdata3_bits {
        constexpr uint32_t DISABLE_APP_CPU = (1U << 0);  ///< DISABLE_APP_CPU
        constexpr uint32_t DISABLE_BT = (1U << 1);  ///< DISABLE_BT
        constexpr uint32_t CHIP_PACKAGE_4BIT = (1U << 2);  ///< CHIP_PACKAGE_4BIT
        constexpr uint32_t DIS_CACHE = (1U << 3);  ///< DIS_CACHE
        constexpr uint32_t SPI_PAD_CONFIG_HD = (5 << 4);  ///< SPI_PAD_CONFIG_HD
        constexpr uint32_t CHIP_PACKAGE = (3 << 9);  ///< CHIP_PACKAGE
        constexpr uint32_t CHIP_CPU_FREQ_LOW = (1U << 12);  ///< CHIP_CPU_FREQ_LOW
        constexpr uint32_t CHIP_CPU_FREQ_RATED = (1U << 13);  ///< CHIP_CPU_FREQ_RATED
        constexpr uint32_t BLK3_PART_RESERVE = (1U << 14);  ///< BLK3_PART_RESERVE
        constexpr uint32_t CHIP_VER_REV1 = (1U << 15);  ///< CHIP_VER_REV1
        constexpr uint32_t RESERVE_0_112 = (16 << 16);  ///< RESERVE_0_112
    }

    /// BLK0_WDATA4 Register bits
    namespace blk0_wdata4_bits {
        constexpr uint32_t CLK8M_FREQ = (8 << 0);  ///< CLK8M_FREQ
        constexpr uint32_t ADC_VREF = (5 << 8);  ///< ADC_VREF
        constexpr uint32_t RESERVE_0_141 = (1U << 13);  ///< RESERVE_0_141
        constexpr uint32_t XPD_SDIO = (1U << 14);  ///< XPD_SDIO
        constexpr uint32_t XPD_SDIO_TIEH = (1U << 15);  ///< XPD_SDIO_TIEH
        constexpr uint32_t XPD_SDIO_FORCE = (1U << 16);  ///< XPD_SDIO_FORCE
        constexpr uint32_t RESERVE_0_145 = (15 << 17);  ///< RESERVE_0_145
    }

    /// BLK0_WDATA5 Register bits
    namespace blk0_wdata5_bits {
        constexpr uint32_t SPI_PAD_CONFIG_CLK = (5 << 0);  ///< SPI_PAD_CONFIG_CLK
        constexpr uint32_t SPI_PAD_CONFIG_Q = (5 << 5);  ///< SPI_PAD_CONFIG_Q
        constexpr uint32_t SPI_PAD_CONFIG_D = (5 << 10);  ///< SPI_PAD_CONFIG_D
        constexpr uint32_t SPI_PAD_CONFIG_CS0 = (5 << 15);  ///< SPI_PAD_CONFIG_CS0
        constexpr uint32_t CHIP_VER_REV2 = (1U << 20);  ///< CHIP_VER_REV2
        constexpr uint32_t RESERVE_0_181 = (1U << 21);  ///< RESERVE_0_181
        constexpr uint32_t VOL_LEVEL_HP_INV = (2 << 22);  ///< VOL_LEVEL_HP_INV
        constexpr uint32_t WAFER_VERSION_MINOR = (2 << 24);  ///< WAFER_VERSION_MINOR
        constexpr uint32_t RESERVE_0_186 = (2 << 26);  ///< RESERVE_0_186
        constexpr uint32_t FLASH_CRYPT_CONFIG = (4 << 28);  ///< FLASH_CRYPT_CONFIG
    }

    /// BLK0_WDATA6 Register bits
    namespace blk0_wdata6_bits {
        constexpr uint32_t CODING_SCHEME = (2 << 0);  ///< CODING_SCHEME
        constexpr uint32_t CONSOLE_DEBUG_DISABLE = (1U << 2);  ///< CONSOLE_DEBUG_DISABLE
        constexpr uint32_t DISABLE_SDIO_HOST = (1U << 3);  ///< DISABLE_SDIO_HOST
        constexpr uint32_t ABS_DONE_0 = (1U << 4);  ///< ABS_DONE_0
        constexpr uint32_t ABS_DONE_1 = (1U << 5);  ///< ABS_DONE_1
        constexpr uint32_t DISABLE_JTAG = (1U << 6);  ///< DISABLE_JTAG
        constexpr uint32_t DISABLE_DL_ENCRYPT = (1U << 7);  ///< DISABLE_DL_ENCRYPT
        constexpr uint32_t DISABLE_DL_DECRYPT = (1U << 8);  ///< DISABLE_DL_DECRYPT
        constexpr uint32_t DISABLE_DL_CACHE = (1U << 9);  ///< DISABLE_DL_CACHE
        constexpr uint32_t KEY_STATUS = (1U << 10);  ///< KEY_STATUS
    }

    /// BLK1_RDATA0 Register bits
    namespace blk1_rdata0_bits {
        constexpr uint32_t RD_BLOCK1 = (32 << 0);  ///< RD_BLOCK1
    }

    /// BLK1_RDATA1 Register bits
    namespace blk1_rdata1_bits {
        constexpr uint32_t RD_BLOCK1_1 = (32 << 0);  ///< RD_BLOCK1_1
    }

    /// BLK1_RDATA2 Register bits
    namespace blk1_rdata2_bits {
        constexpr uint32_t RD_BLOCK1_2 = (32 << 0);  ///< RD_BLOCK1_2
    }

    /// BLK1_RDATA3 Register bits
    namespace blk1_rdata3_bits {
        constexpr uint32_t RD_BLOCK1_3 = (32 << 0);  ///< RD_BLOCK1_3
    }

    /// BLK1_RDATA4 Register bits
    namespace blk1_rdata4_bits {
        constexpr uint32_t RD_BLOCK1_4 = (32 << 0);  ///< RD_BLOCK1_4
    }

    /// BLK1_RDATA5 Register bits
    namespace blk1_rdata5_bits {
        constexpr uint32_t RD_BLOCK1_5 = (32 << 0);  ///< RD_BLOCK1_5
    }

    /// BLK1_RDATA6 Register bits
    namespace blk1_rdata6_bits {
        constexpr uint32_t RD_BLOCK1_6 = (32 << 0);  ///< RD_BLOCK1_6
    }

    /// BLK1_RDATA7 Register bits
    namespace blk1_rdata7_bits {
        constexpr uint32_t RD_BLOCK1_7 = (32 << 0);  ///< RD_BLOCK1_7
    }

    /// BLK2_RDATA0 Register bits
    namespace blk2_rdata0_bits {
        constexpr uint32_t RD_BLOCK2 = (32 << 0);  ///< RD_BLOCK2
    }

    /// BLK2_RDATA1 Register bits
    namespace blk2_rdata1_bits {
        constexpr uint32_t RD_BLOCK2_1 = (32 << 0);  ///< RD_BLOCK2_1
    }

    /// BLK2_RDATA2 Register bits
    namespace blk2_rdata2_bits {
        constexpr uint32_t RD_BLOCK2_2 = (32 << 0);  ///< RD_BLOCK2_2
    }

    /// BLK2_RDATA3 Register bits
    namespace blk2_rdata3_bits {
        constexpr uint32_t RD_BLOCK2_3 = (32 << 0);  ///< RD_BLOCK2_3
    }

    /// BLK2_RDATA4 Register bits
    namespace blk2_rdata4_bits {
        constexpr uint32_t RD_BLOCK2_4 = (32 << 0);  ///< RD_BLOCK2_4
    }

    /// BLK2_RDATA5 Register bits
    namespace blk2_rdata5_bits {
        constexpr uint32_t RD_BLOCK2_5 = (32 << 0);  ///< RD_BLOCK2_5
    }

    /// BLK2_RDATA6 Register bits
    namespace blk2_rdata6_bits {
        constexpr uint32_t RD_BLOCK2_6 = (32 << 0);  ///< RD_BLOCK2_6
    }

    /// BLK2_RDATA7 Register bits
    namespace blk2_rdata7_bits {
        constexpr uint32_t RD_BLOCK2_7 = (32 << 0);  ///< RD_BLOCK2_7
    }

    /// BLK3_RDATA0 Register bits
    namespace blk3_rdata0_bits {
        constexpr uint32_t RD_CUSTOM_MAC_CRC = (8 << 0);  ///< RD_CUSTOM_MAC_CRC
        constexpr uint32_t RD_CUSTOM_MAC = (24 << 8);  ///< RD_CUSTOM_MAC
    }

    /// BLK3_RDATA1 Register bits
    namespace blk3_rdata1_bits {
        constexpr uint32_t RD_CUSTOM_MAC_1 = (24 << 0);  ///< RD_CUSTOM_MAC_1
        constexpr uint32_t RESERVED_3_56 = (8 << 24);  ///< RESERVED_3_56
    }

    /// BLK3_RDATA2 Register bits
    namespace blk3_rdata2_bits {
        constexpr uint32_t RD_BLK3_RESERVED_2 = (32 << 0);  ///< RD_BLK3_RESERVED_2
    }

    /// BLK3_RDATA3 Register bits
    namespace blk3_rdata3_bits {
        constexpr uint32_t RD_ADC1_TP_LOW = (7 << 0);  ///< RD_ADC1_TP_LOW
        constexpr uint32_t RD_ADC1_TP_HIGH = (9 << 7);  ///< RD_ADC1_TP_HIGH
        constexpr uint32_t RD_ADC2_TP_LOW = (7 << 16);  ///< RD_ADC2_TP_LOW
        constexpr uint32_t RD_ADC2_TP_HIGH = (9 << 23);  ///< RD_ADC2_TP_HIGH
    }

    /// BLK3_RDATA4 Register bits
    namespace blk3_rdata4_bits {
        constexpr uint32_t RD_SECURE_VERSION = (32 << 0);  ///< RD_SECURE_VERSION
    }

    /// BLK3_RDATA5 Register bits
    namespace blk3_rdata5_bits {
        constexpr uint32_t RESERVED_3_160 = (24 << 0);  ///< RESERVED_3_160
        constexpr uint32_t RD_MAC_VERSION = (8 << 24);  ///< RD_MAC_VERSION
    }

    /// BLK3_RDATA6 Register bits
    namespace blk3_rdata6_bits {
        constexpr uint32_t RD_BLK3_RESERVED_6 = (32 << 0);  ///< RD_BLK3_RESERVED_6
    }

    /// BLK3_RDATA7 Register bits
    namespace blk3_rdata7_bits {
        constexpr uint32_t RD_BLK3_RESERVED_7 = (32 << 0);  ///< RD_BLK3_RESERVED_7
    }

    /// BLK1_WDATA0 Register bits
    namespace blk1_wdata0_bits {
        constexpr uint32_t BLK1_DIN0 = (32 << 0);  ///< BLK1_DIN0
    }

    /// BLK1_WDATA1 Register bits
    namespace blk1_wdata1_bits {
        constexpr uint32_t BLK1_DIN1 = (32 << 0);  ///< BLK1_DIN1
    }

    /// BLK1_WDATA2 Register bits
    namespace blk1_wdata2_bits {
        constexpr uint32_t BLK1_DIN2 = (32 << 0);  ///< BLK1_DIN2
    }

    /// BLK1_WDATA3 Register bits
    namespace blk1_wdata3_bits {
        constexpr uint32_t BLK1_DIN3 = (32 << 0);  ///< BLK1_DIN3
    }

    /// BLK1_WDATA4 Register bits
    namespace blk1_wdata4_bits {
        constexpr uint32_t BLK1_DIN4 = (32 << 0);  ///< BLK1_DIN4
    }

    /// BLK1_WDATA5 Register bits
    namespace blk1_wdata5_bits {
        constexpr uint32_t BLK1_DIN5 = (32 << 0);  ///< BLK1_DIN5
    }

    /// BLK1_WDATA6 Register bits
    namespace blk1_wdata6_bits {
        constexpr uint32_t BLK1_DIN6 = (32 << 0);  ///< BLK1_DIN6
    }

    /// BLK1_WDATA7 Register bits
    namespace blk1_wdata7_bits {
        constexpr uint32_t BLK1_DIN7 = (32 << 0);  ///< BLK1_DIN7
    }

    /// BLK2_WDATA0 Register bits
    namespace blk2_wdata0_bits {
        constexpr uint32_t BLK2_DIN0 = (32 << 0);  ///< BLK2_DIN0
    }

    /// BLK2_WDATA1 Register bits
    namespace blk2_wdata1_bits {
        constexpr uint32_t BLK2_DIN1 = (32 << 0);  ///< BLK2_DIN1
    }

    /// BLK2_WDATA2 Register bits
    namespace blk2_wdata2_bits {
        constexpr uint32_t BLK2_DIN2 = (32 << 0);  ///< BLK2_DIN2
    }

    /// BLK2_WDATA3 Register bits
    namespace blk2_wdata3_bits {
        constexpr uint32_t BLK2_DIN3 = (32 << 0);  ///< BLK2_DIN3
    }

    /// BLK2_WDATA4 Register bits
    namespace blk2_wdata4_bits {
        constexpr uint32_t BLK2_DIN4 = (32 << 0);  ///< BLK2_DIN4
    }

    /// BLK2_WDATA5 Register bits
    namespace blk2_wdata5_bits {
        constexpr uint32_t BLK2_DIN5 = (32 << 0);  ///< BLK2_DIN5
    }

    /// BLK2_WDATA6 Register bits
    namespace blk2_wdata6_bits {
        constexpr uint32_t BLK2_DIN6 = (32 << 0);  ///< BLK2_DIN6
    }

    /// BLK2_WDATA7 Register bits
    namespace blk2_wdata7_bits {
        constexpr uint32_t BLK2_DIN7 = (32 << 0);  ///< BLK2_DIN7
    }

    /// BLK3_WDATA0 Register bits
    namespace blk3_wdata0_bits {
        constexpr uint32_t BLK3_DIN0 = (32 << 0);  ///< BLK3_DIN0
    }

    /// BLK3_WDATA1 Register bits
    namespace blk3_wdata1_bits {
        constexpr uint32_t BLK3_DIN1 = (32 << 0);  ///< BLK3_DIN1
    }

    /// BLK3_WDATA2 Register bits
    namespace blk3_wdata2_bits {
        constexpr uint32_t BLK3_DIN2 = (32 << 0);  ///< BLK3_DIN2
    }

    /// BLK3_WDATA3 Register bits
    namespace blk3_wdata3_bits {
        constexpr uint32_t ADC1_TP_LOW = (7 << 0);  ///< ADC1_TP_LOW
        constexpr uint32_t ADC1_TP_HIGH = (9 << 7);  ///< ADC1_TP_HIGH
        constexpr uint32_t ADC2_TP_LOW = (7 << 16);  ///< ADC2_TP_LOW
        constexpr uint32_t ADC2_TP_HIGH = (9 << 23);  ///< ADC2_TP_HIGH
    }

    /// BLK3_WDATA4 Register bits
    namespace blk3_wdata4_bits {
        constexpr uint32_t SECURE_VERSION = (32 << 0);  ///< SECURE_VERSION
    }

    /// BLK3_WDATA5 Register bits
    namespace blk3_wdata5_bits {
        constexpr uint32_t BLK3_DIN5 = (32 << 0);  ///< BLK3_DIN5
    }

    /// BLK3_WDATA6 Register bits
    namespace blk3_wdata6_bits {
        constexpr uint32_t BLK3_DIN6 = (32 << 0);  ///< BLK3_DIN6
    }

    /// BLK3_WDATA7 Register bits
    namespace blk3_wdata7_bits {
        constexpr uint32_t BLK3_DIN7 = (32 << 0);  ///< BLK3_DIN7
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t SEL0 = (8 << 0);  ///< SEL0
        constexpr uint32_t SEL1 = (8 << 8);  ///< SEL1
        constexpr uint32_t EN = (1U << 16);  ///< EN
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< OP_CODE
        constexpr uint32_t FORCE_NO_WR_RD_DIS = (1U << 16);  ///< FORCE_NO_WR_RD_DIS
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t DEBUG = (32 << 0);  ///< DEBUG
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< READ_CMD
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< PGM_CMD
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< READ_DONE_INT_RAW
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< PGM_DONE_INT_RAW
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< READ_DONE_INT_ST
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< PGM_DONE_INT_ST
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< READ_DONE_INT_ENA
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< PGM_DONE_INT_ENA
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< READ_DONE_INT_CLR
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< PGM_DONE_INT_CLR
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< DAC_CLK_DIV
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< DAC_CLK_PAD_SEL
    }

    /// DEC_STATUS Register bits
    namespace dec_status_bits {
        constexpr uint32_t DEC_WARNINGS = (12 << 0);  ///< DEC_WARNINGS
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t EMAC_DMA_BASE = 0x3FF69000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t DMABUSMODE;  ///< Offset: 0x00 - Bus mode configuration
        volatile uint32_t DMATXPOLLDEMAND;  ///< Offset: 0x04 - When these bits are written with any value the DMA reads...
        volatile uint32_t DMARXPOLLDEMAND;  ///< Offset: 0x08 - When these bits are written with any value the DMA reads...
        volatile uint32_t DMARXBASEADDR;  ///< Offset: 0x0C - This field contains the base address of the first...
        volatile uint32_t DMATXBASEADDR;  ///< Offset: 0x10 - This field contains the base address of the first...
        volatile uint32_t DMASTATUS;  ///< Offset: 0x14 - State of interrupts, errors and other events
        volatile uint32_t DMAOPERATION_MODE;  ///< Offset: 0x18 - Receive and Transmit operating modes and command
        volatile uint32_t DMAIN_EN;  ///< Offset: 0x1C - When this bit is set with Normal Interrupt Summary...
        volatile uint32_t DMAMISSEDFR;  ///< Offset: 0x20 - Missed Frame and Buffer Overflow Counter Register
        volatile uint32_t DMARINTWDTIMER;  ///< Offset: 0x24 - Watchdog timer count on receive
        volatile uint32_t DMATXCURRDESC;  ///< Offset: 0x48 - The address of the current receive descriptor list....
        volatile uint32_t DMARXCURRDESC;  ///< Offset: 0x4C - The address of the current receive descriptor list....
        volatile uint32_t DMATXCURRADDR_BUF;  ///< Offset: 0x50 - The address of the current receive descriptor list....
        volatile uint32_t DMARXCURRADDR_BUF;  ///< Offset: 0x54 - The address of the current receive descriptor list....
    };

    /// Peripheral instances
    inline Registers* EMAC_DMA = reinterpret_cast<Registers*>(EMAC_DMA_BASE);

    // Bit definitions
    /// DMABUSMODE Register bits
    namespace dmabusmode_bits {
        constexpr uint32_t SW_RST = (1U << 0);  ///< When this bit is set the MAC DMA Controller resets the logic and all internal registers of the MAC. It is cleared automatically after the reset operation is complete in all of the ETH_MAC clock domains. Before reprogramming any register of the ETH_MAC you should read a zero (0) value in this bit.
        constexpr uint32_t DMA_ARB_SCH = (1U << 1);  ///< This bit specifies the arbitration scheme between the transmit and receive paths.1'b0: weighted round-robin with RX:TX or TX:RX priority specified in PR (bit[15:14]). 1'b1 Fixed priority (Rx priority to Tx).
        constexpr uint32_t DESC_SKIP_LEN = (5 << 2);  ///< This bit specifies the number of Word to skip between two unchained descriptors.The address skipping starts from the end of current descriptor to the start of next descriptor. When the DSL(DESC_SKIP_LEN) value is equal to zero the descriptor table is taken as contiguous by the DMA in Ring mode.
        constexpr uint32_t ALT_DESC_SIZE = (1U << 7);  ///< When set the size of the alternate descriptor increases to 32 bytes.
        constexpr uint32_t PROG_BURST_LEN = (6 << 8);  ///< These bits indicate the maximum number of beats to be transferred in one DMA transaction. If the number of beats to be transferred is more than 32 then perform the following steps: 1. Set the PBLx8 mode 2. Set the PBL(PROG_BURST_LEN).
        constexpr uint32_t PRI_RATIO = (2 << 14);  ///< These bits control the priority ratio in the weighted round-robin arbitration between the Rx DMA and Tx DMA. These bits are valid only when Bit 1 (DA) is reset. The priority ratio Rx:Tx represented by each bit: 2'b00 -- 1: 1 2'b01 -- 2: 0 2'b10 -- 3: 1 2'b11 -- 4: 1
        constexpr uint32_t FIXED_BURST = (1U << 16);  ///< This bit controls whether the AHB master interface performs fixed burst transfers or not. When set the AHB interface uses only SINGLE INCR4 INCR8 or INCR16 during start of the normal burst transfers. When reset the AHB interface uses SINGLE and INCR burst transfer Operations.
        constexpr uint32_t RX_DMA_PBL = (6 << 17);  ///< This field indicates the maximum number of beats to be transferred in one Rx DMA transaction. This is the maximum value that is used in a single block Read or Write.The Rx DMA always attempts to burst as specified in the RPBL(RX_DMA_PBL) bit each time it starts a burst transfer on the host bus. You can program RPBL with values of 1 2 4 8 16 and 32. Any other value results in undefined behavior. This field is valid and applicable only when USP(USE_SEP_PBL) is set high.
        constexpr uint32_t USE_SEP_PBL = (1U << 23);  ///< When set high this bit configures the Rx DMA to use the value configured in Bits[22:17] as PBL. The PBL value in Bits[13:8] is applicable only to the Tx DMA operations. When reset to low the PBL value in Bits[13:8] is applicable for both DMA engines.
        constexpr uint32_t PBLX8_MODE = (1U << 24);  ///< When set high this bit multiplies the programmed PBL value (Bits[22:17] and Bits[13:8]) eight times. Therefore the DMA transfers the data in 8 16 32 64 128 and 256 beats depending on the PBL value.
        constexpr uint32_t DMAADDRALIBEA = (1U << 25);  ///< When this bit is set high and the FIXED_BURST bit is 1 the AHB interface generates all bursts aligned to the start address LS bits. If the FIXED_BURST bit is 0 the first burst (accessing the start address of data buffer) is not aligned but subsequent bursts are aligned to the address.
        constexpr uint32_t DMAMIXEDBURST = (1U << 26);  ///< When this bit is set high and the FIXED_BURST bit is low the AHB master interface starts all bursts of a length more than 16 with INCR (undefined burst) whereas it reverts to fixed burst transfers (INCRx and SINGLE) for burst length of 16 and less.
    }

    /// DMASTATUS Register bits
    namespace dmastatus_bits {
        constexpr uint32_t TRANS_INT = (1U << 0);  ///< This bit indicates that the frame transmission is complete. When transmission is complete Bit[31] (OWN) of TDES0 is reset and the specific frame status information is updated in the Descriptor.
        constexpr uint32_t TRANS_PROC_STOP = (1U << 1);  ///< This bit is set when the transmission is stopped.
        constexpr uint32_t TRANS_BUF_UNAVAIL = (1U << 2);  ///< This bit indicates that the host owns the Next Descriptor in the Transmit List and the DMA cannot acquire it. Transmission is suspended. Bits[22:20] explain the Transmit Process state transitions. To resume processing Transmit descriptors the host should change the ownership of the descriptor by setting TDES0[31] and then issue a Transmit Poll Demand Command.
        constexpr uint32_t TRANS_JABBER_TO = (1U << 3);  ///< This bit indicates that the Transmit Jabber Timer expired which happens when the frame size exceeds 2 048 (10 240 bytes when the Jumbo frame is enabled). When the Jabber Timeout occurs the transmission process is aborted and placed in the Stopped state. This causes the Transmit Jabber Timeout TDES0[14] flag to assert.
        constexpr uint32_t RECV_OVFLOW = (1U << 4);  ///< This bit indicates that the Receive Buffer had an Overflow during frame reception. If the partial frame is transferred to the application the overflow status is set in RDES0[11].
        constexpr uint32_t TRANS_UNDFLOW = (1U << 5);  ///< This bit indicates that the Transmit Buffer had an Underflow during frame transmission. Transmission is suspended and an Underflow Error TDES0[1] is set.
        constexpr uint32_t RECV_INT = (1U << 6);  ///< This bit indicates that the frame reception is complete. When reception is complete the Bit[31] of RDES1 (Disable Interrupt on Completion) is reset in the last Descriptor and the specific frame status information is updated in the descriptor. The reception remains in the Running state.
        constexpr uint32_t RECV_BUF_UNAVAIL = (1U << 7);  ///< This bit indicates that the host owns the Next Descriptor in the Receive List and the DMA cannot acquire it. The Receive Process is suspended. To resume processing Receive descriptors the host should change the ownership of the descriptor and issue a Receive Poll Demand command. If no Receive Poll Demand is issued the Receive Process resumes when the next recognized incoming frame is received. This bit is set only when the previous Receive Descriptor is owned by the DMA.
        constexpr uint32_t RECV_PROC_STOP = (1U << 8);  ///< This bit is asserted when the Receive Process enters the Stopped state.
        constexpr uint32_t RECV_WDT_TO = (1U << 9);  ///< When set this bit indicates that the Receive Watchdog Timer expired while receiving the current frame and the current frame is truncated after the watchdog timeout.
        constexpr uint32_t EARLY_TRANS_INT = (1U << 10);  ///< This bit indicates that the frame to be transmitted is fully transferred to the MTL Transmit FIFO.
        constexpr uint32_t FATAL_BUS_ERR_INT = (1U << 13);  ///< This bit indicates that a bus error occurred as described in Bits [25:23]. When this bit is set the corresponding DMA engine disables all of its bus accesses.
        constexpr uint32_t EARLY_RECV_INT = (1U << 14);  ///< This bit indicates that the DMA filled the first data buffer of the packet. This bit is cleared when the software writes 1 to this bit or when Bit[6] (RI) of this register is set (whichever occurs earlier).
        constexpr uint32_t ABN_INT_SUMM = (1U << 15);  ///< Abnormal Interrupt Summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in Interrupt Enable Register: Bit[1]: Transmit Process Stopped. Bit[3]: Transmit Jabber Timeout. Bit[4]: Receive FIFO Overflow. Bit[5]: Transmit Underflow. Bit[7]: Receive Buffer Unavailable. Bit[8]: Receive Process Stopped. Bit[9]: Receive Watchdog Timeout. Bit[10]: Early Transmit Interrupt. Bit[13]: Fatal Bus Error. Only unmasked bits affect the Abnormal Interrupt Summary bit. This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit which causes AIS to be set is cleared.
        constexpr uint32_t NORM_INT_SUMM = (1U << 16);  ///< Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in Interrupt Enable Register: Bit[0]: Transmit Interrupt. Bit[2]: Transmit Buffer Unavailable. Bit[6]: Receive Interrupt. Bit[14]: Early Receive Interrupt. Only unmasked bits affect the Normal Interrupt Summary bit.This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit which causes NIS to be set is cleared.
        constexpr uint32_t RECV_PROC_STATE = (3 << 17);  ///< This field indicates the Receive DMA FSM state. This field does not generate an interrupt. 3'b000: Stopped. Reset or Stop Receive Command issued. 3'b001: Running. Fetching Receive Transfer Descriptor. 3'b010: Reserved for future use. 3'b011: Running. Waiting for RX packets. 3'b100: Suspended. Receive Descriptor Unavailable. 3'b101: Running. Closing Receive Descriptor. 3'b110: TIME_STAMP write state. 3'b111: Running. Transferring the TX packets data from receive buffer to host memory.
        constexpr uint32_t TRANS_PROC_STATE = (3 << 20);  ///< This field indicates the Transmit DMA FSM state. This field does not generate an interrupt. 3'b000: Stopped. Reset or Stop Transmit Command issued. 3'b001: Running. Fetching Transmit Transfer Descriptor. 3'b010: Reserved for future use. 3'b011: Running. Waiting for TX packets. 3'b100: Suspended. Receive Descriptor Unavailable. 3'b101: Running. Closing Transmit Descriptor. 3'b110: TIME_STAMP write state. 3'b111: Running. Transferring the TX packets data from transmit buffer to host memory.
        constexpr uint32_t ERROR_BITS = (3 << 23);  ///< This field indicates the type of error that caused a Bus Error for example error response on the AHB interface. This field is valid only when Bit[13] (FBI) is set. This field does not generate an interrupt. 3'b000: Error during Rx DMA Write Data Transfer. 3'b011: Error during Tx DMA Read Data Transfer. 3'b100: Error during Rx DMA Descriptor Write Access. 3'b101: Error during Tx DMA Descriptor Write Access. 3'b110: Error during Rx DMA Descriptor Read Access. 3'b111: Error during Tx DMA Descriptor Read Access.
        constexpr uint32_t PMT_INT = (1U << 28);  ///< This bit indicates an interrupt event in the PMT module of the ETH_MAC. The software must read the PMT Control and Status Register in the MAC to get the exact cause of interrupt and clear its source to reset this bit to 1'b0.
        constexpr uint32_t TS_TRI_INT = (1U << 29);  ///< This bit indicates an interrupt event in the Timestamp Generator block of the ETH_MAC.The software must read the corresponding registers in the ETH_MAC to get the exact cause of the interrupt and clear its source to reset this bit to 1'b0.
    }

    /// DMAOPERATION_MODE Register bits
    namespace dmaoperation_mode_bits {
        constexpr uint32_t START_STOP_RX = (1U << 1);  ///< When this bit is set the Receive process is placed in the Running state. The DMA attempts to acquire the descriptor from the Receive list and processes the incoming frames.When this bit is cleared the Rx DMA operation is stopped after the transfer of the current frame.
        constexpr uint32_t OPT_SECOND_FRAME = (1U << 2);  ///< When this bit is set it instructs the DMA to process the second frame of the Transmit data even before the status for the first frame is obtained.
        constexpr uint32_t RX_THRESH_CTRL = (2 << 3);  ///< These two bits control the threshold level of the MTL Receive FIFO. Transfer (request) to DMA starts when the frame size within the MTL Receive FIFO is larger than the threshold. 2'b00: 64， 2'b01: 32， 2'b10: 96， 2'b11: 128 .
        constexpr uint32_t DROP_GFRM = (1U << 5);  ///< When set the MAC drops the received giant frames in the Rx FIFO that is frames that are larger than the computed giant frame limit.
        constexpr uint32_t FWD_UNDER_GF = (1U << 6);  ///< When set the Rx FIFO forwards Undersized frames (that is frames with no Error and length less than 64 bytes) including pad-bytes and CRC.
        constexpr uint32_t FWD_ERR_FRAME = (1U << 7);  ///< When this bit is reset the Rx FIFO drops frames with error status (CRC error collision error giant frame watchdog timeout or overflow).
        constexpr uint32_t START_STOP_TRANSMISSION_COMMAND = (1U << 13);  ///< When this bit is set transmission is placed in the Running state and the DMA checks the Transmit List at the current position for a frame to be transmitted.When this bit is reset the transmission process is placed in the Stopped state after completing the transmission of the current frame.
        constexpr uint32_t TX_THRESH_CTRL = (3 << 14);  ///< These bits control the threshold level of the MTL Transmit FIFO. Transmission starts when the frame size within the MTL Transmit FIFO is larger than the threshold. In addition full frames with a length less than the threshold are also transmitted. These bits are used only when Tx_Str_fwd is reset. 3'b000: 64 3'b001: 128 3'b010: 192 3'b011: 256 3'b100: 40 3'b101: 32 3'b110: 24 3'b111: 16 .
        constexpr uint32_t FLUSH_TX_FIFO = (1U << 20);  ///< When this bit is set the transmit FIFO controller logic is reset to its default values and thus all data in the Tx FIFO is lost or flushed. This bit is cleared internally when the flushing operation is complete.
        constexpr uint32_t TX_STR_FWD = (1U << 21);  ///< When this bit is set transmission starts when a full frame resides in the MTL Transmit FIFO. When this bit is set the Tx_Thresh_Ctrl values specified in Tx_Thresh_Ctrl are ignored.
        constexpr uint32_t DIS_FLUSH_RECV_FRAMES = (1U << 24);  ///< When this bit is set the Rx DMA does not flush any frames because of the unavailability of receive descriptors or buffers.
        constexpr uint32_t RX_STORE_FORWARD = (1U << 25);  ///< When this bit is set the MTL reads a frame from the Rx FIFO only after the complete frame has been written to it.
        constexpr uint32_t DIS_DROP_TCPIP_ERR_FRAM = (1U << 26);  ///< When this bit is set the MAC does not drop the frames which only have errors detected by the Receive Checksum engine.When this bit is reset all error frames are dropped if the Fwd_Err_Frame bit is reset.
    }

    /// DMAIN_EN Register bits
    namespace dmain_en_bits {
        constexpr uint32_t DMAIN_TIE = (1U << 0);  ///< When this bit is set with Normal Interrupt Summary Enable (Bit[16]) the Transmit Interrupt is enabled. When this bit is reset the Transmit Interrupt is disabled.
        constexpr uint32_t DMAIN_TSE = (1U << 1);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Transmission Stopped Interrupt is enabled. When this bit is reset the Transmission Stopped Interrupt is disabled.
        constexpr uint32_t DMAIN_TBUE = (1U << 2);  ///< When this bit is set with Normal Interrupt Summary Enable (Bit 16) the Transmit Buffer Unavailable Interrupt is enabled. When this bit is reset the Transmit Buffer Unavailable Interrupt is Disabled.
        constexpr uint32_t DMAIN_TJTE = (1U << 3);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Transmit Jabber Timeout Interrupt is enabled. When this bit is reset the Transmit Jabber Timeout Interrupt is disabled.
        constexpr uint32_t DMAIN_OIE = (1U << 4);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Receive Overflow Interrupt is enabled. When this bit is reset the Overflow Interrupt is disabled.
        constexpr uint32_t DMAIN_UIE = (1U << 5);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Transmit Underflow Interrupt is enabled. When this bit is reset the Underflow Interrupt is disabled.
        constexpr uint32_t DMAIN_RIE = (1U << 6);  ///< When this bit is set with Normal Interrupt Summary Enable (Bit[16]) the Receive Interrupt is enabled. When this bit is reset the Receive Interrupt is disabled.
        constexpr uint32_t DMAIN_RBUE = (1U << 7);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Receive Buffer Unavailable Interrupt is enabled. When this bit is reset the Receive Buffer Unavailable Interrupt is disabled.
        constexpr uint32_t DMAIN_RSE = (1U << 8);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Receive Stopped Interrupt is enabled. When this bit is reset the Receive Stopped Interrupt is disabled.
        constexpr uint32_t DMAIN_RWTE = (1U << 9);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Receive Watchdog Timeout Interrupt is enabled. When this bit is reset the Receive Watchdog Timeout Interrupt is disabled.
        constexpr uint32_t DMAIN_ETIE = (1U << 10);  ///< When this bit is set with an Abnormal Interrupt Summary Enable (Bit[15]) the Early Transmit Interrupt is enabled. When this bit is reset the Early Transmit Interrupt is disabled.
        constexpr uint32_t DMAIN_FBEE = (1U << 13);  ///< When this bit is set with Abnormal Interrupt Summary Enable (Bit[15]) the Fatal Bus Error Interrupt is enabled. When this bit is reset the Fatal Bus Error Enable Interrupt is disabled.
        constexpr uint32_t DMAIN_ERIE = (1U << 14);  ///< When this bit is set with Normal Interrupt Summary Enable (Bit[16]) the Early Receive Interrupt is enabled. When this bit is reset the Early Receive Interrupt is disabled.
        constexpr uint32_t DMAIN_AISE = (1U << 15);  ///< When this bit is set abnormal interrupt summary is enabled. When this bit is reset the abnormal interrupt summary is disabled. This bit enables the following interrupts in Status Register: Bit[1]: Transmit Process Stopped. Bit[3]: Transmit Jabber Timeout. Bit[4]: Receive Overflow. Bit[5]: Transmit Underflow. Bit[7]: Receive Buffer Unavailable. Bit[8]: Receive Process Stopped. Bit[9]: Receive Watchdog Timeout. Bit[10]: Early Transmit Interrupt. Bit[13]: Fatal Bus Error.
        constexpr uint32_t DMAIN_NISE = (1U << 16);  ///< When this bit is set normal interrupt summary is enabled. When this bit is reset normal interrupt summary is disabled. This bit enables the following interrupts in Status Register: Bit[0]: Transmit Interrupt. Bit[2]: Transmit Buffer Unavailable. Bit[6]: Receive Interrupt. Bit[14]: Early Receive Interrupt.
    }

    /// DMAMISSEDFR Register bits
    namespace dmamissedfr_bits {
        constexpr uint32_t MISSED_FC = (16 << 0);  ///< This field indicates the number of frames missed by the controller because of the Host Receive Buffer being unavailable. This counter is incremented each time the DMA discards an incoming frame. The counter is cleared when this register is read.
        constexpr uint32_t OVERFLOW_BMFC = (1U << 16);  ///< This bit is set every time Missed Frame Counter (Bits[15:0]) overflows that is the DMA discards an incoming frame because of the Host Receive Buffer being unavailable with the missed frame counter at maximum value. In such a scenario the Missed frame counter is reset to all-zeros and this bit indicates that the rollover happened.
        constexpr uint32_t OVERFLOW_FC = (11 << 17);  ///< This field indicates the number of frames missed by the application. This counter is incremented each time the MTL FIFO overflows. The counter is cleared when this register is read.
        constexpr uint32_t OVERFLOW_BFOC = (1U << 28);  ///< This bit is set every time the Overflow Frame Counter (Bits[27:17]) overflows that is the Rx FIFO overflows with the overflow frame counter at maximum value. In such a scenario the overflow frame counter is reset to all-zeros and this bit indicates that the rollover happened.
    }

    /// DMARINTWDTIMER Register bits
    namespace dmarintwdtimer_bits {
        constexpr uint32_t RIWTC = (8 << 0);  ///< This bit indicates the number of system clock cycles multiplied by 256 for which the watchdog timer is set. The watchdog timer gets triggered with the programmed value after the Rx DMA completes the transfer of a frame for which the RI(RECV_INT) status bit is not set because of the setting in the corresponding descriptor RDES1[31]. When the watchdog timer runs out the RI bit is set and the timer is stopped. The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per RDES1[31] of any received frame.
    }

}

// ============================================================================
// ETH Peripheral
// ============================================================================

namespace eth {
    /// Base addresses
    constexpr uint32_t EMAC_EXT_BASE = 0x3FF69800;
    constexpr uint32_t EMAC_MAC_BASE = 0x3FF6A000;

    /// ETH Register structure
    struct Registers {
        volatile uint32_t EX_CLKOUT_CONF;  ///< Offset: 0x00 - RMII clock divider setting
        volatile uint32_t EX_OSCCLK_CONF;  ///< Offset: 0x04 - RMII clock half and whole divider settings
        volatile uint32_t EX_CLK_CTRL;  ///< Offset: 0x08 - Clock enable and external/internal clock selection
        volatile uint32_t EX_PHYINF_CONF;  ///< Offset: 0x0C - Selection of MII/RMII phy
        volatile uint32_t PD_SEL;  ///< Offset: 0x10 - Ethernet RAM power-down enable
        volatile uint32_t EX_DATE;  ///< Offset: 0xFC - 
    };

    /// Peripheral instances
    inline Registers* EMAC_EXT = reinterpret_cast<Registers*>(EMAC_EXT_BASE);
    inline Registers* EMAC_MAC = reinterpret_cast<Registers*>(EMAC_MAC_BASE);

    // Bit definitions
    /// EX_CLKOUT_CONF Register bits
    namespace ex_clkout_conf_bits {
        constexpr uint32_t DIV_NUM = (4 << 0);  ///< DIV_NUM
        constexpr uint32_t H_DIV_NUM = (4 << 4);  ///< H_DIV_NUM
        constexpr uint32_t DLY_NUM = (2 << 8);  ///< DLY_NUM
    }

    /// EX_OSCCLK_CONF Register bits
    namespace ex_oscclk_conf_bits {
        constexpr uint32_t DIV_NUM_10M = (6 << 0);  ///< DIV_NUM_10M
        constexpr uint32_t H_DIV_NUM_10M = (6 << 6);  ///< H_DIV_NUM_10M
        constexpr uint32_t DIV_NUM_100M = (6 << 12);  ///< DIV_NUM_100M
        constexpr uint32_t H_DIV_NUM_100M = (6 << 18);  ///< H_DIV_NUM_100M
        constexpr uint32_t CLK_SEL = (1U << 24);  ///< CLK_SEL
    }

    /// EX_CLK_CTRL Register bits
    namespace ex_clk_ctrl_bits {
        constexpr uint32_t EXT_EN = (1U << 0);  ///< EXT_EN
        constexpr uint32_t INT_EN = (1U << 1);  ///< INT_EN
        constexpr uint32_t RX_125_CLK_EN = (1U << 2);  ///< RX_125_CLK_EN
        constexpr uint32_t MII_CLK_TX_EN = (1U << 3);  ///< MII_CLK_TX_EN
        constexpr uint32_t MII_CLK_RX_EN = (1U << 4);  ///< MII_CLK_RX_EN
        constexpr uint32_t CLK_EN = (1U << 5);  ///< CLK_EN
    }

    /// EX_PHYINF_CONF Register bits
    namespace ex_phyinf_conf_bits {
        constexpr uint32_t INT_REVMII_RX_CLK_SEL = (1U << 0);  ///< INT_REVMII_RX_CLK_SEL
        constexpr uint32_t EXT_REVMII_RX_CLK_SEL = (1U << 1);  ///< EXT_REVMII_RX_CLK_SEL
        constexpr uint32_t SBD_FLOWCTRL = (1U << 2);  ///< SBD_FLOWCTRL
        constexpr uint32_t CORE_PHY_ADDR = (5 << 3);  ///< CORE_PHY_ADDR
        constexpr uint32_t REVMII_PHY_ADDR = (5 << 8);  ///< REVMII_PHY_ADDR
        constexpr uint32_t PHY_INTF_SEL = (3 << 13);  ///< PHY_INTF_SEL
        constexpr uint32_t SS_MODE = (1U << 16);  ///< SS_MODE
        constexpr uint32_t SBD_CLK_GATING_EN = (1U << 17);  ///< SBD_CLK_GATING_EN
        constexpr uint32_t PMT_CTRL_EN = (1U << 18);  ///< PMT_CTRL_EN
        constexpr uint32_t SCR_SMI_DLY_RX_SYNC = (1U << 19);  ///< SCR_SMI_DLY_RX_SYNC
        constexpr uint32_t TX_ERR_OUT_EN = (1U << 20);  ///< TX_ERR_OUT_EN
    }

    /// PD_SEL Register bits
    namespace pd_sel_bits {
        constexpr uint32_t RAM_PD_EN = (2 << 0);  ///< RAM_PD_EN
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_ENCRYPTION_BASE = 0x3FF46000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BUFFER_%s;  ///< Offset: 0x00 - Data buffers for encryption.
        volatile uint32_t START;  ///< Offset: 0x20 - Set this bit to start encryption operation on data buffer.
        volatile uint32_t ADDRESS;  ///< Offset: 0x24 - The physical address on the off-chip flash must be...
        volatile uint32_t DONE;  ///< Offset: 0x28 - Set this bit when encryption operation is complete.
    };

    /// Peripheral instances
    inline Registers* FLASH_ENCRYPTION = reinterpret_cast<Registers*>(FLASH_ENCRYPTION_BASE);

    // Bit definitions
    /// BUFFER_%s Register bits
    namespace buffer_%s_bits {
        constexpr uint32_t BUFFER = (8 << 0);  ///< Data buffers for encryption.
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t FLASH_START = (8 << 0);  ///< Set this bit to start encryption operation on data buffer.
    }

    /// ADDRESS Register bits
    namespace address_bits {
        constexpr uint32_t ADDRESS = (8 << 0);  ///< The physical address on the off-chip flash must be 8-word boundary aligned.
    }

    /// DONE Register bits
    namespace done_bits {
        constexpr uint32_t FLASH_DONE = (1U << 0);  ///< Set this bit when encryption operation is complete.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t FRC_TIMER_BASE = 0x3FF47000;
    constexpr uint32_t TIMG0_BASE = 0x3FF5F000;
    constexpr uint32_t TIMG1_BASE = 0x3FF60000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIMER_LOAD;  ///< Offset: 0x00 - 
        volatile uint32_t TIMER_COUNT;  ///< Offset: 0x04 - 
        volatile uint32_t TIMER_CTRL;  ///< Offset: 0x08 - 
        volatile uint32_t TIMER_INT;  ///< Offset: 0x0C - 
        volatile uint32_t TIMER_ALARM;  ///< Offset: 0x10 - 
    };

    /// Peripheral instances
    inline Registers* FRC_TIMER = reinterpret_cast<Registers*>(FRC_TIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// TIMER_LOAD Register bits
    namespace timer_load_bits {
        constexpr uint32_t VALUE = (8 << 0);  ///< VALUE
    }

    /// TIMER_COUNT Register bits
    namespace timer_count_bits {
        constexpr uint32_t TIMER_COUNT = (8 << 0);  ///< TIMER_COUNT
    }

    /// TIMER_CTRL Register bits
    namespace timer_ctrl_bits {
        constexpr uint32_t TIMER_PRESCALER = (8 << 1);  ///< TIMER_PRESCALER
    }

    /// TIMER_INT Register bits
    namespace timer_int_bits {
        constexpr uint32_t CLR = (1U << 0);  ///< CLR
    }

    /// TIMER_ALARM Register bits
    namespace timer_alarm_bits {
        constexpr uint32_t TIMER_ALARM = (8 << 0);  ///< TIMER_ALARM
    }

}

// ============================================================================
// HINF Peripheral
// ============================================================================

namespace hinf {
    /// Base addresses
    constexpr uint32_t HINF_BASE = 0x3FF4B000;

    /// HINF Register structure
    struct Registers {
        volatile uint32_t CFG_DATA0;  ///< Offset: 0x00 - 
        volatile uint32_t CFG_DATA1;  ///< Offset: 0x04 - 
        volatile uint32_t CFG_DATA7;  ///< Offset: 0x1C - 
        volatile uint32_t CIS_CONF0;  ///< Offset: 0x20 - 
        volatile uint32_t CIS_CONF1;  ///< Offset: 0x24 - 
        volatile uint32_t CIS_CONF2;  ///< Offset: 0x28 - 
        volatile uint32_t CIS_CONF3;  ///< Offset: 0x2C - 
        volatile uint32_t CIS_CONF4;  ///< Offset: 0x30 - 
        volatile uint32_t CIS_CONF5;  ///< Offset: 0x34 - 
        volatile uint32_t CIS_CONF6;  ///< Offset: 0x38 - 
        volatile uint32_t CIS_CONF7;  ///< Offset: 0x3C - 
        volatile uint32_t CFG_DATA16;  ///< Offset: 0x40 - 
        volatile uint32_t DATE;  ///< Offset: 0xFC - 
    };

    /// Peripheral instances
    inline Registers* HINF = reinterpret_cast<Registers*>(HINF_BASE);

    // Bit definitions
    /// CFG_DATA0 Register bits
    namespace cfg_data0_bits {
        constexpr uint32_t USER_ID_FN1 = (16 << 0);  ///< USER_ID_FN1
        constexpr uint32_t DEVICE_ID_FN1 = (16 << 16);  ///< DEVICE_ID_FN1
    }

    /// CFG_DATA1 Register bits
    namespace cfg_data1_bits {
        constexpr uint32_t SDIO_ENABLE = (1U << 0);  ///< SDIO_ENABLE
        constexpr uint32_t SDIO_IOREADY1 = (1U << 1);  ///< SDIO_IOREADY1
        constexpr uint32_t HIGHSPEED_ENABLE = (1U << 2);  ///< HIGHSPEED_ENABLE
        constexpr uint32_t HIGHSPEED_MODE = (1U << 3);  ///< HIGHSPEED_MODE
        constexpr uint32_t SDIO_CD_ENABLE = (1U << 4);  ///< SDIO_CD_ENABLE
        constexpr uint32_t SDIO_IOREADY2 = (1U << 5);  ///< SDIO_IOREADY2
        constexpr uint32_t SDIO_INT_MASK = (1U << 6);  ///< SDIO_INT_MASK
        constexpr uint32_t IOENABLE2 = (1U << 7);  ///< IOENABLE2
        constexpr uint32_t CD_DISABLE = (1U << 8);  ///< CD_DISABLE
        constexpr uint32_t FUNC1_EPS = (1U << 9);  ///< FUNC1_EPS
        constexpr uint32_t EMP = (1U << 10);  ///< EMP
        constexpr uint32_t IOENABLE1 = (1U << 11);  ///< IOENABLE1
        constexpr uint32_t SDIO20_CONF0 = (4 << 12);  ///< SDIO20_CONF0
        constexpr uint32_t SDIO_VER = (12 << 16);  ///< SDIO_VER
        constexpr uint32_t FUNC2_EPS = (1U << 28);  ///< FUNC2_EPS
        constexpr uint32_t SDIO20_CONF1 = (3 << 29);  ///< SDIO20_CONF1
    }

    /// CFG_DATA7 Register bits
    namespace cfg_data7_bits {
        constexpr uint32_t PIN_STATE = (8 << 0);  ///< PIN_STATE
        constexpr uint32_t CHIP_STATE = (8 << 8);  ///< CHIP_STATE
        constexpr uint32_t SDIO_RST = (1U << 16);  ///< SDIO_RST
        constexpr uint32_t SDIO_IOREADY0 = (1U << 17);  ///< SDIO_IOREADY0
    }

    /// CIS_CONF0 Register bits
    namespace cis_conf0_bits {
        constexpr uint32_t CIS_CONF_W0 = (32 << 0);  ///< CIS_CONF_W0
    }

    /// CIS_CONF1 Register bits
    namespace cis_conf1_bits {
        constexpr uint32_t CIS_CONF_W1 = (32 << 0);  ///< CIS_CONF_W1
    }

    /// CIS_CONF2 Register bits
    namespace cis_conf2_bits {
        constexpr uint32_t CIS_CONF_W2 = (32 << 0);  ///< CIS_CONF_W2
    }

    /// CIS_CONF3 Register bits
    namespace cis_conf3_bits {
        constexpr uint32_t CIS_CONF_W3 = (32 << 0);  ///< CIS_CONF_W3
    }

    /// CIS_CONF4 Register bits
    namespace cis_conf4_bits {
        constexpr uint32_t CIS_CONF_W4 = (32 << 0);  ///< CIS_CONF_W4
    }

    /// CIS_CONF5 Register bits
    namespace cis_conf5_bits {
        constexpr uint32_t CIS_CONF_W5 = (32 << 0);  ///< CIS_CONF_W5
    }

    /// CIS_CONF6 Register bits
    namespace cis_conf6_bits {
        constexpr uint32_t CIS_CONF_W6 = (32 << 0);  ///< CIS_CONF_W6
    }

    /// CIS_CONF7 Register bits
    namespace cis_conf7_bits {
        constexpr uint32_t CIS_CONF_W7 = (32 << 0);  ///< CIS_CONF_W7
    }

    /// CFG_DATA16 Register bits
    namespace cfg_data16_bits {
        constexpr uint32_t USER_ID_FN2 = (16 << 0);  ///< USER_ID_FN2
        constexpr uint32_t DEVICE_ID_FN2 = (16 << 16);  ///< DEVICE_ID_FN2
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t SDIO_DATE = (32 << 0);  ///< SDIO_DATE
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x3FF53000;
    constexpr uint32_t I2C1_BASE = 0x3FF67000;
    constexpr uint32_t RTC_I2C_BASE = 0x3FF48C00;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - This register is used to configure the low level width...
        volatile uint32_t CTR;  ///< Offset: 0x04 - 1: normally ouput sda data 0: exchange the function of...
        volatile uint32_t SR;  ///< Offset: 0x08 - This register stores the value of ACK bit.
        volatile uint32_t TO;  ///< Offset: 0x0C - This register is used to configure the max clock number...
        volatile uint32_t SLAVE_ADDR;  ///< Offset: 0x10 - when configured as i2c slave this register is used to...
        volatile uint32_t RXFIFO_ST;  ///< Offset: 0x14 - This is the offset address of the last receiving data as...
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - Config txfifo empty threhd value when using apb fifo access
        volatile uint32_t DATA;  ///< Offset: 0x1C - The register represent the byte data read from rxfifo...
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - The raw interrupt status bit for rxfifo full when use...
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Set this bit to clear the rxfifo_full_int interrupt.
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - The enable bit for rxfifo_full_int interrupt.
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - The masked interrupt status for rxfifo_full_int interrupt.
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - This register is used to configure the clock num I2C...
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - This register is used to configure the clock num I2C...
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - This register is used to configure the clock num during...
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - This register is used to configure the clock num between...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - This register is used to configure the clock num between...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - This register is used to configure the clock num after...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - This register is used to configure the clock num between...
        volatile uint32_t SCL_FILTER_CFG;  ///< Offset: 0x50 - When input SCL's pulse width is smaller than this...
        volatile uint32_t SDA_FILTER_CFG;  ///< Offset: 0x54 - When input SCL's pulse width is smaller than this...
        volatile uint32_t COMD%s;  ///< Offset: 0x58 - This is the content of command0. It consists of three...
        volatile uint32_t DATE;  ///< Offset: 0xF8 - 
        volatile uint32_t FIFO_START_ADDR;  ///< Offset: 0x100 - 
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* RTC_I2C = reinterpret_cast<Registers*>(RTC_I2C_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (14 << 0);  ///< This register is used to configure the low level width of SCL clock.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 1: normally ouput sda data 0: exchange the function of sda_o and sda_oe (sda_o is the original internal output sda signal sda_oe is the enable bit for the internal output sda signal)
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 1: normally ouput scl clock 0: exchange the function of scl_o and scl_oe (scl_o is the original internal output scl signal scl_oe is the enable bit for the internal output scl signal)
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< Set this bit to sample data in SCL low level. clear this bit to sample data in SCL high level.
        constexpr uint32_t MS_MODE = (1U << 4);  ///< Set this bit to configure the module as i2c master clear this bit to configure the module as i2c slave.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending data in txfifo.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data need to be send. 1: receive data from most significant bit 0: receive data from least significant bit
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received datas. 1: receive data from most significant bit 0: receive data from least significant bit
        constexpr uint32_t CLK_EN = (1U << 8);  ///< This is the clock gating control bit for reading or writing registers.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ACK_REC = (1U << 0);  ///< This register stores the value of ACK bit.
        constexpr uint32_t SLAVE_RW = (1U << 1);  ///< when in slave mode 1: master read slave 0: master write slave.
        constexpr uint32_t TIME_OUT = (1U << 2);  ///< when I2C takes more than time_out_reg clocks to receive a data then this register changes to high level.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< when I2C lost control of SDA line this register changes to high level.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1:I2C bus is busy transferring data. 0:I2C bus is in idle state.
        constexpr uint32_t SLAVE_ADDRESSED = (1U << 5);  ///< when configured as i2c slave and the address send by master is equal to slave's address then this bit will be high level.
        constexpr uint32_t BYTE_TRANS = (1U << 6);  ///< This register changes to high level when one byte is transferred.
        constexpr uint32_t RXFIFO_CNT = (6 << 8);  ///< This register represent the amount of data need to send.
        constexpr uint32_t TXFIFO_CNT = (6 << 18);  ///< This register stores the amount of received data in ram.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This register stores the value of state machine for i2c module. 3'h0: SCL_MAIN_IDLE 3'h1: SCL_ADDRESS_SHIFT 3'h2: SCL_ACK_ADDRESS 3'h3: SCL_RX_DATA 3'h4 SCL_TX_DATA 3'h5:SCL_SEND_ACK 3'h6:SCL_WAIT_ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This register stores the value of state machine to produce SCL. 3'h0: SCL_IDLE 3'h1:SCL_START 3'h2:SCL_LOW_EDGE 3'h3: SCL_LOW 3'h4:SCL_HIGH_EDGE 3'h5:SCL_HIGH 3'h6:SCL_STOP
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT = (20 << 0);  ///< This register is used to configure the max clock number of receiving a data.
    }

    /// SLAVE_ADDR Register bits
    namespace slave_addr_bits {
        constexpr uint32_t SLAVE_ADDR = (15 << 0);  ///< when configured as i2c slave this register is used to configure slave's address.
        constexpr uint32_t ADDR_10BIT_EN = (1U << 31);  ///< This register is used to enable slave 10bit address mode.
    }

    /// RXFIFO_ST Register bits
    namespace rxfifo_st_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (5 << 0);  ///< This is the offset address of the last receiving data as described in nonfifo_rx_thres_register.
        constexpr uint32_t RXFIFO_END_ADDR = (5 << 5);  ///< This is the offset address of the first receiving data as described in nonfifo_rx_thres_register.
        constexpr uint32_t TXFIFO_START_ADDR = (5 << 10);  ///< This is the offset address of the first sending data as described in nonfifo_tx_thres register.
        constexpr uint32_t TXFIFO_END_ADDR = (5 << 15);  ///< This is the offset address of the last sending data as described in nonfifo_tx_thres register.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (5 << 0);  ///< RXFIFO_FULL_THRHD
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (5 << 5);  ///< Config txfifo empty threhd value when using apb fifo access
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enble apb nonfifo access.
        constexpr uint32_t FIFO_ADDR_CFG_EN = (1U << 11);  ///< When this bit is set to 1 then the byte after address represent the offset address of I2C Slave's ram.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset rx fifo when using apb fifo access.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset tx fifo when using apb fifo access.
        constexpr uint32_t NONFIFO_RX_THRES = (6 << 14);  ///< when I2C receives more than nonfifo_rx_thres data it will produce rx_send_full_int_raw interrupt and update the current offset address of the receiving data.
        constexpr uint32_t NONFIFO_TX_THRES = (6 << 20);  ///< when I2C sends more than nonfifo_tx_thres data it will produce tx_send_empty_int_raw interrupt and update the current offset address of the sending data.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The register represent the byte data read from rxfifo when use apb fifo access
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for rxfifo full when use apb fifo access.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for txfifo empty when use apb fifo access.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for receiving data overflow when use apb fifo access.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for end_detect_int interrupt. when I2C deals with the END command it will produce end_detect_int interrupt.
        constexpr uint32_t SLAVE_TRAN_COMP_INT_RAW = (1U << 4);  ///< The raw interrupt status bit for slave_tran_comp_int interrupt. when I2C Slave detectsthe STOP bit it will produce slave_tran_comp_int interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt status bit for arbitration_lost_int interrupt.when I2C lost the usage right of I2C BUS it will produce arbitration_lost_int interrupt.
        constexpr uint32_t MASTER_TRAN_COMP_INT_RAW = (1U << 6);  ///< The raw interrupt status bit for master_tra_comp_int interrupt. when I2C Master sends or receives a byte it will produce master_tran_comp_int interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt status bit for trans_complete_int interrupt. when I2C Master finished STOP command it will produce trans_complete_int interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt status bit for time_out_int interrupt. when I2C takes a lot of time to receive a data it will produce time_out_int interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt status bit for trans_start_int interrupt. when I2C sends the START bit it will produce trans_start_int interrupt.
        constexpr uint32_t ACK_ERR_INT_RAW = (1U << 10);  ///< The raw interrupt status bit for ack_err_int interrupt. when I2C receives a wrong ACK bit it will produce ack_err_int interrupt..
        constexpr uint32_t RX_REC_FULL_INT_RAW = (1U << 11);  ///< The raw interrupt status bit for rx_rec_full_int interrupt. when I2C receives more data than nonfifo_rx_thres it will produce rx_rec_full_int interrupt.
        constexpr uint32_t TX_SEND_EMPTY_INT_RAW = (1U << 12);  ///< The raw interrupt status bit for tx_send_empty_int interrupt.when I2C sends more data than nonfifo_tx_thres it will produce tx_send_empty_int interrupt..
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear the txfifo_empty_int interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear the rxfifo_ovf_int interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the end_detect_int interrupt.
        constexpr uint32_t SLAVE_TRAN_COMP_INT_CLR = (1U << 4);  ///< Set this bit to clear the slave_tran_comp_int interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the arbitration_lost_int interrupt.
        constexpr uint32_t MASTER_TRAN_COMP_INT_CLR = (1U << 6);  ///< Set this bit to clear the master_tran_comp interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the trans_complete_int interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the time_out_int interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the trans_start_int interrupt.
        constexpr uint32_t ACK_ERR_INT_CLR = (1U << 10);  ///< Set this bit to clear the ack_err_int interrupt.
        constexpr uint32_t RX_REC_FULL_INT_CLR = (1U << 11);  ///< Set this bit to clear the rx_rec_full_int interrupt.
        constexpr uint32_t TX_SEND_EMPTY_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_send_empty_int interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< The enable bit for rxfifo_full_int interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< The enable bit for txfifo_empty_int interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The enable bit for rxfifo_ovf_int interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The enable bit for end_detect_int interrupt.
        constexpr uint32_t SLAVE_TRAN_COMP_INT_ENA = (1U << 4);  ///< The enable bit for slave_tran_comp_int interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The enable bit for arbitration_lost_int interrupt.
        constexpr uint32_t MASTER_TRAN_COMP_INT_ENA = (1U << 6);  ///< The enable bit for master_tran_comp_int interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The enable bit for trans_complete_int interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The enable bit for time_out_int interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The enable bit for trans_start_int interrupt.
        constexpr uint32_t ACK_ERR_INT_ENA = (1U << 10);  ///< The enable bit for ack_err_int interrupt.
        constexpr uint32_t RX_REC_FULL_INT_ENA = (1U << 11);  ///< The enable bit for rx_rec_full_int interrupt.
        constexpr uint32_t TX_SEND_EMPTY_INT_ENA = (1U << 12);  ///< The enable bit for tx_send_empty_int interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< The masked interrupt status for rxfifo_full_int interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< The masked interrupt status for txfifo_empty_int interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status for rxfifo_ovf_int interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status for end_detect_int interrupt.
        constexpr uint32_t SLAVE_TRAN_COMP_INT_ST = (1U << 4);  ///< The masked interrupt status for slave_tran_comp_int interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status for arbitration_lost_int interrupt.
        constexpr uint32_t MASTER_TRAN_COMP_INT_ST = (1U << 6);  ///< The masked interrupt status for master_tran_comp_int interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status for trans_complete_int interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status for time_out_int interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status for trans_start_int interrupt.
        constexpr uint32_t ACK_ERR_INT_ST = (1U << 10);  ///< The masked interrupt status for ack_err_int interrupt.
        constexpr uint32_t RX_REC_FULL_INT_ST = (1U << 11);  ///< The masked interrupt status for rx_rec_full_int interrupt.
        constexpr uint32_t TX_SEND_EMPTY_INT_ST = (1U << 12);  ///< The masked interrupt status for tx_send_empty_int interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the clock num I2C used to hold the data after the negedge of SCL.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the clock num I2C used to sample data on SDA after the posedge of SCL
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (14 << 0);  ///< This register is used to configure the clock num during SCL is low level.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the clock num between the negedge of SDA and negedge of SCL for start mark.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the clock num between the posedge of SCL and the negedge of SDA for restart mark.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (14 << 0);  ///< This register is used to configure the clock num after the STOP bit's posedge.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the clock num between the posedge of SCL and the posedge of SDA.
    }

    /// SCL_FILTER_CFG Register bits
    namespace scl_filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (3 << 0);  ///< When input SCL's pulse width is smaller than this register value I2C ignores this pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 3);  ///< This is the filter enable bit for SCL.
    }

    /// SDA_FILTER_CFG Register bits
    namespace sda_filter_cfg_bits {
        constexpr uint32_t SDA_FILTER_THRES = (3 << 0);  ///< When input SCL's pulse width is smaller than this register value I2C ignores this pulse.
        constexpr uint32_t SDA_FILTER_EN = (1U << 3);  ///< This is the filter enable bit for SDA.
    }

    /// COMD%s Register bits
    namespace comd%s_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< This is the content of command0. It consists of three part. op_code is the command 0: RSTART 1: WRITE 2: READ 3: STOP . 4:END. Byte_num represent the number of data need to be send or data need to be received. ack_check_en ack_exp and ack value are used to control the ack bit.
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< When command0 is done in I2C Master mode this bit changes to high level.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x3FF4F000;
    constexpr uint32_t I2S1_BASE = 0x3FF6D000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x08 - 
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - 
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - 
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - 
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - 
        volatile uint32_t TIMING;  ///< Offset: 0x1C - 
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x20 - 
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x24 - 
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x28 - 
        volatile uint32_t CONF_CHAN;  ///< Offset: 0x2C - 
        volatile uint32_t OUT_LINK;  ///< Offset: 0x30 - 
        volatile uint32_t IN_LINK;  ///< Offset: 0x34 - 
        volatile uint32_t OUT_EOF_DES_ADDR;  ///< Offset: 0x38 - 
        volatile uint32_t IN_EOF_DES_ADDR;  ///< Offset: 0x3C - 
        volatile uint32_t OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x40 - 
        volatile uint32_t AHB_TEST;  ///< Offset: 0x44 - 
        volatile uint32_t INLINK_DSCR;  ///< Offset: 0x48 - 
        volatile uint32_t INLINK_DSCR_BF0;  ///< Offset: 0x4C - 
        volatile uint32_t INLINK_DSCR_BF1;  ///< Offset: 0x50 - 
        volatile uint32_t OUTLINK_DSCR;  ///< Offset: 0x54 - 
        volatile uint32_t OUTLINK_DSCR_BF0;  ///< Offset: 0x58 - 
        volatile uint32_t OUTLINK_DSCR_BF1;  ///< Offset: 0x5C - 
        volatile uint32_t LC_CONF;  ///< Offset: 0x60 - 
        volatile uint32_t OUTFIFO_PUSH;  ///< Offset: 0x64 - 
        volatile uint32_t INFIFO_POP;  ///< Offset: 0x68 - 
        volatile uint32_t LC_STATE0;  ///< Offset: 0x6C - 
        volatile uint32_t LC_STATE1;  ///< Offset: 0x70 - 
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x74 - 
        volatile uint32_t CVSD_CONF0;  ///< Offset: 0x80 - 
        volatile uint32_t CVSD_CONF1;  ///< Offset: 0x84 - 
        volatile uint32_t CVSD_CONF2;  ///< Offset: 0x88 - 
        volatile uint32_t PLC_CONF0;  ///< Offset: 0x8C - 
        volatile uint32_t PLC_CONF1;  ///< Offset: 0x90 - 
        volatile uint32_t PLC_CONF2;  ///< Offset: 0x94 - 
        volatile uint32_t ESCO_CONF0;  ///< Offset: 0x98 - 
        volatile uint32_t SCO_CONF0;  ///< Offset: 0x9C - 
        volatile uint32_t CONF1;  ///< Offset: 0xA0 - 
        volatile uint32_t PD_CONF;  ///< Offset: 0xA4 - 
        volatile uint32_t CONF2;  ///< Offset: 0xA8 - 
        volatile uint32_t CLKM_CONF;  ///< Offset: 0xAC - 
        volatile uint32_t SAMPLE_RATE_CONF;  ///< Offset: 0xB0 - 
        volatile uint32_t PDM_CONF;  ///< Offset: 0xB4 - 
        volatile uint32_t PDM_FREQ_CONF;  ///< Offset: 0xB8 - 
        volatile uint32_t STATE;  ///< Offset: 0xBC - 
        volatile uint32_t DATE;  ///< Offset: 0xFC - 
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< TX_RESET
        constexpr uint32_t RX_RESET = (1U << 1);  ///< RX_RESET
        constexpr uint32_t TX_FIFO_RESET = (1U << 2);  ///< TX_FIFO_RESET
        constexpr uint32_t RX_FIFO_RESET = (1U << 3);  ///< RX_FIFO_RESET
        constexpr uint32_t TX_START = (1U << 4);  ///< TX_START
        constexpr uint32_t RX_START = (1U << 5);  ///< RX_START
        constexpr uint32_t TX_SLAVE_MOD = (1U << 6);  ///< TX_SLAVE_MOD
        constexpr uint32_t RX_SLAVE_MOD = (1U << 7);  ///< RX_SLAVE_MOD
        constexpr uint32_t TX_RIGHT_FIRST = (1U << 8);  ///< TX_RIGHT_FIRST
        constexpr uint32_t RX_RIGHT_FIRST = (1U << 9);  ///< RX_RIGHT_FIRST
        constexpr uint32_t TX_MSB_SHIFT = (1U << 10);  ///< TX_MSB_SHIFT
        constexpr uint32_t RX_MSB_SHIFT = (1U << 11);  ///< RX_MSB_SHIFT
        constexpr uint32_t TX_SHORT_SYNC = (1U << 12);  ///< TX_SHORT_SYNC
        constexpr uint32_t RX_SHORT_SYNC = (1U << 13);  ///< RX_SHORT_SYNC
        constexpr uint32_t TX_MONO = (1U << 14);  ///< TX_MONO
        constexpr uint32_t RX_MONO = (1U << 15);  ///< RX_MONO
        constexpr uint32_t TX_MSB_RIGHT = (1U << 16);  ///< TX_MSB_RIGHT
        constexpr uint32_t RX_MSB_RIGHT = (1U << 17);  ///< RX_MSB_RIGHT
        constexpr uint32_t SIG_LOOPBACK = (1U << 18);  ///< SIG_LOOPBACK
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_RAW = (1U << 0);  ///< RX_TAKE_DATA_INT_RAW
        constexpr uint32_t TX_PUT_DATA_INT_RAW = (1U << 1);  ///< TX_PUT_DATA_INT_RAW
        constexpr uint32_t RX_WFULL_INT_RAW = (1U << 2);  ///< RX_WFULL_INT_RAW
        constexpr uint32_t RX_REMPTY_INT_RAW = (1U << 3);  ///< RX_REMPTY_INT_RAW
        constexpr uint32_t TX_WFULL_INT_RAW = (1U << 4);  ///< TX_WFULL_INT_RAW
        constexpr uint32_t TX_REMPTY_INT_RAW = (1U << 5);  ///< TX_REMPTY_INT_RAW
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 6);  ///< RX_HUNG_INT_RAW
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 7);  ///< TX_HUNG_INT_RAW
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 8);  ///< IN_DONE_INT_RAW
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 9);  ///< IN_SUC_EOF_INT_RAW
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 10);  ///< IN_ERR_EOF_INT_RAW
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 11);  ///< OUT_DONE_INT_RAW
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 12);  ///< OUT_EOF_INT_RAW
        constexpr uint32_t IN_DSCR_ERR_INT_RAW = (1U << 13);  ///< IN_DSCR_ERR_INT_RAW
        constexpr uint32_t OUT_DSCR_ERR_INT_RAW = (1U << 14);  ///< OUT_DSCR_ERR_INT_RAW
        constexpr uint32_t IN_DSCR_EMPTY_INT_RAW = (1U << 15);  ///< IN_DSCR_EMPTY_INT_RAW
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 16);  ///< OUT_TOTAL_EOF_INT_RAW
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_ST = (1U << 0);  ///< RX_TAKE_DATA_INT_ST
        constexpr uint32_t TX_PUT_DATA_INT_ST = (1U << 1);  ///< TX_PUT_DATA_INT_ST
        constexpr uint32_t RX_WFULL_INT_ST = (1U << 2);  ///< RX_WFULL_INT_ST
        constexpr uint32_t RX_REMPTY_INT_ST = (1U << 3);  ///< RX_REMPTY_INT_ST
        constexpr uint32_t TX_WFULL_INT_ST = (1U << 4);  ///< TX_WFULL_INT_ST
        constexpr uint32_t TX_REMPTY_INT_ST = (1U << 5);  ///< TX_REMPTY_INT_ST
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 6);  ///< RX_HUNG_INT_ST
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 7);  ///< TX_HUNG_INT_ST
        constexpr uint32_t IN_DONE_INT_ST = (1U << 8);  ///< IN_DONE_INT_ST
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 9);  ///< IN_SUC_EOF_INT_ST
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 10);  ///< IN_ERR_EOF_INT_ST
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 11);  ///< OUT_DONE_INT_ST
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 12);  ///< OUT_EOF_INT_ST
        constexpr uint32_t IN_DSCR_ERR_INT_ST = (1U << 13);  ///< IN_DSCR_ERR_INT_ST
        constexpr uint32_t OUT_DSCR_ERR_INT_ST = (1U << 14);  ///< OUT_DSCR_ERR_INT_ST
        constexpr uint32_t IN_DSCR_EMPTY_INT_ST = (1U << 15);  ///< IN_DSCR_EMPTY_INT_ST
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 16);  ///< OUT_TOTAL_EOF_INT_ST
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_ENA = (1U << 0);  ///< RX_TAKE_DATA_INT_ENA
        constexpr uint32_t TX_PUT_DATA_INT_ENA = (1U << 1);  ///< TX_PUT_DATA_INT_ENA
        constexpr uint32_t RX_WFULL_INT_ENA = (1U << 2);  ///< RX_WFULL_INT_ENA
        constexpr uint32_t RX_REMPTY_INT_ENA = (1U << 3);  ///< RX_REMPTY_INT_ENA
        constexpr uint32_t TX_WFULL_INT_ENA = (1U << 4);  ///< TX_WFULL_INT_ENA
        constexpr uint32_t TX_REMPTY_INT_ENA = (1U << 5);  ///< TX_REMPTY_INT_ENA
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 6);  ///< RX_HUNG_INT_ENA
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 7);  ///< TX_HUNG_INT_ENA
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 8);  ///< IN_DONE_INT_ENA
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 9);  ///< IN_SUC_EOF_INT_ENA
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 10);  ///< IN_ERR_EOF_INT_ENA
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 11);  ///< OUT_DONE_INT_ENA
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 12);  ///< OUT_EOF_INT_ENA
        constexpr uint32_t IN_DSCR_ERR_INT_ENA = (1U << 13);  ///< IN_DSCR_ERR_INT_ENA
        constexpr uint32_t OUT_DSCR_ERR_INT_ENA = (1U << 14);  ///< OUT_DSCR_ERR_INT_ENA
        constexpr uint32_t IN_DSCR_EMPTY_INT_ENA = (1U << 15);  ///< IN_DSCR_EMPTY_INT_ENA
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 16);  ///< OUT_TOTAL_EOF_INT_ENA
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TAKE_DATA_INT_CLR = (1U << 0);  ///< TAKE_DATA_INT_CLR
        constexpr uint32_t PUT_DATA_INT_CLR = (1U << 1);  ///< PUT_DATA_INT_CLR
        constexpr uint32_t RX_WFULL_INT_CLR = (1U << 2);  ///< RX_WFULL_INT_CLR
        constexpr uint32_t RX_REMPTY_INT_CLR = (1U << 3);  ///< RX_REMPTY_INT_CLR
        constexpr uint32_t TX_WFULL_INT_CLR = (1U << 4);  ///< TX_WFULL_INT_CLR
        constexpr uint32_t TX_REMPTY_INT_CLR = (1U << 5);  ///< TX_REMPTY_INT_CLR
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 6);  ///< RX_HUNG_INT_CLR
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 7);  ///< TX_HUNG_INT_CLR
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 8);  ///< IN_DONE_INT_CLR
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 9);  ///< IN_SUC_EOF_INT_CLR
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 10);  ///< IN_ERR_EOF_INT_CLR
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 11);  ///< OUT_DONE_INT_CLR
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 12);  ///< OUT_EOF_INT_CLR
        constexpr uint32_t IN_DSCR_ERR_INT_CLR = (1U << 13);  ///< IN_DSCR_ERR_INT_CLR
        constexpr uint32_t OUT_DSCR_ERR_INT_CLR = (1U << 14);  ///< OUT_DSCR_ERR_INT_CLR
        constexpr uint32_t IN_DSCR_EMPTY_INT_CLR = (1U << 15);  ///< IN_DSCR_EMPTY_INT_CLR
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 16);  ///< OUT_TOTAL_EOF_INT_CLR
    }

    /// TIMING Register bits
    namespace timing_bits {
        constexpr uint32_t TX_BCK_IN_DELAY = (2 << 0);  ///< TX_BCK_IN_DELAY
        constexpr uint32_t TX_WS_IN_DELAY = (2 << 2);  ///< TX_WS_IN_DELAY
        constexpr uint32_t RX_BCK_IN_DELAY = (2 << 4);  ///< RX_BCK_IN_DELAY
        constexpr uint32_t RX_WS_IN_DELAY = (2 << 6);  ///< RX_WS_IN_DELAY
        constexpr uint32_t RX_SD_IN_DELAY = (2 << 8);  ///< RX_SD_IN_DELAY
        constexpr uint32_t TX_BCK_OUT_DELAY = (2 << 10);  ///< TX_BCK_OUT_DELAY
        constexpr uint32_t TX_WS_OUT_DELAY = (2 << 12);  ///< TX_WS_OUT_DELAY
        constexpr uint32_t TX_SD_OUT_DELAY = (2 << 14);  ///< TX_SD_OUT_DELAY
        constexpr uint32_t RX_WS_OUT_DELAY = (2 << 16);  ///< RX_WS_OUT_DELAY
        constexpr uint32_t RX_BCK_OUT_DELAY = (2 << 18);  ///< RX_BCK_OUT_DELAY
        constexpr uint32_t TX_DSYNC_SW = (1U << 20);  ///< TX_DSYNC_SW
        constexpr uint32_t RX_DSYNC_SW = (1U << 21);  ///< RX_DSYNC_SW
        constexpr uint32_t DATA_ENABLE_DELAY = (2 << 22);  ///< DATA_ENABLE_DELAY
        constexpr uint32_t TX_BCK_IN_INV = (1U << 24);  ///< TX_BCK_IN_INV
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RX_DATA_NUM = (6 << 0);  ///< RX_DATA_NUM
        constexpr uint32_t TX_DATA_NUM = (6 << 6);  ///< TX_DATA_NUM
        constexpr uint32_t DSCR_EN = (1U << 12);  ///< DSCR_EN
        constexpr uint32_t TX_FIFO_MOD = (3 << 13);  ///< TX_FIFO_MOD
        constexpr uint32_t RX_FIFO_MOD = (3 << 16);  ///< RX_FIFO_MOD
        constexpr uint32_t TX_FIFO_MOD_FORCE_EN = (1U << 19);  ///< TX_FIFO_MOD_FORCE_EN
        constexpr uint32_t RX_FIFO_MOD_FORCE_EN = (1U << 20);  ///< RX_FIFO_MOD_FORCE_EN
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (32 << 0);  ///< RX_EOF_NUM
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SIGLE_DATA = (32 << 0);  ///< SIGLE_DATA
    }

    /// CONF_CHAN Register bits
    namespace conf_chan_bits {
        constexpr uint32_t TX_CHAN_MOD = (3 << 0);  ///< TX_CHAN_MOD
        constexpr uint32_t RX_CHAN_MOD = (2 << 3);  ///< RX_CHAN_MOD
    }

    /// OUT_LINK Register bits
    namespace out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< OUTLINK_ADDR
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< OUTLINK_STOP
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< OUTLINK_START
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< OUTLINK_RESTART
        constexpr uint32_t OUTLINK_PARK = (1U << 31);  ///< OUTLINK_PARK
    }

    /// IN_LINK Register bits
    namespace in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< INLINK_ADDR
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< INLINK_STOP
        constexpr uint32_t INLINK_START = (1U << 29);  ///< INLINK_START
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< INLINK_RESTART
        constexpr uint32_t INLINK_PARK = (1U << 31);  ///< INLINK_PARK
    }

    /// OUT_EOF_DES_ADDR Register bits
    namespace out_eof_des_addr_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< OUT_EOF_DES_ADDR
    }

    /// IN_EOF_DES_ADDR Register bits
    namespace in_eof_des_addr_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< IN_SUC_EOF_DES_ADDR
    }

    /// OUT_EOF_BFR_DES_ADDR Register bits
    namespace out_eof_bfr_des_addr_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< OUT_EOF_BFR_DES_ADDR
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< AHB_TESTMODE
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< AHB_TESTADDR
    }

    /// INLINK_DSCR Register bits
    namespace inlink_dscr_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< INLINK_DSCR
    }

    /// INLINK_DSCR_BF0 Register bits
    namespace inlink_dscr_bf0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< INLINK_DSCR_BF0
    }

    /// INLINK_DSCR_BF1 Register bits
    namespace inlink_dscr_bf1_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< INLINK_DSCR_BF1
    }

    /// OUTLINK_DSCR Register bits
    namespace outlink_dscr_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< OUTLINK_DSCR
    }

    /// OUTLINK_DSCR_BF0 Register bits
    namespace outlink_dscr_bf0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< OUTLINK_DSCR_BF0
    }

    /// OUTLINK_DSCR_BF1 Register bits
    namespace outlink_dscr_bf1_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< OUTLINK_DSCR_BF1
    }

    /// LC_CONF Register bits
    namespace lc_conf_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< IN_RST
        constexpr uint32_t OUT_RST = (1U << 1);  ///< OUT_RST
        constexpr uint32_t AHBM_FIFO_RST = (1U << 2);  ///< AHBM_FIFO_RST
        constexpr uint32_t AHBM_RST = (1U << 3);  ///< AHBM_RST
        constexpr uint32_t OUT_LOOP_TEST = (1U << 4);  ///< OUT_LOOP_TEST
        constexpr uint32_t IN_LOOP_TEST = (1U << 5);  ///< IN_LOOP_TEST
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 6);  ///< OUT_AUTO_WRBACK
        constexpr uint32_t OUT_NO_RESTART_CLR = (1U << 7);  ///< OUT_NO_RESTART_CLR
        constexpr uint32_t OUT_EOF_MODE = (1U << 8);  ///< OUT_EOF_MODE
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 9);  ///< OUTDSCR_BURST_EN
        constexpr uint32_t INDSCR_BURST_EN = (1U << 10);  ///< INDSCR_BURST_EN
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 11);  ///< OUT_DATA_BURST_EN
        constexpr uint32_t CHECK_OWNER = (1U << 12);  ///< CHECK_OWNER
        constexpr uint32_t MEM_TRANS_EN = (1U << 13);  ///< MEM_TRANS_EN
    }

    /// OUTFIFO_PUSH Register bits
    namespace outfifo_push_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< OUTFIFO_WDATA
        constexpr uint32_t OUTFIFO_PUSH = (1U << 16);  ///< OUTFIFO_PUSH
    }

    /// INFIFO_POP Register bits
    namespace infifo_pop_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< INFIFO_RDATA
        constexpr uint32_t INFIFO_POP = (1U << 16);  ///< INFIFO_POP
    }

    /// LC_STATE0 Register bits
    namespace lc_state0_bits {
        constexpr uint32_t LC_STATE0 = (32 << 0);  ///< LC_STATE0
    }

    /// LC_STATE1 Register bits
    namespace lc_state1_bits {
        constexpr uint32_t LC_STATE1 = (32 << 0);  ///< LC_STATE1
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< LC_FIFO_TIMEOUT
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< LC_FIFO_TIMEOUT_SHIFT
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< LC_FIFO_TIMEOUT_ENA
    }

    /// CVSD_CONF0 Register bits
    namespace cvsd_conf0_bits {
        constexpr uint32_t CVSD_Y_MAX = (16 << 0);  ///< CVSD_Y_MAX
        constexpr uint32_t CVSD_Y_MIN = (16 << 16);  ///< CVSD_Y_MIN
    }

    /// CVSD_CONF1 Register bits
    namespace cvsd_conf1_bits {
        constexpr uint32_t CVSD_SIGMA_MAX = (16 << 0);  ///< CVSD_SIGMA_MAX
        constexpr uint32_t CVSD_SIGMA_MIN = (16 << 16);  ///< CVSD_SIGMA_MIN
    }

    /// CVSD_CONF2 Register bits
    namespace cvsd_conf2_bits {
        constexpr uint32_t CVSD_K = (3 << 0);  ///< CVSD_K
        constexpr uint32_t CVSD_J = (3 << 3);  ///< CVSD_J
        constexpr uint32_t CVSD_BETA = (10 << 6);  ///< CVSD_BETA
        constexpr uint32_t CVSD_H = (3 << 16);  ///< CVSD_H
    }

    /// PLC_CONF0 Register bits
    namespace plc_conf0_bits {
        constexpr uint32_t GOOD_PACK_MAX = (6 << 0);  ///< GOOD_PACK_MAX
        constexpr uint32_t N_ERR_SEG = (3 << 6);  ///< N_ERR_SEG
        constexpr uint32_t SHIFT_RATE = (3 << 9);  ///< SHIFT_RATE
        constexpr uint32_t MAX_SLIDE_SAMPLE = (8 << 12);  ///< MAX_SLIDE_SAMPLE
        constexpr uint32_t PACK_LEN_8K = (5 << 20);  ///< PACK_LEN_8K
        constexpr uint32_t N_MIN_ERR = (3 << 25);  ///< N_MIN_ERR
    }

    /// PLC_CONF1 Register bits
    namespace plc_conf1_bits {
        constexpr uint32_t BAD_CEF_ATTEN_PARA = (8 << 0);  ///< BAD_CEF_ATTEN_PARA
        constexpr uint32_t BAD_CEF_ATTEN_PARA_SHIFT = (4 << 8);  ///< BAD_CEF_ATTEN_PARA_SHIFT
        constexpr uint32_t BAD_OLA_WIN2_PARA_SHIFT = (4 << 12);  ///< BAD_OLA_WIN2_PARA_SHIFT
        constexpr uint32_t BAD_OLA_WIN2_PARA = (8 << 16);  ///< BAD_OLA_WIN2_PARA
        constexpr uint32_t SLIDE_WIN_LEN = (8 << 24);  ///< SLIDE_WIN_LEN
    }

    /// PLC_CONF2 Register bits
    namespace plc_conf2_bits {
        constexpr uint32_t CVSD_SEG_MOD = (2 << 0);  ///< CVSD_SEG_MOD
        constexpr uint32_t MIN_PERIOD = (5 << 2);  ///< MIN_PERIOD
    }

    /// ESCO_CONF0 Register bits
    namespace esco_conf0_bits {
        constexpr uint32_t ESCO_EN = (1U << 0);  ///< ESCO_EN
        constexpr uint32_t ESCO_CHAN_MOD = (1U << 1);  ///< ESCO_CHAN_MOD
        constexpr uint32_t ESCO_CVSD_DEC_PACK_ERR = (1U << 2);  ///< ESCO_CVSD_DEC_PACK_ERR
        constexpr uint32_t ESCO_CVSD_PACK_LEN_8K = (5 << 3);  ///< ESCO_CVSD_PACK_LEN_8K
        constexpr uint32_t ESCO_CVSD_INF_EN = (1U << 8);  ///< ESCO_CVSD_INF_EN
        constexpr uint32_t CVSD_DEC_START = (1U << 9);  ///< CVSD_DEC_START
        constexpr uint32_t CVSD_DEC_RESET = (1U << 10);  ///< CVSD_DEC_RESET
        constexpr uint32_t PLC_EN = (1U << 11);  ///< PLC_EN
        constexpr uint32_t PLC2DMA_EN = (1U << 12);  ///< PLC2DMA_EN
    }

    /// SCO_CONF0 Register bits
    namespace sco_conf0_bits {
        constexpr uint32_t SCO_WITH_I2S_EN = (1U << 0);  ///< SCO_WITH_I2S_EN
        constexpr uint32_t SCO_NO_I2S_EN = (1U << 1);  ///< SCO_NO_I2S_EN
        constexpr uint32_t CVSD_ENC_START = (1U << 2);  ///< CVSD_ENC_START
        constexpr uint32_t CVSD_ENC_RESET = (1U << 3);  ///< CVSD_ENC_RESET
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t TX_PCM_CONF = (3 << 0);  ///< TX_PCM_CONF
        constexpr uint32_t TX_PCM_BYPASS = (1U << 3);  ///< TX_PCM_BYPASS
        constexpr uint32_t RX_PCM_CONF = (3 << 4);  ///< RX_PCM_CONF
        constexpr uint32_t RX_PCM_BYPASS = (1U << 7);  ///< RX_PCM_BYPASS
        constexpr uint32_t TX_STOP_EN = (1U << 8);  ///< TX_STOP_EN
        constexpr uint32_t TX_ZEROS_RM_EN = (1U << 9);  ///< TX_ZEROS_RM_EN
    }

    /// PD_CONF Register bits
    namespace pd_conf_bits {
        constexpr uint32_t FIFO_FORCE_PD = (1U << 0);  ///< FIFO_FORCE_PD
        constexpr uint32_t FIFO_FORCE_PU = (1U << 1);  ///< FIFO_FORCE_PU
        constexpr uint32_t PLC_MEM_FORCE_PD = (1U << 2);  ///< PLC_MEM_FORCE_PD
        constexpr uint32_t PLC_MEM_FORCE_PU = (1U << 3);  ///< PLC_MEM_FORCE_PU
    }

    /// CONF2 Register bits
    namespace conf2_bits {
        constexpr uint32_t CAMERA_EN = (1U << 0);  ///< CAMERA_EN
        constexpr uint32_t LCD_TX_WRX2_EN = (1U << 1);  ///< LCD_TX_WRX2_EN
        constexpr uint32_t LCD_TX_SDX2_EN = (1U << 2);  ///< LCD_TX_SDX2_EN
        constexpr uint32_t DATA_ENABLE_TEST_EN = (1U << 3);  ///< DATA_ENABLE_TEST_EN
        constexpr uint32_t DATA_ENABLE = (1U << 4);  ///< DATA_ENABLE
        constexpr uint32_t LCD_EN = (1U << 5);  ///< LCD_EN
        constexpr uint32_t EXT_ADC_START_EN = (1U << 6);  ///< EXT_ADC_START_EN
        constexpr uint32_t INTER_VALID_EN = (1U << 7);  ///< INTER_VALID_EN
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< CLKM_DIV_NUM
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< CLKM_DIV_B
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< CLKM_DIV_A
        constexpr uint32_t CLK_EN = (1U << 20);  ///< CLK_EN
        constexpr uint32_t CLKA_ENA = (1U << 21);  ///< CLKA_ENA
    }

    /// SAMPLE_RATE_CONF Register bits
    namespace sample_rate_conf_bits {
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 0);  ///< TX_BCK_DIV_NUM
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 6);  ///< RX_BCK_DIV_NUM
        constexpr uint32_t TX_BITS_MOD = (6 << 12);  ///< TX_BITS_MOD
        constexpr uint32_t RX_BITS_MOD = (6 << 18);  ///< RX_BITS_MOD
    }

    /// PDM_CONF Register bits
    namespace pdm_conf_bits {
        constexpr uint32_t TX_PDM_EN = (1U << 0);  ///< TX_PDM_EN
        constexpr uint32_t RX_PDM_EN = (1U << 1);  ///< RX_PDM_EN
        constexpr uint32_t PCM2PDM_CONV_EN = (1U << 2);  ///< PCM2PDM_CONV_EN
        constexpr uint32_t PDM2PCM_CONV_EN = (1U << 3);  ///< PDM2PCM_CONV_EN
        constexpr uint32_t TX_PDM_SINC_OSR2 = (4 << 4);  ///< TX_PDM_SINC_OSR2
        constexpr uint32_t TX_PDM_PRESCALE = (8 << 8);  ///< TX_PDM_PRESCALE
        constexpr uint32_t TX_PDM_HP_IN_SHIFT = (2 << 16);  ///< TX_PDM_HP_IN_SHIFT
        constexpr uint32_t TX_PDM_LP_IN_SHIFT = (2 << 18);  ///< TX_PDM_LP_IN_SHIFT
        constexpr uint32_t TX_PDM_SINC_IN_SHIFT = (2 << 20);  ///< TX_PDM_SINC_IN_SHIFT
        constexpr uint32_t TX_PDM_SIGMADELTA_IN_SHIFT = (2 << 22);  ///< TX_PDM_SIGMADELTA_IN_SHIFT
        constexpr uint32_t RX_PDM_SINC_DSR_16_EN = (1U << 24);  ///< RX_PDM_SINC_DSR_16_EN
        constexpr uint32_t TX_PDM_HP_BYPASS = (1U << 25);  ///< TX_PDM_HP_BYPASS
    }

    /// PDM_FREQ_CONF Register bits
    namespace pdm_freq_conf_bits {
        constexpr uint32_t TX_PDM_FS = (10 << 0);  ///< TX_PDM_FS
        constexpr uint32_t TX_PDM_FP = (10 << 10);  ///< TX_PDM_FP
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< TX_IDLE
        constexpr uint32_t TX_FIFO_RESET_BACK = (1U << 1);  ///< TX_FIFO_RESET_BACK
        constexpr uint32_t RX_FIFO_RESET_BACK = (1U << 2);  ///< RX_FIFO_RESET_BACK
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t I2SDATE = (32 << 0);  ///< I2SDATE
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x3FF49000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - If you want to output clock for I2S0 to: CLK_OUT1, then...
        volatile uint32_t GPIO36;  ///< Offset: 0x04 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO37;  ///< Offset: 0x08 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO38;  ///< Offset: 0x0C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO39;  ///< Offset: 0x10 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO34;  ///< Offset: 0x14 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO35;  ///< Offset: 0x18 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO32;  ///< Offset: 0x1C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO33;  ///< Offset: 0x20 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO25;  ///< Offset: 0x24 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO26;  ///< Offset: 0x28 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO27;  ///< Offset: 0x2C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO14;  ///< Offset: 0x30 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO12;  ///< Offset: 0x34 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO13;  ///< Offset: 0x38 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO15;  ///< Offset: 0x3C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO2;  ///< Offset: 0x40 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO0;  ///< Offset: 0x44 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO4;  ///< Offset: 0x48 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO16;  ///< Offset: 0x4C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO17;  ///< Offset: 0x50 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO9;  ///< Offset: 0x54 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO10;  ///< Offset: 0x58 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO11;  ///< Offset: 0x5C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO6;  ///< Offset: 0x60 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO7;  ///< Offset: 0x64 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO8;  ///< Offset: 0x68 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO5;  ///< Offset: 0x6C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO18;  ///< Offset: 0x70 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO19;  ///< Offset: 0x74 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO20;  ///< Offset: 0x78 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO21;  ///< Offset: 0x7C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO22;  ///< Offset: 0x80 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO3;  ///< Offset: 0x84 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO1;  ///< Offset: 0x88 - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO23;  ///< Offset: 0x8C - Output enable of the pad in sleep mode. 1: enable...
        volatile uint32_t GPIO24;  ///< Offset: 0x90 - Output enable of the pad in sleep mode. 1: enable...
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t CLK1 = (4 << 0);  ///< If you want to output clock for I2S0 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0x0; CLK_OUT2, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[11:8] = 0x0. If you want to output clock for I2S1 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0xF; CLK_OUT2, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[11:8] = 0x0.
        constexpr uint32_t CLK2 = (4 << 4);  ///< If you want to output clock for I2S0 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0x0; CLK_OUT2, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[11:8] = 0x0. If you want to output clock for I2S1 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0xF; CLK_OUT2, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[11:8] = 0x0.
        constexpr uint32_t CLK3 = (4 << 8);  ///< If you want to output clock for I2S0 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0x0; CLK_OUT2, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0x0 and PIN_CTRL[11:8] = 0x0. If you want to output clock for I2S1 to: CLK_OUT1, then set PIN_CTRL[3:0] = 0xF; CLK_OUT2, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[7:4] = 0x0; CLK_OUT3, then set PIN_CTRL[3:0] = 0xF and PIN_CTRL[11:8] = 0x0.
    }

    /// GPIO36 Register bits
    namespace gpio36_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO37 Register bits
    namespace gpio37_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO38 Register bits
    namespace gpio38_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO39 Register bits
    namespace gpio39_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO34 Register bits
    namespace gpio34_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO35 Register bits
    namespace gpio35_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO32 Register bits
    namespace gpio32_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO33 Register bits
    namespace gpio33_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO25 Register bits
    namespace gpio25_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO26 Register bits
    namespace gpio26_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO27 Register bits
    namespace gpio27_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO14 Register bits
    namespace gpio14_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO12 Register bits
    namespace gpio12_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO13 Register bits
    namespace gpio13_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO15 Register bits
    namespace gpio15_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO2 Register bits
    namespace gpio2_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO0 Register bits
    namespace gpio0_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO4 Register bits
    namespace gpio4_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO16 Register bits
    namespace gpio16_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO17 Register bits
    namespace gpio17_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO9 Register bits
    namespace gpio9_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO10 Register bits
    namespace gpio10_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO11 Register bits
    namespace gpio11_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO6 Register bits
    namespace gpio6_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO7 Register bits
    namespace gpio7_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO8 Register bits
    namespace gpio8_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO5 Register bits
    namespace gpio5_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO18 Register bits
    namespace gpio18_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO19 Register bits
    namespace gpio19_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO20 Register bits
    namespace gpio20_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO21 Register bits
    namespace gpio21_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO22 Register bits
    namespace gpio22_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO3 Register bits
    namespace gpio3_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO1 Register bits
    namespace gpio1_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO23 Register bits
    namespace gpio23_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

    /// GPIO24 Register bits
    namespace gpio24_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: enable output; 0: disable output.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad during sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. A higher value corresponds with a higher strength.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled, 0: internal pull-down disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull-down circuitry, therefore, their FUN_WPD is always 0.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled. GPIO pins 34-39 are input-only. These pins do not feature an output driver or internal pull- up/pull- down circuitry, therefore, their FUN_WPU is always 0.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. A higher value corresponds with a higher strength. For GPIO34-39, FUN_DRV is always 0. For detailed drive strength, please see note 8 in Table ”Notes on ESP32 Pin Lists”, in ESP32 Datasheet.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select the IO_MUX function for this signal. 0 selects Function 0, 1 selects Function 1, etc.
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x3FF59000;
    constexpr uint32_t MCPWM0_BASE = 0x3FF5E000;
    constexpr uint32_t MCPWM1_BASE = 0x3FF6C000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t HSCH%s_CONF0;  ///< Offset: 0x00 - There are four high speed timers the two bits are used...
        volatile uint32_t HSCH%s_HPOINT;  ///< Offset: 0x04 - The output value changes to high when htimerx(x=[0 3])...
        volatile uint32_t HSCH%s_DUTY;  ///< Offset: 0x08 - This register represents the current duty of the output...
        volatile uint32_t HSCH%s_CONF1;  ///< Offset: 0x0C - This register controls the increase or decrease step...
        volatile uint32_t HSCH%s_DUTY_R;  ///< Offset: 0x10 - This register represents the current duty cycle of the...
        volatile uint32_t LSCH%s_CONF0;  ///< Offset: 0xA0 - There are four low speed timers the two bits are used to...
        volatile uint32_t LSCH%s_HPOINT;  ///< Offset: 0xA4 - The output value changes to high when lstimerx(x=[0 3])...
        volatile uint32_t LSCH%s_DUTY;  ///< Offset: 0xA8 - This register represents the current duty of the output...
        volatile uint32_t LSCH%s_CONF1;  ///< Offset: 0xAC - This register controls the increase or decrease step...
        volatile uint32_t LSCH%s_DUTY_R;  ///< Offset: 0xB0 - This register represents the current duty cycle of the...
        volatile uint32_t HSTIMER%s_CONF;  ///< Offset: 0x140 - This register controls the range of the counter in high...
        volatile uint32_t HSTIMER%s_VALUE;  ///< Offset: 0x144 - software can read this register to get the current...
        volatile uint32_t LSTIMER%s_CONF;  ///< Offset: 0x160 - This register controls the range of the counter in low...
        volatile uint32_t LSTIMER%s_VALUE;  ///< Offset: 0x164 - software can read this register to get the current...
        volatile uint32_t INT_RAW;  ///< Offset: 0x180 - The interrupt raw bit for high speed channel0 counter overflow.
        volatile uint32_t INT_ST;  ///< Offset: 0x184 - The interrupt status bit for high speed channel0 counter...
        volatile uint32_t INT_ENA;  ///< Offset: 0x188 - The interrupt enable bit for high speed channel0 counter...
        volatile uint32_t INT_CLR;  ///< Offset: 0x18C - Set this bit to clear high speed channel0 counter...
        volatile uint32_t CONF;  ///< Offset: 0x190 - This bit is used to set the frequency of slow_clk....
        volatile uint32_t DATE;  ///< Offset: 0x1FC - This register represents the version .
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);
    inline Registers* MCPWM0 = reinterpret_cast<Registers*>(MCPWM0_BASE);
    inline Registers* MCPWM1 = reinterpret_cast<Registers*>(MCPWM1_BASE);

    // Bit definitions
    /// HSCH%s_CONF0 Register bits
    namespace hsch%s_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< There are four high speed timers the two bits are used to select one of them for high speed channel0. 2'b00: seletc hstimer0. 2'b01: select hstimer1. 2'b10: select hstimer2. 2'b11: select hstimer3.
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< This is the output enable control bit for high speed channel0
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when high speed channel0 is off.
    }

    /// HSCH%s_HPOINT Register bits
    namespace hsch%s_hpoint_bits {
        constexpr uint32_t HPOINT = (20 << 0);  ///< The output value changes to high when htimerx(x=[0 3]) selected by high speed channel0 has reached reg_hpoint_hsch0[19:0]
    }

    /// HSCH%s_DUTY Register bits
    namespace hsch%s_duty_bits {
        constexpr uint32_t DUTY = (25 << 0);  ///< This register represents the current duty of the output signal for high speed channel0.
    }

    /// HSCH%s_CONF1 Register bits
    namespace hsch%s_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< This register controls the increase or decrease step scale for high speed channel0.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< This register is used to increase or decrease the duty every reg_duty_cycle_hsch0 cycles for high speed channel0.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< This register is used to control the num of increased or decreased times for high speed channel0.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< This register is used to increase the duty of output signal or decrease the duty of output signal for high speed channel0.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< When reg_duty_num_hsch0 reg_duty_cycle_hsch0 and reg_duty_scale_hsch0 has been configured. these register won't take effect until set reg_duty_start_hsch0. this bit is automatically cleared by hardware.
    }

    /// HSCH%s_DUTY_R Register bits
    namespace hsch%s_duty_r_bits {
        constexpr uint32_t DUTY_R = (25 << 0);  ///< This register represents the current duty cycle of the output signal for high-speed channel %s
    }

    /// LSCH%s_CONF0 Register bits
    namespace lsch%s_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< There are four low speed timers the two bits are used to select one of them for low speed channel0. 2'b00: seletc lstimer0. 2'b01: select lstimer1. 2'b10: select lstimer2. 2'b11: select lstimer3.
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< This is the output enable control bit for low speed channel0.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when low speed channel0 is off.
        constexpr uint32_t PARA_UP = (1U << 4);  ///< This bit is used to update register LEDC_LSCH0_HPOINT and LEDC_LSCH0_DUTY for low speed channel0.
    }

    /// LSCH%s_HPOINT Register bits
    namespace lsch%s_hpoint_bits {
        constexpr uint32_t HPOINT = (20 << 0);  ///< The output value changes to high when lstimerx(x=[0 3]) selected by low speed channel0 has reached reg_hpoint_lsch0[19:0]
    }

    /// LSCH%s_DUTY Register bits
    namespace lsch%s_duty_bits {
        constexpr uint32_t DUTY = (25 << 0);  ///< This register represents the current duty of the output signal for low speed channel0.
    }

    /// LSCH%s_CONF1 Register bits
    namespace lsch%s_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< This register controls the increase or decrease step scale for low speed channel0.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< This register is used to increase or decrease the duty every reg_duty_cycle_lsch0 cycles for low speed channel0.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< This register is used to control the num of increased or decreased times for low speed channel6.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< This register is used to increase the duty of output signal or decrease the duty of output signal for low speed channel6.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< When reg_duty_num_hsch1 reg_duty_cycle_hsch1 and reg_duty_scale_hsch1 has been configured. these register won't take effect until set reg_duty_start_hsch1. this bit is automatically cleared by hardware.
    }

    /// LSCH%s_DUTY_R Register bits
    namespace lsch%s_duty_r_bits {
        constexpr uint32_t DUTY_R = (25 << 0);  ///< This register represents the current duty cycle of the output signal for low-speed channel %s
    }

    /// HSTIMER%s_CONF Register bits
    namespace hstimer%s_conf_bits {
        constexpr uint32_t DUTY_RES = (5 << 0);  ///< This register controls the range of the counter in high speed timer0. the counter range is [0 2**reg_hstimer0_lim] the max bit width for counter is 20.
        constexpr uint32_t DIV_NUM = (18 << 5);  ///< This register is used to configure parameter for divider in high speed timer0 the least significant eight bits represent the decimal part.
        constexpr uint32_t PAUSE = (1U << 23);  ///< This bit is used to pause the counter in high speed timer0
        constexpr uint32_t RST = (1U << 24);  ///< This bit is used to reset high speed timer0 the counter will be 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 25);  ///< This bit is used to choose apb_clk or ref_tick for high speed timer0. 1'b1:apb_clk 0:ref_tick
    }

    /// HSTIMER%s_VALUE Register bits
    namespace hstimer%s_value_bits {
        constexpr uint32_t CNT = (20 << 0);  ///< software can read this register to get the current counter value in high speed timer0
    }

    /// LSTIMER%s_CONF Register bits
    namespace lstimer%s_conf_bits {
        constexpr uint32_t DUTY_RES = (5 << 0);  ///< This register controls the range of the counter in low speed timer0. the counter range is [0 2**reg_lstimer0_lim] the max bit width for counter is 20.
        constexpr uint32_t DIV_NUM = (18 << 5);  ///< This register is used to configure parameter for divider in low speed timer0 the least significant eight bits represent the decimal part.
        constexpr uint32_t PAUSE = (1U << 23);  ///< This bit is used to pause the counter in low speed timer0.
        constexpr uint32_t RST = (1U << 24);  ///< This bit is used to reset low speed timer0 the counter will be 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 25);  ///< This bit is used to choose slow_clk or ref_tick for low speed timer0. 1'b1:slow_clk 0:ref_tick
        constexpr uint32_t PARA_UP = (1U << 26);  ///< Set this bit to update reg_div_num_lstime0 and reg_lstimer0_lim.
    }

    /// LSTIMER%s_VALUE Register bits
    namespace lstimer%s_value_bits {
        constexpr uint32_t CNT = (20 << 0);  ///< software can read this register to get the current counter value in low speed timer0.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t HSTIMER0_OVF_INT_RAW = (1U << 0);  ///< The interrupt raw bit for high speed channel0 counter overflow.
        constexpr uint32_t HSTIMER1_OVF_INT_RAW = (1U << 1);  ///< The interrupt raw bit for high speed channel1 counter overflow.
        constexpr uint32_t HSTIMER2_OVF_INT_RAW = (1U << 2);  ///< The interrupt raw bit for high speed channel2 counter overflow.
        constexpr uint32_t HSTIMER3_OVF_INT_RAW = (1U << 3);  ///< The interrupt raw bit for high speed channel3 counter overflow.
        constexpr uint32_t LSTIMER0_OVF_INT_RAW = (1U << 4);  ///< The interrupt raw bit for low speed channel0 counter overflow.
        constexpr uint32_t LSTIMER1_OVF_INT_RAW = (1U << 5);  ///< The interrupt raw bit for low speed channel1 counter overflow.
        constexpr uint32_t LSTIMER2_OVF_INT_RAW = (1U << 6);  ///< The interrupt raw bit for low speed channel2 counter overflow.
        constexpr uint32_t LSTIMER3_OVF_INT_RAW = (1U << 7);  ///< The interrupt raw bit for low speed channel3 counter overflow.
        constexpr uint32_t DUTY_CHNG_END_HSCH0_INT_RAW = (1U << 8);  ///< The interrupt raw bit for high speed channel 0 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH1_INT_RAW = (1U << 9);  ///< The interrupt raw bit for high speed channel 1 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH2_INT_RAW = (1U << 10);  ///< The interrupt raw bit for high speed channel 2 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH3_INT_RAW = (1U << 11);  ///< The interrupt raw bit for high speed channel 3 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH4_INT_RAW = (1U << 12);  ///< The interrupt raw bit for high speed channel 4 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH5_INT_RAW = (1U << 13);  ///< The interrupt raw bit for high speed channel 5 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH6_INT_RAW = (1U << 14);  ///< The interrupt raw bit for high speed channel 6 duty change done.
        constexpr uint32_t DUTY_CHNG_END_HSCH7_INT_RAW = (1U << 15);  ///< The interrupt raw bit for high speed channel 7 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_RAW = (1U << 16);  ///< The interrupt raw bit for low speed channel 0 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_RAW = (1U << 17);  ///< The interrupt raw bit for low speed channel 1 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_RAW = (1U << 18);  ///< The interrupt raw bit for low speed channel 2 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_RAW = (1U << 19);  ///< The interrupt raw bit for low speed channel 3 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_RAW = (1U << 20);  ///< The interrupt raw bit for low speed channel 4 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_RAW = (1U << 21);  ///< The interrupt raw bit for low speed channel 5 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH6_INT_RAW = (1U << 22);  ///< The interrupt raw bit for low speed channel 6 duty change done.
        constexpr uint32_t DUTY_CHNG_END_LSCH7_INT_RAW = (1U << 23);  ///< The interrupt raw bit for low speed channel 7 duty change done.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t HSTIMER0_OVF_INT_ST = (1U << 0);  ///< The interrupt status bit for high speed channel0 counter overflow event.
        constexpr uint32_t HSTIMER1_OVF_INT_ST = (1U << 1);  ///< The interrupt status bit for high speed channel1 counter overflow event.
        constexpr uint32_t HSTIMER2_OVF_INT_ST = (1U << 2);  ///< The interrupt status bit for high speed channel2 counter overflow event.
        constexpr uint32_t HSTIMER3_OVF_INT_ST = (1U << 3);  ///< The interrupt status bit for high speed channel3 counter overflow event.
        constexpr uint32_t LSTIMER0_OVF_INT_ST = (1U << 4);  ///< The interrupt status bit for low speed channel0 counter overflow event.
        constexpr uint32_t LSTIMER1_OVF_INT_ST = (1U << 5);  ///< The interrupt status bit for low speed channel1 counter overflow event.
        constexpr uint32_t LSTIMER2_OVF_INT_ST = (1U << 6);  ///< The interrupt status bit for low speed channel2 counter overflow event.
        constexpr uint32_t LSTIMER3_OVF_INT_ST = (1U << 7);  ///< The interrupt status bit for low speed channel3 counter overflow event.
        constexpr uint32_t DUTY_CHNG_END_HSCH0_INT_ST = (1U << 8);  ///< The interrupt status bit for high speed channel 0 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH1_INT_ST = (1U << 9);  ///< The interrupt status bit for high speed channel 1 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH2_INT_ST = (1U << 10);  ///< The interrupt status bit for high speed channel 2 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH3_INT_ST = (1U << 11);  ///< The interrupt status bit for high speed channel 3 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH4_INT_ST = (1U << 12);  ///< The interrupt status bit for high speed channel 4 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH5_INT_ST = (1U << 13);  ///< The interrupt status bit for high speed channel 5 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH6_INT_ST = (1U << 14);  ///< The interrupt status bit for high speed channel 6 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_HSCH7_INT_ST = (1U << 15);  ///< The interrupt status bit for high speed channel 7 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_ST = (1U << 16);  ///< The interrupt status bit for low speed channel 0 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_ST = (1U << 17);  ///< The interrupt status bit for low speed channel 1 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_ST = (1U << 18);  ///< The interrupt status bit for low speed channel 2 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_ST = (1U << 19);  ///< The interrupt status bit for low speed channel 3 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_ST = (1U << 20);  ///< The interrupt status bit for low speed channel 4 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_ST = (1U << 21);  ///< The interrupt status bit for low speed channel 5 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH6_INT_ST = (1U << 22);  ///< The interrupt status bit for low speed channel 6 duty change done event.
        constexpr uint32_t DUTY_CHNG_END_LSCH7_INT_ST = (1U << 23);  ///< The interrupt status bit for low speed channel 7 duty change done event
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t HSTIMER0_OVF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for high speed channel0 counter overflow interrupt.
        constexpr uint32_t HSTIMER1_OVF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for high speed channel1 counter overflow interrupt.
        constexpr uint32_t HSTIMER2_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for high speed channel2 counter overflow interrupt.
        constexpr uint32_t HSTIMER3_OVF_INT_ENA = (1U << 3);  ///< The interrupt enable bit for high speed channel3 counter overflow interrupt.
        constexpr uint32_t LSTIMER0_OVF_INT_ENA = (1U << 4);  ///< The interrupt enable bit for low speed channel0 counter overflow interrupt.
        constexpr uint32_t LSTIMER1_OVF_INT_ENA = (1U << 5);  ///< The interrupt enable bit for low speed channel1 counter overflow interrupt.
        constexpr uint32_t LSTIMER2_OVF_INT_ENA = (1U << 6);  ///< The interrupt enable bit for low speed channel2 counter overflow interrupt.
        constexpr uint32_t LSTIMER3_OVF_INT_ENA = (1U << 7);  ///< The interrupt enable bit for low speed channel3 counter overflow interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH0_INT_ENA = (1U << 8);  ///< The interrupt enable bit for high speed channel 0 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH1_INT_ENA = (1U << 9);  ///< The interrupt enable bit for high speed channel 1 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH2_INT_ENA = (1U << 10);  ///< The interrupt enable bit for high speed channel 2 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH3_INT_ENA = (1U << 11);  ///< The interrupt enable bit for high speed channel 3 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH4_INT_ENA = (1U << 12);  ///< The interrupt enable bit for high speed channel 4 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH5_INT_ENA = (1U << 13);  ///< The interrupt enable bit for high speed channel 5 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH6_INT_ENA = (1U << 14);  ///< The interrupt enable bit for high speed channel 6 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH7_INT_ENA = (1U << 15);  ///< The interrupt enable bit for high speed channel 7 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_ENA = (1U << 16);  ///< The interrupt enable bit for low speed channel 0 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_ENA = (1U << 17);  ///< The interrupt enable bit for low speed channel 1 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_ENA = (1U << 18);  ///< The interrupt enable bit for low speed channel 2 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_ENA = (1U << 19);  ///< The interrupt enable bit for low speed channel 3 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_ENA = (1U << 20);  ///< The interrupt enable bit for low speed channel 4 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_ENA = (1U << 21);  ///< The interrupt enable bit for low speed channel 5 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH6_INT_ENA = (1U << 22);  ///< The interrupt enable bit for low speed channel 6 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH7_INT_ENA = (1U << 23);  ///< The interrupt enable bit for low speed channel 7 duty change done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t HSTIMER0_OVF_INT_CLR = (1U << 0);  ///< Set this bit to clear high speed channel0 counter overflow interrupt.
        constexpr uint32_t HSTIMER1_OVF_INT_CLR = (1U << 1);  ///< Set this bit to clear high speed channel1 counter overflow interrupt.
        constexpr uint32_t HSTIMER2_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear high speed channel2 counter overflow interrupt.
        constexpr uint32_t HSTIMER3_OVF_INT_CLR = (1U << 3);  ///< Set this bit to clear high speed channel3 counter overflow interrupt.
        constexpr uint32_t LSTIMER0_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear low speed channel0 counter overflow interrupt.
        constexpr uint32_t LSTIMER1_OVF_INT_CLR = (1U << 5);  ///< Set this bit to clear low speed channel1 counter overflow interrupt.
        constexpr uint32_t LSTIMER2_OVF_INT_CLR = (1U << 6);  ///< Set this bit to clear low speed channel2 counter overflow interrupt.
        constexpr uint32_t LSTIMER3_OVF_INT_CLR = (1U << 7);  ///< Set this bit to clear low speed channel3 counter overflow interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH0_INT_CLR = (1U << 8);  ///< Set this bit to clear high speed channel 0 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH1_INT_CLR = (1U << 9);  ///< Set this bit to clear high speed channel 1 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH2_INT_CLR = (1U << 10);  ///< Set this bit to clear high speed channel 2 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH3_INT_CLR = (1U << 11);  ///< Set this bit to clear high speed channel 3 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH4_INT_CLR = (1U << 12);  ///< Set this bit to clear high speed channel 4 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH5_INT_CLR = (1U << 13);  ///< Set this bit to clear high speed channel 5 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH6_INT_CLR = (1U << 14);  ///< Set this bit to clear high speed channel 6 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_HSCH7_INT_CLR = (1U << 15);  ///< Set this bit to clear high speed channel 7 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_CLR = (1U << 16);  ///< Set this bit to clear low speed channel 0 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_CLR = (1U << 17);  ///< Set this bit to clear low speed channel 1 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_CLR = (1U << 18);  ///< Set this bit to clear low speed channel 2 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_CLR = (1U << 19);  ///< Set this bit to clear low speed channel 3 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_CLR = (1U << 20);  ///< Set this bit to clear low speed channel 4 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_CLR = (1U << 21);  ///< Set this bit to clear low speed channel 5 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH6_INT_CLR = (1U << 22);  ///< Set this bit to clear low speed channel 6 duty change done interrupt.
        constexpr uint32_t DUTY_CHNG_END_LSCH7_INT_CLR = (1U << 23);  ///< Set this bit to clear low speed channel 7 duty change done interrupt.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (1U << 0);  ///< This bit is used to set the frequency of slow_clk. 1'b1:80mhz 1'b0:8mhz
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This register represents the version .
    }

}

// ============================================================================
// NRX Peripheral
// ============================================================================

namespace nrx {
    /// Base addresses
    constexpr uint32_t NRX_BASE = 0x3FF5CC00;

    /// NRX Register structure
    struct Registers {
        volatile uint32_t NRXPD_CTRL;  ///< Offset: 0xD4 - WiFi RX control register
    };

    /// Peripheral instances
    inline Registers* NRX = reinterpret_cast<Registers*>(NRX_BASE);

    // Bit definitions
    /// NRXPD_CTRL Register bits
    namespace nrxpd_ctrl_bits {
        constexpr uint32_t DEMAP_FORCE_PD = (1U << 0);  ///< DEMAP_FORCE_PD
        constexpr uint32_t DEMAP_FORCE_PU = (1U << 1);  ///< DEMAP_FORCE_PU
        constexpr uint32_t VIT_FORCE_PD = (1U << 2);  ///< VIT_FORCE_PD
        constexpr uint32_t VIT_FORCE_PU = (1U << 3);  ///< VIT_FORCE_PU
        constexpr uint32_t RX_ROT_FORCE_PD = (1U << 4);  ///< RX_ROT_FORCE_PD
        constexpr uint32_t RX_ROT_FORCE_PU = (1U << 5);  ///< RX_ROT_FORCE_PU
        constexpr uint32_t CHAN_EST_FORCE_PD = (1U << 6);  ///< CHAN_EST_FORCE_PD
        constexpr uint32_t CHAN_EST_FORCE_PU = (1U << 7);  ///< CHAN_EST_FORCE_PU
    }

}

// ============================================================================
// PCNT Peripheral
// ============================================================================

namespace pcnt {
    /// Base addresses
    constexpr uint32_t PCNT_BASE = 0x3FF57000;

    /// PCNT Register structure
    struct Registers {
        volatile uint32_t U%s_CONF0;  ///< Offset: 0x00 - This register is used to filter pluse whose width is...
        volatile uint32_t U%s_CONF1;  ///< Offset: 0x04 - This register is used to configure thres0 value for unit0.
        volatile uint32_t U%s_CONF2;  ///< Offset: 0x08 - This register is used to configure thr_h_lim value for unit0.
        volatile uint32_t U%s_CNT;  ///< Offset: 0x60 - This register stores the current pulse count value for unit0.
        volatile uint32_t INT_RAW;  ///< Offset: 0x80 - This is the interrupt raw bit for channel0 event.
        volatile uint32_t INT_ST;  ///< Offset: 0x84 - This is the interrupt status bit for channel0 event.
        volatile uint32_t INT_ENA;  ///< Offset: 0x88 - This is the interrupt enable bit for channel0 event.
        volatile uint32_t INT_CLR;  ///< Offset: 0x8C - Set this bit to clear channel0 event interrupt.
        volatile uint32_t U%s_STATUS;  ///< Offset: 0x90 - 
        volatile uint32_t CTRL;  ///< Offset: 0xB0 - Set this bit to clear unit0's counter.
        volatile uint32_t DATE;  ///< Offset: 0xFC - 
    };

    /// Peripheral instances
    inline Registers* PCNT = reinterpret_cast<Registers*>(PCNT_BASE);

    // Bit definitions
    /// U%s_CONF0 Register bits
    namespace u%s_conf0_bits {
        constexpr uint32_t FILTER_THRES = (10 << 0);  ///< This register is used to filter pluse whose width is smaller than this value for unit0.
        constexpr uint32_t FILTER_EN = (1U << 10);  ///< This is the enable bit for filtering input signals for unit0.
        constexpr uint32_t THR_ZERO_EN = (1U << 11);  ///< This is the enable bit for comparing unit0's count with 0 value.
        constexpr uint32_t THR_H_LIM_EN = (1U << 12);  ///< This is the enable bit for comparing unit0's count with thr_h_lim value.
        constexpr uint32_t THR_L_LIM_EN = (1U << 13);  ///< This is the enable bit for comparing unit0's count with thr_l_lim value.
        constexpr uint32_t THR_THRES0_EN = (1U << 14);  ///< This is the enable bit for comparing unit0's count with thres0 value.
        constexpr uint32_t THR_THRES1_EN = (1U << 15);  ///< This is the enable bit for comparing unit0's count with thres1 value .
        constexpr uint32_t CH0_NEG_MODE = (2 << 16);  ///< This register is used to control the mode of channel0's input negedge signal for unit0. 2'd1: increase at the negedge of input signal 2'd2:decrease at the negedge of input signal others:forbidden
        constexpr uint32_t CH0_POS_MODE = (2 << 18);  ///< This register is used to control the mode of channel0's input posedge signal for unit0. 2'd1: increase at the posedge of input signal 2'd2:decrease at the posedge of input signal others:forbidden
        constexpr uint32_t CH0_HCTRL_MODE = (2 << 20);  ///< This register is used to control the mode of channel0's high control signal for unit0. 2'd0:increase when control signal is low 2'd1: decrease when control signal is high others:forbidden
        constexpr uint32_t CH0_LCTRL_MODE = (2 << 22);  ///< This register is used to control the mode of channel0's low control signal for unit0. 2'd0:increase when control signal is low 2'd1: decrease when control signal is high others:forbidden
        constexpr uint32_t CH1_NEG_MODE = (2 << 24);  ///< This register is used to control the mode of channel1's input negedge signal for unit0. 2'd1: increase at the negedge of input signal 2'd2:decrease at the negedge of input signal others:forbidden
        constexpr uint32_t CH1_POS_MODE = (2 << 26);  ///< This register is used to control the mode of channel1's input posedge signal for unit0. 2'd1: increase at the posedge of input signal 2'd2:decrease at the posedge of input signal others:forbidden
        constexpr uint32_t CH1_HCTRL_MODE = (2 << 28);  ///< This register is used to control the mode of channel1's high control signal for unit0. 2'd0:increase when control signal is low 2'd1: decrease when control signal is high others:forbidden
        constexpr uint32_t CH1_LCTRL_MODE = (2 << 30);  ///< This register is used to control the mode of channel1's low control signal for unit0. 2'd0:increase when control signal is low 2'd1: decrease when control signal is high others:forbidden
    }

    /// U%s_CONF1 Register bits
    namespace u%s_conf1_bits {
        constexpr uint32_t CNT_THRES0 = (16 << 0);  ///< This register is used to configure thres0 value for unit0.
        constexpr uint32_t CNT_THRES1 = (16 << 16);  ///< This register is used to configure thres1 value for unit0.
    }

    /// U%s_CONF2 Register bits
    namespace u%s_conf2_bits {
        constexpr uint32_t CNT_H_LIM = (16 << 0);  ///< This register is used to configure thr_h_lim value for unit0.
        constexpr uint32_t CNT_L_LIM = (16 << 16);  ///< This register is used to confiugre thr_l_lim value for unit0.
    }

    /// U%s_CNT Register bits
    namespace u%s_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< This register stores the current pulse count value for unit0.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< This is the interrupt raw bit for channel0 event.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< This is the interrupt raw bit for channel1 event.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< This is the interrupt raw bit for channel2 event.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< This is the interrupt raw bit for channel3 event.
        constexpr uint32_t CNT_THR_EVENT_U4 = (1U << 4);  ///< This is the interrupt raw bit for channel4 event.
        constexpr uint32_t CNT_THR_EVENT_U5 = (1U << 5);  ///< This is the interrupt raw bit for channel5 event.
        constexpr uint32_t CNT_THR_EVENT_U6 = (1U << 6);  ///< This is the interrupt raw bit for channel6 event.
        constexpr uint32_t CNT_THR_EVENT_U7 = (1U << 7);  ///< This is the interrupt raw bit for channel7 event.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< This is the interrupt status bit for channel0 event.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< This is the interrupt status bit for channel1 event.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< This is the interrupt status bit for channel2 event.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< This is the interrupt status bit for channel3 event.
        constexpr uint32_t CNT_THR_EVENT_U4 = (1U << 4);  ///< This is the interrupt status bit for channel4 event.
        constexpr uint32_t CNT_THR_EVENT_U5 = (1U << 5);  ///< This is the interrupt status bit for channel5 event.
        constexpr uint32_t CNT_THR_EVENT_U6 = (1U << 6);  ///< This is the interrupt status bit for channel6 event.
        constexpr uint32_t CNT_THR_EVENT_U7 = (1U << 7);  ///< This is the interrupt status bit for channel7 event.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< This is the interrupt enable bit for channel0 event.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< This is the interrupt enable bit for channel1 event.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< This is the interrupt enable bit for channel2 event.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< This is the interrupt enable bit for channel3 event.
        constexpr uint32_t CNT_THR_EVENT_U4 = (1U << 4);  ///< This is the interrupt enable bit for channel4 event.
        constexpr uint32_t CNT_THR_EVENT_U5 = (1U << 5);  ///< This is the interrupt enable bit for channel5 event.
        constexpr uint32_t CNT_THR_EVENT_U6 = (1U << 6);  ///< This is the interrupt enable bit for channel6 event.
        constexpr uint32_t CNT_THR_EVENT_U7 = (1U << 7);  ///< This is the interrupt enable bit for channel7 event.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< Set this bit to clear channel0 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< Set this bit to clear channel1 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< Set this bit to clear channel2 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< Set this bit to clear channel3 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U4 = (1U << 4);  ///< Set this bit to clear channel4 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U5 = (1U << 5);  ///< Set this bit to clear channel5 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U6 = (1U << 6);  ///< Set this bit to clear channel6 event interrupt.
        constexpr uint32_t CNT_THR_EVENT_U7 = (1U << 7);  ///< Set this bit to clear channel7 event interrupt.
    }

    /// U%s_STATUS Register bits
    namespace u%s_status_bits {
        constexpr uint32_t CORE_STATUS_U0 = (32 << 0);  ///< CORE_STATUS_U0
        constexpr uint32_t ZERO_MODE = (2 << 0);  ///< ZERO_MODE
        constexpr uint32_t THRES1 = (1U << 2);  ///< THRES1
        constexpr uint32_t THRES0 = (1U << 3);  ///< THRES0
        constexpr uint32_t L_LIM = (1U << 4);  ///< L_LIM
        constexpr uint32_t H_LIM = (1U << 5);  ///< H_LIM
        constexpr uint32_t ZERO = (1U << 6);  ///< ZERO
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CNT_RST_U0 = (1U << 0);  ///< Set this bit to clear unit0's counter.
        constexpr uint32_t CNT_PAUSE_U0 = (1U << 1);  ///< Set this bit to pause unit0's counter.
        constexpr uint32_t CNT_RST_U1 = (1U << 2);  ///< Set this bit to clear unit1's counter.
        constexpr uint32_t CNT_PAUSE_U1 = (1U << 3);  ///< Set this bit to pause unit1's counter.
        constexpr uint32_t CNT_RST_U2 = (1U << 4);  ///< Set this bit to clear unit2's counter.
        constexpr uint32_t CNT_PAUSE_U2 = (1U << 5);  ///< Set this bit to pause unit2's counter.
        constexpr uint32_t CNT_RST_U3 = (1U << 6);  ///< Set this bit to clear unit3's counter.
        constexpr uint32_t CNT_PAUSE_U3 = (1U << 7);  ///< Set this bit to pause unit3's counter.
        constexpr uint32_t CNT_RST_U4 = (1U << 8);  ///< Set this bit to clear unit4's counter.
        constexpr uint32_t CNT_PAUSE_U4 = (1U << 9);  ///< Set this bit to pause unit4's counter.
        constexpr uint32_t CNT_RST_U5 = (1U << 10);  ///< Set this bit to clear unit5's counter.
        constexpr uint32_t CNT_PAUSE_U5 = (1U << 11);  ///< Set this bit to pause unit5's counter.
        constexpr uint32_t CNT_RST_U6 = (1U << 12);  ///< Set this bit to clear unit6's counter.
        constexpr uint32_t CNT_PAUSE_U6 = (1U << 13);  ///< Set this bit to pause unit6's counter.
        constexpr uint32_t CNT_RST_U7 = (1U << 14);  ///< Set this bit to clear unit7's counter.
        constexpr uint32_t CNT_PAUSE_U7 = (1U << 15);  ///< Set this bit to pause unit7's counter.
        constexpr uint32_t CLK_EN = (1U << 16);  ///< CLK_EN
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x3FF56000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t CH%sDATA;  ///< Offset: 0x00 - 
        volatile uint32_t CH%sCONF0;  ///< Offset: 0x20 - This register is used to configure the frequency...
        volatile uint32_t CH%sCONF1;  ///< Offset: 0x24 - Set this bit to start sending data for channel0.
        volatile uint32_t CH%sSTATUS;  ///< Offset: 0x60 - The status for channel0
        volatile uint32_t CH%sADDR;  ///< Offset: 0x80 - The ram relative address in channel0 by apb fifo access
        volatile uint32_t INT_RAW;  ///< Offset: 0xA0 - The interrupt raw bit for channel %s turns to high level...
        volatile uint32_t INT_ST;  ///< Offset: 0xA4 - The interrupt state bit for channel %s's...
        volatile uint32_t INT_ENA;  ///< Offset: 0xA8 - Set this bit to enable rmt_ch%s_tx_end_int_st.
        volatile uint32_t INT_CLR;  ///< Offset: 0xAC - Set this bit to clear the rmt_ch%s_rx_end_int_raw..
        volatile uint32_t CH%sCARRIER_DUTY;  ///< Offset: 0xB0 - This register is used to configure carrier wave's low...
        volatile uint32_t CH%s_TX_LIM;  ///< Offset: 0xD0 - When channel0 sends more than reg_rmt_tx_lim_ch0 datas...
        volatile uint32_t APB_CONF;  ///< Offset: 0xF0 - Set this bit to disable apb fifo access
        volatile uint32_t DATE;  ///< Offset: 0xFC - This is the version register.
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// CH%sCONF0 Register bits
    namespace ch%sconf0_bits {
        constexpr uint32_t DIV_CNT = (8 << 0);  ///< This register is used to configure the frequency divider's factor in channel0.
        constexpr uint32_t IDLE_THRES = (16 << 8);  ///< In receive mode when no edge is detected on the input signal for longer than reg_idle_thres_ch0 then the receive process is done.
        constexpr uint32_t MEM_SIZE = (4 << 24);  ///< This register is used to configure the the amount of memory blocks allocated to channel0.
        constexpr uint32_t CARRIER_EN = (1U << 28);  ///< This is the carrier modulation enable control bit for channel0.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 29);  ///< This bit is used to configure the way carrier wave is modulated for channel0.1'b1:transmit on low output level 1'b0:transmit on high output level.
        constexpr uint32_t MEM_PD = (1U << 30);  ///< This bit is used to reduce power consumed by mem. 1:mem is in low power state.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< This bit is used to control clock.when software config RMT internal registers it controls the register clock.
    }

    /// CH%sCONF1 Register bits
    namespace ch%sconf1_bits {
        constexpr uint32_t TX_START = (1U << 0);  ///< Set this bit to start sending data for channel0.
        constexpr uint32_t RX_EN = (1U << 1);  ///< Set this bit to enbale receving data for channel0.
        constexpr uint32_t MEM_WR_RST = (1U << 2);  ///< Set this bit to reset write ram address for channel0 by receiver access.
        constexpr uint32_t MEM_RD_RST = (1U << 3);  ///< Set this bit to reset read ram address for channel0 by transmitter access.
        constexpr uint32_t APB_MEM_RST = (1U << 4);  ///< Set this bit to reset W/R ram address for channel0 by apb fifo access
        constexpr uint32_t MEM_OWNER = (1U << 5);  ///< This is the mark of channel0's ram usage right.1'b1：receiver uses the ram 0：transmitter uses the ram
        constexpr uint32_t TX_CONTI_MODE = (1U << 6);  ///< Set this bit to continue sending from the first data to the last data in channel0 again and again.
        constexpr uint32_t RX_FILTER_EN = (1U << 7);  ///< This is the receive filter enable bit for channel0.
        constexpr uint32_t RX_FILTER_THRES = (8 << 8);  ///< in receive mode channel0 ignore input pulse when the pulse width is smaller then this value.
        constexpr uint32_t REF_CNT_RST = (1U << 16);  ///< This bit is used to reset divider in channel0.
        constexpr uint32_t REF_ALWAYS_ON = (1U << 17);  ///< This bit is used to select base clock. 1'b1:clk_apb 1'b0:clk_ref
        constexpr uint32_t IDLE_OUT_LV = (1U << 18);  ///< This bit configures the output signal's level for channel0 in IDLE state.
        constexpr uint32_t IDLE_OUT_EN = (1U << 19);  ///< This is the output enable control bit for channel0 in IDLE state.
    }

    /// CH%sSTATUS Register bits
    namespace ch%sstatus_bits {
        constexpr uint32_t STATUS = (32 << 0);  ///< The status for channel0
        constexpr uint32_t MEM_WADDR_EX = (10 << 0);  ///< The current memory read address of channel0.
        constexpr uint32_t MEM_RADDR_EX = (10 << 12);  ///< The current memory write address of channel0.
        constexpr uint32_t STATE = (3 << 24);  ///< The channel0 state machine status register.3'h0 : idle, 3'h1 : send, 3'h2 : read memory, 3'h3 : receive, 3'h4 : wait.
        constexpr uint32_t MEM_OWNER_ERR = (1U << 27);  ///< When channel0 is configured for receive mode, this bit will turn to high level if rmt_mem_owner register is not set to 1.
        constexpr uint32_t MEM_FULL = (1U << 28);  ///< The memory full status bit for channel0 turns to high level when mem_waddr_ex is greater than or equal to the configuration range.
        constexpr uint32_t MEM_EMPTY = (1U << 29);  ///< The memory empty status bit for channel0. in acyclic mode, this bit turns to high level when mem_raddr_ex is greater than or equal to the configured range.
        constexpr uint32_t APB_MEM_WR_ERR = (1U << 30);  ///< The apb write memory status bit for channel0 turns to high level when the apb write address exceeds the configuration range.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 31);  ///< The apb read memory status bit for channel0 turns to high level when the apb read address exceeds the configuration range.
    }

    /// CH%sADDR Register bits
    namespace ch%saddr_bits {
        constexpr uint32_t APB_MEM_ADDR = (32 << 0);  ///< The ram relative address in channel0 by apb fifo access
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt raw bit for channel %s turns to high level when the transmit process is done.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< The interrupt raw bit for channel %s turns to high level when the receive process is done.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< The interrupt raw bit for channel %s turns to high level when channle %s detects some errors.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 24);  ///< The interrupt raw bit for channel %s turns to high level when transmitter in channle%s have send datas more than reg_rmt_tx_lim_ch%s after detecting this interrupt software can updata the old datas with new datas.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt state bit for channel %s's mt_ch%s_tx_end_int_raw when mt_ch%s_tx_end_int_ena is set to %s.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< The interrupt state bit for channel %s's rmt_ch%s_rx_end_int_raw when rmt_ch%s_rx_end_int_ena is set to %s.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< The interrupt state bit for channel %s's rmt_ch%s_err_int_raw when rmt_ch%s_err_int_ena is set to %s.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 24);  ///< The interrupt state bit for channel %s's rmt_ch%s_tx_thr_event_int_raw when mt_ch%s_tx_thr_event_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< Set this bit to enable rmt_ch%s_tx_end_int_st.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< Set this bit to enable rmt_ch%s_rx_end_int_st.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< Set this bit to enable rmt_ch%s_err_int_st.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 24);  ///< Set this bit to enable rmt_ch%s_tx_thr_event_int_st.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< Set this bit to clear the rmt_ch%s_rx_end_int_raw..
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< Set this bit to clear the rmt_ch%s_tx_end_int_raw.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< Set this bit to clear the rmt_ch%s_err_int_raw.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 24);  ///< Set this bit to clear the rmt_ch%s_tx_thr_event_int_raw interrupt.
    }

    /// CH%sCARRIER_DUTY Register bits
    namespace ch%scarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW = (16 << 0);  ///< This register is used to configure carrier wave's low level value for channel0.
        constexpr uint32_t CARRIER_HIGH = (16 << 16);  ///< This register is used to configure carrier wave's high level value for channel0.
    }

    /// CH%s_TX_LIM Register bits
    namespace ch%s_tx_lim_bits {
        constexpr uint32_t TX_LIM = (9 << 0);  ///< When channel0 sends more than reg_rmt_tx_lim_ch0 datas then channel0 produce the relative interrupt.
    }

    /// APB_CONF Register bits
    namespace apb_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< Set this bit to disable apb fifo access
        constexpr uint32_t MEM_TX_WRAP_EN = (1U << 1);  ///< when datas need to be send is more than channel's mem can store then set this bit to enable reusage of mem this bit is used together with reg_rmt_tx_lim_chn.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x60035000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x144 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_CNTL_BASE = 0x3FF48000;
    constexpr uint32_t RTC_IO_BASE = 0x3FF48400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t OPTIONS0;  ///< Offset: 0x00 - {reg_sw_stall_appcpu_c1[5:0]...
        volatile uint32_t SLP_TIMER0;  ///< Offset: 0x04 - RTC sleep timer low 32 bits
        volatile uint32_t SLP_TIMER1;  ///< Offset: 0x08 - RTC sleep timer high 16 bits
        volatile uint32_t TIME_UPDATE;  ///< Offset: 0x0C - To indicate the register is updated
        volatile uint32_t TIME0;  ///< Offset: 0x10 - RTC timer low 32 bits
        volatile uint32_t TIME1;  ///< Offset: 0x14 - RTC timer high 16 bits
        volatile uint32_t STATE0;  ///< Offset: 0x18 - touch controller force wake up
        volatile uint32_t TIMER1;  ///< Offset: 0x1C - CPU stall enable bit
        volatile uint32_t TIMER2;  ///< Offset: 0x20 - wait cycles in slow_clk_rtc before ULP-coprocessor /...
        volatile uint32_t TIMER3;  ///< Offset: 0x24 - 
        volatile uint32_t TIMER4;  ///< Offset: 0x28 - 
        volatile uint32_t TIMER5;  ///< Offset: 0x2C - minimal sleep cycles in slow_clk_rtc
        volatile uint32_t ANA_CONF;  ///< Offset: 0x30 - PLLA force power down
        volatile uint32_t RESET_STATE;  ///< Offset: 0x34 - reset cause of PRO CPU
        volatile uint32_t WAKEUP_STATE;  ///< Offset: 0x38 - wakeup cause
        volatile uint32_t INT_ENA;  ///< Offset: 0x3C - enable sleep wakeup interrupt
        volatile uint32_t INT_RAW;  ///< Offset: 0x40 - sleep wakeup interrupt raw
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - sleep wakeup interrupt state
        volatile uint32_t INT_CLR;  ///< Offset: 0x48 - Clear sleep wakeup interrupt state
        volatile uint32_t STORE0;  ///< Offset: 0x4C - 32-bit general purpose retention register
        volatile uint32_t STORE1;  ///< Offset: 0x50 - 32-bit general purpose retention register
        volatile uint32_t STORE2;  ///< Offset: 0x54 - 32-bit general purpose retention register
        volatile uint32_t STORE3;  ///< Offset: 0x58 - 32-bit general purpose retention register
        volatile uint32_t EXT_XTL_CONF;  ///< Offset: 0x5C - 0: power down XTAL at high level 1: power down XTAL at low level
        volatile uint32_t EXT_WAKEUP_CONF;  ///< Offset: 0x60 - 0: external wakeup at low level 1: external wakeup at high level
        volatile uint32_t SLP_REJECT_CONF;  ///< Offset: 0x64 - enable GPIO reject
        volatile uint32_t CPU_PERIOD_CONF;  ///< Offset: 0x68 - CPU sel option
        volatile uint32_t SDIO_ACT_CONF;  ///< Offset: 0x6C - 
        volatile uint32_t CLK_CONF;  ///< Offset: 0x70 - CK8M_D256_OUT divider. 00: div128 01: div256 10: div512...
        volatile uint32_t SDIO_CONF;  ///< Offset: 0x74 - power down SDIO_REG in sleep. Only active when reg_sdio_force = 0
        volatile uint32_t BIAS_CONF;  ///< Offset: 0x78 - DBG_ATTEN
        volatile uint32_t REG;  ///< Offset: 0x7C - N/A
        volatile uint32_t PWC;  ///< Offset: 0x80 - Fast RTC memory force no ISO
        volatile uint32_t DIG_PWC;  ///< Offset: 0x84 - memories in digital core force PD in sleep
        volatile uint32_t DIG_ISO;  ///< Offset: 0x88 - read only register to indicate digital pad auto-hold status
        volatile uint32_t WDTCONFIG0;  ///< Offset: 0x8C - pause WDT in sleep
        volatile uint32_t WDTCONFIG1;  ///< Offset: 0x90 - 
        volatile uint32_t WDTCONFIG2;  ///< Offset: 0x94 - 
        volatile uint32_t WDTCONFIG3;  ///< Offset: 0x98 - 
        volatile uint32_t WDTCONFIG4;  ///< Offset: 0x9C - 
        volatile uint32_t WDTFEED;  ///< Offset: 0xA0 - 
        volatile uint32_t WDTWPROTECT;  ///< Offset: 0xA4 - 
        volatile uint32_t TEST_MUX;  ///< Offset: 0xA8 - ENT_RTC
        volatile uint32_t SW_CPU_STALL;  ///< Offset: 0xAC - {reg_sw_stall_appcpu_c1[5:0]...
        volatile uint32_t STORE4;  ///< Offset: 0xB0 - 32-bit general purpose retention register
        volatile uint32_t STORE5;  ///< Offset: 0xB4 - 32-bit general purpose retention register
        volatile uint32_t STORE6;  ///< Offset: 0xB8 - 32-bit general purpose retention register
        volatile uint32_t STORE7;  ///< Offset: 0xBC - 32-bit general purpose retention register
        volatile uint32_t LOW_POWER_ST;  ///< Offset: 0xC0 - 1 if RTC controller is ready to execute WAKE...
        volatile uint32_t DIAG1;  ///< Offset: 0xC4 - 
        volatile uint32_t HOLD_FORCE;  ///< Offset: 0xC8 - 
        volatile uint32_t EXT_WAKEUP1;  ///< Offset: 0xCC - Bitmap to select RTC pads for ext wakeup1
        volatile uint32_t EXT_WAKEUP1_STATUS;  ///< Offset: 0xD0 - ext wakeup1 status
        volatile uint32_t BROWN_OUT;  ///< Offset: 0xD4 - enable close flash when brown out happens
        volatile uint32_t DATE;  ///< Offset: 0x13C - 
    };

    /// Peripheral instances
    inline Registers* RTC_CNTL = reinterpret_cast<Registers*>(RTC_CNTL_BASE);
    inline Registers* RTC_IO = reinterpret_cast<Registers*>(RTC_IO_BASE);

    // Bit definitions
    /// OPTIONS0 Register bits
    namespace options0_bits {
        constexpr uint32_t SW_STALL_APPCPU_C0 = (2 << 0);  ///< {reg_sw_stall_appcpu_c1[5:0] reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
        constexpr uint32_t SW_STALL_PROCPU_C0 = (2 << 2);  ///< {reg_sw_stall_procpu_c1[5:0] reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall PRO CPU
        constexpr uint32_t SW_APPCPU_RST = (1U << 4);  ///< APP CPU SW reset
        constexpr uint32_t SW_PROCPU_RST = (1U << 5);  ///< PRO CPU SW reset
        constexpr uint32_t BB_I2C_FORCE_PD = (1U << 6);  ///< BB_I2C force power down
        constexpr uint32_t BB_I2C_FORCE_PU = (1U << 7);  ///< BB_I2C force power up
        constexpr uint32_t BBPLL_I2C_FORCE_PD = (1U << 8);  ///< BB_PLL _I2C force power down
        constexpr uint32_t BBPLL_I2C_FORCE_PU = (1U << 9);  ///< BB_PLL_I2C force power up
        constexpr uint32_t BBPLL_FORCE_PD = (1U << 10);  ///< BB_PLL force power down
        constexpr uint32_t BBPLL_FORCE_PU = (1U << 11);  ///< BB_PLL force power up
        constexpr uint32_t XTL_FORCE_PD = (1U << 12);  ///< crystall force power down
        constexpr uint32_t XTL_FORCE_PU = (1U << 13);  ///< crystall force power up
        constexpr uint32_t BIAS_SLEEP_FOLW_8M = (1U << 14);  ///< BIAS_SLEEP follow CK8M
        constexpr uint32_t BIAS_FORCE_SLEEP = (1U << 15);  ///< BIAS_SLEEP force sleep
        constexpr uint32_t BIAS_FORCE_NOSLEEP = (1U << 16);  ///< BIAS_SLEEP force no sleep
        constexpr uint32_t BIAS_I2C_FOLW_8M = (1U << 17);  ///< BIAS_I2C follow CK8M
        constexpr uint32_t BIAS_I2C_FORCE_PD = (1U << 18);  ///< BIAS_I2C force power down
        constexpr uint32_t BIAS_I2C_FORCE_PU = (1U << 19);  ///< BIAS_I2C force power up
        constexpr uint32_t BIAS_CORE_FOLW_8M = (1U << 20);  ///< BIAS_CORE follow CK8M
        constexpr uint32_t BIAS_CORE_FORCE_PD = (1U << 21);  ///< BIAS_CORE force power down
        constexpr uint32_t BIAS_CORE_FORCE_PU = (1U << 22);  ///< BIAS_CORE force power up
        constexpr uint32_t XTL_FORCE_ISO = (1U << 23);  ///< XTL_FORCE_ISO
        constexpr uint32_t PLL_FORCE_ISO = (1U << 24);  ///< PLL_FORCE_ISO
        constexpr uint32_t ANALOG_FORCE_ISO = (1U << 25);  ///< ANALOG_FORCE_ISO
        constexpr uint32_t XTL_FORCE_NOISO = (1U << 26);  ///< XTL_FORCE_NOISO
        constexpr uint32_t PLL_FORCE_NOISO = (1U << 27);  ///< PLL_FORCE_NOISO
        constexpr uint32_t ANALOG_FORCE_NOISO = (1U << 28);  ///< ANALOG_FORCE_NOISO
        constexpr uint32_t DG_WRAP_FORCE_RST = (1U << 29);  ///< digital wrap force reset in deep sleep
        constexpr uint32_t DG_WRAP_FORCE_NORST = (1U << 30);  ///< digital core force no reset in deep sleep
        constexpr uint32_t SW_SYS_RST = (1U << 31);  ///< SW system reset
    }

    /// SLP_TIMER0 Register bits
    namespace slp_timer0_bits {
        constexpr uint32_t SLP_VAL_LO = (32 << 0);  ///< RTC sleep timer low 32 bits
    }

    /// SLP_TIMER1 Register bits
    namespace slp_timer1_bits {
        constexpr uint32_t SLP_VAL_HI = (16 << 0);  ///< RTC sleep timer high 16 bits
        constexpr uint32_t MAIN_TIMER_ALARM_EN = (1U << 16);  ///< timer alarm enable bit
    }

    /// TIME_UPDATE Register bits
    namespace time_update_bits {
        constexpr uint32_t TIME_VALID = (1U << 30);  ///< To indicate the register is updated
        constexpr uint32_t TIME_UPDATE = (1U << 31);  ///< Set 1: to update register with RTC timer
    }

    /// TIME0 Register bits
    namespace time0_bits {
        constexpr uint32_t TIME_LO = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME1 Register bits
    namespace time1_bits {
        constexpr uint32_t TIME_HI = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t TOUCH_WAKEUP_FORCE_EN = (1U << 20);  ///< touch controller force wake up
        constexpr uint32_t ULP_CP_WAKEUP_FORCE_EN = (1U << 21);  ///< ULP-coprocessor force wake up
        constexpr uint32_t APB2RTC_BRIDGE_SEL = (1U << 22);  ///< 1: APB to RTC using bridge 0: APB to RTC using sync
        constexpr uint32_t TOUCH_SLP_TIMER_EN = (1U << 23);  ///< touch timer enable bit
        constexpr uint32_t ULP_CP_SLP_TIMER_EN = (1U << 24);  ///< ULP-coprocessor timer enable bit
        constexpr uint32_t SDIO_ACTIVE_IND = (1U << 28);  ///< SDIO active indication
        constexpr uint32_t SLP_WAKEUP = (1U << 29);  ///< sleep wakeup bit
        constexpr uint32_t SLP_REJECT = (1U << 30);  ///< sleep reject bit
        constexpr uint32_t SLEEP_EN = (1U << 31);  ///< sleep enable bit
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t CPU_STALL_EN = (1U << 0);  ///< CPU stall enable bit
        constexpr uint32_t CPU_STALL_WAIT = (5 << 1);  ///< CPU stall wait cycles in fast_clk_rtc
        constexpr uint32_t CK8M_WAIT = (8 << 6);  ///< CK8M wait cycles in slow_clk_rtc
        constexpr uint32_t XTL_BUF_WAIT = (10 << 14);  ///< XTAL wait cycles in slow_clk_rtc
        constexpr uint32_t PLL_BUF_WAIT = (8 << 24);  ///< PLL wait cycles in slow_clk_rtc
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t ULPCP_TOUCH_START_WAIT = (9 << 15);  ///< wait cycles in slow_clk_rtc before ULP-coprocessor / touch controller start to work
        constexpr uint32_t MIN_TIME_CK8M_OFF = (8 << 24);  ///< minimal cycles in slow_clk_rtc for CK8M in power down state
    }

    /// TIMER3 Register bits
    namespace timer3_bits {
        constexpr uint32_t WIFI_WAIT_TIMER = (9 << 0);  ///< WIFI_WAIT_TIMER
        constexpr uint32_t WIFI_POWERUP_TIMER = (7 << 9);  ///< WIFI_POWERUP_TIMER
        constexpr uint32_t ROM_RAM_WAIT_TIMER = (9 << 16);  ///< ROM_RAM_WAIT_TIMER
        constexpr uint32_t ROM_RAM_POWERUP_TIMER = (7 << 25);  ///< ROM_RAM_POWERUP_TIMER
    }

    /// TIMER4 Register bits
    namespace timer4_bits {
        constexpr uint32_t WAIT_TIMER = (9 << 0);  ///< WAIT_TIMER
        constexpr uint32_t POWERUP_TIMER = (7 << 9);  ///< POWERUP_TIMER
        constexpr uint32_t DG_WRAP_WAIT_TIMER = (9 << 16);  ///< DG_WRAP_WAIT_TIMER
        constexpr uint32_t DG_WRAP_POWERUP_TIMER = (7 << 25);  ///< DG_WRAP_POWERUP_TIMER
    }

    /// TIMER5 Register bits
    namespace timer5_bits {
        constexpr uint32_t ULP_CP_SUBTIMER_PREDIV = (8 << 0);  ///< ULP_CP_SUBTIMER_PREDIV
        constexpr uint32_t MIN_SLP_VAL = (8 << 8);  ///< minimal sleep cycles in slow_clk_rtc
        constexpr uint32_t RTCMEM_WAIT_TIMER = (9 << 16);  ///< RTCMEM_WAIT_TIMER
        constexpr uint32_t RTCMEM_POWERUP_TIMER = (7 << 25);  ///< RTCMEM_POWERUP_TIMER
    }

    /// ANA_CONF Register bits
    namespace ana_conf_bits {
        constexpr uint32_t PLLA_FORCE_PD = (1U << 23);  ///< PLLA force power down
        constexpr uint32_t PLLA_FORCE_PU = (1U << 24);  ///< PLLA force power up
        constexpr uint32_t BBPLL_CAL_SLP_START = (1U << 25);  ///< start BBPLL calibration during sleep
        constexpr uint32_t PVTMON_PU = (1U << 26);  ///< 1: PVTMON power up otherwise power down
        constexpr uint32_t TXRF_I2C_PU = (1U << 27);  ///< 1: TXRF_I2C power up otherwise power down
        constexpr uint32_t RFRX_PBUS_PU = (1U << 28);  ///< 1: RFRX_PBUS power up otherwise power down
        constexpr uint32_t CKGEN_I2C_PU = (1U << 30);  ///< 1: CKGEN_I2C power up otherwise power down
        constexpr uint32_t PLL_I2C_PU = (1U << 31);  ///< 1: PLL_I2C power up otherwise power down
    }

    /// RESET_STATE Register bits
    namespace reset_state_bits {
        constexpr uint32_t RESET_CAUSE_PROCPU = (6 << 0);  ///< reset cause of PRO CPU
        constexpr uint32_t RESET_CAUSE_APPCPU = (6 << 6);  ///< reset cause of APP CPU
        constexpr uint32_t APPCPU_STAT_VECTOR_SEL = (1U << 12);  ///< APP CPU state vector sel
        constexpr uint32_t PROCPU_STAT_VECTOR_SEL = (1U << 13);  ///< PRO CPU state vector sel
    }

    /// WAKEUP_STATE Register bits
    namespace wakeup_state_bits {
        constexpr uint32_t WAKEUP_CAUSE = (11 << 0);  ///< wakeup cause
        constexpr uint32_t WAKEUP_ENA = (11 << 11);  ///< wakeup enable bitmap
        constexpr uint32_t GPIO_WAKEUP_FILTER = (1U << 22);  ///< enable filter for gpio wakeup event
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t SDIO_IDLE_INT_ENA = (1U << 2);  ///< enable SDIO idle interrupt
        constexpr uint32_t WDT_INT_ENA = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t TIME_VALID_INT_ENA = (1U << 4);  ///< enable RTC time valid interrupt
        constexpr uint32_t ULP_CP_INT_ENA = (1U << 5);  ///< enable ULP-coprocessor interrupt
        constexpr uint32_t TOUCH_INT_ENA = (1U << 6);  ///< enable touch interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA = (1U << 7);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA = (1U << 8);  ///< enable RTC main timer interrupt
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t SLP_WAKEUP_INT_RAW = (1U << 0);  ///< sleep wakeup interrupt raw
        constexpr uint32_t SLP_REJECT_INT_RAW = (1U << 1);  ///< sleep reject interrupt raw
        constexpr uint32_t SDIO_IDLE_INT_RAW = (1U << 2);  ///< SDIO idle interrupt raw
        constexpr uint32_t WDT_INT_RAW = (1U << 3);  ///< RTC WDT interrupt raw
        constexpr uint32_t TIME_VALID_INT_RAW = (1U << 4);  ///< RTC time valid interrupt raw
        constexpr uint32_t ULP_CP_INT_RAW = (1U << 5);  ///< ULP-coprocessor interrupt raw
        constexpr uint32_t TOUCH_INT_RAW = (1U << 6);  ///< touch interrupt raw
        constexpr uint32_t BROWN_OUT_INT_RAW = (1U << 7);  ///< brown out interrupt raw
        constexpr uint32_t MAIN_TIMER_INT_RAW = (1U << 8);  ///< RTC main timer interrupt raw
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ST = (1U << 0);  ///< sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_ST = (1U << 1);  ///< sleep reject interrupt state
        constexpr uint32_t SDIO_IDLE_INT_ST = (1U << 2);  ///< SDIO idle interrupt state
        constexpr uint32_t WDT_INT_ST = (1U << 3);  ///< RTC WDT interrupt state
        constexpr uint32_t TIME_VALID_INT_ST = (1U << 4);  ///< RTC time valid interrupt state
        constexpr uint32_t SAR_INT_ST = (1U << 5);  ///< ULP-coprocessor interrupt state
        constexpr uint32_t TOUCH_INT_ST = (1U << 6);  ///< touch interrupt state
        constexpr uint32_t BROWN_OUT_INT_ST = (1U << 7);  ///< brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_ST = (1U << 8);  ///< RTC main timer interrupt state
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t SLP_WAKEUP_INT_CLR = (1U << 0);  ///< Clear sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_CLR = (1U << 1);  ///< Clear sleep reject interrupt state
        constexpr uint32_t SDIO_IDLE_INT_CLR = (1U << 2);  ///< Clear SDIO idle interrupt state
        constexpr uint32_t WDT_INT_CLR = (1U << 3);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t TIME_VALID_INT_CLR = (1U << 4);  ///< Clear RTC time valid interrupt state
        constexpr uint32_t SAR_INT_CLR = (1U << 5);  ///< Clear ULP-coprocessor interrupt state
        constexpr uint32_t TOUCH_INT_CLR = (1U << 6);  ///< Clear touch interrupt state
        constexpr uint32_t BROWN_OUT_INT_CLR = (1U << 7);  ///< Clear brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_CLR = (1U << 8);  ///< Clear RTC main timer interrupt state
    }

    /// STORE0 Register bits
    namespace store0_bits {
        constexpr uint32_t SCRATCH0 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE1 Register bits
    namespace store1_bits {
        constexpr uint32_t SCRATCH1 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE2 Register bits
    namespace store2_bits {
        constexpr uint32_t SCRATCH2 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE3 Register bits
    namespace store3_bits {
        constexpr uint32_t SCRATCH3 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// EXT_XTL_CONF Register bits
    namespace ext_xtl_conf_bits {
        constexpr uint32_t XTL_EXT_CTR_LV = (1U << 30);  ///< 0: power down XTAL at high level 1: power down XTAL at low level
        constexpr uint32_t XTL_EXT_CTR_EN = (1U << 31);  ///< enable control XTAL by external pads
    }

    /// EXT_WAKEUP_CONF Register bits
    namespace ext_wakeup_conf_bits {
        constexpr uint32_t EXT_WAKEUP0_LV = (1U << 30);  ///< 0: external wakeup at low level 1: external wakeup at high level
        constexpr uint32_t EXT_WAKEUP1_LV = (1U << 31);  ///< 0: external wakeup at low level 1: external wakeup at high level
    }

    /// SLP_REJECT_CONF Register bits
    namespace slp_reject_conf_bits {
        constexpr uint32_t GPIO_REJECT_EN = (1U << 24);  ///< enable GPIO reject
        constexpr uint32_t SDIO_REJECT_EN = (1U << 25);  ///< enable SDIO reject
        constexpr uint32_t LIGHT_SLP_REJECT_EN = (1U << 26);  ///< enable reject for light sleep
        constexpr uint32_t DEEP_SLP_REJECT_EN = (1U << 27);  ///< enable reject for deep sleep
        constexpr uint32_t REJECT_CAUSE = (4 << 28);  ///< sleep reject cause
    }

    /// CPU_PERIOD_CONF Register bits
    namespace cpu_period_conf_bits {
        constexpr uint32_t CPUSEL_CONF = (1U << 29);  ///< CPU sel option
        constexpr uint32_t CPUPERIOD_SEL = (2 << 30);  ///< CPU period sel
    }

    /// SDIO_ACT_CONF Register bits
    namespace sdio_act_conf_bits {
        constexpr uint32_t SDIO_ACT_DNUM = (10 << 22);  ///< SDIO_ACT_DNUM
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t CK8M_DIV = (2 << 4);  ///< CK8M_D256_OUT divider. 00: div128 01: div256 10: div512 11: div1024.
        constexpr uint32_t ENB_CK8M = (1U << 6);  ///< disable CK8M and CK8M_D256_OUT
        constexpr uint32_t ENB_CK8M_DIV = (1U << 7);  ///< 1: CK8M_D256_OUT is actually CK8M 0: CK8M_D256_OUT is CK8M divided by 256
        constexpr uint32_t DIG_XTAL32K_EN = (1U << 8);  ///< enable CK_XTAL_32K for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_D256_EN = (1U << 9);  ///< enable CK8M_D256_OUT for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_EN = (1U << 10);  ///< enable CK8M for digital core (no relationship with RTC core)
        constexpr uint32_t CK8M_DFREQ_FORCE = (1U << 11);  ///< CK8M_DFREQ_FORCE
        constexpr uint32_t CK8M_DIV_SEL = (3 << 12);  ///< divider = reg_ck8m_div_sel + 1
        constexpr uint32_t XTAL_FORCE_NOGATING = (1U << 15);  ///< XTAL force no gating during sleep
        constexpr uint32_t CK8M_FORCE_NOGATING = (1U << 16);  ///< CK8M force no gating during sleep
        constexpr uint32_t CK8M_DFREQ = (8 << 17);  ///< CK8M_DFREQ
        constexpr uint32_t CK8M_FORCE_PD = (1U << 25);  ///< CK8M force power down
        constexpr uint32_t CK8M_FORCE_PU = (1U << 26);  ///< CK8M force power up
        constexpr uint32_t SOC_CLK_SEL = (2 << 27);  ///< SOC clock sel. 0: XTAL 1: PLL 2: CK8M 3: APLL
        constexpr uint32_t FAST_CLK_RTC_SEL = (1U << 29);  ///< fast_clk_rtc sel. 0: XTAL div 4 1: CK8M
        constexpr uint32_t ANA_CLK_RTC_SEL = (2 << 30);  ///< slow_clk_rtc sel. 0: SLOW_CK 1: CK_XTAL_32K 2: CK8M_D256_OUT
    }

    /// SDIO_CONF Register bits
    namespace sdio_conf_bits {
        constexpr uint32_t SDIO_PD_EN = (1U << 21);  ///< power down SDIO_REG in sleep. Only active when reg_sdio_force = 0
        constexpr uint32_t SDIO_FORCE = (1U << 22);  ///< 1: use SW option to control SDIO_REG 0: use state machine
        constexpr uint32_t SDIO_TIEH = (1U << 23);  ///< SW option for SDIO_TIEH. Only active when reg_sdio_force = 1
        constexpr uint32_t REG1P8_READY = (1U << 24);  ///< read only register for REG1P8_READY
        constexpr uint32_t DREFL_SDIO = (2 << 25);  ///< SW option for DREFL_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFM_SDIO = (2 << 27);  ///< SW option for DREFM_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFH_SDIO = (2 << 29);  ///< SW option for DREFH_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t XPD_SDIO = (1U << 31);  ///< SW option for XPD_SDIO_REG. Only active when reg_sdio_force = 1
    }

    /// BIAS_CONF Register bits
    namespace bias_conf_bits {
        constexpr uint32_t DBG_ATTEN = (2 << 24);  ///< DBG_ATTEN
        constexpr uint32_t ENB_SCK_XTAL = (1U << 26);  ///< ENB_SCK_XTAL
        constexpr uint32_t INC_HEARTBEAT_REFRESH = (1U << 27);  ///< INC_HEARTBEAT_REFRESH
        constexpr uint32_t DEC_HEARTBEAT_PERIOD = (1U << 28);  ///< DEC_HEARTBEAT_PERIOD
        constexpr uint32_t INC_HEARTBEAT_PERIOD = (1U << 29);  ///< INC_HEARTBEAT_PERIOD
        constexpr uint32_t DEC_HEARTBEAT_WIDTH = (1U << 30);  ///< DEC_HEARTBEAT_WIDTH
        constexpr uint32_t RST_BIAS_I2C = (1U << 31);  ///< RST_BIAS_I2C
    }

    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t SCK_DCAP_FORCE = (1U << 7);  ///< N/A
        constexpr uint32_t DIG_DBIAS_SLP = (3 << 8);  ///< DIG_REG_DBIAS during sleep
        constexpr uint32_t DIG_DBIAS_WAK = (3 << 11);  ///< DIG_REG_DBIAS during wakeup
        constexpr uint32_t SCK_DCAP = (8 << 14);  ///< SCK_DCAP
        constexpr uint32_t DBIAS_SLP = (3 << 22);  ///< RTC_DBIAS during sleep
        constexpr uint32_t DBIAS_WAK = (3 << 25);  ///< RTC_DBIAS during wakeup
        constexpr uint32_t DBOOST_FORCE_PD = (1U << 28);  ///< RTC_DBOOST force power down
        constexpr uint32_t DBOOST_FORCE_PU = (1U << 29);  ///< RTC_DBOOST force power up
        constexpr uint32_t FORCE_PD = (1U << 30);  ///< RTC_REG force power down (for RTC_REG power down means decrease the voltage to 0.8v or lower )
        constexpr uint32_t FORCE_PU = (1U << 31);  ///< RTC_REG force power up
    }

    /// PWC Register bits
    namespace pwc_bits {
        constexpr uint32_t FASTMEM_FORCE_NOISO = (1U << 0);  ///< Fast RTC memory force no ISO
        constexpr uint32_t FASTMEM_FORCE_ISO = (1U << 1);  ///< Fast RTC memory force ISO
        constexpr uint32_t SLOWMEM_FORCE_NOISO = (1U << 2);  ///< RTC memory force no ISO
        constexpr uint32_t SLOWMEM_FORCE_ISO = (1U << 3);  ///< RTC memory force ISO
        constexpr uint32_t FORCE_ISO = (1U << 4);  ///< rtc_peri force ISO
        constexpr uint32_t FORCE_NOISO = (1U << 5);  ///< rtc_peri force no ISO
        constexpr uint32_t FASTMEM_FOLW_CPU = (1U << 6);  ///< 1: Fast RTC memory PD following CPU 0: fast RTC memory PD following RTC state machine
        constexpr uint32_t FASTMEM_FORCE_LPD = (1U << 7);  ///< Fast RTC memory force PD
        constexpr uint32_t FASTMEM_FORCE_LPU = (1U << 8);  ///< Fast RTC memory force no PD
        constexpr uint32_t SLOWMEM_FOLW_CPU = (1U << 9);  ///< 1: RTC memory PD following CPU 0: RTC memory PD following RTC state machine
        constexpr uint32_t SLOWMEM_FORCE_LPD = (1U << 10);  ///< RTC memory force PD
        constexpr uint32_t SLOWMEM_FORCE_LPU = (1U << 11);  ///< RTC memory force no PD
        constexpr uint32_t FASTMEM_FORCE_PD = (1U << 12);  ///< Fast RTC memory force power down
        constexpr uint32_t FASTMEM_FORCE_PU = (1U << 13);  ///< Fast RTC memory force power up
        constexpr uint32_t FASTMEM_PD_EN = (1U << 14);  ///< enable power down fast RTC memory in sleep
        constexpr uint32_t SLOWMEM_FORCE_PD = (1U << 15);  ///< RTC memory force power down
        constexpr uint32_t SLOWMEM_FORCE_PU = (1U << 16);  ///< RTC memory force power up
        constexpr uint32_t SLOWMEM_PD_EN = (1U << 17);  ///< enable power down RTC memory in sleep
        constexpr uint32_t FORCE_PD = (1U << 18);  ///< rtc_peri force power down
        constexpr uint32_t FORCE_PU = (1U << 19);  ///< rtc_peri force power up
        constexpr uint32_t PD_EN = (1U << 20);  ///< enable power down rtc_peri in sleep
    }

    /// DIG_PWC Register bits
    namespace dig_pwc_bits {
        constexpr uint32_t LSLP_MEM_FORCE_PD = (1U << 3);  ///< memories in digital core force PD in sleep
        constexpr uint32_t LSLP_MEM_FORCE_PU = (1U << 4);  ///< memories in digital core force no PD in sleep
        constexpr uint32_t ROM0_FORCE_PD = (1U << 5);  ///< ROM force power down
        constexpr uint32_t ROM0_FORCE_PU = (1U << 6);  ///< ROM force power up
        constexpr uint32_t INTER_RAM0_FORCE_PD = (1U << 7);  ///< internal SRAM 0 force power down
        constexpr uint32_t INTER_RAM0_FORCE_PU = (1U << 8);  ///< internal SRAM 0 force power up
        constexpr uint32_t INTER_RAM1_FORCE_PD = (1U << 9);  ///< internal SRAM 1 force power down
        constexpr uint32_t INTER_RAM1_FORCE_PU = (1U << 10);  ///< internal SRAM 1 force power up
        constexpr uint32_t INTER_RAM2_FORCE_PD = (1U << 11);  ///< internal SRAM 2 force power down
        constexpr uint32_t INTER_RAM2_FORCE_PU = (1U << 12);  ///< internal SRAM 2 force power up
        constexpr uint32_t INTER_RAM3_FORCE_PD = (1U << 13);  ///< internal SRAM 3 force power down
        constexpr uint32_t INTER_RAM3_FORCE_PU = (1U << 14);  ///< internal SRAM 3 force power up
        constexpr uint32_t INTER_RAM4_FORCE_PD = (1U << 15);  ///< internal SRAM 4 force power down
        constexpr uint32_t INTER_RAM4_FORCE_PU = (1U << 16);  ///< internal SRAM 4 force power up
        constexpr uint32_t WIFI_FORCE_PD = (1U << 17);  ///< wifi force power down
        constexpr uint32_t WIFI_FORCE_PU = (1U << 18);  ///< wifi force power up
        constexpr uint32_t DG_WRAP_FORCE_PD = (1U << 19);  ///< digital core force power down
        constexpr uint32_t DG_WRAP_FORCE_PU = (1U << 20);  ///< digital core force power up
        constexpr uint32_t ROM0_PD_EN = (1U << 24);  ///< enable power down ROM in sleep
        constexpr uint32_t INTER_RAM0_PD_EN = (1U << 25);  ///< enable power down internal SRAM 0 in sleep
        constexpr uint32_t INTER_RAM1_PD_EN = (1U << 26);  ///< enable power down internal SRAM 1 in sleep
        constexpr uint32_t INTER_RAM2_PD_EN = (1U << 27);  ///< enable power down internal SRAM 2 in sleep
        constexpr uint32_t INTER_RAM3_PD_EN = (1U << 28);  ///< enable power down internal SRAM 3 in sleep
        constexpr uint32_t INTER_RAM4_PD_EN = (1U << 29);  ///< enable power down internal SRAM 4 in sleep
        constexpr uint32_t WIFI_PD_EN = (1U << 30);  ///< enable power down wifi in sleep
        constexpr uint32_t DG_WRAP_PD_EN = (1U << 31);  ///< enable power down digital core in sleep
    }

    /// DIG_ISO Register bits
    namespace dig_iso_bits {
        constexpr uint32_t FORCE_OFF = (1U << 7);  ///< FORCE_OFF
        constexpr uint32_t FORCE_ON = (1U << 8);  ///< FORCE_ON
        constexpr uint32_t DG_PAD_AUTOHOLD = (1U << 9);  ///< read only register to indicate digital pad auto-hold status
        constexpr uint32_t CLR_DG_PAD_AUTOHOLD = (1U << 10);  ///< wtite only register to clear digital pad auto-hold
        constexpr uint32_t DG_PAD_AUTOHOLD_EN = (1U << 11);  ///< digital pad enable auto-hold
        constexpr uint32_t DG_PAD_FORCE_NOISO = (1U << 12);  ///< digital pad force no ISO
        constexpr uint32_t DG_PAD_FORCE_ISO = (1U << 13);  ///< digital pad force ISO
        constexpr uint32_t DG_PAD_FORCE_UNHOLD = (1U << 14);  ///< digital pad force un-hold
        constexpr uint32_t DG_PAD_FORCE_HOLD = (1U << 15);  ///< digital pad force hold
        constexpr uint32_t ROM0_FORCE_ISO = (1U << 16);  ///< ROM force ISO
        constexpr uint32_t ROM0_FORCE_NOISO = (1U << 17);  ///< ROM force no ISO
        constexpr uint32_t INTER_RAM0_FORCE_ISO = (1U << 18);  ///< internal SRAM 0 force ISO
        constexpr uint32_t INTER_RAM0_FORCE_NOISO = (1U << 19);  ///< internal SRAM 0 force no ISO
        constexpr uint32_t INTER_RAM1_FORCE_ISO = (1U << 20);  ///< internal SRAM 1 force ISO
        constexpr uint32_t INTER_RAM1_FORCE_NOISO = (1U << 21);  ///< internal SRAM 1 force no ISO
        constexpr uint32_t INTER_RAM2_FORCE_ISO = (1U << 22);  ///< internal SRAM 2 force ISO
        constexpr uint32_t INTER_RAM2_FORCE_NOISO = (1U << 23);  ///< internal SRAM 2 force no ISO
        constexpr uint32_t INTER_RAM3_FORCE_ISO = (1U << 24);  ///< internal SRAM 3 force ISO
        constexpr uint32_t INTER_RAM3_FORCE_NOISO = (1U << 25);  ///< internal SRAM 3 force no ISO
        constexpr uint32_t INTER_RAM4_FORCE_ISO = (1U << 26);  ///< internal SRAM 4 force ISO
        constexpr uint32_t INTER_RAM4_FORCE_NOISO = (1U << 27);  ///< internal SRAM 4 force no ISO
        constexpr uint32_t WIFI_FORCE_ISO = (1U << 28);  ///< wifi force ISO
        constexpr uint32_t WIFI_FORCE_NOISO = (1U << 29);  ///< wifi force no ISO
        constexpr uint32_t DG_WRAP_FORCE_ISO = (1U << 30);  ///< digital core force ISO
        constexpr uint32_t DG_WRAP_FORCE_NOISO = (1U << 31);  ///< digital core force no ISO
    }

    /// WDTCONFIG0 Register bits
    namespace wdtconfig0_bits {
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 7);  ///< pause WDT in sleep
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 8);  ///< enable WDT reset APP CPU
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 9);  ///< enable WDT reset PRO CPU
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 10);  ///< enable WDT in flash boot
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 11);  ///< system reset counter length
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 14);  ///< CPU reset counter length
        constexpr uint32_t WDT_LEVEL_INT_EN = (1U << 17);  ///< N/A
        constexpr uint32_t WDT_EDGE_INT_EN = (1U << 18);  ///< N/A
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_EN = (1U << 31);  ///< enable RTC WDT
    }

    /// WDTCONFIG1 Register bits
    namespace wdtconfig1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< WDT_STG0_HOLD
    }

    /// WDTCONFIG2 Register bits
    namespace wdtconfig2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< WDT_STG1_HOLD
    }

    /// WDTCONFIG3 Register bits
    namespace wdtconfig3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< WDT_STG2_HOLD
    }

    /// WDTCONFIG4 Register bits
    namespace wdtconfig4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< WDT_STG3_HOLD
    }

    /// WDTFEED Register bits
    namespace wdtfeed_bits {
        constexpr uint32_t WDT_FEED = (1U << 31);  ///< WDT_FEED
    }

    /// WDTWPROTECT Register bits
    namespace wdtwprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< WDT_WKEY
    }

    /// TEST_MUX Register bits
    namespace test_mux_bits {
        constexpr uint32_t ENT_RTC = (1U << 29);  ///< ENT_RTC
        constexpr uint32_t DTEST_RTC = (2 << 30);  ///< DTEST_RTC
    }

    /// SW_CPU_STALL Register bits
    namespace sw_cpu_stall_bits {
        constexpr uint32_t SW_STALL_APPCPU_C1 = (6 << 20);  ///< {reg_sw_stall_appcpu_c1[5:0] reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
        constexpr uint32_t SW_STALL_PROCPU_C1 = (6 << 26);  ///< {reg_sw_stall_procpu_c1[5:0] reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall PRO CPU
    }

    /// STORE4 Register bits
    namespace store4_bits {
        constexpr uint32_t SCRATCH4 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE5 Register bits
    namespace store5_bits {
        constexpr uint32_t SCRATCH5 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE6 Register bits
    namespace store6_bits {
        constexpr uint32_t SCRATCH6 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// STORE7 Register bits
    namespace store7_bits {
        constexpr uint32_t SCRATCH7 = (32 << 0);  ///< 32-bit general purpose retention register
    }

    /// LOW_POWER_ST Register bits
    namespace low_power_st_bits {
        constexpr uint32_t LOW_POWER_DIAG0 = (32 << 0);  ///< LOW_POWER_DIAG0
        constexpr uint32_t RDY_FOR_WAKEUP = (1U << 19);  ///< 1 if RTC controller is ready to execute WAKE instruction, 0 otherwise
    }

    /// DIAG1 Register bits
    namespace diag1_bits {
        constexpr uint32_t LOW_POWER_DIAG1 = (32 << 0);  ///< LOW_POWER_DIAG1
    }

    /// HOLD_FORCE Register bits
    namespace hold_force_bits {
        constexpr uint32_t ADC1_HOLD_FORCE = (1U << 0);  ///< ADC1_HOLD_FORCE
        constexpr uint32_t ADC2_HOLD_FORCE = (1U << 1);  ///< ADC2_HOLD_FORCE
        constexpr uint32_t PDAC1_HOLD_FORCE = (1U << 2);  ///< PDAC1_HOLD_FORCE
        constexpr uint32_t PDAC2_HOLD_FORCE = (1U << 3);  ///< PDAC2_HOLD_FORCE
        constexpr uint32_t SENSE1_HOLD_FORCE = (1U << 4);  ///< SENSE1_HOLD_FORCE
        constexpr uint32_t SENSE2_HOLD_FORCE = (1U << 5);  ///< SENSE2_HOLD_FORCE
        constexpr uint32_t SENSE3_HOLD_FORCE = (1U << 6);  ///< SENSE3_HOLD_FORCE
        constexpr uint32_t SENSE4_HOLD_FORCE = (1U << 7);  ///< SENSE4_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD0_HOLD_FORCE = (1U << 8);  ///< TOUCH_PAD0_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD1_HOLD_FORCE = (1U << 9);  ///< TOUCH_PAD1_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD2_HOLD_FORCE = (1U << 10);  ///< TOUCH_PAD2_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD3_HOLD_FORCE = (1U << 11);  ///< TOUCH_PAD3_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD4_HOLD_FORCE = (1U << 12);  ///< TOUCH_PAD4_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD5_HOLD_FORCE = (1U << 13);  ///< TOUCH_PAD5_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD6_HOLD_FORCE = (1U << 14);  ///< TOUCH_PAD6_HOLD_FORCE
        constexpr uint32_t TOUCH_PAD7_HOLD_FORCE = (1U << 15);  ///< TOUCH_PAD7_HOLD_FORCE
        constexpr uint32_t X32P_HOLD_FORCE = (1U << 16);  ///< X32P_HOLD_FORCE
        constexpr uint32_t X32N_HOLD_FORCE = (1U << 17);  ///< X32N_HOLD_FORCE
    }

    /// EXT_WAKEUP1 Register bits
    namespace ext_wakeup1_bits {
        constexpr uint32_t SEL = (18 << 0);  ///< Bitmap to select RTC pads for ext wakeup1
        constexpr uint32_t STATUS_CLR = (1U << 18);  ///< clear ext wakeup1 status
    }

    /// EXT_WAKEUP1_STATUS Register bits
    namespace ext_wakeup1_status_bits {
        constexpr uint32_t EXT_WAKEUP1_STATUS = (18 << 0);  ///< ext wakeup1 status
    }

    /// BROWN_OUT Register bits
    namespace brown_out_bits {
        constexpr uint32_t RTC_MEM_PID_CONF = (8 << 0);  ///< RTC_MEM_PID_CONF
        constexpr uint32_t RTC_MEM_CRC_START = (1U << 8);  ///< RTC_MEM_CRC_START
        constexpr uint32_t RTC_MEM_CRC_ADDR = (11 << 9);  ///< RTC_MEM_CRC_ADDR
        constexpr uint32_t CLOSE_FLASH_ENA = (1U << 14);  ///< enable close flash when brown out happens
        constexpr uint32_t PD_RF_ENA = (1U << 15);  ///< enable power down RF when brown out happens
        constexpr uint32_t RST_WAIT = (10 << 16);  ///< brown out reset wait cycles
        constexpr uint32_t RTC_MEM_CRC_LEN = (11 << 20);  ///< RTC_MEM_CRC_LEN
        constexpr uint32_t RST_ENA = (1U << 26);  ///< enable brown out reset
        constexpr uint32_t DBROWN_OUT_THRES = (3 << 27);  ///< brown out threshold
        constexpr uint32_t ENA = (1U << 30);  ///< enable brown out
        constexpr uint32_t DET = (1U << 31);  ///< brown out detect
        constexpr uint32_t RTC_MEM_CRC_FINISH = (1U << 31);  ///< RTC_MEM_CRC_FINISH
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t CNTL_DATE = (28 << 0);  ///< CNTL_DATE
    }

}

// ============================================================================
// SDHOST Peripheral
// ============================================================================

namespace sdhost {
    /// Base addresses
    constexpr uint32_t SDHOST_BASE = 0x3FF68000;

    /// SDHOST Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLKDIV;  ///< Offset: 0x08 - Clock divider configuration register
        volatile uint32_t CLKSRC;  ///< Offset: 0x0C - Clock source selection register
        volatile uint32_t CLKENA;  ///< Offset: 0x10 - Clock enable register
        volatile uint32_t TMOUT;  ///< Offset: 0x14 - Data and response timeout configuration register
        volatile uint32_t CTYPE;  ///< Offset: 0x18 - Card bus width configuration register
        volatile uint32_t BLKSIZ;  ///< Offset: 0x1C - Card data block size configuration register
        volatile uint32_t BYTCNT;  ///< Offset: 0x20 - Data transfer length configuration register
        volatile uint32_t INTMASK;  ///< Offset: 0x24 - SDIO interrupt mask register
        volatile uint32_t CMDARG;  ///< Offset: 0x28 - Command argument data register
        volatile uint32_t CMD;  ///< Offset: 0x2C - Command and boot configuration register
        volatile uint32_t RESP0;  ///< Offset: 0x30 - Response data register
        volatile uint32_t RESP1;  ///< Offset: 0x34 - Long response data register
        volatile uint32_t RESP2;  ///< Offset: 0x38 - Long response data register
        volatile uint32_t RESP3;  ///< Offset: 0x3C - Long response data register
        volatile uint32_t MINTSTS;  ///< Offset: 0x40 - Masked interrupt status register
        volatile uint32_t RINTSTS;  ///< Offset: 0x44 - Raw interrupt status register
        volatile uint32_t STATUS;  ///< Offset: 0x48 - SD/MMC status register
        volatile uint32_t FIFOTH;  ///< Offset: 0x4C - FIFO configuration register
        volatile uint32_t CDETECT;  ///< Offset: 0x50 - Card detect register
        volatile uint32_t WRTPRT;  ///< Offset: 0x54 - Card write protection (WP) status register
        volatile uint32_t TCBCNT;  ///< Offset: 0x5C - Transferred byte count register
        volatile uint32_t TBBCNT;  ///< Offset: 0x60 - Transferred byte count register
        volatile uint32_t DEBNCE;  ///< Offset: 0x64 - Debounce filter time configuration register
        volatile uint32_t USRID;  ///< Offset: 0x68 - User ID (scratchpad) register
        volatile uint32_t VERID;  ///< Offset: 0x6C - Version ID (scratchpad) register
        volatile uint32_t HCON;  ///< Offset: 0x70 - Hardware feature register
        volatile uint32_t UHS;  ///< Offset: 0x74 - UHS-1 register
        volatile uint32_t RST_N;  ///< Offset: 0x78 - Card reset register
        volatile uint32_t BMOD;  ///< Offset: 0x80 - Burst mode transfer configuration register
        volatile uint32_t PLDMND;  ///< Offset: 0x84 - Poll demand configuration register
        volatile uint32_t DBADDR;  ///< Offset: 0x88 - Descriptor base address register
        volatile uint32_t IDSTS;  ///< Offset: 0x8C - IDMAC status register
        volatile uint32_t IDINTEN;  ///< Offset: 0x90 - IDMAC interrupt enable register
        volatile uint32_t DSCADDR;  ///< Offset: 0x94 - Host descriptor address pointer
        volatile uint32_t BUFADDR;  ///< Offset: 0x98 - Host buffer address pointer register
        volatile uint32_t CARDTHRCTL;  ///< Offset: 0x100 - Card Threshold Control register
        volatile uint32_t EMMCDDR;  ///< Offset: 0x10C - eMMC DDR register
        volatile uint32_t ENSHIFT;  ///< Offset: 0x110 - Enable Phase Shift register
        volatile uint32_t BUFFIFO;  ///< Offset: 0x200 - CPU write and read transmit data by FIFO
        volatile uint32_t CLK_EDGE_SEL;  ///< Offset: 0x800 - SDIO control register.
    };

    /// Peripheral instances
    inline Registers* SDHOST = reinterpret_cast<Registers*>(SDHOST_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CONTROLLER_RESET = (1U << 0);  ///< To reset controller, firmware should set this bit. This bit is auto-cleared after two AHB and two sdhost_cclk_in clock cycles.
        constexpr uint32_t FIFO_RESET = (1U << 1);  ///< To reset FIFO, firmware should set bit to 1. This bit is auto-cleared after completion of reset operation. Note: FIFO pointers will be out of reset after 2 cycles of system clocks in addition to synchronization delay (2 cycles of card clock), after the fifo_reset is cleared.
        constexpr uint32_t DMA_RESET = (1U << 2);  ///< To reset DMA interface, firmware should set bit to 1. This bit is auto-cleared after two AHB clocks.
        constexpr uint32_t INT_ENABLE = (1U << 4);  ///< Global interrupt enable/disable bit. 0: Disable; 1: Enable.
        constexpr uint32_t READ_WAIT = (1U << 6);  ///< For sending read-wait to SDIO cards.
        constexpr uint32_t SEND_IRQ_RESPONSE = (1U << 7);  ///< Bit automatically clears once response is sent. To wait for MMC card interrupts, host issues CMD40 and waits for interrupt response from MMC card(s). In the meantime, if host wants SD/MMC to exit waiting for interrupt state, it can set this bit, at which time SD/MMC command state-machine sends CMD40 response on bus and returns to idle state.
        constexpr uint32_t ABORT_READ_DATA = (1U << 8);  ///< After a suspend-command is issued during a read-operation, software polls the card to find when the suspend-event occurred. Once the suspend-event has occurred, software sets the bit which will reset the data state machine that is waiting for the next block of data. This bit is automatically cleared once the data state machine is reset to idle.
        constexpr uint32_t SEND_CCSD = (1U << 9);  ///< When set, SD/MMC sends CCSD to the CE-ATA device. Software sets this bit only if the current command is expecting CCS (that is, RW_BLK), and if interrupts are enabled for the CE-ATA device. Once the CCSD pattern is sent to the device, SD/MMC automatically clears the SDHOST_SEND_CCSD bit. It also sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG register, and generates an interrupt for the host, in case the Command Done interrupt is not masked. NOTE: Once the SDHOST_SEND_CCSD bit is set, it takes two card clock cycles to drive the CCSD on the CMD line. Due to this, within the boundary conditions the CCSD may be sent to the CE-ATA device, even if the device has signalled CCS.
        constexpr uint32_t SEND_AUTO_STOP_CCSD = (1U << 10);  ///< Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits together; SDHOST_SEND_AUTO_STOP_CCSD should not be set independently of send_ccsd. When set, SD/MMC automatically sends an internally-generated STOP command (CMD12) to the CE-ATA device. After sending this internally-generated STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG is set and an interrupt is generated for the host, in case the ACD interrupt is not masked. After sending the Command Completion Signal Disable (CCSD), SD/MMC automatically clears the SDHOST_SEND_AUTO_STOP_CCSD bit.
        constexpr uint32_t CEATA_DEVICE_INTERRUPT_STATUS = (1U << 11);  ///< Software should appropriately write to this bit after the power-on reset or any other reset to the CE-ATA device. After reset, the CE-ATA device's interrupt is usually disabled (nIEN = 1). If the host enables the CE-ATA device's interrupt, then software should set this bit.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLK_DIVIDER0 = (8 << 0);  ///< Clock divider0 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER1 = (8 << 8);  ///< Clock divider1 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER2 = (8 << 16);  ///< Clock divider2 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER3 = (8 << 24);  ///< Clock divider3 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
    }

    /// CLKSRC Register bits
    namespace clksrc_bits {
        constexpr uint32_t CLKSRC = (4 << 0);  ///< Clock divider source for two SD cards is supported. Each card has two bits assigned to it. For example, bit[1:0] are assigned for card 0, bit[3:2] are assigned for card 1. Card 0 maps and internally routes clock divider[0:3] outputs to cclk_out[1:0] pins, depending on bit value. 00 : Clock divider 0; 01 : Clock divider 1; 10 : Clock divider 2; 11 : Clock divider 3.
    }

    /// CLKENA Register bits
    namespace clkena_bits {
        constexpr uint32_t CCLK_ENABLE = (2 << 0);  ///< Clock-enable control for two SD card clocks and one MMC card clock is supported. One bit per card. 0: Clock disabled; 1: Clock enabled.
        constexpr uint32_t LP_ENABLE = (2 << 16);  ///< Disable clock when the card is in IDLE state. One bit per card. 0: clock disabled; 1: clock enabled.
    }

    /// TMOUT Register bits
    namespace tmout_bits {
        constexpr uint32_t RESPONSE_TIMEOUT = (8 << 0);  ///< Response timeout value. Value is specified in terms of number of card output clocks, i.e., sdhost_cclk_out.
        constexpr uint32_t DATA_TIMEOUT = (24 << 8);  ///< Value for card data read timeout. This value is also used for data starvation by host timeout. The timeout counter is started only after the card clock is stopped. This value is specified in number of card output clocks, i.e. sdhost_cclk_out of the selected card. NOTE: The software timer should be used if the timeout value is in the order of 100 ms. In this case, read data timeout interrupt needs to be disabled.
    }

    /// CTYPE Register bits
    namespace ctype_bits {
        constexpr uint32_t CARD_WIDTH4 = (2 << 0);  ///< One bit per card indicates if card is 1-bit or 4-bit mode. 0: 1-bit mode; 1: 4-bit mode. Bit[1:0] correspond to card[1:0] respectively.
        constexpr uint32_t CARD_WIDTH8 = (2 << 16);  ///< One bit per card indicates if card is in 8-bit mode. 0: Non 8-bit mode; 1: 8-bit mode. Bit[17:16] correspond to card[1:0] respectively.
    }

    /// BLKSIZ Register bits
    namespace blksiz_bits {
        constexpr uint32_t BLOCK_SIZE = (16 << 0);  ///< Block size.
    }

    /// BYTCNT Register bits
    namespace bytcnt_bits {
        constexpr uint32_t BYTE_COUNT = (32 << 0);  ///< Number of bytes to be transferred, should be an integral multiple of Block Size for block transfers. For data transfers of undefined byte lengths, byte count should be set to 0. When byte count is set to 0, it is the responsibility of host to explicitly send stop/abort command to terminate data transfer.
    }

    /// INTMASK Register bits
    namespace intmask_bits {
        constexpr uint32_t INT_MASK = (16 << 0);  ///< These bits used to mask unwanted interrupts. A value of 0 masks interrupt, and a value of 1 enables the interrupt. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): Rx Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation-by-host timeout; Bit 9 (DRTO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INT_MASK = (2 << 16);  ///< SDIO interrupt mask, one bit for each card. Bit[17:16] correspond to card[15:0] respectively. When masked, SDIO interrupt detection for that card is disabled. 0 masks an interrupt, and 1 enables an interrupt.
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Value indicates command argument to be passed to the card.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Command index.
        constexpr uint32_t RESPONSE_EXPECT = (1U << 6);  ///< 0: No response expected from card; 1: Response expected from card.
        constexpr uint32_t RESPONSE_LENGTH = (1U << 7);  ///< 0: Short response expected from card; 1: Long response expected from card.
        constexpr uint32_t CHECK_RESPONSE_CRC = (1U << 8);  ///< 0: Do not check; 1: Check response CRC. Some of command responses do not return valid CRC bits. Software should disable CRC checks for those commands in order to disable CRC checking by controller.
        constexpr uint32_t DATA_EXPECTED = (1U << 9);  ///< 0: No data transfer expected; 1: Data transfer expected.
        constexpr uint32_t READ_WRITE = (1U << 10);  ///< 0: Read from card; 1: Write to card. Don't care if no data is expected from card.
        constexpr uint32_t TRANSFER_MODE = (1U << 11);  ///< Block data transfer command; 1: Stream data transfer command. Don't care if no data expected.
        constexpr uint32_t SEND_AUTO_STOP = (1U << 12);  ///< 0: No stop command is sent at the end of data transfer; 1: Send stop command at the end of data transfer.
        constexpr uint32_t WAIT_PRVDATA_COMPLETE = (1U << 13);  ///< 0: Send command at once, even if previous data transfer has not completed; 1: Wait for previous data transfer to complete before sending Command. The SDHOST_WAIT_PRVDATA_COMPLETE] = 0 option is typically used to query status of card during data transfer or to stop current data transfer. SDHOST_CARD_NUMBERr should be same as in previous command.
        constexpr uint32_t STOP_ABORT_CMD = (1U << 14);  ///< 0: Neither stop nor abort command can stop current data transfer. If abort is sent to function-number currently selected or not in data-transfer mode, then bit should be set to 0; 1: Stop or abort command intended to stop current data transfer in progress. When open-ended or predefined data transfer is in progress, and host issues stop or abort command to stop data transfer, bit should be set so that command/data state-machines of CIU can return correctly to idle state.
        constexpr uint32_t SEND_INITIALIZATION = (1U << 15);  ///< 0: Do not send initialization sequence (80 clocks of 1) before sending this command; 1: Send initialization sequence before sending this command. After powered on, 80 clocks must be sent to card for initialization before sending any commands to card. Bit should be set while sending first command to card so that controller will initialize clocks before sending command to card.
        constexpr uint32_t CARD_NUMBER = (5 << 16);  ///< Card number in use. Represents physical slot number of card being accessed. In SD-only mode, up to two cards are supported.
        constexpr uint32_t UPDATE_CLOCK_REGISTERS_ONLY = (1U << 21);  ///< 0: Normal command sequence; 1: Do not send commands, just update clock register value into card clock domain. Following register values are transferred into card clock domain: CLKDIV, CLRSRC, and CLKENA. Changes card clocks (change frequency, truncate off or on, and set low-frequency mode). This is provided in order to change clock frequency or stop clock without having to send command to cards. During normal command sequence, when sdhost_update_clock_registers_only = 0, following control registers are transferred from BIU to CIU: CMD, CMDARG, TMOUT, CTYPE, BLKSIZ, and BYTCNT. CIU uses new register values for new command sequence to card(s). When bit is set, there are no Command Done interrupts because no command is sent to SD_MMC_CEATA cards.
        constexpr uint32_t READ_CEATA_DEVICE = (1U << 22);  ///< Read access flag. 0: Host is not performing read access (RW_REG or RW_BLK)towards CE-ATA device; 1: Host is performing read access (RW_REG or RW_BLK) towards CE-ATA device. Software should set this bit to indicate that CE-ATA device is being accessed for read transfer. This bit is used to disable read data timeout indication while performing CE-ATA read transfers. Maximum value of I/O transmission delay can be no less than 10 seconds. SD/MMC should not indicate read data timeout while waiting for data from CE-ATA device.
        constexpr uint32_t CCS_EXPECTED = (1U << 23);  ///< Expected Command Completion Signal (CCS) configuration. 0: Interrupts are not enabled in CE-ATA device (nIEN = 1 in ATA control register), or command does not expect CCS from device; 1: Interrupts are enabled in CE-ATA device (nIEN = 0), and RW_BLK command expects command completion signal from CE-ATA device. If the command expects Command Completion Signal (CCS) from the CE-ATA device, the software should set this control bit. SD/MMC sets Data Transfer Over (DTO) bit in RINTSTS register and generates interrupt to host if Data Transfer Over interrupt is not masked.
        constexpr uint32_t USE_HOLE = (1U << 29);  ///< Use Hold Register. 0: CMD and DATA sent to card bypassing HOLD Register; 1: CMD and DATA sent to card through the HOLD Register.
        constexpr uint32_t START_CMD = (1U << 31);  ///< Start command. Once command is served by the CIU, this bit is automatically cleared. When this bit is set, host should not attempt to write to any command registers. If a write is attempted, hardware lock error is set in raw interrupt register. Once command is sent and a response is received from SD_MMC_CEATA cards, Command Done bit is set in the raw interrupt Register.
    }

    /// RESP0 Register bits
    namespace resp0_bits {
        constexpr uint32_t RESPONSE0 = (32 << 0);  ///< Bit[31:0] of response.
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t RESPONSE1 = (32 << 0);  ///< Bit[63:32] of long response.
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t RESPONSE2 = (32 << 0);  ///< Bit[95:64] of long response.
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t RESPONSE3 = (32 << 0);  ///< Bit[127:96] of long response.
    }

    /// MINTSTS Register bits
    namespace mintsts_bits {
        constexpr uint32_t INT_STATUS_MSK = (16 << 0);  ///< Interrupt enabled only if corresponding bit in interrupt mask register is set. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_MSK = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. SDIO interrupt for card is enabled only if corresponding sdhost_sdio_int_mask bit is set in Interrupt mask register (Setting mask bit enables interrupt).
    }

    /// RINTSTS Register bits
    namespace rintsts_bits {
        constexpr uint32_t INT_STATUS_RAW = (16 << 0);  ///< Setting a bit clears the corresponding interrupt and writing 0 has no effect. Bits are logged regardless of interrupt mask status. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_RAW = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. Setting a bit clears the corresponding interrupt bit and writing 0 has no effect. 0: No SDIO interrupt from card; 1: SDIO interrupt from card.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t FIFO_RX_WATERMARK = (1U << 0);  ///< FIFO reached Receive watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_TX_WATERMARK = (1U << 1);  ///< FIFO reached Transmit watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_EMPTY = (1U << 2);  ///< FIFO is empty status.
        constexpr uint32_t FIFO_FULL = (1U << 3);  ///< FIFO is full status.
        constexpr uint32_t COMMAND_FSM_STATES = (4 << 4);  ///< Command FSM states. 0: Idle; 1: Send init sequence; 2: Send cmd start bit; 3: Send cmd tx bit; 4: Send cmd index + arg; 5: Send cmd crc7; 6: Send cmd end bit; 7: Receive resp start bit; 8: Receive resp IRQ response; 9: Receive resp tx bit; 10: Receive resp cmd idx; 11: Receive resp data; 12: Receive resp crc7; 13: Receive resp end bit; 14: Cmd path wait NCC; 15: Wait, cmd-to-response turnaround.
        constexpr uint32_t DATA_3_STATUS = (1U << 8);  ///< Raw selected sdhost_card_data[3], checks whether card is present. 0: card not present; 1: card present.
        constexpr uint32_t DATA_BUSY = (1U << 9);  ///< Inverted version of raw selected sdhost_card_data[0]. 0: Card data not busy; 1: Card data busy.
        constexpr uint32_t DATA_STATE_MC_BUSY = (1U << 10);  ///< Data transmit or receive state-machine is busy.
        constexpr uint32_t RESPONSE_INDEX = (6 << 11);  ///< Index of previous response, including any auto-stop sent by core.
        constexpr uint32_t FIFO_COUNT = (13 << 17);  ///< FIFO count, number of filled locations in FIFO.
    }

    /// FIFOTH Register bits
    namespace fifoth_bits {
        constexpr uint32_t TX_WMARK = (12 << 0);  ///< FIFO threshold watermark level when transmitting data to card. When FIFO data count is less than or equal to this number, DMA/FIFO request is raised. If Interrupt is enabled, then interrupt occurs. During end of packet, request or interrupt is generated, regardless of threshold programming.In non-DMA mode, when transmit FIFO threshold (TXDR) interrupt is enabled, then interrupt is generated instead of DMA request. During end of packet, on last interrupt, host is responsible for filling FIFO with only required remaining bytes (not before FIFO is full or after CIU completes data transfers, because FIFO may not be empty). In DMA mode, at end of packet, if last transfer is less than burst size, DMA controller does single cycles until required bytes are transferred.
        constexpr uint32_t RX_WMARK = (11 << 16);  ///< FIFO threshold watermark level when receiving data to card.When FIFO data count reaches greater than this number , DMA/FIFO request is raised. During end of packet, request is generated regardless of threshold programming in order to complete any remaining data.In non-DMA mode, when receiver FIFO threshold (RXDR) interrupt is enabled, then interrupt is generated instead of DMA request.During end of packet, interrupt is not generated if threshold programming is larger than any remaining data. It is responsibility of host to read remaining bytes on seeing Data Transfer Done interrupt.In DMA mode, at end of packet, even if remaining bytes are less than threshold, DMA request does single transfers to flush out any remaining bytes before Data Transfer Done interrupt is set.
        constexpr uint32_t DMA_MULTIPLE_TRANSACTION_SIZE = (3 << 28);  ///< Burst size of multiple transaction, should be programmed same as DMA controller multiple-transaction-size SDHOST_SRC/DEST_MSIZE. 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer.
    }

    /// CDETECT Register bits
    namespace cdetect_bits {
        constexpr uint32_t CARD_DETECT_N = (2 << 0);  ///< Value on sdhost_card_detect_n input ports (1 bit per card), read-only bits. 0 represents presence of card. Only NUM_CARDS number of bits are implemented.
    }

    /// WRTPRT Register bits
    namespace wrtprt_bits {
        constexpr uint32_t WRITE_PROTECT = (2 << 0);  ///< Value on sdhost_card_write_prt input ports (1 bit per card). 1 represents write protection. Only NUM_CARDS number of bits are implemented.
    }

    /// TCBCNT Register bits
    namespace tcbcnt_bits {
        constexpr uint32_t TCBCNT = (32 << 0);  ///< Number of bytes transferred by CIU unit to card.
    }

    /// TBBCNT Register bits
    namespace tbbcnt_bits {
        constexpr uint32_t TBBCNT = (32 << 0);  ///< Number of bytes transferred between Host/DMA memory and BIU FIFO.
    }

    /// DEBNCE Register bits
    namespace debnce_bits {
        constexpr uint32_t DEBOUNCE_COUNT = (24 << 0);  ///< Number of host clocks (clk) used by debounce filter logic. The typical debounce time is 5 \verb+~+ 25 ms to prevent the card instability when the card is inserted or removed.
    }

    /// USRID Register bits
    namespace usrid_bits {
        constexpr uint32_t USRID = (32 << 0);  ///< User identification register, value set by user. Can also be used as a scratchpad register by user.
    }

    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSIONID = (32 << 0);  ///< Hardware version register. Can also be read by fireware.
    }

    /// HCON Register bits
    namespace hcon_bits {
        constexpr uint32_t CARD_TYPE = (1U << 0);  ///< Hardware support SDIO and MMC.
        constexpr uint32_t CARD_NUM = (5 << 1);  ///< Support card number is 2.
        constexpr uint32_t BUS_TYPE = (1U << 6);  ///< Register config is APB bus.
        constexpr uint32_t DATA_WIDTH = (3 << 7);  ///< Regisger data widht is 32.
        constexpr uint32_t ADDR_WIDTH = (6 << 10);  ///< Register address width is 32.
        constexpr uint32_t DMA_WIDTH = (3 << 18);  ///< DMA data witdth is 32.
        constexpr uint32_t RAM_INDISE = (1U << 21);  ///< Inside RAM in SDMMC module.
        constexpr uint32_t HOLD = (1U << 22);  ///< Have a hold regiser in data path .
        constexpr uint32_t NUM_CLK_DIV = (2 << 24);  ///< Have 4 clk divider in design .
    }

    /// UHS Register bits
    namespace uhs_bits {
        constexpr uint32_t DDR = (2 << 16);  ///< DDR mode selecton,1 bit for each card. 0-Non-DDR mdoe. 1-DDR mdoe.
    }

    /// RST_N Register bits
    namespace rst_n_bits {
        constexpr uint32_t CARD_RESET = (2 << 0);  ///< Hardware reset. 1: Active mode; 0: Reset. These bits cause the cards to enter pre-idle state, which requires them to be re-initialized. SDHOST_RST_CARD_RESET[0] should be set to 1'b0 to reset card0, SDHOST_RST_CARD_RESET[1] should be set to 1'b0 to reset card1.
    }

    /// BMOD Register bits
    namespace bmod_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset. When set, the DMA Controller resets all its internal registers. It is automatically cleared after one clock cycle.
        constexpr uint32_t FB = (1U << 1);  ///< Fixed Burst. Controls whether the AHB Master interface performs fixed burst transfers or not. When set, the AHB will use only SINGLE, INCR4, INCR8 or INCR16 during start of normal burst transfers. When reset, the AHB will use SINGLE and INCR burst transfer operations.
        constexpr uint32_t DE = (1U << 7);  ///< IDMAC Enable. When set, the IDMAC is enabled.
        constexpr uint32_t PBL = (3 << 8);  ///< Programmable Burst Length. These bits indicate the maximum number of beats to be performed in one IDMAC???Internal DMA Control???transaction. The IDMAC will always attempt to burst as specified in PBL each time it starts a burst transfer on the host bus. The permissible values are 1, 4, 8, 16, 32, 64, 128 and 256. This value is the mirror of MSIZE of FIFOTH register. In order to change this value, write the required value to FIFOTH register. This is an encode value as follows: 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer. PBL is a read-only value and is applicable only for data access, it does not apply to descriptor access.
    }

    /// PLDMND Register bits
    namespace pldmnd_bits {
        constexpr uint32_t PD = (32 << 0);  ///< Poll Demand. If the OWNER bit of a descriptor is not set, the FSM goes to the Suspend state. The host needs to write any value into this register for the IDMAC FSM to resume normal descriptor fetch operation. This is a write only .
    }

    /// DBADDR Register bits
    namespace dbaddr_bits {
        constexpr uint32_t DBADDR = (32 << 0);  ///< Start of Descriptor List. Contains the base address of the First Descriptor. The LSB bits [1:0] are ignored and taken as all-zero by the IDMAC internally. Hence these LSB bits may be treated as read-only.
    }

    /// IDSTS Register bits
    namespace idsts_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt. Indicates that data transmission is finished for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt. Indicates the completion of data reception for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Interrupt. Indicates that a Bus Error occurred (IDSTS[12:10]) . When this bit is set, the DMA disables all its bus accesses. Writing 1 clears this bit.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. This bit is set when the descriptor is unavailable due to OWNER bit = 0 (DES0[31] = 0). Writing 1 clears this bit.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error Summary. Indicates the status of the transaction to/from the card, also present in RINTSTS. Indicates the logical OR of the following bits: EBE : End Bit Error; RTO : Response Timeout/Boot Ack Timeout; RCRC : Response CRC; SBE : Start Bit Error; DRTO : Data Read Timeout/BDS timeout; DCRC : Data CRC for Receive; RE : Response Error. Writing 1 clears this bit. The abort condition of the IDMAC depends on the setting of this CES bit. If the CES bit is enabled, then the IDMAC aborts on a response error.
        constexpr uint32_t NIS = (1U << 8);  ///< Normal Interrupt Summary. Logical OR of the following: IDSTS[0] : Transmit Interrupt, IDSTS[1] : Receive Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes NIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t AIS = (1U << 9);  ///< Abnormal Interrupt Summary. Logical OR of the following: IDSTS[2] : Fatal Bus Interrupt, IDSTS[4] : DU bit Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes AIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t FBE_CODE = (3 << 10);  ///< Fatal Bus Error Code. Indicates the type of error that caused a Bus Error. Valid only when the Fatal Bus Error bit IDSTS[2] is set. This field does not generate an interrupt. 001: Host Abort received during transmission; 010: Host Abort received during reception; Others: Reserved.
        constexpr uint32_t FSM = (4 << 13);  ///< DMAC FSM present state. 0: DMA_IDLE (idle state); 1: DMA_SUSPEND (suspend state); 2: DESC_RD (descriptor reading state); 3: DESC_CHK (descriptor checking state); 4: DMA_RD_REQ_WAIT (read-data request waiting state); 5: DMA_WR_REQ_WAIT (write-data request waiting state); 6: DMA_RD (data-read state); 7: DMA_WR (data-write state); 8: DESC_CLOSE (descriptor close state).
    }

    /// IDINTEN Register bits
    namespace idinten_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable, Transmit Interrupt is enabled. When reset, Transmit Interrupt is disabled.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive Interrupt is enabled. When reset, Receive Interrupt is disabled.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Enable. When set with Abnormal Interrupt Summary Enable, the Fatal Bus Error Interrupt is enabled. When reset, Fatal Bus Error Enable Interrupt is disabled.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary Enable, the DU interrupt is enabled.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error summary Interrupt Enable. When set, it enables the Card Interrupt summary.
        constexpr uint32_t NI = (1U << 8);  ///< Normal Interrupt Summary Enable. When set, a normal interrupt is enabled. When reset, a normal interrupt is disabled. This bit enables the following bits: IDINTEN[0]: Transmit Interrupt; IDINTEN[1]: Receive Interrupt.
        constexpr uint32_t AI = (1U << 9);  ///< Abnormal Interrupt Summary Enable. When set, an abnormal interrupt is enabled. This bit enables the following bits: IDINTEN[2]: Fatal Bus Error Interrupt; IDINTEN[4]: DU Interrupt.
    }

    /// DSCADDR Register bits
    namespace dscaddr_bits {
        constexpr uint32_t DSCADDR = (32 << 0);  ///< Host Descriptor Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the start address of the current descriptor read by the IDMAC.
    }

    /// BUFADDR Register bits
    namespace bufaddr_bits {
        constexpr uint32_t BUFADDR = (32 << 0);  ///< Host Buffer Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the current Data Buffer Address being accessed by the IDMAC.
    }

    /// CARDTHRCTL Register bits
    namespace cardthrctl_bits {
        constexpr uint32_t CARDRDTHREN = (1U << 0);  ///< Card read threshold enable. 1'b0-Card read threshold disabled. 1'b1-Card read threshold enabled.
        constexpr uint32_t CARDCLRINTEN = (1U << 1);  ///< Busy clear interrupt generation: 1'b0-Busy clear interrypt disabled. 1'b1-Busy clear interrypt enabled.
        constexpr uint32_t CARDWRTHREN = (1U << 2);  ///< Applicable when HS400 mode is enabled. 1'b0-Card write Threshold disabled. 1'b1-Card write Threshold enabled.
        constexpr uint32_t CARDTHRESHOLD = (16 << 16);  ///< The inside FIFO size is 512,This register is applicable when SDHOST_CARDERTHREN_REG is set to 1 or SDHOST_CARDRDTHREN_REG set to 1.
    }

    /// EMMCDDR Register bits
    namespace emmcddr_bits {
        constexpr uint32_t HALFSTARTBIT = (2 << 0);  ///< Control for start bit detection mechanism duration of start bit.Each bit refers to one slot.Set this bit to 1 for eMMC4.5 and above,set to 0 for SD applications.For eMMC4.5,start bit can be: 1'b0-Full cycle. 1'b1-less than one full cycle.
        constexpr uint32_t HS400_MODE = (1U << 31);  ///< Set 1 to enable HS400 mode.
    }

    /// ENSHIFT Register bits
    namespace enshift_bits {
        constexpr uint32_t ENABLE_SHIFT = (4 << 0);  ///< Control for the amount of phase shift provided on the default enables in the design.Two bits assigned for each card. 2'b00-Default phase shift. 2'b01-Enables shifted to next immediate positive edge. 2'b10-Enables shifted to next immediate negative edge. 2'b11-Reserved.
    }

    /// BUFFIFO Register bits
    namespace buffifo_bits {
        constexpr uint32_t BUFFIFO = (32 << 0);  ///< CPU write and read transmit data by FIFO. This register points to the current Data FIFO .
    }

    /// CLK_EDGE_SEL Register bits
    namespace clk_edge_sel_bits {
        constexpr uint32_t CCLKIN_EDGE_DRV_SEL = (3 << 0);  ///< It's used to select the clock phase of the output signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SAM_SEL = (3 << 3);  ///< It's used to select the clock phase of the input signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SLF_SEL = (3 << 6);  ///< It's used to select the clock phase of the internal signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLLKIN_EDGE_H = (4 << 9);  ///< The high level of the divider clock. The value should be smaller than CCLKIN_EDGE_L.
        constexpr uint32_t CCLLKIN_EDGE_L = (4 << 13);  ///< The low level of the divider clock. The value should be larger than CCLKIN_EDGE_H.
        constexpr uint32_t CCLLKIN_EDGE_N = (4 << 17);  ///< The value should be equal to CCLKIN_EDGE_L.
        constexpr uint32_t ESDIO_MODE = (1U << 21);  ///< Enable esdio mode.
        constexpr uint32_t ESD_MODE = (1U << 22);  ///< Enable esd mode.
        constexpr uint32_t CCLK_EN = (1U << 23);  ///< Sdio clock enable
    }

}

// ============================================================================
// SENS Peripheral
// ============================================================================

namespace sens {
    /// Base addresses
    constexpr uint32_t SENS_BASE = 0x3FF48800;

    /// SENS Register structure
    struct Registers {
        volatile uint32_t SAR_READ_CTRL;  ///< Offset: 0x00 - clock divider
        volatile uint32_t SAR_READ_STATUS1;  ///< Offset: 0x04 - 
        volatile uint32_t SAR_MEAS_WAIT1;  ///< Offset: 0x08 - 
        volatile uint32_t SAR_MEAS_WAIT2;  ///< Offset: 0x0C - 
        volatile uint32_t SAR_MEAS_CTRL;  ///< Offset: 0x10 - 
        volatile uint32_t SAR_READ_STATUS2;  ///< Offset: 0x14 - 
        volatile uint32_t ULP_CP_SLEEP_CYC0;  ///< Offset: 0x18 - sleep cycles for ULP-coprocessor timer
        volatile uint32_t ULP_CP_SLEEP_CYC1;  ///< Offset: 0x1C - 
        volatile uint32_t ULP_CP_SLEEP_CYC2;  ///< Offset: 0x20 - 
        volatile uint32_t ULP_CP_SLEEP_CYC3;  ///< Offset: 0x24 - 
        volatile uint32_t ULP_CP_SLEEP_CYC4;  ///< Offset: 0x28 - 
        volatile uint32_t SAR_START_FORCE;  ///< Offset: 0x2C - 00: 9 bit 01: 10 bits 10: 11bits 11: 12bits
        volatile uint32_t SAR_MEM_WR_CTRL;  ///< Offset: 0x30 - 
        volatile uint32_t SAR_ATTEN1;  ///< Offset: 0x34 - 2-bit attenuation for each pad 11:1dB 10:6dB 01:3dB 00:0dB
        volatile uint32_t SAR_ATTEN2;  ///< Offset: 0x38 - 2-bit attenuation for each pad 11:1dB 10:6dB 01:3dB 00:0dB
        volatile uint32_t SAR_SLAVE_ADDR1;  ///< Offset: 0x3C - 
        volatile uint32_t SAR_SLAVE_ADDR2;  ///< Offset: 0x40 - 
        volatile uint32_t SAR_SLAVE_ADDR3;  ///< Offset: 0x44 - temperature sensor data out
        volatile uint32_t SAR_SLAVE_ADDR4;  ///< Offset: 0x48 - I2C read data
        volatile uint32_t SAR_TSENS_CTRL;  ///< Offset: 0x4C - invert temperature sensor data
        volatile uint32_t SAR_I2C_CTRL;  ///< Offset: 0x50 - I2C control data only active when reg_sar_i2c_start_force = 1
        volatile uint32_t SAR_MEAS_START1;  ///< Offset: 0x54 - SAR ADC1 data
        volatile uint32_t SAR_TOUCH_CTRL1;  ///< Offset: 0x58 - the meas length (in 8MHz)
        volatile uint32_t SAR_TOUCH_THRES1;  ///< Offset: 0x5C - the threshold for touch pad 1
        volatile uint32_t SAR_TOUCH_THRES2;  ///< Offset: 0x60 - the threshold for touch pad 3
        volatile uint32_t SAR_TOUCH_THRES3;  ///< Offset: 0x64 - the threshold for touch pad 5
        volatile uint32_t SAR_TOUCH_THRES4;  ///< Offset: 0x68 - the threshold for touch pad 7
        volatile uint32_t SAR_TOUCH_THRES5;  ///< Offset: 0x6C - the threshold for touch pad 9
        volatile uint32_t SAR_TOUCH_OUT1;  ///< Offset: 0x70 - the counter for touch pad 1
        volatile uint32_t SAR_TOUCH_OUT2;  ///< Offset: 0x74 - the counter for touch pad 3
        volatile uint32_t SAR_TOUCH_OUT3;  ///< Offset: 0x78 - the counter for touch pad 5
        volatile uint32_t SAR_TOUCH_OUT4;  ///< Offset: 0x7C - the counter for touch pad 7
        volatile uint32_t SAR_TOUCH_OUT5;  ///< Offset: 0x80 - the counter for touch pad 9
        volatile uint32_t SAR_TOUCH_CTRL2;  ///< Offset: 0x84 - 10-bit register to indicate which pads are "touched"
        volatile uint32_t SAR_TOUCH_ENABLE;  ///< Offset: 0x8C - Bitmap defining the working set during the measurement.
        volatile uint32_t SAR_READ_CTRL2;  ///< Offset: 0x90 - clock divider
        volatile uint32_t SAR_MEAS_START2;  ///< Offset: 0x94 - SAR ADC2 data
        volatile uint32_t SAR_DAC_CTRL1;  ///< Offset: 0x98 - frequency step for CW generator can be used to adjust...
        volatile uint32_t SAR_DAC_CTRL2;  ///< Offset: 0x9C - DC offset for DAC1 CW generator
        volatile uint32_t SAR_MEAS_CTRL2;  ///< Offset: 0xA0 - 
        volatile uint32_t SAR_NOUSE;  ///< Offset: 0xF8 - 
        volatile uint32_t SARDATE;  ///< Offset: 0xFC - 
    };

    /// Peripheral instances
    inline Registers* SENS = reinterpret_cast<Registers*>(SENS_BASE);

    // Bit definitions
    /// SAR_READ_CTRL Register bits
    namespace sar_read_ctrl_bits {
        constexpr uint32_t SAR1_CLK_DIV = (8 << 0);  ///< clock divider
        constexpr uint32_t SAR1_SAMPLE_CYCLE = (8 << 8);  ///< sample cycles for SAR ADC1
        constexpr uint32_t SAR1_SAMPLE_BIT = (2 << 16);  ///< 00: for 9-bit width 01: for 10-bit width 10: for 11-bit width 11: for 12-bit width
        constexpr uint32_t SAR1_CLK_GATED = (1U << 18);  ///< SAR1_CLK_GATED
        constexpr uint32_t SAR1_SAMPLE_NUM = (8 << 19);  ///< SAR1_SAMPLE_NUM
        constexpr uint32_t SAR1_DIG_FORCE = (1U << 27);  ///< 1: SAR ADC1 controlled by DIG ADC1 CTRL 0: SAR ADC1 controlled by RTC ADC1 CTRL
        constexpr uint32_t SAR1_DATA_INV = (1U << 28);  ///< Invert SAR ADC1 data
    }

    /// SAR_READ_STATUS1 Register bits
    namespace sar_read_status1_bits {
        constexpr uint32_t SAR1_READER_STATUS = (32 << 0);  ///< SAR1_READER_STATUS
    }

    /// SAR_MEAS_WAIT1 Register bits
    namespace sar_meas_wait1_bits {
        constexpr uint32_t SAR_AMP_WAIT1 = (16 << 0);  ///< SAR_AMP_WAIT1
        constexpr uint32_t SAR_AMP_WAIT2 = (16 << 16);  ///< SAR_AMP_WAIT2
    }

    /// SAR_MEAS_WAIT2 Register bits
    namespace sar_meas_wait2_bits {
        constexpr uint32_t FORCE_XPD_SAR_SW = (1U << 0);  ///< FORCE_XPD_SAR_SW
        constexpr uint32_t SAR_AMP_WAIT3 = (16 << 0);  ///< SAR_AMP_WAIT3
        constexpr uint32_t FORCE_XPD_AMP = (2 << 16);  ///< FORCE_XPD_AMP
        constexpr uint32_t FORCE_XPD_SAR = (2 << 18);  ///< FORCE_XPD_SAR
        constexpr uint32_t SAR2_RSTB_WAIT = (8 << 20);  ///< SAR2_RSTB_WAIT
    }

    /// SAR_MEAS_CTRL Register bits
    namespace sar_meas_ctrl_bits {
        constexpr uint32_t XPD_SAR_AMP_FSM = (4 << 0);  ///< XPD_SAR_AMP_FSM
        constexpr uint32_t AMP_RST_FB_FSM = (4 << 4);  ///< AMP_RST_FB_FSM
        constexpr uint32_t AMP_SHORT_REF_FSM = (4 << 8);  ///< AMP_SHORT_REF_FSM
        constexpr uint32_t AMP_SHORT_REF_GND_FSM = (4 << 12);  ///< AMP_SHORT_REF_GND_FSM
        constexpr uint32_t XPD_SAR_FSM = (4 << 16);  ///< XPD_SAR_FSM
        constexpr uint32_t SAR_RSTB_FSM = (4 << 20);  ///< SAR_RSTB_FSM
        constexpr uint32_t SAR2_XPD_WAIT = (8 << 24);  ///< SAR2_XPD_WAIT
    }

    /// SAR_READ_STATUS2 Register bits
    namespace sar_read_status2_bits {
        constexpr uint32_t SAR2_READER_STATUS = (32 << 0);  ///< SAR2_READER_STATUS
    }

    /// ULP_CP_SLEEP_CYC0 Register bits
    namespace ulp_cp_sleep_cyc0_bits {
        constexpr uint32_t SLEEP_CYCLES_S0 = (32 << 0);  ///< sleep cycles for ULP-coprocessor timer
    }

    /// ULP_CP_SLEEP_CYC1 Register bits
    namespace ulp_cp_sleep_cyc1_bits {
        constexpr uint32_t SLEEP_CYCLES_S1 = (32 << 0);  ///< SLEEP_CYCLES_S1
    }

    /// ULP_CP_SLEEP_CYC2 Register bits
    namespace ulp_cp_sleep_cyc2_bits {
        constexpr uint32_t SLEEP_CYCLES_S2 = (32 << 0);  ///< SLEEP_CYCLES_S2
    }

    /// ULP_CP_SLEEP_CYC3 Register bits
    namespace ulp_cp_sleep_cyc3_bits {
        constexpr uint32_t SLEEP_CYCLES_S3 = (32 << 0);  ///< SLEEP_CYCLES_S3
    }

    /// ULP_CP_SLEEP_CYC4 Register bits
    namespace ulp_cp_sleep_cyc4_bits {
        constexpr uint32_t SLEEP_CYCLES_S4 = (32 << 0);  ///< SLEEP_CYCLES_S4
    }

    /// SAR_START_FORCE Register bits
    namespace sar_start_force_bits {
        constexpr uint32_t SAR1_BIT_WIDTH = (2 << 0);  ///< 00: 9 bit 01: 10 bits 10: 11bits 11: 12bits
        constexpr uint32_t SAR2_BIT_WIDTH = (2 << 2);  ///< 00: 9 bit 01: 10 bits 10: 11bits 11: 12bits
        constexpr uint32_t SAR2_EN_TEST = (1U << 4);  ///< SAR2_EN_TEST only active when reg_sar2_dig_force = 0
        constexpr uint32_t SAR2_PWDET_CCT = (3 << 5);  ///< SAR2_PWDET_CCT PA power detector capacitance tuning.
        constexpr uint32_t ULP_CP_FORCE_START_TOP = (1U << 8);  ///< 1: ULP-coprocessor is started by SW 0: ULP-coprocessor is started by timer
        constexpr uint32_t ULP_CP_START_TOP = (1U << 9);  ///< Write 1 to start ULP-coprocessor only active when reg_ulp_cp_force_start_top = 1
        constexpr uint32_t SARCLK_EN = (1U << 10);  ///< SARCLK_EN
        constexpr uint32_t PC_INIT = (11 << 11);  ///< initialized PC for ULP-coprocessor
        constexpr uint32_t SAR2_STOP = (1U << 22);  ///< stop SAR ADC2 conversion
        constexpr uint32_t SAR1_STOP = (1U << 23);  ///< stop SAR ADC1 conversion
        constexpr uint32_t SAR2_PWDET_EN = (1U << 24);  ///< N/A
    }

    /// SAR_MEM_WR_CTRL Register bits
    namespace sar_mem_wr_ctrl_bits {
        constexpr uint32_t MEM_WR_ADDR_INIT = (11 << 0);  ///< MEM_WR_ADDR_INIT
        constexpr uint32_t MEM_WR_ADDR_SIZE = (11 << 11);  ///< MEM_WR_ADDR_SIZE
        constexpr uint32_t RTC_MEM_WR_OFFST_CLR = (1U << 22);  ///< RTC_MEM_WR_OFFST_CLR
    }

    /// SAR_ATTEN1 Register bits
    namespace sar_atten1_bits {
        constexpr uint32_t SAR1_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad 11:1dB 10:6dB 01:3dB 00:0dB
    }

    /// SAR_ATTEN2 Register bits
    namespace sar_atten2_bits {
        constexpr uint32_t SAR2_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad 11:1dB 10:6dB 01:3dB 00:0dB
    }

    /// SAR_SLAVE_ADDR1 Register bits
    namespace sar_slave_addr1_bits {
        constexpr uint32_t I2C_SLAVE_ADDR1 = (11 << 0);  ///< I2C_SLAVE_ADDR1
        constexpr uint32_t I2C_SLAVE_ADDR0 = (11 << 11);  ///< I2C_SLAVE_ADDR0
        constexpr uint32_t MEAS_STATUS = (8 << 22);  ///< MEAS_STATUS
    }

    /// SAR_SLAVE_ADDR2 Register bits
    namespace sar_slave_addr2_bits {
        constexpr uint32_t I2C_SLAVE_ADDR3 = (11 << 0);  ///< I2C_SLAVE_ADDR3
        constexpr uint32_t I2C_SLAVE_ADDR2 = (11 << 11);  ///< I2C_SLAVE_ADDR2
    }

    /// SAR_SLAVE_ADDR3 Register bits
    namespace sar_slave_addr3_bits {
        constexpr uint32_t I2C_SLAVE_ADDR5 = (11 << 0);  ///< I2C_SLAVE_ADDR5
        constexpr uint32_t I2C_SLAVE_ADDR4 = (11 << 11);  ///< I2C_SLAVE_ADDR4
        constexpr uint32_t TSENS_OUT = (8 << 22);  ///< temperature sensor data out
        constexpr uint32_t TSENS_RDY_OUT = (1U << 30);  ///< indicate temperature sensor out ready
    }

    /// SAR_SLAVE_ADDR4 Register bits
    namespace sar_slave_addr4_bits {
        constexpr uint32_t I2C_SLAVE_ADDR7 = (11 << 0);  ///< I2C_SLAVE_ADDR7
        constexpr uint32_t I2C_SLAVE_ADDR6 = (11 << 11);  ///< I2C_SLAVE_ADDR6
        constexpr uint32_t I2C_RDATA = (8 << 22);  ///< I2C read data
        constexpr uint32_t I2C_DONE = (1U << 30);  ///< indicate I2C done
    }

    /// SAR_TSENS_CTRL Register bits
    namespace sar_tsens_ctrl_bits {
        constexpr uint32_t TSENS_XPD_WAIT = (12 << 0);  ///< TSENS_XPD_WAIT
        constexpr uint32_t TSENS_XPD_FORCE = (1U << 12);  ///< TSENS_XPD_FORCE
        constexpr uint32_t TSENS_CLK_INV = (1U << 13);  ///< TSENS_CLK_INV
        constexpr uint32_t TSENS_CLK_GATED = (1U << 14);  ///< TSENS_CLK_GATED
        constexpr uint32_t TSENS_IN_INV = (1U << 15);  ///< invert temperature sensor data
        constexpr uint32_t TSENS_CLK_DIV = (8 << 16);  ///< temperature sensor clock divider
        constexpr uint32_t TSENS_POWER_UP = (1U << 24);  ///< temperature sensor power up
        constexpr uint32_t TSENS_POWER_UP_FORCE = (1U << 25);  ///< 1: dump out & power up controlled by SW 0: by FSM
        constexpr uint32_t TSENS_DUMP_OUT = (1U << 26);  ///< temperature sensor dump out only active when reg_tsens_power_up_force = 1
    }

    /// SAR_I2C_CTRL Register bits
    namespace sar_i2c_ctrl_bits {
        constexpr uint32_t SAR_I2C_CTRL = (28 << 0);  ///< I2C control data only active when reg_sar_i2c_start_force = 1
        constexpr uint32_t SAR_I2C_START = (1U << 28);  ///< start I2C only active when reg_sar_i2c_start_force = 1
        constexpr uint32_t SAR_I2C_START_FORCE = (1U << 29);  ///< 1: I2C started by SW 0: I2C started by FSM
    }

    /// SAR_MEAS_START1 Register bits
    namespace sar_meas_start1_bits {
        constexpr uint32_t MEAS1_DATA_SAR = (16 << 0);  ///< SAR ADC1 data
        constexpr uint32_t MEAS1_DONE_SAR = (1U << 16);  ///< SAR ADC1 conversion done indication
        constexpr uint32_t MEAS1_START_SAR = (1U << 17);  ///< SAR ADC1 controller (in RTC) starts conversion only active when reg_meas1_start_force = 1
        constexpr uint32_t MEAS1_START_FORCE = (1U << 18);  ///< 1: SAR ADC1 controller (in RTC) is started by SW 0: SAR ADC1 controller is started by ULP-coprocessor
        constexpr uint32_t SAR1_EN_PAD = (12 << 19);  ///< SAR ADC1 pad enable bitmap only active when reg_sar1_en_pad_force = 1
        constexpr uint32_t SAR1_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC1 pad enable bitmap is controlled by SW 0: SAR ADC1 pad enable bitmap is controlled by ULP-coprocessor
    }

    /// SAR_TOUCH_CTRL1 Register bits
    namespace sar_touch_ctrl1_bits {
        constexpr uint32_t TOUCH_MEAS_DELAY = (16 << 0);  ///< the meas length (in 8MHz)
        constexpr uint32_t TOUCH_XPD_WAIT = (8 << 16);  ///< the waiting cycles (in 8MHz) between TOUCH_START and TOUCH_XPD
        constexpr uint32_t TOUCH_OUT_SEL = (1U << 24);  ///< 1: when the counter is greater then the threshold the touch pad is considered as "touched" 0: when the counter is less than the threshold the touch pad is considered as "touched"
        constexpr uint32_t TOUCH_OUT_1EN = (1U << 25);  ///< 1: wakeup interrupt is generated if SET1 is "touched" 0: wakeup interrupt is generated only if SET1 & SET2 is both "touched"
        constexpr uint32_t XPD_HALL_FORCE = (1U << 26);  ///< 1: XPD HALL is controlled by SW. 0: XPD HALL is controlled by FSM in ULP-coprocessor
        constexpr uint32_t HALL_PHASE_FORCE = (1U << 27);  ///< 1: HALL PHASE is controlled by SW 0: HALL PHASE is controlled by FSM in ULP-coprocessor
    }

    /// SAR_TOUCH_THRES1 Register bits
    namespace sar_touch_thres1_bits {
        constexpr uint32_t TOUCH_OUT_TH1 = (16 << 0);  ///< the threshold for touch pad 1
        constexpr uint32_t TOUCH_OUT_TH0 = (16 << 16);  ///< the threshold for touch pad 0
    }

    /// SAR_TOUCH_THRES2 Register bits
    namespace sar_touch_thres2_bits {
        constexpr uint32_t TOUCH_OUT_TH3 = (16 << 0);  ///< the threshold for touch pad 3
        constexpr uint32_t TOUCH_OUT_TH2 = (16 << 16);  ///< the threshold for touch pad 2
    }

    /// SAR_TOUCH_THRES3 Register bits
    namespace sar_touch_thres3_bits {
        constexpr uint32_t TOUCH_OUT_TH5 = (16 << 0);  ///< the threshold for touch pad 5
        constexpr uint32_t TOUCH_OUT_TH4 = (16 << 16);  ///< the threshold for touch pad 4
    }

    /// SAR_TOUCH_THRES4 Register bits
    namespace sar_touch_thres4_bits {
        constexpr uint32_t TOUCH_OUT_TH7 = (16 << 0);  ///< the threshold for touch pad 7
        constexpr uint32_t TOUCH_OUT_TH6 = (16 << 16);  ///< the threshold for touch pad 6
    }

    /// SAR_TOUCH_THRES5 Register bits
    namespace sar_touch_thres5_bits {
        constexpr uint32_t TOUCH_OUT_TH9 = (16 << 0);  ///< the threshold for touch pad 9
        constexpr uint32_t TOUCH_OUT_TH8 = (16 << 16);  ///< the threshold for touch pad 8
    }

    /// SAR_TOUCH_OUT1 Register bits
    namespace sar_touch_out1_bits {
        constexpr uint32_t TOUCH_MEAS_OUT1 = (16 << 0);  ///< the counter for touch pad 1
        constexpr uint32_t TOUCH_MEAS_OUT0 = (16 << 16);  ///< the counter for touch pad 0
    }

    /// SAR_TOUCH_OUT2 Register bits
    namespace sar_touch_out2_bits {
        constexpr uint32_t TOUCH_MEAS_OUT3 = (16 << 0);  ///< the counter for touch pad 3
        constexpr uint32_t TOUCH_MEAS_OUT2 = (16 << 16);  ///< the counter for touch pad 2
    }

    /// SAR_TOUCH_OUT3 Register bits
    namespace sar_touch_out3_bits {
        constexpr uint32_t TOUCH_MEAS_OUT5 = (16 << 0);  ///< the counter for touch pad 5
        constexpr uint32_t TOUCH_MEAS_OUT4 = (16 << 16);  ///< the counter for touch pad 4
    }

    /// SAR_TOUCH_OUT4 Register bits
    namespace sar_touch_out4_bits {
        constexpr uint32_t TOUCH_MEAS_OUT7 = (16 << 0);  ///< the counter for touch pad 7
        constexpr uint32_t TOUCH_MEAS_OUT6 = (16 << 16);  ///< the counter for touch pad 6
    }

    /// SAR_TOUCH_OUT5 Register bits
    namespace sar_touch_out5_bits {
        constexpr uint32_t TOUCH_MEAS_OUT9 = (16 << 0);  ///< the counter for touch pad 9
        constexpr uint32_t TOUCH_MEAS_OUT8 = (16 << 16);  ///< the counter for touch pad 8
    }

    /// SAR_TOUCH_CTRL2 Register bits
    namespace sar_touch_ctrl2_bits {
        constexpr uint32_t TOUCH_MEAS_EN = (10 << 0);  ///< 10-bit register to indicate which pads are "touched"
        constexpr uint32_t TOUCH_MEAS_DONE = (1U << 10);  ///< fsm set 1 to indicate touch touch meas is done
        constexpr uint32_t TOUCH_START_FSM_EN = (1U << 11);  ///< 1: TOUCH_START & TOUCH_XPD is controlled by touch fsm 0: TOUCH_START & TOUCH_XPD is controlled by registers
        constexpr uint32_t TOUCH_START_EN = (1U << 12);  ///< 1: start touch fsm valid when reg_touch_start_force is set
        constexpr uint32_t TOUCH_START_FORCE = (1U << 13);  ///< 1: to start touch fsm by SW 0: to start touch fsm by timer
        constexpr uint32_t TOUCH_SLEEP_CYCLES = (16 << 14);  ///< sleep cycles for timer
        constexpr uint32_t TOUCH_MEAS_EN_CLR = (1U << 30);  ///< to clear reg_touch_meas_en
    }

    /// SAR_TOUCH_ENABLE Register bits
    namespace sar_touch_enable_bits {
        constexpr uint32_t TOUCH_PAD_WORKEN = (10 << 0);  ///< Bitmap defining the working set during the measurement.
        constexpr uint32_t TOUCH_PAD_OUTEN2 = (10 << 10);  ///< Bitmap defining SET2 for generating wakeup interrupt. SET2 is "touched" only if at least one of touch pad in SET2 is "touched".
        constexpr uint32_t TOUCH_PAD_OUTEN1 = (10 << 20);  ///< Bitmap defining SET1 for generating wakeup interrupt. SET1 is "touched" only if at least one of touch pad in SET1 is "touched".
    }

    /// SAR_READ_CTRL2 Register bits
    namespace sar_read_ctrl2_bits {
        constexpr uint32_t SAR2_CLK_DIV = (8 << 0);  ///< clock divider
        constexpr uint32_t SAR2_SAMPLE_CYCLE = (8 << 8);  ///< sample cycles for SAR ADC2
        constexpr uint32_t SAR2_SAMPLE_BIT = (2 << 16);  ///< 00: for 9-bit width 01: for 10-bit width 10: for 11-bit width 11: for 12-bit width
        constexpr uint32_t SAR2_CLK_GATED = (1U << 18);  ///< SAR2_CLK_GATED
        constexpr uint32_t SAR2_SAMPLE_NUM = (8 << 19);  ///< SAR2_SAMPLE_NUM
        constexpr uint32_t SAR2_PWDET_FORCE = (1U << 27);  ///< SAR2_PWDET_FORCE
        constexpr uint32_t SAR2_DIG_FORCE = (1U << 28);  ///< 1: SAR ADC2 controlled by DIG ADC2 CTRL or PWDET CTRL 0: SAR ADC2 controlled by RTC ADC2 CTRL
        constexpr uint32_t SAR2_DATA_INV = (1U << 29);  ///< Invert SAR ADC2 data
    }

    /// SAR_MEAS_START2 Register bits
    namespace sar_meas_start2_bits {
        constexpr uint32_t MEAS2_DATA_SAR = (16 << 0);  ///< SAR ADC2 data
        constexpr uint32_t MEAS2_DONE_SAR = (1U << 16);  ///< SAR ADC2 conversion done indication
        constexpr uint32_t MEAS2_START_SAR = (1U << 17);  ///< SAR ADC2 controller (in RTC) starts conversion only active when reg_meas2_start_force = 1
        constexpr uint32_t MEAS2_START_FORCE = (1U << 18);  ///< 1: SAR ADC2 controller (in RTC) is started by SW 0: SAR ADC2 controller is started by ULP-coprocessor
        constexpr uint32_t SAR2_EN_PAD = (12 << 19);  ///< SAR ADC2 pad enable bitmap only active when reg_sar2_en_pad_force = 1
        constexpr uint32_t SAR2_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC2 pad enable bitmap is controlled by SW 0: SAR ADC2 pad enable bitmap is controlled by ULP-coprocessor
    }

    /// SAR_DAC_CTRL1 Register bits
    namespace sar_dac_ctrl1_bits {
        constexpr uint32_t SW_FSTEP = (16 << 0);  ///< frequency step for CW generator can be used to adjust the frequency
        constexpr uint32_t SW_TONE_EN = (1U << 16);  ///< 1: enable CW generator 0: disable CW generator
        constexpr uint32_t DEBUG_BIT_SEL = (5 << 17);  ///< DEBUG_BIT_SEL
        constexpr uint32_t DAC_DIG_FORCE = (1U << 22);  ///< 1: DAC1 & DAC2 use DMA 0: DAC1 & DAC2 do not use DMA
        constexpr uint32_t DAC_CLK_FORCE_LOW = (1U << 23);  ///< 1: force PDAC_CLK to low
        constexpr uint32_t DAC_CLK_FORCE_HIGH = (1U << 24);  ///< 1: force PDAC_CLK to high
        constexpr uint32_t DAC_CLK_INV = (1U << 25);  ///< 1: invert PDAC_CLK
    }

    /// SAR_DAC_CTRL2 Register bits
    namespace sar_dac_ctrl2_bits {
        constexpr uint32_t DAC_DC1 = (8 << 0);  ///< DC offset for DAC1 CW generator
        constexpr uint32_t DAC_DC2 = (8 << 8);  ///< DC offset for DAC2 CW generator
        constexpr uint32_t DAC_SCALE1 = (2 << 16);  ///< 00: no scale 01: scale to 1/2 10: scale to 1/4 scale to 1/8
        constexpr uint32_t DAC_SCALE2 = (2 << 18);  ///< 00: no scale 01: scale to 1/2 10: scale to 1/4 scale to 1/8
        constexpr uint32_t DAC_INV1 = (2 << 20);  ///< 00: do not invert any bits 01: invert all bits 10: invert MSB 11: invert all bits except MSB
        constexpr uint32_t DAC_INV2 = (2 << 22);  ///< 00: do not invert any bits 01: invert all bits 10: invert MSB 11: invert all bits except MSB
        constexpr uint32_t DAC_CW_EN1 = (1U << 24);  ///< 1: to select CW generator as source to PDAC1_DAC[7:0] 0: to select register reg_pdac1_dac[7:0] as source to PDAC1_DAC[7:0]
        constexpr uint32_t DAC_CW_EN2 = (1U << 25);  ///< 1: to select CW generator as source to PDAC2_DAC[7:0] 0: to select register reg_pdac2_dac[7:0] as source to PDAC2_DAC[7:0]
    }

    /// SAR_MEAS_CTRL2 Register bits
    namespace sar_meas_ctrl2_bits {
        constexpr uint32_t SAR1_DAC_XPD_FSM = (4 << 0);  ///< SAR1_DAC_XPD_FSM
        constexpr uint32_t SAR1_DAC_XPD_FSM_IDLE = (1U << 4);  ///< SAR1_DAC_XPD_FSM_IDLE
        constexpr uint32_t XPD_SAR_AMP_FSM_IDLE = (1U << 5);  ///< XPD_SAR_AMP_FSM_IDLE
        constexpr uint32_t AMP_RST_FB_FSM_IDLE = (1U << 6);  ///< AMP_RST_FB_FSM_IDLE
        constexpr uint32_t AMP_SHORT_REF_FSM_IDLE = (1U << 7);  ///< AMP_SHORT_REF_FSM_IDLE
        constexpr uint32_t AMP_SHORT_REF_GND_FSM_IDLE = (1U << 8);  ///< AMP_SHORT_REF_GND_FSM_IDLE
        constexpr uint32_t XPD_SAR_FSM_IDLE = (1U << 9);  ///< XPD_SAR_FSM_IDLE
        constexpr uint32_t SAR_RSTB_FSM_IDLE = (1U << 10);  ///< SAR_RSTB_FSM_IDLE
        constexpr uint32_t SAR2_RSTB_FORCE = (2 << 11);  ///< SAR2_RSTB_FORCE
        constexpr uint32_t AMP_RST_FB_FORCE = (2 << 13);  ///< AMP_RST_FB_FORCE
        constexpr uint32_t AMP_SHORT_REF_FORCE = (2 << 15);  ///< AMP_SHORT_REF_FORCE
        constexpr uint32_t AMP_SHORT_REF_GND_FORCE = (2 << 17);  ///< AMP_SHORT_REF_GND_FORCE
    }

    /// SAR_NOUSE Register bits
    namespace sar_nouse_bits {
        constexpr uint32_t SAR_NOUSE = (32 << 0);  ///< SAR_NOUSE
    }

    /// SARDATE Register bits
    namespace sardate_bits {
        constexpr uint32_t SAR_DATE = (28 << 0);  ///< SAR_DATE
    }

}

// ============================================================================
// SLC Peripheral
// ============================================================================

namespace slc {
    /// Base addresses
    constexpr uint32_t SLC_BASE = 0x3FF58000;

    /// SLC Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - 
        volatile uint32_t _0INT_RAW;  ///< Offset: 0x04 - 
        volatile uint32_t _0INT_ST;  ///< Offset: 0x08 - 
        volatile uint32_t _0INT_ENA;  ///< Offset: 0x0C - 
        volatile uint32_t _0INT_CLR;  ///< Offset: 0x10 - 
        volatile uint32_t _1INT_RAW;  ///< Offset: 0x14 - 
        volatile uint32_t _1INT_ST;  ///< Offset: 0x18 - 
        volatile uint32_t _1INT_ENA;  ///< Offset: 0x1C - 
        volatile uint32_t _1INT_CLR;  ///< Offset: 0x20 - 
        volatile uint32_t RX_STATUS;  ///< Offset: 0x24 - 
        volatile uint32_t _0RXFIFO_PUSH;  ///< Offset: 0x28 - 
        volatile uint32_t _1RXFIFO_PUSH;  ///< Offset: 0x2C - 
        volatile uint32_t TX_STATUS;  ///< Offset: 0x30 - 
        volatile uint32_t _0TXFIFO_POP;  ///< Offset: 0x34 - 
        volatile uint32_t _1TXFIFO_POP;  ///< Offset: 0x38 - 
        volatile uint32_t _0RX_LINK;  ///< Offset: 0x3C - 
        volatile uint32_t _0TX_LINK;  ///< Offset: 0x40 - 
        volatile uint32_t _1RX_LINK;  ///< Offset: 0x44 - 
        volatile uint32_t _1TX_LINK;  ///< Offset: 0x48 - 
        volatile uint32_t INTVEC_TOHOST;  ///< Offset: 0x4C - 
        volatile uint32_t _0TOKEN0;  ///< Offset: 0x50 - 
        volatile uint32_t _0TOKEN1;  ///< Offset: 0x54 - 
        volatile uint32_t _1TOKEN0;  ///< Offset: 0x58 - 
        volatile uint32_t _1TOKEN1;  ///< Offset: 0x5C - 
        volatile uint32_t CONF1;  ///< Offset: 0x60 - 
        volatile uint32_t _0_STATE0;  ///< Offset: 0x64 - 
        volatile uint32_t _0_STATE1;  ///< Offset: 0x68 - 
        volatile uint32_t _1_STATE0;  ///< Offset: 0x6C - 
        volatile uint32_t _1_STATE1;  ///< Offset: 0x70 - 
        volatile uint32_t BRIDGE_CONF;  ///< Offset: 0x74 - 
        volatile uint32_t _0_TO_EOF_DES_ADDR;  ///< Offset: 0x78 - 
        volatile uint32_t _0_TX_EOF_DES_ADDR;  ///< Offset: 0x7C - 
        volatile uint32_t _0_TO_EOF_BFR_DES_ADDR;  ///< Offset: 0x80 - 
        volatile uint32_t _1_TO_EOF_DES_ADDR;  ///< Offset: 0x84 - 
        volatile uint32_t _1_TX_EOF_DES_ADDR;  ///< Offset: 0x88 - 
        volatile uint32_t _1_TO_EOF_BFR_DES_ADDR;  ///< Offset: 0x8C - 
        volatile uint32_t AHB_TEST;  ///< Offset: 0x90 - 
        volatile uint32_t SDIO_ST;  ///< Offset: 0x94 - 
        volatile uint32_t RX_DSCR_CONF;  ///< Offset: 0x98 - 
        volatile uint32_t _0_TXLINK_DSCR;  ///< Offset: 0x9C - 
        volatile uint32_t _0_TXLINK_DSCR_BF0;  ///< Offset: 0xA0 - 
        volatile uint32_t _0_TXLINK_DSCR_BF1;  ///< Offset: 0xA4 - 
        volatile uint32_t _0_RXLINK_DSCR;  ///< Offset: 0xA8 - 
        volatile uint32_t _0_RXLINK_DSCR_BF0;  ///< Offset: 0xAC - 
        volatile uint32_t _0_RXLINK_DSCR_BF1;  ///< Offset: 0xB0 - 
        volatile uint32_t _1_TXLINK_DSCR;  ///< Offset: 0xB4 - 
        volatile uint32_t _1_TXLINK_DSCR_BF0;  ///< Offset: 0xB8 - 
        volatile uint32_t _1_TXLINK_DSCR_BF1;  ///< Offset: 0xBC - 
        volatile uint32_t _1_RXLINK_DSCR;  ///< Offset: 0xC0 - 
        volatile uint32_t _1_RXLINK_DSCR_BF0;  ///< Offset: 0xC4 - 
        volatile uint32_t _1_RXLINK_DSCR_BF1;  ///< Offset: 0xC8 - 
        volatile uint32_t _0_TX_ERREOF_DES_ADDR;  ///< Offset: 0xCC - 
        volatile uint32_t _1_TX_ERREOF_DES_ADDR;  ///< Offset: 0xD0 - 
        volatile uint32_t TOKEN_LAT;  ///< Offset: 0xD4 - 
        volatile uint32_t TX_DSCR_CONF;  ///< Offset: 0xD8 - 
        volatile uint32_t CMD_INFOR0;  ///< Offset: 0xDC - 
        volatile uint32_t CMD_INFOR1;  ///< Offset: 0xE0 - 
        volatile uint32_t _0_LEN_CONF;  ///< Offset: 0xE4 - 
        volatile uint32_t _0_LENGTH;  ///< Offset: 0xE8 - 
        volatile uint32_t _0_TXPKT_H_DSCR;  ///< Offset: 0xEC - 
        volatile uint32_t _0_TXPKT_E_DSCR;  ///< Offset: 0xF0 - 
        volatile uint32_t _0_RXPKT_H_DSCR;  ///< Offset: 0xF4 - 
        volatile uint32_t _0_RXPKT_E_DSCR;  ///< Offset: 0xF8 - 
        volatile uint32_t _0_TXPKTU_H_DSCR;  ///< Offset: 0xFC - 
        volatile uint32_t _0_TXPKTU_E_DSCR;  ///< Offset: 0x100 - 
        volatile uint32_t _0_RXPKTU_H_DSCR;  ///< Offset: 0x104 - 
        volatile uint32_t _0_RXPKTU_E_DSCR;  ///< Offset: 0x108 - 
        volatile uint32_t SEQ_POSITION;  ///< Offset: 0x114 - 
        volatile uint32_t _0_DSCR_REC_CONF;  ///< Offset: 0x118 - 
        volatile uint32_t SDIO_CRC_ST0;  ///< Offset: 0x11C - 
        volatile uint32_t SDIO_CRC_ST1;  ///< Offset: 0x120 - 
        volatile uint32_t _0_EOF_START_DES;  ///< Offset: 0x124 - 
        volatile uint32_t _0_PUSH_DSCR_ADDR;  ///< Offset: 0x128 - 
        volatile uint32_t _0_DONE_DSCR_ADDR;  ///< Offset: 0x12C - 
        volatile uint32_t _0_SUB_START_DES;  ///< Offset: 0x130 - 
        volatile uint32_t _0_DSCR_CNT;  ///< Offset: 0x134 - 
        volatile uint32_t _0_LEN_LIM_CONF;  ///< Offset: 0x138 - 
        volatile uint32_t _0INT_ST1;  ///< Offset: 0x13C - 
        volatile uint32_t _0INT_ENA1;  ///< Offset: 0x140 - 
        volatile uint32_t _1INT_ST1;  ///< Offset: 0x144 - 
        volatile uint32_t _1INT_ENA1;  ///< Offset: 0x148 - 
        volatile uint32_t DATE;  ///< Offset: 0x1F8 - 
        volatile uint32_t ID;  ///< Offset: 0x1FC - 
    };

    /// Peripheral instances
    inline Registers* SLC = reinterpret_cast<Registers*>(SLC_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t SLC0_TX_RST = (1U << 0);  ///< SLC0_TX_RST
        constexpr uint32_t SLC0_RX_RST = (1U << 1);  ///< SLC0_RX_RST
        constexpr uint32_t AHBM_FIFO_RST = (1U << 2);  ///< AHBM_FIFO_RST
        constexpr uint32_t AHBM_RST = (1U << 3);  ///< AHBM_RST
        constexpr uint32_t SLC0_TX_LOOP_TEST = (1U << 4);  ///< SLC0_TX_LOOP_TEST
        constexpr uint32_t SLC0_RX_LOOP_TEST = (1U << 5);  ///< SLC0_RX_LOOP_TEST
        constexpr uint32_t SLC0_RX_AUTO_WRBACK = (1U << 6);  ///< SLC0_RX_AUTO_WRBACK
        constexpr uint32_t SLC0_RX_NO_RESTART_CLR = (1U << 7);  ///< SLC0_RX_NO_RESTART_CLR
        constexpr uint32_t SLC0_RXDSCR_BURST_EN = (1U << 8);  ///< SLC0_RXDSCR_BURST_EN
        constexpr uint32_t SLC0_RXDATA_BURST_EN = (1U << 9);  ///< SLC0_RXDATA_BURST_EN
        constexpr uint32_t SLC0_RXLINK_AUTO_RET = (1U << 10);  ///< SLC0_RXLINK_AUTO_RET
        constexpr uint32_t SLC0_TXLINK_AUTO_RET = (1U << 11);  ///< SLC0_TXLINK_AUTO_RET
        constexpr uint32_t SLC0_TXDSCR_BURST_EN = (1U << 12);  ///< SLC0_TXDSCR_BURST_EN
        constexpr uint32_t SLC0_TXDATA_BURST_EN = (1U << 13);  ///< SLC0_TXDATA_BURST_EN
        constexpr uint32_t SLC0_TOKEN_AUTO_CLR = (1U << 14);  ///< SLC0_TOKEN_AUTO_CLR
        constexpr uint32_t SLC0_TOKEN_SEL = (1U << 15);  ///< SLC0_TOKEN_SEL
        constexpr uint32_t SLC1_TX_RST = (1U << 16);  ///< SLC1_TX_RST
        constexpr uint32_t SLC1_RX_RST = (1U << 17);  ///< SLC1_RX_RST
        constexpr uint32_t SLC0_WR_RETRY_MASK_EN = (1U << 18);  ///< SLC0_WR_RETRY_MASK_EN
        constexpr uint32_t SLC1_WR_RETRY_MASK_EN = (1U << 19);  ///< SLC1_WR_RETRY_MASK_EN
        constexpr uint32_t SLC1_TX_LOOP_TEST = (1U << 20);  ///< SLC1_TX_LOOP_TEST
        constexpr uint32_t SLC1_RX_LOOP_TEST = (1U << 21);  ///< SLC1_RX_LOOP_TEST
        constexpr uint32_t SLC1_RX_AUTO_WRBACK = (1U << 22);  ///< SLC1_RX_AUTO_WRBACK
        constexpr uint32_t SLC1_RX_NO_RESTART_CLR = (1U << 23);  ///< SLC1_RX_NO_RESTART_CLR
        constexpr uint32_t SLC1_RXDSCR_BURST_EN = (1U << 24);  ///< SLC1_RXDSCR_BURST_EN
        constexpr uint32_t SLC1_RXDATA_BURST_EN = (1U << 25);  ///< SLC1_RXDATA_BURST_EN
        constexpr uint32_t SLC1_RXLINK_AUTO_RET = (1U << 26);  ///< SLC1_RXLINK_AUTO_RET
        constexpr uint32_t SLC1_TXLINK_AUTO_RET = (1U << 27);  ///< SLC1_TXLINK_AUTO_RET
        constexpr uint32_t SLC1_TXDSCR_BURST_EN = (1U << 28);  ///< SLC1_TXDSCR_BURST_EN
        constexpr uint32_t SLC1_TXDATA_BURST_EN = (1U << 29);  ///< SLC1_TXDATA_BURST_EN
        constexpr uint32_t SLC1_TOKEN_AUTO_CLR = (1U << 30);  ///< SLC1_TOKEN_AUTO_CLR
        constexpr uint32_t SLC1_TOKEN_SEL = (1U << 31);  ///< SLC1_TOKEN_SEL
    }

    /// _0INT_RAW Register bits
    namespace _0int_raw_bits {
        constexpr uint32_t FRHOST_BIT0_INT_RAW = (1U << 0);  ///< FRHOST_BIT0_INT_RAW
        constexpr uint32_t FRHOST_BIT1_INT_RAW = (1U << 1);  ///< FRHOST_BIT1_INT_RAW
        constexpr uint32_t FRHOST_BIT2_INT_RAW = (1U << 2);  ///< FRHOST_BIT2_INT_RAW
        constexpr uint32_t FRHOST_BIT3_INT_RAW = (1U << 3);  ///< FRHOST_BIT3_INT_RAW
        constexpr uint32_t FRHOST_BIT4_INT_RAW = (1U << 4);  ///< FRHOST_BIT4_INT_RAW
        constexpr uint32_t FRHOST_BIT5_INT_RAW = (1U << 5);  ///< FRHOST_BIT5_INT_RAW
        constexpr uint32_t FRHOST_BIT6_INT_RAW = (1U << 6);  ///< FRHOST_BIT6_INT_RAW
        constexpr uint32_t FRHOST_BIT7_INT_RAW = (1U << 7);  ///< FRHOST_BIT7_INT_RAW
        constexpr uint32_t SLC0_RX_START_INT_RAW = (1U << 8);  ///< SLC0_RX_START_INT_RAW
        constexpr uint32_t SLC0_TX_START_INT_RAW = (1U << 9);  ///< SLC0_TX_START_INT_RAW
        constexpr uint32_t SLC0_RX_UDF_INT_RAW = (1U << 10);  ///< SLC0_RX_UDF_INT_RAW
        constexpr uint32_t SLC0_TX_OVF_INT_RAW = (1U << 11);  ///< SLC0_TX_OVF_INT_RAW
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_RAW = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_RAW
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_RAW = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_RAW
        constexpr uint32_t SLC0_TX_DONE_INT_RAW = (1U << 14);  ///< SLC0_TX_DONE_INT_RAW
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_RAW = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_RAW
        constexpr uint32_t SLC0_RX_DONE_INT_RAW = (1U << 16);  ///< SLC0_RX_DONE_INT_RAW
        constexpr uint32_t SLC0_RX_EOF_INT_RAW = (1U << 17);  ///< SLC0_RX_EOF_INT_RAW
        constexpr uint32_t SLC0_TOHOST_INT_RAW = (1U << 18);  ///< SLC0_TOHOST_INT_RAW
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_RAW = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_RAW = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_RAW = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_RAW
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_RAW = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_RAW
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_RAW = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_RAW
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_RAW = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_RAW
        constexpr uint32_t CMD_DTC_INT_RAW = (1U << 25);  ///< CMD_DTC_INT_RAW
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_RAW = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_RAW
    }

    /// _0INT_ST Register bits
    namespace _0int_st_bits {
        constexpr uint32_t FRHOST_BIT0_INT_ST = (1U << 0);  ///< FRHOST_BIT0_INT_ST
        constexpr uint32_t FRHOST_BIT1_INT_ST = (1U << 1);  ///< FRHOST_BIT1_INT_ST
        constexpr uint32_t FRHOST_BIT2_INT_ST = (1U << 2);  ///< FRHOST_BIT2_INT_ST
        constexpr uint32_t FRHOST_BIT3_INT_ST = (1U << 3);  ///< FRHOST_BIT3_INT_ST
        constexpr uint32_t FRHOST_BIT4_INT_ST = (1U << 4);  ///< FRHOST_BIT4_INT_ST
        constexpr uint32_t FRHOST_BIT5_INT_ST = (1U << 5);  ///< FRHOST_BIT5_INT_ST
        constexpr uint32_t FRHOST_BIT6_INT_ST = (1U << 6);  ///< FRHOST_BIT6_INT_ST
        constexpr uint32_t FRHOST_BIT7_INT_ST = (1U << 7);  ///< FRHOST_BIT7_INT_ST
        constexpr uint32_t SLC0_RX_START_INT_ST = (1U << 8);  ///< SLC0_RX_START_INT_ST
        constexpr uint32_t SLC0_TX_START_INT_ST = (1U << 9);  ///< SLC0_TX_START_INT_ST
        constexpr uint32_t SLC0_RX_UDF_INT_ST = (1U << 10);  ///< SLC0_RX_UDF_INT_ST
        constexpr uint32_t SLC0_TX_OVF_INT_ST = (1U << 11);  ///< SLC0_TX_OVF_INT_ST
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_ST = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_ST
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_ST = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_ST
        constexpr uint32_t SLC0_TX_DONE_INT_ST = (1U << 14);  ///< SLC0_TX_DONE_INT_ST
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_ST = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_ST
        constexpr uint32_t SLC0_RX_DONE_INT_ST = (1U << 16);  ///< SLC0_RX_DONE_INT_ST
        constexpr uint32_t SLC0_RX_EOF_INT_ST = (1U << 17);  ///< SLC0_RX_EOF_INT_ST
        constexpr uint32_t SLC0_TOHOST_INT_ST = (1U << 18);  ///< SLC0_TOHOST_INT_ST
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_ST = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_ST = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_ST = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_ST
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_ST = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_ST
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_ST = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_ST
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_ST = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_ST
        constexpr uint32_t CMD_DTC_INT_ST = (1U << 25);  ///< CMD_DTC_INT_ST
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_ST = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_ST
    }

    /// _0INT_ENA Register bits
    namespace _0int_ena_bits {
        constexpr uint32_t FRHOST_BIT0_INT_ENA = (1U << 0);  ///< FRHOST_BIT0_INT_ENA
        constexpr uint32_t FRHOST_BIT1_INT_ENA = (1U << 1);  ///< FRHOST_BIT1_INT_ENA
        constexpr uint32_t FRHOST_BIT2_INT_ENA = (1U << 2);  ///< FRHOST_BIT2_INT_ENA
        constexpr uint32_t FRHOST_BIT3_INT_ENA = (1U << 3);  ///< FRHOST_BIT3_INT_ENA
        constexpr uint32_t FRHOST_BIT4_INT_ENA = (1U << 4);  ///< FRHOST_BIT4_INT_ENA
        constexpr uint32_t FRHOST_BIT5_INT_ENA = (1U << 5);  ///< FRHOST_BIT5_INT_ENA
        constexpr uint32_t FRHOST_BIT6_INT_ENA = (1U << 6);  ///< FRHOST_BIT6_INT_ENA
        constexpr uint32_t FRHOST_BIT7_INT_ENA = (1U << 7);  ///< FRHOST_BIT7_INT_ENA
        constexpr uint32_t SLC0_RX_START_INT_ENA = (1U << 8);  ///< SLC0_RX_START_INT_ENA
        constexpr uint32_t SLC0_TX_START_INT_ENA = (1U << 9);  ///< SLC0_TX_START_INT_ENA
        constexpr uint32_t SLC0_RX_UDF_INT_ENA = (1U << 10);  ///< SLC0_RX_UDF_INT_ENA
        constexpr uint32_t SLC0_TX_OVF_INT_ENA = (1U << 11);  ///< SLC0_TX_OVF_INT_ENA
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_ENA = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_ENA = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t SLC0_TX_DONE_INT_ENA = (1U << 14);  ///< SLC0_TX_DONE_INT_ENA
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_ENA = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_ENA
        constexpr uint32_t SLC0_RX_DONE_INT_ENA = (1U << 16);  ///< SLC0_RX_DONE_INT_ENA
        constexpr uint32_t SLC0_RX_EOF_INT_ENA = (1U << 17);  ///< SLC0_RX_EOF_INT_ENA
        constexpr uint32_t SLC0_TOHOST_INT_ENA = (1U << 18);  ///< SLC0_TOHOST_INT_ENA
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_ENA = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_ENA = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_ENA = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_ENA
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_ENA = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_ENA
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_ENA = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_ENA
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_ENA = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_ENA
        constexpr uint32_t CMD_DTC_INT_ENA = (1U << 25);  ///< CMD_DTC_INT_ENA
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_ENA = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_ENA
    }

    /// _0INT_CLR Register bits
    namespace _0int_clr_bits {
        constexpr uint32_t FRHOST_BIT0_INT_CLR = (1U << 0);  ///< FRHOST_BIT0_INT_CLR
        constexpr uint32_t FRHOST_BIT1_INT_CLR = (1U << 1);  ///< FRHOST_BIT1_INT_CLR
        constexpr uint32_t FRHOST_BIT2_INT_CLR = (1U << 2);  ///< FRHOST_BIT2_INT_CLR
        constexpr uint32_t FRHOST_BIT3_INT_CLR = (1U << 3);  ///< FRHOST_BIT3_INT_CLR
        constexpr uint32_t FRHOST_BIT4_INT_CLR = (1U << 4);  ///< FRHOST_BIT4_INT_CLR
        constexpr uint32_t FRHOST_BIT5_INT_CLR = (1U << 5);  ///< FRHOST_BIT5_INT_CLR
        constexpr uint32_t FRHOST_BIT6_INT_CLR = (1U << 6);  ///< FRHOST_BIT6_INT_CLR
        constexpr uint32_t FRHOST_BIT7_INT_CLR = (1U << 7);  ///< FRHOST_BIT7_INT_CLR
        constexpr uint32_t SLC0_RX_START_INT_CLR = (1U << 8);  ///< SLC0_RX_START_INT_CLR
        constexpr uint32_t SLC0_TX_START_INT_CLR = (1U << 9);  ///< SLC0_TX_START_INT_CLR
        constexpr uint32_t SLC0_RX_UDF_INT_CLR = (1U << 10);  ///< SLC0_RX_UDF_INT_CLR
        constexpr uint32_t SLC0_TX_OVF_INT_CLR = (1U << 11);  ///< SLC0_TX_OVF_INT_CLR
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_CLR = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_CLR
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_CLR = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_CLR
        constexpr uint32_t SLC0_TX_DONE_INT_CLR = (1U << 14);  ///< SLC0_TX_DONE_INT_CLR
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_CLR = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_CLR
        constexpr uint32_t SLC0_RX_DONE_INT_CLR = (1U << 16);  ///< SLC0_RX_DONE_INT_CLR
        constexpr uint32_t SLC0_RX_EOF_INT_CLR = (1U << 17);  ///< SLC0_RX_EOF_INT_CLR
        constexpr uint32_t SLC0_TOHOST_INT_CLR = (1U << 18);  ///< SLC0_TOHOST_INT_CLR
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_CLR = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_CLR = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_CLR = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_CLR
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_CLR = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_CLR
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_CLR = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_CLR
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_CLR = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_CLR
        constexpr uint32_t CMD_DTC_INT_CLR = (1U << 25);  ///< CMD_DTC_INT_CLR
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_CLR = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_CLR
    }

    /// _1INT_RAW Register bits
    namespace _1int_raw_bits {
        constexpr uint32_t FRHOST_BIT8_INT_RAW = (1U << 0);  ///< FRHOST_BIT8_INT_RAW
        constexpr uint32_t FRHOST_BIT9_INT_RAW = (1U << 1);  ///< FRHOST_BIT9_INT_RAW
        constexpr uint32_t FRHOST_BIT10_INT_RAW = (1U << 2);  ///< FRHOST_BIT10_INT_RAW
        constexpr uint32_t FRHOST_BIT11_INT_RAW = (1U << 3);  ///< FRHOST_BIT11_INT_RAW
        constexpr uint32_t FRHOST_BIT12_INT_RAW = (1U << 4);  ///< FRHOST_BIT12_INT_RAW
        constexpr uint32_t FRHOST_BIT13_INT_RAW = (1U << 5);  ///< FRHOST_BIT13_INT_RAW
        constexpr uint32_t FRHOST_BIT14_INT_RAW = (1U << 6);  ///< FRHOST_BIT14_INT_RAW
        constexpr uint32_t FRHOST_BIT15_INT_RAW = (1U << 7);  ///< FRHOST_BIT15_INT_RAW
        constexpr uint32_t SLC1_RX_START_INT_RAW = (1U << 8);  ///< SLC1_RX_START_INT_RAW
        constexpr uint32_t SLC1_TX_START_INT_RAW = (1U << 9);  ///< SLC1_TX_START_INT_RAW
        constexpr uint32_t SLC1_RX_UDF_INT_RAW = (1U << 10);  ///< SLC1_RX_UDF_INT_RAW
        constexpr uint32_t SLC1_TX_OVF_INT_RAW = (1U << 11);  ///< SLC1_TX_OVF_INT_RAW
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_RAW = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_RAW
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_RAW = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_RAW
        constexpr uint32_t SLC1_TX_DONE_INT_RAW = (1U << 14);  ///< SLC1_TX_DONE_INT_RAW
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_RAW = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_RAW
        constexpr uint32_t SLC1_RX_DONE_INT_RAW = (1U << 16);  ///< SLC1_RX_DONE_INT_RAW
        constexpr uint32_t SLC1_RX_EOF_INT_RAW = (1U << 17);  ///< SLC1_RX_EOF_INT_RAW
        constexpr uint32_t SLC1_TOHOST_INT_RAW = (1U << 18);  ///< SLC1_TOHOST_INT_RAW
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_RAW = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_RAW = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_RAW
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_RAW = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_RAW
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_RAW = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_RAW
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_RAW = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_RAW
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_RAW = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_RAW
    }

    /// _1INT_ST Register bits
    namespace _1int_st_bits {
        constexpr uint32_t FRHOST_BIT8_INT_ST = (1U << 0);  ///< FRHOST_BIT8_INT_ST
        constexpr uint32_t FRHOST_BIT9_INT_ST = (1U << 1);  ///< FRHOST_BIT9_INT_ST
        constexpr uint32_t FRHOST_BIT10_INT_ST = (1U << 2);  ///< FRHOST_BIT10_INT_ST
        constexpr uint32_t FRHOST_BIT11_INT_ST = (1U << 3);  ///< FRHOST_BIT11_INT_ST
        constexpr uint32_t FRHOST_BIT12_INT_ST = (1U << 4);  ///< FRHOST_BIT12_INT_ST
        constexpr uint32_t FRHOST_BIT13_INT_ST = (1U << 5);  ///< FRHOST_BIT13_INT_ST
        constexpr uint32_t FRHOST_BIT14_INT_ST = (1U << 6);  ///< FRHOST_BIT14_INT_ST
        constexpr uint32_t FRHOST_BIT15_INT_ST = (1U << 7);  ///< FRHOST_BIT15_INT_ST
        constexpr uint32_t SLC1_RX_START_INT_ST = (1U << 8);  ///< SLC1_RX_START_INT_ST
        constexpr uint32_t SLC1_TX_START_INT_ST = (1U << 9);  ///< SLC1_TX_START_INT_ST
        constexpr uint32_t SLC1_RX_UDF_INT_ST = (1U << 10);  ///< SLC1_RX_UDF_INT_ST
        constexpr uint32_t SLC1_TX_OVF_INT_ST = (1U << 11);  ///< SLC1_TX_OVF_INT_ST
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_ST = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_ST
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_ST = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_ST
        constexpr uint32_t SLC1_TX_DONE_INT_ST = (1U << 14);  ///< SLC1_TX_DONE_INT_ST
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_ST = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_ST
        constexpr uint32_t SLC1_RX_DONE_INT_ST = (1U << 16);  ///< SLC1_RX_DONE_INT_ST
        constexpr uint32_t SLC1_RX_EOF_INT_ST = (1U << 17);  ///< SLC1_RX_EOF_INT_ST
        constexpr uint32_t SLC1_TOHOST_INT_ST = (1U << 18);  ///< SLC1_TOHOST_INT_ST
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_ST = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_ST = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_ST
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_ST = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_ST
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_ST = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_ST
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_ST = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_ST
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_ST = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_ST
    }

    /// _1INT_ENA Register bits
    namespace _1int_ena_bits {
        constexpr uint32_t FRHOST_BIT8_INT_ENA = (1U << 0);  ///< FRHOST_BIT8_INT_ENA
        constexpr uint32_t FRHOST_BIT9_INT_ENA = (1U << 1);  ///< FRHOST_BIT9_INT_ENA
        constexpr uint32_t FRHOST_BIT10_INT_ENA = (1U << 2);  ///< FRHOST_BIT10_INT_ENA
        constexpr uint32_t FRHOST_BIT11_INT_ENA = (1U << 3);  ///< FRHOST_BIT11_INT_ENA
        constexpr uint32_t FRHOST_BIT12_INT_ENA = (1U << 4);  ///< FRHOST_BIT12_INT_ENA
        constexpr uint32_t FRHOST_BIT13_INT_ENA = (1U << 5);  ///< FRHOST_BIT13_INT_ENA
        constexpr uint32_t FRHOST_BIT14_INT_ENA = (1U << 6);  ///< FRHOST_BIT14_INT_ENA
        constexpr uint32_t FRHOST_BIT15_INT_ENA = (1U << 7);  ///< FRHOST_BIT15_INT_ENA
        constexpr uint32_t SLC1_RX_START_INT_ENA = (1U << 8);  ///< SLC1_RX_START_INT_ENA
        constexpr uint32_t SLC1_TX_START_INT_ENA = (1U << 9);  ///< SLC1_TX_START_INT_ENA
        constexpr uint32_t SLC1_RX_UDF_INT_ENA = (1U << 10);  ///< SLC1_RX_UDF_INT_ENA
        constexpr uint32_t SLC1_TX_OVF_INT_ENA = (1U << 11);  ///< SLC1_TX_OVF_INT_ENA
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_ENA = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_ENA = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t SLC1_TX_DONE_INT_ENA = (1U << 14);  ///< SLC1_TX_DONE_INT_ENA
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_ENA = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_ENA
        constexpr uint32_t SLC1_RX_DONE_INT_ENA = (1U << 16);  ///< SLC1_RX_DONE_INT_ENA
        constexpr uint32_t SLC1_RX_EOF_INT_ENA = (1U << 17);  ///< SLC1_RX_EOF_INT_ENA
        constexpr uint32_t SLC1_TOHOST_INT_ENA = (1U << 18);  ///< SLC1_TOHOST_INT_ENA
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_ENA = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_ENA = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_ENA
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_ENA = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_ENA
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_ENA = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_ENA
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_ENA = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_ENA
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_ENA = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_ENA
    }

    /// _1INT_CLR Register bits
    namespace _1int_clr_bits {
        constexpr uint32_t FRHOST_BIT8_INT_CLR = (1U << 0);  ///< FRHOST_BIT8_INT_CLR
        constexpr uint32_t FRHOST_BIT9_INT_CLR = (1U << 1);  ///< FRHOST_BIT9_INT_CLR
        constexpr uint32_t FRHOST_BIT10_INT_CLR = (1U << 2);  ///< FRHOST_BIT10_INT_CLR
        constexpr uint32_t FRHOST_BIT11_INT_CLR = (1U << 3);  ///< FRHOST_BIT11_INT_CLR
        constexpr uint32_t FRHOST_BIT12_INT_CLR = (1U << 4);  ///< FRHOST_BIT12_INT_CLR
        constexpr uint32_t FRHOST_BIT13_INT_CLR = (1U << 5);  ///< FRHOST_BIT13_INT_CLR
        constexpr uint32_t FRHOST_BIT14_INT_CLR = (1U << 6);  ///< FRHOST_BIT14_INT_CLR
        constexpr uint32_t FRHOST_BIT15_INT_CLR = (1U << 7);  ///< FRHOST_BIT15_INT_CLR
        constexpr uint32_t SLC1_RX_START_INT_CLR = (1U << 8);  ///< SLC1_RX_START_INT_CLR
        constexpr uint32_t SLC1_TX_START_INT_CLR = (1U << 9);  ///< SLC1_TX_START_INT_CLR
        constexpr uint32_t SLC1_RX_UDF_INT_CLR = (1U << 10);  ///< SLC1_RX_UDF_INT_CLR
        constexpr uint32_t SLC1_TX_OVF_INT_CLR = (1U << 11);  ///< SLC1_TX_OVF_INT_CLR
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_CLR = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_CLR
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_CLR = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_CLR
        constexpr uint32_t SLC1_TX_DONE_INT_CLR = (1U << 14);  ///< SLC1_TX_DONE_INT_CLR
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_CLR = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_CLR
        constexpr uint32_t SLC1_RX_DONE_INT_CLR = (1U << 16);  ///< SLC1_RX_DONE_INT_CLR
        constexpr uint32_t SLC1_RX_EOF_INT_CLR = (1U << 17);  ///< SLC1_RX_EOF_INT_CLR
        constexpr uint32_t SLC1_TOHOST_INT_CLR = (1U << 18);  ///< SLC1_TOHOST_INT_CLR
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_CLR = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_CLR = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_CLR
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_CLR = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_CLR
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_CLR = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_CLR
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_CLR = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_CLR
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_CLR = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_CLR
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t SLC0_RX_FULL = (1U << 0);  ///< SLC0_RX_FULL
        constexpr uint32_t SLC0_RX_EMPTY = (1U << 1);  ///< SLC0_RX_EMPTY
        constexpr uint32_t SLC1_RX_FULL = (1U << 16);  ///< SLC1_RX_FULL
        constexpr uint32_t SLC1_RX_EMPTY = (1U << 17);  ///< SLC1_RX_EMPTY
    }

    /// _0RXFIFO_PUSH Register bits
    namespace _0rxfifo_push_bits {
        constexpr uint32_t SLC0_RXFIFO_WDATA = (9 << 0);  ///< SLC0_RXFIFO_WDATA
        constexpr uint32_t SLC0_RXFIFO_PUSH = (1U << 16);  ///< SLC0_RXFIFO_PUSH
    }

    /// _1RXFIFO_PUSH Register bits
    namespace _1rxfifo_push_bits {
        constexpr uint32_t SLC1_RXFIFO_WDATA = (9 << 0);  ///< SLC1_RXFIFO_WDATA
        constexpr uint32_t SLC1_RXFIFO_PUSH = (1U << 16);  ///< SLC1_RXFIFO_PUSH
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t SLC0_TX_FULL = (1U << 0);  ///< SLC0_TX_FULL
        constexpr uint32_t SLC0_TX_EMPTY = (1U << 1);  ///< SLC0_TX_EMPTY
        constexpr uint32_t SLC1_TX_FULL = (1U << 16);  ///< SLC1_TX_FULL
        constexpr uint32_t SLC1_TX_EMPTY = (1U << 17);  ///< SLC1_TX_EMPTY
    }

    /// _0TXFIFO_POP Register bits
    namespace _0txfifo_pop_bits {
        constexpr uint32_t SLC0_TXFIFO_RDATA = (11 << 0);  ///< SLC0_TXFIFO_RDATA
        constexpr uint32_t SLC0_TXFIFO_POP = (1U << 16);  ///< SLC0_TXFIFO_POP
    }

    /// _1TXFIFO_POP Register bits
    namespace _1txfifo_pop_bits {
        constexpr uint32_t SLC1_TXFIFO_RDATA = (11 << 0);  ///< SLC1_TXFIFO_RDATA
        constexpr uint32_t SLC1_TXFIFO_POP = (1U << 16);  ///< SLC1_TXFIFO_POP
    }

    /// _0RX_LINK Register bits
    namespace _0rx_link_bits {
        constexpr uint32_t SLC0_RXLINK_ADDR = (20 << 0);  ///< SLC0_RXLINK_ADDR
        constexpr uint32_t SLC0_RXLINK_STOP = (1U << 28);  ///< SLC0_RXLINK_STOP
        constexpr uint32_t SLC0_RXLINK_START = (1U << 29);  ///< SLC0_RXLINK_START
        constexpr uint32_t SLC0_RXLINK_RESTART = (1U << 30);  ///< SLC0_RXLINK_RESTART
        constexpr uint32_t SLC0_RXLINK_PARK = (1U << 31);  ///< SLC0_RXLINK_PARK
    }

    /// _0TX_LINK Register bits
    namespace _0tx_link_bits {
        constexpr uint32_t SLC0_TXLINK_ADDR = (20 << 0);  ///< SLC0_TXLINK_ADDR
        constexpr uint32_t SLC0_TXLINK_STOP = (1U << 28);  ///< SLC0_TXLINK_STOP
        constexpr uint32_t SLC0_TXLINK_START = (1U << 29);  ///< SLC0_TXLINK_START
        constexpr uint32_t SLC0_TXLINK_RESTART = (1U << 30);  ///< SLC0_TXLINK_RESTART
        constexpr uint32_t SLC0_TXLINK_PARK = (1U << 31);  ///< SLC0_TXLINK_PARK
    }

    /// _1RX_LINK Register bits
    namespace _1rx_link_bits {
        constexpr uint32_t SLC1_RXLINK_ADDR = (20 << 0);  ///< SLC1_RXLINK_ADDR
        constexpr uint32_t SLC1_BT_PACKET = (1U << 20);  ///< SLC1_BT_PACKET
        constexpr uint32_t SLC1_RXLINK_STOP = (1U << 28);  ///< SLC1_RXLINK_STOP
        constexpr uint32_t SLC1_RXLINK_START = (1U << 29);  ///< SLC1_RXLINK_START
        constexpr uint32_t SLC1_RXLINK_RESTART = (1U << 30);  ///< SLC1_RXLINK_RESTART
        constexpr uint32_t SLC1_RXLINK_PARK = (1U << 31);  ///< SLC1_RXLINK_PARK
    }

    /// _1TX_LINK Register bits
    namespace _1tx_link_bits {
        constexpr uint32_t SLC1_TXLINK_ADDR = (20 << 0);  ///< SLC1_TXLINK_ADDR
        constexpr uint32_t SLC1_TXLINK_STOP = (1U << 28);  ///< SLC1_TXLINK_STOP
        constexpr uint32_t SLC1_TXLINK_START = (1U << 29);  ///< SLC1_TXLINK_START
        constexpr uint32_t SLC1_TXLINK_RESTART = (1U << 30);  ///< SLC1_TXLINK_RESTART
        constexpr uint32_t SLC1_TXLINK_PARK = (1U << 31);  ///< SLC1_TXLINK_PARK
    }

    /// INTVEC_TOHOST Register bits
    namespace intvec_tohost_bits {
        constexpr uint32_t SLC0_TOHOST_INTVEC = (8 << 0);  ///< SLC0_TOHOST_INTVEC
        constexpr uint32_t SLC1_TOHOST_INTVEC = (8 << 16);  ///< SLC1_TOHOST_INTVEC
    }

    /// _0TOKEN0 Register bits
    namespace _0token0_bits {
        constexpr uint32_t SLC0_TOKEN0_WDATA = (12 << 0);  ///< SLC0_TOKEN0_WDATA
        constexpr uint32_t SLC0_TOKEN0_WR = (1U << 12);  ///< SLC0_TOKEN0_WR
        constexpr uint32_t SLC0_TOKEN0_INC = (1U << 13);  ///< SLC0_TOKEN0_INC
        constexpr uint32_t SLC0_TOKEN0_INC_MORE = (1U << 14);  ///< SLC0_TOKEN0_INC_MORE
        constexpr uint32_t SLC0_TOKEN0 = (12 << 16);  ///< SLC0_TOKEN0
    }

    /// _0TOKEN1 Register bits
    namespace _0token1_bits {
        constexpr uint32_t SLC0_TOKEN1_WDATA = (12 << 0);  ///< SLC0_TOKEN1_WDATA
        constexpr uint32_t SLC0_TOKEN1_WR = (1U << 12);  ///< SLC0_TOKEN1_WR
        constexpr uint32_t SLC0_TOKEN1_INC = (1U << 13);  ///< SLC0_TOKEN1_INC
        constexpr uint32_t SLC0_TOKEN1_INC_MORE = (1U << 14);  ///< SLC0_TOKEN1_INC_MORE
        constexpr uint32_t SLC0_TOKEN1 = (12 << 16);  ///< SLC0_TOKEN1
    }

    /// _1TOKEN0 Register bits
    namespace _1token0_bits {
        constexpr uint32_t SLC1_TOKEN0_WDATA = (12 << 0);  ///< SLC1_TOKEN0_WDATA
        constexpr uint32_t SLC1_TOKEN0_WR = (1U << 12);  ///< SLC1_TOKEN0_WR
        constexpr uint32_t SLC1_TOKEN0_INC = (1U << 13);  ///< SLC1_TOKEN0_INC
        constexpr uint32_t SLC1_TOKEN0_INC_MORE = (1U << 14);  ///< SLC1_TOKEN0_INC_MORE
        constexpr uint32_t SLC1_TOKEN0 = (12 << 16);  ///< SLC1_TOKEN0
    }

    /// _1TOKEN1 Register bits
    namespace _1token1_bits {
        constexpr uint32_t SLC1_TOKEN1_WDATA = (12 << 0);  ///< SLC1_TOKEN1_WDATA
        constexpr uint32_t SLC1_TOKEN1_WR = (1U << 12);  ///< SLC1_TOKEN1_WR
        constexpr uint32_t SLC1_TOKEN1_INC = (1U << 13);  ///< SLC1_TOKEN1_INC
        constexpr uint32_t SLC1_TOKEN1_INC_MORE = (1U << 14);  ///< SLC1_TOKEN1_INC_MORE
        constexpr uint32_t SLC1_TOKEN1 = (12 << 16);  ///< SLC1_TOKEN1
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t SLC0_CHECK_OWNER = (1U << 0);  ///< SLC0_CHECK_OWNER
        constexpr uint32_t SLC0_TX_CHECK_SUM_EN = (1U << 1);  ///< SLC0_TX_CHECK_SUM_EN
        constexpr uint32_t SLC0_RX_CHECK_SUM_EN = (1U << 2);  ///< SLC0_RX_CHECK_SUM_EN
        constexpr uint32_t CMD_HOLD_EN = (1U << 3);  ///< CMD_HOLD_EN
        constexpr uint32_t SLC0_LEN_AUTO_CLR = (1U << 4);  ///< SLC0_LEN_AUTO_CLR
        constexpr uint32_t SLC0_TX_STITCH_EN = (1U << 5);  ///< SLC0_TX_STITCH_EN
        constexpr uint32_t SLC0_RX_STITCH_EN = (1U << 6);  ///< SLC0_RX_STITCH_EN
        constexpr uint32_t SLC1_CHECK_OWNER = (1U << 16);  ///< SLC1_CHECK_OWNER
        constexpr uint32_t SLC1_TX_CHECK_SUM_EN = (1U << 17);  ///< SLC1_TX_CHECK_SUM_EN
        constexpr uint32_t SLC1_RX_CHECK_SUM_EN = (1U << 18);  ///< SLC1_RX_CHECK_SUM_EN
        constexpr uint32_t HOST_INT_LEVEL_SEL = (1U << 19);  ///< HOST_INT_LEVEL_SEL
        constexpr uint32_t SLC1_TX_STITCH_EN = (1U << 20);  ///< SLC1_TX_STITCH_EN
        constexpr uint32_t SLC1_RX_STITCH_EN = (1U << 21);  ///< SLC1_RX_STITCH_EN
        constexpr uint32_t CLK_EN = (1U << 22);  ///< CLK_EN
    }

    /// _0_STATE0 Register bits
    namespace _0_state0_bits {
        constexpr uint32_t SLC0_STATE0 = (32 << 0);  ///< SLC0_STATE0
    }

    /// _0_STATE1 Register bits
    namespace _0_state1_bits {
        constexpr uint32_t SLC0_STATE1 = (32 << 0);  ///< SLC0_STATE1
    }

    /// _1_STATE0 Register bits
    namespace _1_state0_bits {
        constexpr uint32_t SLC1_STATE0 = (32 << 0);  ///< SLC1_STATE0
    }

    /// _1_STATE1 Register bits
    namespace _1_state1_bits {
        constexpr uint32_t SLC1_STATE1 = (32 << 0);  ///< SLC1_STATE1
    }

    /// BRIDGE_CONF Register bits
    namespace bridge_conf_bits {
        constexpr uint32_t TXEOF_ENA = (6 << 0);  ///< TXEOF_ENA
        constexpr uint32_t FIFO_MAP_ENA = (4 << 8);  ///< FIFO_MAP_ENA
        constexpr uint32_t SLC0_TX_DUMMY_MODE = (1U << 12);  ///< SLC0_TX_DUMMY_MODE
        constexpr uint32_t HDA_MAP_128K = (1U << 13);  ///< HDA_MAP_128K
        constexpr uint32_t SLC1_TX_DUMMY_MODE = (1U << 14);  ///< SLC1_TX_DUMMY_MODE
        constexpr uint32_t TX_PUSH_IDLE_NUM = (16 << 16);  ///< TX_PUSH_IDLE_NUM
    }

    /// _0_TO_EOF_DES_ADDR Register bits
    namespace _0_to_eof_des_addr_bits {
        constexpr uint32_t SLC0_TO_EOF_DES_ADDR = (32 << 0);  ///< SLC0_TO_EOF_DES_ADDR
    }

    /// _0_TX_EOF_DES_ADDR Register bits
    namespace _0_tx_eof_des_addr_bits {
        constexpr uint32_t SLC0_TX_SUC_EOF_DES_ADDR = (32 << 0);  ///< SLC0_TX_SUC_EOF_DES_ADDR
    }

    /// _0_TO_EOF_BFR_DES_ADDR Register bits
    namespace _0_to_eof_bfr_des_addr_bits {
        constexpr uint32_t SLC0_TO_EOF_BFR_DES_ADDR = (32 << 0);  ///< SLC0_TO_EOF_BFR_DES_ADDR
    }

    /// _1_TO_EOF_DES_ADDR Register bits
    namespace _1_to_eof_des_addr_bits {
        constexpr uint32_t SLC1_TO_EOF_DES_ADDR = (32 << 0);  ///< SLC1_TO_EOF_DES_ADDR
    }

    /// _1_TX_EOF_DES_ADDR Register bits
    namespace _1_tx_eof_des_addr_bits {
        constexpr uint32_t SLC1_TX_SUC_EOF_DES_ADDR = (32 << 0);  ///< SLC1_TX_SUC_EOF_DES_ADDR
    }

    /// _1_TO_EOF_BFR_DES_ADDR Register bits
    namespace _1_to_eof_bfr_des_addr_bits {
        constexpr uint32_t SLC1_TO_EOF_BFR_DES_ADDR = (32 << 0);  ///< SLC1_TO_EOF_BFR_DES_ADDR
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< AHB_TESTMODE
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< AHB_TESTADDR
    }

    /// SDIO_ST Register bits
    namespace sdio_st_bits {
        constexpr uint32_t CMD_ST = (3 << 0);  ///< CMD_ST
        constexpr uint32_t FUNC_ST = (4 << 4);  ///< FUNC_ST
        constexpr uint32_t SDIO_WAKEUP = (1U << 8);  ///< SDIO_WAKEUP
        constexpr uint32_t BUS_ST = (3 << 12);  ///< BUS_ST
        constexpr uint32_t FUNC1_ACC_STATE = (5 << 16);  ///< FUNC1_ACC_STATE
        constexpr uint32_t FUNC2_ACC_STATE = (5 << 24);  ///< FUNC2_ACC_STATE
    }

    /// RX_DSCR_CONF Register bits
    namespace rx_dscr_conf_bits {
        constexpr uint32_t SLC0_TOKEN_NO_REPLACE = (1U << 0);  ///< SLC0_TOKEN_NO_REPLACE
        constexpr uint32_t SLC0_INFOR_NO_REPLACE = (1U << 1);  ///< SLC0_INFOR_NO_REPLACE
        constexpr uint32_t SLC0_RX_FILL_MODE = (1U << 2);  ///< SLC0_RX_FILL_MODE
        constexpr uint32_t SLC0_RX_EOF_MODE = (1U << 3);  ///< SLC0_RX_EOF_MODE
        constexpr uint32_t SLC0_RX_FILL_EN = (1U << 4);  ///< SLC0_RX_FILL_EN
        constexpr uint32_t SLC0_RD_RETRY_THRESHOLD = (11 << 5);  ///< SLC0_RD_RETRY_THRESHOLD
        constexpr uint32_t SLC1_TOKEN_NO_REPLACE = (1U << 16);  ///< SLC1_TOKEN_NO_REPLACE
        constexpr uint32_t SLC1_INFOR_NO_REPLACE = (1U << 17);  ///< SLC1_INFOR_NO_REPLACE
        constexpr uint32_t SLC1_RX_FILL_MODE = (1U << 18);  ///< SLC1_RX_FILL_MODE
        constexpr uint32_t SLC1_RX_EOF_MODE = (1U << 19);  ///< SLC1_RX_EOF_MODE
        constexpr uint32_t SLC1_RX_FILL_EN = (1U << 20);  ///< SLC1_RX_FILL_EN
        constexpr uint32_t SLC1_RD_RETRY_THRESHOLD = (11 << 21);  ///< SLC1_RD_RETRY_THRESHOLD
    }

    /// _0_TXLINK_DSCR Register bits
    namespace _0_txlink_dscr_bits {
        constexpr uint32_t SLC0_TXLINK_DSCR = (32 << 0);  ///< SLC0_TXLINK_DSCR
    }

    /// _0_TXLINK_DSCR_BF0 Register bits
    namespace _0_txlink_dscr_bf0_bits {
        constexpr uint32_t SLC0_TXLINK_DSCR_BF0 = (32 << 0);  ///< SLC0_TXLINK_DSCR_BF0
    }

    /// _0_TXLINK_DSCR_BF1 Register bits
    namespace _0_txlink_dscr_bf1_bits {
        constexpr uint32_t SLC0_TXLINK_DSCR_BF1 = (32 << 0);  ///< SLC0_TXLINK_DSCR_BF1
    }

    /// _0_RXLINK_DSCR Register bits
    namespace _0_rxlink_dscr_bits {
        constexpr uint32_t SLC0_RXLINK_DSCR = (32 << 0);  ///< SLC0_RXLINK_DSCR
    }

    /// _0_RXLINK_DSCR_BF0 Register bits
    namespace _0_rxlink_dscr_bf0_bits {
        constexpr uint32_t SLC0_RXLINK_DSCR_BF0 = (32 << 0);  ///< SLC0_RXLINK_DSCR_BF0
    }

    /// _0_RXLINK_DSCR_BF1 Register bits
    namespace _0_rxlink_dscr_bf1_bits {
        constexpr uint32_t SLC0_RXLINK_DSCR_BF1 = (32 << 0);  ///< SLC0_RXLINK_DSCR_BF1
    }

    /// _1_TXLINK_DSCR Register bits
    namespace _1_txlink_dscr_bits {
        constexpr uint32_t SLC1_TXLINK_DSCR = (32 << 0);  ///< SLC1_TXLINK_DSCR
    }

    /// _1_TXLINK_DSCR_BF0 Register bits
    namespace _1_txlink_dscr_bf0_bits {
        constexpr uint32_t SLC1_TXLINK_DSCR_BF0 = (32 << 0);  ///< SLC1_TXLINK_DSCR_BF0
    }

    /// _1_TXLINK_DSCR_BF1 Register bits
    namespace _1_txlink_dscr_bf1_bits {
        constexpr uint32_t SLC1_TXLINK_DSCR_BF1 = (32 << 0);  ///< SLC1_TXLINK_DSCR_BF1
    }

    /// _1_RXLINK_DSCR Register bits
    namespace _1_rxlink_dscr_bits {
        constexpr uint32_t SLC1_RXLINK_DSCR = (32 << 0);  ///< SLC1_RXLINK_DSCR
    }

    /// _1_RXLINK_DSCR_BF0 Register bits
    namespace _1_rxlink_dscr_bf0_bits {
        constexpr uint32_t SLC1_RXLINK_DSCR_BF0 = (32 << 0);  ///< SLC1_RXLINK_DSCR_BF0
    }

    /// _1_RXLINK_DSCR_BF1 Register bits
    namespace _1_rxlink_dscr_bf1_bits {
        constexpr uint32_t SLC1_RXLINK_DSCR_BF1 = (32 << 0);  ///< SLC1_RXLINK_DSCR_BF1
    }

    /// _0_TX_ERREOF_DES_ADDR Register bits
    namespace _0_tx_erreof_des_addr_bits {
        constexpr uint32_t SLC0_TX_ERR_EOF_DES_ADDR = (32 << 0);  ///< SLC0_TX_ERR_EOF_DES_ADDR
    }

    /// _1_TX_ERREOF_DES_ADDR Register bits
    namespace _1_tx_erreof_des_addr_bits {
        constexpr uint32_t SLC1_TX_ERR_EOF_DES_ADDR = (32 << 0);  ///< SLC1_TX_ERR_EOF_DES_ADDR
    }

    /// TOKEN_LAT Register bits
    namespace token_lat_bits {
        constexpr uint32_t SLC0_TOKEN = (12 << 0);  ///< SLC0_TOKEN
        constexpr uint32_t SLC1_TOKEN = (12 << 16);  ///< SLC1_TOKEN
    }

    /// TX_DSCR_CONF Register bits
    namespace tx_dscr_conf_bits {
        constexpr uint32_t WR_RETRY_THRESHOLD = (11 << 0);  ///< WR_RETRY_THRESHOLD
    }

    /// CMD_INFOR0 Register bits
    namespace cmd_infor0_bits {
        constexpr uint32_t CMD_CONTENT0 = (32 << 0);  ///< CMD_CONTENT0
    }

    /// CMD_INFOR1 Register bits
    namespace cmd_infor1_bits {
        constexpr uint32_t CMD_CONTENT1 = (32 << 0);  ///< CMD_CONTENT1
    }

    /// _0_LEN_CONF Register bits
    namespace _0_len_conf_bits {
        constexpr uint32_t SLC0_LEN_WDATA = (20 << 0);  ///< SLC0_LEN_WDATA
        constexpr uint32_t SLC0_LEN_WR = (1U << 20);  ///< SLC0_LEN_WR
        constexpr uint32_t SLC0_LEN_INC = (1U << 21);  ///< SLC0_LEN_INC
        constexpr uint32_t SLC0_LEN_INC_MORE = (1U << 22);  ///< SLC0_LEN_INC_MORE
        constexpr uint32_t SLC0_RX_PACKET_LOAD_EN = (1U << 23);  ///< SLC0_RX_PACKET_LOAD_EN
        constexpr uint32_t SLC0_TX_PACKET_LOAD_EN = (1U << 24);  ///< SLC0_TX_PACKET_LOAD_EN
        constexpr uint32_t SLC0_RX_GET_USED_DSCR = (1U << 25);  ///< SLC0_RX_GET_USED_DSCR
        constexpr uint32_t SLC0_TX_GET_USED_DSCR = (1U << 26);  ///< SLC0_TX_GET_USED_DSCR
        constexpr uint32_t SLC0_RX_NEW_PKT_IND = (1U << 27);  ///< SLC0_RX_NEW_PKT_IND
        constexpr uint32_t SLC0_TX_NEW_PKT_IND = (1U << 28);  ///< SLC0_TX_NEW_PKT_IND
    }

    /// _0_LENGTH Register bits
    namespace _0_length_bits {
        constexpr uint32_t SLC0_LEN = (20 << 0);  ///< SLC0_LEN
    }

    /// _0_TXPKT_H_DSCR Register bits
    namespace _0_txpkt_h_dscr_bits {
        constexpr uint32_t SLC0_TX_PKT_H_DSCR_ADDR = (32 << 0);  ///< SLC0_TX_PKT_H_DSCR_ADDR
    }

    /// _0_TXPKT_E_DSCR Register bits
    namespace _0_txpkt_e_dscr_bits {
        constexpr uint32_t SLC0_TX_PKT_E_DSCR_ADDR = (32 << 0);  ///< SLC0_TX_PKT_E_DSCR_ADDR
    }

    /// _0_RXPKT_H_DSCR Register bits
    namespace _0_rxpkt_h_dscr_bits {
        constexpr uint32_t SLC0_RX_PKT_H_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_PKT_H_DSCR_ADDR
    }

    /// _0_RXPKT_E_DSCR Register bits
    namespace _0_rxpkt_e_dscr_bits {
        constexpr uint32_t SLC0_RX_PKT_E_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_PKT_E_DSCR_ADDR
    }

    /// _0_TXPKTU_H_DSCR Register bits
    namespace _0_txpktu_h_dscr_bits {
        constexpr uint32_t SLC0_TX_PKT_START_DSCR_ADDR = (32 << 0);  ///< SLC0_TX_PKT_START_DSCR_ADDR
    }

    /// _0_TXPKTU_E_DSCR Register bits
    namespace _0_txpktu_e_dscr_bits {
        constexpr uint32_t SLC0_TX_PKT_END_DSCR_ADDR = (32 << 0);  ///< SLC0_TX_PKT_END_DSCR_ADDR
    }

    /// _0_RXPKTU_H_DSCR Register bits
    namespace _0_rxpktu_h_dscr_bits {
        constexpr uint32_t SLC0_RX_PKT_START_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_PKT_START_DSCR_ADDR
    }

    /// _0_RXPKTU_E_DSCR Register bits
    namespace _0_rxpktu_e_dscr_bits {
        constexpr uint32_t SLC0_RX_PKT_END_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_PKT_END_DSCR_ADDR
    }

    /// SEQ_POSITION Register bits
    namespace seq_position_bits {
        constexpr uint32_t SLC0_SEQ_POSITION = (8 << 0);  ///< SLC0_SEQ_POSITION
        constexpr uint32_t SLC1_SEQ_POSITION = (8 << 8);  ///< SLC1_SEQ_POSITION
    }

    /// _0_DSCR_REC_CONF Register bits
    namespace _0_dscr_rec_conf_bits {
        constexpr uint32_t SLC0_RX_DSCR_REC_LIM = (10 << 0);  ///< SLC0_RX_DSCR_REC_LIM
    }

    /// SDIO_CRC_ST0 Register bits
    namespace sdio_crc_st0_bits {
        constexpr uint32_t DAT0_CRC_ERR_CNT = (8 << 0);  ///< DAT0_CRC_ERR_CNT
        constexpr uint32_t DAT1_CRC_ERR_CNT = (8 << 8);  ///< DAT1_CRC_ERR_CNT
        constexpr uint32_t DAT2_CRC_ERR_CNT = (8 << 16);  ///< DAT2_CRC_ERR_CNT
        constexpr uint32_t DAT3_CRC_ERR_CNT = (8 << 24);  ///< DAT3_CRC_ERR_CNT
    }

    /// SDIO_CRC_ST1 Register bits
    namespace sdio_crc_st1_bits {
        constexpr uint32_t CMD_CRC_ERR_CNT = (8 << 0);  ///< CMD_CRC_ERR_CNT
        constexpr uint32_t ERR_CNT_CLR = (1U << 31);  ///< ERR_CNT_CLR
    }

    /// _0_EOF_START_DES Register bits
    namespace _0_eof_start_des_bits {
        constexpr uint32_t SLC0_EOF_START_DES_ADDR = (32 << 0);  ///< SLC0_EOF_START_DES_ADDR
    }

    /// _0_PUSH_DSCR_ADDR Register bits
    namespace _0_push_dscr_addr_bits {
        constexpr uint32_t SLC0_RX_PUSH_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_PUSH_DSCR_ADDR
    }

    /// _0_DONE_DSCR_ADDR Register bits
    namespace _0_done_dscr_addr_bits {
        constexpr uint32_t SLC0_RX_DONE_DSCR_ADDR = (32 << 0);  ///< SLC0_RX_DONE_DSCR_ADDR
    }

    /// _0_SUB_START_DES Register bits
    namespace _0_sub_start_des_bits {
        constexpr uint32_t SLC0_SUB_PAC_START_DSCR_ADDR = (32 << 0);  ///< SLC0_SUB_PAC_START_DSCR_ADDR
    }

    /// _0_DSCR_CNT Register bits
    namespace _0_dscr_cnt_bits {
        constexpr uint32_t SLC0_RX_DSCR_CNT_LAT = (10 << 0);  ///< SLC0_RX_DSCR_CNT_LAT
        constexpr uint32_t SLC0_RX_GET_EOF_OCC = (1U << 16);  ///< SLC0_RX_GET_EOF_OCC
    }

    /// _0_LEN_LIM_CONF Register bits
    namespace _0_len_lim_conf_bits {
        constexpr uint32_t SLC0_LEN_LIM = (20 << 0);  ///< SLC0_LEN_LIM
    }

    /// _0INT_ST1 Register bits
    namespace _0int_st1_bits {
        constexpr uint32_t FRHOST_BIT0_INT_ST1 = (1U << 0);  ///< FRHOST_BIT0_INT_ST1
        constexpr uint32_t FRHOST_BIT1_INT_ST1 = (1U << 1);  ///< FRHOST_BIT1_INT_ST1
        constexpr uint32_t FRHOST_BIT2_INT_ST1 = (1U << 2);  ///< FRHOST_BIT2_INT_ST1
        constexpr uint32_t FRHOST_BIT3_INT_ST1 = (1U << 3);  ///< FRHOST_BIT3_INT_ST1
        constexpr uint32_t FRHOST_BIT4_INT_ST1 = (1U << 4);  ///< FRHOST_BIT4_INT_ST1
        constexpr uint32_t FRHOST_BIT5_INT_ST1 = (1U << 5);  ///< FRHOST_BIT5_INT_ST1
        constexpr uint32_t FRHOST_BIT6_INT_ST1 = (1U << 6);  ///< FRHOST_BIT6_INT_ST1
        constexpr uint32_t FRHOST_BIT7_INT_ST1 = (1U << 7);  ///< FRHOST_BIT7_INT_ST1
        constexpr uint32_t SLC0_RX_START_INT_ST1 = (1U << 8);  ///< SLC0_RX_START_INT_ST1
        constexpr uint32_t SLC0_TX_START_INT_ST1 = (1U << 9);  ///< SLC0_TX_START_INT_ST1
        constexpr uint32_t SLC0_RX_UDF_INT_ST1 = (1U << 10);  ///< SLC0_RX_UDF_INT_ST1
        constexpr uint32_t SLC0_TX_OVF_INT_ST1 = (1U << 11);  ///< SLC0_TX_OVF_INT_ST1
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_ST1 = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_ST1
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_ST1 = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_ST1
        constexpr uint32_t SLC0_TX_DONE_INT_ST1 = (1U << 14);  ///< SLC0_TX_DONE_INT_ST1
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_ST1 = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_ST1
        constexpr uint32_t SLC0_RX_DONE_INT_ST1 = (1U << 16);  ///< SLC0_RX_DONE_INT_ST1
        constexpr uint32_t SLC0_RX_EOF_INT_ST1 = (1U << 17);  ///< SLC0_RX_EOF_INT_ST1
        constexpr uint32_t SLC0_TOHOST_INT_ST1 = (1U << 18);  ///< SLC0_TOHOST_INT_ST1
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_ST1 = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_ST1
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_ST1 = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_ST1
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_ST1 = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_ST1
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_ST1 = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_ST1
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_ST1 = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_ST1
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_ST1 = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_ST1
        constexpr uint32_t CMD_DTC_INT_ST1 = (1U << 25);  ///< CMD_DTC_INT_ST1
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_ST1 = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_ST1
    }

    /// _0INT_ENA1 Register bits
    namespace _0int_ena1_bits {
        constexpr uint32_t FRHOST_BIT0_INT_ENA1 = (1U << 0);  ///< FRHOST_BIT0_INT_ENA1
        constexpr uint32_t FRHOST_BIT1_INT_ENA1 = (1U << 1);  ///< FRHOST_BIT1_INT_ENA1
        constexpr uint32_t FRHOST_BIT2_INT_ENA1 = (1U << 2);  ///< FRHOST_BIT2_INT_ENA1
        constexpr uint32_t FRHOST_BIT3_INT_ENA1 = (1U << 3);  ///< FRHOST_BIT3_INT_ENA1
        constexpr uint32_t FRHOST_BIT4_INT_ENA1 = (1U << 4);  ///< FRHOST_BIT4_INT_ENA1
        constexpr uint32_t FRHOST_BIT5_INT_ENA1 = (1U << 5);  ///< FRHOST_BIT5_INT_ENA1
        constexpr uint32_t FRHOST_BIT6_INT_ENA1 = (1U << 6);  ///< FRHOST_BIT6_INT_ENA1
        constexpr uint32_t FRHOST_BIT7_INT_ENA1 = (1U << 7);  ///< FRHOST_BIT7_INT_ENA1
        constexpr uint32_t SLC0_RX_START_INT_ENA1 = (1U << 8);  ///< SLC0_RX_START_INT_ENA1
        constexpr uint32_t SLC0_TX_START_INT_ENA1 = (1U << 9);  ///< SLC0_TX_START_INT_ENA1
        constexpr uint32_t SLC0_RX_UDF_INT_ENA1 = (1U << 10);  ///< SLC0_RX_UDF_INT_ENA1
        constexpr uint32_t SLC0_TX_OVF_INT_ENA1 = (1U << 11);  ///< SLC0_TX_OVF_INT_ENA1
        constexpr uint32_t SLC0_TOKEN0_1TO0_INT_ENA1 = (1U << 12);  ///< SLC0_TOKEN0_1TO0_INT_ENA1
        constexpr uint32_t SLC0_TOKEN1_1TO0_INT_ENA1 = (1U << 13);  ///< SLC0_TOKEN1_1TO0_INT_ENA1
        constexpr uint32_t SLC0_TX_DONE_INT_ENA1 = (1U << 14);  ///< SLC0_TX_DONE_INT_ENA1
        constexpr uint32_t SLC0_TX_SUC_EOF_INT_ENA1 = (1U << 15);  ///< SLC0_TX_SUC_EOF_INT_ENA1
        constexpr uint32_t SLC0_RX_DONE_INT_ENA1 = (1U << 16);  ///< SLC0_RX_DONE_INT_ENA1
        constexpr uint32_t SLC0_RX_EOF_INT_ENA1 = (1U << 17);  ///< SLC0_RX_EOF_INT_ENA1
        constexpr uint32_t SLC0_TOHOST_INT_ENA1 = (1U << 18);  ///< SLC0_TOHOST_INT_ENA1
        constexpr uint32_t SLC0_TX_DSCR_ERR_INT_ENA1 = (1U << 19);  ///< SLC0_TX_DSCR_ERR_INT_ENA1
        constexpr uint32_t SLC0_RX_DSCR_ERR_INT_ENA1 = (1U << 20);  ///< SLC0_RX_DSCR_ERR_INT_ENA1
        constexpr uint32_t SLC0_TX_DSCR_EMPTY_INT_ENA1 = (1U << 21);  ///< SLC0_TX_DSCR_EMPTY_INT_ENA1
        constexpr uint32_t SLC0_HOST_RD_ACK_INT_ENA1 = (1U << 22);  ///< SLC0_HOST_RD_ACK_INT_ENA1
        constexpr uint32_t SLC0_WR_RETRY_DONE_INT_ENA1 = (1U << 23);  ///< SLC0_WR_RETRY_DONE_INT_ENA1
        constexpr uint32_t SLC0_TX_ERR_EOF_INT_ENA1 = (1U << 24);  ///< SLC0_TX_ERR_EOF_INT_ENA1
        constexpr uint32_t CMD_DTC_INT_ENA1 = (1U << 25);  ///< CMD_DTC_INT_ENA1
        constexpr uint32_t SLC0_RX_QUICK_EOF_INT_ENA1 = (1U << 26);  ///< SLC0_RX_QUICK_EOF_INT_ENA1
    }

    /// _1INT_ST1 Register bits
    namespace _1int_st1_bits {
        constexpr uint32_t FRHOST_BIT8_INT_ST1 = (1U << 0);  ///< FRHOST_BIT8_INT_ST1
        constexpr uint32_t FRHOST_BIT9_INT_ST1 = (1U << 1);  ///< FRHOST_BIT9_INT_ST1
        constexpr uint32_t FRHOST_BIT10_INT_ST1 = (1U << 2);  ///< FRHOST_BIT10_INT_ST1
        constexpr uint32_t FRHOST_BIT11_INT_ST1 = (1U << 3);  ///< FRHOST_BIT11_INT_ST1
        constexpr uint32_t FRHOST_BIT12_INT_ST1 = (1U << 4);  ///< FRHOST_BIT12_INT_ST1
        constexpr uint32_t FRHOST_BIT13_INT_ST1 = (1U << 5);  ///< FRHOST_BIT13_INT_ST1
        constexpr uint32_t FRHOST_BIT14_INT_ST1 = (1U << 6);  ///< FRHOST_BIT14_INT_ST1
        constexpr uint32_t FRHOST_BIT15_INT_ST1 = (1U << 7);  ///< FRHOST_BIT15_INT_ST1
        constexpr uint32_t SLC1_RX_START_INT_ST1 = (1U << 8);  ///< SLC1_RX_START_INT_ST1
        constexpr uint32_t SLC1_TX_START_INT_ST1 = (1U << 9);  ///< SLC1_TX_START_INT_ST1
        constexpr uint32_t SLC1_RX_UDF_INT_ST1 = (1U << 10);  ///< SLC1_RX_UDF_INT_ST1
        constexpr uint32_t SLC1_TX_OVF_INT_ST1 = (1U << 11);  ///< SLC1_TX_OVF_INT_ST1
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_ST1 = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_ST1
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_ST1 = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_ST1
        constexpr uint32_t SLC1_TX_DONE_INT_ST1 = (1U << 14);  ///< SLC1_TX_DONE_INT_ST1
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_ST1 = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_ST1
        constexpr uint32_t SLC1_RX_DONE_INT_ST1 = (1U << 16);  ///< SLC1_RX_DONE_INT_ST1
        constexpr uint32_t SLC1_RX_EOF_INT_ST1 = (1U << 17);  ///< SLC1_RX_EOF_INT_ST1
        constexpr uint32_t SLC1_TOHOST_INT_ST1 = (1U << 18);  ///< SLC1_TOHOST_INT_ST1
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_ST1 = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_ST1
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_ST1 = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_ST1
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_ST1 = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_ST1
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_ST1 = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_ST1
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_ST1 = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_ST1
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_ST1 = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_ST1
    }

    /// _1INT_ENA1 Register bits
    namespace _1int_ena1_bits {
        constexpr uint32_t FRHOST_BIT8_INT_ENA1 = (1U << 0);  ///< FRHOST_BIT8_INT_ENA1
        constexpr uint32_t FRHOST_BIT9_INT_ENA1 = (1U << 1);  ///< FRHOST_BIT9_INT_ENA1
        constexpr uint32_t FRHOST_BIT10_INT_ENA1 = (1U << 2);  ///< FRHOST_BIT10_INT_ENA1
        constexpr uint32_t FRHOST_BIT11_INT_ENA1 = (1U << 3);  ///< FRHOST_BIT11_INT_ENA1
        constexpr uint32_t FRHOST_BIT12_INT_ENA1 = (1U << 4);  ///< FRHOST_BIT12_INT_ENA1
        constexpr uint32_t FRHOST_BIT13_INT_ENA1 = (1U << 5);  ///< FRHOST_BIT13_INT_ENA1
        constexpr uint32_t FRHOST_BIT14_INT_ENA1 = (1U << 6);  ///< FRHOST_BIT14_INT_ENA1
        constexpr uint32_t FRHOST_BIT15_INT_ENA1 = (1U << 7);  ///< FRHOST_BIT15_INT_ENA1
        constexpr uint32_t SLC1_RX_START_INT_ENA1 = (1U << 8);  ///< SLC1_RX_START_INT_ENA1
        constexpr uint32_t SLC1_TX_START_INT_ENA1 = (1U << 9);  ///< SLC1_TX_START_INT_ENA1
        constexpr uint32_t SLC1_RX_UDF_INT_ENA1 = (1U << 10);  ///< SLC1_RX_UDF_INT_ENA1
        constexpr uint32_t SLC1_TX_OVF_INT_ENA1 = (1U << 11);  ///< SLC1_TX_OVF_INT_ENA1
        constexpr uint32_t SLC1_TOKEN0_1TO0_INT_ENA1 = (1U << 12);  ///< SLC1_TOKEN0_1TO0_INT_ENA1
        constexpr uint32_t SLC1_TOKEN1_1TO0_INT_ENA1 = (1U << 13);  ///< SLC1_TOKEN1_1TO0_INT_ENA1
        constexpr uint32_t SLC1_TX_DONE_INT_ENA1 = (1U << 14);  ///< SLC1_TX_DONE_INT_ENA1
        constexpr uint32_t SLC1_TX_SUC_EOF_INT_ENA1 = (1U << 15);  ///< SLC1_TX_SUC_EOF_INT_ENA1
        constexpr uint32_t SLC1_RX_DONE_INT_ENA1 = (1U << 16);  ///< SLC1_RX_DONE_INT_ENA1
        constexpr uint32_t SLC1_RX_EOF_INT_ENA1 = (1U << 17);  ///< SLC1_RX_EOF_INT_ENA1
        constexpr uint32_t SLC1_TOHOST_INT_ENA1 = (1U << 18);  ///< SLC1_TOHOST_INT_ENA1
        constexpr uint32_t SLC1_TX_DSCR_ERR_INT_ENA1 = (1U << 19);  ///< SLC1_TX_DSCR_ERR_INT_ENA1
        constexpr uint32_t SLC1_RX_DSCR_ERR_INT_ENA1 = (1U << 20);  ///< SLC1_RX_DSCR_ERR_INT_ENA1
        constexpr uint32_t SLC1_TX_DSCR_EMPTY_INT_ENA1 = (1U << 21);  ///< SLC1_TX_DSCR_EMPTY_INT_ENA1
        constexpr uint32_t SLC1_HOST_RD_ACK_INT_ENA1 = (1U << 22);  ///< SLC1_HOST_RD_ACK_INT_ENA1
        constexpr uint32_t SLC1_WR_RETRY_DONE_INT_ENA1 = (1U << 23);  ///< SLC1_WR_RETRY_DONE_INT_ENA1
        constexpr uint32_t SLC1_TX_ERR_EOF_INT_ENA1 = (1U << 24);  ///< SLC1_TX_ERR_EOF_INT_ENA1
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< ID
    }

}

// ============================================================================
// SLCHOST Peripheral
// ============================================================================

namespace slchost {
    /// Base addresses
    constexpr uint32_t SLCHOST_BASE = 0x3FF55000;

    /// SLCHOST Register structure
    struct Registers {
        volatile uint32_t HOST_SLCHOST_FUNC2_0;  ///< Offset: 0x10 - 
        volatile uint32_t HOST_SLCHOST_FUNC2_1;  ///< Offset: 0x14 - 
        volatile uint32_t HOST_SLCHOST_FUNC2_2;  ///< Offset: 0x20 - 
        volatile uint32_t HOST_SLCHOST_GPIO_STATUS0;  ///< Offset: 0x34 - 
        volatile uint32_t HOST_SLCHOST_GPIO_STATUS1;  ///< Offset: 0x38 - 
        volatile uint32_t HOST_SLCHOST_GPIO_IN0;  ///< Offset: 0x3C - 
        volatile uint32_t HOST_SLCHOST_GPIO_IN1;  ///< Offset: 0x40 - 
        volatile uint32_t HOST_SLC0HOST_TOKEN_RDATA;  ///< Offset: 0x44 - 
        volatile uint32_t HOST_SLC0_HOST_PF;  ///< Offset: 0x48 - 
        volatile uint32_t HOST_SLC1_HOST_PF;  ///< Offset: 0x4C - 
        volatile uint32_t HOST_SLC0HOST_INT_RAW;  ///< Offset: 0x50 - 
        volatile uint32_t HOST_SLC1HOST_INT_RAW;  ///< Offset: 0x54 - 
        volatile uint32_t HOST_SLC0HOST_INT_ST;  ///< Offset: 0x58 - 
        volatile uint32_t HOST_SLC1HOST_INT_ST;  ///< Offset: 0x5C - 
        volatile uint32_t HOST_SLCHOST_PKT_LEN;  ///< Offset: 0x60 - 
        volatile uint32_t HOST_SLCHOST_STATE_W0;  ///< Offset: 0x64 - 
        volatile uint32_t HOST_SLCHOST_STATE_W1;  ///< Offset: 0x68 - 
        volatile uint32_t HOST_SLCHOST_CONF_W0;  ///< Offset: 0x6C - 
        volatile uint32_t HOST_SLCHOST_CONF_W1;  ///< Offset: 0x70 - 
        volatile uint32_t HOST_SLCHOST_CONF_W2;  ///< Offset: 0x74 - 
        volatile uint32_t HOST_SLCHOST_CONF_W3;  ///< Offset: 0x78 - 
        volatile uint32_t HOST_SLCHOST_CONF_W4;  ///< Offset: 0x7C - SLC timeout value
        volatile uint32_t HOST_SLCHOST_CONF_W5;  ///< Offset: 0x80 - 
        volatile uint32_t HOST_SLCHOST_WIN_CMD;  ///< Offset: 0x84 - 
        volatile uint32_t HOST_SLCHOST_CONF_W6;  ///< Offset: 0x88 - 
        volatile uint32_t HOST_SLCHOST_CONF_W7;  ///< Offset: 0x8C - 
        volatile uint32_t HOST_SLCHOST_PKT_LEN0;  ///< Offset: 0x90 - 
        volatile uint32_t HOST_SLCHOST_PKT_LEN1;  ///< Offset: 0x94 - 
        volatile uint32_t HOST_SLCHOST_PKT_LEN2;  ///< Offset: 0x98 - 
        volatile uint32_t HOST_SLCHOST_CONF_W8;  ///< Offset: 0x9C - 
        volatile uint32_t HOST_SLCHOST_CONF_W9;  ///< Offset: 0xA0 - 
        volatile uint32_t HOST_SLCHOST_CONF_W10;  ///< Offset: 0xA4 - 
        volatile uint32_t HOST_SLCHOST_CONF_W11;  ///< Offset: 0xA8 - 
        volatile uint32_t HOST_SLCHOST_CONF_W12;  ///< Offset: 0xAC - 
        volatile uint32_t HOST_SLCHOST_CONF_W13;  ///< Offset: 0xB0 - 
        volatile uint32_t HOST_SLCHOST_CONF_W14;  ///< Offset: 0xB4 - 
        volatile uint32_t HOST_SLCHOST_CONF_W15;  ///< Offset: 0xB8 - 
        volatile uint32_t HOST_SLCHOST_CHECK_SUM0;  ///< Offset: 0xBC - 
        volatile uint32_t HOST_SLCHOST_CHECK_SUM1;  ///< Offset: 0xC0 - 
        volatile uint32_t HOST_SLC1HOST_TOKEN_RDATA;  ///< Offset: 0xC4 - 
        volatile uint32_t HOST_SLC0HOST_TOKEN_WDATA;  ///< Offset: 0xC8 - 
        volatile uint32_t HOST_SLC1HOST_TOKEN_WDATA;  ///< Offset: 0xCC - 
        volatile uint32_t HOST_SLCHOST_TOKEN_CON;  ///< Offset: 0xD0 - 
        volatile uint32_t HOST_SLC0HOST_INT_CLR;  ///< Offset: 0xD4 - 
        volatile uint32_t HOST_SLC1HOST_INT_CLR;  ///< Offset: 0xD8 - 
        volatile uint32_t HOST_SLC0HOST_FUNC1_INT_ENA;  ///< Offset: 0xDC - 
        volatile uint32_t HOST_SLC1HOST_FUNC1_INT_ENA;  ///< Offset: 0xE0 - 
        volatile uint32_t HOST_SLC0HOST_FUNC2_INT_ENA;  ///< Offset: 0xE4 - 
        volatile uint32_t HOST_SLC1HOST_FUNC2_INT_ENA;  ///< Offset: 0xE8 - 
        volatile uint32_t HOST_SLC0HOST_INT_ENA;  ///< Offset: 0xEC - 
        volatile uint32_t HOST_SLC1HOST_INT_ENA;  ///< Offset: 0xF0 - 
        volatile uint32_t HOST_SLC0HOST_RX_INFOR;  ///< Offset: 0xF4 - 
        volatile uint32_t HOST_SLC1HOST_RX_INFOR;  ///< Offset: 0xF8 - 
        volatile uint32_t HOST_SLC0HOST_LEN_WD;  ///< Offset: 0xFC - 
        volatile uint32_t HOST_SLC_APBWIN_WDATA;  ///< Offset: 0x100 - 
        volatile uint32_t HOST_SLC_APBWIN_CONF;  ///< Offset: 0x104 - 
        volatile uint32_t HOST_SLC_APBWIN_RDATA;  ///< Offset: 0x108 - 
        volatile uint32_t HOST_SLCHOST_RDCLR0;  ///< Offset: 0x10C - 
        volatile uint32_t HOST_SLCHOST_RDCLR1;  ///< Offset: 0x110 - 
        volatile uint32_t HOST_SLC0HOST_INT_ENA1;  ///< Offset: 0x114 - 
        volatile uint32_t HOST_SLC1HOST_INT_ENA1;  ///< Offset: 0x118 - 
        volatile uint32_t HOST_SLCHOSTDATE;  ///< Offset: 0x178 - 
        volatile uint32_t HOST_SLCHOSTID;  ///< Offset: 0x17C - 
        volatile uint32_t HOST_SLCHOST_CONF;  ///< Offset: 0x1F0 - 
        volatile uint32_t HOST_SLCHOST_INF_ST;  ///< Offset: 0x1F4 - 
    };

    /// Peripheral instances
    inline Registers* SLCHOST = reinterpret_cast<Registers*>(SLCHOST_BASE);

    // Bit definitions
    /// HOST_SLCHOST_FUNC2_0 Register bits
    namespace host_slchost_func2_0_bits {
        constexpr uint32_t HOST_SLC_FUNC2_INT = (1U << 24);  ///< HOST_SLC_FUNC2_INT
    }

    /// HOST_SLCHOST_FUNC2_1 Register bits
    namespace host_slchost_func2_1_bits {
        constexpr uint32_t HOST_SLC_FUNC2_INT_EN = (1U << 0);  ///< HOST_SLC_FUNC2_INT_EN
    }

    /// HOST_SLCHOST_FUNC2_2 Register bits
    namespace host_slchost_func2_2_bits {
        constexpr uint32_t HOST_SLC_FUNC1_MDSTAT = (1U << 0);  ///< HOST_SLC_FUNC1_MDSTAT
    }

    /// HOST_SLCHOST_GPIO_STATUS0 Register bits
    namespace host_slchost_gpio_status0_bits {
        constexpr uint32_t HOST_GPIO_SDIO_INT0 = (32 << 0);  ///< HOST_GPIO_SDIO_INT0
    }

    /// HOST_SLCHOST_GPIO_STATUS1 Register bits
    namespace host_slchost_gpio_status1_bits {
        constexpr uint32_t HOST_GPIO_SDIO_INT1 = (8 << 0);  ///< HOST_GPIO_SDIO_INT1
    }

    /// HOST_SLCHOST_GPIO_IN0 Register bits
    namespace host_slchost_gpio_in0_bits {
        constexpr uint32_t HOST_GPIO_SDIO_IN0 = (32 << 0);  ///< HOST_GPIO_SDIO_IN0
    }

    /// HOST_SLCHOST_GPIO_IN1 Register bits
    namespace host_slchost_gpio_in1_bits {
        constexpr uint32_t HOST_GPIO_SDIO_IN1 = (8 << 0);  ///< HOST_GPIO_SDIO_IN1
    }

    /// HOST_SLC0HOST_TOKEN_RDATA Register bits
    namespace host_slc0host_token_rdata_bits {
        constexpr uint32_t HOST_SLC0_TOKEN0 = (12 << 0);  ///< HOST_SLC0_TOKEN0
        constexpr uint32_t HOST_SLC0_RX_PF_VALID = (1U << 12);  ///< HOST_SLC0_RX_PF_VALID
        constexpr uint32_t HOST_HOSTSLC0_TOKEN1 = (12 << 16);  ///< HOST_HOSTSLC0_TOKEN1
        constexpr uint32_t HOST_SLC0_RX_PF_EOF = (4 << 28);  ///< HOST_SLC0_RX_PF_EOF
    }

    /// HOST_SLC0_HOST_PF Register bits
    namespace host_slc0_host_pf_bits {
        constexpr uint32_t HOST_SLC0_PF_DATA = (32 << 0);  ///< HOST_SLC0_PF_DATA
    }

    /// HOST_SLC1_HOST_PF Register bits
    namespace host_slc1_host_pf_bits {
        constexpr uint32_t HOST_SLC1_PF_DATA = (32 << 0);  ///< HOST_SLC1_PF_DATA
    }

    /// HOST_SLC0HOST_INT_RAW Register bits
    namespace host_slc0host_int_raw_bits {
        constexpr uint32_t HOST_SLC0_TOHOST_BIT0_INT_RAW = (1U << 0);  ///< HOST_SLC0_TOHOST_BIT0_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT1_INT_RAW = (1U << 1);  ///< HOST_SLC0_TOHOST_BIT1_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT2_INT_RAW = (1U << 2);  ///< HOST_SLC0_TOHOST_BIT2_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT3_INT_RAW = (1U << 3);  ///< HOST_SLC0_TOHOST_BIT3_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT4_INT_RAW = (1U << 4);  ///< HOST_SLC0_TOHOST_BIT4_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT5_INT_RAW = (1U << 5);  ///< HOST_SLC0_TOHOST_BIT5_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT6_INT_RAW = (1U << 6);  ///< HOST_SLC0_TOHOST_BIT6_INT_RAW
        constexpr uint32_t HOST_SLC0_TOHOST_BIT7_INT_RAW = (1U << 7);  ///< HOST_SLC0_TOHOST_BIT7_INT_RAW
        constexpr uint32_t HOST_SLC0_TOKEN0_1TO0_INT_RAW = (1U << 8);  ///< HOST_SLC0_TOKEN0_1TO0_INT_RAW
        constexpr uint32_t HOST_SLC0_TOKEN1_1TO0_INT_RAW = (1U << 9);  ///< HOST_SLC0_TOKEN1_1TO0_INT_RAW
        constexpr uint32_t HOST_SLC0_TOKEN0_0TO1_INT_RAW = (1U << 10);  ///< HOST_SLC0_TOKEN0_0TO1_INT_RAW
        constexpr uint32_t HOST_SLC0_TOKEN1_0TO1_INT_RAW = (1U << 11);  ///< HOST_SLC0_TOKEN1_0TO1_INT_RAW
        constexpr uint32_t HOST_SLC0HOST_RX_SOF_INT_RAW = (1U << 12);  ///< HOST_SLC0HOST_RX_SOF_INT_RAW
        constexpr uint32_t HOST_SLC0HOST_RX_EOF_INT_RAW = (1U << 13);  ///< HOST_SLC0HOST_RX_EOF_INT_RAW
        constexpr uint32_t HOST_SLC0HOST_RX_START_INT_RAW = (1U << 14);  ///< HOST_SLC0HOST_RX_START_INT_RAW
        constexpr uint32_t HOST_SLC0HOST_TX_START_INT_RAW = (1U << 15);  ///< HOST_SLC0HOST_TX_START_INT_RAW
        constexpr uint32_t HOST_SLC0_RX_UDF_INT_RAW = (1U << 16);  ///< HOST_SLC0_RX_UDF_INT_RAW
        constexpr uint32_t HOST_SLC0_TX_OVF_INT_RAW = (1U << 17);  ///< HOST_SLC0_TX_OVF_INT_RAW
        constexpr uint32_t HOST_SLC0_RX_PF_VALID_INT_RAW = (1U << 18);  ///< HOST_SLC0_RX_PF_VALID_INT_RAW
        constexpr uint32_t HOST_SLC0_EXT_BIT0_INT_RAW = (1U << 19);  ///< HOST_SLC0_EXT_BIT0_INT_RAW
        constexpr uint32_t HOST_SLC0_EXT_BIT1_INT_RAW = (1U << 20);  ///< HOST_SLC0_EXT_BIT1_INT_RAW
        constexpr uint32_t HOST_SLC0_EXT_BIT2_INT_RAW = (1U << 21);  ///< HOST_SLC0_EXT_BIT2_INT_RAW
        constexpr uint32_t HOST_SLC0_EXT_BIT3_INT_RAW = (1U << 22);  ///< HOST_SLC0_EXT_BIT3_INT_RAW
        constexpr uint32_t HOST_SLC0_RX_NEW_PACKET_INT_RAW = (1U << 23);  ///< HOST_SLC0_RX_NEW_PACKET_INT_RAW
        constexpr uint32_t HOST_SLC0_HOST_RD_RETRY_INT_RAW = (1U << 24);  ///< HOST_SLC0_HOST_RD_RETRY_INT_RAW
        constexpr uint32_t HOST_GPIO_SDIO_INT_RAW = (1U << 25);  ///< HOST_GPIO_SDIO_INT_RAW
    }

    /// HOST_SLC1HOST_INT_RAW Register bits
    namespace host_slc1host_int_raw_bits {
        constexpr uint32_t HOST_SLC1_TOHOST_BIT0_INT_RAW = (1U << 0);  ///< HOST_SLC1_TOHOST_BIT0_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT1_INT_RAW = (1U << 1);  ///< HOST_SLC1_TOHOST_BIT1_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT2_INT_RAW = (1U << 2);  ///< HOST_SLC1_TOHOST_BIT2_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT3_INT_RAW = (1U << 3);  ///< HOST_SLC1_TOHOST_BIT3_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT4_INT_RAW = (1U << 4);  ///< HOST_SLC1_TOHOST_BIT4_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT5_INT_RAW = (1U << 5);  ///< HOST_SLC1_TOHOST_BIT5_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT6_INT_RAW = (1U << 6);  ///< HOST_SLC1_TOHOST_BIT6_INT_RAW
        constexpr uint32_t HOST_SLC1_TOHOST_BIT7_INT_RAW = (1U << 7);  ///< HOST_SLC1_TOHOST_BIT7_INT_RAW
        constexpr uint32_t HOST_SLC1_TOKEN0_1TO0_INT_RAW = (1U << 8);  ///< HOST_SLC1_TOKEN0_1TO0_INT_RAW
        constexpr uint32_t HOST_SLC1_TOKEN1_1TO0_INT_RAW = (1U << 9);  ///< HOST_SLC1_TOKEN1_1TO0_INT_RAW
        constexpr uint32_t HOST_SLC1_TOKEN0_0TO1_INT_RAW = (1U << 10);  ///< HOST_SLC1_TOKEN0_0TO1_INT_RAW
        constexpr uint32_t HOST_SLC1_TOKEN1_0TO1_INT_RAW = (1U << 11);  ///< HOST_SLC1_TOKEN1_0TO1_INT_RAW
        constexpr uint32_t HOST_SLC1HOST_RX_SOF_INT_RAW = (1U << 12);  ///< HOST_SLC1HOST_RX_SOF_INT_RAW
        constexpr uint32_t HOST_SLC1HOST_RX_EOF_INT_RAW = (1U << 13);  ///< HOST_SLC1HOST_RX_EOF_INT_RAW
        constexpr uint32_t HOST_SLC1HOST_RX_START_INT_RAW = (1U << 14);  ///< HOST_SLC1HOST_RX_START_INT_RAW
        constexpr uint32_t HOST_SLC1HOST_TX_START_INT_RAW = (1U << 15);  ///< HOST_SLC1HOST_TX_START_INT_RAW
        constexpr uint32_t HOST_SLC1_RX_UDF_INT_RAW = (1U << 16);  ///< HOST_SLC1_RX_UDF_INT_RAW
        constexpr uint32_t HOST_SLC1_TX_OVF_INT_RAW = (1U << 17);  ///< HOST_SLC1_TX_OVF_INT_RAW
        constexpr uint32_t HOST_SLC1_RX_PF_VALID_INT_RAW = (1U << 18);  ///< HOST_SLC1_RX_PF_VALID_INT_RAW
        constexpr uint32_t HOST_SLC1_EXT_BIT0_INT_RAW = (1U << 19);  ///< HOST_SLC1_EXT_BIT0_INT_RAW
        constexpr uint32_t HOST_SLC1_EXT_BIT1_INT_RAW = (1U << 20);  ///< HOST_SLC1_EXT_BIT1_INT_RAW
        constexpr uint32_t HOST_SLC1_EXT_BIT2_INT_RAW = (1U << 21);  ///< HOST_SLC1_EXT_BIT2_INT_RAW
        constexpr uint32_t HOST_SLC1_EXT_BIT3_INT_RAW = (1U << 22);  ///< HOST_SLC1_EXT_BIT3_INT_RAW
        constexpr uint32_t HOST_SLC1_WIFI_RX_NEW_PACKET_INT_RAW = (1U << 23);  ///< HOST_SLC1_WIFI_RX_NEW_PACKET_INT_RAW
        constexpr uint32_t HOST_SLC1_HOST_RD_RETRY_INT_RAW = (1U << 24);  ///< HOST_SLC1_HOST_RD_RETRY_INT_RAW
        constexpr uint32_t HOST_SLC1_BT_RX_NEW_PACKET_INT_RAW = (1U << 25);  ///< HOST_SLC1_BT_RX_NEW_PACKET_INT_RAW
    }

    /// HOST_SLC0HOST_INT_ST Register bits
    namespace host_slc0host_int_st_bits {
        constexpr uint32_t HOST_SLC0_TOHOST_BIT0_INT_ST = (1U << 0);  ///< HOST_SLC0_TOHOST_BIT0_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT1_INT_ST = (1U << 1);  ///< HOST_SLC0_TOHOST_BIT1_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT2_INT_ST = (1U << 2);  ///< HOST_SLC0_TOHOST_BIT2_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT3_INT_ST = (1U << 3);  ///< HOST_SLC0_TOHOST_BIT3_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT4_INT_ST = (1U << 4);  ///< HOST_SLC0_TOHOST_BIT4_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT5_INT_ST = (1U << 5);  ///< HOST_SLC0_TOHOST_BIT5_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT6_INT_ST = (1U << 6);  ///< HOST_SLC0_TOHOST_BIT6_INT_ST
        constexpr uint32_t HOST_SLC0_TOHOST_BIT7_INT_ST = (1U << 7);  ///< HOST_SLC0_TOHOST_BIT7_INT_ST
        constexpr uint32_t HOST_SLC0_TOKEN0_1TO0_INT_ST = (1U << 8);  ///< HOST_SLC0_TOKEN0_1TO0_INT_ST
        constexpr uint32_t HOST_SLC0_TOKEN1_1TO0_INT_ST = (1U << 9);  ///< HOST_SLC0_TOKEN1_1TO0_INT_ST
        constexpr uint32_t HOST_SLC0_TOKEN0_0TO1_INT_ST = (1U << 10);  ///< HOST_SLC0_TOKEN0_0TO1_INT_ST
        constexpr uint32_t HOST_SLC0_TOKEN1_0TO1_INT_ST = (1U << 11);  ///< HOST_SLC0_TOKEN1_0TO1_INT_ST
        constexpr uint32_t HOST_SLC0HOST_RX_SOF_INT_ST = (1U << 12);  ///< HOST_SLC0HOST_RX_SOF_INT_ST
        constexpr uint32_t HOST_SLC0HOST_RX_EOF_INT_ST = (1U << 13);  ///< HOST_SLC0HOST_RX_EOF_INT_ST
        constexpr uint32_t HOST_SLC0HOST_RX_START_INT_ST = (1U << 14);  ///< HOST_SLC0HOST_RX_START_INT_ST
        constexpr uint32_t HOST_SLC0HOST_TX_START_INT_ST = (1U << 15);  ///< HOST_SLC0HOST_TX_START_INT_ST
        constexpr uint32_t HOST_SLC0_RX_UDF_INT_ST = (1U << 16);  ///< HOST_SLC0_RX_UDF_INT_ST
        constexpr uint32_t HOST_SLC0_TX_OVF_INT_ST = (1U << 17);  ///< HOST_SLC0_TX_OVF_INT_ST
        constexpr uint32_t HOST_SLC0_RX_PF_VALID_INT_ST = (1U << 18);  ///< HOST_SLC0_RX_PF_VALID_INT_ST
        constexpr uint32_t HOST_SLC0_EXT_BIT0_INT_ST = (1U << 19);  ///< HOST_SLC0_EXT_BIT0_INT_ST
        constexpr uint32_t HOST_SLC0_EXT_BIT1_INT_ST = (1U << 20);  ///< HOST_SLC0_EXT_BIT1_INT_ST
        constexpr uint32_t HOST_SLC0_EXT_BIT2_INT_ST = (1U << 21);  ///< HOST_SLC0_EXT_BIT2_INT_ST
        constexpr uint32_t HOST_SLC0_EXT_BIT3_INT_ST = (1U << 22);  ///< HOST_SLC0_EXT_BIT3_INT_ST
        constexpr uint32_t HOST_SLC0_RX_NEW_PACKET_INT_ST = (1U << 23);  ///< HOST_SLC0_RX_NEW_PACKET_INT_ST
        constexpr uint32_t HOST_SLC0_HOST_RD_RETRY_INT_ST = (1U << 24);  ///< HOST_SLC0_HOST_RD_RETRY_INT_ST
        constexpr uint32_t HOST_GPIO_SDIO_INT_ST = (1U << 25);  ///< HOST_GPIO_SDIO_INT_ST
    }

    /// HOST_SLC1HOST_INT_ST Register bits
    namespace host_slc1host_int_st_bits {
        constexpr uint32_t HOST_SLC1_TOHOST_BIT0_INT_ST = (1U << 0);  ///< HOST_SLC1_TOHOST_BIT0_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT1_INT_ST = (1U << 1);  ///< HOST_SLC1_TOHOST_BIT1_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT2_INT_ST = (1U << 2);  ///< HOST_SLC1_TOHOST_BIT2_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT3_INT_ST = (1U << 3);  ///< HOST_SLC1_TOHOST_BIT3_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT4_INT_ST = (1U << 4);  ///< HOST_SLC1_TOHOST_BIT4_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT5_INT_ST = (1U << 5);  ///< HOST_SLC1_TOHOST_BIT5_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT6_INT_ST = (1U << 6);  ///< HOST_SLC1_TOHOST_BIT6_INT_ST
        constexpr uint32_t HOST_SLC1_TOHOST_BIT7_INT_ST = (1U << 7);  ///< HOST_SLC1_TOHOST_BIT7_INT_ST
        constexpr uint32_t HOST_SLC1_TOKEN0_1TO0_INT_ST = (1U << 8);  ///< HOST_SLC1_TOKEN0_1TO0_INT_ST
        constexpr uint32_t HOST_SLC1_TOKEN1_1TO0_INT_ST = (1U << 9);  ///< HOST_SLC1_TOKEN1_1TO0_INT_ST
        constexpr uint32_t HOST_SLC1_TOKEN0_0TO1_INT_ST = (1U << 10);  ///< HOST_SLC1_TOKEN0_0TO1_INT_ST
        constexpr uint32_t HOST_SLC1_TOKEN1_0TO1_INT_ST = (1U << 11);  ///< HOST_SLC1_TOKEN1_0TO1_INT_ST
        constexpr uint32_t HOST_SLC1HOST_RX_SOF_INT_ST = (1U << 12);  ///< HOST_SLC1HOST_RX_SOF_INT_ST
        constexpr uint32_t HOST_SLC1HOST_RX_EOF_INT_ST = (1U << 13);  ///< HOST_SLC1HOST_RX_EOF_INT_ST
        constexpr uint32_t HOST_SLC1HOST_RX_START_INT_ST = (1U << 14);  ///< HOST_SLC1HOST_RX_START_INT_ST
        constexpr uint32_t HOST_SLC1HOST_TX_START_INT_ST = (1U << 15);  ///< HOST_SLC1HOST_TX_START_INT_ST
        constexpr uint32_t HOST_SLC1_RX_UDF_INT_ST = (1U << 16);  ///< HOST_SLC1_RX_UDF_INT_ST
        constexpr uint32_t HOST_SLC1_TX_OVF_INT_ST = (1U << 17);  ///< HOST_SLC1_TX_OVF_INT_ST
        constexpr uint32_t HOST_SLC1_RX_PF_VALID_INT_ST = (1U << 18);  ///< HOST_SLC1_RX_PF_VALID_INT_ST
        constexpr uint32_t HOST_SLC1_EXT_BIT0_INT_ST = (1U << 19);  ///< HOST_SLC1_EXT_BIT0_INT_ST
        constexpr uint32_t HOST_SLC1_EXT_BIT1_INT_ST = (1U << 20);  ///< HOST_SLC1_EXT_BIT1_INT_ST
        constexpr uint32_t HOST_SLC1_EXT_BIT2_INT_ST = (1U << 21);  ///< HOST_SLC1_EXT_BIT2_INT_ST
        constexpr uint32_t HOST_SLC1_EXT_BIT3_INT_ST = (1U << 22);  ///< HOST_SLC1_EXT_BIT3_INT_ST
        constexpr uint32_t HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ST = (1U << 23);  ///< HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ST
        constexpr uint32_t HOST_SLC1_HOST_RD_RETRY_INT_ST = (1U << 24);  ///< HOST_SLC1_HOST_RD_RETRY_INT_ST
        constexpr uint32_t HOST_SLC1_BT_RX_NEW_PACKET_INT_ST = (1U << 25);  ///< HOST_SLC1_BT_RX_NEW_PACKET_INT_ST
    }

    /// HOST_SLCHOST_PKT_LEN Register bits
    namespace host_slchost_pkt_len_bits {
        constexpr uint32_t HOST_HOSTSLC0_LEN = (20 << 0);  ///< HOST_HOSTSLC0_LEN
        constexpr uint32_t HOST_HOSTSLC0_LEN_CHECK = (12 << 20);  ///< HOST_HOSTSLC0_LEN_CHECK
    }

    /// HOST_SLCHOST_STATE_W0 Register bits
    namespace host_slchost_state_w0_bits {
        constexpr uint32_t HOST_SLCHOST_STATE0 = (8 << 0);  ///< HOST_SLCHOST_STATE0
        constexpr uint32_t HOST_SLCHOST_STATE1 = (8 << 8);  ///< HOST_SLCHOST_STATE1
        constexpr uint32_t HOST_SLCHOST_STATE2 = (8 << 16);  ///< HOST_SLCHOST_STATE2
        constexpr uint32_t HOST_SLCHOST_STATE3 = (8 << 24);  ///< HOST_SLCHOST_STATE3
    }

    /// HOST_SLCHOST_STATE_W1 Register bits
    namespace host_slchost_state_w1_bits {
        constexpr uint32_t HOST_SLCHOST_STATE4 = (8 << 0);  ///< HOST_SLCHOST_STATE4
        constexpr uint32_t HOST_SLCHOST_STATE5 = (8 << 8);  ///< HOST_SLCHOST_STATE5
        constexpr uint32_t HOST_SLCHOST_STATE6 = (8 << 16);  ///< HOST_SLCHOST_STATE6
        constexpr uint32_t HOST_SLCHOST_STATE7 = (8 << 24);  ///< HOST_SLCHOST_STATE7
    }

    /// HOST_SLCHOST_CONF_W0 Register bits
    namespace host_slchost_conf_w0_bits {
        constexpr uint32_t HOST_SLCHOST_CONF0 = (8 << 0);  ///< HOST_SLCHOST_CONF0
        constexpr uint32_t HOST_SLCHOST_CONF1 = (8 << 8);  ///< HOST_SLCHOST_CONF1
        constexpr uint32_t HOST_SLCHOST_CONF2 = (8 << 16);  ///< HOST_SLCHOST_CONF2
        constexpr uint32_t HOST_SLCHOST_CONF3 = (8 << 24);  ///< HOST_SLCHOST_CONF3
    }

    /// HOST_SLCHOST_CONF_W1 Register bits
    namespace host_slchost_conf_w1_bits {
        constexpr uint32_t HOST_SLCHOST_CONF4 = (8 << 0);  ///< HOST_SLCHOST_CONF4
        constexpr uint32_t HOST_SLCHOST_CONF5 = (8 << 8);  ///< HOST_SLCHOST_CONF5
        constexpr uint32_t HOST_SLCHOST_CONF6 = (8 << 16);  ///< HOST_SLCHOST_CONF6
        constexpr uint32_t HOST_SLCHOST_CONF7 = (8 << 24);  ///< HOST_SLCHOST_CONF7
    }

    /// HOST_SLCHOST_CONF_W2 Register bits
    namespace host_slchost_conf_w2_bits {
        constexpr uint32_t HOST_SLCHOST_CONF8 = (8 << 0);  ///< HOST_SLCHOST_CONF8
        constexpr uint32_t HOST_SLCHOST_CONF9 = (8 << 8);  ///< HOST_SLCHOST_CONF9
        constexpr uint32_t HOST_SLCHOST_CONF10 = (8 << 16);  ///< HOST_SLCHOST_CONF10
        constexpr uint32_t HOST_SLCHOST_CONF11 = (8 << 24);  ///< HOST_SLCHOST_CONF11
    }

    /// HOST_SLCHOST_CONF_W3 Register bits
    namespace host_slchost_conf_w3_bits {
        constexpr uint32_t HOST_SLCHOST_CONF12 = (8 << 0);  ///< HOST_SLCHOST_CONF12
        constexpr uint32_t HOST_SLCHOST_CONF13 = (8 << 8);  ///< HOST_SLCHOST_CONF13
        constexpr uint32_t HOST_SLCHOST_CONF14 = (8 << 16);  ///< HOST_SLCHOST_CONF14
        constexpr uint32_t HOST_SLCHOST_CONF15 = (8 << 24);  ///< HOST_SLCHOST_CONF15
    }

    /// HOST_SLCHOST_CONF_W4 Register bits
    namespace host_slchost_conf_w4_bits {
        constexpr uint32_t HOST_SLCHOST_CONF16 = (8 << 0);  ///< SLC timeout value
        constexpr uint32_t HOST_SLCHOST_CONF17 = (8 << 8);  ///< SLC timeout enable
        constexpr uint32_t HOST_SLCHOST_CONF18 = (8 << 16);  ///< HOST_SLCHOST_CONF18
        constexpr uint32_t HOST_SLCHOST_CONF19 = (8 << 24);  ///< Interrupt to target CPU
    }

    /// HOST_SLCHOST_CONF_W5 Register bits
    namespace host_slchost_conf_w5_bits {
        constexpr uint32_t HOST_SLCHOST_CONF20 = (8 << 0);  ///< HOST_SLCHOST_CONF20
        constexpr uint32_t HOST_SLCHOST_CONF21 = (8 << 8);  ///< HOST_SLCHOST_CONF21
        constexpr uint32_t HOST_SLCHOST_CONF22 = (8 << 16);  ///< HOST_SLCHOST_CONF22
        constexpr uint32_t HOST_SLCHOST_CONF23 = (8 << 24);  ///< HOST_SLCHOST_CONF23
    }

    /// HOST_SLCHOST_CONF_W6 Register bits
    namespace host_slchost_conf_w6_bits {
        constexpr uint32_t HOST_SLCHOST_CONF24 = (8 << 0);  ///< HOST_SLCHOST_CONF24
        constexpr uint32_t HOST_SLCHOST_CONF25 = (8 << 8);  ///< HOST_SLCHOST_CONF25
        constexpr uint32_t HOST_SLCHOST_CONF26 = (8 << 16);  ///< HOST_SLCHOST_CONF26
        constexpr uint32_t HOST_SLCHOST_CONF27 = (8 << 24);  ///< HOST_SLCHOST_CONF27
    }

    /// HOST_SLCHOST_CONF_W7 Register bits
    namespace host_slchost_conf_w7_bits {
        constexpr uint32_t HOST_SLCHOST_CONF28 = (8 << 0);  ///< HOST_SLCHOST_CONF28
        constexpr uint32_t HOST_SLCHOST_CONF29 = (8 << 8);  ///< HOST_SLCHOST_CONF29
        constexpr uint32_t HOST_SLCHOST_CONF30 = (8 << 16);  ///< HOST_SLCHOST_CONF30
        constexpr uint32_t HOST_SLCHOST_CONF31 = (8 << 24);  ///< HOST_SLCHOST_CONF31
    }

    /// HOST_SLCHOST_PKT_LEN0 Register bits
    namespace host_slchost_pkt_len0_bits {
        constexpr uint32_t HOST_HOSTSLC0_LEN0 = (20 << 0);  ///< HOST_HOSTSLC0_LEN0
    }

    /// HOST_SLCHOST_PKT_LEN1 Register bits
    namespace host_slchost_pkt_len1_bits {
        constexpr uint32_t HOST_HOSTSLC0_LEN1 = (20 << 0);  ///< HOST_HOSTSLC0_LEN1
    }

    /// HOST_SLCHOST_PKT_LEN2 Register bits
    namespace host_slchost_pkt_len2_bits {
        constexpr uint32_t HOST_HOSTSLC0_LEN2 = (20 << 0);  ///< HOST_HOSTSLC0_LEN2
    }

    /// HOST_SLCHOST_CONF_W8 Register bits
    namespace host_slchost_conf_w8_bits {
        constexpr uint32_t HOST_SLCHOST_CONF32 = (8 << 0);  ///< HOST_SLCHOST_CONF32
        constexpr uint32_t HOST_SLCHOST_CONF33 = (8 << 8);  ///< HOST_SLCHOST_CONF33
        constexpr uint32_t HOST_SLCHOST_CONF34 = (8 << 16);  ///< HOST_SLCHOST_CONF34
        constexpr uint32_t HOST_SLCHOST_CONF35 = (8 << 24);  ///< HOST_SLCHOST_CONF35
    }

    /// HOST_SLCHOST_CONF_W9 Register bits
    namespace host_slchost_conf_w9_bits {
        constexpr uint32_t HOST_SLCHOST_CONF36 = (8 << 0);  ///< HOST_SLCHOST_CONF36
        constexpr uint32_t HOST_SLCHOST_CONF37 = (8 << 8);  ///< HOST_SLCHOST_CONF37
        constexpr uint32_t HOST_SLCHOST_CONF38 = (8 << 16);  ///< HOST_SLCHOST_CONF38
        constexpr uint32_t HOST_SLCHOST_CONF39 = (8 << 24);  ///< HOST_SLCHOST_CONF39
    }

    /// HOST_SLCHOST_CONF_W10 Register bits
    namespace host_slchost_conf_w10_bits {
        constexpr uint32_t HOST_SLCHOST_CONF40 = (8 << 0);  ///< HOST_SLCHOST_CONF40
        constexpr uint32_t HOST_SLCHOST_CONF41 = (8 << 8);  ///< HOST_SLCHOST_CONF41
        constexpr uint32_t HOST_SLCHOST_CONF42 = (8 << 16);  ///< HOST_SLCHOST_CONF42
        constexpr uint32_t HOST_SLCHOST_CONF43 = (8 << 24);  ///< HOST_SLCHOST_CONF43
    }

    /// HOST_SLCHOST_CONF_W11 Register bits
    namespace host_slchost_conf_w11_bits {
        constexpr uint32_t HOST_SLCHOST_CONF44 = (8 << 0);  ///< HOST_SLCHOST_CONF44
        constexpr uint32_t HOST_SLCHOST_CONF45 = (8 << 8);  ///< HOST_SLCHOST_CONF45
        constexpr uint32_t HOST_SLCHOST_CONF46 = (8 << 16);  ///< HOST_SLCHOST_CONF46
        constexpr uint32_t HOST_SLCHOST_CONF47 = (8 << 24);  ///< HOST_SLCHOST_CONF47
    }

    /// HOST_SLCHOST_CONF_W12 Register bits
    namespace host_slchost_conf_w12_bits {
        constexpr uint32_t HOST_SLCHOST_CONF48 = (8 << 0);  ///< HOST_SLCHOST_CONF48
        constexpr uint32_t HOST_SLCHOST_CONF49 = (8 << 8);  ///< HOST_SLCHOST_CONF49
        constexpr uint32_t HOST_SLCHOST_CONF50 = (8 << 16);  ///< HOST_SLCHOST_CONF50
        constexpr uint32_t HOST_SLCHOST_CONF51 = (8 << 24);  ///< HOST_SLCHOST_CONF51
    }

    /// HOST_SLCHOST_CONF_W13 Register bits
    namespace host_slchost_conf_w13_bits {
        constexpr uint32_t HOST_SLCHOST_CONF52 = (8 << 0);  ///< HOST_SLCHOST_CONF52
        constexpr uint32_t HOST_SLCHOST_CONF53 = (8 << 8);  ///< HOST_SLCHOST_CONF53
        constexpr uint32_t HOST_SLCHOST_CONF54 = (8 << 16);  ///< HOST_SLCHOST_CONF54
        constexpr uint32_t HOST_SLCHOST_CONF55 = (8 << 24);  ///< HOST_SLCHOST_CONF55
    }

    /// HOST_SLCHOST_CONF_W14 Register bits
    namespace host_slchost_conf_w14_bits {
        constexpr uint32_t HOST_SLCHOST_CONF56 = (8 << 0);  ///< HOST_SLCHOST_CONF56
        constexpr uint32_t HOST_SLCHOST_CONF57 = (8 << 8);  ///< HOST_SLCHOST_CONF57
        constexpr uint32_t HOST_SLCHOST_CONF58 = (8 << 16);  ///< HOST_SLCHOST_CONF58
        constexpr uint32_t HOST_SLCHOST_CONF59 = (8 << 24);  ///< HOST_SLCHOST_CONF59
    }

    /// HOST_SLCHOST_CONF_W15 Register bits
    namespace host_slchost_conf_w15_bits {
        constexpr uint32_t HOST_SLCHOST_CONF60 = (8 << 0);  ///< HOST_SLCHOST_CONF60
        constexpr uint32_t HOST_SLCHOST_CONF61 = (8 << 8);  ///< HOST_SLCHOST_CONF61
        constexpr uint32_t HOST_SLCHOST_CONF62 = (8 << 16);  ///< HOST_SLCHOST_CONF62
        constexpr uint32_t HOST_SLCHOST_CONF63 = (8 << 24);  ///< HOST_SLCHOST_CONF63
    }

    /// HOST_SLCHOST_CHECK_SUM0 Register bits
    namespace host_slchost_check_sum0_bits {
        constexpr uint32_t HOST_SLCHOST_CHECK_SUM0 = (32 << 0);  ///< HOST_SLCHOST_CHECK_SUM0
    }

    /// HOST_SLCHOST_CHECK_SUM1 Register bits
    namespace host_slchost_check_sum1_bits {
        constexpr uint32_t HOST_SLCHOST_CHECK_SUM1 = (32 << 0);  ///< HOST_SLCHOST_CHECK_SUM1
    }

    /// HOST_SLC1HOST_TOKEN_RDATA Register bits
    namespace host_slc1host_token_rdata_bits {
        constexpr uint32_t HOST_SLC1_TOKEN0 = (12 << 0);  ///< HOST_SLC1_TOKEN0
        constexpr uint32_t HOST_SLC1_RX_PF_VALID = (1U << 12);  ///< HOST_SLC1_RX_PF_VALID
        constexpr uint32_t HOST_HOSTSLC1_TOKEN1 = (12 << 16);  ///< HOST_HOSTSLC1_TOKEN1
        constexpr uint32_t HOST_SLC1_RX_PF_EOF = (4 << 28);  ///< HOST_SLC1_RX_PF_EOF
    }

    /// HOST_SLC0HOST_TOKEN_WDATA Register bits
    namespace host_slc0host_token_wdata_bits {
        constexpr uint32_t HOST_SLC0HOST_TOKEN0_WD = (12 << 0);  ///< HOST_SLC0HOST_TOKEN0_WD
        constexpr uint32_t HOST_SLC0HOST_TOKEN1_WD = (12 << 16);  ///< HOST_SLC0HOST_TOKEN1_WD
    }

    /// HOST_SLC1HOST_TOKEN_WDATA Register bits
    namespace host_slc1host_token_wdata_bits {
        constexpr uint32_t HOST_SLC1HOST_TOKEN0_WD = (12 << 0);  ///< HOST_SLC1HOST_TOKEN0_WD
        constexpr uint32_t HOST_SLC1HOST_TOKEN1_WD = (12 << 16);  ///< HOST_SLC1HOST_TOKEN1_WD
    }

    /// HOST_SLCHOST_TOKEN_CON Register bits
    namespace host_slchost_token_con_bits {
        constexpr uint32_t HOST_SLC0HOST_TOKEN0_DEC = (1U << 0);  ///< HOST_SLC0HOST_TOKEN0_DEC
        constexpr uint32_t HOST_SLC0HOST_TOKEN1_DEC = (1U << 1);  ///< HOST_SLC0HOST_TOKEN1_DEC
        constexpr uint32_t HOST_SLC0HOST_TOKEN0_WR = (1U << 2);  ///< HOST_SLC0HOST_TOKEN0_WR
        constexpr uint32_t HOST_SLC0HOST_TOKEN1_WR = (1U << 3);  ///< HOST_SLC0HOST_TOKEN1_WR
        constexpr uint32_t HOST_SLC1HOST_TOKEN0_DEC = (1U << 4);  ///< HOST_SLC1HOST_TOKEN0_DEC
        constexpr uint32_t HOST_SLC1HOST_TOKEN1_DEC = (1U << 5);  ///< HOST_SLC1HOST_TOKEN1_DEC
        constexpr uint32_t HOST_SLC1HOST_TOKEN0_WR = (1U << 6);  ///< HOST_SLC1HOST_TOKEN0_WR
        constexpr uint32_t HOST_SLC1HOST_TOKEN1_WR = (1U << 7);  ///< HOST_SLC1HOST_TOKEN1_WR
        constexpr uint32_t HOST_SLC0HOST_LEN_WR = (1U << 8);  ///< HOST_SLC0HOST_LEN_WR
    }

    /// HOST_SLC0HOST_INT_CLR Register bits
    namespace host_slc0host_int_clr_bits {
        constexpr uint32_t HOST_SLC0_TOHOST_BIT0_INT_CLR = (1U << 0);  ///< HOST_SLC0_TOHOST_BIT0_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT1_INT_CLR = (1U << 1);  ///< HOST_SLC0_TOHOST_BIT1_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT2_INT_CLR = (1U << 2);  ///< HOST_SLC0_TOHOST_BIT2_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT3_INT_CLR = (1U << 3);  ///< HOST_SLC0_TOHOST_BIT3_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT4_INT_CLR = (1U << 4);  ///< HOST_SLC0_TOHOST_BIT4_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT5_INT_CLR = (1U << 5);  ///< HOST_SLC0_TOHOST_BIT5_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT6_INT_CLR = (1U << 6);  ///< HOST_SLC0_TOHOST_BIT6_INT_CLR
        constexpr uint32_t HOST_SLC0_TOHOST_BIT7_INT_CLR = (1U << 7);  ///< HOST_SLC0_TOHOST_BIT7_INT_CLR
        constexpr uint32_t HOST_SLC0_TOKEN0_1TO0_INT_CLR = (1U << 8);  ///< HOST_SLC0_TOKEN0_1TO0_INT_CLR
        constexpr uint32_t HOST_SLC0_TOKEN1_1TO0_INT_CLR = (1U << 9);  ///< HOST_SLC0_TOKEN1_1TO0_INT_CLR
        constexpr uint32_t HOST_SLC0_TOKEN0_0TO1_INT_CLR = (1U << 10);  ///< HOST_SLC0_TOKEN0_0TO1_INT_CLR
        constexpr uint32_t HOST_SLC0_TOKEN1_0TO1_INT_CLR = (1U << 11);  ///< HOST_SLC0_TOKEN1_0TO1_INT_CLR
        constexpr uint32_t HOST_SLC0HOST_RX_SOF_INT_CLR = (1U << 12);  ///< HOST_SLC0HOST_RX_SOF_INT_CLR
        constexpr uint32_t HOST_SLC0HOST_RX_EOF_INT_CLR = (1U << 13);  ///< HOST_SLC0HOST_RX_EOF_INT_CLR
        constexpr uint32_t HOST_SLC0HOST_RX_START_INT_CLR = (1U << 14);  ///< HOST_SLC0HOST_RX_START_INT_CLR
        constexpr uint32_t HOST_SLC0HOST_TX_START_INT_CLR = (1U << 15);  ///< HOST_SLC0HOST_TX_START_INT_CLR
        constexpr uint32_t HOST_SLC0_RX_UDF_INT_CLR = (1U << 16);  ///< HOST_SLC0_RX_UDF_INT_CLR
        constexpr uint32_t HOST_SLC0_TX_OVF_INT_CLR = (1U << 17);  ///< HOST_SLC0_TX_OVF_INT_CLR
        constexpr uint32_t HOST_SLC0_RX_PF_VALID_INT_CLR = (1U << 18);  ///< HOST_SLC0_RX_PF_VALID_INT_CLR
        constexpr uint32_t HOST_SLC0_EXT_BIT0_INT_CLR = (1U << 19);  ///< HOST_SLC0_EXT_BIT0_INT_CLR
        constexpr uint32_t HOST_SLC0_EXT_BIT1_INT_CLR = (1U << 20);  ///< HOST_SLC0_EXT_BIT1_INT_CLR
        constexpr uint32_t HOST_SLC0_EXT_BIT2_INT_CLR = (1U << 21);  ///< HOST_SLC0_EXT_BIT2_INT_CLR
        constexpr uint32_t HOST_SLC0_EXT_BIT3_INT_CLR = (1U << 22);  ///< HOST_SLC0_EXT_BIT3_INT_CLR
        constexpr uint32_t HOST_SLC0_RX_NEW_PACKET_INT_CLR = (1U << 23);  ///< HOST_SLC0_RX_NEW_PACKET_INT_CLR
        constexpr uint32_t HOST_SLC0_HOST_RD_RETRY_INT_CLR = (1U << 24);  ///< HOST_SLC0_HOST_RD_RETRY_INT_CLR
        constexpr uint32_t HOST_GPIO_SDIO_INT_CLR = (1U << 25);  ///< HOST_GPIO_SDIO_INT_CLR
    }

    /// HOST_SLC1HOST_INT_CLR Register bits
    namespace host_slc1host_int_clr_bits {
        constexpr uint32_t HOST_SLC1_TOHOST_BIT0_INT_CLR = (1U << 0);  ///< HOST_SLC1_TOHOST_BIT0_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT1_INT_CLR = (1U << 1);  ///< HOST_SLC1_TOHOST_BIT1_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT2_INT_CLR = (1U << 2);  ///< HOST_SLC1_TOHOST_BIT2_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT3_INT_CLR = (1U << 3);  ///< HOST_SLC1_TOHOST_BIT3_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT4_INT_CLR = (1U << 4);  ///< HOST_SLC1_TOHOST_BIT4_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT5_INT_CLR = (1U << 5);  ///< HOST_SLC1_TOHOST_BIT5_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT6_INT_CLR = (1U << 6);  ///< HOST_SLC1_TOHOST_BIT6_INT_CLR
        constexpr uint32_t HOST_SLC1_TOHOST_BIT7_INT_CLR = (1U << 7);  ///< HOST_SLC1_TOHOST_BIT7_INT_CLR
        constexpr uint32_t HOST_SLC1_TOKEN0_1TO0_INT_CLR = (1U << 8);  ///< HOST_SLC1_TOKEN0_1TO0_INT_CLR
        constexpr uint32_t HOST_SLC1_TOKEN1_1TO0_INT_CLR = (1U << 9);  ///< HOST_SLC1_TOKEN1_1TO0_INT_CLR
        constexpr uint32_t HOST_SLC1_TOKEN0_0TO1_INT_CLR = (1U << 10);  ///< HOST_SLC1_TOKEN0_0TO1_INT_CLR
        constexpr uint32_t HOST_SLC1_TOKEN1_0TO1_INT_CLR = (1U << 11);  ///< HOST_SLC1_TOKEN1_0TO1_INT_CLR
        constexpr uint32_t HOST_SLC1HOST_RX_SOF_INT_CLR = (1U << 12);  ///< HOST_SLC1HOST_RX_SOF_INT_CLR
        constexpr uint32_t HOST_SLC1HOST_RX_EOF_INT_CLR = (1U << 13);  ///< HOST_SLC1HOST_RX_EOF_INT_CLR
        constexpr uint32_t HOST_SLC1HOST_RX_START_INT_CLR = (1U << 14);  ///< HOST_SLC1HOST_RX_START_INT_CLR
        constexpr uint32_t HOST_SLC1HOST_TX_START_INT_CLR = (1U << 15);  ///< HOST_SLC1HOST_TX_START_INT_CLR
        constexpr uint32_t HOST_SLC1_RX_UDF_INT_CLR = (1U << 16);  ///< HOST_SLC1_RX_UDF_INT_CLR
        constexpr uint32_t HOST_SLC1_TX_OVF_INT_CLR = (1U << 17);  ///< HOST_SLC1_TX_OVF_INT_CLR
        constexpr uint32_t HOST_SLC1_RX_PF_VALID_INT_CLR = (1U << 18);  ///< HOST_SLC1_RX_PF_VALID_INT_CLR
        constexpr uint32_t HOST_SLC1_EXT_BIT0_INT_CLR = (1U << 19);  ///< HOST_SLC1_EXT_BIT0_INT_CLR
        constexpr uint32_t HOST_SLC1_EXT_BIT1_INT_CLR = (1U << 20);  ///< HOST_SLC1_EXT_BIT1_INT_CLR
        constexpr uint32_t HOST_SLC1_EXT_BIT2_INT_CLR = (1U << 21);  ///< HOST_SLC1_EXT_BIT2_INT_CLR
        constexpr uint32_t HOST_SLC1_EXT_BIT3_INT_CLR = (1U << 22);  ///< HOST_SLC1_EXT_BIT3_INT_CLR
        constexpr uint32_t HOST_SLC1_WIFI_RX_NEW_PACKET_INT_CLR = (1U << 23);  ///< HOST_SLC1_WIFI_RX_NEW_PACKET_INT_CLR
        constexpr uint32_t HOST_SLC1_HOST_RD_RETRY_INT_CLR = (1U << 24);  ///< HOST_SLC1_HOST_RD_RETRY_INT_CLR
        constexpr uint32_t HOST_SLC1_BT_RX_NEW_PACKET_INT_CLR = (1U << 25);  ///< HOST_SLC1_BT_RX_NEW_PACKET_INT_CLR
    }

    /// HOST_SLC0HOST_FUNC1_INT_ENA Register bits
    namespace host_slc0host_func1_int_ena_bits {
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_FN1_SLC0_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_FN1_SLC0_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_FN1_SLC0_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_FN1_SLC0_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_FN1_SLC0_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_FN1_SLC0_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_FN1_SLC0_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_FN1_SLC0_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_FN1_SLC0_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_FN1_SLC0_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_FN1_SLC0_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_FN1_SLC0_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_FN1_SLC0HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_FN1_SLC0HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_FN1_SLC0HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_FN1_SLC0HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_FN1_SLC0_RX_UDF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_FN1_SLC0_TX_OVF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_FN1_SLC0_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_FN1_SLC0_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_FN1_SLC0_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_FN1_SLC0_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_FN1_SLC0_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_FN1_SLC0_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_FN1_SLC0_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_FN1_SLC0_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_FN1_GPIO_SDIO_INT_ENA = (1U << 25);  ///< HOST_FN1_GPIO_SDIO_INT_ENA
    }

    /// HOST_SLC1HOST_FUNC1_INT_ENA Register bits
    namespace host_slc1host_func1_int_ena_bits {
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_FN1_SLC1_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_FN1_SLC1_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_FN1_SLC1_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_FN1_SLC1_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_FN1_SLC1_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_FN1_SLC1_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_FN1_SLC1_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_FN1_SLC1_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_FN1_SLC1_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_FN1_SLC1_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_FN1_SLC1_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_FN1_SLC1_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_FN1_SLC1HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_FN1_SLC1HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_FN1_SLC1HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_FN1_SLC1HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_FN1_SLC1_RX_UDF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_FN1_SLC1_TX_OVF_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_FN1_SLC1_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_FN1_SLC1_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_FN1_SLC1_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_FN1_SLC1_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_FN1_SLC1_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_FN1_SLC1_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA = (1U << 25);  ///< HOST_FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA
    }

    /// HOST_SLC0HOST_FUNC2_INT_ENA Register bits
    namespace host_slc0host_func2_int_ena_bits {
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_FN2_SLC0_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_FN2_SLC0_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_FN2_SLC0_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_FN2_SLC0_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_FN2_SLC0_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_FN2_SLC0_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_FN2_SLC0_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_FN2_SLC0_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_FN2_SLC0_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_FN2_SLC0_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_FN2_SLC0_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_FN2_SLC0_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_FN2_SLC0HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_FN2_SLC0HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_FN2_SLC0HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_FN2_SLC0HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_FN2_SLC0_RX_UDF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_FN2_SLC0_TX_OVF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_FN2_SLC0_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_FN2_SLC0_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_FN2_SLC0_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_FN2_SLC0_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_FN2_SLC0_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_FN2_SLC0_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_FN2_SLC0_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_FN2_SLC0_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_FN2_GPIO_SDIO_INT_ENA = (1U << 25);  ///< HOST_FN2_GPIO_SDIO_INT_ENA
    }

    /// HOST_SLC1HOST_FUNC2_INT_ENA Register bits
    namespace host_slc1host_func2_int_ena_bits {
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_FN2_SLC1_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_FN2_SLC1_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_FN2_SLC1_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_FN2_SLC1_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_FN2_SLC1_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_FN2_SLC1_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_FN2_SLC1_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_FN2_SLC1_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_FN2_SLC1_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_FN2_SLC1_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_FN2_SLC1_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_FN2_SLC1_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_FN2_SLC1HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_FN2_SLC1HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_FN2_SLC1HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_FN2_SLC1HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_FN2_SLC1_RX_UDF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_FN2_SLC1_TX_OVF_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_FN2_SLC1_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_FN2_SLC1_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_FN2_SLC1_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_FN2_SLC1_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_FN2_SLC1_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_FN2_SLC1_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA = (1U << 25);  ///< HOST_FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA
    }

    /// HOST_SLC0HOST_INT_ENA Register bits
    namespace host_slc0host_int_ena_bits {
        constexpr uint32_t HOST_SLC0_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_SLC0_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_SLC0_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_SLC0_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_SLC0_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_SLC0_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_SLC0_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_SLC0_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_SLC0_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_SLC0_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_SLC0_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_SLC0_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_SLC0_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_SLC0_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_SLC0_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_SLC0_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_SLC0_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_SLC0_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_SLC0HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_SLC0HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_SLC0HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_SLC0HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_SLC0HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_SLC0HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_SLC0HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_SLC0HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_SLC0_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_SLC0_RX_UDF_INT_ENA
        constexpr uint32_t HOST_SLC0_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_SLC0_TX_OVF_INT_ENA
        constexpr uint32_t HOST_SLC0_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_SLC0_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_SLC0_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_SLC0_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_SLC0_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_SLC0_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_SLC0_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_SLC0_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_SLC0_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_SLC0_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_SLC0_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_SLC0_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_SLC0_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_SLC0_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_GPIO_SDIO_INT_ENA = (1U << 25);  ///< HOST_GPIO_SDIO_INT_ENA
    }

    /// HOST_SLC1HOST_INT_ENA Register bits
    namespace host_slc1host_int_ena_bits {
        constexpr uint32_t HOST_SLC1_TOHOST_BIT0_INT_ENA = (1U << 0);  ///< HOST_SLC1_TOHOST_BIT0_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT1_INT_ENA = (1U << 1);  ///< HOST_SLC1_TOHOST_BIT1_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT2_INT_ENA = (1U << 2);  ///< HOST_SLC1_TOHOST_BIT2_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT3_INT_ENA = (1U << 3);  ///< HOST_SLC1_TOHOST_BIT3_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT4_INT_ENA = (1U << 4);  ///< HOST_SLC1_TOHOST_BIT4_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT5_INT_ENA = (1U << 5);  ///< HOST_SLC1_TOHOST_BIT5_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT6_INT_ENA = (1U << 6);  ///< HOST_SLC1_TOHOST_BIT6_INT_ENA
        constexpr uint32_t HOST_SLC1_TOHOST_BIT7_INT_ENA = (1U << 7);  ///< HOST_SLC1_TOHOST_BIT7_INT_ENA
        constexpr uint32_t HOST_SLC1_TOKEN0_1TO0_INT_ENA = (1U << 8);  ///< HOST_SLC1_TOKEN0_1TO0_INT_ENA
        constexpr uint32_t HOST_SLC1_TOKEN1_1TO0_INT_ENA = (1U << 9);  ///< HOST_SLC1_TOKEN1_1TO0_INT_ENA
        constexpr uint32_t HOST_SLC1_TOKEN0_0TO1_INT_ENA = (1U << 10);  ///< HOST_SLC1_TOKEN0_0TO1_INT_ENA
        constexpr uint32_t HOST_SLC1_TOKEN1_0TO1_INT_ENA = (1U << 11);  ///< HOST_SLC1_TOKEN1_0TO1_INT_ENA
        constexpr uint32_t HOST_SLC1HOST_RX_SOF_INT_ENA = (1U << 12);  ///< HOST_SLC1HOST_RX_SOF_INT_ENA
        constexpr uint32_t HOST_SLC1HOST_RX_EOF_INT_ENA = (1U << 13);  ///< HOST_SLC1HOST_RX_EOF_INT_ENA
        constexpr uint32_t HOST_SLC1HOST_RX_START_INT_ENA = (1U << 14);  ///< HOST_SLC1HOST_RX_START_INT_ENA
        constexpr uint32_t HOST_SLC1HOST_TX_START_INT_ENA = (1U << 15);  ///< HOST_SLC1HOST_TX_START_INT_ENA
        constexpr uint32_t HOST_SLC1_RX_UDF_INT_ENA = (1U << 16);  ///< HOST_SLC1_RX_UDF_INT_ENA
        constexpr uint32_t HOST_SLC1_TX_OVF_INT_ENA = (1U << 17);  ///< HOST_SLC1_TX_OVF_INT_ENA
        constexpr uint32_t HOST_SLC1_RX_PF_VALID_INT_ENA = (1U << 18);  ///< HOST_SLC1_RX_PF_VALID_INT_ENA
        constexpr uint32_t HOST_SLC1_EXT_BIT0_INT_ENA = (1U << 19);  ///< HOST_SLC1_EXT_BIT0_INT_ENA
        constexpr uint32_t HOST_SLC1_EXT_BIT1_INT_ENA = (1U << 20);  ///< HOST_SLC1_EXT_BIT1_INT_ENA
        constexpr uint32_t HOST_SLC1_EXT_BIT2_INT_ENA = (1U << 21);  ///< HOST_SLC1_EXT_BIT2_INT_ENA
        constexpr uint32_t HOST_SLC1_EXT_BIT3_INT_ENA = (1U << 22);  ///< HOST_SLC1_EXT_BIT3_INT_ENA
        constexpr uint32_t HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA = (1U << 23);  ///< HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA
        constexpr uint32_t HOST_SLC1_HOST_RD_RETRY_INT_ENA = (1U << 24);  ///< HOST_SLC1_HOST_RD_RETRY_INT_ENA
        constexpr uint32_t HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA = (1U << 25);  ///< HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA
    }

    /// HOST_SLC0HOST_RX_INFOR Register bits
    namespace host_slc0host_rx_infor_bits {
        constexpr uint32_t HOST_SLC0HOST_RX_INFOR = (20 << 0);  ///< HOST_SLC0HOST_RX_INFOR
    }

    /// HOST_SLC1HOST_RX_INFOR Register bits
    namespace host_slc1host_rx_infor_bits {
        constexpr uint32_t HOST_SLC1HOST_RX_INFOR = (20 << 0);  ///< HOST_SLC1HOST_RX_INFOR
    }

    /// HOST_SLC0HOST_LEN_WD Register bits
    namespace host_slc0host_len_wd_bits {
        constexpr uint32_t HOST_SLC0HOST_LEN_WD = (32 << 0);  ///< HOST_SLC0HOST_LEN_WD
    }

    /// HOST_SLC_APBWIN_WDATA Register bits
    namespace host_slc_apbwin_wdata_bits {
        constexpr uint32_t HOST_SLC_APBWIN_WDATA = (32 << 0);  ///< HOST_SLC_APBWIN_WDATA
    }

    /// HOST_SLC_APBWIN_CONF Register bits
    namespace host_slc_apbwin_conf_bits {
        constexpr uint32_t HOST_SLC_APBWIN_ADDR = (28 << 0);  ///< HOST_SLC_APBWIN_ADDR
        constexpr uint32_t HOST_SLC_APBWIN_WR = (1U << 28);  ///< HOST_SLC_APBWIN_WR
        constexpr uint32_t HOST_SLC_APBWIN_START = (1U << 29);  ///< HOST_SLC_APBWIN_START
    }

    /// HOST_SLC_APBWIN_RDATA Register bits
    namespace host_slc_apbwin_rdata_bits {
        constexpr uint32_t HOST_SLC_APBWIN_RDATA = (32 << 0);  ///< HOST_SLC_APBWIN_RDATA
    }

    /// HOST_SLCHOST_RDCLR0 Register bits
    namespace host_slchost_rdclr0_bits {
        constexpr uint32_t HOST_SLCHOST_SLC0_BIT7_CLRADDR = (9 << 0);  ///< HOST_SLCHOST_SLC0_BIT7_CLRADDR
        constexpr uint32_t HOST_SLCHOST_SLC0_BIT6_CLRADDR = (9 << 9);  ///< HOST_SLCHOST_SLC0_BIT6_CLRADDR
    }

    /// HOST_SLCHOST_RDCLR1 Register bits
    namespace host_slchost_rdclr1_bits {
        constexpr uint32_t HOST_SLCHOST_SLC1_BIT7_CLRADDR = (9 << 0);  ///< HOST_SLCHOST_SLC1_BIT7_CLRADDR
        constexpr uint32_t HOST_SLCHOST_SLC1_BIT6_CLRADDR = (9 << 9);  ///< HOST_SLCHOST_SLC1_BIT6_CLRADDR
    }

    /// HOST_SLC0HOST_INT_ENA1 Register bits
    namespace host_slc0host_int_ena1_bits {
        constexpr uint32_t HOST_SLC0_TOHOST_BIT0_INT_ENA1 = (1U << 0);  ///< HOST_SLC0_TOHOST_BIT0_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT1_INT_ENA1 = (1U << 1);  ///< HOST_SLC0_TOHOST_BIT1_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT2_INT_ENA1 = (1U << 2);  ///< HOST_SLC0_TOHOST_BIT2_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT3_INT_ENA1 = (1U << 3);  ///< HOST_SLC0_TOHOST_BIT3_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT4_INT_ENA1 = (1U << 4);  ///< HOST_SLC0_TOHOST_BIT4_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT5_INT_ENA1 = (1U << 5);  ///< HOST_SLC0_TOHOST_BIT5_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT6_INT_ENA1 = (1U << 6);  ///< HOST_SLC0_TOHOST_BIT6_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOHOST_BIT7_INT_ENA1 = (1U << 7);  ///< HOST_SLC0_TOHOST_BIT7_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOKEN0_1TO0_INT_ENA1 = (1U << 8);  ///< HOST_SLC0_TOKEN0_1TO0_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOKEN1_1TO0_INT_ENA1 = (1U << 9);  ///< HOST_SLC0_TOKEN1_1TO0_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOKEN0_0TO1_INT_ENA1 = (1U << 10);  ///< HOST_SLC0_TOKEN0_0TO1_INT_ENA1
        constexpr uint32_t HOST_SLC0_TOKEN1_0TO1_INT_ENA1 = (1U << 11);  ///< HOST_SLC0_TOKEN1_0TO1_INT_ENA1
        constexpr uint32_t HOST_SLC0HOST_RX_SOF_INT_ENA1 = (1U << 12);  ///< HOST_SLC0HOST_RX_SOF_INT_ENA1
        constexpr uint32_t HOST_SLC0HOST_RX_EOF_INT_ENA1 = (1U << 13);  ///< HOST_SLC0HOST_RX_EOF_INT_ENA1
        constexpr uint32_t HOST_SLC0HOST_RX_START_INT_ENA1 = (1U << 14);  ///< HOST_SLC0HOST_RX_START_INT_ENA1
        constexpr uint32_t HOST_SLC0HOST_TX_START_INT_ENA1 = (1U << 15);  ///< HOST_SLC0HOST_TX_START_INT_ENA1
        constexpr uint32_t HOST_SLC0_RX_UDF_INT_ENA1 = (1U << 16);  ///< HOST_SLC0_RX_UDF_INT_ENA1
        constexpr uint32_t HOST_SLC0_TX_OVF_INT_ENA1 = (1U << 17);  ///< HOST_SLC0_TX_OVF_INT_ENA1
        constexpr uint32_t HOST_SLC0_RX_PF_VALID_INT_ENA1 = (1U << 18);  ///< HOST_SLC0_RX_PF_VALID_INT_ENA1
        constexpr uint32_t HOST_SLC0_EXT_BIT0_INT_ENA1 = (1U << 19);  ///< HOST_SLC0_EXT_BIT0_INT_ENA1
        constexpr uint32_t HOST_SLC0_EXT_BIT1_INT_ENA1 = (1U << 20);  ///< HOST_SLC0_EXT_BIT1_INT_ENA1
        constexpr uint32_t HOST_SLC0_EXT_BIT2_INT_ENA1 = (1U << 21);  ///< HOST_SLC0_EXT_BIT2_INT_ENA1
        constexpr uint32_t HOST_SLC0_EXT_BIT3_INT_ENA1 = (1U << 22);  ///< HOST_SLC0_EXT_BIT3_INT_ENA1
        constexpr uint32_t HOST_SLC0_RX_NEW_PACKET_INT_ENA1 = (1U << 23);  ///< HOST_SLC0_RX_NEW_PACKET_INT_ENA1
        constexpr uint32_t HOST_SLC0_HOST_RD_RETRY_INT_ENA1 = (1U << 24);  ///< HOST_SLC0_HOST_RD_RETRY_INT_ENA1
        constexpr uint32_t HOST_GPIO_SDIO_INT_ENA1 = (1U << 25);  ///< HOST_GPIO_SDIO_INT_ENA1
    }

    /// HOST_SLC1HOST_INT_ENA1 Register bits
    namespace host_slc1host_int_ena1_bits {
        constexpr uint32_t HOST_SLC1_TOHOST_BIT0_INT_ENA1 = (1U << 0);  ///< HOST_SLC1_TOHOST_BIT0_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT1_INT_ENA1 = (1U << 1);  ///< HOST_SLC1_TOHOST_BIT1_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT2_INT_ENA1 = (1U << 2);  ///< HOST_SLC1_TOHOST_BIT2_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT3_INT_ENA1 = (1U << 3);  ///< HOST_SLC1_TOHOST_BIT3_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT4_INT_ENA1 = (1U << 4);  ///< HOST_SLC1_TOHOST_BIT4_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT5_INT_ENA1 = (1U << 5);  ///< HOST_SLC1_TOHOST_BIT5_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT6_INT_ENA1 = (1U << 6);  ///< HOST_SLC1_TOHOST_BIT6_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOHOST_BIT7_INT_ENA1 = (1U << 7);  ///< HOST_SLC1_TOHOST_BIT7_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOKEN0_1TO0_INT_ENA1 = (1U << 8);  ///< HOST_SLC1_TOKEN0_1TO0_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOKEN1_1TO0_INT_ENA1 = (1U << 9);  ///< HOST_SLC1_TOKEN1_1TO0_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOKEN0_0TO1_INT_ENA1 = (1U << 10);  ///< HOST_SLC1_TOKEN0_0TO1_INT_ENA1
        constexpr uint32_t HOST_SLC1_TOKEN1_0TO1_INT_ENA1 = (1U << 11);  ///< HOST_SLC1_TOKEN1_0TO1_INT_ENA1
        constexpr uint32_t HOST_SLC1HOST_RX_SOF_INT_ENA1 = (1U << 12);  ///< HOST_SLC1HOST_RX_SOF_INT_ENA1
        constexpr uint32_t HOST_SLC1HOST_RX_EOF_INT_ENA1 = (1U << 13);  ///< HOST_SLC1HOST_RX_EOF_INT_ENA1
        constexpr uint32_t HOST_SLC1HOST_RX_START_INT_ENA1 = (1U << 14);  ///< HOST_SLC1HOST_RX_START_INT_ENA1
        constexpr uint32_t HOST_SLC1HOST_TX_START_INT_ENA1 = (1U << 15);  ///< HOST_SLC1HOST_TX_START_INT_ENA1
        constexpr uint32_t HOST_SLC1_RX_UDF_INT_ENA1 = (1U << 16);  ///< HOST_SLC1_RX_UDF_INT_ENA1
        constexpr uint32_t HOST_SLC1_TX_OVF_INT_ENA1 = (1U << 17);  ///< HOST_SLC1_TX_OVF_INT_ENA1
        constexpr uint32_t HOST_SLC1_RX_PF_VALID_INT_ENA1 = (1U << 18);  ///< HOST_SLC1_RX_PF_VALID_INT_ENA1
        constexpr uint32_t HOST_SLC1_EXT_BIT0_INT_ENA1 = (1U << 19);  ///< HOST_SLC1_EXT_BIT0_INT_ENA1
        constexpr uint32_t HOST_SLC1_EXT_BIT1_INT_ENA1 = (1U << 20);  ///< HOST_SLC1_EXT_BIT1_INT_ENA1
        constexpr uint32_t HOST_SLC1_EXT_BIT2_INT_ENA1 = (1U << 21);  ///< HOST_SLC1_EXT_BIT2_INT_ENA1
        constexpr uint32_t HOST_SLC1_EXT_BIT3_INT_ENA1 = (1U << 22);  ///< HOST_SLC1_EXT_BIT3_INT_ENA1
        constexpr uint32_t HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA1 = (1U << 23);  ///< HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA1
        constexpr uint32_t HOST_SLC1_HOST_RD_RETRY_INT_ENA1 = (1U << 24);  ///< HOST_SLC1_HOST_RD_RETRY_INT_ENA1
        constexpr uint32_t HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA1 = (1U << 25);  ///< HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA1
    }

    /// HOST_SLCHOSTDATE Register bits
    namespace host_slchostdate_bits {
        constexpr uint32_t HOST_SLCHOST_DATE = (32 << 0);  ///< HOST_SLCHOST_DATE
    }

    /// HOST_SLCHOSTID Register bits
    namespace host_slchostid_bits {
        constexpr uint32_t HOST_SLCHOST_ID = (32 << 0);  ///< HOST_SLCHOST_ID
    }

    /// HOST_SLCHOST_CONF Register bits
    namespace host_slchost_conf_bits {
        constexpr uint32_t HOST_FRC_SDIO11 = (5 << 0);  ///< HOST_FRC_SDIO11
        constexpr uint32_t HOST_FRC_SDIO20 = (5 << 5);  ///< HOST_FRC_SDIO20
        constexpr uint32_t HOST_FRC_NEG_SAMP = (5 << 10);  ///< HOST_FRC_NEG_SAMP
        constexpr uint32_t HOST_FRC_POS_SAMP = (5 << 15);  ///< HOST_FRC_POS_SAMP
        constexpr uint32_t HOST_FRC_QUICK_IN = (5 << 20);  ///< HOST_FRC_QUICK_IN
        constexpr uint32_t HOST_SDIO20_INT_DELAY = (1U << 25);  ///< HOST_SDIO20_INT_DELAY
        constexpr uint32_t HOST_SDIO_PAD_PULLUP = (1U << 26);  ///< HOST_SDIO_PAD_PULLUP
        constexpr uint32_t HOST_HSPEED_CON_EN = (1U << 27);  ///< HOST_HSPEED_CON_EN
    }

    /// HOST_SLCHOST_INF_ST Register bits
    namespace host_slchost_inf_st_bits {
        constexpr uint32_t HOST_SDIO20_MODE = (5 << 0);  ///< HOST_SDIO20_MODE
        constexpr uint32_t HOST_SDIO_NEG_SAMP = (5 << 5);  ///< HOST_SDIO_NEG_SAMP
        constexpr uint32_t HOST_SDIO_QUICK_IN = (5 << 10);  ///< HOST_SDIO_QUICK_IN
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x3FF43000;
    constexpr uint32_t SPI1_BASE = 0x3FF42000;
    constexpr uint32_t SPI2_BASE = 0x3FF64000;
    constexpr uint32_t SPI3_BASE = 0x3FF65000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CMD;  ///< Offset: 0x00 - program erase resume bit program erase suspend operation...
        volatile uint32_t ADDR;  ///< Offset: 0x04 - 
        volatile uint32_t CTRL;  ///< Offset: 0x08 - For SPI1 initialize crc32 module before writing...
        volatile uint32_t CTRL1;  ///< Offset: 0x0C - Delay cycles of resume Flash when resume Flash is enable...
        volatile uint32_t RD_STATUS;  ///< Offset: 0x10 - In the slave mode, it is the status for master to read out.
        volatile uint32_t CTRL2;  ///< Offset: 0x14 - (cycles-1) of ¡°prepare¡± phase by spi clock, this bits...
        volatile uint32_t CLOCK;  ///< Offset: 0x18 - In the master mode it must be equal to spi_clkcnt_N. In...
        volatile uint32_t USER;  ///< Offset: 0x1C - Set the bit to enable full duplex communication. 1:...
        volatile uint32_t USER1;  ///< Offset: 0x20 - The length in spi_clk cycles of dummy phase. The...
        volatile uint32_t USER2;  ///< Offset: 0x24 - The value of command.
        volatile uint32_t MOSI_DLEN;  ///< Offset: 0x28 - The length in bits of write-data. The register value...
        volatile uint32_t MISO_DLEN;  ///< Offset: 0x2C - The length in bits of read-data. The register value...
        volatile uint32_t SLV_WR_STATUS;  ///< Offset: 0x30 - In the slave mode this register are the status register...
        volatile uint32_t PIN;  ///< Offset: 0x34 - SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is...
        volatile uint32_t SLAVE;  ///< Offset: 0x38 - The interrupt raw bit for the completion of read-buffer...
        volatile uint32_t SLAVE1;  ///< Offset: 0x3C - In the slave mode it is the enable bit of dummy phase...
        volatile uint32_t SLAVE2;  ///< Offset: 0x40 - In the slave mode it is the length in spi_clk cycles of...
        volatile uint32_t SLAVE3;  ///< Offset: 0x44 - In the slave mode it is the value of read-buffer command.
        volatile uint32_t SLV_WRBUF_DLEN;  ///< Offset: 0x48 - In the slave mode it is the length in bits for...
        volatile uint32_t SLV_RDBUF_DLEN;  ///< Offset: 0x4C - In the slave mode it is the length in bits for...
        volatile uint32_t CACHE_FCTRL;  ///< Offset: 0x50 - For SPI0 Cache access enable 1: enable 0:disable.
        volatile uint32_t CACHE_SCTRL;  ///< Offset: 0x54 - For SPI0 In the spi sram mode spi dual I/O mode enable...
        volatile uint32_t SRAM_CMD;  ///< Offset: 0x58 - For SPI0 SRAM DIO mode enable . SRAM DIO enable command...
        volatile uint32_t SRAM_DRD_CMD;  ///< Offset: 0x5C - For SPI0 When cache mode is enable it is the read...
        volatile uint32_t SRAM_DWR_CMD;  ///< Offset: 0x60 - For SPI0 When cache mode is enable it is the write...
        volatile uint32_t SLV_RD_BIT;  ///< Offset: 0x64 - In the slave mode it is the bit length of read data. The...
        volatile uint32_t W0;  ///< Offset: 0x80 - data buffer
        volatile uint32_t W1;  ///< Offset: 0x84 - data buffer
        volatile uint32_t W2;  ///< Offset: 0x88 - data buffer
        volatile uint32_t W3;  ///< Offset: 0x8C - data buffer
        volatile uint32_t W4;  ///< Offset: 0x90 - data buffer
        volatile uint32_t W5;  ///< Offset: 0x94 - data buffer
        volatile uint32_t W6;  ///< Offset: 0x98 - data buffer
        volatile uint32_t W7;  ///< Offset: 0x9C - data buffer
        volatile uint32_t W8;  ///< Offset: 0xA0 - data buffer
        volatile uint32_t W9;  ///< Offset: 0xA4 - data buffer
        volatile uint32_t W10;  ///< Offset: 0xA8 - data buffer
        volatile uint32_t W11;  ///< Offset: 0xAC - data buffer
        volatile uint32_t W12;  ///< Offset: 0xB0 - data buffer
        volatile uint32_t W13;  ///< Offset: 0xB4 - data buffer
        volatile uint32_t W14;  ///< Offset: 0xB8 - data buffer
        volatile uint32_t W15;  ///< Offset: 0xBC - data buffer
        volatile uint32_t TX_CRC;  ///< Offset: 0xC0 - For SPI1 the value of crc32 for 256 bits data.
        volatile uint32_t EXT0;  ///< Offset: 0xF0 - page program delay time by system clock.
        volatile uint32_t EXT1;  ///< Offset: 0xF4 - erase flash delay time by system clock.
        volatile uint32_t EXT2;  ///< Offset: 0xF8 - The status of spi state machine .
        volatile uint32_t EXT3;  ///< Offset: 0xFC - This register is for two SPI masters to share the same...
        volatile uint32_t DMA_CONF;  ///< Offset: 0x100 - The bit is used to reset in dma fsm and in data fifo pointer.
        volatile uint32_t DMA_OUT_LINK;  ///< Offset: 0x104 - The address of the first outlink descriptor.
        volatile uint32_t DMA_IN_LINK;  ///< Offset: 0x108 - The address of the first inlink descriptor.
        volatile uint32_t DMA_STATUS;  ///< Offset: 0x10C - spi dma read data status bit.
        volatile uint32_t DMA_INT_ENA;  ///< Offset: 0x110 - The enable bit for lack of enough inlink descriptors.
        volatile uint32_t DMA_INT_RAW;  ///< Offset: 0x114 - The raw bit for lack of enough inlink descriptors.
        volatile uint32_t DMA_INT_ST;  ///< Offset: 0x118 - The status bit for lack of enough inlink descriptors.
        volatile uint32_t DMA_INT_CLR;  ///< Offset: 0x11C - The clear bit for lack of enough inlink descriptors.
        volatile uint32_t IN_ERR_EOF_DES_ADDR;  ///< Offset: 0x120 - The inlink descriptor address when spi dma produce...
        volatile uint32_t IN_SUC_EOF_DES_ADDR;  ///< Offset: 0x124 - The last inlink descriptor address when spi dma produce...
        volatile uint32_t INLINK_DSCR;  ///< Offset: 0x128 - The content of current in descriptor pointer.
        volatile uint32_t INLINK_DSCR_BF0;  ///< Offset: 0x12C - The content of next in descriptor pointer.
        volatile uint32_t INLINK_DSCR_BF1;  ///< Offset: 0x130 - The content of current in descriptor data buffer pointer.
        volatile uint32_t OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x134 - The address of buffer relative to the outlink descriptor...
        volatile uint32_t OUT_EOF_DES_ADDR;  ///< Offset: 0x138 - The last outlink descriptor address when spi dma produce to_eof.
        volatile uint32_t OUTLINK_DSCR;  ///< Offset: 0x13C - The content of current out descriptor pointer.
        volatile uint32_t OUTLINK_DSCR_BF0;  ///< Offset: 0x140 - The content of next out descriptor pointer.
        volatile uint32_t OUTLINK_DSCR_BF1;  ///< Offset: 0x144 - The content of current out descriptor data buffer pointer.
        volatile uint32_t DMA_RSTATUS;  ///< Offset: 0x148 - spi dma read data from memory status.
        volatile uint32_t DMA_TSTATUS;  ///< Offset: 0x14C - spi dma write data to memory status.
        volatile uint32_t DATE;  ///< Offset: 0x3FC - SPI register version.
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);

    // Bit definitions
    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t FLASH_PER = (1U << 16);  ///< program erase resume bit program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_PES = (1U << 17);  ///< program erase suspend bit program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t USR = (1U << 18);  ///< User define command enable. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_HPM = (1U << 19);  ///< Drive Flash into high performance mode. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_RES = (1U << 20);  ///< This bit combined with reg_resandres bit releases Flash from the power-down state or high performance mode and obtains the devices ID. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_DP = (1U << 21);  ///< Drive Flash into power down. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_CE = (1U << 22);  ///< Chip erase enable. Chip erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_BE = (1U << 23);  ///< Block erase enable. A 64KB block is erased via SPI command D8H. Block erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_SE = (1U << 24);  ///< Sector erase enable. A 4KB sector is erased via SPI command 20H. Sector erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_PP = (1U << 25);  ///< Page program enable(1 byte ~256 bytes data to be programmed). Page program operation will be triggered when the bit is set. The bit will be cleared once the operation done .1: enable 0: disable.
        constexpr uint32_t FLASH_WRSR = (1U << 26);  ///< Write status register enable. Write status operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_RDSR = (1U << 27);  ///< Read status register-1. Read status operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        constexpr uint32_t FLASH_RDID = (1U << 28);  ///< Read JEDEC ID . Read ID command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
        constexpr uint32_t FLASH_WRDI = (1U << 29);  ///< Write flash disable. Write disable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
        constexpr uint32_t FLASH_WREN = (1U << 30);  ///< Write flash enable. Write enable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
        constexpr uint32_t FLASH_READ = (1U << 31);  ///< Read flash enable. Read flash operation will be triggered when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FCS_CRC_EN = (1U << 10);  ///< For SPI1 initialize crc32 module before writing encrypted data to flash. Active low.
        constexpr uint32_t TX_CRC_EN = (1U << 11);  ///< For SPI1 enable crc32 when writing encrypted data to flash. 1: enable 0:disable
        constexpr uint32_t WAIT_FLASH_IDLE_EN = (1U << 12);  ///< wait flash idle when program flash or erase flash. 1: enable 0: disable.
        constexpr uint32_t FASTRD_MODE = (1U << 13);  ///< This bit enable the bits: spi_fread_qio spi_fread_dio spi_fread_qout and spi_fread_dout. 1: enable 0: disable.
        constexpr uint32_t FREAD_DUAL = (1U << 14);  ///< In the read operations read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t RESANDRES = (1U << 15);  ///< The Device ID is read out to SPI_RD_STATUS register, this bit combine with spi_flash_res bit. 1: enable 0: disable.
        constexpr uint32_t FREAD_QUAD = (1U << 20);  ///< In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high 0: output low.
        constexpr uint32_t WRSR_2B = (1U << 22);  ///< two bytes data will be written to status register when it is set. 1: enable 0: disable.
        constexpr uint32_t FREAD_DIO = (1U << 23);  ///< In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t FREAD_QIO = (1U << 24);  ///< In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t RD_BIT_ORDER = (1U << 25);  ///< In read-data (MISO) phase 1: LSB first 0: MSB first
        constexpr uint32_t WR_BIT_ORDER = (1U << 26);  ///< In command address write-data (MOSI) phases 1: LSB firs 0: MSB first
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t CS_HOLD_DELAY_RES = (12 << 16);  ///< Delay cycles of resume Flash when resume Flash is enable by spi clock.
        constexpr uint32_t CS_HOLD_DELAY = (4 << 28);  ///< SPI cs signal is delayed by spi clock cycles
    }

    /// RD_STATUS Register bits
    namespace rd_status_bits {
        constexpr uint32_t STATUS = (16 << 0);  ///< In the slave mode, it is the status for master to read out.
        constexpr uint32_t WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode, it is combined with spi_fastrd_mode bit.
        constexpr uint32_t STATUS_EXT = (8 << 24);  ///< In the slave mode,it is the status for master to read out.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t SETUP_TIME = (4 << 0);  ///< (cycles-1) of ¡°prepare¡± phase by spi clock, this bits combined with spi_cs_setup bit.
        constexpr uint32_t HOLD_TIME = (4 << 4);  ///< delay cycles of cs pin by spi clock, this bits combined with spi_cs_hold bit.
        constexpr uint32_t CK_OUT_LOW_MODE = (4 << 8);  ///< modify spi clock duty ratio when the value is lager than 8, the bits are combined with spi_clkcnt_N bits and spi_clkcnt_L bits.
        constexpr uint32_t CK_OUT_HIGH_MODE = (4 << 12);  ///< modify spi clock duty ratio when the value is lager than 8, the bits are combined with spi_clkcnt_N bits and spi_clkcnt_H bits.
        constexpr uint32_t MISO_DELAY_MODE = (2 << 16);  ///< MISO signals are delayed by spi_clk. 0: zero 1: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by half cycle else delayed by one cycle 2: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by one cycle else delayed by half cycle 3: delayed one cycle
        constexpr uint32_t MISO_DELAY_NUM = (3 << 18);  ///< MISO signals are delayed by system clock cycles
        constexpr uint32_t MOSI_DELAY_MODE = (2 << 21);  ///< MOSI signals are delayed by spi_clk. 0: zero 1: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by half cycle else delayed by one cycle 2: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by one cycle else delayed by half cycle 3: delayed one cycle
        constexpr uint32_t MOSI_DELAY_NUM = (3 << 23);  ///< MOSI signals are delayed by system clock cycles
        constexpr uint32_t CS_DELAY_MODE = (2 << 26);  ///< spi_cs signal is delayed by spi_clk . 0: zero 1: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by half cycle else delayed by one cycle 2: if spi_ck_out_edge or spi_ck_i_edge is set 1 delayed by one cycle else delayed by half cycle 3: delayed one cycle
        constexpr uint32_t CS_DELAY_NUM = (4 << 28);  ///< spi_cs signal is delayed by system clock cycles
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLKCNT_L = (6 << 0);  ///< In the master mode it must be equal to spi_clkcnt_N. In the slave mode it must be 0.
        constexpr uint32_t CLKCNT_H = (6 << 6);  ///< In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode it must be 0.
        constexpr uint32_t CLKCNT_N = (6 << 12);  ///< In the master mode it is the divider of spi_clk. So spi_clk frequency is system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1)
        constexpr uint32_t CLKDIV_PRE = (13 << 18);  ///< In the master mode it is pre-divider of spi_clk.
        constexpr uint32_t CLK_EQU_SYSCLK = (1U << 31);  ///< In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from system clock.
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t DOUTDIN = (1U << 0);  ///< Set the bit to enable full duplex communication. 1: enable 0: disable.
        constexpr uint32_t CS_HOLD = (1U << 4);  ///< spi cs keep low when spi is in ¡°done¡± phase. 1: enable 0: disable.
        constexpr uint32_t CS_SETUP = (1U << 5);  ///< spi cs is enable when spi is in ¡°prepare¡± phase. 1: enable 0: disable.
        constexpr uint32_t CK_I_EDGE = (1U << 6);  ///< In the slave mode the bit is same as spi_ck_out_edge in master mode. It is combined with spi_miso_delay_mode bits.
        constexpr uint32_t CK_OUT_EDGE = (1U << 7);  ///< the bit combined with spi_mosi_delay_mode bits to set mosi signal delay mode.
        constexpr uint32_t RD_BYTE_ORDER = (1U << 10);  ///< In read-data (MISO) phase 1: big-endian 0: little_endian
        constexpr uint32_t WR_BYTE_ORDER = (1U << 11);  ///< In command address write-data (MOSI) phases 1: big-endian 0: litte_endian
        constexpr uint32_t FWRITE_DUAL = (1U << 12);  ///< In the write operations read-data phase apply 2 signals
        constexpr uint32_t FWRITE_QUAD = (1U << 13);  ///< In the write operations read-data phase apply 4 signals
        constexpr uint32_t FWRITE_DIO = (1U << 14);  ///< In the write operations address phase and read-data phase apply 2 signals.
        constexpr uint32_t FWRITE_QIO = (1U << 15);  ///< In the write operations address phase and read-data phase apply 4 signals.
        constexpr uint32_t SIO = (1U << 16);  ///< Set the bit to enable 3-line half duplex communication mosi and miso signals share the same pin. 1: enable 0: disable.
        constexpr uint32_t USR_HOLD_POL = (1U << 17);  ///< It is combined with hold bits to set the polarity of spi hold line 1: spi will be held when spi hold line is high 0: spi will be held when spi hold line is low
        constexpr uint32_t USR_DOUT_HOLD = (1U << 18);  ///< spi is hold at data out state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_DIN_HOLD = (1U << 19);  ///< spi is hold at data in state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_DUMMY_HOLD = (1U << 20);  ///< spi is hold at dummy state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_ADDR_HOLD = (1U << 21);  ///< spi is hold at address state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_CMD_HOLD = (1U << 22);  ///< spi is hold at command state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_PREP_HOLD = (1U << 23);  ///< spi is hold at prepare state the bit combined with spi_usr_hold_pol bit.
        constexpr uint32_t USR_MISO_HIGHPART = (1U << 24);  ///< read-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.
        constexpr uint32_t USR_MOSI_HIGHPART = (1U << 25);  ///< write-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.
        constexpr uint32_t USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable.
        constexpr uint32_t USR_MOSI = (1U << 27);  ///< This bit enable the write-data phase of an operation.
        constexpr uint32_t USR_MISO = (1U << 28);  ///< This bit enable the read-data phase of an operation.
        constexpr uint32_t USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation.
        constexpr uint32_t USR_ADDR = (1U << 30);  ///< This bit enable the address phase of an operation.
        constexpr uint32_t USR_COMMAND = (1U << 31);  ///< This bit enable the command phase of an operation.
    }

    /// USER1 Register bits
    namespace user1_bits {
        constexpr uint32_t USR_DUMMY_CYCLELEN = (8 << 0);  ///< The length in spi_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        constexpr uint32_t USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of address phase. The register value shall be (bit_num-1).
    }

    /// USER2 Register bits
    namespace user2_bits {
        constexpr uint32_t USR_COMMAND_VALUE = (16 << 0);  ///< The value of command.
        constexpr uint32_t USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1)
    }

    /// MOSI_DLEN Register bits
    namespace mosi_dlen_bits {
        constexpr uint32_t USR_MOSI_DBITLEN = (24 << 0);  ///< The length in bits of write-data. The register value shall be (bit_num-1).
    }

    /// MISO_DLEN Register bits
    namespace miso_dlen_bits {
        constexpr uint32_t USR_MISO_DBITLEN = (24 << 0);  ///< The length in bits of read-data. The register value shall be (bit_num-1).
    }

    /// SLV_WR_STATUS Register bits
    namespace slv_wr_status_bits {
        constexpr uint32_t SLV_WR_ST = (32 << 0);  ///< In the slave mode this register are the status register for the master to write into. In the master mode this register are the higher 32bits in the 64 bits address condition.
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t CS0_DIS = (1U << 0);  ///< SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to CS0 pin
        constexpr uint32_t CS1_DIS = (1U << 1);  ///< SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to CS1 pin
        constexpr uint32_t CS2_DIS = (1U << 2);  ///< SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to CS2 pin
        constexpr uint32_t CK_DIS = (1U << 5);  ///< 1: spi clk out disable 0: spi clk out enable
        constexpr uint32_t MASTER_CS_POL = (3 << 6);  ///< In the master mode the bits are the polarity of spi cs line the value is equivalent to spi_cs ^ spi_master_cs_pol.
        constexpr uint32_t MASTER_CK_SEL = (3 << 11);  ///< In the master mode spi cs line is enable as spi clk it is combined with spi_cs0_dis spi_cs1_dis spi_cs2_dis.
        constexpr uint32_t CK_IDLE_EDGE = (1U << 29);  ///< 1: spi clk line is high when idle 0: spi clk line is low when idle
        constexpr uint32_t CS_KEEP_ACTIVE = (1U << 30);  ///< spi cs line keep low when the bit is set.
    }

    /// SLAVE Register bits
    namespace slave_bits {
        constexpr uint32_t SLV_RD_BUF_DONE = (1U << 0);  ///< The interrupt raw bit for the completion of read-buffer operation in the slave mode.
        constexpr uint32_t SLV_WR_BUF_DONE = (1U << 1);  ///< The interrupt raw bit for the completion of write-buffer operation in the slave mode.
        constexpr uint32_t SLV_RD_STA_DONE = (1U << 2);  ///< The interrupt raw bit for the completion of read-status operation in the slave mode.
        constexpr uint32_t SLV_WR_STA_DONE = (1U << 3);  ///< The interrupt raw bit for the completion of write-status operation in the slave mode.
        constexpr uint32_t TRANS_DONE = (1U << 4);  ///< The interrupt raw bit for the completion of any operation in both the master mode and the slave mode.
        constexpr uint32_t INT_EN = (5 << 5);  ///< Interrupt enable bits for the below 5 sources
        constexpr uint32_t CS_I_MODE = (2 << 10);  ///< In the slave mode this bits used to synchronize the input spi cs signal and eliminate spi cs jitter.
        constexpr uint32_t SLV_LAST_COMMAND = (3 << 17);  ///< In the slave mode it is the value of command.
        constexpr uint32_t SLV_LAST_STATE = (3 << 20);  ///< In the slave mode it is the state of spi state machine.
        constexpr uint32_t TRANS_CNT = (4 << 23);  ///< The operations counter in both the master mode and the slave mode. 4: read-status
        constexpr uint32_t SLV_CMD_DEFINE = (1U << 27);  ///< 1: slave mode commands are defined in SPI_SLAVE3. 0: slave mode commands are fixed as: 1: write-status 2: write-buffer and 3: read-buffer.
        constexpr uint32_t SLV_WR_RD_STA_EN = (1U << 28);  ///< write and read status enable in the slave mode
        constexpr uint32_t SLV_WR_RD_BUF_EN = (1U << 29);  ///< write and read buffer enable in the slave mode
        constexpr uint32_t MODE = (1U << 30);  ///< 1: slave mode 0: master mode.
        constexpr uint32_t SYNC_RESET = (1U << 31);  ///< Software reset enable, reset the spi clock line cs line and data lines.
    }

    /// SLAVE1 Register bits
    namespace slave1_bits {
        constexpr uint32_t SLV_RDBUF_DUMMY_EN = (1U << 0);  ///< In the slave mode it is the enable bit of dummy phase for read-buffer operations.
        constexpr uint32_t SLV_WRBUF_DUMMY_EN = (1U << 1);  ///< In the slave mode it is the enable bit of dummy phase for write-buffer operations.
        constexpr uint32_t SLV_RDSTA_DUMMY_EN = (1U << 2);  ///< In the slave mode it is the enable bit of dummy phase for read-status operations.
        constexpr uint32_t SLV_WRSTA_DUMMY_EN = (1U << 3);  ///< In the slave mode it is the enable bit of dummy phase for write-status operations.
        constexpr uint32_t SLV_WR_ADDR_BITLEN = (6 << 4);  ///< In the slave mode it is the address length in bits for write-buffer operation. The register value shall be (bit_num-1).
        constexpr uint32_t SLV_RD_ADDR_BITLEN = (6 << 10);  ///< In the slave mode it is the address length in bits for read-buffer operation. The register value shall be (bit_num-1).
        constexpr uint32_t SLV_STATUS_READBACK = (1U << 25);  ///< In the slave mode 1:read register of SPI_SLV_WR_STATUS 0: read register of SPI_RD_STATUS.
        constexpr uint32_t SLV_STATUS_FAST_EN = (1U << 26);  ///< In the slave mode enable fast read status.
        constexpr uint32_t SLV_STATUS_BITLEN = (5 << 27);  ///< In the slave mode it is the length of status bit.
    }

    /// SLAVE2 Register bits
    namespace slave2_bits {
        constexpr uint32_t SLV_RDSTA_DUMMY_CYCLELEN = (8 << 0);  ///< In the slave mode it is the length in spi_clk cycles of dummy phase for read-status operations. The register value shall be (cycle_num-1).
        constexpr uint32_t SLV_WRSTA_DUMMY_CYCLELEN = (8 << 8);  ///< In the slave mode it is the length in spi_clk cycles of dummy phase for write-status operations. The register value shall be (cycle_num-1).
        constexpr uint32_t SLV_RDBUF_DUMMY_CYCLELEN = (8 << 16);  ///< In the slave mode it is the length in spi_clk cycles of dummy phase for read-buffer operations. The register value shall be (cycle_num-1).
        constexpr uint32_t SLV_WRBUF_DUMMY_CYCLELEN = (8 << 24);  ///< In the slave mode it is the length in spi_clk cycles of dummy phase for write-buffer operations. The register value shall be (cycle_num-1).
    }

    /// SLAVE3 Register bits
    namespace slave3_bits {
        constexpr uint32_t SLV_RDBUF_CMD_VALUE = (8 << 0);  ///< In the slave mode it is the value of read-buffer command.
        constexpr uint32_t SLV_WRBUF_CMD_VALUE = (8 << 8);  ///< In the slave mode it is the value of write-buffer command.
        constexpr uint32_t SLV_RDSTA_CMD_VALUE = (8 << 16);  ///< In the slave mode it is the value of read-status command.
        constexpr uint32_t SLV_WRSTA_CMD_VALUE = (8 << 24);  ///< In the slave mode it is the value of write-status command.
    }

    /// SLV_WRBUF_DLEN Register bits
    namespace slv_wrbuf_dlen_bits {
        constexpr uint32_t SLV_WRBUF_DBITLEN = (24 << 0);  ///< In the slave mode it is the length in bits for write-buffer operations. The register value shall be (bit_num-1).
    }

    /// SLV_RDBUF_DLEN Register bits
    namespace slv_rdbuf_dlen_bits {
        constexpr uint32_t SLV_RDBUF_DBITLEN = (24 << 0);  ///< In the slave mode it is the length in bits for read-buffer operations. The register value shall be (bit_num-1).
    }

    /// CACHE_FCTRL Register bits
    namespace cache_fctrl_bits {
        constexpr uint32_t CACHE_REQ_EN = (1U << 0);  ///< For SPI0 Cache access enable 1: enable 0:disable.
        constexpr uint32_t CACHE_USR_CMD_4BYTE = (1U << 1);  ///< For SPI0 cache read flash with 4 bytes command 1: enable 0:disable.
        constexpr uint32_t CACHE_FLASH_USR_CMD = (1U << 2);  ///< For SPI0 cache read flash for user define command 1: enable 0:disable.
        constexpr uint32_t CACHE_FLASH_PES_EN = (1U << 3);  ///< For SPI0 spi1 send suspend command before cache read flash 1: enable 0:disable.
    }

    /// CACHE_SCTRL Register bits
    namespace cache_sctrl_bits {
        constexpr uint32_t USR_SRAM_DIO = (1U << 1);  ///< For SPI0 In the spi sram mode spi dual I/O mode enable 1: enable 0:disable
        constexpr uint32_t USR_SRAM_QIO = (1U << 2);  ///< For SPI0 In the spi sram mode spi quad I/O mode enable 1: enable 0:disable
        constexpr uint32_t USR_WR_SRAM_DUMMY = (1U << 3);  ///< For SPI0 In the spi sram mode it is the enable bit of dummy phase for write operations.
        constexpr uint32_t USR_RD_SRAM_DUMMY = (1U << 4);  ///< For SPI0 In the spi sram mode it is the enable bit of dummy phase for read operations.
        constexpr uint32_t CACHE_SRAM_USR_RCMD = (1U << 5);  ///< For SPI0 In the spi sram mode cache read sram for user define command.
        constexpr uint32_t SRAM_BYTES_LEN = (8 << 6);  ///< For SPI0 In the sram mode it is the byte length of spi read sram data.
        constexpr uint32_t SRAM_DUMMY_CYCLELEN = (8 << 14);  ///< For SPI0 In the sram mode it is the length in bits of address phase. The register value shall be (bit_num-1).
        constexpr uint32_t SRAM_ADDR_BITLEN = (6 << 22);  ///< For SPI0 In the sram mode it is the length in bits of address phase. The register value shall be (bit_num-1).
        constexpr uint32_t CACHE_SRAM_USR_WCMD = (1U << 28);  ///< For SPI0 In the spi sram mode cache write sram for user define command
    }

    /// SRAM_CMD Register bits
    namespace sram_cmd_bits {
        constexpr uint32_t SRAM_DIO = (1U << 0);  ///< For SPI0 SRAM DIO mode enable . SRAM DIO enable command will be send when the bit is set. The bit will be cleared once the operation done.
        constexpr uint32_t SRAM_QIO = (1U << 1);  ///< For SPI0 SRAM QIO mode enable . SRAM QIO enable command will be send when the bit is set. The bit will be cleared once the operation done.
        constexpr uint32_t SRAM_RSTIO = (1U << 4);  ///< For SPI0 SRAM IO mode reset enable. SRAM IO mode reset operation will be triggered when the bit is set. The bit will be cleared once the operation done
    }

    /// SRAM_DRD_CMD Register bits
    namespace sram_drd_cmd_bits {
        constexpr uint32_t CACHE_SRAM_USR_RD_CMD_VALUE = (16 << 0);  ///< For SPI0 When cache mode is enable it is the read command value of command phase for SRAM.
        constexpr uint32_t CACHE_SRAM_USR_RD_CMD_BITLEN = (4 << 28);  ///< For SPI0 When cache mode is enable it is the length in bits of command phase for SRAM. The register value shall be (bit_num-1).
    }

    /// SRAM_DWR_CMD Register bits
    namespace sram_dwr_cmd_bits {
        constexpr uint32_t CACHE_SRAM_USR_WR_CMD_VALUE = (16 << 0);  ///< For SPI0 When cache mode is enable it is the write command value of command phase for SRAM.
        constexpr uint32_t CACHE_SRAM_USR_WR_CMD_BITLEN = (4 << 28);  ///< For SPI0 When cache mode is enable it is the in bits of command phase for SRAM. The register value shall be (bit_num-1).
    }

    /// SLV_RD_BIT Register bits
    namespace slv_rd_bit_bits {
        constexpr uint32_t SLV_RDATA_BIT = (24 << 0);  ///< In the slave mode it is the bit length of read data. The value is the length - 1.
    }

    /// W0 Register bits
    namespace w0_bits {
        constexpr uint32_t BUF0 = (32 << 0);  ///< data buffer
    }

    /// W1 Register bits
    namespace w1_bits {
        constexpr uint32_t BUF1 = (32 << 0);  ///< data buffer
    }

    /// W2 Register bits
    namespace w2_bits {
        constexpr uint32_t BUF2 = (32 << 0);  ///< data buffer
    }

    /// W3 Register bits
    namespace w3_bits {
        constexpr uint32_t BUF3 = (32 << 0);  ///< data buffer
    }

    /// W4 Register bits
    namespace w4_bits {
        constexpr uint32_t BUF4 = (32 << 0);  ///< data buffer
    }

    /// W5 Register bits
    namespace w5_bits {
        constexpr uint32_t BUF5 = (32 << 0);  ///< data buffer
    }

    /// W6 Register bits
    namespace w6_bits {
        constexpr uint32_t BUF6 = (32 << 0);  ///< data buffer
    }

    /// W7 Register bits
    namespace w7_bits {
        constexpr uint32_t BUF7 = (32 << 0);  ///< data buffer
    }

    /// W8 Register bits
    namespace w8_bits {
        constexpr uint32_t BUF8 = (32 << 0);  ///< data buffer
    }

    /// W9 Register bits
    namespace w9_bits {
        constexpr uint32_t BUF9 = (32 << 0);  ///< data buffer
    }

    /// W10 Register bits
    namespace w10_bits {
        constexpr uint32_t BUF10 = (32 << 0);  ///< data buffer
    }

    /// W11 Register bits
    namespace w11_bits {
        constexpr uint32_t BUF11 = (32 << 0);  ///< data buffer
    }

    /// W12 Register bits
    namespace w12_bits {
        constexpr uint32_t BUF12 = (32 << 0);  ///< data buffer
    }

    /// W13 Register bits
    namespace w13_bits {
        constexpr uint32_t BUF13 = (32 << 0);  ///< data buffer
    }

    /// W14 Register bits
    namespace w14_bits {
        constexpr uint32_t BUF14 = (32 << 0);  ///< data buffer
    }

    /// W15 Register bits
    namespace w15_bits {
        constexpr uint32_t BUF15 = (32 << 0);  ///< data buffer
    }

    /// TX_CRC Register bits
    namespace tx_crc_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< For SPI1 the value of crc32 for 256 bits data.
    }

    /// EXT0 Register bits
    namespace ext0_bits {
        constexpr uint32_t T_PP_TIME = (12 << 0);  ///< page program delay time by system clock.
        constexpr uint32_t T_PP_SHIFT = (4 << 16);  ///< page program delay time shift .
        constexpr uint32_t T_PP_ENA = (1U << 31);  ///< page program delay enable.
    }

    /// EXT1 Register bits
    namespace ext1_bits {
        constexpr uint32_t T_ERASE_TIME = (12 << 0);  ///< erase flash delay time by system clock.
        constexpr uint32_t T_ERASE_SHIFT = (4 << 16);  ///< erase flash delay time shift.
        constexpr uint32_t T_ERASE_ENA = (1U << 31);  ///< erase flash delay enable.
    }

    /// EXT2 Register bits
    namespace ext2_bits {
        constexpr uint32_t ST = (3 << 0);  ///< The status of spi state machine .
    }

    /// EXT3 Register bits
    namespace ext3_bits {
        constexpr uint32_t INT_HOLD_ENA = (2 << 0);  ///< This register is for two SPI masters to share the same cs clock and data signals. The bits of one SPI are set if the other SPI is busy the SPI will be hold. 1(3): hold at ¡°idle¡± phase 2: hold at ¡°prepare¡± phase.
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t IN_RST = (1U << 2);  ///< The bit is used to reset in dma fsm and in data fifo pointer.
        constexpr uint32_t OUT_RST = (1U << 3);  ///< The bit is used to reset out dma fsm and out data fifo pointer.
        constexpr uint32_t AHBM_FIFO_RST = (1U << 4);  ///< reset spi dma ahb master fifo pointer.
        constexpr uint32_t AHBM_RST = (1U << 5);  ///< reset spi dma ahb master.
        constexpr uint32_t IN_LOOP_TEST = (1U << 6);  ///< Set bit to test in link.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 7);  ///< Set bit to test out link.
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 8);  ///< when the link is empty jump to next automatically.
        constexpr uint32_t OUT_EOF_MODE = (1U << 9);  ///< out eof flag generation mode . 1: when dma pop all data from fifo 0:when ahb push all data to fifo.
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 10);  ///< read descriptor use burst mode when read data for memory.
        constexpr uint32_t INDSCR_BURST_EN = (1U << 11);  ///< read descriptor use burst mode when write data to memory.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 12);  ///< spi dma read data from memory in burst mode.
        constexpr uint32_t DMA_RX_STOP = (1U << 14);  ///< spi dma read data stop when in continue tx/rx mode.
        constexpr uint32_t DMA_TX_STOP = (1U << 15);  ///< spi dma write data stop when in continue tx/rx mode.
        constexpr uint32_t DMA_CONTINUE = (1U << 16);  ///< spi dma continue tx/rx data.
    }

    /// DMA_OUT_LINK Register bits
    namespace dma_out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< The address of the first outlink descriptor.
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< Set the bit to stop to use outlink descriptor.
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< Set the bit to start to use outlink descriptor.
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< Set the bit to mount on new outlink descriptors.
    }

    /// DMA_IN_LINK Register bits
    namespace dma_in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< The address of the first inlink descriptor.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< when the bit is set inlink descriptor returns to the next descriptor while a packet is wrong
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< Set the bit to stop to use inlink descriptor.
        constexpr uint32_t INLINK_START = (1U << 29);  ///< Set the bit to start to use inlink descriptor.
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< Set the bit to mount on new inlink descriptors.
    }

    /// DMA_STATUS Register bits
    namespace dma_status_bits {
        constexpr uint32_t DMA_RX_EN = (1U << 0);  ///< spi dma read data status bit.
        constexpr uint32_t DMA_TX_EN = (1U << 1);  ///< spi dma write data status bit.
    }

    /// DMA_INT_ENA Register bits
    namespace dma_int_ena_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_ENA = (1U << 0);  ///< The enable bit for lack of enough inlink descriptors.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ENA = (1U << 1);  ///< The enable bit for outlink descriptor error.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_ENA = (1U << 2);  ///< The enable bit for inlink descriptor error.
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 3);  ///< The enable bit for completing usage of a inlink descriptor.
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 4);  ///< The enable bit for receiving error.
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 5);  ///< The enable bit for completing receiving all the packets from host.
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 6);  ///< The enable bit for completing usage of a outlink descriptor .
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 7);  ///< The enable bit for sending a packet to host done.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 8);  ///< The enable bit for sending all the packets to host done.
    }

    /// DMA_INT_RAW Register bits
    namespace dma_int_raw_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_RAW = (1U << 0);  ///< The raw bit for lack of enough inlink descriptors.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_RAW = (1U << 1);  ///< The raw bit for outlink descriptor error.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_RAW = (1U << 2);  ///< The raw bit for inlink descriptor error.
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 3);  ///< The raw bit for completing usage of a inlink descriptor.
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 4);  ///< The raw bit for receiving error.
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 5);  ///< The raw bit for completing receiving all the packets from host.
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 6);  ///< The raw bit for completing usage of a outlink descriptor.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 7);  ///< The raw bit for sending a packet to host done.
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 8);  ///< The raw bit for sending all the packets to host done.
    }

    /// DMA_INT_ST Register bits
    namespace dma_int_st_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_ST = (1U << 0);  ///< The status bit for lack of enough inlink descriptors.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ST = (1U << 1);  ///< The status bit for outlink descriptor error.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_ST = (1U << 2);  ///< The status bit for inlink descriptor error.
        constexpr uint32_t IN_DONE_INT_ST = (1U << 3);  ///< The status bit for completing usage of a inlink descriptor.
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 4);  ///< The status bit for receiving error.
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 5);  ///< The status bit for completing receiving all the packets from host.
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 6);  ///< The status bit for completing usage of a outlink descriptor.
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 7);  ///< The status bit for sending a packet to host done.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 8);  ///< The status bit for sending all the packets to host done.
    }

    /// DMA_INT_CLR Register bits
    namespace dma_int_clr_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_CLR = (1U << 0);  ///< The clear bit for lack of enough inlink descriptors.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_CLR = (1U << 1);  ///< The clear bit for outlink descriptor error.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_CLR = (1U << 2);  ///< The clear bit for inlink descriptor error.
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 3);  ///< The clear bit for completing usage of a inlink descriptor.
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 4);  ///< The clear bit for receiving error.
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 5);  ///< The clear bit for completing receiving all the packets from host.
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 6);  ///< The clear bit for completing usage of a outlink descriptor.
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 7);  ///< The clear bit for sending a packet to host done.
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 8);  ///< The clear bit for sending all the packets to host done.
    }

    /// IN_ERR_EOF_DES_ADDR Register bits
    namespace in_err_eof_des_addr_bits {
        constexpr uint32_t DMA_IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< The inlink descriptor address when spi dma produce receiving error.
    }

    /// IN_SUC_EOF_DES_ADDR Register bits
    namespace in_suc_eof_des_addr_bits {
        constexpr uint32_t DMA_IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< The last inlink descriptor address when spi dma produce from_suc_eof.
    }

    /// INLINK_DSCR Register bits
    namespace inlink_dscr_bits {
        constexpr uint32_t DMA_INLINK_DSCR = (32 << 0);  ///< The content of current in descriptor pointer.
    }

    /// INLINK_DSCR_BF0 Register bits
    namespace inlink_dscr_bf0_bits {
        constexpr uint32_t DMA_INLINK_DSCR_BF0 = (32 << 0);  ///< The content of next in descriptor pointer.
    }

    /// INLINK_DSCR_BF1 Register bits
    namespace inlink_dscr_bf1_bits {
        constexpr uint32_t DMA_INLINK_DSCR_BF1 = (32 << 0);  ///< The content of current in descriptor data buffer pointer.
    }

    /// OUT_EOF_BFR_DES_ADDR Register bits
    namespace out_eof_bfr_des_addr_bits {
        constexpr uint32_t DMA_OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< The address of buffer relative to the outlink descriptor that produce eof.
    }

    /// OUT_EOF_DES_ADDR Register bits
    namespace out_eof_des_addr_bits {
        constexpr uint32_t DMA_OUT_EOF_DES_ADDR = (32 << 0);  ///< The last outlink descriptor address when spi dma produce to_eof.
    }

    /// OUTLINK_DSCR Register bits
    namespace outlink_dscr_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR = (32 << 0);  ///< The content of current out descriptor pointer.
    }

    /// OUTLINK_DSCR_BF0 Register bits
    namespace outlink_dscr_bf0_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR_BF0 = (32 << 0);  ///< The content of next out descriptor pointer.
    }

    /// OUTLINK_DSCR_BF1 Register bits
    namespace outlink_dscr_bf1_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR_BF1 = (32 << 0);  ///< The content of current out descriptor data buffer pointer.
    }

    /// DMA_RSTATUS Register bits
    namespace dma_rstatus_bits {
        constexpr uint32_t DMA_OUT_STATUS = (32 << 0);  ///< spi dma read data from memory status.
    }

    /// DMA_TSTATUS Register bits
    namespace dma_tstatus_bits {
        constexpr uint32_t DMA_IN_STATUS = (32 << 0);  ///< spi dma write data to memory status.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< SPI register version.
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x3FF6B000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t CMD;  ///< Offset: 0x04 - Command Register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - Interrupt Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bus Timing Register 0
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bus Timing Register 1
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - Arbitration Lost Capture Register
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - Error Code Capture Register
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - Error Warning Limit Register
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Receive Error Counter Register
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Transmit Error Counter Register
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12
        volatile uint32_t RX_MESSAGE_CNT;  ///< Offset: 0x74 - Receive Message Counter Register
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock Divider register
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< This bit is used to configure the operating mode of the TWAI Controller. 1: Reset mode; 0: Operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: Listen only mode. In this mode the nodes will only receive messages from the bus, without generating the acknowledge signal nor updating the RX error counter.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: Self test mode. In this mode the TX nodes can perform a successful transmission without receiving the acknowledge signal. This mode is often used to test a single node with the self reception request command.
        constexpr uint32_t RX_FILTER_MODE = (1U << 3);  ///< This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single filter mode.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQ = (1U << 0);  ///< Set the bit to 1 to allow the driving nodes start transmission.
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< Set the bit to 1 to cancel a pending transmission request.
        constexpr uint32_t RELEASE_BUF = (1U << 2);  ///< Set the bit to 1 to release the RX buffer.
        constexpr uint32_t CLR_OVERRUN = (1U << 3);  ///< Set the bit to 1 to clear the data overrun status bit.
        constexpr uint32_t SELF_RX_REQ = (1U << 4);  ///< Self reception request command. Set the bit to 1 to allow a message be transmitted and received simultaneously.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RX_BUF_ST = (1U << 0);  ///< 1: The data in the RX buffer is not empty, with at least one received data packet.
        constexpr uint32_t OVERRUN_ST = (1U << 1);  ///< 1: The RX FIFO is full and data overrun has occurred.
        constexpr uint32_t TX_BUF_ST = (1U << 2);  ///< 1: The TX buffer is empty, the CPU may write a message into it.
        constexpr uint32_t TX_COMPLETE = (1U << 3);  ///< 1: The TWAI controller has successfully received a packet from the bus.
        constexpr uint32_t RX_ST = (1U << 4);  ///< 1: The TWAI Controller is receiving a message from the bus.
        constexpr uint32_t TX_ST = (1U << 5);  ///< 1: The TWAI Controller is transmitting a message to the bus.
        constexpr uint32_t ERR_ST = (1U << 6);  ///< 1: At least one of the RX/TX error counter has reached or exceeded the value set in register TWAI_ERR_WARNING_LIMIT_REG.
        constexpr uint32_t BUS_OFF_ST = (1U << 7);  ///< 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
        constexpr uint32_t MISS_ST = (1U << 8);  ///< This bit reflects whether the data packet in the RX FIFO is complete. 1: The current packet is missing; 0: The current packet is complete
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_INT_ST = (1U << 0);  ///< Receive interrupt. If this bit is set to 1, it indicates there are messages to be handled in the RX FIFO.
        constexpr uint32_t TX_INT_ST = (1U << 1);  ///< Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis- sion is finished and a new transmission is able to execute.
        constexpr uint32_t ERR_WARN_INT_ST = (1U << 2);  ///< Error warning interrupt. If this bit is set to 1, it indicates the error status signal and the bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or from 1 to 0).
        constexpr uint32_t OVERRUN_INT_ST = (1U << 3);  ///< Data overrun interrupt. If this bit is set to 1, it indicates a data overrun interrupt is generated in the RX FIFO.
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< Error passive interrupt. If this bit is set to 1, it indicates the TWAI Controller is switched between error active status and error passive status due to the change of error counters.
        constexpr uint32_t ARB_LOST_INT_ST = (1U << 6);  ///< Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration lost interrupt is generated.
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< Error interrupt. If this bit is set to 1, it indicates an error is detected on the bus.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable receive interrupt.
        constexpr uint32_t TX_INT_ENA = (1U << 1);  ///< Set this bit to 1 to enable transmit interrupt.
        constexpr uint32_t ERR_WARN_INT_ENA = (1U << 2);  ///< Set this bit to 1 to enable error warning interrupt.
        constexpr uint32_t OVERRUN_INT_ENA = (1U << 3);  ///< Set this bit to 1 to enable data overrun interrupt.
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< Set this bit to 1 to enable error passive interrupt.
        constexpr uint32_t ARB_LOST_INT_ENA = (1U << 6);  ///< Set this bit to 1 to enable arbitration lost interrupt.
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< Set this bit to 1 to enable error interrupt.
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (6 << 0);  ///< Baud Rate Prescaler, determines the frequency dividing ratio.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 6);  ///< Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEG1 = (4 << 0);  ///< The width of PBS1.
        constexpr uint32_t TIME_SEG2 = (3 << 4);  ///< The width of PBS2.
        constexpr uint32_t TIME_SAMP = (1U << 7);  ///< The number of sample points. 0: the bus is sampled once; 1: the bus is sampled three times
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARB_LOST_CAP = (5 << 0);  ///< This register contains information about the bit position of lost arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ECC_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors, see Table 181 for details.
        constexpr uint32_t ECC_DIRECTION = (1U << 5);  ///< This register contains information about transmission direction of the node when error occurs. 1: Error occurs when receiving a message; 0: Error occurs when transmitting a message
        constexpr uint32_t ECC_TYPE = (2 << 6);  ///< This register contains information about error types: 00: bit error; 01: form error; 10: stuff error; 11: other type of error
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< Error warning threshold. In the case when any of a error counter value exceeds the threshold, or all the error counter values are below the threshold, an error warning interrupt will be triggered (given the enable signal is valid).
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register, reflects value changes under reception status.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register, reflects value changes under transmission status.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t TX_BYTE_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, it stores the 0th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t TX_BYTE_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, it stores the 1st byte information of the data to be transmitted under operating mode.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t TX_BYTE_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, it stores the 2nd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t TX_BYTE_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, it stores the 3rd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t TX_BYTE_4 = (8 << 0);  ///< In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, it stores the 4th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t TX_BYTE_5 = (8 << 0);  ///< In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, it stores the 5th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t TX_BYTE_6 = (8 << 0);  ///< In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, it stores the 6th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t TX_BYTE_7 = (8 << 0);  ///< In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, it stores the 7th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t TX_BYTE_8 = (8 << 0);  ///< Stored the 8th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t TX_BYTE_9 = (8 << 0);  ///< Stored the 9th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t TX_BYTE_10 = (8 << 0);  ///< Stored the 10th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t TX_BYTE_11 = (8 << 0);  ///< Stored the 11th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t TX_BYTE_12 = (8 << 0);  ///< Stored the 12th byte information of the data to be transmitted under operating mode.
    }

    /// RX_MESSAGE_CNT Register bits
    namespace rx_message_cnt_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< This register reflects the number of messages available within the RX FIFO.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to configure frequency dividing coefficients of the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< This bit can be configured under reset mode. 1: Disable the external CLKOUT pin; 0: Enable the external CLKOUT pin
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x3FF40000;
    constexpr uint32_t UART1_BASE = 0x3FF50000;
    constexpr uint32_t UART2_BASE = 0x3FF6E000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - This register stores one byte data read by rx fifo.
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - This interrupt raw bit turns to high level when receiver...
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - This is the status bit for rxfifo_full_int_raw when...
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - This is the enable bit for rxfifo_full_int_st register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Set this bit to clear the rxfifo_full_int_raw interrupt.
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - The register value is the integer part of the frequency...
        volatile uint32_t AUTOBAUD;  ///< Offset: 0x18 - This is the enable bit for detecting baudrate.
        volatile uint32_t STATUS;  ///< Offset: 0x1C - (rx_mem_cnt rxfifo_cnt) stores the byte num of valid...
        volatile uint32_t CONF0;  ///< Offset: 0x20 - This register is used to configure the parity check...
        volatile uint32_t CONF1;  ///< Offset: 0x24 - When receiver receives more data than its threshold...
        volatile uint32_t LOWPULSE;  ///< Offset: 0x28 - This register stores the value of the minimum duration...
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x2C - This register stores the value of the maxinum duration...
        volatile uint32_t RXD_CNT;  ///< Offset: 0x30 - This register stores the count of rxd edge change. it is...
        volatile uint32_t FLOW_CONF;  ///< Offset: 0x34 - Set this bit to enable software flow control. it is used...
        volatile uint32_t SLEEP_CONF;  ///< Offset: 0x38 - When the input rxd edge changes more than this register...
        volatile uint32_t SWFC_CONF;  ///< Offset: 0x3C - when the data amount in receiver's fifo is more than...
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x40 - when receiver takes more time than this register value...
        volatile uint32_t RS485_CONF;  ///< Offset: 0x44 - Set this bit to choose rs485 mode.
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x48 - This register is used to configure the idle duration...
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x4C - This register is used to configure the duration time...
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x50 - This register is used to configure the duration time...
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x54 - This register is used to configure the content of at_cmd char.
        volatile uint32_t MEM_CONF;  ///< Offset: 0x58 - Set this bit to power down mem.when reg_mem_pd registers...
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x5C - 
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x60 - This register stores the current uart rx mem read...
        volatile uint32_t MEM_CNT_STATUS;  ///< Offset: 0x64 - refer to the rxfifo_cnt's describtion.
        volatile uint32_t POSPULSE;  ///< Offset: 0x68 - This register stores the count of rxd posedge edge. it...
        volatile uint32_t NEGPULSE;  ///< Offset: 0x6C - This register stores the count of rxd negedge edge. it...
        volatile uint32_t DATE;  ///< Offset: 0x78 - 
        volatile uint32_t ID;  ///< Offset: 0x7C - 
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< This register stores one byte data read by rx fifo.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than (rx_flow_thrhd_h3 rx_flow_thrhd).
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in transmitter's fifo is less than ((tx_mem_cnttxfifo_cnt) .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects the parity error of data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects data's frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the fifo can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of dsrn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of ctsn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects the 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver receives xoff char with uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives xon char with uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects the start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sendding 0 after all the datas in transmitter's fifo are send.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after the last data has been send.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send all the data in fifo.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when rs485 detects the parity error.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when rs485 detects the data frame error.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when rs485 detects the clash between transmitter and receiver.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd chars.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when fm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for rs485_fm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for rs485_clash_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear the rs485_parity_err_int_raw interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear the rs485_frm_err_int_raw interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear the rs485_clash_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (20 << 0);  ///< The register value is the integer part of the frequency divider's factor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The register value is the decimal part of the frequency divider's factor.
    }

    /// AUTOBAUD Register bits
    namespace autobaud_bits {
        constexpr uint32_t EN = (1U << 0);  ///< This is the enable bit for detecting baudrate.
        constexpr uint32_t GLITCH_FILT = (8 << 8);  ///< when input pulse width is lower then this value igore this pulse.this register is used in autobaud detect process.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (8 << 0);  ///< (rx_mem_cnt rxfifo_cnt) stores the byte num of valid datas in receiver's fifo. rx_mem_cnt register stores the 3 most significant bits rxfifo_cnt stores the 8 least significant bits.
        constexpr uint32_t ST_URX_OUT = (4 << 8);  ///< This register stores the value of receiver's finite state machine. 0:RX_IDLE 1:RX_STRT 2:RX_DAT0 3:RX_DAT1 4:RX_DAT2 5:RX_DAT3 6:RX_DAT4 7:RX_DAT5 8:RX_DAT6 9:RX_DAT7 10:RX_PRTY 11:RX_STP1 12:RX_STP2 13:RX_DL1
        constexpr uint32_t DSRN = (1U << 13);  ///< This register stores the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register stores the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register stores the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (8 << 16);  ///< (tx_mem_cnt txfifo_cnt) stores the byte num of valid datas in transmitter's fifo.tx_mem_cnt stores the 3 most significant bits txfifo_cnt stores the 8 least significant bits.
        constexpr uint32_t ST_UTX_OUT = (4 << 24);  ///< This register stores the value of transmitter's finite state machine. 0:TX_IDLE 1:TX_STRT 2:TX_DAT0 3:TX_DAT1 4:TX_DAT2 5:TX_DAT3 6:TX_DAT4 7:TX_DAT5 8:TX_DAT6 9:TX_DAT7 10:TX_PRTY 11:TX_STP1 12:TX_STP2 13:TX_DL0 14:TX_DL1
        constexpr uint32_t DTRN = (1U << 29);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This register represent the level value of the internal uart rxd signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode. 0:even 1:odd
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This registe is used to set the length of data: 0:5bits 1:6bits 2:7bits 3:8bits
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit. 1:1bit 2:1.5bits 3:2bits
        constexpr uint32_t SW_RTS = (1U << 6);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t SW_DTR = (1U << 7);  ///< This register is used to configure the software dtr signal which is used in software flow control..
        constexpr uint32_t TXD_BRK = (1U << 8);  ///< Set this bit to enbale transmitter to send 0 when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 9);  ///< Set this bit to enable irda loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 10);  ///< This is the start enable bit for irda transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 11);  ///< 1.the irda transmitter's 11th bit is the same to the 10th bit. 0.set irda transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 12);  ///< Set this bit to inverse the level value of irda transmitter's level.
        constexpr uint32_t IRDA_RX_INV = (1U << 13);  ///< Set this bit to inverse the level value of irda receiver's level.
        constexpr uint32_t LOOPBACK = (1U << 14);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 15);  ///< Set this bit to enable transmitter's flow control function.
        constexpr uint32_t IRDA_EN = (1U << 16);  ///< Set this bit to enable irda protocol.
        constexpr uint32_t RXFIFO_RST = (1U << 17);  ///< Set this bit to reset uart receiver's fifo.
        constexpr uint32_t TXFIFO_RST = (1U << 18);  ///< Set this bit to reset uart transmitter's fifo.
        constexpr uint32_t RXD_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t CTS_INV = (1U << 20);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 21);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t TXD_INV = (1U << 22);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t RTS_INV = (1U << 23);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 24);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t CLK_EN = (1U << 25);  ///< 1.force clock on for registers.support clock only when write registers
        constexpr uint32_t ERR_WR_MASK = (1U << 26);  ///< 1.receiver stops storing data int fifo when data is wrong. 0.receiver stores the data even if the received data is wrong.
        constexpr uint32_t TICK_REF_ALWAYS_ON = (1U << 27);  ///< This register is used to select the clock.1.apb clock 0:ref_tick
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (7 << 0);  ///< When receiver receives more data than its threshold value.receiver will produce rxfifo_full_int_raw interrupt.the threshold value is (rx_flow_thrhd_h3 rxfifo_full_thrhd).
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (7 << 8);  ///< when the data amount in transmitter fifo is less than its threshold value. it will produce txfifo_empty_int_raw interrupt. the threshold value is (tx_mem_empty_thrhd txfifo_empty_thrhd)
        constexpr uint32_t RX_FLOW_THRHD = (7 << 16);  ///< when receiver receives more data than its threshold value. receiver produce signal to tell the transmitter stop transferring data. the threshold value is (rx_flow_thrhd_h3 rx_flow_thrhd).
        constexpr uint32_t RX_FLOW_EN = (1U << 23);  ///< This is the flow enable bit for uart receiver. 1:choose software flow control with configuring sw_rts signal
        constexpr uint32_t RX_TOUT_THRHD = (7 << 24);  ///< This register is used to configure the timeout value for uart receiver receiving a byte.
        constexpr uint32_t RX_TOUT_EN = (1U << 31);  ///< This is the enble bit for uart receiver's timeout function.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (20 << 0);  ///< This register stores the value of the minimum duration time for the low level pulse. it is used in baudrate-detect process.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (20 << 0);  ///< This register stores the value of the maxinum duration time for the high level pulse. it is used in baudrate-detect process.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of rxd edge change. it is used in baudrate-detect process.
    }

    /// FLOW_CONF Register bits
    namespace flow_conf_bits {
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 0);  ///< Set this bit to enable software flow control. it is used with register sw_xon or sw_xoff .
        constexpr uint32_t XONOFF_DEL = (1U << 1);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 2);  ///< Set this bit to clear ctsn to stop the transmitter from sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 3);  ///< Set this bit to set ctsn to enable the transmitter to go on sending data.
        constexpr uint32_t SEND_XON = (1U << 4);  ///< Set this bit to send xon char. it is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 5);  ///< Set this bit to send xoff char. it is cleared by hardware automatically.
    }

    /// SLEEP_CONF Register bits
    namespace sleep_conf_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< When the input rxd edge changes more than this register value. the uart is active from light sleeping mode.
    }

    /// SWFC_CONF Register bits
    namespace swfc_conf_bits {
        constexpr uint32_t XON_THRESHOLD = (8 << 0);  ///< when the data amount in receiver's fifo is more than this register value. it will send a xoff char with uart_sw_flow_con_en set to 1.
        constexpr uint32_t XOFF_THRESHOLD = (8 << 8);  ///< When the data amount in receiver's fifo is less than this register value. it will send a xon char with uart_sw_flow_con_en set to 1.
        constexpr uint32_t XON_CHAR = (8 << 16);  ///< This register stores the xon flow control char.
        constexpr uint32_t XOFF_CHAR = (8 << 24);  ///< This register stores the xoff flow control char.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< when receiver takes more time than this register value to receive a byte data. it will produce frame end signal for uhci to stop receiving data.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
        constexpr uint32_t TX_BRK_NUM = (8 << 20);  ///< This register is used to configure the num of 0 send after the process of sending data is done. it is active when txd_brk is set to 1.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose rs485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable loopback transmitter's output data signal to receiver's input data signal.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1: enable rs485's transmitter to send data when rs485's receiver is busy. 0:rs485's transmitter should not send data when its receiver is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (24 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver. when the the duration is less than this register value it will not take the next data received as at_cmd char.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (24 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data. when the duration is less than this register value it will not take the previous data as at_cmd char.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (24 << 0);  ///< This register is used to configure the duration time between the at_cmd chars. when the duration time is less than this register value it will not take the datas as continous at_cmd chars.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t MEM_PD = (1U << 0);  ///< Set this bit to power down mem.when reg_mem_pd registers in the 3 uarts are all set to 1 mem will enter low power mode.
        constexpr uint32_t RX_SIZE = (4 << 3);  ///< This register is used to configure the amount of mem allocated to receiver's fifo. the default byte num is 128.
        constexpr uint32_t TX_SIZE = (4 << 7);  ///< This register is used to configure the amount of mem allocated to transmitter's fifo.the default byte num is 128.
        constexpr uint32_t RX_FLOW_THRHD_H3 = (3 << 15);  ///< refer to the rx_flow_thrhd's describtion.
        constexpr uint32_t RX_TOUT_THRHD_H3 = (3 << 18);  ///< refer to the rx_tout_thrhd's describtion.
        constexpr uint32_t XON_THRESHOLD_H2 = (2 << 21);  ///< refer to the uart_xon_threshold's describtion.
        constexpr uint32_t XOFF_THRESHOLD_H2 = (2 << 23);  ///< refer to the uart_xoff_threshold's describtion.
        constexpr uint32_t RX_MEM_FULL_THRHD = (3 << 25);  ///< refer to the rxfifo_full_thrhd's describtion.
        constexpr uint32_t TX_MEM_EMPTY_THRHD = (3 << 28);  ///< refer to txfifo_empty_thrhd 's describtion.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t MEM_TX_STATUS = (24 << 0);  ///< MEM_TX_STATUS
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t MEM_RX_STATUS = (24 << 0);  ///< This register stores the current uart rx mem read address and rx mem write address
        constexpr uint32_t MEM_RX_RD_ADDR = (11 << 2);  ///< This register stores the rx mem read address
        constexpr uint32_t MEM_RX_WR_ADDR = (11 << 13);  ///< This register stores the rx mem write address
    }

    /// MEM_CNT_STATUS Register bits
    namespace mem_cnt_status_bits {
        constexpr uint32_t RX_MEM_CNT = (3 << 0);  ///< refer to the rxfifo_cnt's describtion.
        constexpr uint32_t TX_MEM_CNT = (3 << 3);  ///< refer to the txfifo_cnt's describtion.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (20 << 0);  ///< This register stores the count of rxd posedge edge. it is used in boudrate-detect process.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (20 << 0);  ///< This register stores the count of rxd negedge edge. it is used in boudrate-detect process.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< ID
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x3FF54000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - Set this bit to reset in link operations.
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - when a separator char has been send it will produce...
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - 
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - 
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - 
        volatile uint32_t DMA_OUT_STATUS;  ///< Offset: 0x14 - 1:DMA out link descriptor's fifo is full.
        volatile uint32_t DMA_OUT_PUSH;  ///< Offset: 0x18 - This is the data need to be pushed into out link...
        volatile uint32_t DMA_IN_STATUS;  ///< Offset: 0x1C - This register stores the errors caused in out link...
        volatile uint32_t DMA_IN_POP;  ///< Offset: 0x20 - This register stores the data pop from in link descriptor's fifo.
        volatile uint32_t DMA_OUT_LINK;  ///< Offset: 0x24 - This register stores the least 20 bits of the first out...
        volatile uint32_t DMA_IN_LINK;  ///< Offset: 0x28 - This register stores the least 20 bits of the first in...
        volatile uint32_t CONF1;  ///< Offset: 0x2C - Set this bit to enable decoder to check check_sum in...
        volatile uint32_t STATE0;  ///< Offset: 0x30 - 
        volatile uint32_t STATE1;  ///< Offset: 0x34 - 
        volatile uint32_t DMA_OUT_EOF_DES_ADDR;  ///< Offset: 0x38 - This register stores the address of out link descriptoir...
        volatile uint32_t DMA_IN_SUC_EOF_DES_ADDR;  ///< Offset: 0x3C - This register stores the address of in link descriptor...
        volatile uint32_t DMA_IN_ERR_EOF_DES_ADDR;  ///< Offset: 0x40 - This register stores the address of in link descriptor...
        volatile uint32_t DMA_OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x44 - This register stores the address of out link descriptor...
        volatile uint32_t AHB_TEST;  ///< Offset: 0x48 - bit2 is ahb bus test enable ,bit1 is used to choose...
        volatile uint32_t DMA_IN_DSCR;  ///< Offset: 0x4C - The content of current in link descriptor's third dword
        volatile uint32_t DMA_IN_DSCR_BF0;  ///< Offset: 0x50 - The content of current in link descriptor's first dword
        volatile uint32_t DMA_IN_DSCR_BF1;  ///< Offset: 0x54 - The content of current in link descriptor's second dword
        volatile uint32_t DMA_OUT_DSCR;  ///< Offset: 0x58 - The content of current out link descriptor's third dword
        volatile uint32_t DMA_OUT_DSCR_BF0;  ///< Offset: 0x5C - The content of current out link descriptor's first dword
        volatile uint32_t DMA_OUT_DSCR_BF1;  ///< Offset: 0x60 - The content of current out link descriptor's second dword
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x64 - Set this bit to enable 0xc0 char decode when DMA receives data.
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x68 - This register stores the timeout value.when DMA takes...
        volatile uint32_t ACK_NUM;  ///< Offset: 0x6C - 
        volatile uint32_t RX_HEAD;  ///< Offset: 0x70 - This register stores the packet header received by DMA
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x74 - The bits are used to choose which short packet
        volatile uint32_t Q0_WORD0;  ///< Offset: 0x78 - This register stores the content of short packet's first dword
        volatile uint32_t Q0_WORD1;  ///< Offset: 0x7C - This register stores the content of short packet's second dword
        volatile uint32_t Q1_WORD0;  ///< Offset: 0x80 - This register stores the content of short packet's first dword
        volatile uint32_t Q1_WORD1;  ///< Offset: 0x84 - This register stores the content of short packet's second dword
        volatile uint32_t Q2_WORD0;  ///< Offset: 0x88 - This register stores the content of short packet's first dword
        volatile uint32_t Q2_WORD1;  ///< Offset: 0x8C - This register stores the content of short packet's second dword
        volatile uint32_t Q3_WORD0;  ///< Offset: 0x90 - This register stores the content of short packet's first dword
        volatile uint32_t Q3_WORD1;  ///< Offset: 0x94 - This register stores the content of short packet's second dword
        volatile uint32_t Q4_WORD0;  ///< Offset: 0x98 - This register stores the content of short packet's first dword
        volatile uint32_t Q4_WORD1;  ///< Offset: 0x9C - This register stores the content of short packet's second dword
        volatile uint32_t Q5_WORD0;  ///< Offset: 0xA0 - This register stores the content of short packet's first dword
        volatile uint32_t Q5_WORD1;  ///< Offset: 0xA4 - This register stores the content of short packet's second dword
        volatile uint32_t Q6_WORD0;  ///< Offset: 0xA8 - This register stores the content of short packet's first dword
        volatile uint32_t Q6_WORD1;  ///< Offset: 0xAC - This register stores the content of short packet's second dword
        volatile uint32_t ESC_CONF0;  ///< Offset: 0xB0 - This register stores the seperator char seperator char...
        volatile uint32_t ESC_CONF1;  ///< Offset: 0xB4 - This register stores the first substitute char used to...
        volatile uint32_t ESC_CONF2;  ///< Offset: 0xB8 - This register stores the flow control char to turn on...
        volatile uint32_t ESC_CONF3;  ///< Offset: 0xBC - This register stores the flow_control char to turn off...
        volatile uint32_t PKT_THRES;  ///< Offset: 0xC0 - when the amount of packet payload is greater than this...
        volatile uint32_t DATE;  ///< Offset: 0xFC - version information
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< Set this bit to reset in link operations.
        constexpr uint32_t OUT_RST = (1U << 1);  ///< Set this bit to reset out link operations.
        constexpr uint32_t AHBM_FIFO_RST = (1U << 2);  ///< Set this bit to reset dma ahb fifo.
        constexpr uint32_t AHBM_RST = (1U << 3);  ///< Set this bit to reset dma ahb interface.
        constexpr uint32_t IN_LOOP_TEST = (1U << 4);  ///< Set this bit to enable loop test for in links.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 5);  ///< Set this bit to enable loop test for out links.
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 6);  ///< when in link's length is 0 go on to use the next in link automatically.
        constexpr uint32_t OUT_NO_RESTART_CLR = (1U << 7);  ///< don't use
        constexpr uint32_t OUT_EOF_MODE = (1U << 8);  ///< Set this bit to produce eof after DMA pops all data clear this bit to produce eof after DMA pushes all data
        constexpr uint32_t UART0_CE = (1U << 9);  ///< Set this bit to use UART to transmit or receive data.
        constexpr uint32_t UART1_CE = (1U << 10);  ///< Set this bit to use UART1 to transmit or receive data.
        constexpr uint32_t UART2_CE = (1U << 11);  ///< Set this bit to use UART2 to transmit or receive data.
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 12);  ///< Set this bit to enable DMA in links to use burst mode.
        constexpr uint32_t INDSCR_BURST_EN = (1U << 13);  ///< Set this bit to enable DMA out links to use burst mode.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 14);  ///< Set this bit to enable DMA burst MODE
        constexpr uint32_t MEM_TRANS_EN = (1U << 15);  ///< MEM_TRANS_EN
        constexpr uint32_t SEPER_EN = (1U << 16);  ///< Set this bit to use special char to separate the data frame.
        constexpr uint32_t HEAD_EN = (1U << 17);  ///< Set this bit to enable to use head packet before the data frame.
        constexpr uint32_t CRC_REC_EN = (1U << 18);  ///< Set this bit to enable receiver''s ability of crc calculation when crc_en bit in head packet is 1 then there will be crc bytes after data_frame
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 19);  ///< Set this bit to enable to use idle time when the idle time after data frame is satisfied this means the end of a data frame.
        constexpr uint32_t LEN_EOF_EN = (1U << 20);  ///< Set this bit to enable to use packet_len in packet head when the received data is equal to packet_len this means the end of a data frame.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 21);  ///< Set this bit to enable crc calculation for data frame when bit6 in the head packet is 1.
        constexpr uint32_t CLK_EN = (1U << 22);  ///< Set this bit to enable clock-gating for read or write registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 23);  ///< Set this bit to enable to use brk char as the end of a data frame.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< when a separator char has been send it will produce uhci_rx_start_int interrupt.
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< when DMA detects a separator char it will produce uhci_tx_start_int interrupt.
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< when DMA takes a lot of time to receive a data it will produce uhci_rx_hung_int interrupt.
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< when DMA takes a lot of time to read a data from RAM it will produce uhci_tx_hung_int interrupt.
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 4);  ///< when a in link descriptor has been completed it will produce uhci_in_done_int interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 5);  ///< when a data packet has been received it will produce uhci_in_suc_eof_int interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 6);  ///< when there are some errors about eof in in link descriptor it will produce uhci_in_err_eof_int interrupt.
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 7);  ///< when a out link descriptor is completed it will produce uhci_out_done_int interrupt.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 8);  ///< when the current descriptor's eof bit is 1 it will produce uhci_out_eof_int interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_RAW = (1U << 9);  ///< when there are some errors about the out link descriptor it will produce uhci_in_dscr_err_int interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_RAW = (1U << 10);  ///< when there are some errors about the in link descriptor it will produce uhci_out_dscr_err_int interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_RAW = (1U << 11);  ///< when there are not enough in links for DMA it will produce uhci_in_dscr_err_int interrupt.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_RAW = (1U << 12);  ///< when there are some errors about eof in outlink descriptor it will produce uhci_outlink_eof_err_int interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 13);  ///< When all data have been send it will produce uhci_out_total_eof_int interrupt.
        constexpr uint32_t SEND_S_Q_INT_RAW = (1U << 14);  ///< When use single send registers to send a short packets it will produce this interrupt when dma has send the short packet.
        constexpr uint32_t SEND_A_Q_INT_RAW = (1U << 15);  ///< When use always_send registers to send a series of short packets it will produce this interrupt when dma has send the short packet.
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_RAW = (1U << 16);  ///< DMA_INFIFO_FULL_WM_INT_RAW
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< RX_START_INT_ST
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< TX_START_INT_ST
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< RX_HUNG_INT_ST
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< TX_HUNG_INT_ST
        constexpr uint32_t IN_DONE_INT_ST = (1U << 4);  ///< IN_DONE_INT_ST
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 5);  ///< IN_SUC_EOF_INT_ST
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 6);  ///< IN_ERR_EOF_INT_ST
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 7);  ///< OUT_DONE_INT_ST
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 8);  ///< OUT_EOF_INT_ST
        constexpr uint32_t IN_DSCR_ERR_INT_ST = (1U << 9);  ///< IN_DSCR_ERR_INT_ST
        constexpr uint32_t OUT_DSCR_ERR_INT_ST = (1U << 10);  ///< OUT_DSCR_ERR_INT_ST
        constexpr uint32_t IN_DSCR_EMPTY_INT_ST = (1U << 11);  ///< IN_DSCR_EMPTY_INT_ST
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 12);  ///< OUTLINK_EOF_ERR_INT_ST
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 13);  ///< OUT_TOTAL_EOF_INT_ST
        constexpr uint32_t SEND_S_Q_INT_ST = (1U << 14);  ///< SEND_S_Q_INT_ST
        constexpr uint32_t SEND_A_Q_INT_ST = (1U << 15);  ///< SEND_A_Q_INT_ST
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ST = (1U << 16);  ///< DMA_INFIFO_FULL_WM_INT_ST
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< RX_START_INT_ENA
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< TX_START_INT_ENA
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< RX_HUNG_INT_ENA
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< TX_HUNG_INT_ENA
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 4);  ///< IN_DONE_INT_ENA
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 5);  ///< IN_SUC_EOF_INT_ENA
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 6);  ///< IN_ERR_EOF_INT_ENA
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 7);  ///< OUT_DONE_INT_ENA
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 8);  ///< OUT_EOF_INT_ENA
        constexpr uint32_t IN_DSCR_ERR_INT_ENA = (1U << 9);  ///< IN_DSCR_ERR_INT_ENA
        constexpr uint32_t OUT_DSCR_ERR_INT_ENA = (1U << 10);  ///< OUT_DSCR_ERR_INT_ENA
        constexpr uint32_t IN_DSCR_EMPTY_INT_ENA = (1U << 11);  ///< IN_DSCR_EMPTY_INT_ENA
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 12);  ///< OUTLINK_EOF_ERR_INT_ENA
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 13);  ///< OUT_TOTAL_EOF_INT_ENA
        constexpr uint32_t SEND_S_Q_INT_ENA = (1U << 14);  ///< SEND_S_Q_INT_ENA
        constexpr uint32_t SEND_A_Q_INT_ENA = (1U << 15);  ///< SEND_A_Q_INT_ENA
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ENA = (1U << 16);  ///< DMA_INFIFO_FULL_WM_INT_ENA
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< RX_START_INT_CLR
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< TX_START_INT_CLR
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< RX_HUNG_INT_CLR
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< TX_HUNG_INT_CLR
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 4);  ///< IN_DONE_INT_CLR
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 5);  ///< IN_SUC_EOF_INT_CLR
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 6);  ///< IN_ERR_EOF_INT_CLR
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 7);  ///< OUT_DONE_INT_CLR
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 8);  ///< OUT_EOF_INT_CLR
        constexpr uint32_t IN_DSCR_ERR_INT_CLR = (1U << 9);  ///< IN_DSCR_ERR_INT_CLR
        constexpr uint32_t OUT_DSCR_ERR_INT_CLR = (1U << 10);  ///< OUT_DSCR_ERR_INT_CLR
        constexpr uint32_t IN_DSCR_EMPTY_INT_CLR = (1U << 11);  ///< IN_DSCR_EMPTY_INT_CLR
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 12);  ///< OUTLINK_EOF_ERR_INT_CLR
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 13);  ///< OUT_TOTAL_EOF_INT_CLR
        constexpr uint32_t SEND_S_Q_INT_CLR = (1U << 14);  ///< SEND_S_Q_INT_CLR
        constexpr uint32_t SEND_A_Q_INT_CLR = (1U << 15);  ///< SEND_A_Q_INT_CLR
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_CLR = (1U << 16);  ///< DMA_INFIFO_FULL_WM_INT_CLR
    }

    /// DMA_OUT_STATUS Register bits
    namespace dma_out_status_bits {
        constexpr uint32_t OUT_FULL = (1U << 0);  ///< 1:DMA out link descriptor's fifo is full.
        constexpr uint32_t OUT_EMPTY = (1U << 1);  ///< 1:DMA in link descriptor's fifo is empty.
    }

    /// DMA_OUT_PUSH Register bits
    namespace dma_out_push_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This is the data need to be pushed into out link descriptor's fifo.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 16);  ///< Set this bit to push data in out link descriptor's fifo.
    }

    /// DMA_IN_STATUS Register bits
    namespace dma_in_status_bits {
        constexpr uint32_t IN_FULL = (1U << 0);  ///< IN_FULL
        constexpr uint32_t IN_EMPTY = (1U << 1);  ///< IN_EMPTY
        constexpr uint32_t RX_ERR_CAUSE = (3 << 4);  ///< This register stores the errors caused in out link descriptor's data packet.
    }

    /// DMA_IN_POP Register bits
    namespace dma_in_pop_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data pop from in link descriptor's fifo.
        constexpr uint32_t INFIFO_POP = (1U << 16);  ///< Set this bit to pop data in in link descriptor's fifo.
    }

    /// DMA_OUT_LINK Register bits
    namespace dma_out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the least 20 bits of the first out link descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< Set this bit to stop dealing with the out link descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< Set this bit to start dealing with the out link descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< Set this bit to mount on new out link descriptors
        constexpr uint32_t OUTLINK_PARK = (1U << 31);  ///< 1£º the out link descriptor's fsm is in idle state. 0:the out link descriptor's fsm is working.
    }

    /// DMA_IN_LINK Register bits
    namespace dma_in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the least 20 bits of the first in link descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< 1:when a packet is wrong in link descriptor returns to the descriptor which is lately used.
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< Set this bit to stop dealing with the in link descriptors.
        constexpr uint32_t INLINK_START = (1U << 29);  ///< Set this bit to start dealing with the in link descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< Set this bit to mount on new in link descriptors
        constexpr uint32_t INLINK_PARK = (1U << 31);  ///< 1:the in link descriptor's fsm is in idle state. 0:the in link descriptor's fsm is working
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< Set this bit to enable decoder to check check_sum in packet header.
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< Set this bit to enable decoder to check seq num in packet header.
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< Set this bit to disable crc calculation.
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< Set this bit to save packet header .
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< Set this bit to enable hardware replace check_sum in packet header automatically.
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< Set this bit to enable hardware replace ack num in packet header automatically.
        constexpr uint32_t CHECK_OWNER = (1U << 6);  ///< Set this bit to check the owner bit in link descriptor.
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< Set this bit to enable software way to add packet header.
        constexpr uint32_t SW_START = (1U << 8);  ///< Set this bit to start inserting the packet header.
        constexpr uint32_t DMA_INFIFO_FULL_THRS = (12 << 9);  ///< when data amount in link descriptor's fifo is more than this register value it will produce uhci_dma_infifo_full_wm_int interrupt.
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t STATE0 = (32 << 0);  ///< STATE0
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t STATE1 = (32 << 0);  ///< STATE1
    }

    /// DMA_OUT_EOF_DES_ADDR Register bits
    namespace dma_out_eof_des_addr_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of out link descriptoir when eof bit in this descriptor is 1.
    }

    /// DMA_IN_SUC_EOF_DES_ADDR Register bits
    namespace dma_in_suc_eof_des_addr_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of in link descriptor when eof bit in this descriptor is 1.
    }

    /// DMA_IN_ERR_EOF_DES_ADDR Register bits
    namespace dma_in_err_eof_des_addr_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of in link descriptor when there are some errors in this descriptor.
    }

    /// DMA_OUT_EOF_BFR_DES_ADDR Register bits
    namespace dma_out_eof_bfr_des_addr_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of out link descriptor when there are some errors in this descriptor.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< bit2 is ahb bus test enable ,bit1 is used to choose wrtie(1) or read(0) mode. bit0 is used to choose test only once(1) or continue(0)
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< The two bits represent ahb bus address bit[20:19]
    }

    /// DMA_IN_DSCR Register bits
    namespace dma_in_dscr_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The content of current in link descriptor's third dword
    }

    /// DMA_IN_DSCR_BF0 Register bits
    namespace dma_in_dscr_bf0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The content of current in link descriptor's first dword
    }

    /// DMA_IN_DSCR_BF1 Register bits
    namespace dma_in_dscr_bf1_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The content of current in link descriptor's second dword
    }

    /// DMA_OUT_DSCR Register bits
    namespace dma_out_dscr_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The content of current out link descriptor's third dword
    }

    /// DMA_OUT_DSCR_BF0 Register bits
    namespace dma_out_dscr_bf0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The content of current out link descriptor's first dword
    }

    /// DMA_OUT_DSCR_BF1 Register bits
    namespace dma_out_dscr_bf1_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The content of current out link descriptor's second dword
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< Set this bit to enable 0xc0 char decode when DMA receives data.
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< Set this bit to enable 0xdb char decode when DMA receives data.
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< Set this bit to enable flow control char 0x11 decode when DMA receives data.
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< Set this bit to enable flow control char 0x13 decode when DMA receives data.
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< Set this bit to enable 0xc0 char replace when DMA sends data.
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< Set this bit to enable 0xdb char replace when DMA sends data.
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< Set this bit to enable flow control char 0x11 replace when DMA sends data.
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< Set this bit to enable flow control char 0x13 replace when DMA sends data.
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< This register stores the timeout value.when DMA takes more time than this register value to receive a data it will produce uhci_tx_hung_int interrupt.
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The tick count is cleared when its value >=(17'd8000>>reg_txfifo_timeout_shift)
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for txfifo receive data timeout
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< This register stores the timeout value.when DMA takes more time than this register value to read a data from RAM it will produce uhci_rx_hung_int interrupt.
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< The tick count is cleared when its value >=(17'd8000>>reg_rxfifo_timeout_shift)
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< This is the enable bit for DMA send data timeout
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< This register stores the packet header received by DMA
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< The bits are used to choose which short packet
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< Set this bit to enable send a short packet
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< The bits are used to choose which short packet
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< Set this bit to enable continuously send the same short packet
    }

    /// Q0_WORD0 Register bits
    namespace q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q0_WORD1 Register bits
    namespace q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q1_WORD0 Register bits
    namespace q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q1_WORD1 Register bits
    namespace q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q2_WORD0 Register bits
    namespace q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q2_WORD1 Register bits
    namespace q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q3_WORD0 Register bits
    namespace q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q3_WORD1 Register bits
    namespace q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q4_WORD0 Register bits
    namespace q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q4_WORD1 Register bits
    namespace q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q5_WORD0 Register bits
    namespace q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q5_WORD1 Register bits
    namespace q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// Q6_WORD0 Register bits
    namespace q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< This register stores the content of short packet's first dword
    }

    /// Q6_WORD1 Register bits
    namespace q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< This register stores the content of short packet's second dword
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< This register stores the seperator char seperator char is used to seperate the data frame.
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< This register stores thee first char used to replace seperator char in data.
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< This register stores the second char used to replace seperator char in data . 0xdc 0xdb replace 0xc0 by default.
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< This register stores the first substitute char used to replace the seperator char.
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< This register stores the first char used to replace reg_esc_seq0 in data.
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< This register stores the second char used to replace the reg_esc_seq0 in data
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< This register stores the flow control char to turn on the flow_control
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< This register stores the first char used to replace the reg_esc_seq1 in data.
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< This register stores the second char used to replace the reg_esc_seq1 in data.
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< This register stores the flow_control char to turn off the flow_control
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< This register stores the first char used to replace the reg_esc_seq2 in data.
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< This register stores the second char used to replace the reg_esc_seq2 in data.
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< when the amount of packet payload is greater than this value the process of receiving data is done.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< version information
    }

}

// ============================================================================
// UHCI1 Peripheral
// ============================================================================

namespace uhci1 {
    /// Base addresses
    constexpr uint32_t UHCI1_BASE = 0x3FF4C000;

    /// UHCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* UHCI1 = reinterpret_cast<Registers*>(UHCI1_BASE);

}


} // namespace alloy::generated::esp32

#endif // ALLOY_GENERATED_ESP32_PERIPHERALS_HPP