/// Auto-generated code for ESP32-C2
/// Generated by Alloy Code Generator
/// Source: espressif_esp32c2.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:12
#ifndef ALLOY_GENERATED_ESP32-C2_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-C2_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::esp32-c2 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_apb = true;
    constexpr uint32_t num_apb_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_assist = true;
    constexpr uint32_t num_assist_instances = 1;
    constexpr bool has_bb = true;
    constexpr uint32_t num_bb_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_ecc = true;
    constexpr uint32_t num_ecc_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_extmem = true;
    constexpr uint32_t num_extmem_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 1;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_modem = true;
    constexpr uint32_t num_modem_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sensitive = true;
    constexpr uint32_t num_sensitive_instances = 1;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct apb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct assist_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct extmem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct modem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sensitive_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 1;
    constexpr uint32_t max_gpio_pins = 16;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// APB Peripheral
// ============================================================================

namespace apb {
    /// Base addresses
    constexpr uint32_t APB_CTRL_BASE = 0x60026000;

    /// APB Register structure
    struct Registers {
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x00 - APB_CTRL_SYSCLK_CONF_REG
        volatile uint32_t TICK_CONF;  ///< Offset: 0x04 - APB_CTRL_TICK_CONF_REG
        volatile uint32_t CLK_OUT_EN;  ///< Offset: 0x08 - APB_CTRL_CLK_OUT_EN_REG
        volatile uint32_t WIFI_BB_CFG;  ///< Offset: 0x0C - APB_CTRL_WIFI_BB_CFG_REG
        volatile uint32_t WIFI_BB_CFG_2;  ///< Offset: 0x10 - APB_CTRL_WIFI_BB_CFG_2_REG
        volatile uint32_t WIFI_CLK_EN;  ///< Offset: 0x14 - APB_CTRL_WIFI_CLK_EN_REG
        volatile uint32_t WIFI_RST_EN;  ///< Offset: 0x18 - APB_CTRL_WIFI_RST_EN_REG
        volatile uint32_t HOST_INF_SEL;  ///< Offset: 0x1C - APB_CTRL_HOST_INF_SEL_REG
        volatile uint32_t EXT_MEM_PMS_LOCK;  ///< Offset: 0x20 - APB_CTRL_EXT_MEM_PMS_LOCK_REG
        volatile uint32_t FLASH_ACE0_ATTR;  ///< Offset: 0x28 - APB_CTRL_FLASH_ACE0_ATTR_REG
        volatile uint32_t FLASH_ACE1_ATTR;  ///< Offset: 0x2C - APB_CTRL_FLASH_ACE1_ATTR_REG
        volatile uint32_t FLASH_ACE2_ATTR;  ///< Offset: 0x30 - APB_CTRL_FLASH_ACE2_ATTR_REG
        volatile uint32_t FLASH_ACE3_ATTR;  ///< Offset: 0x34 - APB_CTRL_FLASH_ACE3_ATTR_REG
        volatile uint32_t FLASH_ACE0_ADDR;  ///< Offset: 0x38 - APB_CTRL_FLASH_ACE0_ADDR_REG
        volatile uint32_t FLASH_ACE1_ADDR;  ///< Offset: 0x3C - APB_CTRL_FLASH_ACE1_ADDR_REG
        volatile uint32_t FLASH_ACE2_ADDR;  ///< Offset: 0x40 - APB_CTRL_FLASH_ACE2_ADDR_REG
        volatile uint32_t FLASH_ACE3_ADDR;  ///< Offset: 0x44 - APB_CTRL_FLASH_ACE3_ADDR_REG
        volatile uint32_t FLASH_ACE0_SIZE;  ///< Offset: 0x48 - APB_CTRL_FLASH_ACE0_SIZE_REG
        volatile uint32_t FLASH_ACE1_SIZE;  ///< Offset: 0x4C - APB_CTRL_FLASH_ACE1_SIZE_REG
        volatile uint32_t FLASH_ACE2_SIZE;  ///< Offset: 0x50 - APB_CTRL_FLASH_ACE2_SIZE_REG
        volatile uint32_t FLASH_ACE3_SIZE;  ///< Offset: 0x54 - APB_CTRL_FLASH_ACE3_SIZE_REG
        volatile uint32_t SPI_MEM_PMS_CTRL;  ///< Offset: 0x88 - APB_CTRL_SPI_MEM_PMS_CTRL_REG
        volatile uint32_t SPI_MEM_REJECT_ADDR;  ///< Offset: 0x8C - APB_CTRL_SPI_MEM_REJECT_ADDR_REG
        volatile uint32_t SDIO_CTRL;  ///< Offset: 0x90 - APB_CTRL_SDIO_CTRL_REG
        volatile uint32_t REDCY_SIG0;  ///< Offset: 0x94 - APB_CTRL_REDCY_SIG0_REG_REG
        volatile uint32_t REDCY_SIG1;  ///< Offset: 0x98 - APB_CTRL_REDCY_SIG1_REG_REG
        volatile uint32_t FRONT_END_MEM_PD;  ///< Offset: 0x9C - APB_CTRL_FRONT_END_MEM_PD_REG
        volatile uint32_t RETENTION_CTRL;  ///< Offset: 0xA0 - APB_CTRL_RETENTION_CTRL_REG
        volatile uint32_t CLKGATE_FORCE_ON;  ///< Offset: 0xA4 - Memory power configuration registers
        volatile uint32_t MEM_POWER_DOWN;  ///< Offset: 0xA8 - Memory power configuration registers
        volatile uint32_t MEM_POWER_UP;  ///< Offset: 0xAC - Memory power configuration registers
        volatile uint32_t RND_DATA;  ///< Offset: 0xB0 - APB_CTRL_RND_DATA_REG
        volatile uint32_t PERI_BACKUP_CONFIG;  ///< Offset: 0xB4 - APB_CTRL_PERI_BACKUP_CONFIG_REG_REG
        volatile uint32_t PERI_BACKUP_APB_ADDR;  ///< Offset: 0xB8 - APB_CTRL_PERI_BACKUP_APB_ADDR_REG_REG
        volatile uint32_t PERI_BACKUP_MEM_ADDR;  ///< Offset: 0xBC - APB_CTRL_PERI_BACKUP_MEM_ADDR_REG_REG
        volatile uint32_t PERI_BACKUP_INT_RAW;  ///< Offset: 0xC0 - APB_CTRL_PERI_BACKUP_INT_RAW_REG
        volatile uint32_t PERI_BACKUP_INT_ST;  ///< Offset: 0xC4 - APB_CTRL_PERI_BACKUP_INT_ST_REG
        volatile uint32_t PERI_BACKUP_INT_ENA;  ///< Offset: 0xC8 - APB_CTRL_PERI_BACKUP_INT_ENA_REG
        volatile uint32_t PERI_BACKUP_INT_CLR;  ///< Offset: 0xD0 - APB_CTRL_PERI_BACKUP_INT_CLR_REG
        volatile uint32_t DATE;  ///< Offset: 0x3FC - APB_CTRL_DATE_REG
    };

    /// Peripheral instances
    inline Registers* APB_CTRL = reinterpret_cast<Registers*>(APB_CTRL_BASE);

    // Bit definitions
    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< reg_pre_div_cnt
        constexpr uint32_t CLK_320M_EN = (1U << 10);  ///< reg_clk_320m_en
        constexpr uint32_t CLK_EN = (1U << 11);  ///< reg_clk_en
        constexpr uint32_t RST_TICK_CNT = (1U << 12);  ///< reg_rst_tick_cnt
    }

    /// TICK_CONF Register bits
    namespace tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< reg_xtal_tick_num
        constexpr uint32_t CK8M_TICK_NUM = (8 << 8);  ///< reg_ck8m_tick_num
        constexpr uint32_t TICK_ENABLE = (1U << 16);  ///< reg_tick_enable
    }

    /// CLK_OUT_EN Register bits
    namespace clk_out_en_bits {
        constexpr uint32_t CLK20_OEN = (1U << 0);  ///< reg_clk20_oen
        constexpr uint32_t CLK22_OEN = (1U << 1);  ///< reg_clk22_oen
        constexpr uint32_t CLK44_OEN = (1U << 2);  ///< reg_clk44_oen
        constexpr uint32_t CLK_BB_OEN = (1U << 3);  ///< reg_clk_bb_oen
        constexpr uint32_t CLK80_OEN = (1U << 4);  ///< reg_clk80_oen
        constexpr uint32_t CLK160_OEN = (1U << 5);  ///< reg_clk160_oen
        constexpr uint32_t CLK_320M_OEN = (1U << 6);  ///< reg_clk_320m_oen
        constexpr uint32_t CLK_ADC_INF_OEN = (1U << 7);  ///< reg_clk_adc_inf_oen
        constexpr uint32_t CLK_DAC_CPU_OEN = (1U << 8);  ///< reg_clk_dac_cpu_oen
        constexpr uint32_t CLK40X_BB_OEN = (1U << 9);  ///< reg_clk40x_bb_oen
        constexpr uint32_t CLK_XTAL_OEN = (1U << 10);  ///< reg_clk_xtal_oen
    }

    /// WIFI_BB_CFG Register bits
    namespace wifi_bb_cfg_bits {
        constexpr uint32_t WIFI_BB_CFG = (32 << 0);  ///< reg_wifi_bb_cfg
    }

    /// WIFI_BB_CFG_2 Register bits
    namespace wifi_bb_cfg_2_bits {
        constexpr uint32_t WIFI_BB_CFG_2 = (32 << 0);  ///< reg_wifi_bb_cfg_2
    }

    /// WIFI_CLK_EN Register bits
    namespace wifi_clk_en_bits {
        constexpr uint32_t WIFI_CLK_EN = (32 << 0);  ///< reg_wifi_clk_en
    }

    /// WIFI_RST_EN Register bits
    namespace wifi_rst_en_bits {
        constexpr uint32_t WIFI_RST = (32 << 0);  ///< reg_wifi_rst
    }

    /// HOST_INF_SEL Register bits
    namespace host_inf_sel_bits {
        constexpr uint32_t PERI_IO_SWAP = (8 << 0);  ///< reg_peri_io_swap
    }

    /// EXT_MEM_PMS_LOCK Register bits
    namespace ext_mem_pms_lock_bits {
        constexpr uint32_t EXT_MEM_PMS_LOCK = (1U << 0);  ///< reg_ext_mem_pms_lock
    }

    /// FLASH_ACE0_ATTR Register bits
    namespace flash_ace0_attr_bits {
        constexpr uint32_t FLASH_ACE0_ATTR = (2 << 0);  ///< reg_flash_ace0_attr
    }

    /// FLASH_ACE1_ATTR Register bits
    namespace flash_ace1_attr_bits {
        constexpr uint32_t FLASH_ACE1_ATTR = (2 << 0);  ///< reg_flash_ace1_attr
    }

    /// FLASH_ACE2_ATTR Register bits
    namespace flash_ace2_attr_bits {
        constexpr uint32_t FLASH_ACE2_ATTR = (2 << 0);  ///< reg_flash_ace2_attr
    }

    /// FLASH_ACE3_ATTR Register bits
    namespace flash_ace3_attr_bits {
        constexpr uint32_t FLASH_ACE3_ATTR = (2 << 0);  ///< reg_flash_ace3_attr
    }

    /// FLASH_ACE0_ADDR Register bits
    namespace flash_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace0_addr_s
    }

    /// FLASH_ACE1_ADDR Register bits
    namespace flash_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace1_addr_s
    }

    /// FLASH_ACE2_ADDR Register bits
    namespace flash_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace2_addr_s
    }

    /// FLASH_ACE3_ADDR Register bits
    namespace flash_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace3_addr_s
    }

    /// FLASH_ACE0_SIZE Register bits
    namespace flash_ace0_size_bits {
        constexpr uint32_t FLASH_ACE0_SIZE = (13 << 0);  ///< reg_flash_ace0_size
    }

    /// FLASH_ACE1_SIZE Register bits
    namespace flash_ace1_size_bits {
        constexpr uint32_t FLASH_ACE1_SIZE = (13 << 0);  ///< reg_flash_ace1_size
    }

    /// FLASH_ACE2_SIZE Register bits
    namespace flash_ace2_size_bits {
        constexpr uint32_t FLASH_ACE2_SIZE = (13 << 0);  ///< reg_flash_ace2_size
    }

    /// FLASH_ACE3_SIZE Register bits
    namespace flash_ace3_size_bits {
        constexpr uint32_t FLASH_ACE3_SIZE = (13 << 0);  ///< reg_flash_ace3_size
    }

    /// SPI_MEM_PMS_CTRL Register bits
    namespace spi_mem_pms_ctrl_bits {
        constexpr uint32_t SPI_MEM_REJECT_INT = (1U << 0);  ///< reg_spi_mem_reject_int
        constexpr uint32_t SPI_MEM_REJECT_CLR = (1U << 1);  ///< reg_spi_mem_reject_clr
        constexpr uint32_t SPI_MEM_REJECT_CDE = (5 << 2);  ///< reg_spi_mem_reject_cde
    }

    /// SPI_MEM_REJECT_ADDR Register bits
    namespace spi_mem_reject_addr_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (32 << 0);  ///< reg_spi_mem_reject_addr
    }

    /// SDIO_CTRL Register bits
    namespace sdio_ctrl_bits {
        constexpr uint32_t SDIO_WIN_ACCESS_EN = (1U << 0);  ///< reg_sdio_win_access_en
    }

    /// REDCY_SIG0 Register bits
    namespace redcy_sig0_bits {
        constexpr uint32_t REDCY_SIG0 = (31 << 0);  ///< reg_redcy_sig0
        constexpr uint32_t REDCY_ANDOR = (1U << 31);  ///< reg_redcy_andor
    }

    /// REDCY_SIG1 Register bits
    namespace redcy_sig1_bits {
        constexpr uint32_t REDCY_SIG1 = (31 << 0);  ///< reg_redcy_sig1
        constexpr uint32_t REDCY_NANDOR = (1U << 31);  ///< reg_redcy_nandor
    }

    /// FRONT_END_MEM_PD Register bits
    namespace front_end_mem_pd_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 0);  ///< reg_agc_mem_force_pu
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 1);  ///< reg_agc_mem_force_pd
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 2);  ///< reg_pbus_mem_force_pu
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 3);  ///< reg_pbus_mem_force_pd
        constexpr uint32_t DC_MEM_FORCE_PU = (1U << 4);  ///< reg_dc_mem_force_pu
        constexpr uint32_t DC_MEM_FORCE_PD = (1U << 5);  ///< reg_dc_mem_force_pd
        constexpr uint32_t FREQ_MEM_FORCE_PU = (1U << 6);  ///< reg_freq_mem_force_pu
        constexpr uint32_t FREQ_MEM_FORCE_PD = (1U << 7);  ///< reg_freq_mem_force_pd
    }

    /// RETENTION_CTRL Register bits
    namespace retention_ctrl_bits {
        constexpr uint32_t RETENTION_LINK_ADDR = (27 << 0);  ///< reg_retention_link_addr
        constexpr uint32_t NOBYPASS_CPU_ISO_RST = (1U << 27);  ///< reg_nobypass_cpu_iso_rst
    }

    /// CLKGATE_FORCE_ON Register bits
    namespace clkgate_force_on_bits {
        constexpr uint32_t ROM_CLKGATE_FORCE_ON = (3 << 0);  ///< Set the bit to 1 to force rom always have clock, for low power can clear to 0 then only when have access the rom have clock
        constexpr uint32_t SRAM_CLKGATE_FORCE_ON = (4 << 3);  ///< Set the bit to 1 to force sram always have clock, for low power can clear to 0 then only when have access the sram have clock
    }

    /// MEM_POWER_DOWN Register bits
    namespace mem_power_down_bits {
        constexpr uint32_t ROM_POWER_DOWN = (3 << 0);  ///< Set 1 to let rom power down
        constexpr uint32_t SRAM_POWER_DOWN = (4 << 3);  ///< Set 1 to let sram power down
    }

    /// MEM_POWER_UP Register bits
    namespace mem_power_up_bits {
        constexpr uint32_t ROM_POWER_UP = (3 << 0);  ///< Set 1 to let rom power up
        constexpr uint32_t SRAM_POWER_UP = (4 << 3);  ///< Set 1 to let sram power up
    }

    /// RND_DATA Register bits
    namespace rnd_data_bits {
        constexpr uint32_t RND_DATA = (32 << 0);  ///< reg_rnd_data
    }

    /// PERI_BACKUP_CONFIG Register bits
    namespace peri_backup_config_bits {
        constexpr uint32_t PERI_BACKUP_FLOW_ERR = (2 << 1);  ///< reg_peri_backup_flow_err
        constexpr uint32_t PERI_BACKUP_BURST_LIMIT = (5 << 4);  ///< reg_peri_backup_burst_limit
        constexpr uint32_t PERI_BACKUP_TOUT_THRES = (10 << 9);  ///< reg_peri_backup_tout_thres
        constexpr uint32_t PERI_BACKUP_SIZE = (10 << 19);  ///< reg_peri_backup_size
        constexpr uint32_t PERI_BACKUP_START = (1U << 29);  ///< reg_peri_backup_start
        constexpr uint32_t PERI_BACKUP_TO_MEM = (1U << 30);  ///< reg_peri_backup_to_mem
        constexpr uint32_t PERI_BACKUP_ENA = (1U << 31);  ///< reg_peri_backup_ena
    }

    /// PERI_BACKUP_APB_ADDR Register bits
    namespace peri_backup_apb_addr_bits {
        constexpr uint32_t BACKUP_APB_START_ADDR = (32 << 0);  ///< reg_backup_apb_start_addr
    }

    /// PERI_BACKUP_MEM_ADDR Register bits
    namespace peri_backup_mem_addr_bits {
        constexpr uint32_t BACKUP_MEM_START_ADDR = (32 << 0);  ///< reg_backup_mem_start_addr
    }

    /// PERI_BACKUP_INT_RAW Register bits
    namespace peri_backup_int_raw_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_RAW = (1U << 0);  ///< reg_peri_backup_done_int_raw
        constexpr uint32_t PERI_BACKUP_ERR_INT_RAW = (1U << 1);  ///< reg_peri_backup_err_int_raw
    }

    /// PERI_BACKUP_INT_ST Register bits
    namespace peri_backup_int_st_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_ST = (1U << 0);  ///< reg_peri_backup_done_int_st
        constexpr uint32_t PERI_BACKUP_ERR_INT_ST = (1U << 1);  ///< reg_peri_backup_err_int_st
    }

    /// PERI_BACKUP_INT_ENA Register bits
    namespace peri_backup_int_ena_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_ENA = (1U << 0);  ///< reg_peri_backup_done_int_ena
        constexpr uint32_t PERI_BACKUP_ERR_INT_ENA = (1U << 1);  ///< reg_peri_backup_err_int_ena
    }

    /// PERI_BACKUP_INT_CLR Register bits
    namespace peri_backup_int_clr_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_CLR = (1U << 0);  ///< reg_peri_backup_done_int_clr
        constexpr uint32_t PERI_BACKUP_ERR_INT_CLR = (1U << 1);  ///< reg_peri_backup_err_int_clr
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< reg_dateVersion control
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t APB_SARADC_BASE = 0x60040000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - register description
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - register description
        volatile uint32_t FILTER_CTRL1;  ///< Offset: 0x08 - register description
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - register description
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - register description
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - register description
        volatile uint32_t SAR_PATT_TAB1;  ///< Offset: 0x18 - register description
        volatile uint32_t SAR_PATT_TAB2;  ///< Offset: 0x1C - register description
        volatile uint32_t ONETIME_SAMPLE;  ///< Offset: 0x20 - register description
        volatile uint32_t APB_ADC_ARB_CTRL;  ///< Offset: 0x24 - register description
        volatile uint32_t FILTER_CTRL0;  ///< Offset: 0x28 - register description
        volatile uint32_t SAR1DATA_STATUS;  ///< Offset: 0x2C - register description
        volatile uint32_t SAR2DATA_STATUS;  ///< Offset: 0x30 - register description
        volatile uint32_t THRES0_CTRL;  ///< Offset: 0x34 - register description
        volatile uint32_t THRES1_CTRL;  ///< Offset: 0x38 - register description
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x3C - register description
        volatile uint32_t INT_ENA;  ///< Offset: 0x40 - register description
        volatile uint32_t INT_RAW;  ///< Offset: 0x44 - register description
        volatile uint32_t INT_ST;  ///< Offset: 0x48 - register description
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - register description
        volatile uint32_t DMA_CONF;  ///< Offset: 0x50 - register description
        volatile uint32_t APB_ADC_CLKM_CONF;  ///< Offset: 0x54 - register description
        volatile uint32_t APB_TSENS_CTRL;  ///< Offset: 0x58 - register description
        volatile uint32_t APB_TSENS_CTRL2;  ///< Offset: 0x5C - register description
        volatile uint32_t CALI;  ///< Offset: 0x60 - register description
        volatile uint32_t APB_CTRL_DATE;  ///< Offset: 0x3FC - register description
    };

    /// Peripheral instances
    inline Registers* APB_SARADC = reinterpret_cast<Registers*>(APB_SARADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SARADC_START_FORCE = (1U << 0);  ///< Need add description
        constexpr uint32_t SARADC_START = (1U << 1);  ///< Need add description
        constexpr uint32_t SARADC_SAR_CLK_GATED = (1U << 6);  ///< Need add description
        constexpr uint32_t SARADC_SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SARADC_SAR_PATT_LEN = (3 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SARADC_XPD_SAR_FORCE = (2 << 27);  ///< force option to xpd sar blocks
        constexpr uint32_t SARADC_WAIT_ARB_CYCLE = (2 << 30);  ///< wait arbit signal stable after sar_done
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t SARADC_MEAS_NUM_LIMIT = (1U << 0);  ///< Need add description
        constexpr uint32_t SARADC_MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SARADC_SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_TIMER_TARGET = (12 << 12);  ///< to set saradc timer target
        constexpr uint32_t SARADC_TIMER_EN = (1U << 24);  ///< to enable saradc timer trigger
    }

    /// FILTER_CTRL1 Register bits
    namespace filter_ctrl1_bits {
        constexpr uint32_t FILTER_FACTOR1 = (3 << 26);  ///< Need add description
        constexpr uint32_t FILTER_FACTOR0 = (3 << 29);  ///< Need add description
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t SARADC_XPD_WAIT = (8 << 0);  ///< Need add description
        constexpr uint32_t SARADC_RSTB_WAIT = (8 << 8);  ///< Need add description
        constexpr uint32_t SARADC_STANDBY_WAIT = (8 << 16);  ///< Need add description
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SARADC_SAR1_STATUS = (32 << 0);  ///< Need add description
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SARADC_SAR2_STATUS = (32 << 0);  ///< Need add description
    }

    /// SAR_PATT_TAB1 Register bits
    namespace sar_patt_tab1_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// SAR_PATT_TAB2 Register bits
    namespace sar_patt_tab2_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item one byte)
    }

    /// ONETIME_SAMPLE Register bits
    namespace onetime_sample_bits {
        constexpr uint32_t SARADC_ONETIME_ATTEN = (2 << 23);  ///< Need add description
        constexpr uint32_t SARADC_ONETIME_CHANNEL = (4 << 25);  ///< Need add description
        constexpr uint32_t SARADC_ONETIME_START = (1U << 29);  ///< Need add description
        constexpr uint32_t SARADC2_ONETIME_SAMPLE = (1U << 30);  ///< Need add description
        constexpr uint32_t SARADC1_ONETIME_SAMPLE = (1U << 31);  ///< Need add description
    }

    /// APB_ADC_ARB_CTRL Register bits
    namespace apb_adc_arb_ctrl_bits {
        constexpr uint32_t ADC_ARB_APB_FORCE = (1U << 2);  ///< adc2 arbiter force to enableapb controller
        constexpr uint32_t ADC_ARB_RTC_FORCE = (1U << 3);  ///< adc2 arbiter force to enable rtc controller
        constexpr uint32_t ADC_ARB_WIFI_FORCE = (1U << 4);  ///< adc2 arbiter force to enable wifi controller
        constexpr uint32_t ADC_ARB_GRANT_FORCE = (1U << 5);  ///< adc2 arbiter force grant
        constexpr uint32_t ADC_ARB_APB_PRIORITY = (2 << 6);  ///< Set adc2 arbiterapb priority
        constexpr uint32_t ADC_ARB_RTC_PRIORITY = (2 << 8);  ///< Set adc2 arbiter rtc priority
        constexpr uint32_t ADC_ARB_WIFI_PRIORITY = (2 << 10);  ///< Set adc2 arbiter wifi priority
        constexpr uint32_t ADC_ARB_FIX_PRIORITY = (1U << 12);  ///< adc2 arbiter uses fixed priority
    }

    /// FILTER_CTRL0 Register bits
    namespace filter_ctrl0_bits {
        constexpr uint32_t FILTER_CHANNEL1 = (4 << 18);  ///< Need add description
        constexpr uint32_t FILTER_CHANNEL0 = (4 << 22);  ///< apb_adc1_filter_factor
        constexpr uint32_t FILTER_RESET = (1U << 31);  ///< enable apb_adc1_filter
    }

    /// SAR1DATA_STATUS Register bits
    namespace sar1data_status_bits {
        constexpr uint32_t APB_SARADC1_DATA = (17 << 0);  ///< Need add description
    }

    /// SAR2DATA_STATUS Register bits
    namespace sar2data_status_bits {
        constexpr uint32_t APB_SARADC2_DATA = (17 << 0);  ///< Need add description
    }

    /// THRES0_CTRL Register bits
    namespace thres0_ctrl_bits {
        constexpr uint32_t THRES0_CHANNEL = (4 << 0);  ///< Need add description
        constexpr uint32_t THRES0_HIGH = (13 << 5);  ///< saradc1's thres0 monitor thres
        constexpr uint32_t THRES0_LOW = (13 << 18);  ///< saradc1's thres0 monitor thres
    }

    /// THRES1_CTRL Register bits
    namespace thres1_ctrl_bits {
        constexpr uint32_t THRES1_CHANNEL = (4 << 0);  ///< Need add description
        constexpr uint32_t THRES1_HIGH = (13 << 5);  ///< saradc1's thres0 monitor thres
        constexpr uint32_t THRES1_LOW = (13 << 18);  ///< saradc1's thres0 monitor thres
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t THRES_ALL_EN = (1U << 27);  ///< Need add description
        constexpr uint32_t THRES3_EN = (1U << 28);  ///< Need add description
        constexpr uint32_t THRES2_EN = (1U << 29);  ///< Need add description
        constexpr uint32_t THRES1_EN = (1U << 30);  ///< Need add description
        constexpr uint32_t THRES0_EN = (1U << 31);  ///< Need add description
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t THRES1_LOW_INT_ENA = (1U << 26);  ///< Need add description
        constexpr uint32_t THRES0_LOW_INT_ENA = (1U << 27);  ///< Need add description
        constexpr uint32_t THRES1_HIGH_INT_ENA = (1U << 28);  ///< Need add description
        constexpr uint32_t THRES0_HIGH_INT_ENA = (1U << 29);  ///< Need add description
        constexpr uint32_t APB_SARADC2_DONE_INT_ENA = (1U << 30);  ///< Need add description
        constexpr uint32_t APB_SARADC1_DONE_INT_ENA = (1U << 31);  ///< Need add description
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t THRES1_LOW_INT_RAW = (1U << 26);  ///< Need add description
        constexpr uint32_t THRES0_LOW_INT_RAW = (1U << 27);  ///< Need add description
        constexpr uint32_t THRES1_HIGH_INT_RAW = (1U << 28);  ///< Need add description
        constexpr uint32_t THRES0_HIGH_INT_RAW = (1U << 29);  ///< Need add description
        constexpr uint32_t APB_SARADC2_DONE_INT_RAW = (1U << 30);  ///< Need add description
        constexpr uint32_t APB_SARADC1_DONE_INT_RAW = (1U << 31);  ///< Need add description
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t THRES1_LOW_INT_ST = (1U << 26);  ///< Need add description
        constexpr uint32_t THRES0_LOW_INT_ST = (1U << 27);  ///< Need add description
        constexpr uint32_t THRES1_HIGH_INT_ST = (1U << 28);  ///< Need add description
        constexpr uint32_t THRES0_HIGH_INT_ST = (1U << 29);  ///< Need add description
        constexpr uint32_t APB_SARADC2_DONE_INT_ST = (1U << 30);  ///< Need add description
        constexpr uint32_t APB_SARADC1_DONE_INT_ST = (1U << 31);  ///< Need add description
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t THRES1_LOW_INT_CLR = (1U << 26);  ///< Need add description
        constexpr uint32_t THRES0_LOW_INT_CLR = (1U << 27);  ///< Need add description
        constexpr uint32_t THRES1_HIGH_INT_CLR = (1U << 28);  ///< Need add description
        constexpr uint32_t THRES0_HIGH_INT_CLR = (1U << 29);  ///< Need add description
        constexpr uint32_t APB_SARADC2_DONE_INT_CLR = (1U << 30);  ///< Need add description
        constexpr uint32_t APB_SARADC1_DONE_INT_CLR = (1U << 31);  ///< Need add description
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< the dma_in_suc_eof gen when sample cnt = spi_eof_num
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< reset_apb_adc_state
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< enable apb_adc use spi_dma
    }

    /// APB_ADC_CLKM_CONF Register bits
    namespace apb_adc_clkm_conf_bits {
        constexpr uint32_t REG_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t REG_CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value
        constexpr uint32_t REG_CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value
        constexpr uint32_t CLK_EN = (1U << 20);  ///< Need add description
        constexpr uint32_t REG_CLK_SEL = (2 << 21);  ///< Set this bit to enable clk_apll
    }

    /// APB_TSENS_CTRL Register bits
    namespace apb_tsens_ctrl_bits {
        constexpr uint32_t REG_TSENS_OUT = (8 << 0);  ///< Need add description
        constexpr uint32_t REG_TSENS_IN_INV = (1U << 13);  ///< Need add description
        constexpr uint32_t REG_TSENS_CLK_DIV = (8 << 14);  ///< Need add description
        constexpr uint32_t REG_TSENS_PU = (1U << 22);  ///< Need add description
    }

    /// APB_TSENS_CTRL2 Register bits
    namespace apb_tsens_ctrl2_bits {
        constexpr uint32_t REG_TSENS_XPD_WAIT = (12 << 0);  ///< Need add description
        constexpr uint32_t REG_TSENS_XPD_FORCE = (2 << 12);  ///< Need add description
        constexpr uint32_t REG_TSENS_CLK_INV = (1U << 14);  ///< Need add description
        constexpr uint32_t TSENS_CLK_SEL = (1U << 15);  ///< Need add description
    }

    /// CALI Register bits
    namespace cali_bits {
        constexpr uint32_t CFG = (17 << 0);  ///< Need add description
    }

    /// APB_CTRL_DATE Register bits
    namespace apb_ctrl_date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Need add description
    }

}

// ============================================================================
// ASSIST Peripheral
// ============================================================================

namespace assist {
    /// Base addresses
    constexpr uint32_t ASSIST_DEBUG_BASE = 0x600CE000;

    /// ASSIST Register structure
    struct Registers {
        volatile uint32_t CORE_0_MONTR_ENA;  ///< Offset: 0x00 - core0 monitor enable configuration register
        volatile uint32_t CORE_0_INTR_RAW;  ///< Offset: 0x04 - core0 monitor interrupt status register
        volatile uint32_t CORE_0_INTR_ENA;  ///< Offset: 0x08 - core0 monitor interrupt enable register
        volatile uint32_t CORE_0_INTR_CLR;  ///< Offset: 0x0C - core0 monitor interrupt clr register
        volatile uint32_t CORE_0_SP_MIN;  ///< Offset: 0x10 - stack min value
        volatile uint32_t CORE_0_SP_MAX;  ///< Offset: 0x14 - stack max value
        volatile uint32_t CORE_0_SP_PC;  ///< Offset: 0x18 - stack monitor pc status register
        volatile uint32_t CORE_0_RCD_EN;  ///< Offset: 0x1C - record enable configuration register
        volatile uint32_t CORE_0_RCD_PDEBUGPC;  ///< Offset: 0x20 - record status regsiter
        volatile uint32_t CORE_0_RCD_PDEBUGSP;  ///< Offset: 0x24 - record status regsiter
        volatile uint32_t CORE_0_LASTPC_BEFORE_EXCEPTION;  ///< Offset: 0x28 - cpu status register
        volatile uint32_t CORE_0_DEBUG_MODE;  ///< Offset: 0x2C - cpu status register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x30 - clock gate register
        volatile uint32_t DATE;  ///< Offset: 0x1FC - version register
    };

    /// Peripheral instances
    inline Registers* ASSIST_DEBUG = reinterpret_cast<Registers*>(ASSIST_DEBUG_BASE);

    // Bit definitions
    /// CORE_0_MONTR_ENA Register bits
    namespace core_0_montr_ena_bits {
        constexpr uint32_t CORE_0_SP_SPILL_MIN_ENA = (1U << 0);  ///< enbale sp underlow monitor
        constexpr uint32_t CORE_0_SP_SPILL_MAX_ENA = (1U << 1);  ///< enbale sp overflow monitor
    }

    /// CORE_0_INTR_RAW Register bits
    namespace core_0_intr_raw_bits {
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RAW = (1U << 0);  ///< sp underlow monitor interrupt status register
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RAW = (1U << 1);  ///< sp overflow monitor interupt status register
    }

    /// CORE_0_INTR_ENA Register bits
    namespace core_0_intr_ena_bits {
        constexpr uint32_t CORE_0_SP_SPILL_MIN_INTR_ENA = (1U << 0);  ///< enbale sp underlow monitor interrupt
        constexpr uint32_t CORE_0_SP_SPILL_MAX_INTR_ENA = (1U << 1);  ///< enbale sp overflow monitor interrupt
    }

    /// CORE_0_INTR_CLR Register bits
    namespace core_0_intr_clr_bits {
        constexpr uint32_t CORE_0_SP_SPILL_MIN_CLR = (1U << 0);  ///< clr sp underlow monitor interrupt
        constexpr uint32_t CORE_0_SP_SPILL_MAX_CLR = (1U << 1);  ///< clr sp overflow monitor interrupt
    }

    /// CORE_0_SP_MIN Register bits
    namespace core_0_sp_min_bits {
        constexpr uint32_t CORE_0_SP_MIN = (32 << 0);  ///< core0 sp region configuration regsiter
    }

    /// CORE_0_SP_MAX Register bits
    namespace core_0_sp_max_bits {
        constexpr uint32_t CORE_0_SP_MAX = (32 << 0);  ///< core0 sp pc status register
    }

    /// CORE_0_SP_PC Register bits
    namespace core_0_sp_pc_bits {
        constexpr uint32_t CORE_0_SP_PC = (32 << 0);  ///< This regsiter stores the PC when trigger stack monitor.
    }

    /// CORE_0_RCD_EN Register bits
    namespace core_0_rcd_en_bits {
        constexpr uint32_t CORE_0_RCD_RECORDEN = (1U << 0);  ///< Set 1 to enable record PC
        constexpr uint32_t CORE_0_RCD_PDEBUGEN = (1U << 1);  ///< Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
    }

    /// CORE_0_RCD_PDEBUGPC Register bits
    namespace core_0_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGPC = (32 << 0);  ///< recorded PC
    }

    /// CORE_0_RCD_PDEBUGSP Register bits
    namespace core_0_rcd_pdebugsp_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGSP = (32 << 0);  ///< recorded sp
    }

    /// CORE_0_LASTPC_BEFORE_EXCEPTION Register bits
    namespace core_0_lastpc_before_exception_bits {
        constexpr uint32_t CORE_0_LASTPC_BEFORE_EXC = (32 << 0);  ///< cpu's lastpc before exception
    }

    /// CORE_0_DEBUG_MODE Register bits
    namespace core_0_debug_mode_bits {
        constexpr uint32_t CORE_0_DEBUG_MODE = (1U << 0);  ///< cpu debug mode status, 1 means cpu enter debug mode.
        constexpr uint32_t CORE_0_DEBUG_MODULE_ACTIVE = (1U << 1);  ///< cpu debug_module active status
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock gate register
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// BB Peripheral
// ============================================================================

namespace bb {
    /// Base addresses
    constexpr uint32_t BB_BASE = 0x6001D000;

    /// BB Register structure
    struct Registers {
        volatile uint32_t BBPD_CTRL;  ///< Offset: 0x54 - Baseband control register
    };

    /// Peripheral instances
    inline Registers* BB = reinterpret_cast<Registers*>(BB_BASE);

    // Bit definitions
    /// BBPD_CTRL Register bits
    namespace bbpd_ctrl_bits {
        constexpr uint32_t DC_EST_FORCE_PD = (1U << 0);  ///< DC_EST_FORCE_PD
        constexpr uint32_t DC_EST_FORCE_PU = (1U << 1);  ///< DC_EST_FORCE_PU
        constexpr uint32_t FFT_FORCE_PD = (1U << 2);  ///< FFT_FORCE_PD
        constexpr uint32_t FFT_FORCE_PU = (1U << 3);  ///< FFT_FORCE_PU
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x6003F000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t INT_RAW_CH0;  ///< Offset: 0x00 - DMA_INT_RAW_CH0_REG.
        volatile uint32_t INT_ST_CH0;  ///< Offset: 0x04 - DMA_INT_ST_CH0_REG.
        volatile uint32_t INT_ENA_CH0;  ///< Offset: 0x08 - DMA_INT_ENA_CH0_REG.
        volatile uint32_t INT_CLR_CH0;  ///< Offset: 0x0C - DMA_INT_CLR_CH0_REG.
        volatile uint32_t AHB_TEST;  ///< Offset: 0x40 - DMA_AHB_TEST_REG.
        volatile uint32_t MISC_CONF;  ///< Offset: 0x44 - DMA_MISC_CONF_REG.
        volatile uint32_t DATE;  ///< Offset: 0x48 - DMA_DATE_REG.
        volatile uint32_t IN_CONF0_CH0;  ///< Offset: 0x70 - DMA_IN_CONF0_CH0_REG.
        volatile uint32_t IN_CONF1_CH0;  ///< Offset: 0x74 - DMA_IN_CONF1_CH0_REG.
        volatile uint32_t INFIFO_STATUS_CH0;  ///< Offset: 0x78 - DMA_INFIFO_STATUS_CH0_REG.
        volatile uint32_t IN_POP_CH0;  ///< Offset: 0x7C - DMA_IN_POP_CH0_REG.
        volatile uint32_t IN_LINK_CH0;  ///< Offset: 0x80 - DMA_IN_LINK_CH0_REG.
        volatile uint32_t IN_STATE_CH0;  ///< Offset: 0x84 - DMA_IN_STATE_CH0_REG.
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH0;  ///< Offset: 0x88 - DMA_IN_SUC_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH0;  ///< Offset: 0x8C - DMA_IN_ERR_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t IN_DSCR_CH0;  ///< Offset: 0x90 - DMA_IN_DSCR_CH0_REG.
        volatile uint32_t IN_DSCR_BF0_CH0;  ///< Offset: 0x94 - DMA_IN_DSCR_BF0_CH0_REG.
        volatile uint32_t IN_DSCR_BF1_CH0;  ///< Offset: 0x98 - DMA_IN_DSCR_BF1_CH0_REG.
        volatile uint32_t IN_PRI_CH0;  ///< Offset: 0x9C - DMA_IN_PRI_CH0_REG.
        volatile uint32_t IN_PERI_SEL_CH0;  ///< Offset: 0xA0 - DMA_IN_PERI_SEL_CH0_REG.
        volatile uint32_t OUT_CONF0_CH0;  ///< Offset: 0xD0 - DMA_OUT_CONF0_CH0_REG.
        volatile uint32_t OUT_CONF1_CH0;  ///< Offset: 0xD4 - DMA_OUT_CONF1_CH0_REG.
        volatile uint32_t OUTFIFO_STATUS_CH0;  ///< Offset: 0xD8 - DMA_OUTFIFO_STATUS_CH0_REG.
        volatile uint32_t OUT_PUSH_CH0;  ///< Offset: 0xDC - DMA_OUT_PUSH_CH0_REG.
        volatile uint32_t OUT_LINK_CH0;  ///< Offset: 0xE0 - DMA_OUT_LINK_CH0_REG.
        volatile uint32_t OUT_STATE_CH0;  ///< Offset: 0xE4 - DMA_OUT_STATE_CH0_REG.
        volatile uint32_t OUT_EOF_DES_ADDR_CH0;  ///< Offset: 0xE8 - DMA_OUT_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH0;  ///< Offset: 0xEC - DMA_OUT_EOF_BFR_DES_ADDR_CH0_REG.
        volatile uint32_t OUT_DSCR_CH0;  ///< Offset: 0xF0 - DMA_OUT_DSCR_CH0_REG.
        volatile uint32_t OUT_DSCR_BF0_CH0;  ///< Offset: 0xF4 - DMA_OUT_DSCR_BF0_CH0_REG.
        volatile uint32_t OUT_DSCR_BF1_CH0;  ///< Offset: 0xF8 - DMA_OUT_DSCR_BF1_CH0_REG.
        volatile uint32_t OUT_PRI_CH0;  ///< Offset: 0xFC - DMA_OUT_PRI_CH0_REG.
        volatile uint32_t OUT_PERI_SEL_CH0;  ///< Offset: 0x100 - DMA_OUT_PERI_SEL_CH0_REG.
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// INT_RAW_CH0 Register bits
    namespace int_raw_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0, the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals, this raw interrupt is reserved.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error, including owner error, the second and third word error of inlink descriptor for Rx channel 0.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error, including owner error, the second and third word error of outlink descriptor for Tx channel 0.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed, but there is no more inlink for Rx channel 0.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
    }

    /// INT_ST_CH0 Register bits
    namespace int_st_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_ENA_CH0 Register bits
    namespace int_ena_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_CLR_CH0 Register bits
    namespace int_clr_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< reserved
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< reserved
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t AHBM_RST_INTER = (1U << 0);  ///< Set this bit, then clear this bit to reset the internal ahb FSM.
        constexpr uint32_t ARB_PRI_DIS = (1U << 2);  ///< Set this bit to disable priority arbitration function.
        constexpr uint32_t CLK_EN = (1U << 3);  ///< reg_clk_en
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

    /// IN_CONF0_CH0 Register bits
    namespace in_conf0_ch0_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
    }

    /// IN_CONF1_CH0 Register bits
    namespace in_conf1_ch0_bits {
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH0 Register bits
    namespace infifo_status_ch0_bits {
        constexpr uint32_t INFIFO_FULL = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
        constexpr uint32_t IN_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH0 Register bits
    namespace in_pop_ch0_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH0 Register bits
    namespace in_link_ch0_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address, when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH0 Register bits
    namespace in_state_ch0_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH0 Register bits
    namespace in_suc_eof_des_addr_ch0_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH0 Register bits
    namespace in_err_eof_des_addr_ch0_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH0 Register bits
    namespace in_dscr_ch0_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH0 Register bits
    namespace in_dscr_bf0_ch0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH0 Register bits
    namespace in_dscr_bf1_ch0_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH0 Register bits
    namespace in_pri_ch0_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 0. The larger of the value, the higher of the priority.
    }

    /// IN_PERI_SEL_CH0 Register bits
    namespace in_peri_sel_ch0_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// OUT_CONF0_CH0 Register bits
    namespace out_conf0_ch0_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 0 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 transmitting data when accessing internal SRAM.
    }

    /// OUT_CONF1_CH0 Register bits
    namespace out_conf1_ch0_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH0 Register bits
    namespace outfifo_status_ch0_bits {
        constexpr uint32_t OUTFIFO_FULL = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUT_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH0 Register bits
    namespace out_push_ch0_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH0 Register bits
    namespace out_link_ch0_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH0 Register bits
    namespace out_state_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH0 Register bits
    namespace out_eof_des_addr_ch0_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH0 Register bits
    namespace out_eof_bfr_des_addr_ch0_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH0 Register bits
    namespace out_dscr_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH0 Register bits
    namespace out_dscr_bf0_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH0 Register bits
    namespace out_dscr_bf1_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH0 Register bits
    namespace out_pri_ch0_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 0. The larger of the value, the higher of the priority.
    }

    /// OUT_PERI_SEL_CH0 Register bits
    namespace out_peri_sel_ch0_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

}

// ============================================================================
// ECC Peripheral
// ============================================================================

namespace ecc {
    /// Base addresses
    constexpr uint32_t ECC_BASE = 0x6003E000;

    /// ECC Register structure
    struct Registers {
        volatile uint32_t MULT_INT_RAW;  ///< Offset: 0x0C - I2S interrupt raw register, valid in level.
        volatile uint32_t MULT_INT_ST;  ///< Offset: 0x10 - I2S interrupt status register.
        volatile uint32_t MULT_INT_ENA;  ///< Offset: 0x14 - I2S interrupt enable register.
        volatile uint32_t MULT_INT_CLR;  ///< Offset: 0x18 - I2S interrupt clear register.
        volatile uint32_t MULT_CONF;  ///< Offset: 0x1C - I2S RX configure register
        volatile uint32_t MULT_DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t K_MEM__;  ///< Offset: 0x100 - The memory that stores k. (renamed from K_MEM__)
        volatile uint32_t PX_MEM__;  ///< Offset: 0x120 - The memory that stores Px. (renamed from PX_MEM__)
        volatile uint32_t PY_MEM__;  ///< Offset: 0x140 - The memory that stores Py. (renamed from PY_MEM__)
    };

    /// Peripheral instances
    inline Registers* ECC = reinterpret_cast<Registers*>(ECC_BASE);

    // Bit definitions
    /// MULT_INT_RAW Register bits
    namespace mult_int_raw_bits {
        constexpr uint32_t CALC_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// MULT_INT_ST Register bits
    namespace mult_int_st_bits {
        constexpr uint32_t CALC_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the i2s_rx_done_int interrupt
    }

    /// MULT_INT_ENA Register bits
    namespace mult_int_ena_bits {
        constexpr uint32_t CALC_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the i2s_rx_done_int interrupt
    }

    /// MULT_INT_CLR Register bits
    namespace mult_int_clr_bits {
        constexpr uint32_t CALC_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the i2s_rx_done_int interrupt
    }

    /// MULT_CONF Register bits
    namespace mult_conf_bits {
        constexpr uint32_t START = (1U << 0);  ///< Set this bit to reset receiver
        constexpr uint32_t RESET = (1U << 1);  ///< Set this bit to reset Rx AFIFO
        constexpr uint32_t KEY_LENGTH = (1U << 2);  ///< Set this bit to start receiving data
        constexpr uint32_t SECURITY_MODE = (1U << 3);  ///< Set this bit to enable slave receiver mode
        constexpr uint32_t CLK_EN = (1U << 4);  ///< clk gate
        constexpr uint32_t WORK_MODE = (3 << 5);  ///< Reserved
        constexpr uint32_t VERIFICATION_RESULT = (1U << 8);  ///< Reserve
    }

    /// MULT_DATE Register bits
    namespace mult_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< ECC mult version control register
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x60008800;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA0;  ///< Offset: 0x00 - Register 0 that stores data to be programmed.
        volatile uint32_t PGM_DATA1;  ///< Offset: 0x04 - Register 1 that stores data to be programmed.
        volatile uint32_t PGM_DATA2;  ///< Offset: 0x08 - Register 2 that stores data to be programmed.
        volatile uint32_t PGM_DATA3;  ///< Offset: 0x0C - Register 3 that stores data to be programmed.
        volatile uint32_t PGM_DATA4;  ///< Offset: 0x10 - Register 4 that stores data to be programmed.
        volatile uint32_t PGM_DATA5;  ///< Offset: 0x14 - Register 5 that stores data to be programmed.
        volatile uint32_t PGM_DATA6;  ///< Offset: 0x18 - Register 6 that stores data to be programmed.
        volatile uint32_t PGM_DATA7;  ///< Offset: 0x1C - Register 7 that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE0;  ///< Offset: 0x20 - Register 0 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE1;  ///< Offset: 0x24 - Register 1 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE2;  ///< Offset: 0x28 - Register 2 that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - BLOCK0 data register 0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - BLOCK0 data register 1.
        volatile uint32_t RD_BLK1_DATA0;  ///< Offset: 0x34 - BLOCK1 data register 0.
        volatile uint32_t RD_BLK1_DATA1;  ///< Offset: 0x38 - BLOCK1 data register 1.
        volatile uint32_t RD_BLK1_DATA2;  ///< Offset: 0x3C - BLOCK1 data register 2.
        volatile uint32_t RD_BLK2_DATA0;  ///< Offset: 0x40 - Register 0 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA1;  ///< Offset: 0x44 - Register 1 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA2;  ///< Offset: 0x48 - Register 2 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA3;  ///< Offset: 0x4C - Register 3 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA4;  ///< Offset: 0x50 - Register 4 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA5;  ///< Offset: 0x54 - Register 5 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA6;  ///< Offset: 0x58 - Register 6 of BLOCK2.
        volatile uint32_t RD_BLK2_DATA7;  ///< Offset: 0x5C - Register 7 of BLOCK2.
        volatile uint32_t RD_BLK3_DATA0;  ///< Offset: 0x60 - Register 0 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA1;  ///< Offset: 0x64 - Register 1 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA2;  ///< Offset: 0x68 - Register 2 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA3;  ///< Offset: 0x6C - Register 3 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA4;  ///< Offset: 0x70 - Register 4 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA5;  ///< Offset: 0x74 - Register 5 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA6;  ///< Offset: 0x78 - Register 6 of BLOCK3.
        volatile uint32_t RD_BLK3_DATA7;  ///< Offset: 0x7C - Register 7 of BLOCK3.
        volatile uint32_t RD_REPEAT_ERR;  ///< Offset: 0x80 - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_RS_ERR;  ///< Offset: 0x84 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x88 - eFuse clcok configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x8C - eFuse operation mode configuraiton register
        volatile uint32_t STATUS;  ///< Offset: 0x90 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x94 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x98 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x9C - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x100 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x104 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x108 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x10C - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF0;  ///< Offset: 0x110 - Configurarion register 0 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x114 - Configurarion register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x118 - Configurarion register 2 of eFuse programming timing parameters.
        volatile uint32_t DATE;  ///< Offset: 0x1FC - eFuse version register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA0 Register bits
    namespace pgm_data0_bits {
        constexpr uint32_t PGM_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit data to be programmed.
    }

    /// PGM_DATA1 Register bits
    namespace pgm_data1_bits {
        constexpr uint32_t PGM_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit data to be programmed.
    }

    /// PGM_DATA2 Register bits
    namespace pgm_data2_bits {
        constexpr uint32_t PGM_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit data to be programmed.
    }

    /// PGM_DATA3 Register bits
    namespace pgm_data3_bits {
        constexpr uint32_t PGM_DATA_3 = (32 << 0);  ///< The content of the 3rd 32-bit data to be programmed.
    }

    /// PGM_DATA4 Register bits
    namespace pgm_data4_bits {
        constexpr uint32_t PGM_DATA_4 = (32 << 0);  ///< The content of the 4th 32-bit data to be programmed.
    }

    /// PGM_DATA5 Register bits
    namespace pgm_data5_bits {
        constexpr uint32_t PGM_DATA_5 = (32 << 0);  ///< The content of the 5th 32-bit data to be programmed.
    }

    /// PGM_DATA6 Register bits
    namespace pgm_data6_bits {
        constexpr uint32_t PGM_DATA_6 = (32 << 0);  ///< The content of the 6th 32-bit data to be programmed.
    }

    /// PGM_DATA7 Register bits
    namespace pgm_data7_bits {
        constexpr uint32_t PGM_DATA_7 = (32 << 0);  ///< The content of the 7th 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE0 Register bits
    namespace pgm_check_value0_bits {
        constexpr uint32_t PGM_RS_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE1 Register bits
    namespace pgm_check_value1_bits {
        constexpr uint32_t PGM_RS_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE2 Register bits
    namespace pgm_check_value2_bits {
        constexpr uint32_t PGM_RS_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (8 << 0);  ///< Disable programming of individual eFuses.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (2 << 0);  ///< The bit be set to disable software read high/low 128-bit of BLK3.
        constexpr uint32_t WDT_DELAY_SEL = (2 << 2);  ///< Selects RTC watchdog timeout threshold, in unit of slow clock cycle. 0: 40000. 1: 80000. 2: 160000. 3:320000.
        constexpr uint32_t DIS_PAD_JTAG = (1U << 4);  ///< Set this bit to disable pad jtag.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE = (1U << 5);  ///< The bit be set to disable icache in download mode.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 6);  ///< The bit be set to disable manual encryption.
        constexpr uint32_t SPI_BOOT_ENCRYPT_DECRYPT_CNT = (3 << 7);  ///< These bits be set to enable SPI boot encrypt/decrypt. Odd number of 1: enable. even number of 1: disable.
        constexpr uint32_t XTS_KEY_LENGTH_256 = (1U << 10);  ///< The bit be set means XTS_AES use the whole 256-bit efuse data in BLOCK3. Otherwise, XTS_AES use 128-bit eFuse data in BLOCK3.
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 11);  ///< Set this bit to disable usb printing.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 13);  ///< Set this bit to force ROM code to send a resume command during SPI boot.
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 14);  ///< Set this bit to disable download mode (boot_mode[3:0] = 0, 1, 2, 4, 5, 6, 7).
        constexpr uint32_t DIS_DIRECT_BOOT = (1U << 15);  ///< This bit set means disable direct_boot mode.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 16);  ///< Set this bit to enable secure UART download mode.
        constexpr uint32_t FLASH_TPUW = (4 << 17);  ///< Configures flash waiting time after power-up, in unit of ms. If the value is less than 15, the waiting time is the configurable value. Otherwise, the waiting time is twice the configurable value.
        constexpr uint32_t SECURE_BOOT_EN = (1U << 21);  ///< The bit be set to enable secure boot.
        constexpr uint32_t RPT4_RESERVED = (10 << 22);  ///< Reserved (used for four backups method).
    }

    /// RD_BLK1_DATA0 Register bits
    namespace rd_blk1_data0_bits {
        constexpr uint32_t SYSTEM_DATA0 = (32 << 0);  ///< Stores the bits [0:31] of system data.
    }

    /// RD_BLK1_DATA1 Register bits
    namespace rd_blk1_data1_bits {
        constexpr uint32_t SYSTEM_DATA1 = (32 << 0);  ///< Stores the bits [32:63] of system data.
    }

    /// RD_BLK1_DATA2 Register bits
    namespace rd_blk1_data2_bits {
        constexpr uint32_t SYSTEM_DATA2 = (24 << 0);  ///< Stores the bits [64:87] of system data.
    }

    /// RD_BLK2_DATA0 Register bits
    namespace rd_blk2_data0_bits {
        constexpr uint32_t BLK2_DATA0 = (32 << 0);  ///< Store the bit [0:31] of MAC.
    }

    /// RD_BLK2_DATA1 Register bits
    namespace rd_blk2_data1_bits {
        constexpr uint32_t MAC_ID_HIGH = (16 << 0);  ///< Store the bit [31:47] of MAC.
        constexpr uint32_t WAFER_VERSION = (3 << 16);  ///< Store wafer version.
        constexpr uint32_t PKG_VERSION = (3 << 19);  ///< Store package version.
        constexpr uint32_t BLK2_EFUSE_VERSION = (3 << 22);  ///< Store efuse version.
        constexpr uint32_t RF_REF_I_BIAS_CONFIG = (4 << 25);  ///< Store rf configuration parameters.
        constexpr uint32_t LDO_VOL_BIAS_CONFIG_LOW = (3 << 29);  ///< Store the bit [0:2] of ido configuration parameters.
    }

    /// RD_BLK2_DATA2 Register bits
    namespace rd_blk2_data2_bits {
        constexpr uint32_t LDO_VOL_BIAS_CONFIG_HIGH = (27 << 0);  ///< Store the bit [3:29] of ido configuration parameters.
        constexpr uint32_t PVT_LOW = (5 << 27);  ///< Store the bit [0:4] of pvt.
    }

    /// RD_BLK2_DATA3 Register bits
    namespace rd_blk2_data3_bits {
        constexpr uint32_t PVT_HIGH = (10 << 0);  ///< Store the bit [5:14] of pvt.
        constexpr uint32_t ADC_CALIBRATION_0 = (22 << 10);  ///< Store the bit [0:21] of ADC calibration data.
    }

    /// RD_BLK2_DATA4 Register bits
    namespace rd_blk2_data4_bits {
        constexpr uint32_t ADC_CALIBRATION_1 = (32 << 0);  ///< Store the bit [22:53] of ADC calibration data.
    }

    /// RD_BLK2_DATA5 Register bits
    namespace rd_blk2_data5_bits {
        constexpr uint32_t ADC_CALIBRATION_2 = (32 << 0);  ///< Store the bit [54:85] of ADC calibration data.
    }

    /// RD_BLK2_DATA6 Register bits
    namespace rd_blk2_data6_bits {
        constexpr uint32_t ADC_CALIBRATION_3 = (11 << 0);  ///< Store the bit [86:96] of ADC calibration data.
        constexpr uint32_t BLK2_RESERVED_DATA_0 = (21 << 11);  ///< Store the bit [0:20] of block2 reserved data.
    }

    /// RD_BLK2_DATA7 Register bits
    namespace rd_blk2_data7_bits {
        constexpr uint32_t BLK2_RESERVED_DATA_1 = (32 << 0);  ///< Store the bit [21:52] of block2 reserved data.
    }

    /// RD_BLK3_DATA0 Register bits
    namespace rd_blk3_data0_bits {
        constexpr uint32_t BLK3_DATA0 = (32 << 0);  ///< Store the first 32-bit of Block3.
    }

    /// RD_BLK3_DATA1 Register bits
    namespace rd_blk3_data1_bits {
        constexpr uint32_t BLK3_DATA1 = (32 << 0);  ///< Store the second 32-bit of Block3.
    }

    /// RD_BLK3_DATA2 Register bits
    namespace rd_blk3_data2_bits {
        constexpr uint32_t BLK3_DATA2 = (32 << 0);  ///< Store the third 32-bit of Block3.
    }

    /// RD_BLK3_DATA3 Register bits
    namespace rd_blk3_data3_bits {
        constexpr uint32_t BLK3_DATA3 = (32 << 0);  ///< Store the fourth 32-bit of Block3.
    }

    /// RD_BLK3_DATA4 Register bits
    namespace rd_blk3_data4_bits {
        constexpr uint32_t BLK3_DATA4 = (32 << 0);  ///< Store the fifth 32-bit of Block3.
    }

    /// RD_BLK3_DATA5 Register bits
    namespace rd_blk3_data5_bits {
        constexpr uint32_t BLK3_DATA5 = (32 << 0);  ///< Store the sixth 32-bit of Block3.
    }

    /// RD_BLK3_DATA6 Register bits
    namespace rd_blk3_data6_bits {
        constexpr uint32_t BLK3_DATA6 = (32 << 0);  ///< Store the seventh 32-bit of Block3.
    }

    /// RD_BLK3_DATA7 Register bits
    namespace rd_blk3_data7_bits {
        constexpr uint32_t BLK3_DATA7 = (32 << 0);  ///< Store the eighth 32-bit of Block3.
    }

    /// RD_REPEAT_ERR Register bits
    namespace rd_repeat_err_bits {
        constexpr uint32_t RD_DIS_ERR = (2 << 0);  ///< If any bit in RD_DIS is 1, then it indicates a programming error.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 2);  ///< If any bit in WDT_DELAY_SEL is 1, then it indicates a programming error.
        constexpr uint32_t DIS_PAD_JTAG_ERR = (1U << 4);  ///< If any bit in DIS_PAD_JTAG is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE_ERR = (1U << 5);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 6);  ///< If any bit in DIS_DOWNLOAD_MANUAL_ENCRYPT is 1, then it indicates a programming error.
        constexpr uint32_t SPI_BOOT_ENCRYPT_DECRYPT_CNT_ERR = (3 << 7);  ///< If any bit in SPI_BOOT_ENCRYPT_DECRYPT_CNT is 1, then it indicates a programming error.
        constexpr uint32_t XTS_KEY_LENGTH_256_ERR = (1U << 10);  ///< If any bit in XTS_KEY_LENGTH_256 is 1, then it indicates a programming error.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 11);  ///< If any bit in UART_PRINT_CONTROL is 1, then it indicates a programming error.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 13);  ///< If any bit in FORCE_SEND_RESUME is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 14);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DIRECT_BOOT_ERR = (1U << 15);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 16);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 17);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 21);  ///< If any bit in this filed is 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED_ERR = (10 << 22);  ///< Reserved.
    }

    /// RD_RS_ERR Register bits
    namespace rd_rs_err_bits {
        constexpr uint32_t BLK1_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes in block1.
        constexpr uint32_t BLK1_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of block1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t BLK2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes in block2.
        constexpr uint32_t BLK2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of block2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t BLK3_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes in block3.
        constexpr uint32_t BLK3_FAIL = (1U << 11);  ///< 0: Means no failure and that the block3 data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EFUSE_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to force eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit and force to activate clock signal of eFuse SRAM.
        constexpr uint32_t EFUSE_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< Set this bit and force to enable clock signal of eFuse memory.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: Operate programming command 0x5AA5: Operate read command.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t BLK0_VALID_BIT_CNT = (6 << 10);  ///< Record the number of bit '1' in BLOCK0.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (2 << 2);  ///< The serial number of the block to be programmed. Value 0-3 corresponds to block number 0-3, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t THR_A = (8 << 0);  ///< Configures hold time for efuse read.
        constexpr uint32_t TRD = (8 << 8);  ///< Configures pulse time for efuse read.
        constexpr uint32_t TSUR_A = (8 << 16);  ///< Configures setup time for efuse read.
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the initial read time of eFuse.
    }

    /// WR_TIM_CONF0 Register bits
    namespace wr_tim_conf0_bits {
        constexpr uint32_t THP_A = (8 << 0);  ///< Configures hold time for efuse program.
        constexpr uint32_t TPGM_INACTIVE = (8 << 8);  ///< Configures pulse time for burning '0' bit.
        constexpr uint32_t TPGM = (16 << 16);  ///< Configures pulse time for burning '1' bit.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t TSUP_A = (8 << 0);  ///< Configures setup time for efuse program.
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores eFuse version.
    }

}

// ============================================================================
// EXTMEM Peripheral
// ============================================================================

namespace extmem {
    /// Base addresses
    constexpr uint32_t EXTMEM_BASE = 0x600C4000;

    /// EXTMEM Register structure
    struct Registers {
        volatile uint32_t ICACHE_CTRL;  ///< Offset: 0x00 - This description will be updated in the near future.
        volatile uint32_t ICACHE_CTRL1;  ///< Offset: 0x04 - This description will be updated in the near future.
        volatile uint32_t ICACHE_TAG_POWER_CTRL;  ///< Offset: 0x08 - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_CTRL;  ///< Offset: 0x28 - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_ADDR;  ///< Offset: 0x2C - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_SIZE;  ///< Offset: 0x30 - This description will be updated in the near future.
        volatile uint32_t IBUS_TO_FLASH_START_VADDR;  ///< Offset: 0x54 - This description will be updated in the near future.
        volatile uint32_t IBUS_TO_FLASH_END_VADDR;  ///< Offset: 0x58 - This description will be updated in the near future.
        volatile uint32_t DBUS_TO_FLASH_START_VADDR;  ///< Offset: 0x5C - This description will be updated in the near future.
        volatile uint32_t DBUS_TO_FLASH_END_VADDR;  ///< Offset: 0x60 - This description will be updated in the near future.
        volatile uint32_t CACHE_ACS_CNT_CLR;  ///< Offset: 0x64 - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_ENA;  ///< Offset: 0x78 - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_CLR;  ///< Offset: 0x7C - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_ST;  ///< Offset: 0x80 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_ENA;  ///< Offset: 0x84 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_CLR;  ///< Offset: 0x88 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_ST;  ///< Offset: 0x8C - This description will be updated in the near future.
        volatile uint32_t CORE0_DBUS_REJECT_ST;  ///< Offset: 0x90 - This description will be updated in the near future.
        volatile uint32_t CORE0_DBUS_REJECT_VADDR;  ///< Offset: 0x94 - This description will be updated in the near future.
        volatile uint32_t CORE0_IBUS_REJECT_ST;  ///< Offset: 0x98 - This description will be updated in the near future.
        volatile uint32_t CORE0_IBUS_REJECT_VADDR;  ///< Offset: 0x9C - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_FAULT_CONTENT;  ///< Offset: 0xA0 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_FAULT_VADDR;  ///< Offset: 0xA4 - This description will be updated in the near future.
        volatile uint32_t CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0xA8 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_POWER_CTRL;  ///< Offset: 0xAC - This description will be updated in the near future.
        volatile uint32_t CACHE_STATE;  ///< Offset: 0xB0 - This description will be updated in the near future.
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE;  ///< Offset: 0xB4 - This description will be updated in the near future.
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON;  ///< Offset: 0xB8 - This description will be updated in the near future.
        volatile uint32_t CACHE_PRELOAD_INT_CTRL;  ///< Offset: 0xBC - This description will be updated in the near future.
        volatile uint32_t CACHE_SYNC_INT_CTRL;  ///< Offset: 0xC0 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_OWNER;  ///< Offset: 0xC4 - This description will be updated in the near future.
        volatile uint32_t CACHE_CONF_MISC;  ///< Offset: 0xC8 - This description will be updated in the near future.
        volatile uint32_t ICACHE_FREEZE;  ///< Offset: 0xCC - This description will be updated in the near future.
        volatile uint32_t ICACHE_ATOMIC_OPERATE_ENA;  ///< Offset: 0xD0 - This description will be updated in the near future.
        volatile uint32_t CACHE_REQUEST;  ///< Offset: 0xD4 - This description will be updated in the near future.
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x100 - This description will be updated in the near future.
        volatile uint32_t REG_DATE;  ///< Offset: 0x3FC - This description will be updated in the near future.
    };

    /// Peripheral instances
    inline Registers* EXTMEM = reinterpret_cast<Registers*>(EXTMEM_BASE);

    // Bit definitions
    /// ICACHE_CTRL Register bits
    namespace icache_ctrl_bits {
        constexpr uint32_t ICACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
    }

    /// ICACHE_CTRL1 Register bits
    namespace icache_ctrl1_bits {
        constexpr uint32_t ICACHE_SHUT_IBUS = (1U << 0);  ///< The bit is used to disable core0 ibus, 0: enable, 1: disable
        constexpr uint32_t ICACHE_SHUT_DBUS = (1U << 1);  ///< The bit is used to disable core1 ibus, 0: enable, 1: disable
    }

    /// ICACHE_TAG_POWER_CTRL Register bits
    namespace icache_tag_power_ctrl_bits {
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of icache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power down
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power icache tag memory up, 0: follow rtc_lslp, 1: power up
    }

    /// ICACHE_SYNC_CTRL Register bits
    namespace icache_sync_ctrl_bits {
        constexpr uint32_t ICACHE_INVALIDATE_ENA = (1U << 0);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t ICACHE_SYNC_DONE = (1U << 1);  ///< The bit is used to indicate invalidate operation is finished.
    }

    /// ICACHE_SYNC_ADDR Register bits
    namespace icache_sync_addr_bits {
        constexpr uint32_t ICACHE_SYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for clean operations. It should be combined with ICACHE_SYNC_SIZE_REG.
    }

    /// ICACHE_SYNC_SIZE Register bits
    namespace icache_sync_size_bits {
        constexpr uint32_t ICACHE_SYNC_SIZE = (23 << 0);  ///< The bits are used to configure the length for sync operations. The bits are the counts of cache block. It should be combined with ICACHE_SYNC_ADDR_REG.
    }

    /// IBUS_TO_FLASH_START_VADDR Register bits
    namespace ibus_to_flash_start_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// IBUS_TO_FLASH_END_VADDR Register bits
    namespace ibus_to_flash_end_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// DBUS_TO_FLASH_START_VADDR Register bits
    namespace dbus_to_flash_start_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// DBUS_TO_FLASH_END_VADDR Register bits
    namespace dbus_to_flash_end_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// CACHE_ACS_CNT_CLR Register bits
    namespace cache_acs_cnt_clr_bits {
        constexpr uint32_t IBUS_ACS_CNT_CLR = (1U << 0);  ///< The bit is used to clear ibus counter.
        constexpr uint32_t DBUS_ACS_CNT_CLR = (1U << 1);  ///< The bit is used to clear dbus counter.
    }

    /// CACHE_ILG_INT_ENA Register bits
    namespace cache_ilg_int_ena_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by mmu entry fault.
        constexpr uint32_t IBUS_CNT_OVF_INT_ENA = (1U << 7);  ///< The bit is used to enable interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_CLR Register bits
    namespace cache_ilg_int_clr_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by mmu entry fault.
        constexpr uint32_t IBUS_CNT_OVF_INT_CLR = (1U << 7);  ///< The bit is used to clear interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_CLR = (1U << 8);  ///< The bit is used to clear interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_ST Register bits
    namespace cache_ilg_int_st_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_ST = (1U << 0);  ///< The bit is used to indicate interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_ST = (1U << 1);  ///< The bit is used to indicate interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_ST = (1U << 5);  ///< The bit is used to indicate interrupt by mmu entry fault.
        constexpr uint32_t IBUS_ACS_CNT_OVF_ST = (1U << 7);  ///< The bit is used to indicate interrupt by ibus access flash/spiram counter overflow.
        constexpr uint32_t IBUS_ACS_MISS_CNT_OVF_ST = (1U << 8);  ///< The bit is used to indicate interrupt by ibus access flash/spiram miss counter overflow.
        constexpr uint32_t DBUS_ACS_CNT_OVF_ST = (1U << 9);  ///< The bit is used to indicate interrupt by dbus access flash/spiram counter overflow.
        constexpr uint32_t DBUS_ACS_FLASH_MISS_CNT_OVF_ST = (1U << 10);  ///< The bit is used to indicate interrupt by dbus access flash miss counter overflow.
    }

    /// CORE0_ACS_CACHE_INT_ENA Register bits
    namespace core0_acs_cache_int_ena_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding ibus is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_IC_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding dbus is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_IC_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by dbus trying to write icache
    }

    /// CORE0_ACS_CACHE_INT_CLR Register bits
    namespace core0_acs_cache_int_clr_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_IC_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding dbus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_IC_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by dbus trying to write icache
    }

    /// CORE0_ACS_CACHE_INT_ST Register bits
    namespace core0_acs_cache_int_st_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_ICACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access icache while the core0_ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_ICACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_ST = (1U << 2);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_ICACHE_ST = (1U << 3);  ///< The bit is used to indicate interrupt by cpu access icache while the core0_dbus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_ST = (1U << 4);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_ICACHE_ST = (1U << 5);  ///< The bit is used to indicate interrupt by dbus trying to write icache
    }

    /// CORE0_DBUS_REJECT_ST Register bits
    namespace core0_dbus_reject_st_bits {
        constexpr uint32_t CORE0_DBUS_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of CPU access dbus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE0_DBUS_WORLD = (1U << 3);  ///< The bit is used to indicate the world of CPU access dbus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_DBUS_REJECT_VADDR Register bits
    namespace core0_dbus_reject_vaddr_bits {
        constexpr uint32_t CORE0_DBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access dbus when authentication fail.
    }

    /// CORE0_IBUS_REJECT_ST Register bits
    namespace core0_ibus_reject_st_bits {
        constexpr uint32_t CORE0_IBUS_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of CPU access ibus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able
        constexpr uint32_t CORE0_IBUS_WORLD = (1U << 3);  ///< The bit is used to indicate the world of CPU access ibus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_IBUS_REJECT_VADDR Register bits
    namespace core0_ibus_reject_vaddr_bits {
        constexpr uint32_t CORE0_IBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access ibus when authentication fail.
    }

    /// CACHE_MMU_FAULT_CONTENT Register bits
    namespace cache_mmu_fault_content_bits {
        constexpr uint32_t CACHE_MMU_FAULT_CONTENT = (8 << 0);  ///< The bits are used to indicate the content of mmu entry which cause mmu fault..
        constexpr uint32_t CACHE_MMU_FAULT_CODE = (4 << 10);  ///< The right-most 3 bits are used to indicate the operations which cause mmu fault occurrence. 0: default, 1: cpu miss, 2: preload miss, 3: writeback, 4: cpu miss evict recovery address, 5: load miss evict recovery address, 6: external dma tx, 7: external dma rx. The most significant bit is used to indicate this operation occurs in which one icache.
    }

    /// CACHE_MMU_FAULT_VADDR Register bits
    namespace cache_mmu_fault_vaddr_bits {
        constexpr uint32_t CACHE_MMU_FAULT_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address which cause mmu fault..
    }

    /// CACHE_WRAP_AROUND_CTRL Register bits
    namespace cache_wrap_around_ctrl_bits {
        constexpr uint32_t CACHE_FLASH_WRAP_AROUND = (1U << 0);  ///< The bit is used to enable wrap around mode when read data from flash.
    }

    /// CACHE_MMU_POWER_CTRL Register bits
    namespace cache_mmu_power_ctrl_bits {
        constexpr uint32_t CACHE_MMU_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to enable clock gating to save power when access mmu memory, 0: enable, 1: disable
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power down
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power up
    }

    /// CACHE_STATE Register bits
    namespace cache_state_bits {
        constexpr uint32_t ICACHE_STATE = (12 << 0);  ///< The bit is used to indicate whether icache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
    }

    /// CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE Register bits
    namespace cache_encrypt_decrypt_record_disable_bits {
        constexpr uint32_t RECORD_DISABLE_DB_ENCRYPT = (1U << 0);  ///< Reserved.
        constexpr uint32_t RECORD_DISABLE_G0CB_DECRYPT = (1U << 1);  ///< Reserved.
    }

    /// CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON Register bits
    namespace cache_encrypt_decrypt_clk_force_on_bits {
        constexpr uint32_t CLK_FORCE_ON_MANUAL_CRYPT = (1U << 0);  ///< The bit is used to close clock gating of manual crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_AUTO_CRYPT = (1U << 1);  ///< The bit is used to close clock gating of automatic crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_CRYPT = (1U << 2);  ///< The bit is used to close clock gating of external memory encrypt and decrypt clock. 1: close gating, 0: open clock gating.
    }

    /// CACHE_PRELOAD_INT_CTRL Register bits
    namespace cache_preload_int_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache pre-load done.
    }

    /// CACHE_SYNC_INT_CTRL Register bits
    namespace cache_sync_int_ctrl_bits {
        constexpr uint32_t ICACHE_SYNC_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache sync done.
    }

    /// CACHE_MMU_OWNER Register bits
    namespace cache_mmu_owner_bits {
        constexpr uint32_t CACHE_MMU_OWNER = (4 << 0);  ///< The bits are used to specify the owner of MMU.bit0/bit2: ibus, bit1/bit3: dbus
    }

    /// CACHE_CONF_MISC Register bits
    namespace cache_conf_misc_bits {
        constexpr uint32_t CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT = (1U << 0);  ///< The bit is used to disable checking mmu entry fault by preload operation.
        constexpr uint32_t CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT = (1U << 1);  ///< The bit is used to disable checking mmu entry fault by sync operation.
        constexpr uint32_t CACHE_TRACE_ENA = (1U << 2);  ///< The bit is used to enable cache trace function.
        constexpr uint32_t CACHE_MMU_PAGE_SIZE = (2 << 3);  ///< This bit is used to choose mmu page size. 2:64KB. 1. 32KB. 0: 16KB
    }

    /// ICACHE_FREEZE Register bits
    namespace icache_freeze_bits {
        constexpr uint32_t ENA = (1U << 0);  ///< The bit is used to enable icache freeze mode
        constexpr uint32_t MODE = (1U << 1);  ///< The bit is used to configure freeze mode, 0: assert busy if CPU miss 1: assert hit if CPU miss
        constexpr uint32_t DONE = (1U << 2);  ///< The bit is used to indicate icache freeze success
    }

    /// ICACHE_ATOMIC_OPERATE_ENA Register bits
    namespace icache_atomic_operate_ena_bits {
        constexpr uint32_t ICACHE_ATOMIC_OPERATE_ENA = (1U << 0);  ///< The bit is used to activate icache atomic operation protection. In this case, sync/lock operation can not interrupt miss-work. This feature does not work during invalidateAll operation.
    }

    /// CACHE_REQUEST Register bits
    namespace cache_request_bits {
        constexpr uint32_t BYPASS = (1U << 0);  ///< The bit is used to disable request recording which could cause performance issue
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock gate enable.
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version information
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x60004000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t BT_SELECT;  ///< Offset: 0x00 - GPIO bit select register
        volatile uint32_t OUT;  ///< Offset: 0x04 - GPIO output register
        volatile uint32_t OUT_W1TS;  ///< Offset: 0x08 - GPIO output set register
        volatile uint32_t OUT_W1TC;  ///< Offset: 0x0C - GPIO output clear register
        volatile uint32_t SDIO_SELECT;  ///< Offset: 0x1C - GPIO sdio select register
        volatile uint32_t ENABLE;  ///< Offset: 0x20 - GPIO output enable register
        volatile uint32_t ENABLE_W1TS;  ///< Offset: 0x24 - GPIO output enable set register
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x28 - GPIO output enable clear register
        volatile uint32_t STRAP;  ///< Offset: 0x38 - pad strapping register
        volatile uint32_t IN;  ///< Offset: 0x3C - GPIO input register
        volatile uint32_t STATUS;  ///< Offset: 0x44 - GPIO interrupt status register
        volatile uint32_t STATUS_W1TS;  ///< Offset: 0x48 - GPIO interrupt status set register
        volatile uint32_t STATUS_W1TC;  ///< Offset: 0x4C - GPIO interrupt status clear register
        volatile uint32_t PCPU_INT;  ///< Offset: 0x5C - GPIO PRO_CPU interrupt status register
        volatile uint32_t PCPU_NMI_INT;  ///< Offset: 0x60 - GPIO PRO_CPU(not shielded) interrupt status register
        volatile uint32_t CPUSDIO_INT;  ///< Offset: 0x64 - GPIO CPUSDIO interrupt status register
        volatile uint32_t PIN;  ///< Offset: 0x74 - GPIO pin configuration register (renamed from PIN)
        volatile uint32_t STATUS_NEXT;  ///< Offset: 0x14C - GPIO interrupt source register
        volatile uint32_t FUNC_IN_SEL_CFG;  ///< Offset: 0x154 - GPIO input function configuration register (renamed from FUNC_IN_SEL_CFG)
        volatile uint32_t FUNC_OUT_SEL_CFG;  ///< Offset: 0x554 - GPIO output function select register (renamed from FUNC_OUT_SEL_CFG)
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x62C - GPIO clock gate register
        volatile uint32_t REG_DATE;  ///< Offset: 0x6FC - GPIO version register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);

    // Bit definitions
    /// BT_SELECT Register bits
    namespace bt_select_bits {
        constexpr uint32_t BT_SEL = (32 << 0);  ///< GPIO bit select register
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t DATA_ORIG = (25 << 0);  ///< GPIO output register for GPIO0-24
    }

    /// OUT_W1TS Register bits
    namespace out_w1ts_bits {
        constexpr uint32_t OUT_W1TS = (25 << 0);  ///< GPIO output set register for GPIO0-24
    }

    /// OUT_W1TC Register bits
    namespace out_w1tc_bits {
        constexpr uint32_t OUT_W1TC = (25 << 0);  ///< GPIO output clear register for GPIO0-24
    }

    /// SDIO_SELECT Register bits
    namespace sdio_select_bits {
        constexpr uint32_t SDIO_SEL = (8 << 0);  ///< GPIO sdio select register
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t DATA = (25 << 0);  ///< GPIO output enable register for GPIO0-24
    }

    /// ENABLE_W1TS Register bits
    namespace enable_w1ts_bits {
        constexpr uint32_t ENABLE_W1TS = (25 << 0);  ///< GPIO output enable set register for GPIO0-24
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (25 << 0);  ///< GPIO output enable clear register for GPIO0-24
    }

    /// STRAP Register bits
    namespace strap_bits {
        constexpr uint32_t STRAPPING = (16 << 0);  ///< pad strapping register
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t DATA_NEXT = (25 << 0);  ///< GPIO input register for GPIO0-24
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INTERRUPT = (25 << 0);  ///< GPIO interrupt status register for GPIO0-24
    }

    /// STATUS_W1TS Register bits
    namespace status_w1ts_bits {
        constexpr uint32_t STATUS_W1TS = (25 << 0);  ///< GPIO interrupt status set register for GPIO0-24
    }

    /// STATUS_W1TC Register bits
    namespace status_w1tc_bits {
        constexpr uint32_t STATUS_W1TC = (25 << 0);  ///< GPIO interrupt status clear register for GPIO0-24
    }

    /// PCPU_INT Register bits
    namespace pcpu_int_bits {
        constexpr uint32_t PROCPU_INT = (25 << 0);  ///< GPIO PRO_CPU interrupt status register for GPIO0-24
    }

    /// PCPU_NMI_INT Register bits
    namespace pcpu_nmi_int_bits {
        constexpr uint32_t PROCPU_NMI_INT = (25 << 0);  ///< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-24
    }

    /// CPUSDIO_INT Register bits
    namespace cpusdio_int_bits {
        constexpr uint32_t SDIO_INT = (25 << 0);  ///< GPIO CPUSDIO interrupt status register for GPIO0-24
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t SYNC2_BYPASS = (2 << 0);  ///< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< set this bit to select pad driver. 1:open-drain. 0:normal.
        constexpr uint32_t SYNC1_BYPASS = (2 << 3);  ///< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t INT_TYPE = (3 << 7);  ///< set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
        constexpr uint32_t WAKEUP_ENABLE = (1U << 10);  ///< set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
        constexpr uint32_t CONFIG = (2 << 11);  ///< reserved
        constexpr uint32_t INT_ENA = (5 << 13);  ///< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
    }

    /// STATUS_NEXT Register bits
    namespace status_next_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT = (26 << 0);  ///< GPIO interrupt source register for GPIO0-24
    }

    /// FUNC_IN_SEL_CFG Register bits
    namespace func_in_sel_cfg_bits {
        constexpr uint32_t IN_SEL = (5 << 0);  ///< set this value: s=0-53: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
        constexpr uint32_t IN_INV_SEL = (1U << 5);  ///< set this bit to invert input signal. 1:invert. 0:not invert.
        constexpr uint32_t SEL = (1U << 6);  ///< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
    }

    /// FUNC_OUT_SEL_CFG Register bits
    namespace func_out_sel_cfg_bits {
        constexpr uint32_t OUT_SEL = (8 << 0);  ///< The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-255: output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals GPIO_OUT_REG[n].
        constexpr uint32_t INV_SEL = (1U << 8);  ///< set this bit to invert output signal.1:invert.0:not invert.
        constexpr uint32_t OEN_SEL = (1U << 9);  ///< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
        constexpr uint32_t OEN_INV_SEL = (1U << 10);  ///< set this bit to invert output enable signal.1:invert.0:not invert.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable GPIO clock gate
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x60013000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - Configures the low level width of the SCL Clock
        volatile uint32_t CTR;  ///< Offset: 0x04 - Transmission setting
        volatile uint32_t SR;  ///< Offset: 0x08 - Describe I2C work status.
        volatile uint32_t TO;  ///< Offset: 0x0C - Setting time out control for receiving data.
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - FIFO status register.
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - FIFO configuration register.
        volatile uint32_t DATA;  ///< Offset: 0x1C - Rx FIFO read data.
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Interrupt clear bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Interrupt enable bits
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - Status of captured I2C communication events
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - Configures the hold time after a negative SCL edge.
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - Configures the sample time after a positive SCL edge.
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - Configures the high level width of SCL
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - Configures the delay between the SDA and SCL negative...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - Configures the delay between the positive edge of SCL...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - Configures the delay after the SCL clock edge for a stop...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - Configures the delay between the SDA and SCL positive...
        volatile uint32_t FILTER_CFG;  ///< Offset: 0x50 - SCL and SDA filter configuration register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x54 - I2C CLK configuration register
        volatile uint32_t COMD;  ///< Offset: 0x58 - I2C command register %s (renamed from COMD)
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x78 - SCL status time out register
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x7C - SCL main status time out register
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0x80 - Power configuration register
        volatile uint32_t DATE;  ///< Offset: 0xF8 - Version register
        volatile uint32_t TXFIFO_START_ADDR;  ///< Offset: 0x100 - I2C TXFIFO base address register
        volatile uint32_t RXFIFO_START_ADDR;  ///< Offset: 0x180 - I2C RXFIFO base address register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 0: direct output, 1: open drain output.
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 0: direct output, 1: open drain output.
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< This register is used to select the sample mode. 1: sample SDA data on the SCL low level. 0: sample SDA data on the SCL high level.
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        constexpr uint32_t MS_MODE = (1U << 4);  ///< Set this bit to configure the module as an I2C Master. Clear this bit to configure the module as an I2C Slave.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending the data in txfifo.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit, 0: send data from the most significant bit.
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received data. 1: receive data from the least significant bit, 0: receive data from the most significant bit.
        constexpr uint32_t CLK_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< This is the enable bit for arbitration_lost.
        constexpr uint32_t FSM_RST = (1U << 10);  ///< This register is used to reset the scl FMS.
        constexpr uint32_t CONF_UPGATE = (1U << 11);  ///< synchronization bit
        constexpr uint32_t SLV_TX_AUTO_START_EN = (1U << 12);  ///< This is the enable bit for slave to send data automatically
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< When the I2C controller loses control of SCL line, this register changes to 1.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
        constexpr uint32_t RXFIFO_CNT = (5 << 8);  ///< This field represents the amount of data needed to be sent.
        constexpr uint32_t TXFIFO_CNT = (5 << 18);  ///< This field stores the amount of received data in RAM.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This field indicates the states of the state machine used to produce SCL. 0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (5 << 0);  ///< This register is used to configure the timeout for receiving a data bit in APB clock cycles.
        constexpr uint32_t TIME_OUT_EN = (1U << 5);  ///< This is the enable bit for time out control.
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_RADDR = (4 << 0);  ///< This is the offset address of the APB reading from rxfifo
        constexpr uint32_t RXFIFO_WADDR = (4 << 5);  ///< This is the offset address of i2c module receiving data and writing to rxfifo.
        constexpr uint32_t TXFIFO_RADDR = (4 << 10);  ///< This is the offset address of i2c module reading from txfifo.
        constexpr uint32_t TXFIFO_WADDR = (4 << 15);  ///< This is the offset address of APB bus writing to txfifo.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (4 << 0);  ///< The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[3:0], reg_rxfifo_wm_int_raw bit will be valid.
        constexpr uint32_t TXFIFO_WM_THRHD = (4 << 5);  ///< The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[3:0], reg_txfifo_wm_int_raw bit will be valid.
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enable APB nonfifo access.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset rx-fifo.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset tx-fifo.
        constexpr uint32_t FIFO_PRT_EN = (1U << 14);  ///< The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The value of rx FIFO read data.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< Set this bit to clear I2C_DET_START_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< The interrupt enable bit for I2C_DET_START_INT interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2C_DET_START_INT interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time to hold the data after the negative edge of SCL, in I2C module clock cycles.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL setup to high level and remains high in master mode, in I2C module clock cycles.
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (7 << 9);  ///< This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the negative edge of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the delay after the STOP condition, in I2C module clock cycles.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the positive edge of SDA, in I2C module clock cycles.
    }

    /// FILTER_CFG Register bits
    namespace filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< When a pulse on the SCL input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SDA_FILTER_THRES = (4 << 4);  ///< When a pulse on the SDA input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 8);  ///< This is the filter enable bit for SCL.
        constexpr uint32_t SDA_FILTER_EN = (1U << 9);  ///< This is the filter enable bit for SDA.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_NUM = (8 << 0);  ///< the integral part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_A = (6 << 8);  ///< the numerator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_B = (6 << 14);  ///< the denominator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
        constexpr uint32_t SCLK_ACTIVE = (1U << 21);  ///< The clock switch for i2c module
    }

    /// COMD Register bits
    namespace comd_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< When command 0 is done in I2C Master mode, this bit changes to high level.
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_FSM state unchanged period. It should be o more than 23
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the the version register.
    }

    /// TXFIFO_START_ADDR Register bits
    namespace txfifo_start_addr_bits {
        constexpr uint32_t TXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C txfifo first address.
    }

    /// RXFIFO_START_ADDR Register bits
    namespace rxfifo_start_addr_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C rxfifo first address.
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x600C2000;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t MAC_INTR_MAP;  ///< Offset: 0x00 - register description
        volatile uint32_t WIFI_MAC_NMI_MAP;  ///< Offset: 0x04 - register description
        volatile uint32_t WIFI_PWR_INT_MAP;  ///< Offset: 0x08 - register description
        volatile uint32_t WIFI_BB_INT_MAP;  ///< Offset: 0x0C - register description
        volatile uint32_t BT_MAC_INT_MAP;  ///< Offset: 0x10 - register description
        volatile uint32_t BT_BB_INT_MAP;  ///< Offset: 0x14 - register description
        volatile uint32_t BT_BB_NMI_MAP;  ///< Offset: 0x18 - register description
        volatile uint32_t LP_TIMER_INT_MAP;  ///< Offset: 0x1C - register description
        volatile uint32_t COEX_INT_MAP;  ///< Offset: 0x20 - register description
        volatile uint32_t BLE_TIMER_INT_MAP;  ///< Offset: 0x24 - register description
        volatile uint32_t BLE_SEC_INT_MAP;  ///< Offset: 0x28 - register description
        volatile uint32_t I2C_MST_INT_MAP;  ///< Offset: 0x2C - register description
        volatile uint32_t APB_CTRL_INTR_MAP;  ///< Offset: 0x30 - register description
        volatile uint32_t GPIO_INTERRUPT_PRO_MAP;  ///< Offset: 0x34 - register description
        volatile uint32_t GPIO_INTERRUPT_PRO_NMI_MAP;  ///< Offset: 0x38 - register description
        volatile uint32_t SPI_INTR_1_MAP;  ///< Offset: 0x3C - register description
        volatile uint32_t SPI_INTR_2_MAP;  ///< Offset: 0x40 - register description
        volatile uint32_t UART_INTR_MAP;  ///< Offset: 0x44 - register description
        volatile uint32_t UART1_INTR_MAP;  ///< Offset: 0x48 - register description
        volatile uint32_t LEDC_INT_MAP;  ///< Offset: 0x4C - register description
        volatile uint32_t EFUSE_INT_MAP;  ///< Offset: 0x50 - register description
        volatile uint32_t RTC_CORE_INTR_MAP;  ///< Offset: 0x54 - register description
        volatile uint32_t I2C_EXT0_INTR_MAP;  ///< Offset: 0x58 - register description
        volatile uint32_t TG_T0_INT_MAP;  ///< Offset: 0x5C - register description
        volatile uint32_t TG_WDT_INT_MAP;  ///< Offset: 0x60 - register description
        volatile uint32_t CACHE_IA_INT_MAP;  ///< Offset: 0x64 - register description
        volatile uint32_t SYSTIMER_TARGET0_INT_MAP;  ///< Offset: 0x68 - register description
        volatile uint32_t SYSTIMER_TARGET1_INT_MAP;  ///< Offset: 0x6C - register description
        volatile uint32_t SYSTIMER_TARGET2_INT_MAP;  ///< Offset: 0x70 - register description
        volatile uint32_t SPI_MEM_REJECT_INTR_MAP;  ///< Offset: 0x74 - register description
        volatile uint32_t ICACHE_PRELOAD_INT_MAP;  ///< Offset: 0x78 - register description
        volatile uint32_t ICACHE_SYNC_INT_MAP;  ///< Offset: 0x7C - register description
        volatile uint32_t APB_ADC_INT_MAP;  ///< Offset: 0x80 - register description
        volatile uint32_t DMA_CH0_INT_MAP;  ///< Offset: 0x84 - register description
        volatile uint32_t SHA_INT_MAP;  ///< Offset: 0x88 - register description
        volatile uint32_t ECC_INT_MAP;  ///< Offset: 0x8C - register description
        volatile uint32_t CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x90 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x94 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x98 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x9C - register description
        volatile uint32_t ASSIST_DEBUG_INTR_MAP;  ///< Offset: 0xA0 - register description
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;  ///< Offset: 0xA4 - register description
        volatile uint32_t CACHE_CORE0_ACS_INT_MAP;  ///< Offset: 0xA8 - register description
        volatile uint32_t INTR_STATUS_REG_0;  ///< Offset: 0xAC - register description
        volatile uint32_t INTR_STATUS_REG_1;  ///< Offset: 0xB0 - register description
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xB4 - register description
        volatile uint32_t CPU_INT_ENABLE;  ///< Offset: 0xB8 - register description
        volatile uint32_t CPU_INT_TYPE;  ///< Offset: 0xBC - register description
        volatile uint32_t CPU_INT_CLEAR;  ///< Offset: 0xC0 - register description
        volatile uint32_t CPU_INT_EIP_STATUS;  ///< Offset: 0xC4 - register description
        volatile uint32_t CPU_INT_PRI_0;  ///< Offset: 0xC8 - register description
        volatile uint32_t CPU_INT_PRI_1;  ///< Offset: 0xCC - register description
        volatile uint32_t CPU_INT_PRI_2;  ///< Offset: 0xD0 - register description
        volatile uint32_t CPU_INT_PRI_3;  ///< Offset: 0xD4 - register description
        volatile uint32_t CPU_INT_PRI_4;  ///< Offset: 0xD8 - register description
        volatile uint32_t CPU_INT_PRI_5;  ///< Offset: 0xDC - register description
        volatile uint32_t CPU_INT_PRI_6;  ///< Offset: 0xE0 - register description
        volatile uint32_t CPU_INT_PRI_7;  ///< Offset: 0xE4 - register description
        volatile uint32_t CPU_INT_PRI_8;  ///< Offset: 0xE8 - register description
        volatile uint32_t CPU_INT_PRI_9;  ///< Offset: 0xEC - register description
        volatile uint32_t CPU_INT_PRI_10;  ///< Offset: 0xF0 - register description
        volatile uint32_t CPU_INT_PRI_11;  ///< Offset: 0xF4 - register description
        volatile uint32_t CPU_INT_PRI_12;  ///< Offset: 0xF8 - register description
        volatile uint32_t CPU_INT_PRI_13;  ///< Offset: 0xFC - register description
        volatile uint32_t CPU_INT_PRI_14;  ///< Offset: 0x100 - register description
        volatile uint32_t CPU_INT_PRI_15;  ///< Offset: 0x104 - register description
        volatile uint32_t CPU_INT_PRI_16;  ///< Offset: 0x108 - register description
        volatile uint32_t CPU_INT_PRI_17;  ///< Offset: 0x10C - register description
        volatile uint32_t CPU_INT_PRI_18;  ///< Offset: 0x110 - register description
        volatile uint32_t CPU_INT_PRI_19;  ///< Offset: 0x114 - register description
        volatile uint32_t CPU_INT_PRI_20;  ///< Offset: 0x118 - register description
        volatile uint32_t CPU_INT_PRI_21;  ///< Offset: 0x11C - register description
        volatile uint32_t CPU_INT_PRI_22;  ///< Offset: 0x120 - register description
        volatile uint32_t CPU_INT_PRI_23;  ///< Offset: 0x124 - register description
        volatile uint32_t CPU_INT_PRI_24;  ///< Offset: 0x128 - register description
        volatile uint32_t CPU_INT_PRI_25;  ///< Offset: 0x12C - register description
        volatile uint32_t CPU_INT_PRI_26;  ///< Offset: 0x130 - register description
        volatile uint32_t CPU_INT_PRI_27;  ///< Offset: 0x134 - register description
        volatile uint32_t CPU_INT_PRI_28;  ///< Offset: 0x138 - register description
        volatile uint32_t CPU_INT_PRI_29;  ///< Offset: 0x13C - register description
        volatile uint32_t CPU_INT_PRI_30;  ///< Offset: 0x140 - register description
        volatile uint32_t CPU_INT_PRI_31;  ///< Offset: 0x144 - register description
        volatile uint32_t CPU_INT_THRESH;  ///< Offset: 0x148 - register description
        volatile uint32_t INTERRUPT_REG_DATE;  ///< Offset: 0x7FC - register description
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);

    // Bit definitions
    /// MAC_INTR_MAP Register bits
    namespace mac_intr_map_bits {
        constexpr uint32_t WIFI_MAC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// WIFI_MAC_NMI_MAP Register bits
    namespace wifi_mac_nmi_map_bits {
        constexpr uint32_t WIFI_MAC_NMI_MAP = (5 << 0);  ///< Need add description
    }

    /// WIFI_PWR_INT_MAP Register bits
    namespace wifi_pwr_int_map_bits {
        constexpr uint32_t WIFI_PWR_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// WIFI_BB_INT_MAP Register bits
    namespace wifi_bb_int_map_bits {
        constexpr uint32_t WIFI_BB_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// BT_MAC_INT_MAP Register bits
    namespace bt_mac_int_map_bits {
        constexpr uint32_t BT_MAC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// BT_BB_INT_MAP Register bits
    namespace bt_bb_int_map_bits {
        constexpr uint32_t BT_BB_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// BT_BB_NMI_MAP Register bits
    namespace bt_bb_nmi_map_bits {
        constexpr uint32_t BT_BB_NMI_MAP = (5 << 0);  ///< Need add description
    }

    /// LP_TIMER_INT_MAP Register bits
    namespace lp_timer_int_map_bits {
        constexpr uint32_t LP_TIMER_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// COEX_INT_MAP Register bits
    namespace coex_int_map_bits {
        constexpr uint32_t COEX_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// BLE_TIMER_INT_MAP Register bits
    namespace ble_timer_int_map_bits {
        constexpr uint32_t BLE_TIMER_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// BLE_SEC_INT_MAP Register bits
    namespace ble_sec_int_map_bits {
        constexpr uint32_t BLE_SEC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// I2C_MST_INT_MAP Register bits
    namespace i2c_mst_int_map_bits {
        constexpr uint32_t I2C_MST_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// APB_CTRL_INTR_MAP Register bits
    namespace apb_ctrl_intr_map_bits {
        constexpr uint32_t APB_CTRL_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// GPIO_INTERRUPT_PRO_MAP Register bits
    namespace gpio_interrupt_pro_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< Need add description
    }

    /// GPIO_INTERRUPT_PRO_NMI_MAP Register bits
    namespace gpio_interrupt_pro_nmi_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< Need add description
    }

    /// SPI_INTR_1_MAP Register bits
    namespace spi_intr_1_map_bits {
        constexpr uint32_t SPI_INTR_1_MAP = (5 << 0);  ///< Need add description
    }

    /// SPI_INTR_2_MAP Register bits
    namespace spi_intr_2_map_bits {
        constexpr uint32_t SPI_INTR_2_MAP = (5 << 0);  ///< Need add description
    }

    /// UART_INTR_MAP Register bits
    namespace uart_intr_map_bits {
        constexpr uint32_t UART_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// UART1_INTR_MAP Register bits
    namespace uart1_intr_map_bits {
        constexpr uint32_t UART1_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// LEDC_INT_MAP Register bits
    namespace ledc_int_map_bits {
        constexpr uint32_t LEDC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// EFUSE_INT_MAP Register bits
    namespace efuse_int_map_bits {
        constexpr uint32_t EFUSE_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// RTC_CORE_INTR_MAP Register bits
    namespace rtc_core_intr_map_bits {
        constexpr uint32_t RTC_CORE_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// I2C_EXT0_INTR_MAP Register bits
    namespace i2c_ext0_intr_map_bits {
        constexpr uint32_t I2C_EXT0_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// TG_T0_INT_MAP Register bits
    namespace tg_t0_int_map_bits {
        constexpr uint32_t TG_T0_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// TG_WDT_INT_MAP Register bits
    namespace tg_wdt_int_map_bits {
        constexpr uint32_t TG_WDT_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// CACHE_IA_INT_MAP Register bits
    namespace cache_ia_int_map_bits {
        constexpr uint32_t CACHE_IA_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// SYSTIMER_TARGET0_INT_MAP Register bits
    namespace systimer_target0_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET0_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// SYSTIMER_TARGET1_INT_MAP Register bits
    namespace systimer_target1_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET1_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// SYSTIMER_TARGET2_INT_MAP Register bits
    namespace systimer_target2_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET2_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// SPI_MEM_REJECT_INTR_MAP Register bits
    namespace spi_mem_reject_intr_map_bits {
        constexpr uint32_t SPI_MEM_REJECT_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// ICACHE_PRELOAD_INT_MAP Register bits
    namespace icache_preload_int_map_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// ICACHE_SYNC_INT_MAP Register bits
    namespace icache_sync_int_map_bits {
        constexpr uint32_t ICACHE_SYNC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// APB_ADC_INT_MAP Register bits
    namespace apb_adc_int_map_bits {
        constexpr uint32_t APB_ADC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// DMA_CH0_INT_MAP Register bits
    namespace dma_ch0_int_map_bits {
        constexpr uint32_t DMA_CH0_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// SHA_INT_MAP Register bits
    namespace sha_int_map_bits {
        constexpr uint32_t SHA_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// ECC_INT_MAP Register bits
    namespace ecc_int_map_bits {
        constexpr uint32_t ECC_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< Need add description
    }

    /// ASSIST_DEBUG_INTR_MAP Register bits
    namespace assist_debug_intr_map_bits {
        constexpr uint32_t ASSIST_DEBUG_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP Register bits
    namespace core_0_pif_pms_monitor_violate_size_intr_map_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP = (5 << 0);  ///< Need add description
    }

    /// CACHE_CORE0_ACS_INT_MAP Register bits
    namespace cache_core0_acs_int_map_bits {
        constexpr uint32_t CACHE_CORE0_ACS_INT_MAP = (5 << 0);  ///< Need add description
    }

    /// INTR_STATUS_REG_0 Register bits
    namespace intr_status_reg_0_bits {
        constexpr uint32_t INTR_STATUS_0 = (32 << 0);  ///< Need add description
    }

    /// INTR_STATUS_REG_1 Register bits
    namespace intr_status_reg_1_bits {
        constexpr uint32_t INTR_STATUS_1 = (32 << 0);  ///< Need add description
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< Need add description
    }

    /// CPU_INT_ENABLE Register bits
    namespace cpu_int_enable_bits {
        constexpr uint32_t CPU_INT_ENABLE = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_TYPE Register bits
    namespace cpu_int_type_bits {
        constexpr uint32_t CPU_INT_TYPE = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_CLEAR Register bits
    namespace cpu_int_clear_bits {
        constexpr uint32_t CPU_INT_CLEAR = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_EIP_STATUS Register bits
    namespace cpu_int_eip_status_bits {
        constexpr uint32_t CPU_INT_EIP_STATUS = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_0 Register bits
    namespace cpu_int_pri_0_bits {
        constexpr uint32_t CPU_PRI_0_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_1 Register bits
    namespace cpu_int_pri_1_bits {
        constexpr uint32_t CPU_PRI_1_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_2 Register bits
    namespace cpu_int_pri_2_bits {
        constexpr uint32_t CPU_PRI_2_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_3 Register bits
    namespace cpu_int_pri_3_bits {
        constexpr uint32_t CPU_PRI_3_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_4 Register bits
    namespace cpu_int_pri_4_bits {
        constexpr uint32_t CPU_PRI_4_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_5 Register bits
    namespace cpu_int_pri_5_bits {
        constexpr uint32_t CPU_PRI_5_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_6 Register bits
    namespace cpu_int_pri_6_bits {
        constexpr uint32_t CPU_PRI_6_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_7 Register bits
    namespace cpu_int_pri_7_bits {
        constexpr uint32_t CPU_PRI_7_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_8 Register bits
    namespace cpu_int_pri_8_bits {
        constexpr uint32_t CPU_PRI_8_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_9 Register bits
    namespace cpu_int_pri_9_bits {
        constexpr uint32_t CPU_PRI_9_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_10 Register bits
    namespace cpu_int_pri_10_bits {
        constexpr uint32_t CPU_PRI_10_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_11 Register bits
    namespace cpu_int_pri_11_bits {
        constexpr uint32_t CPU_PRI_11_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_12 Register bits
    namespace cpu_int_pri_12_bits {
        constexpr uint32_t CPU_PRI_12_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_13 Register bits
    namespace cpu_int_pri_13_bits {
        constexpr uint32_t CPU_PRI_13_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_14 Register bits
    namespace cpu_int_pri_14_bits {
        constexpr uint32_t CPU_PRI_14_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_15 Register bits
    namespace cpu_int_pri_15_bits {
        constexpr uint32_t CPU_PRI_15_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_16 Register bits
    namespace cpu_int_pri_16_bits {
        constexpr uint32_t CPU_PRI_16_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_17 Register bits
    namespace cpu_int_pri_17_bits {
        constexpr uint32_t CPU_PRI_17_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_18 Register bits
    namespace cpu_int_pri_18_bits {
        constexpr uint32_t CPU_PRI_18_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_19 Register bits
    namespace cpu_int_pri_19_bits {
        constexpr uint32_t CPU_PRI_19_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_20 Register bits
    namespace cpu_int_pri_20_bits {
        constexpr uint32_t CPU_PRI_20_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_21 Register bits
    namespace cpu_int_pri_21_bits {
        constexpr uint32_t CPU_PRI_21_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_22 Register bits
    namespace cpu_int_pri_22_bits {
        constexpr uint32_t CPU_PRI_22_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_23 Register bits
    namespace cpu_int_pri_23_bits {
        constexpr uint32_t CPU_PRI_23_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_24 Register bits
    namespace cpu_int_pri_24_bits {
        constexpr uint32_t CPU_PRI_24_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_25 Register bits
    namespace cpu_int_pri_25_bits {
        constexpr uint32_t CPU_PRI_25_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_26 Register bits
    namespace cpu_int_pri_26_bits {
        constexpr uint32_t CPU_PRI_26_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_27 Register bits
    namespace cpu_int_pri_27_bits {
        constexpr uint32_t CPU_PRI_27_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_28 Register bits
    namespace cpu_int_pri_28_bits {
        constexpr uint32_t CPU_PRI_28_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_29 Register bits
    namespace cpu_int_pri_29_bits {
        constexpr uint32_t CPU_PRI_29_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_30 Register bits
    namespace cpu_int_pri_30_bits {
        constexpr uint32_t CPU_PRI_30_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_31 Register bits
    namespace cpu_int_pri_31_bits {
        constexpr uint32_t CPU_PRI_31_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_THRESH Register bits
    namespace cpu_int_thresh_bits {
        constexpr uint32_t CPU_INT_THRESH = (4 << 0);  ///< Need add description
    }

    /// INTERRUPT_REG_DATE Register bits
    namespace interrupt_reg_date_bits {
        constexpr uint32_t INTERRUPT_REG_DATE = (28 << 0);  ///< Need add description
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x60009000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - Clock Output Configuration Register
        volatile uint32_t GPIO;  ///< Offset: 0x04 - IO MUX Configure Register for pad XTAL_32K_P (renamed from GPIO)
        volatile uint32_t DATE;  ///< Offset: 0xFC - IO MUX Version Control Register
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t CLK_OUT1 = (4 << 0);  ///< If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT2 = (4 << 4);  ///< If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT3 = (4 << 8);  ///< If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
    }

    /// GPIO Register bits
    namespace gpio_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function 2; etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x60019000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH_CONF0;  ///< Offset: 0x00 - Configuration register 0 for channel %s (renamed from CH_CONF0)
        volatile uint32_t CH_HPOINT;  ///< Offset: 0x04 - High point register for channel %s (renamed from CH_HPOINT)
        volatile uint32_t CH_DUTY;  ///< Offset: 0x08 - Initial duty cycle for channel %s (renamed from CH_DUTY)
        volatile uint32_t CH_CONF1;  ///< Offset: 0x0C - Configuration register 1 for channel %s (renamed from CH_CONF1)
        volatile uint32_t CH_DUTY_R;  ///< Offset: 0x10 - Current duty cycle for channel %s (renamed from CH_DUTY_R)
        volatile uint32_t TIMER_CONF;  ///< Offset: 0xA0 - Timer %s configuration (renamed from TIMER_CONF)
        volatile uint32_t TIMER_VALUE;  ///< Offset: 0xA4 - Timer %s current counter value (renamed from TIMER_VALUE)
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear bits
        volatile uint32_t CONF;  ///< Offset: 0xD0 - Global ledc configuration register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);

    // Bit definitions
    /// CH_CONF0 Register bits
    namespace ch_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< This field is used to select one of timers for channel %s. 0: select timer0; 1: select timer1; 2: select timer2; 3: select timer3
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< Set this bit to enable signal output on channel %s.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
        constexpr uint32_t PARA_UP = (1U << 4);  ///< This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
        constexpr uint32_t OVF_NUM = (10 << 5);  ///< This register is used to configure the maximum times of overflow minus 1. The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
        constexpr uint32_t OVF_CNT_EN = (1U << 15);  ///< This bit is used to enable the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET = (1U << 16);  ///< Set this bit to reset the ovf_cnt of channel %s.
    }

    /// CH_HPOINT Register bits
    namespace ch_hpoint_bits {
        constexpr uint32_t HPOINT = (14 << 0);  ///< The output value changes to high when the selected timers has reached the value specified by this register.
    }

    /// CH_DUTY Register bits
    namespace ch_duty_bits {
        constexpr uint32_t DUTY = (19 << 0);  ///< This register is used to change the output duty by controlling the Lpoint. The output value turns to low when the selected timers has reached the Lpoint.
    }

    /// CH_CONF1 Register bits
    namespace ch_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< This register is used to configure the changing step scale of duty on channel %s.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< The duty will change every LEDC_DUTY_CYCLE_CH%s on channel %s.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< This register is used to control the number of times the duty cycle will be changed.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase; 0: Decrease.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
    }

    /// CH_DUTY_R Register bits
    namespace ch_duty_r_bits {
        constexpr uint32_t DUTY_CH0_R = (19 << 0);  ///< This register stores the current duty of output signal on channel %s.
    }

    /// TIMER_CONF Register bits
    namespace timer_conf_bits {
        constexpr uint32_t DUTY_RES = (4 << 0);  ///< This register is used to control the range of the counter in timer %s.
        constexpr uint32_t CLK_DIV = (18 << 4);  ///< This register is used to configure the divisor for the divider in timer %s. The least significant eight bits represent the fractional part.
        constexpr uint32_t PAUSE = (1U << 22);  ///< This bit is used to suspend the counter in timer %s.
        constexpr uint32_t RST = (1U << 23);  ///< This bit is used to reset timer %s. The counter will show 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 24);  ///< This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate. 1'h0: SLOW_CLK 1'h1: REF_TICK
        constexpr uint32_t PARA_UP = (1U << 25);  ///< Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
    }

    /// TIMER_VALUE Register bits
    namespace timer_value_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< This register stores the current counter value of timer %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t OVF_INT_RAW = (1U << 0);  ///< Triggered when the timer0 has reached its maximum counter value.
        constexpr uint32_t TIMER1_OVF_INT_RAW = (1U << 1);  ///< Triggered when the timer1 has reached its maximum counter value.
        constexpr uint32_t TIMER2_OVF_INT_RAW = (1U << 2);  ///< Triggered when the timer2 has reached its maximum counter value.
        constexpr uint32_t TIMER3_OVF_INT_RAW = (1U << 3);  ///< Triggered when the timer3 has reached its maximum counter value.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_RAW = (1U << 4);  ///< Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_RAW = (1U << 5);  ///< Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_RAW = (1U << 6);  ///< Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_RAW = (1U << 7);  ///< Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_RAW = (1U << 8);  ///< Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_RAW = (1U << 9);  ///< Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
        constexpr uint32_t OVF_CNT_CH0_INT_RAW = (1U << 10);  ///< Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
        constexpr uint32_t OVF_CNT_CH1_INT_RAW = (1U << 11);  ///< Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
        constexpr uint32_t OVF_CNT_CH2_INT_RAW = (1U << 12);  ///< Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
        constexpr uint32_t OVF_CNT_CH3_INT_RAW = (1U << 13);  ///< Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
        constexpr uint32_t OVF_CNT_CH4_INT_RAW = (1U << 14);  ///< Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
        constexpr uint32_t OVF_CNT_CH5_INT_RAW = (1U << 15);  ///< Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t OVF_INT_ST = (1U << 0);  ///< This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER1_OVF_INT_ST = (1U << 1);  ///< This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER2_OVF_INT_ST = (1U << 2);  ///< This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER3_OVF_INT_ST = (1U << 3);  ///< This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ST = (1U << 4);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ST = (1U << 5);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ST = (1U << 6);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ST = (1U << 7);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ST = (1U << 8);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ST = (1U << 9);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENAIS set to 1.
        constexpr uint32_t OVF_CNT_CH0_INT_ST = (1U << 10);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH1_INT_ST = (1U << 11);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH2_INT_ST = (1U << 12);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH3_INT_ST = (1U << 13);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH4_INT_ST = (1U << 14);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH5_INT_ST = (1U << 15);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t OVF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t OVF_INT_CLR = (1U << 0);  ///< Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_CLR = (1U << 1);  ///< Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_CLR = (1U << 3);  ///< Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_CLR = (1U << 4);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_CLR = (1U << 5);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_CLR = (1U << 6);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_CLR = (1U << 7);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_CLR = (1U << 8);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_CLR = (1U << 9);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_CLR = (1U << 10);  ///< Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_CLR = (1U << 11);  ///< Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_CLR = (1U << 12);  ///< Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_CLR = (1U << 13);  ///< Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_CLR = (1U << 14);  ///< Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_CLR = (1U << 15);  ///< Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< This bit is used to select clock source for the 4 timers . 2'd1: APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK
        constexpr uint32_t CLK_EN = (1U << 31);  ///< This bit is used to control clock. 1'b1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LEDC_DATE = (32 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// MODEM Peripheral
// ============================================================================

namespace modem {
    /// Base addresses
    constexpr uint32_t MODEM_CLKRST_BASE = 0x6004D800;

    /// MODEM Register structure
    struct Registers {
        volatile uint32_t CLK_CONF;  ///< Offset: 0x00 - .
        volatile uint32_t MODEM_LP_TIMER_CONF;  ///< Offset: 0x04 - .
        volatile uint32_t COEX_LP_CLK_CONF;  ///< Offset: 0x08 - .
        volatile uint32_t BLE_TIMER_CLK_CONF;  ///< Offset: 0x0C - .
        volatile uint32_t DATE;  ///< Offset: 0x0C - .
        volatile uint32_t ETM_CLK_CONF;  ///< Offset: 0x10 - .
    };

    /// Peripheral instances
    inline Registers* MODEM_CLKRST = reinterpret_cast<Registers*>(MODEM_CLKRST_BASE);

    // Bit definitions
    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< .
    }

    /// MODEM_LP_TIMER_CONF Register bits
    namespace modem_lp_timer_conf_bits {
        constexpr uint32_t LP_TIMER_SEL_RTC_SLOW = (1U << 0);  ///< .
        constexpr uint32_t LP_TIMER_SEL_8M = (1U << 1);  ///< .
        constexpr uint32_t LP_TIMER_SEL_XTAL = (1U << 2);  ///< .
        constexpr uint32_t LP_TIMER_SEL_XTAL32K = (1U << 3);  ///< .
        constexpr uint32_t LP_TIMER_CLK_DIV_NUM = (8 << 4);  ///< .
    }

    /// COEX_LP_CLK_CONF Register bits
    namespace coex_lp_clk_conf_bits {
        constexpr uint32_t COEX_LPCLK_SEL_RTC_SLOW = (1U << 0);  ///< .
        constexpr uint32_t COEX_LPCLK_SEL_8M = (1U << 1);  ///< .
        constexpr uint32_t COEX_LPCLK_SEL_XTAL = (1U << 2);  ///< .
        constexpr uint32_t COEX_LPCLK_SEL_XTAL32K = (1U << 3);  ///< .
        constexpr uint32_t COEX_LPCLK_DIV_NUM = (8 << 4);  ///< .
    }

    /// BLE_TIMER_CLK_CONF Register bits
    namespace ble_timer_clk_conf_bits {
        constexpr uint32_t BLETIMER_USE_XTAL = (1U << 0);  ///< .
        constexpr uint32_t BLETIMER_CLK_IS_ACTIVE = (1U << 1);  ///< .
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< .
    }

    /// ETM_CLK_CONF Register bits
    namespace etm_clk_conf_bits {
        constexpr uint32_t ETM_CLK_SEL = (1U << 0);  ///< .
        constexpr uint32_t ETM_CLK_ACTIVE = (1U << 1);  ///< .
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x60026000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0xB0 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_CNTL_BASE = 0x60008000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t OPTIONS0;  ///< Offset: 0x00 - register description
        volatile uint32_t SLP_TIMER0;  ///< Offset: 0x04 - register description
        volatile uint32_t SLP_TIMER1;  ///< Offset: 0x08 - register description
        volatile uint32_t TIME_UPDATE;  ///< Offset: 0x0C - register description
        volatile uint32_t TIME_LOW0;  ///< Offset: 0x10 - register description
        volatile uint32_t TIME_HIGH0;  ///< Offset: 0x14 - register description
        volatile uint32_t STATE0;  ///< Offset: 0x18 - register description
        volatile uint32_t TIMER1;  ///< Offset: 0x1C - register description
        volatile uint32_t TIMER2;  ///< Offset: 0x20 - register description
        volatile uint32_t TIMER4;  ///< Offset: 0x24 - register description
        volatile uint32_t TIMER5;  ///< Offset: 0x28 - register description
        volatile uint32_t ANA_CONF;  ///< Offset: 0x2C - register description
        volatile uint32_t RESET_STATE;  ///< Offset: 0x30 - register description
        volatile uint32_t WAKEUP_STATE;  ///< Offset: 0x34 - register description
        volatile uint32_t INT_ENA_RTC;  ///< Offset: 0x38 - register description
        volatile uint32_t INT_RAW_RTC;  ///< Offset: 0x3C - register description
        volatile uint32_t INT_ST_RTC;  ///< Offset: 0x40 - register description
        volatile uint32_t INT_CLR_RTC;  ///< Offset: 0x44 - register description
        volatile uint32_t STORE0;  ///< Offset: 0x48 - register description
        volatile uint32_t STORE1;  ///< Offset: 0x4C - register description
        volatile uint32_t STORE2;  ///< Offset: 0x50 - register description
        volatile uint32_t STORE3;  ///< Offset: 0x54 - register description
        volatile uint32_t EXT_XTL_CONF;  ///< Offset: 0x58 - register description
        volatile uint32_t EXT_WAKEUP_CONF;  ///< Offset: 0x5C - register description
        volatile uint32_t SLP_REJECT_CONF;  ///< Offset: 0x60 - register description
        volatile uint32_t CPU_PERIOD_CONF;  ///< Offset: 0x64 - register description
        volatile uint32_t CLK_CONF;  ///< Offset: 0x68 - register description
        volatile uint32_t SLOW_CLK_CONF;  ///< Offset: 0x6C - register description
        volatile uint32_t BIAS_CONF;  ///< Offset: 0x70 - register description
        volatile uint32_t RTC_CNTL;  ///< Offset: 0x74 - register description
        volatile uint32_t PWC;  ///< Offset: 0x78 - register description
        volatile uint32_t DIG_PWC;  ///< Offset: 0x7C - register description
        volatile uint32_t DIG_ISO;  ///< Offset: 0x80 - register description
        volatile uint32_t WDTCONFIG0;  ///< Offset: 0x84 - register description
        volatile uint32_t WDTCONFIG1;  ///< Offset: 0x88 - register description
        volatile uint32_t WDTCONFIG2;  ///< Offset: 0x8C - register description
        volatile uint32_t WDTCONFIG3;  ///< Offset: 0x90 - register description
        volatile uint32_t WDTCONFIG4;  ///< Offset: 0x94 - register description
        volatile uint32_t WDTFEED;  ///< Offset: 0x98 - register description
        volatile uint32_t WDTWPROTECT;  ///< Offset: 0x9C - register description
        volatile uint32_t SWD_CONF;  ///< Offset: 0xA0 - register description
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0xA4 - register description
        volatile uint32_t SW_CPU_STALL;  ///< Offset: 0xA8 - register description
        volatile uint32_t STORE4;  ///< Offset: 0xAC - register description
        volatile uint32_t STORE5;  ///< Offset: 0xB0 - register description
        volatile uint32_t STORE6;  ///< Offset: 0xB4 - register description
        volatile uint32_t STORE7;  ///< Offset: 0xB8 - register description
        volatile uint32_t LOW_POWER_ST;  ///< Offset: 0xBC - register description
        volatile uint32_t DIAG0;  ///< Offset: 0xC0 - register description
        volatile uint32_t PAD_HOLD;  ///< Offset: 0xC4 - register description
        volatile uint32_t DIG_PAD_HOLD;  ///< Offset: 0xC8 - register description
        volatile uint32_t BROWN_OUT;  ///< Offset: 0xCC - register description
        volatile uint32_t TIME_LOW1;  ///< Offset: 0xD0 - register description
        volatile uint32_t TIME_HIGH1;  ///< Offset: 0xD4 - register description
        volatile uint32_t USB_CONF;  ///< Offset: 0xD8 - register description
        volatile uint32_t SLP_REJECT_CAUSE;  ///< Offset: 0xDC - register description
        volatile uint32_t OPTION1;  ///< Offset: 0xE0 - register description
        volatile uint32_t SLP_WAKEUP_CAUSE;  ///< Offset: 0xE4 - register description
        volatile uint32_t ULP_CP_TIMER_1;  ///< Offset: 0xE8 - register description
        volatile uint32_t INT_ENA_RTC_W1TS;  ///< Offset: 0xEC - register description
        volatile uint32_t INT_ENA_RTC_W1TC;  ///< Offset: 0xF0 - register description
        volatile uint32_t CNTL_RETENTION_CTRL;  ///< Offset: 0xF4 - register description
        volatile uint32_t FIB_SEL;  ///< Offset: 0xF8 - register description
        volatile uint32_t CNTL_GPIO_WAKEUP;  ///< Offset: 0xFC - register description
        volatile uint32_t CNTL_DBG_SEL;  ///< Offset: 0x100 - register description
        volatile uint32_t CNTL_DBG_MAP;  ///< Offset: 0x104 - register description
        volatile uint32_t CNTL_SENSOR_CTRL;  ///< Offset: 0x108 - register description
        volatile uint32_t CNTL_DBG_SAR_SEL;  ///< Offset: 0x10C - register description
        volatile uint32_t CNTL_DATE;  ///< Offset: 0x1FC - register description
    };

    /// Peripheral instances
    inline Registers* RTC_CNTL = reinterpret_cast<Registers*>(RTC_CNTL_BASE);

    // Bit definitions
    /// OPTIONS0 Register bits
    namespace options0_bits {
        constexpr uint32_t SW_STALL_PROCPU_C0 = (2 << 2);  ///< {reg_sw_stall_procpu_c1[5:0], reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall PRO CPU
        constexpr uint32_t SW_PROCPU_RST = (1U << 5);  ///< PRO CPU SW reset
        constexpr uint32_t BB_I2C_FORCE_PD = (1U << 6);  ///< BB_I2C force power down
        constexpr uint32_t BB_I2C_FORCE_PU = (1U << 7);  ///< BB_I2C force power up
        constexpr uint32_t BBPLL_I2C_FORCE_PD = (1U << 8);  ///< BB_PLL _I2C force power down
        constexpr uint32_t BBPLL_I2C_FORCE_PU = (1U << 9);  ///< BB_PLL_I2C force power up
        constexpr uint32_t BBPLL_FORCE_PD = (1U << 10);  ///< BB_PLL force power down
        constexpr uint32_t BBPLL_FORCE_PU = (1U << 11);  ///< BB_PLL force power up
        constexpr uint32_t XTL_FORCE_PD = (1U << 12);  ///< crystall force power down
        constexpr uint32_t XTL_FORCE_PU = (1U << 13);  ///< crystall force power up
        constexpr uint32_t XTL_EN_WAIT = (4 << 14);  ///< wait bias_sleep and current source wakeup
        constexpr uint32_t XTL_EXT_CTR_SEL = (3 << 20);  ///< Need add desc
        constexpr uint32_t ANALOG_FORCE_ISO = (1U << 25);  ///< Need add desc
        constexpr uint32_t ANALOG_FORCE_NOISO = (1U << 28);  ///< Need add desc
        constexpr uint32_t DG_WRAP_FORCE_RST = (1U << 29);  ///< digital wrap force reset in deep sleep
        constexpr uint32_t DG_WRAP_FORCE_NORST = (1U << 30);  ///< digital core force no reset in deep sleep
        constexpr uint32_t SW_SYS_RST = (1U << 31);  ///< SW system reset
    }

    /// SLP_TIMER0 Register bits
    namespace slp_timer0_bits {
        constexpr uint32_t SLP_VAL_LO = (32 << 0);  ///< Need add desc
    }

    /// SLP_TIMER1 Register bits
    namespace slp_timer1_bits {
        constexpr uint32_t SLP_VAL_HI = (16 << 0);  ///< RTC sleep timer high 16 bits
        constexpr uint32_t MAIN_TIMER_ALARM_EN = (1U << 16);  ///< timer alarm enable bit
    }

    /// TIME_UPDATE Register bits
    namespace time_update_bits {
        constexpr uint32_t TIMER_SYS_STALL = (1U << 27);  ///< Enable to record system stall time
        constexpr uint32_t TIMER_XTL_OFF = (1U << 28);  ///< Enable to record 40M XTAL OFF time
        constexpr uint32_t TIMER_SYS_RST = (1U << 29);  ///< enable to record system reset time
        constexpr uint32_t TIME_UPDATE = (1U << 31);  ///< Set 1: to update register with RTC timer
    }

    /// TIME_LOW0 Register bits
    namespace time_low0_bits {
        constexpr uint32_t TIMER_VALUE0_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH0 Register bits
    namespace time_high0_bits {
        constexpr uint32_t TIMER_VALUE0_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t SW_CPU_INT = (1U << 0);  ///< rtc software interrupt to main cpu
        constexpr uint32_t SLP_REJECT_CAUSE_CLR = (1U << 1);  ///< clear rtc sleep reject cause
        constexpr uint32_t APB2RTC_BRIDGE_SEL = (1U << 22);  ///< 1: APB to RTC using bridge
        constexpr uint32_t SDIO_ACTIVE_IND = (1U << 28);  ///< SDIO active indication
        constexpr uint32_t SLP_WAKEUP = (1U << 29);  ///< leep wakeup bit
        constexpr uint32_t SLP_REJECT = (1U << 30);  ///< leep reject bit
        constexpr uint32_t SLEEP_EN = (1U << 31);  ///< sleep enable bit
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t CPU_STALL_EN = (1U << 0);  ///< CPU stall enable bit
        constexpr uint32_t CPU_STALL_WAIT = (5 << 1);  ///< CPU stall wait cycles in fast_clk_rtc
        constexpr uint32_t CK8M_WAIT = (8 << 6);  ///< CK8M wait cycles in slow_clk_rtc
        constexpr uint32_t XTL_BUF_WAIT = (10 << 14);  ///< XTAL wait cycles in slow_clk_rtc
        constexpr uint32_t PLL_BUF_WAIT = (8 << 24);  ///< PLL wait cycles in slow_clk_rtc
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t MIN_TIME_CK8M_OFF = (8 << 24);  ///< minimal cycles in slow_clk_rtc for CK8M in power down state
    }

    /// TIMER4 Register bits
    namespace timer4_bits {
        constexpr uint32_t DG_WRAP_WAIT_TIMER = (9 << 16);  ///< Need add desc
        constexpr uint32_t DG_WRAP_POWERUP_TIMER = (7 << 25);  ///< Need add desc
    }

    /// TIMER5 Register bits
    namespace timer5_bits {
        constexpr uint32_t MIN_SLP_VAL = (8 << 8);  ///< minimal sleep cycles in slow_clk_rtc
    }

    /// ANA_CONF Register bits
    namespace ana_conf_bits {
        constexpr uint32_t I2C_RESET_POR_FORCE_PD = (1U << 18);  ///< Need add desc
        constexpr uint32_t I2C_RESET_POR_FORCE_PU = (1U << 19);  ///< Need add desc
        constexpr uint32_t SAR_I2C_PU = (1U << 22);  ///< PLLA force power up
        constexpr uint32_t BBPLL_CAL_SLP_START = (1U << 25);  ///< start BBPLL calibration during sleep
        constexpr uint32_t TXRF_I2C_PU = (1U << 27);  ///< 1: TXRF_I2C power up
        constexpr uint32_t RFRX_PBUS_PU = (1U << 28);  ///< 1: RFRX_PBUS power up
        constexpr uint32_t CKGEN_I2C_PU = (1U << 30);  ///< 1: CKGEN_I2C power up
        constexpr uint32_t PLL_I2C_PU = (1U << 31);  ///< Need add desc
        constexpr uint32_t PLLA_FORCE_PD = (1U << 23);  ///< PLLA force power down
        constexpr uint32_t PLLA_FORCE_PU = (1U << 24);  ///< PLLA force power up
    }

    /// RESET_STATE Register bits
    namespace reset_state_bits {
        constexpr uint32_t RESET_CAUSE_PROCPU = (6 << 0);  ///< reset cause of PRO CPU
        constexpr uint32_t STAT_VECTOR_SEL_PROCPU = (1U << 13);  ///< PRO CPU state vector sel
        constexpr uint32_t OCD_HALT_ON_RESET_PROCPU = (1U << 19);  ///< PROCPU OcdHaltOnReset
        constexpr uint32_t DRESET_MASK_PROCPU = (1U << 20);  ///< Need add desc
    }

    /// WAKEUP_STATE Register bits
    namespace wakeup_state_bits {
        constexpr uint32_t WAKEUP_ENA = (17 << 15);  ///< wakeup enable bitmap
    }

    /// INT_ENA_RTC Register bits
    namespace int_ena_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t WDT_INT_ENA = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SWD_INT_ENA = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t BBPLL_CAL_INT_ENA = (1U << 20);  ///< Need add desc
    }

    /// INT_RAW_RTC Register bits
    namespace int_raw_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_RAW = (1U << 0);  ///< sleep wakeup interrupt raw
        constexpr uint32_t SLP_REJECT_INT_RAW = (1U << 1);  ///< sleep reject interrupt raw
        constexpr uint32_t WDT_INT_RAW = (1U << 3);  ///< RTC WDT interrupt raw
        constexpr uint32_t BROWN_OUT_INT_RAW = (1U << 9);  ///< brown out interrupt raw
        constexpr uint32_t MAIN_TIMER_INT_RAW = (1U << 10);  ///< RTC main timer interrupt raw
        constexpr uint32_t SWD_INT_RAW = (1U << 15);  ///< super watch dog interrupt raw
        constexpr uint32_t BBPLL_CAL_INT_RAW = (1U << 20);  ///< Need add desc
    }

    /// INT_ST_RTC Register bits
    namespace int_st_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ST = (1U << 0);  ///< sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_ST = (1U << 1);  ///< sleep reject interrupt state
        constexpr uint32_t WDT_INT_ST = (1U << 3);  ///< RTC WDT interrupt state
        constexpr uint32_t BROWN_OUT_INT_ST = (1U << 9);  ///< brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_ST = (1U << 10);  ///< RTC main timer interrupt state
        constexpr uint32_t SWD_INT_ST = (1U << 15);  ///< super watch dog interrupt state
        constexpr uint32_t BBPLL_CAL_INT_ST = (1U << 20);  ///< Need add desc
    }

    /// INT_CLR_RTC Register bits
    namespace int_clr_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_CLR = (1U << 0);  ///< Clear sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_CLR = (1U << 1);  ///< Clear sleep reject interrupt state
        constexpr uint32_t WDT_INT_CLR = (1U << 3);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t BROWN_OUT_INT_CLR = (1U << 9);  ///< Clear brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_CLR = (1U << 10);  ///< Clear RTC main timer interrupt state
        constexpr uint32_t SWD_INT_CLR = (1U << 15);  ///< Clear super watch dog interrupt state
        constexpr uint32_t BBPLL_CAL_INT_CLR = (1U << 20);  ///< Need add desc
    }

    /// STORE0 Register bits
    namespace store0_bits {
        constexpr uint32_t SCRATCH0 = (32 << 0);  ///< Need add desc
    }

    /// STORE1 Register bits
    namespace store1_bits {
        constexpr uint32_t SCRATCH1 = (32 << 0);  ///< Need add desc
    }

    /// STORE2 Register bits
    namespace store2_bits {
        constexpr uint32_t SCRATCH2 = (32 << 0);  ///< Need add desc
    }

    /// STORE3 Register bits
    namespace store3_bits {
        constexpr uint32_t SCRATCH3 = (32 << 0);  ///< Need add desc
    }

    /// EXT_XTL_CONF Register bits
    namespace ext_xtl_conf_bits {
        constexpr uint32_t XTL_EXT_CTR_LV = (1U << 30);  ///< 0: power down XTAL at high level
        constexpr uint32_t XTL_EXT_CTR_EN = (1U << 31);  ///< Need add desc
    }

    /// EXT_WAKEUP_CONF Register bits
    namespace ext_wakeup_conf_bits {
        constexpr uint32_t GPIO_WAKEUP_FILTER = (1U << 31);  ///< enable filter for gpio wakeup event
    }

    /// SLP_REJECT_CONF Register bits
    namespace slp_reject_conf_bits {
        constexpr uint32_t SLEEP_REJECT_ENA = (18 << 12);  ///< sleep reject enable
        constexpr uint32_t LIGHT_SLP_REJECT_EN = (1U << 30);  ///< enable reject for light sleep
        constexpr uint32_t DEEP_SLP_REJECT_EN = (1U << 31);  ///< enable reject for deep sleep
    }

    /// CPU_PERIOD_CONF Register bits
    namespace cpu_period_conf_bits {
        constexpr uint32_t CPUSEL_CONF = (1U << 29);  ///< CPU sel option
        constexpr uint32_t CPUPERIOD_SEL = (2 << 30);  ///< Need add desc
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t EFUSE_CLK_FORCE_GATING = (1U << 1);  ///< Need add desc
        constexpr uint32_t EFUSE_CLK_FORCE_NOGATING = (1U << 2);  ///< Need add desc
        constexpr uint32_t CK8M_DIV_SEL_VLD = (1U << 3);  ///< used to sync reg_ck8m_div_sel bus. Clear vld before set reg_ck8m_div_sel
        constexpr uint32_t CK8M_DIV = (2 << 4);  ///< CK8M_D256_OUT divider. 00: div128
        constexpr uint32_t ENB_CK8M = (1U << 6);  ///< disable CK8M and CK8M_D256_OUT
        constexpr uint32_t ENB_CK8M_DIV = (1U << 7);  ///< 1: CK8M_D256_OUT is actually CK8M
        constexpr uint32_t DIG_XTAL32K_EN = (1U << 8);  ///< enable CK_XTAL_32K for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_D256_EN = (1U << 9);  ///< enable CK8M_D256_OUT for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_EN = (1U << 10);  ///< enable CK8M for digital core (no relationship with RTC core)
        constexpr uint32_t CK8M_DIV_SEL = (3 << 12);  ///< divider = reg_ck8m_div_sel + 1
        constexpr uint32_t XTAL_FORCE_NOGATING = (1U << 15);  ///< XTAL force no gating during sleep
        constexpr uint32_t CK8M_FORCE_NOGATING = (1U << 16);  ///< CK8M force no gating during sleep
        constexpr uint32_t CK8M_DFREQ = (8 << 17);  ///< CK8M_DFREQ
        constexpr uint32_t CK8M_FORCE_PD = (1U << 25);  ///< CK8M force power down
        constexpr uint32_t CK8M_FORCE_PU = (1U << 26);  ///< CK8M force power up
        constexpr uint32_t XTAL_GLOBAL_FORCE_GATING = (1U << 27);  ///< Need add desc
        constexpr uint32_t XTAL_GLOBAL_FORCE_NOGATING = (1U << 28);  ///< Need add desc
        constexpr uint32_t FAST_CLK_RTC_SEL = (1U << 29);  ///< fast_clk_rtc sel. 0: XTAL div 4
        constexpr uint32_t ANA_CLK_RTC_SEL = (2 << 30);  ///< Need add desc
    }

    /// SLOW_CLK_CONF Register bits
    namespace slow_clk_conf_bits {
        constexpr uint32_t ANA_CLK_DIV_VLD = (1U << 22);  ///< used to sync div bus. clear vld before set reg_rtc_ana_clk_div
        constexpr uint32_t ANA_CLK_DIV = (8 << 23);  ///< Need add desc
        constexpr uint32_t SLOW_CLK_NEXT_EDGE = (1U << 31);  ///< Need add desc
    }

    /// BIAS_CONF Register bits
    namespace bias_conf_bits {
        constexpr uint32_t DG_VDD_DRV_B_SLP = (8 << 0);  ///< Need add desc
        constexpr uint32_t DG_VDD_DRV_B_SLP_EN = (1U << 8);  ///< Need add desc
        constexpr uint32_t BIAS_BUF_IDLE = (1U << 10);  ///< Need add desc
        constexpr uint32_t BIAS_BUF_WAKE = (1U << 11);  ///< Need add desc
        constexpr uint32_t BIAS_BUF_DEEP_SLP = (1U << 12);  ///< Need add desc
        constexpr uint32_t BIAS_BUF_MONITOR = (1U << 13);  ///< Need add desc
        constexpr uint32_t PD_CUR_DEEP_SLP = (1U << 14);  ///< xpd cur when rtc in sleep_state
        constexpr uint32_t PD_CUR_MONITOR = (1U << 15);  ///< xpd cur when rtc in monitor state
        constexpr uint32_t BIAS_SLEEP_DEEP_SLP = (1U << 16);  ///< bias_sleep when rtc in sleep_state
        constexpr uint32_t BIAS_SLEEP_MONITOR = (1U << 17);  ///< bias_sleep when rtc in monitor state
        constexpr uint32_t DBG_ATTEN_DEEP_SLP = (4 << 18);  ///< DBG_ATTEN when rtc in sleep state
        constexpr uint32_t DBG_ATTEN_MONITOR = (4 << 22);  ///< DBG_ATTEN when rtc in active state
        constexpr uint32_t DBG_ATTEN_ACTIVE = (4 << 26);  ///< Need add desc
    }

    /// RTC_CNTL Register bits
    namespace rtc_cntl_bits {
        constexpr uint32_t DIG_REG_CAL_EN = (1U << 7);  ///< Need add desc
        constexpr uint32_t SCK_DCAP = (8 << 14);  ///< SCK_DCAP
        constexpr uint32_t REGULATOR_FORCE_PD = (1U << 30);  ///< RTC_REG force power down (for RTC_REG power down means decrease the voltage to 0.8v or lower )
        constexpr uint32_t REGULATOR_FORCE_PU = (1U << 31);  ///< Need add desc
    }

    /// PWC Register bits
    namespace pwc_bits {
        constexpr uint32_t PAD_FORCE_HOLD = (1U << 21);  ///< rtc pad force hold
    }

    /// DIG_PWC Register bits
    namespace dig_pwc_bits {
        constexpr uint32_t VDD_SPI_PWR_DRV = (2 << 0);  ///< Need add desc
        constexpr uint32_t VDD_SPI_PWR_FORCE = (1U << 2);  ///< Need add desc
        constexpr uint32_t VDD_SPI_PD_EN = (1U << 3);  ///< Need add desc
        constexpr uint32_t LSLP_MEM_FORCE_PD = (1U << 4);  ///< memories in digital core force PD in sleep
        constexpr uint32_t LSLP_MEM_FORCE_PU = (1U << 5);  ///< memories in digital core force no PD in sleep
        constexpr uint32_t DG_WRAP_FORCE_PD = (1U << 19);  ///< digital core force power down
        constexpr uint32_t DG_WRAP_FORCE_PU = (1U << 20);  ///< digital core force power up
        constexpr uint32_t DG_WRAP_PD_EN = (1U << 31);  ///< Need add desc
    }

    /// DIG_ISO Register bits
    namespace dig_iso_bits {
        constexpr uint32_t FORCE_OFF = (1U << 7);  ///< Need add desc
        constexpr uint32_t FORCE_ON = (1U << 8);  ///< Need add desc
        constexpr uint32_t DG_PAD_AUTOHOLD = (1U << 9);  ///< read only register to indicate digital pad auto-hold status
        constexpr uint32_t CLR_DG_PAD_AUTOHOLD = (1U << 10);  ///< wtite only register to clear digital pad auto-hold
        constexpr uint32_t DG_PAD_AUTOHOLD_EN = (1U << 11);  ///< digital pad enable auto-hold
        constexpr uint32_t DG_PAD_FORCE_NOISO = (1U << 12);  ///< digital pad force no ISO
        constexpr uint32_t DG_PAD_FORCE_ISO = (1U << 13);  ///< digital pad force ISO
        constexpr uint32_t DG_PAD_FORCE_UNHOLD = (1U << 14);  ///< digital pad force un-hold
        constexpr uint32_t DG_PAD_FORCE_HOLD = (1U << 15);  ///< digital pad force hold
        constexpr uint32_t DG_WRAP_FORCE_ISO = (1U << 30);  ///< digital core force ISO
        constexpr uint32_t DG_WRAP_FORCE_NOISO = (1U << 31);  ///< Need add desc
    }

    /// WDTCONFIG0 Register bits
    namespace wdtconfig0_bits {
        constexpr uint32_t WDT_CHIP_RESET_WIDTH = (8 << 0);  ///< chip reset siginal pulse width
        constexpr uint32_t WDT_CHIP_RESET_EN = (1U << 8);  ///< wdt reset whole chip enable
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< pause WDT in sleep
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< enable WDT reset PRO CPU
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< enable WDT in flash boot
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< system reset counter length
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< CPU reset counter length
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_EN = (1U << 31);  ///< Need add desc
    }

    /// WDTCONFIG1 Register bits
    namespace wdtconfig1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< Need add desc
    }

    /// WDTCONFIG2 Register bits
    namespace wdtconfig2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< Need add desc
    }

    /// WDTCONFIG3 Register bits
    namespace wdtconfig3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< Need add desc
    }

    /// WDTCONFIG4 Register bits
    namespace wdtconfig4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< Need add desc
    }

    /// WDTFEED Register bits
    namespace wdtfeed_bits {
        constexpr uint32_t WDT_FEED = (1U << 31);  ///< Need add desc
    }

    /// WDTWPROTECT Register bits
    namespace wdtwprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< Need add desc
    }

    /// SWD_CONF Register bits
    namespace swd_conf_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< swd reset flag
        constexpr uint32_t SWD_FEED_INT = (1U << 1);  ///< swd interrupt for feeding
        constexpr uint32_t SWD_BYPASS_RST = (1U << 17);  ///< Need add desc
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 18);  ///< adjust signal width send to swd
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 28);  ///< reset swd reset flag
        constexpr uint32_t SWD_FEED = (1U << 29);  ///< Sw feed swd
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< disabel SWD
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 31);  ///< automatically feed swd when int comes
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< Need add desc
    }

    /// SW_CPU_STALL Register bits
    namespace sw_cpu_stall_bits {
        constexpr uint32_t SW_STALL_PROCPU_C1 = (6 << 26);  ///< Need add desc
    }

    /// STORE4 Register bits
    namespace store4_bits {
        constexpr uint32_t SCRATCH4 = (32 << 0);  ///< Need add desc
    }

    /// STORE5 Register bits
    namespace store5_bits {
        constexpr uint32_t SCRATCH5 = (32 << 0);  ///< Need add desc
    }

    /// STORE6 Register bits
    namespace store6_bits {
        constexpr uint32_t SCRATCH6 = (32 << 0);  ///< Need add desc
    }

    /// STORE7 Register bits
    namespace store7_bits {
        constexpr uint32_t SCRATCH7 = (32 << 0);  ///< Need add desc
    }

    /// LOW_POWER_ST Register bits
    namespace low_power_st_bits {
        constexpr uint32_t XPD_DIG = (1U << 8);  ///< digital wrap power down
        constexpr uint32_t TOUCH_STATE_START = (1U << 9);  ///< touch should start to work
        constexpr uint32_t TOUCH_STATE_SWITCH = (1U << 10);  ///< touch is about to working. Switch rtc main state
        constexpr uint32_t TOUCH_STATE_SLP = (1U << 11);  ///< touch is in sleep state
        constexpr uint32_t TOUCH_STATE_DONE = (1U << 12);  ///< touch is done
        constexpr uint32_t COCPU_STATE_START = (1U << 13);  ///< ulp/cocpu should start to work
        constexpr uint32_t COCPU_STATE_SWITCH = (1U << 14);  ///< ulp/cocpu is about to working. Switch rtc main state
        constexpr uint32_t COCPU_STATE_SLP = (1U << 15);  ///< ulp/cocpu is in sleep state
        constexpr uint32_t COCPU_STATE_DONE = (1U << 16);  ///< ulp/cocpu is done
        constexpr uint32_t MAIN_STATE_XTAL_ISO = (1U << 17);  ///< no use any more
        constexpr uint32_t MAIN_STATE_PLL_ON = (1U << 18);  ///< rtc main state machine is in states that pll should be running
        constexpr uint32_t RDY_FOR_WAKEUP = (1U << 19);  ///< rtc is ready to receive wake up trigger from wake up source
        constexpr uint32_t MAIN_STATE_WAIT_END = (1U << 20);  ///< rtc main state machine has been waited for some cycles
        constexpr uint32_t IN_WAKEUP_STATE = (1U << 21);  ///< rtc main state machine is in the states of wakeup process
        constexpr uint32_t IN_LOW_POWER_STATE = (1U << 22);  ///< rtc main state machine is in the states of low power
        constexpr uint32_t MAIN_STATE_IN_WAIT_8M = (1U << 23);  ///< rtc main state machine is in wait 8m state
        constexpr uint32_t MAIN_STATE_IN_WAIT_PLL = (1U << 24);  ///< rtc main state machine is in wait pll state
        constexpr uint32_t MAIN_STATE_IN_WAIT_XTL = (1U << 25);  ///< rtc main state machine is in wait xtal state
        constexpr uint32_t MAIN_STATE_IN_SLP = (1U << 26);  ///< rtc main state machine is in sleep state
        constexpr uint32_t MAIN_STATE_IN_IDLE = (1U << 27);  ///< rtc main state machine is in idle state
        constexpr uint32_t MAIN_STATE = (4 << 28);  ///< rtc main state machine status
    }

    /// DIAG0 Register bits
    namespace diag0_bits {
        constexpr uint32_t LOW_POWER_DIAG1 = (32 << 0);  ///< Need add desc
    }

    /// PAD_HOLD Register bits
    namespace pad_hold_bits {
        constexpr uint32_t GPIO_PIN0_HOLD = (1U << 0);  ///< Need add desc
        constexpr uint32_t GPIO_PIN1_HOLD = (1U << 1);  ///< Need add desc
        constexpr uint32_t GPIO_PIN2_HOLD = (1U << 2);  ///< Need add desc
        constexpr uint32_t GPIO_PIN3_HOLD = (1U << 3);  ///< Need add desc
        constexpr uint32_t GPIO_PIN4_HOLD = (1U << 4);  ///< Need add desc
        constexpr uint32_t GPIO_PIN5_HOLD = (1U << 5);  ///< Need add desc
    }

    /// DIG_PAD_HOLD Register bits
    namespace dig_pad_hold_bits {
        constexpr uint32_t DIG_PAD_HOLD = (32 << 0);  ///< Need add desc
    }

    /// BROWN_OUT Register bits
    namespace brown_out_bits {
        constexpr uint32_t BROWN_OUT_INT_WAIT = (10 << 4);  ///< brown out interrupt wait cycles
        constexpr uint32_t BROWN_OUT_CLOSE_FLASH_ENA = (1U << 14);  ///< enable close flash when brown out happens
        constexpr uint32_t BROWN_OUT_PD_RF_ENA = (1U << 15);  ///< enable power down RF when brown out happens
        constexpr uint32_t BROWN_OUT_RST_WAIT = (10 << 16);  ///< brown out reset wait cycles
        constexpr uint32_t BROWN_OUT_RST_ENA = (1U << 26);  ///< enable brown out reset
        constexpr uint32_t BROWN_OUT_RST_SEL = (1U << 27);  ///< 1: 4-pos reset
        constexpr uint32_t BROWN_OUT_ANA_RST_EN = (1U << 28);  ///< Need add desc
        constexpr uint32_t BROWN_OUT_CNT_CLR = (1U << 29);  ///< clear brown out counter
        constexpr uint32_t BROWN_OUT_ENA = (1U << 30);  ///< enable brown out
        constexpr uint32_t DET = (1U << 31);  ///< Need add desc
    }

    /// TIME_LOW1 Register bits
    namespace time_low1_bits {
        constexpr uint32_t TIMER_VALUE1_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH1 Register bits
    namespace time_high1_bits {
        constexpr uint32_t TIMER_VALUE1_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// USB_CONF Register bits
    namespace usb_conf_bits {
        constexpr uint32_t IO_MUX_RESET_DISABLE = (1U << 18);  ///< Need add desc
    }

    /// SLP_REJECT_CAUSE Register bits
    namespace slp_reject_cause_bits {
        constexpr uint32_t REJECT_CAUSE = (18 << 0);  ///< sleep reject cause
    }

    /// OPTION1 Register bits
    namespace option1_bits {
        constexpr uint32_t FORCE_DOWNLOAD_BOOT = (1U << 0);  ///< Need add desc
    }

    /// SLP_WAKEUP_CAUSE Register bits
    namespace slp_wakeup_cause_bits {
        constexpr uint32_t WAKEUP_CAUSE = (17 << 0);  ///< sleep wakeup cause
    }

    /// ULP_CP_TIMER_1 Register bits
    namespace ulp_cp_timer_1_bits {
        constexpr uint32_t ULP_CP_TIMER_SLP_CYCLE = (24 << 8);  ///< sleep cycles for ULP-coprocessor timer
    }

    /// INT_ENA_RTC_W1TS Register bits
    namespace int_ena_rtc_w1ts_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TS = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TS = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t WDT_INT_ENA_W1TS = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TS = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TS = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SWD_INT_ENA_W1TS = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t BBPLL_CAL_INT_ENA_W1TS = (1U << 20);  ///< Need add desc
    }

    /// INT_ENA_RTC_W1TC Register bits
    namespace int_ena_rtc_w1tc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TC = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TC = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t WDT_INT_ENA_W1TC = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TC = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TC = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SWD_INT_ENA_W1TC = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t BBPLL_CAL_INT_ENA_W1TC = (1U << 20);  ///< Need add desc
    }

    /// CNTL_RETENTION_CTRL Register bits
    namespace cntl_retention_ctrl_bits {
        constexpr uint32_t RETENTION_CLK_SEL = (1U << 18);  ///< Need add desc
        constexpr uint32_t RETENTION_DONE_WAIT = (3 << 19);  ///< Need add desc
        constexpr uint32_t RETENTION_CLKOFF_WAIT = (4 << 22);  ///< Need add desc
        constexpr uint32_t RETENTION_EN = (1U << 26);  ///< Need add desc
        constexpr uint32_t RETENTION_WAIT = (5 << 27);  ///< wait cycles for rention operation
    }

    /// FIB_SEL Register bits
    namespace fib_sel_bits {
        constexpr uint32_t FIB_SEL = (3 << 0);  ///< select use analog fib signal
    }

    /// CNTL_GPIO_WAKEUP Register bits
    namespace cntl_gpio_wakeup_bits {
        constexpr uint32_t GPIO_WAKEUP_STATUS = (6 << 0);  ///< Need add desc
        constexpr uint32_t GPIO_WAKEUP_STATUS_CLR = (1U << 6);  ///< Need add desc
        constexpr uint32_t GPIO_PIN_CLK_GATE = (1U << 7);  ///< Need add desc
        constexpr uint32_t GPIO_PIN5_INT_TYPE = (3 << 8);  ///< Need add desc
        constexpr uint32_t GPIO_PIN4_INT_TYPE = (3 << 11);  ///< Need add desc
        constexpr uint32_t GPIO_PIN3_INT_TYPE = (3 << 14);  ///< Need add desc
        constexpr uint32_t GPIO_PIN2_INT_TYPE = (3 << 17);  ///< Need add desc
        constexpr uint32_t GPIO_PIN1_INT_TYPE = (3 << 20);  ///< Need add desc
        constexpr uint32_t GPIO_PIN0_INT_TYPE = (3 << 23);  ///< Need add desc
        constexpr uint32_t GPIO_PIN5_WAKEUP_ENABLE = (1U << 26);  ///< Need add desc
        constexpr uint32_t GPIO_PIN4_WAKEUP_ENABLE = (1U << 27);  ///< Need add desc
        constexpr uint32_t GPIO_PIN3_WAKEUP_ENABLE = (1U << 28);  ///< Need add desc
        constexpr uint32_t GPIO_PIN2_WAKEUP_ENABLE = (1U << 29);  ///< Need add desc
        constexpr uint32_t GPIO_PIN1_WAKEUP_ENABLE = (1U << 30);  ///< Need add desc
        constexpr uint32_t GPIO_PIN0_WAKEUP_ENABLE = (1U << 31);  ///< Need add desc
    }

    /// CNTL_DBG_SEL Register bits
    namespace cntl_dbg_sel_bits {
        constexpr uint32_t DEBUG_12M_NO_GATING = (1U << 1);  ///< Need add desc
        constexpr uint32_t DEBUG_BIT_SEL = (5 << 2);  ///< Need add desc
        constexpr uint32_t DEBUG_SEL0 = (5 << 7);  ///< Need add desc
        constexpr uint32_t DEBUG_SEL1 = (5 << 12);  ///< Need add desc
        constexpr uint32_t DEBUG_SEL2 = (5 << 17);  ///< Need add desc
        constexpr uint32_t DEBUG_SEL3 = (5 << 22);  ///< Need add desc
        constexpr uint32_t DEBUG_SEL4 = (5 << 27);  ///< Need add desc
    }

    /// CNTL_DBG_MAP Register bits
    namespace cntl_dbg_map_bits {
        constexpr uint32_t GPIO_PIN5_MUX_SEL = (1U << 2);  ///< Need add desc
        constexpr uint32_t GPIO_PIN4_MUX_SEL = (1U << 3);  ///< Need add desc
        constexpr uint32_t GPIO_PIN3_MUX_SEL = (1U << 4);  ///< Need add desc
        constexpr uint32_t GPIO_PIN2_MUX_SEL = (1U << 5);  ///< Need add desc
        constexpr uint32_t GPIO_PIN1_MUX_SEL = (1U << 6);  ///< Need add desc
        constexpr uint32_t GPIO_PIN0_MUX_SEL = (1U << 7);  ///< Need add desc
        constexpr uint32_t GPIO_PIN5_FUN_SEL = (4 << 8);  ///< Need add desc
        constexpr uint32_t GPIO_PIN4_FUN_SEL = (4 << 12);  ///< Need add desc
        constexpr uint32_t GPIO_PIN3_FUN_SEL = (4 << 16);  ///< Need add desc
        constexpr uint32_t GPIO_PIN2_FUN_SEL = (4 << 20);  ///< Need add desc
        constexpr uint32_t GPIO_PIN1_FUN_SEL = (4 << 24);  ///< Need add desc
        constexpr uint32_t GPIO_PIN0_FUN_SEL = (4 << 28);  ///< Need add desc
    }

    /// CNTL_SENSOR_CTRL Register bits
    namespace cntl_sensor_ctrl_bits {
        constexpr uint32_t SAR2_PWDET_CCT = (3 << 27);  ///< Need add desc
        constexpr uint32_t FORCE_XPD_SAR = (2 << 30);  ///< Need add desc
    }

    /// CNTL_DBG_SAR_SEL Register bits
    namespace cntl_dbg_sar_sel_bits {
        constexpr uint32_t SAR_DEBUG_SEL = (5 << 27);  ///< Need add desc
    }

    /// CNTL_DATE Register bits
    namespace cntl_date_bits {
        constexpr uint32_t CNTL_DATE = (28 << 0);  ///< Need add desc
    }

}

// ============================================================================
// SENSITIVE Peripheral
// ============================================================================

namespace sensitive {
    /// Base addresses
    constexpr uint32_t SENSITIVE_BASE = 0x600C1000;

    /// SENSITIVE Register structure
    struct Registers {
        volatile uint32_t ROM_TABLE_LOCK;  ///< Offset: 0x00 - register description
        volatile uint32_t ROM_TABLE;  ///< Offset: 0x04 - register description
        volatile uint32_t APB_PERIPHERAL_ACCESS_0;  ///< Offset: 0x08 - register description
        volatile uint32_t APB_PERIPHERAL_ACCESS_1;  ///< Offset: 0x0C - register description
        volatile uint32_t INTERNAL_SRAM_USAGE_0;  ///< Offset: 0x10 - register description
        volatile uint32_t INTERNAL_SRAM_USAGE_1;  ///< Offset: 0x14 - register description
        volatile uint32_t INTERNAL_SRAM_USAGE_3;  ///< Offset: 0x18 - register description
        volatile uint32_t CACHE_TAG_ACCESS_0;  ///< Offset: 0x1C - register description
        volatile uint32_t CACHE_TAG_ACCESS_1;  ///< Offset: 0x20 - register description
        volatile uint32_t CACHE_MMU_ACCESS_0;  ///< Offset: 0x24 - register description
        volatile uint32_t CACHE_MMU_ACCESS_1;  ///< Offset: 0x28 - register description
        volatile uint32_t PIF_ACCESS_MONITOR_0;  ///< Offset: 0x2C - register description
        volatile uint32_t PIF_ACCESS_MONITOR_1;  ///< Offset: 0x30 - register description
        volatile uint32_t PIF_ACCESS_MONITOR_2;  ///< Offset: 0x34 - register description
        volatile uint32_t PIF_ACCESS_MONITOR_3;  ///< Offset: 0x38 - register description
        volatile uint32_t XTS_AES_KEY_UPDATE;  ///< Offset: 0x3C - register description
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x40 - register description
        volatile uint32_t SENSITIVE_REG_DATE;  ///< Offset: 0xFFC - register description
    };

    /// Peripheral instances
    inline Registers* SENSITIVE = reinterpret_cast<Registers*>(SENSITIVE_BASE);

    // Bit definitions
    /// ROM_TABLE_LOCK Register bits
    namespace rom_table_lock_bits {
        constexpr uint32_t ROM_TABLE_LOCK = (1U << 0);  ///< Need add description
    }

    /// ROM_TABLE Register bits
    namespace rom_table_bits {
        constexpr uint32_t ROM_TABLE = (32 << 0);  ///< Need add description
    }

    /// APB_PERIPHERAL_ACCESS_0 Register bits
    namespace apb_peripheral_access_0_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_LOCK = (1U << 0);  ///< Need add description
    }

    /// APB_PERIPHERAL_ACCESS_1 Register bits
    namespace apb_peripheral_access_1_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_SPLIT_BURST = (1U << 0);  ///< Need add description
    }

    /// INTERNAL_SRAM_USAGE_0 Register bits
    namespace internal_sram_usage_0_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_LOCK = (1U << 0);  ///< Need add description
    }

    /// INTERNAL_SRAM_USAGE_1 Register bits
    namespace internal_sram_usage_1_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_CPU_CACHE = (1U << 0);  ///< Need add description
        constexpr uint32_t INTERNAL_SRAM_USAGE_CPU_SRAM = (3 << 1);  ///< Need add description
    }

    /// INTERNAL_SRAM_USAGE_3 Register bits
    namespace internal_sram_usage_3_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_MAC_DUMP_SRAM = (3 << 0);  ///< Need add description
        constexpr uint32_t INTERNAL_SRAM_ALLOC_MAC_DUMP = (1U << 3);  ///< Need add description
    }

    /// CACHE_TAG_ACCESS_0 Register bits
    namespace cache_tag_access_0_bits {
        constexpr uint32_t CACHE_TAG_ACCESS_LOCK = (1U << 0);  ///< Need add description
    }

    /// CACHE_TAG_ACCESS_1 Register bits
    namespace cache_tag_access_1_bits {
        constexpr uint32_t PRO_I_TAG_RD_ACS = (1U << 0);  ///< Need add description
        constexpr uint32_t PRO_I_TAG_WR_ACS = (1U << 1);  ///< Need add description
        constexpr uint32_t PRO_D_TAG_RD_ACS = (1U << 2);  ///< Need add description
        constexpr uint32_t PRO_D_TAG_WR_ACS = (1U << 3);  ///< Need add description
    }

    /// CACHE_MMU_ACCESS_0 Register bits
    namespace cache_mmu_access_0_bits {
        constexpr uint32_t CACHE_MMU_ACCESS_LOCK = (1U << 0);  ///< Need add description
    }

    /// CACHE_MMU_ACCESS_1 Register bits
    namespace cache_mmu_access_1_bits {
        constexpr uint32_t PRO_MMU_RD_ACS = (1U << 0);  ///< Need add description
        constexpr uint32_t PRO_MMU_WR_ACS = (1U << 1);  ///< Need add description
    }

    /// PIF_ACCESS_MONITOR_0 Register bits
    namespace pif_access_monitor_0_bits {
        constexpr uint32_t PIF_ACCESS_MONITOR_LOCK = (1U << 0);  ///< Need add description
    }

    /// PIF_ACCESS_MONITOR_1 Register bits
    namespace pif_access_monitor_1_bits {
        constexpr uint32_t PIF_ACCESS_MONITOR_NONWORD_VIOLATE_CLR = (1U << 0);  ///< Need add description
        constexpr uint32_t PIF_ACCESS_MONITOR_NONWORD_VIOLATE_EN = (1U << 1);  ///< Need add description
    }

    /// PIF_ACCESS_MONITOR_2 Register bits
    namespace pif_access_monitor_2_bits {
        constexpr uint32_t PIF_ACCESS_MONITOR_NONWORD_VIOLATE_INTR = (1U << 0);  ///< Need add description
        constexpr uint32_t PIF_ACCESS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE = (2 << 1);  ///< Need add description
    }

    /// PIF_ACCESS_MONITOR_3 Register bits
    namespace pif_access_monitor_3_bits {
        constexpr uint32_t PIF_ACCESS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR = (32 << 0);  ///< Need add description
    }

    /// XTS_AES_KEY_UPDATE Register bits
    namespace xts_aes_key_update_bits {
        constexpr uint32_t XTS_AES_KEY_UPDATE = (1U << 0);  ///< Set this bit to update xts_aes key
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Need add description
    }

    /// SENSITIVE_REG_DATE Register bits
    namespace sensitive_reg_date_bits {
        constexpr uint32_t SENSITIVE_REG_DATE = (28 << 0);  ///< Need add description
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t SHA_BASE = 0x6003B000;
    constexpr uint32_t XTS_AES_BASE = 0x600CC000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - Initial configuration register.
        volatile uint32_t T_STRING;  ///< Offset: 0x04 - SHA 512/t configuration register 0.
        volatile uint32_t T_LENGTH;  ///< Offset: 0x08 - SHA 512/t configuration register 1.
        volatile uint32_t DMA_BLOCK_NUM;  ///< Offset: 0x0C - DMA configuration register 0.
        volatile uint32_t START;  ///< Offset: 0x10 - Typical SHA configuration register 0.
        volatile uint32_t CONTINUE_;  ///< Offset: 0x14 - Typical SHA configuration register 1. (renamed from CONTINUE_)
        volatile uint32_t BUSY;  ///< Offset: 0x18 - Busy register.
        volatile uint32_t DMA_START;  ///< Offset: 0x1C - DMA configuration register 1.
        volatile uint32_t DMA_CONTINUE;  ///< Offset: 0x20 - DMA configuration register 2.
        volatile uint32_t CLEAR_IRQ;  ///< Offset: 0x24 - Interrupt clear register.
        volatile uint32_t IRQ_ENA;  ///< Offset: 0x28 - Interrupt enable register.
        volatile uint32_t DATE;  ///< Offset: 0x2C - Date register.
        volatile uint32_t H_MEM__;  ///< Offset: 0x40 - Sha H memory which contains intermediate hash or finial hash. (renamed from H_MEM__)
        volatile uint32_t M_MEM__;  ///< Offset: 0x80 - Sha M memory which contains message. (renamed from M_MEM__)
    };

    /// Peripheral instances
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);
    inline Registers* XTS_AES = reinterpret_cast<Registers*>(XTS_AES_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< Sha mode.
    }

    /// T_STRING Register bits
    namespace t_string_bits {
        constexpr uint32_t T_STRING = (32 << 0);  ///< Sha t_string (used if and only if mode == SHA_512/t).
    }

    /// T_LENGTH Register bits
    namespace t_length_bits {
        constexpr uint32_t T_LENGTH = (6 << 0);  ///< Sha t_length (used if and only if mode == SHA_512/t).
    }

    /// DMA_BLOCK_NUM Register bits
    namespace dma_block_num_bits {
        constexpr uint32_t DMA_BLOCK_NUM = (6 << 0);  ///< Dma-sha block number.
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t START = (31 << 1);  ///< Reserved.
    }

    /// CONTINUE_ Register bits
    namespace continue__bits {
        constexpr uint32_t CONTINUE_ = (31 << 1);  ///< Reserved. (renamed from CONTINUE_)
    }

    /// BUSY Register bits
    namespace busy_bits {
        constexpr uint32_t STATE = (1U << 0);  ///< Sha busy state. 1'b0: idle. 1'b1: busy.
    }

    /// DMA_START Register bits
    namespace dma_start_bits {
        constexpr uint32_t DMA_START = (1U << 0);  ///< Start dma-sha.
    }

    /// DMA_CONTINUE Register bits
    namespace dma_continue_bits {
        constexpr uint32_t DMA_CONTINUE = (1U << 0);  ///< Continue dma-sha.
    }

    /// CLEAR_IRQ Register bits
    namespace clear_irq_bits {
        constexpr uint32_t CLEAR_INTERRUPT = (1U << 0);  ///< Clear sha interrupt.
    }

    /// IRQ_ENA Register bits
    namespace irq_ena_bits {
        constexpr uint32_t INTERRUPT_ENA = (1U << 0);  ///< Sha interrupt enable register. 1'b0: disable(default). 1'b1: enable.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< Sha date information/ sha version information.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x60003000;
    constexpr uint32_t SPI1_BASE = 0x60002000;
    constexpr uint32_t SPI2_BASE = 0x60024000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x08 - SPI0 control register.
        volatile uint32_t CTRL1;  ///< Offset: 0x0C - SPI0 control1 register.
        volatile uint32_t CTRL2;  ///< Offset: 0x10 - SPI0 control2 register.
        volatile uint32_t CLOCK;  ///< Offset: 0x14 - SPI clock division control register.
        volatile uint32_t USER;  ///< Offset: 0x18 - SPI0 user register.
        volatile uint32_t USER1;  ///< Offset: 0x1C - SPI0 user1 register.
        volatile uint32_t USER2;  ///< Offset: 0x20 - SPI0 user2 register.
        volatile uint32_t RD_STATUS;  ///< Offset: 0x2C - SPI0 read control register.
        volatile uint32_t MISC;  ///< Offset: 0x34 - SPI0 misc register
        volatile uint32_t CACHE_FCTRL;  ///< Offset: 0x3C - SPI0 bit mode control register.
        volatile uint32_t FSM;  ///< Offset: 0x54 - SPI0 FSM status register
        volatile uint32_t TIMING_CALI;  ///< Offset: 0xA8 - SPI0 timing calibration register
        volatile uint32_t DIN_MODE;  ///< Offset: 0xAC - SPI0 input delay mode control register
        volatile uint32_t DIN_NUM;  ///< Offset: 0xB0 - SPI0 input delay number control register
        volatile uint32_t DOUT_MODE;  ///< Offset: 0xB4 - SPI0 output delay mode control register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xDC - SPI0 clk_gate register
        volatile uint32_t CORE_CLK_SEL;  ///< Offset: 0xE0 - SPI0 module clock select register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FDUMMY_OUT = (1U << 3);  ///< In the dummy phase the signal level of spi is output by the spi controller.
        constexpr uint32_t FCMD_DUAL = (1U << 7);  ///< Apply 2 signals during command phase 1:enable 0: disable
        constexpr uint32_t FCMD_QUAD = (1U << 8);  ///< Apply 4 signals during command phase 1:enable 0: disable
        constexpr uint32_t FASTRD_MODE = (1U << 13);  ///< This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT AND SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
        constexpr uint32_t FREAD_DUAL = (1U << 14);  ///< In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low
        constexpr uint32_t D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low
        constexpr uint32_t FREAD_QUAD = (1U << 20);  ///< In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low.
        constexpr uint32_t FREAD_DIO = (1U << 23);  ///< In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t FREAD_QIO = (1U << 24);  ///< In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t CLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
        constexpr uint32_t RXFIFO_RST = (1U << 30);  ///< SPI0 RX FIFO reset signal.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CS_SETUP_TIME = (5 << 0);  ///< (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
        constexpr uint32_t CS_HOLD_TIME = (5 << 5);  ///< Spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
        constexpr uint32_t CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SYNC_RESET = (1U << 31);  ///< The FSM will be reset.
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLKCNT_L = (8 << 0);  ///< In the master mode it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t CLKCNT_H = (8 << 8);  ///< In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t CLKCNT_N = (8 << 16);  ///< In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t CLK_EQU_SYSCLK = (1U << 31);  ///< Set this bit in 1-division mode.
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t CS_HOLD = (1U << 6);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t CS_SETUP = (1U << 7);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t CK_OUT_EDGE = (1U << 9);  ///< the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay mode.
        constexpr uint32_t USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable.
        constexpr uint32_t USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation.
    }

    /// USER1 Register bits
    namespace user1_bits {
        constexpr uint32_t USR_DUMMY_CYCLELEN = (6 << 0);  ///< The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        constexpr uint32_t USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of address phase. The register value shall be (bit_num-1).
    }

    /// USER2 Register bits
    namespace user2_bits {
        constexpr uint32_t USR_COMMAND_VALUE = (16 << 0);  ///< The value of command.
        constexpr uint32_t USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1)
    }

    /// RD_STATUS Register bits
    namespace rd_status_bits {
        constexpr uint32_t WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode bit.
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t TRANS_END = (1U << 3);  ///< The bit is used to indicate the spi0_mst_st controlled transmitting is done.
        constexpr uint32_t TRANS_END_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt of spi0_mst_st controlled transmitting is done.
        constexpr uint32_t CSPI_ST_TRANS_END = (1U << 5);  ///< The bit is used to indicate the spi0_slv_st controlled transmitting is done.
        constexpr uint32_t CSPI_ST_TRANS_END_INT_ENA = (1U << 6);  ///< The bit is used to enable the interrupt of spi0_slv_st controlled transmitting is done.
        constexpr uint32_t CK_IDLE_EDGE = (1U << 9);  ///< 1: spi clk line is high when idle 0: spi clk line is low when idle
        constexpr uint32_t CS_KEEP_ACTIVE = (1U << 10);  ///< spi cs line keep low when the bit is set.
    }

    /// CACHE_FCTRL Register bits
    namespace cache_fctrl_bits {
        constexpr uint32_t CACHE_REQ_EN = (1U << 0);  ///< For SPI0, Cache access enable, 1: enable, 0:disable.
        constexpr uint32_t CACHE_USR_ADDR_4BYTE = (1U << 1);  ///< For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
        constexpr uint32_t CACHE_FLASH_USR_CMD = (1U << 2);  ///< For SPI0, cache read flash for user define command, 1: enable, 0:disable.
        constexpr uint32_t FDIN_DUAL = (1U << 3);  ///< For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FDOUT_DUAL = (1U << 4);  ///< For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FADDR_DUAL = (1U << 5);  ///< For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FDIN_QUAD = (1U << 6);  ///< For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t FDOUT_QUAD = (1U << 7);  ///< For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t FADDR_QUAD = (1U << 8);  ///< For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
    }

    /// FSM Register bits
    namespace fsm_bits {
        constexpr uint32_t CSPI_ST = (4 << 0);  ///< The current status of SPI0 slave FSM: spi0_slv_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
        constexpr uint32_t EM_ST = (3 << 4);  ///< The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:EM_CACHE_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
        constexpr uint32_t CSPI_LOCK_DELAY_TIME = (5 << 7);  ///< The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
    }

    /// TIMING_CALI Register bits
    namespace timing_cali_bits {
        constexpr uint32_t TIMING_CLK_ENA = (1U << 0);  ///< The bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t TIMING_CALI = (1U << 1);  ///< The bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< add extra dummy spi clock cycle length for spi clock calibration.
    }

    /// DIN_MODE Register bits
    namespace din_mode_bits {
        constexpr uint32_t DIN0_MODE = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN1_MODE = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN2_MODE = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN3_MODE = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// DIN_NUM Register bits
    namespace din_num_bits {
        constexpr uint32_t DIN0_NUM = (1U << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN1_NUM = (1U << 1);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN2_NUM = (1U << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN3_NUM = (1U << 3);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// DOUT_MODE Register bits
    namespace dout_mode_bits {
        constexpr uint32_t DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Register clock gate enable signal. 1: Enable. 0: Disable.
    }

    /// CORE_CLK_SEL Register bits
    namespace core_clk_sel_bits {
        constexpr uint32_t SPI01_CLK_SEL = (2 << 0);  ///< When the digital system clock selects PLL clock and the frequency of PLL clock is 480MHz, the value of reg_spi01_clk_sel: 0: SPI0/1 module clock (clk) is 80MHz. 1: SPI0/1 module clock (clk) is 120MHz. 2: SPI0/1 module clock (clk) 160MHz. 3: Not used. When the digital system clock selects PLL clock and the frequency of PLL clock is 320MHz, the value of reg_spi01_clk_sel: 0: SPI0/1 module clock (clk) is 80MHz. 1: SPI0/1 module clock (clk) is 80MHz. 2: SPI0/1 module clock (clk) 160MHz. 3: Not used.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< SPI register version.
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x600C0000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t CPU_PERI_CLK_EN;  ///< Offset: 0x00 - cpu_peripheral clock gating register
        volatile uint32_t CPU_PERI_RST_EN;  ///< Offset: 0x04 - cpu_peripheral reset register
        volatile uint32_t CPU_PER_CONF;  ///< Offset: 0x08 - cpu clock config register
        volatile uint32_t MEM_PD_MASK;  ///< Offset: 0x0C - memory power down mask register
        volatile uint32_t PERIP_CLK_EN0;  ///< Offset: 0x10 - peripheral clock gating register
        volatile uint32_t PERIP_CLK_EN1;  ///< Offset: 0x14 - peripheral clock gating register
        volatile uint32_t PERIP_RST_EN0;  ///< Offset: 0x18 - reserved
        volatile uint32_t PERIP_RST_EN1;  ///< Offset: 0x1C - peripheral reset register
        volatile uint32_t BT_LPCK_DIV_INT;  ///< Offset: 0x20 - clock config register
        volatile uint32_t BT_LPCK_DIV_FRAC;  ///< Offset: 0x24 - low power clock configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x28 - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x2C - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x30 - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x34 - interrupt generate register
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x38 - rsa memory power control register
        volatile uint32_t EDMA_CTRL;  ///< Offset: 0x3C - edma clcok and reset register
        volatile uint32_t CACHE_CONTROL;  ///< Offset: 0x40 - cache control register
        volatile uint32_t EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL;  ///< Offset: 0x44 - SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG
        volatile uint32_t RTC_FASTMEM_CONFIG;  ///< Offset: 0x48 - fast memory config register
        volatile uint32_t RTC_FASTMEM_CRC;  ///< Offset: 0x4C - reserved
        volatile uint32_t REDUNDANT_ECO_CTRL;  ///< Offset: 0x50 - eco register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x54 - clock gating register
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x58 - system clock config register
        volatile uint32_t MEM_PVT;  ///< Offset: 0x5C - mem pvt register
        volatile uint32_t COMB_PVT_LVT_CONF;  ///< Offset: 0x60 - mem pvt register
        volatile uint32_t COMB_PVT_NVT_CONF;  ///< Offset: 0x64 - mem pvt register
        volatile uint32_t COMB_PVT_HVT_CONF;  ///< Offset: 0x68 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE0;  ///< Offset: 0x6C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE0;  ///< Offset: 0x70 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE0;  ///< Offset: 0x74 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE1;  ///< Offset: 0x78 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE1;  ///< Offset: 0x7C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE1;  ///< Offset: 0x80 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE2;  ///< Offset: 0x84 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE2;  ///< Offset: 0x88 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE2;  ///< Offset: 0x8C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE3;  ///< Offset: 0x90 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE3;  ///< Offset: 0x94 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE3;  ///< Offset: 0x98 - mem pvt register
        volatile uint32_t REG_DATE;  ///< Offset: 0xFFC - Version register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// CPU_PERI_CLK_EN Register bits
    namespace cpu_peri_clk_en_bits {
        constexpr uint32_t CLK_EN_ASSIST_DEBUG = (1U << 6);  ///< Set 1 to open assist_debug module clock
        constexpr uint32_t CLK_EN_DEDICATED_GPIO = (1U << 7);  ///< Set 1 to open dedicated_gpio module clk
    }

    /// CPU_PERI_RST_EN Register bits
    namespace cpu_peri_rst_en_bits {
        constexpr uint32_t RST_EN_ASSIST_DEBUG = (1U << 6);  ///< Set 1 to let assist_debug module reset
        constexpr uint32_t RST_EN_DEDICATED_GPIO = (1U << 7);  ///< Set 1 to let dedicated_gpio module reset
    }

    /// CPU_PER_CONF Register bits
    namespace cpu_per_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< This field used to sel cpu clock frequent.
        constexpr uint32_t PLL_FREQ_SEL = (1U << 2);  ///< This field used to sel pll frequent.
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 3);  ///< Set 1 to force cpu_waiti_clk enable.
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 4);  ///< This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
    }

    /// MEM_PD_MASK Register bits
    namespace mem_pd_mask_bits {
        constexpr uint32_t LSLP_MEM_PD_MASK = (1U << 0);  ///< Set 1 to mask memory power down.
    }

    /// PERIP_CLK_EN0 Register bits
    namespace perip_clk_en0_bits {
        constexpr uint32_t SPI01_CLK_EN = (1U << 1);  ///< Set 1 to enable SPI01 clock
        constexpr uint32_t UART_CLK_EN = (1U << 2);  ///< Set 1 to enable UART clock
        constexpr uint32_t UART1_CLK_EN = (1U << 5);  ///< Set 1 to enable UART1 clock
        constexpr uint32_t SPI2_CLK_EN = (1U << 6);  ///< Set 1 to enable SPI2 clock
        constexpr uint32_t I2C_EXT0_CLK_EN = (1U << 7);  ///< Set 1 to enable I2C_EXT0 clock
        constexpr uint32_t LEDC_CLK_EN = (1U << 11);  ///< Set 1 to enable LEDC clock
        constexpr uint32_t TIMERGROUP_CLK_EN = (1U << 13);  ///< Set 1 to enable TIMERGROUP clock
        constexpr uint32_t UART_MEM_CLK_EN = (1U << 24);  ///< Set 1 to enable UART_MEM clock
        constexpr uint32_t APB_SARADC_CLK_EN = (1U << 28);  ///< Set 1 to enable APB_SARADC clock
        constexpr uint32_t SYSTIMER_CLK_EN = (1U << 29);  ///< Set 1 to enable SYSTEMTIMER clock
        constexpr uint32_t ADC2_ARB_CLK_EN = (1U << 30);  ///< Set 1 to enable ADC2_ARB clock
    }

    /// PERIP_CLK_EN1 Register bits
    namespace perip_clk_en1_bits {
        constexpr uint32_t CRYPTO_ECC_CLK_EN = (1U << 1);  ///< Set 1 to enable ECC clock
        constexpr uint32_t CRYPTO_SHA_CLK_EN = (1U << 2);  ///< Set 1 to enable SHA clock
        constexpr uint32_t DMA_CLK_EN = (1U << 6);  ///< Set 1 to enable DMA clock
        constexpr uint32_t TSENS_CLK_EN = (1U << 10);  ///< Set 1 to enable TSENS clock
    }

    /// PERIP_RST_EN0 Register bits
    namespace perip_rst_en0_bits {
        constexpr uint32_t SPI01_RST = (1U << 1);  ///< Set 1 to let SPI01 reset
        constexpr uint32_t UART_RST = (1U << 2);  ///< Set 1 to let UART reset
        constexpr uint32_t UART1_RST = (1U << 5);  ///< Set 1 to let UART1 reset
        constexpr uint32_t SPI2_RST = (1U << 6);  ///< Set 1 to let SPI2 reset
        constexpr uint32_t I2C_EXT0_RST = (1U << 7);  ///< Set 1 to let I2C_EXT0 reset
        constexpr uint32_t LEDC_RST = (1U << 11);  ///< Set 1 to let LEDC reset
        constexpr uint32_t TIMERGROUP_RST = (1U << 13);  ///< Set 1 to let TIMERGROUP reset
        constexpr uint32_t UART_MEM_RST = (1U << 24);  ///< Set 1 to let UART_MEM reset
        constexpr uint32_t APB_SARADC_RST = (1U << 28);  ///< Set 1 to let APB_SARADC reset
        constexpr uint32_t SYSTIMER_RST = (1U << 29);  ///< Set 1 to let SYSTIMER reset
        constexpr uint32_t ADC2_ARB_RST = (1U << 30);  ///< Set 1 to let ADC2_ARB reset
    }

    /// PERIP_RST_EN1 Register bits
    namespace perip_rst_en1_bits {
        constexpr uint32_t CRYPTO_ECC_RST = (1U << 1);  ///< Set 1 to let CRYPTO_ECC reset
        constexpr uint32_t CRYPTO_SHA_RST = (1U << 2);  ///< Set 1 to let CRYPTO_SHA reset
        constexpr uint32_t DMA_RST = (1U << 6);  ///< Set 1 to let DMA reset
        constexpr uint32_t TSENS_RST = (1U << 10);  ///< Set 1 to let TSENS reset
    }

    /// BT_LPCK_DIV_INT Register bits
    namespace bt_lpck_div_int_bits {
        constexpr uint32_t BT_LPCK_DIV_NUM = (12 << 0);  ///< This field is lower power clock frequent division factor
    }

    /// BT_LPCK_DIV_FRAC Register bits
    namespace bt_lpck_div_frac_bits {
        constexpr uint32_t BT_LPCK_DIV_B = (12 << 0);  ///< This field is lower power clock frequent division factor b
        constexpr uint32_t BT_LPCK_DIV_A = (12 << 12);  ///< This field is lower power clock frequent division factor a
        constexpr uint32_t LPCLK_SEL_RTC_SLOW = (1U << 24);  ///< Set 1 to select rtc-slow clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_8M = (1U << 25);  ///< Set 1 to select 8m clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_XTAL = (1U << 26);  ///< Set 1 to select xtal clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_XTAL32K = (1U << 27);  ///< Set 1 to select xtal32k clock as low power clock
        constexpr uint32_t LPCLK_RTC_EN = (1U << 28);  ///< Set 1 to enable RTC low power clock
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< Set 1 to generate cpu interrupt 0
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< Set 1 to generate cpu interrupt 1
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< Set 1 to generate cpu interrupt 2
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< Set 1 to generate cpu interrupt 3
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_PD = (1U << 0);  ///< Set 1 to power down RSA memory. This bit has the lowest priority.When Digital Signature occupies the RSA. This bit is invalid.
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< Set 1 to force power up RSA memory. This bit has the second highest priority.
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 2);  ///< Set 1 to force power down RSA memory. This bit has the highest priority.
    }

    /// EDMA_CTRL Register bits
    namespace edma_ctrl_bits {
        constexpr uint32_t EDMA_CLK_ON = (1U << 0);  ///< Set 1 to enable EDMA clock.
        constexpr uint32_t EDMA_RESET = (1U << 1);  ///< Set 1 to let EDMA reset
    }

    /// CACHE_CONTROL Register bits
    namespace cache_control_bits {
        constexpr uint32_t ICACHE_CLK_ON = (1U << 0);  ///< Set 1 to enable icache clock
        constexpr uint32_t ICACHE_RESET = (1U << 1);  ///< Set 1 to let icache reset
        constexpr uint32_t DCACHE_CLK_ON = (1U << 2);  ///< Set 1 to enable dcache clock
        constexpr uint32_t DCACHE_RESET = (1U << 3);  ///< Set 1 to let dcache reset
    }

    /// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL Register bits
    namespace external_device_encrypt_decrypt_control_bits {
        constexpr uint32_t ENABLE_SPI_MANUAL_ENCRYPT = (1U << 0);  ///< Set 1 to enable the SPI manual encrypt.
        constexpr uint32_t ENABLE_DOWNLOAD_DB_ENCRYPT = (1U << 1);  ///< Set 1 to enable download DB encrypt.
        constexpr uint32_t ENABLE_DOWNLOAD_G0CB_DECRYPT = (1U << 2);  ///< Set 1 to enable download G0CB decrypt
        constexpr uint32_t ENABLE_DOWNLOAD_MANUAL_ENCRYPT = (1U << 3);  ///< Set 1 to enable download manual encrypt
    }

    /// RTC_FASTMEM_CONFIG Register bits
    namespace rtc_fastmem_config_bits {
        constexpr uint32_t RTC_MEM_CRC_START = (1U << 8);  ///< Set 1 to start the CRC of RTC memory
        constexpr uint32_t RTC_MEM_CRC_ADDR = (11 << 9);  ///< This field is used to set address of RTC memory for CRC.
        constexpr uint32_t RTC_MEM_CRC_LEN = (11 << 20);  ///< This field is used to set length of RTC memory for CRC based on start address.
        constexpr uint32_t RTC_MEM_CRC_FINISH = (1U << 31);  ///< This bit stores the status of RTC memory CRC.1 means finished.
    }

    /// RTC_FASTMEM_CRC Register bits
    namespace rtc_fastmem_crc_bits {
        constexpr uint32_t RTC_MEM_CRC_RES = (32 << 0);  ///< This field stores the CRC result of RTC memory.
    }

    /// REDUNDANT_ECO_CTRL Register bits
    namespace redundant_eco_ctrl_bits {
        constexpr uint32_t REDUNDANT_ECO_DRIVE = (1U << 0);  ///< reg_redundant_eco_drive
        constexpr uint32_t REDUNDANT_ECO_RESULT = (1U << 1);  ///< reg_redundant_eco_result
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< reg_clk_en
    }

    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< This field is used to set the count of prescaler of XTAL_CLK.
        constexpr uint32_t SOC_CLK_SEL = (2 << 10);  ///< This field is used to select soc clock.
        constexpr uint32_t CLK_XTAL_FREQ = (7 << 12);  ///< This field is used to read xtal frequency in MHz.
        constexpr uint32_t CLK_DIV_EN = (1U << 19);  ///< reg_clk_div_en
    }

    /// MEM_PVT Register bits
    namespace mem_pvt_bits {
        constexpr uint32_t MEM_PATH_LEN = (4 << 0);  ///< reg_mem_path_len
        constexpr uint32_t MEM_ERR_CNT_CLR = (1U << 4);  ///< reg_mem_err_cnt_clr
        constexpr uint32_t MONITOR_EN = (1U << 5);  ///< reg_mem_pvt_monitor_en
        constexpr uint32_t MEM_TIMING_ERR_CNT = (16 << 6);  ///< reg_mem_timing_err_cnt
        constexpr uint32_t MEM_VT_SEL = (2 << 22);  ///< reg_mem_vt_sel
    }

    /// COMB_PVT_LVT_CONF Register bits
    namespace comb_pvt_lvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_LVT = (6 << 0);  ///< reg_comb_path_len_lvt
        constexpr uint32_t COMB_ERR_CNT_CLR_LVT = (1U << 6);  ///< reg_comb_err_cnt_clr_lvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_LVT = (1U << 7);  ///< reg_comb_pvt_monitor_en_lvt
    }

    /// COMB_PVT_NVT_CONF Register bits
    namespace comb_pvt_nvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_NVT = (6 << 0);  ///< reg_comb_path_len_nvt
        constexpr uint32_t COMB_ERR_CNT_CLR_NVT = (1U << 6);  ///< reg_comb_err_cnt_clr_nvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_NVT = (1U << 7);  ///< reg_comb_pvt_monitor_en_nvt
    }

    /// COMB_PVT_HVT_CONF Register bits
    namespace comb_pvt_hvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_HVT = (6 << 0);  ///< reg_comb_path_len_hvt
        constexpr uint32_t COMB_ERR_CNT_CLR_HVT = (1U << 6);  ///< reg_comb_err_cnt_clr_hvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_HVT = (1U << 7);  ///< reg_comb_pvt_monitor_en_hvt
    }

    /// COMB_PVT_ERR_LVT_SITE0 Register bits
    namespace comb_pvt_err_lvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site0
    }

    /// COMB_PVT_ERR_NVT_SITE0 Register bits
    namespace comb_pvt_err_nvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site0
    }

    /// COMB_PVT_ERR_HVT_SITE0 Register bits
    namespace comb_pvt_err_hvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site0
    }

    /// COMB_PVT_ERR_LVT_SITE1 Register bits
    namespace comb_pvt_err_lvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site1
    }

    /// COMB_PVT_ERR_NVT_SITE1 Register bits
    namespace comb_pvt_err_nvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site1
    }

    /// COMB_PVT_ERR_HVT_SITE1 Register bits
    namespace comb_pvt_err_hvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site1
    }

    /// COMB_PVT_ERR_LVT_SITE2 Register bits
    namespace comb_pvt_err_lvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site2
    }

    /// COMB_PVT_ERR_NVT_SITE2 Register bits
    namespace comb_pvt_err_nvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site2
    }

    /// COMB_PVT_ERR_HVT_SITE2 Register bits
    namespace comb_pvt_err_hvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site2
    }

    /// COMB_PVT_ERR_LVT_SITE3 Register bits
    namespace comb_pvt_err_lvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site3
    }

    /// COMB_PVT_ERR_NVT_SITE3 Register bits
    namespace comb_pvt_err_nvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site3
    }

    /// COMB_PVT_ERR_HVT_SITE3 Register bits
    namespace comb_pvt_err_hvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site3
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t SYSTEM_REG_DATE = (28 << 0);  ///< reg_system_reg_date
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t SYSTIMER_BASE = 0x60023000;
    constexpr uint32_t TIMG0_BASE = 0x6001F000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x00 - Configure system timer clock
        volatile uint32_t UNIT0_OP;  ///< Offset: 0x04 - system timer unit0 value update register
        volatile uint32_t UNIT1_OP;  ///< Offset: 0x08 - system timer unit1 value update register
        volatile uint32_t UNIT0_LOAD_HI;  ///< Offset: 0x0C - system timer unit0 value high load register
        volatile uint32_t UNIT0_LOAD_LO;  ///< Offset: 0x10 - system timer unit0 value low load register
        volatile uint32_t UNIT1_LOAD_HI;  ///< Offset: 0x14 - system timer unit1 value high load register
        volatile uint32_t UNIT1_LOAD_LO;  ///< Offset: 0x18 - system timer unit1 value low load register
        volatile uint32_t TARGET0_HI;  ///< Offset: 0x1C - system timer comp0 value high register
        volatile uint32_t TARGET0_LO;  ///< Offset: 0x20 - system timer comp0 value low register
        volatile uint32_t TARGET1_HI;  ///< Offset: 0x24 - system timer comp1 value high register
        volatile uint32_t TARGET1_LO;  ///< Offset: 0x28 - system timer comp1 value low register
        volatile uint32_t TARGET2_HI;  ///< Offset: 0x2C - system timer comp2 value high register
        volatile uint32_t TARGET2_LO;  ///< Offset: 0x30 - system timer comp2 value low register
        volatile uint32_t TARGET0_CONF;  ///< Offset: 0x34 - system timer comp0 target mode register
        volatile uint32_t TARGET1_CONF;  ///< Offset: 0x38 - system timer comp1 target mode register
        volatile uint32_t TARGET2_CONF;  ///< Offset: 0x3C - system timer comp2 target mode register
        volatile uint32_t UNIT0_VALUE_HI;  ///< Offset: 0x40 - system timer unit0 value high register
        volatile uint32_t UNIT0_VALUE_LO;  ///< Offset: 0x44 - system timer unit0 value low register
        volatile uint32_t UNIT1_VALUE_HI;  ///< Offset: 0x48 - system timer unit1 value high register
        volatile uint32_t UNIT1_VALUE_LO;  ///< Offset: 0x4C - system timer unit1 value low register
        volatile uint32_t COMP0_LOAD;  ///< Offset: 0x50 - system timer comp0 conf sync register
        volatile uint32_t COMP1_LOAD;  ///< Offset: 0x54 - system timer comp1 conf sync register
        volatile uint32_t COMP2_LOAD;  ///< Offset: 0x58 - system timer comp2 conf sync register
        volatile uint32_t UNIT0_LOAD;  ///< Offset: 0x5C - system timer unit0 conf sync register
        volatile uint32_t UNIT1_LOAD;  ///< Offset: 0x60 - system timer unit1 conf sync register
        volatile uint32_t INT_ENA;  ///< Offset: 0x64 - systimer interrupt enable register
        volatile uint32_t INT_RAW;  ///< Offset: 0x68 - systimer interrupt raw register
        volatile uint32_t INT_CLR;  ///< Offset: 0x6C - systimer interrupt clear register
        volatile uint32_t INT_ST;  ///< Offset: 0x70 - systimer interrupt status register
        volatile uint32_t DATE;  ///< Offset: 0xFC - system timer version control register
    };

    /// Peripheral instances
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t SYSTIMER_CLK_FO = (1U << 0);  ///< systimer clock force on
        constexpr uint32_t TARGET2_WORK_EN = (1U << 22);  ///< target2 work enable
        constexpr uint32_t TARGET1_WORK_EN = (1U << 23);  ///< target1 work enable
        constexpr uint32_t TARGET0_WORK_EN = (1U << 24);  ///< target0 work enable
        constexpr uint32_t TIMER_UNIT1_CORE1_STALL_EN = (1U << 25);  ///< If timer unit1 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT1_CORE0_STALL_EN = (1U << 26);  ///< If timer unit1 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT0_CORE1_STALL_EN = (1U << 27);  ///< If timer unit0 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT0_CORE0_STALL_EN = (1U << 28);  ///< If timer unit0 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT1_WORK_EN = (1U << 29);  ///< timer unit1 work enable
        constexpr uint32_t TIMER_UNIT0_WORK_EN = (1U << 30);  ///< timer unit0 work enable
        constexpr uint32_t CLK_EN = (1U << 31);  ///< register file clk gating
    }

    /// UNIT0_OP Register bits
    namespace unit0_op_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_VALID = (1U << 29);  ///< timer value is sync and valid
        constexpr uint32_t TIMER_UNIT0_UPDATE = (1U << 30);  ///< update timer_unit0
    }

    /// UNIT1_OP Register bits
    namespace unit1_op_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_VALID = (1U << 29);  ///< timer value is sync and valid
        constexpr uint32_t TIMER_UNIT1_UPDATE = (1U << 30);  ///< update timer unit1
    }

    /// UNIT0_LOAD_HI Register bits
    namespace unit0_load_hi_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_HI = (20 << 0);  ///< timer unit0 load high 20 bits
    }

    /// UNIT0_LOAD_LO Register bits
    namespace unit0_load_lo_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_LO = (32 << 0);  ///< timer unit0 load low 32 bits
    }

    /// UNIT1_LOAD_HI Register bits
    namespace unit1_load_hi_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_HI = (20 << 0);  ///< timer unit1 load high 20 bits
    }

    /// UNIT1_LOAD_LO Register bits
    namespace unit1_load_lo_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_LO = (32 << 0);  ///< timer unit1 load low 32 bits
    }

    /// TARGET0_HI Register bits
    namespace target0_hi_bits {
        constexpr uint32_t TIMER_TARGET0_HI = (20 << 0);  ///< timer taget0 high 20 bits
    }

    /// TARGET0_LO Register bits
    namespace target0_lo_bits {
        constexpr uint32_t TIMER_TARGET0_LO = (32 << 0);  ///< timer taget0 low 32 bits
    }

    /// TARGET1_HI Register bits
    namespace target1_hi_bits {
        constexpr uint32_t TIMER_TARGET1_HI = (20 << 0);  ///< timer taget1 high 20 bits
    }

    /// TARGET1_LO Register bits
    namespace target1_lo_bits {
        constexpr uint32_t TIMER_TARGET1_LO = (32 << 0);  ///< timer taget1 low 32 bits
    }

    /// TARGET2_HI Register bits
    namespace target2_hi_bits {
        constexpr uint32_t TIMER_TARGET2_HI = (20 << 0);  ///< timer taget2 high 20 bits
    }

    /// TARGET2_LO Register bits
    namespace target2_lo_bits {
        constexpr uint32_t TIMER_TARGET2_LO = (32 << 0);  ///< timer taget2 low 32 bits
    }

    /// TARGET0_CONF Register bits
    namespace target0_conf_bits {
        constexpr uint32_t TARGET0_PERIOD = (26 << 0);  ///< target0 period
        constexpr uint32_t TARGET0_PERIOD_MODE = (1U << 30);  ///< Set target0 to period mode
        constexpr uint32_t TARGET0_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET1_CONF Register bits
    namespace target1_conf_bits {
        constexpr uint32_t TARGET1_PERIOD = (26 << 0);  ///< target1 period
        constexpr uint32_t TARGET1_PERIOD_MODE = (1U << 30);  ///< Set target1 to period mode
        constexpr uint32_t TARGET1_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET2_CONF Register bits
    namespace target2_conf_bits {
        constexpr uint32_t TARGET2_PERIOD = (26 << 0);  ///< target2 period
        constexpr uint32_t TARGET2_PERIOD_MODE = (1U << 30);  ///< Set target2 to period mode
        constexpr uint32_t TARGET2_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// UNIT0_VALUE_HI Register bits
    namespace unit0_value_hi_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_HI = (20 << 0);  ///< timer read value high 20bits
    }

    /// UNIT0_VALUE_LO Register bits
    namespace unit0_value_lo_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_LO = (32 << 0);  ///< timer read value low 32bits
    }

    /// UNIT1_VALUE_HI Register bits
    namespace unit1_value_hi_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_HI = (20 << 0);  ///< timer read value high 20bits
    }

    /// UNIT1_VALUE_LO Register bits
    namespace unit1_value_lo_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_LO = (32 << 0);  ///< timer read value low 32bits
    }

    /// COMP0_LOAD Register bits
    namespace comp0_load_bits {
        constexpr uint32_t TIMER_COMP0_LOAD = (1U << 0);  ///< timer comp0 sync enable signal
    }

    /// COMP1_LOAD Register bits
    namespace comp1_load_bits {
        constexpr uint32_t TIMER_COMP1_LOAD = (1U << 0);  ///< timer comp1 sync enable signal
    }

    /// COMP2_LOAD Register bits
    namespace comp2_load_bits {
        constexpr uint32_t TIMER_COMP2_LOAD = (1U << 0);  ///< timer comp2 sync enable signal
    }

    /// UNIT0_LOAD Register bits
    namespace unit0_load_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD = (1U << 0);  ///< timer unit0 sync enable signal
    }

    /// UNIT1_LOAD Register bits
    namespace unit1_load_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD = (1U << 0);  ///< timer unit1 sync enable signal
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TARGET0_INT_ENA = (1U << 0);  ///< interupt0 enable
        constexpr uint32_t TARGET1_INT_ENA = (1U << 1);  ///< interupt1 enable
        constexpr uint32_t TARGET2_INT_ENA = (1U << 2);  ///< interupt2 enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TARGET0_INT_RAW = (1U << 0);  ///< interupt0 raw
        constexpr uint32_t TARGET1_INT_RAW = (1U << 1);  ///< interupt1 raw
        constexpr uint32_t TARGET2_INT_RAW = (1U << 2);  ///< interupt2 raw
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TARGET0_INT_CLR = (1U << 0);  ///< interupt0 clear
        constexpr uint32_t TARGET1_INT_CLR = (1U << 1);  ///< interupt1 clear
        constexpr uint32_t TARGET2_INT_CLR = (1U << 2);  ///< interupt2 clear
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TARGET0_INT_ST = (1U << 0);  ///< interupt0 status
        constexpr uint32_t TARGET1_INT_ST = (1U << 1);  ///< interupt1 status
        constexpr uint32_t TARGET2_INT_ST = (1U << 2);  ///< interupt2 status
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< systimer register version
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x60000000;
    constexpr uint32_t UART1_BASE = 0x60010000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0;  ///< Offset: 0x20 - a
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t LOWPULSE;  ///< Offset: 0x28 - Autobaud minimum low pulse duration register
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x2C - Autobaud minimum high pulse duration register
        volatile uint32_t RXD_CNT;  ///< Offset: 0x30 - Autobaud edge change count register
        volatile uint32_t FLOW_CONF;  ///< Offset: 0x34 - Software flow-control configuration
        volatile uint32_t SLEEP_CONF;  ///< Offset: 0x38 - Sleep-mode configuration
        volatile uint32_t SWFC_CONF0;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x64 - Tx-FIFO write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x68 - Rx-FIFO write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x6C - UART transmit and receive status.
        volatile uint32_t POSPULSE;  ///< Offset: 0x70 - Autobaud high pulse register
        volatile uint32_t NEGPULSE;  ///< Offset: 0x74 - Autobaud low pulse register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x78 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x7C - UART Version register
        volatile uint32_t ID;  ///< Offset: 0x80 - UART ID register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters, after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for rs485_clash_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear the rs485_parity_err_int_raw interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear the rs485_frm_err_int_raw interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear the rs485_clash_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value, the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (10 << 0);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (10 << 16);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t SW_RTS = (1U << 6);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t SW_DTR = (1U << 7);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t TXD_BRK = (1U << 8);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 9);  ///< Set this bit to enable IrDA loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 10);  ///< This is the start enable bit for IrDA transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 11);  ///< 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 12);  ///< Set this bit to invert the level of IrDA transmitter.
        constexpr uint32_t IRDA_RX_INV = (1U << 13);  ///< Set this bit to invert the level of IrDA receiver.
        constexpr uint32_t LOOPBACK = (1U << 14);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 15);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t IRDA_EN = (1U << 16);  ///< Set this bit to enable IrDA protocol.
        constexpr uint32_t RXFIFO_RST = (1U << 17);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 18);  ///< Set this bit to reset the uart transmit-FIFO.
        constexpr uint32_t RXD_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t CTS_INV = (1U << 20);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 21);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t TXD_INV = (1U << 22);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t RTS_INV = (1U << 23);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 24);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t CLK_EN = (1U << 25);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
        constexpr uint32_t ERR_WR_MASK = (1U << 26);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t AUTOBAUD_EN = (1U << 27);  ///< This is the enable bit for detecting baudrate.
        constexpr uint32_t MEM_CLK_EN = (1U << 28);  ///< UART memory clock gate enable signal.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (9 << 0);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (9 << 9);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 18);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 19);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 20);  ///< This is the flow enable bit for UART receiver.
        constexpr uint32_t RX_TOUT_EN = (1U << 21);  ///< This is the enble bit for uart receiver's timeout function.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of rxd edge change. It is used in baud rate-detect process.
    }

    /// FLOW_CONF Register bits
    namespace flow_conf_bits {
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 0);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 1);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 2);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 3);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 4);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 5);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SLEEP_CONF Register bits
    namespace sleep_conf_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
    }

    /// SWFC_CONF0 Register bits
    namespace swfc_conf0_bits {
        constexpr uint32_t XOFF_THRESHOLD = (9 << 0);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1, it will send a Xoff char.
        constexpr uint32_t XOFF_CHAR = (8 << 9);  ///< This register stores the Xoff flow control char.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (9 << 0);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1, it will send a Xon char.
        constexpr uint32_t XON_CHAR = (8 << 9);  ///< This register stores the Xon flow control char.
    }

    /// TXBRK_CONF Register bits
    namespace txbrk_conf_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose the rs485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t RX_SIZE = (3 << 1);  ///< This register is used to configure the amount of mem allocated for receive-FIFO. The default number is 128 bytes.
        constexpr uint32_t TX_SIZE = (3 << 4);  ///< This register is used to configure the amount of mem allocated for transmit-FIFO. The default number is 128 bytes.
        constexpr uint32_t RX_FLOW_THRHD = (9 << 7);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 16);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
        constexpr uint32_t MEM_FORCE_PD = (1U << 26);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 27);  ///< Set this bit to force power up UART memory.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t APB_TX_WADDR = (10 << 0);  ///< This register stores the offset address in Tx-FIFO when software writes Tx-FIFO via APB.
        constexpr uint32_t TX_RADDR = (10 << 11);  ///< This register stores the offset address in Tx-FIFO when Tx-FSM reads data via Tx-FIFO_Ctrl.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t APB_RX_RADDR = (10 << 0);  ///< This register stores the offset address in RX-FIFO when software reads data from Rx-FIFO via APB. UART0 is 10'h100. UART1 is 10'h180.
        constexpr uint32_t RX_WADDR = (10 << 11);  ///< This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl writes Rx-FIFO. UART0 is 10'h100. UART1 is 10'h180.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_B = (6 << 0);  ///< The denominator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_A = (6 << 6);  ///< The numerator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t SCLK_SEL = (2 << 20);  ///< UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.
        constexpr uint32_t SCLK_EN = (1U << 22);  ///< Set this bit to enable UART Tx/Rx clock.
        constexpr uint32_t RST_CORE = (1U << 23);  ///< Write 1 then write 0 to this bit, reset UART Tx/Rx.
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t RX_SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit, reset UART Tx.
        constexpr uint32_t RX_RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit, reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (30 << 0);  ///< This register is used to configure the uart_id.
        constexpr uint32_t HIGH_SPEED = (1U << 30);  ///< This bit used to select synchronize mode. 1: Registers are auto synchronized into UART Core clock and UART core should be keep the same with APB clock. 0: After configure registers, software needs to write 1 to UART_REG_UPDATE to synchronize registers.
        constexpr uint32_t REG_UPDATE = (1U << 31);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

}


} // namespace alloy::generated::esp32-c2

#endif // ALLOY_GENERATED_ESP32-C2_PERIPHERALS_HPP