/// Auto-generated code for ESP32-C3
/// Generated by Alloy Code Generator
/// Source: espressif_esp32c3.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:00
#ifndef ALLOY_GENERATED_ESP32-C3_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-C3_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-c3 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 5;
    constexpr bool has_apb = true;
    constexpr uint32_t num_apb_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_assist = true;
    constexpr uint32_t num_assist_instances = 1;
    constexpr bool has_bb = true;
    constexpr uint32_t num_bb_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_extmem = true;
    constexpr uint32_t num_extmem_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sensitive = true;
    constexpr uint32_t num_sensitive_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_uhci1 = true;
    constexpr uint32_t num_uhci1_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct apb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct assist_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct extmem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sensitive_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uhci1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x6003A000;
    constexpr uint32_t HMAC_BASE = 0x6003E000;
    constexpr uint32_t RSA_BASE = 0x6003C000;
    constexpr uint32_t SHA_BASE = 0x6003B000;
    constexpr uint32_t XTS_AES_BASE = 0x600CC000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t KEY_0;  ///< Offset: 0x00 - Key material key_0 configure register
        volatile uint32_t KEY_1;  ///< Offset: 0x04 - Key material key_1 configure register
        volatile uint32_t KEY_2;  ///< Offset: 0x08 - Key material key_2 configure register
        volatile uint32_t KEY_3;  ///< Offset: 0x0C - Key material key_3 configure register
        volatile uint32_t KEY_4;  ///< Offset: 0x10 - Key material key_4 configure register
        volatile uint32_t KEY_5;  ///< Offset: 0x14 - Key material key_5 configure register
        volatile uint32_t KEY_6;  ///< Offset: 0x18 - Key material key_6 configure register
        volatile uint32_t KEY_7;  ///< Offset: 0x1C - Key material key_7 configure register
        volatile uint32_t TEXT_IN_0;  ///< Offset: 0x20 - source text material text_in_0 configure register
        volatile uint32_t TEXT_IN_1;  ///< Offset: 0x24 - source text material text_in_1 configure register
        volatile uint32_t TEXT_IN_2;  ///< Offset: 0x28 - source text material text_in_2 configure register
        volatile uint32_t TEXT_IN_3;  ///< Offset: 0x2C - source text material text_in_3 configure register
        volatile uint32_t TEXT_OUT_0;  ///< Offset: 0x30 - result text material text_out_0 configure register
        volatile uint32_t TEXT_OUT_1;  ///< Offset: 0x34 - result text material text_out_1 configure register
        volatile uint32_t TEXT_OUT_2;  ///< Offset: 0x38 - result text material text_out_2 configure register
        volatile uint32_t TEXT_OUT_3;  ///< Offset: 0x3C - result text material text_out_3 configure register
        volatile uint32_t MODE;  ///< Offset: 0x40 - AES Mode register
        volatile uint32_t ENDIAN;  ///< Offset: 0x44 - AES Endian configure register
        volatile uint32_t TRIGGER;  ///< Offset: 0x48 - AES trigger register
        volatile uint32_t STATE;  ///< Offset: 0x4C - AES state register
        volatile uint32_t IV_MEM__;  ///< Offset: 0x50 - The memory that stores initialization vector (renamed from IV_MEM__)
        volatile uint32_t H_MEM__;  ///< Offset: 0x60 - The memory that stores GCM hash subkey (renamed from H_MEM__)
        volatile uint32_t J0_MEM__;  ///< Offset: 0x70 - The memory that stores J0 (renamed from J0_MEM__)
        volatile uint32_t T0_MEM__;  ///< Offset: 0x80 - The memory that stores T0 (renamed from T0_MEM__)
        volatile uint32_t DMA_ENABLE;  ///< Offset: 0x90 - DMA-AES working mode register
        volatile uint32_t BLOCK_MODE;  ///< Offset: 0x94 - AES cipher block mode register
        volatile uint32_t BLOCK_NUM;  ///< Offset: 0x98 - AES block number register
        volatile uint32_t INC_SEL;  ///< Offset: 0x9C - Standard incrementing function configure register
        volatile uint32_t AAD_BLOCK_NUM;  ///< Offset: 0xA0 - Additional Authential Data block number register
        volatile uint32_t REMAINDER_BIT_NUM;  ///< Offset: 0xA4 - AES remainder bit number register
        volatile uint32_t CONTINUE_;  ///< Offset: 0xA8 - AES continue register (renamed from CONTINUE_)
        volatile uint32_t INT_CLEAR;  ///< Offset: 0xAC - AES Interrupt clear register
        volatile uint32_t INT_ENA;  ///< Offset: 0xB0 - AES Interrupt enable register
        volatile uint32_t DATE;  ///< Offset: 0xB4 - AES version control register
        volatile uint32_t DMA_EXIT;  ///< Offset: 0xB8 - AES-DMA exit config
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* HMAC = reinterpret_cast<Registers*>(HMAC_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);
    inline Registers* XTS_AES = reinterpret_cast<Registers*>(XTS_AES_BASE);

    // Bit definitions
    /// KEY_0 Register bits
    namespace key_0_bits {
        constexpr uint32_t KEY_0 = (32 << 0);  ///< This bits stores key_0 that is a part of key material.
    }

    /// KEY_1 Register bits
    namespace key_1_bits {
        constexpr uint32_t KEY_1 = (32 << 0);  ///< This bits stores key_1 that is a part of key material.
    }

    /// KEY_2 Register bits
    namespace key_2_bits {
        constexpr uint32_t KEY_2 = (32 << 0);  ///< This bits stores key_2 that is a part of key material.
    }

    /// KEY_3 Register bits
    namespace key_3_bits {
        constexpr uint32_t KEY_3 = (32 << 0);  ///< This bits stores key_3 that is a part of key material.
    }

    /// KEY_4 Register bits
    namespace key_4_bits {
        constexpr uint32_t KEY_4 = (32 << 0);  ///< This bits stores key_4 that is a part of key material.
    }

    /// KEY_5 Register bits
    namespace key_5_bits {
        constexpr uint32_t KEY_5 = (32 << 0);  ///< This bits stores key_5 that is a part of key material.
    }

    /// KEY_6 Register bits
    namespace key_6_bits {
        constexpr uint32_t KEY_6 = (32 << 0);  ///< This bits stores key_6 that is a part of key material.
    }

    /// KEY_7 Register bits
    namespace key_7_bits {
        constexpr uint32_t KEY_7 = (32 << 0);  ///< This bits stores key_7 that is a part of key material.
    }

    /// TEXT_IN_0 Register bits
    namespace text_in_0_bits {
        constexpr uint32_t TEXT_IN_0 = (32 << 0);  ///< This bits stores text_in_0 that is a part of source text material.
    }

    /// TEXT_IN_1 Register bits
    namespace text_in_1_bits {
        constexpr uint32_t TEXT_IN_1 = (32 << 0);  ///< This bits stores text_in_1 that is a part of source text material.
    }

    /// TEXT_IN_2 Register bits
    namespace text_in_2_bits {
        constexpr uint32_t TEXT_IN_2 = (32 << 0);  ///< This bits stores text_in_2 that is a part of source text material.
    }

    /// TEXT_IN_3 Register bits
    namespace text_in_3_bits {
        constexpr uint32_t TEXT_IN_3 = (32 << 0);  ///< This bits stores text_in_3 that is a part of source text material.
    }

    /// TEXT_OUT_0 Register bits
    namespace text_out_0_bits {
        constexpr uint32_t TEXT_OUT_0 = (32 << 0);  ///< This bits stores text_out_0 that is a part of result text material.
    }

    /// TEXT_OUT_1 Register bits
    namespace text_out_1_bits {
        constexpr uint32_t TEXT_OUT_1 = (32 << 0);  ///< This bits stores text_out_1 that is a part of result text material.
    }

    /// TEXT_OUT_2 Register bits
    namespace text_out_2_bits {
        constexpr uint32_t TEXT_OUT_2 = (32 << 0);  ///< This bits stores text_out_2 that is a part of result text material.
    }

    /// TEXT_OUT_3 Register bits
    namespace text_out_3_bits {
        constexpr uint32_t TEXT_OUT_3 = (32 << 0);  ///< This bits stores text_out_3 that is a part of result text material.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< This bits decides which one operation mode will be used. 3'd0: AES-EN-128, 3'd1: AES-EN-192, 3'd2: AES-EN-256, 3'd4: AES-DE-128, 3'd5: AES-DE-192, 3'd6: AES-DE-256.
    }

    /// ENDIAN Register bits
    namespace endian_bits {
        constexpr uint32_t ENDIAN = (6 << 0);  ///< endian. [1:0] key endian, [3:2] text_in endian or in_stream endian, [5:4] text_out endian or out_stream endian
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< Set this bit to start AES calculation.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< Those bits shows AES status. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
    }

    /// DMA_ENABLE Register bits
    namespace dma_enable_bits {
        constexpr uint32_t DMA_ENABLE = (1U << 0);  ///< 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
    }

    /// BLOCK_MODE Register bits
    namespace block_mode_bits {
        constexpr uint32_t BLOCK_MODE = (3 << 0);  ///< Those bits decides which block mode will be used. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: GCM, 0x7: reserved.
    }

    /// BLOCK_NUM Register bits
    namespace block_num_bits {
        constexpr uint32_t BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of Plaintext/ciphertext block.
    }

    /// INC_SEL Register bits
    namespace inc_sel_bits {
        constexpr uint32_t INC_SEL = (1U << 0);  ///< This bit decides the standard incrementing function. 0: INC32. 1: INC128.
    }

    /// AAD_BLOCK_NUM Register bits
    namespace aad_block_num_bits {
        constexpr uint32_t AAD_BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of AAD block.
    }

    /// REMAINDER_BIT_NUM Register bits
    namespace remainder_bit_num_bits {
        constexpr uint32_t REMAINDER_BIT_NUM = (7 << 0);  ///< Those bits stores the number of remainder bit.
    }

    /// CONTINUE_ Register bits
    namespace continue__bits {
        constexpr uint32_t CONTINUE_ = (1U << 0);  ///< Set this bit to continue GCM operation. (renamed from CONTINUE_)
    }

    /// INT_CLEAR Register bits
    namespace int_clear_bits {
        constexpr uint32_t INT_CLEAR = (1U << 0);  ///< Set this bit to clear the AES interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t INT_ENA = (1U << 0);  ///< Set this bit to enable interrupt that occurs when DMA-AES calculation is done.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< This bits stores the version information of AES.
    }

    /// DMA_EXIT Register bits
    namespace dma_exit_bits {
        constexpr uint32_t DMA_EXIT = (1U << 0);  ///< Set this register to leave calculation done stage. Recommend to use it after software finishes reading DMA's output buffer.
    }

}

// ============================================================================
// APB Peripheral
// ============================================================================

namespace apb {
    /// Base addresses
    constexpr uint32_t APB_CTRL_BASE = 0x60026000;

    /// APB Register structure
    struct Registers {
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x00 - APB_CTRL_SYSCLK_CONF_REG
        volatile uint32_t TICK_CONF;  ///< Offset: 0x04 - APB_CTRL_TICK_CONF_REG
        volatile uint32_t CLK_OUT_EN;  ///< Offset: 0x08 - APB_CTRL_CLK_OUT_EN_REG
        volatile uint32_t WIFI_BB_CFG;  ///< Offset: 0x0C - APB_CTRL_WIFI_BB_CFG_REG
        volatile uint32_t WIFI_BB_CFG_2;  ///< Offset: 0x10 - APB_CTRL_WIFI_BB_CFG_2_REG
        volatile uint32_t WIFI_CLK_EN;  ///< Offset: 0x14 - APB_CTRL_WIFI_CLK_EN_REG
        volatile uint32_t WIFI_RST_EN;  ///< Offset: 0x18 - APB_CTRL_WIFI_RST_EN_REG
        volatile uint32_t HOST_INF_SEL;  ///< Offset: 0x1C - APB_CTRL_HOST_INF_SEL_REG
        volatile uint32_t EXT_MEM_PMS_LOCK;  ///< Offset: 0x20 - APB_CTRL_EXT_MEM_PMS_LOCK_REG
        volatile uint32_t FLASH_ACE0_ATTR;  ///< Offset: 0x28 - APB_CTRL_FLASH_ACE0_ATTR_REG
        volatile uint32_t FLASH_ACE1_ATTR;  ///< Offset: 0x2C - APB_CTRL_FLASH_ACE1_ATTR_REG
        volatile uint32_t FLASH_ACE2_ATTR;  ///< Offset: 0x30 - APB_CTRL_FLASH_ACE2_ATTR_REG
        volatile uint32_t FLASH_ACE3_ATTR;  ///< Offset: 0x34 - APB_CTRL_FLASH_ACE3_ATTR_REG
        volatile uint32_t FLASH_ACE0_ADDR;  ///< Offset: 0x38 - APB_CTRL_FLASH_ACE0_ADDR_REG
        volatile uint32_t FLASH_ACE1_ADDR;  ///< Offset: 0x3C - APB_CTRL_FLASH_ACE1_ADDR_REG
        volatile uint32_t FLASH_ACE2_ADDR;  ///< Offset: 0x40 - APB_CTRL_FLASH_ACE2_ADDR_REG
        volatile uint32_t FLASH_ACE3_ADDR;  ///< Offset: 0x44 - APB_CTRL_FLASH_ACE3_ADDR_REG
        volatile uint32_t FLASH_ACE0_SIZE;  ///< Offset: 0x48 - APB_CTRL_FLASH_ACE0_SIZE_REG
        volatile uint32_t FLASH_ACE1_SIZE;  ///< Offset: 0x4C - APB_CTRL_FLASH_ACE1_SIZE_REG
        volatile uint32_t FLASH_ACE2_SIZE;  ///< Offset: 0x50 - APB_CTRL_FLASH_ACE2_SIZE_REG
        volatile uint32_t FLASH_ACE3_SIZE;  ///< Offset: 0x54 - APB_CTRL_FLASH_ACE3_SIZE_REG
        volatile uint32_t SPI_MEM_PMS_CTRL;  ///< Offset: 0x88 - APB_CTRL_SPI_MEM_PMS_CTRL_REG
        volatile uint32_t SPI_MEM_REJECT_ADDR;  ///< Offset: 0x8C - APB_CTRL_SPI_MEM_REJECT_ADDR_REG
        volatile uint32_t SDIO_CTRL;  ///< Offset: 0x90 - APB_CTRL_SDIO_CTRL_REG
        volatile uint32_t REDCY_SIG0;  ///< Offset: 0x94 - APB_CTRL_REDCY_SIG0_REG_REG
        volatile uint32_t REDCY_SIG1;  ///< Offset: 0x98 - APB_CTRL_REDCY_SIG1_REG_REG
        volatile uint32_t FRONT_END_MEM_PD;  ///< Offset: 0x9C - APB_CTRL_FRONT_END_MEM_PD_REG
        volatile uint32_t RETENTION_CTRL;  ///< Offset: 0xA0 - APB_CTRL_RETENTION_CTRL_REG
        volatile uint32_t CLKGATE_FORCE_ON;  ///< Offset: 0xA4 - APB_CTRL_CLKGATE_FORCE_ON_REG
        volatile uint32_t MEM_POWER_DOWN;  ///< Offset: 0xA8 - APB_CTRL_MEM_POWER_DOWN_REG
        volatile uint32_t MEM_POWER_UP;  ///< Offset: 0xAC - APB_CTRL_MEM_POWER_UP_REG
        volatile uint32_t RND_DATA;  ///< Offset: 0xB0 - APB_CTRL_RND_DATA_REG
        volatile uint32_t PERI_BACKUP_CONFIG;  ///< Offset: 0xB4 - APB_CTRL_PERI_BACKUP_CONFIG_REG_REG
        volatile uint32_t PERI_BACKUP_APB_ADDR;  ///< Offset: 0xB8 - APB_CTRL_PERI_BACKUP_APB_ADDR_REG_REG
        volatile uint32_t PERI_BACKUP_MEM_ADDR;  ///< Offset: 0xBC - APB_CTRL_PERI_BACKUP_MEM_ADDR_REG_REG
        volatile uint32_t PERI_BACKUP_INT_RAW;  ///< Offset: 0xC0 - APB_CTRL_PERI_BACKUP_INT_RAW_REG
        volatile uint32_t PERI_BACKUP_INT_ST;  ///< Offset: 0xC4 - APB_CTRL_PERI_BACKUP_INT_ST_REG
        volatile uint32_t PERI_BACKUP_INT_ENA;  ///< Offset: 0xC8 - APB_CTRL_PERI_BACKUP_INT_ENA_REG
        volatile uint32_t PERI_BACKUP_INT_CLR;  ///< Offset: 0xD0 - APB_CTRL_PERI_BACKUP_INT_CLR_REG
        volatile uint32_t DATE;  ///< Offset: 0x3FC - APB_CTRL_DATE_REG
    };

    /// Peripheral instances
    inline Registers* APB_CTRL = reinterpret_cast<Registers*>(APB_CTRL_BASE);

    // Bit definitions
    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< reg_pre_div_cnt
        constexpr uint32_t CLK_320M_EN = (1U << 10);  ///< reg_clk_320m_en
        constexpr uint32_t CLK_EN = (1U << 11);  ///< reg_clk_en
        constexpr uint32_t RST_TICK_CNT = (1U << 12);  ///< reg_rst_tick_cnt
    }

    /// TICK_CONF Register bits
    namespace tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< reg_xtal_tick_num
        constexpr uint32_t CK8M_TICK_NUM = (8 << 8);  ///< reg_ck8m_tick_num
        constexpr uint32_t TICK_ENABLE = (1U << 16);  ///< reg_tick_enable
    }

    /// CLK_OUT_EN Register bits
    namespace clk_out_en_bits {
        constexpr uint32_t CLK20_OEN = (1U << 0);  ///< reg_clk20_oen
        constexpr uint32_t CLK22_OEN = (1U << 1);  ///< reg_clk22_oen
        constexpr uint32_t CLK44_OEN = (1U << 2);  ///< reg_clk44_oen
        constexpr uint32_t CLK_BB_OEN = (1U << 3);  ///< reg_clk_bb_oen
        constexpr uint32_t CLK80_OEN = (1U << 4);  ///< reg_clk80_oen
        constexpr uint32_t CLK160_OEN = (1U << 5);  ///< reg_clk160_oen
        constexpr uint32_t CLK_320M_OEN = (1U << 6);  ///< reg_clk_320m_oen
        constexpr uint32_t CLK_ADC_INF_OEN = (1U << 7);  ///< reg_clk_adc_inf_oen
        constexpr uint32_t CLK_DAC_CPU_OEN = (1U << 8);  ///< reg_clk_dac_cpu_oen
        constexpr uint32_t CLK40X_BB_OEN = (1U << 9);  ///< reg_clk40x_bb_oen
        constexpr uint32_t CLK_XTAL_OEN = (1U << 10);  ///< reg_clk_xtal_oen
    }

    /// WIFI_BB_CFG Register bits
    namespace wifi_bb_cfg_bits {
        constexpr uint32_t WIFI_BB_CFG = (32 << 0);  ///< reg_wifi_bb_cfg
    }

    /// WIFI_BB_CFG_2 Register bits
    namespace wifi_bb_cfg_2_bits {
        constexpr uint32_t WIFI_BB_CFG_2 = (32 << 0);  ///< reg_wifi_bb_cfg_2
    }

    /// WIFI_CLK_EN Register bits
    namespace wifi_clk_en_bits {
        constexpr uint32_t WIFI_CLK_EN = (32 << 0);  ///< reg_wifi_clk_en
    }

    /// WIFI_RST_EN Register bits
    namespace wifi_rst_en_bits {
        constexpr uint32_t WIFI_RST = (32 << 0);  ///< reg_wifi_rst
    }

    /// HOST_INF_SEL Register bits
    namespace host_inf_sel_bits {
        constexpr uint32_t PERI_IO_SWAP = (8 << 0);  ///< reg_peri_io_swap
    }

    /// EXT_MEM_PMS_LOCK Register bits
    namespace ext_mem_pms_lock_bits {
        constexpr uint32_t EXT_MEM_PMS_LOCK = (1U << 0);  ///< reg_ext_mem_pms_lock
    }

    /// FLASH_ACE0_ATTR Register bits
    namespace flash_ace0_attr_bits {
        constexpr uint32_t FLASH_ACE0_ATTR = (2 << 0);  ///< reg_flash_ace0_attr
    }

    /// FLASH_ACE1_ATTR Register bits
    namespace flash_ace1_attr_bits {
        constexpr uint32_t FLASH_ACE1_ATTR = (2 << 0);  ///< reg_flash_ace1_attr
    }

    /// FLASH_ACE2_ATTR Register bits
    namespace flash_ace2_attr_bits {
        constexpr uint32_t FLASH_ACE2_ATTR = (2 << 0);  ///< reg_flash_ace2_attr
    }

    /// FLASH_ACE3_ATTR Register bits
    namespace flash_ace3_attr_bits {
        constexpr uint32_t FLASH_ACE3_ATTR = (2 << 0);  ///< reg_flash_ace3_attr
    }

    /// FLASH_ACE0_ADDR Register bits
    namespace flash_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace0_addr_s
    }

    /// FLASH_ACE1_ADDR Register bits
    namespace flash_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace1_addr_s
    }

    /// FLASH_ACE2_ADDR Register bits
    namespace flash_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace2_addr_s
    }

    /// FLASH_ACE3_ADDR Register bits
    namespace flash_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< reg_flash_ace3_addr_s
    }

    /// FLASH_ACE0_SIZE Register bits
    namespace flash_ace0_size_bits {
        constexpr uint32_t FLASH_ACE0_SIZE = (13 << 0);  ///< reg_flash_ace0_size
    }

    /// FLASH_ACE1_SIZE Register bits
    namespace flash_ace1_size_bits {
        constexpr uint32_t FLASH_ACE1_SIZE = (13 << 0);  ///< reg_flash_ace1_size
    }

    /// FLASH_ACE2_SIZE Register bits
    namespace flash_ace2_size_bits {
        constexpr uint32_t FLASH_ACE2_SIZE = (13 << 0);  ///< reg_flash_ace2_size
    }

    /// FLASH_ACE3_SIZE Register bits
    namespace flash_ace3_size_bits {
        constexpr uint32_t FLASH_ACE3_SIZE = (13 << 0);  ///< reg_flash_ace3_size
    }

    /// SPI_MEM_PMS_CTRL Register bits
    namespace spi_mem_pms_ctrl_bits {
        constexpr uint32_t SPI_MEM_REJECT_INT = (1U << 0);  ///< reg_spi_mem_reject_int
        constexpr uint32_t SPI_MEM_REJECT_CLR = (1U << 1);  ///< reg_spi_mem_reject_clr
        constexpr uint32_t SPI_MEM_REJECT_CDE = (5 << 2);  ///< reg_spi_mem_reject_cde
    }

    /// SPI_MEM_REJECT_ADDR Register bits
    namespace spi_mem_reject_addr_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (32 << 0);  ///< reg_spi_mem_reject_addr
    }

    /// SDIO_CTRL Register bits
    namespace sdio_ctrl_bits {
        constexpr uint32_t SDIO_WIN_ACCESS_EN = (1U << 0);  ///< reg_sdio_win_access_en
    }

    /// REDCY_SIG0 Register bits
    namespace redcy_sig0_bits {
        constexpr uint32_t REDCY_SIG0 = (31 << 0);  ///< reg_redcy_sig0
        constexpr uint32_t REDCY_ANDOR = (1U << 31);  ///< reg_redcy_andor
    }

    /// REDCY_SIG1 Register bits
    namespace redcy_sig1_bits {
        constexpr uint32_t REDCY_SIG1 = (31 << 0);  ///< reg_redcy_sig1
        constexpr uint32_t REDCY_NANDOR = (1U << 31);  ///< reg_redcy_nandor
    }

    /// FRONT_END_MEM_PD Register bits
    namespace front_end_mem_pd_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 0);  ///< reg_agc_mem_force_pu
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 1);  ///< reg_agc_mem_force_pd
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 2);  ///< reg_pbus_mem_force_pu
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 3);  ///< reg_pbus_mem_force_pd
        constexpr uint32_t DC_MEM_FORCE_PU = (1U << 4);  ///< reg_dc_mem_force_pu
        constexpr uint32_t DC_MEM_FORCE_PD = (1U << 5);  ///< reg_dc_mem_force_pd
    }

    /// RETENTION_CTRL Register bits
    namespace retention_ctrl_bits {
        constexpr uint32_t RETENTION_LINK_ADDR = (27 << 0);  ///< reg_retention_link_addr
        constexpr uint32_t NOBYPASS_CPU_ISO_RST = (1U << 27);  ///< reg_nobypass_cpu_iso_rst
    }

    /// CLKGATE_FORCE_ON Register bits
    namespace clkgate_force_on_bits {
        constexpr uint32_t ROM_CLKGATE_FORCE_ON = (2 << 0);  ///< reg_rom_clkgate_force_on
        constexpr uint32_t SRAM_CLKGATE_FORCE_ON = (4 << 2);  ///< reg_sram_clkgate_force_on
    }

    /// MEM_POWER_DOWN Register bits
    namespace mem_power_down_bits {
        constexpr uint32_t ROM_POWER_DOWN = (2 << 0);  ///< reg_rom_power_down
        constexpr uint32_t SRAM_POWER_DOWN = (4 << 2);  ///< reg_sram_power_down
    }

    /// MEM_POWER_UP Register bits
    namespace mem_power_up_bits {
        constexpr uint32_t ROM_POWER_UP = (2 << 0);  ///< reg_rom_power_up
        constexpr uint32_t SRAM_POWER_UP = (4 << 2);  ///< reg_sram_power_up
    }

    /// RND_DATA Register bits
    namespace rnd_data_bits {
        constexpr uint32_t RND_DATA = (32 << 0);  ///< reg_rnd_data
    }

    /// PERI_BACKUP_CONFIG Register bits
    namespace peri_backup_config_bits {
        constexpr uint32_t PERI_BACKUP_FLOW_ERR = (2 << 1);  ///< reg_peri_backup_flow_err
        constexpr uint32_t PERI_BACKUP_BURST_LIMIT = (5 << 4);  ///< reg_peri_backup_burst_limit
        constexpr uint32_t PERI_BACKUP_TOUT_THRES = (10 << 9);  ///< reg_peri_backup_tout_thres
        constexpr uint32_t PERI_BACKUP_SIZE = (10 << 19);  ///< reg_peri_backup_size
        constexpr uint32_t PERI_BACKUP_START = (1U << 29);  ///< reg_peri_backup_start
        constexpr uint32_t PERI_BACKUP_TO_MEM = (1U << 30);  ///< reg_peri_backup_to_mem
        constexpr uint32_t PERI_BACKUP_ENA = (1U << 31);  ///< reg_peri_backup_ena
    }

    /// PERI_BACKUP_APB_ADDR Register bits
    namespace peri_backup_apb_addr_bits {
        constexpr uint32_t BACKUP_APB_START_ADDR = (32 << 0);  ///< reg_backup_apb_start_addr
    }

    /// PERI_BACKUP_MEM_ADDR Register bits
    namespace peri_backup_mem_addr_bits {
        constexpr uint32_t BACKUP_MEM_START_ADDR = (32 << 0);  ///< reg_backup_mem_start_addr
    }

    /// PERI_BACKUP_INT_RAW Register bits
    namespace peri_backup_int_raw_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_RAW = (1U << 0);  ///< reg_peri_backup_done_int_raw
        constexpr uint32_t PERI_BACKUP_ERR_INT_RAW = (1U << 1);  ///< reg_peri_backup_err_int_raw
    }

    /// PERI_BACKUP_INT_ST Register bits
    namespace peri_backup_int_st_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_ST = (1U << 0);  ///< reg_peri_backup_done_int_st
        constexpr uint32_t PERI_BACKUP_ERR_INT_ST = (1U << 1);  ///< reg_peri_backup_err_int_st
    }

    /// PERI_BACKUP_INT_ENA Register bits
    namespace peri_backup_int_ena_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_ENA = (1U << 0);  ///< reg_peri_backup_done_int_ena
        constexpr uint32_t PERI_BACKUP_ERR_INT_ENA = (1U << 1);  ///< reg_peri_backup_err_int_ena
    }

    /// PERI_BACKUP_INT_CLR Register bits
    namespace peri_backup_int_clr_bits {
        constexpr uint32_t PERI_BACKUP_DONE_INT_CLR = (1U << 0);  ///< reg_peri_backup_done_int_clr
        constexpr uint32_t PERI_BACKUP_ERR_INT_CLR = (1U << 1);  ///< reg_peri_backup_err_int_clr
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< reg_dateVersion control
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t APB_SARADC_BASE = 0x60040000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - digital saradc configure register
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - digital saradc configure register
        volatile uint32_t FILTER_CTRL1;  ///< Offset: 0x08 - digital saradc configure register
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - digital saradc configure register
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - digital saradc configure register
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - digital saradc configure register
        volatile uint32_t SAR_PATT_TAB1;  ///< Offset: 0x18 - digital saradc configure register
        volatile uint32_t SAR_PATT_TAB2;  ///< Offset: 0x1C - digital saradc configure register
        volatile uint32_t ONETIME_SAMPLE;  ///< Offset: 0x20 - digital saradc configure register
        volatile uint32_t ARB_CTRL;  ///< Offset: 0x24 - digital saradc configure register
        volatile uint32_t FILTER_CTRL0;  ///< Offset: 0x28 - digital saradc configure register
        volatile uint32_t SAR1DATA_STATUS;  ///< Offset: 0x2C - digital saradc configure register
        volatile uint32_t SAR2DATA_STATUS;  ///< Offset: 0x30 - digital saradc configure register
        volatile uint32_t THRES0_CTRL;  ///< Offset: 0x34 - digital saradc configure register
        volatile uint32_t THRES1_CTRL;  ///< Offset: 0x38 - digital saradc configure register
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x3C - digital saradc configure register
        volatile uint32_t INT_ENA;  ///< Offset: 0x40 - digital saradc int register
        volatile uint32_t INT_RAW;  ///< Offset: 0x44 - digital saradc int register
        volatile uint32_t INT_ST;  ///< Offset: 0x48 - digital saradc int register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - digital saradc int register
        volatile uint32_t DMA_CONF;  ///< Offset: 0x50 - digital saradc configure register
        volatile uint32_t CLKM_CONF;  ///< Offset: 0x54 - digital saradc configure register
        volatile uint32_t APB_TSENS_CTRL;  ///< Offset: 0x58 - digital tsens configure register
        volatile uint32_t TSENS_CTRL2;  ///< Offset: 0x5C - digital tsens configure register
        volatile uint32_t CALI;  ///< Offset: 0x60 - digital saradc configure register
        volatile uint32_t CTRL_DATE;  ///< Offset: 0x3FC - version
    };

    /// Peripheral instances
    inline Registers* APB_SARADC = reinterpret_cast<Registers*>(APB_SARADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SARADC_START_FORCE = (1U << 0);  ///< select software enable saradc sample
        constexpr uint32_t SARADC_START = (1U << 1);  ///< software enable saradc sample
        constexpr uint32_t SARADC_SAR_CLK_GATED = (1U << 6);  ///< SAR clock gated
        constexpr uint32_t SARADC_SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SARADC_SAR_PATT_LEN = (3 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SARADC_XPD_SAR_FORCE = (2 << 27);  ///< force option to xpd sar blocks
        constexpr uint32_t SARADC_WAIT_ARB_CYCLE = (2 << 30);  ///< wait arbit signal stable after sar_done
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t SARADC_MEAS_NUM_LIMIT = (1U << 0);  ///< enable max meas num
        constexpr uint32_t SARADC_MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SARADC_SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_TIMER_TARGET = (12 << 12);  ///< to set saradc timer target
        constexpr uint32_t SARADC_TIMER_EN = (1U << 24);  ///< to enable saradc timer trigger
    }

    /// FILTER_CTRL1 Register bits
    namespace filter_ctrl1_bits {
        constexpr uint32_t APB_SARADC_FILTER_FACTOR1 = (3 << 26);  ///< Factor of saradc filter1
        constexpr uint32_t APB_SARADC_FILTER_FACTOR0 = (3 << 29);  ///< Factor of saradc filter0
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t SARADC_XPD_WAIT = (8 << 0);  ///< saradc_xpd_wait
        constexpr uint32_t SARADC_RSTB_WAIT = (8 << 8);  ///< saradc_rstb_wait
        constexpr uint32_t SARADC_STANDBY_WAIT = (8 << 16);  ///< saradc_standby_wait
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SARADC_SAR1_STATUS = (32 << 0);  ///< saradc1 status about data and channel
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SARADC_SAR2_STATUS = (32 << 0);  ///< saradc2 status about data and channel
    }

    /// SAR_PATT_TAB1 Register bits
    namespace sar_patt_tab1_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// SAR_PATT_TAB2 Register bits
    namespace sar_patt_tab2_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item one byte)
    }

    /// ONETIME_SAMPLE Register bits
    namespace onetime_sample_bits {
        constexpr uint32_t SARADC_ONETIME_ATTEN = (2 << 23);  ///< configure onetime atten
        constexpr uint32_t SARADC_ONETIME_CHANNEL = (4 << 25);  ///< configure onetime channel
        constexpr uint32_t SARADC_ONETIME_START = (1U << 29);  ///< trigger adc onetime sample
        constexpr uint32_t SARADC2_ONETIME_SAMPLE = (1U << 30);  ///< enable adc2 onetime sample
        constexpr uint32_t SARADC1_ONETIME_SAMPLE = (1U << 31);  ///< enable adc1 onetime sample
    }

    /// ARB_CTRL Register bits
    namespace arb_ctrl_bits {
        constexpr uint32_t ADC_ARB_APB_FORCE = (1U << 2);  ///< adc2 arbiter force to enableapb controller
        constexpr uint32_t ADC_ARB_RTC_FORCE = (1U << 3);  ///< adc2 arbiter force to enable rtc controller
        constexpr uint32_t ADC_ARB_WIFI_FORCE = (1U << 4);  ///< adc2 arbiter force to enable wifi controller
        constexpr uint32_t ADC_ARB_GRANT_FORCE = (1U << 5);  ///< adc2 arbiter force grant
        constexpr uint32_t ADC_ARB_APB_PRIORITY = (2 << 6);  ///< Set adc2 arbiterapb priority
        constexpr uint32_t ADC_ARB_RTC_PRIORITY = (2 << 8);  ///< Set adc2 arbiter rtc priority
        constexpr uint32_t ADC_ARB_WIFI_PRIORITY = (2 << 10);  ///< Set adc2 arbiter wifi priority
        constexpr uint32_t ADC_ARB_FIX_PRIORITY = (1U << 12);  ///< adc2 arbiter uses fixed priority
    }

    /// FILTER_CTRL0 Register bits
    namespace filter_ctrl0_bits {
        constexpr uint32_t APB_SARADC_FILTER_CHANNEL1 = (4 << 18);  ///< configure filter1 to adc channel
        constexpr uint32_t APB_SARADC_FILTER_CHANNEL0 = (4 << 22);  ///< configure filter0 to adc channel
        constexpr uint32_t APB_SARADC_FILTER_RESET = (1U << 31);  ///< enable apb_adc1_filter
    }

    /// SAR1DATA_STATUS Register bits
    namespace sar1data_status_bits {
        constexpr uint32_t APB_SARADC1_DATA = (17 << 0);  ///< saradc1 data
    }

    /// SAR2DATA_STATUS Register bits
    namespace sar2data_status_bits {
        constexpr uint32_t APB_SARADC2_DATA = (17 << 0);  ///< saradc2 data
    }

    /// THRES0_CTRL Register bits
    namespace thres0_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES0_CHANNEL = (4 << 0);  ///< configure thres0 to adc channel
        constexpr uint32_t APB_SARADC_THRES0_HIGH = (13 << 5);  ///< saradc thres0 monitor thres
        constexpr uint32_t APB_SARADC_THRES0_LOW = (13 << 18);  ///< saradc thres0 monitor thres
    }

    /// THRES1_CTRL Register bits
    namespace thres1_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES1_CHANNEL = (4 << 0);  ///< configure thres1 to adc channel
        constexpr uint32_t APB_SARADC_THRES1_HIGH = (13 << 5);  ///< saradc thres1 monitor thres
        constexpr uint32_t APB_SARADC_THRES1_LOW = (13 << 18);  ///< saradc thres1 monitor thres
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES_ALL_EN = (1U << 27);  ///< enable thres to all channel
        constexpr uint32_t APB_SARADC_THRES1_EN = (1U << 30);  ///< enable thres1
        constexpr uint32_t APB_SARADC_THRES0_EN = (1U << 31);  ///< enable thres0
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_ENA = (1U << 26);  ///< saradc thres1 low interrupt enable
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_ENA = (1U << 27);  ///< saradc thres0 low interrupt enable
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_ENA = (1U << 28);  ///< saradc thres1 high interrupt enable
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_ENA = (1U << 29);  ///< saradc thres0 high interrupt enable
        constexpr uint32_t APB_SARADC2_DONE_INT_ENA = (1U << 30);  ///< saradc2 done interrupt enable
        constexpr uint32_t APB_SARADC1_DONE_INT_ENA = (1U << 31);  ///< saradc1 done interrupt enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_RAW = (1U << 26);  ///< saradc thres1 low interrupt raw
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_RAW = (1U << 27);  ///< saradc thres0 low interrupt raw
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_RAW = (1U << 28);  ///< saradc thres1 high interrupt raw
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_RAW = (1U << 29);  ///< saradc thres0 high interrupt raw
        constexpr uint32_t APB_SARADC2_DONE_INT_RAW = (1U << 30);  ///< saradc2 done interrupt raw
        constexpr uint32_t APB_SARADC1_DONE_INT_RAW = (1U << 31);  ///< saradc1 done interrupt raw
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_ST = (1U << 26);  ///< saradc thres1 low interrupt state
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_ST = (1U << 27);  ///< saradc thres0 low interrupt state
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_ST = (1U << 28);  ///< saradc thres1 high interrupt state
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_ST = (1U << 29);  ///< saradc thres0 high interrupt state
        constexpr uint32_t APB_SARADC2_DONE_INT_ST = (1U << 30);  ///< saradc2 done interrupt state
        constexpr uint32_t APB_SARADC1_DONE_INT_ST = (1U << 31);  ///< saradc1 done interrupt state
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_CLR = (1U << 26);  ///< saradc thres1 low interrupt clear
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_CLR = (1U << 27);  ///< saradc thres0 low interrupt clear
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_CLR = (1U << 28);  ///< saradc thres1 high interrupt clear
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_CLR = (1U << 29);  ///< saradc thres0 high interrupt clear
        constexpr uint32_t APB_SARADC2_DONE_INT_CLR = (1U << 30);  ///< saradc2 done interrupt clear
        constexpr uint32_t APB_SARADC1_DONE_INT_CLR = (1U << 31);  ///< saradc1 done interrupt clear
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< the dma_in_suc_eof gen when sample cnt = spi_eof_num
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< reset_apb_adc_state
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< enable apb_adc use spi_dma
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value
        constexpr uint32_t CLK_EN = (1U << 20);  ///< reg clk en
        constexpr uint32_t CLK_SEL = (2 << 21);  ///< Set this bit to enable clk_apll
    }

    /// APB_TSENS_CTRL Register bits
    namespace apb_tsens_ctrl_bits {
        constexpr uint32_t TSENS_OUT = (8 << 0);  ///< temperature sensor data out
        constexpr uint32_t TSENS_IN_INV = (1U << 13);  ///< invert temperature sensor data
        constexpr uint32_t TSENS_CLK_DIV = (8 << 14);  ///< temperature sensor clock divider
        constexpr uint32_t TSENS_PU = (1U << 22);  ///< temperature sensor power up
    }

    /// TSENS_CTRL2 Register bits
    namespace tsens_ctrl2_bits {
        constexpr uint32_t TSENS_XPD_WAIT = (12 << 0);  ///< the time that power up tsens need wait
        constexpr uint32_t TSENS_XPD_FORCE = (2 << 12);  ///< force power up tsens
        constexpr uint32_t TSENS_CLK_INV = (1U << 14);  ///< inv tsens clk
        constexpr uint32_t TSENS_CLK_SEL = (1U << 15);  ///< tsens clk select
    }

    /// CALI Register bits
    namespace cali_bits {
        constexpr uint32_t APB_SARADC_CALI_CFG = (17 << 0);  ///< saradc cali factor
    }

    /// CTRL_DATE Register bits
    namespace ctrl_date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< version
    }

}

// ============================================================================
// ASSIST Peripheral
// ============================================================================

namespace assist {
    /// Base addresses
    constexpr uint32_t ASSIST_DEBUG_BASE = 0x600CE000;

    /// ASSIST Register structure
    struct Registers {
        volatile uint32_t CORE_0_MONTR_ENA;  ///< Offset: 0x00 - ASSIST_DEBUG_C0RE_0_MONTR_ENA_REG
        volatile uint32_t CORE_0_INTR_RAW;  ///< Offset: 0x04 - ASSIST_DEBUG_CORE_0_INTR_RAW_REG
        volatile uint32_t CORE_0_INTR_ENA;  ///< Offset: 0x08 - ASSIST_DEBUG_CORE_0_INTR_ENA_REG
        volatile uint32_t CORE_0_INTR_CLR;  ///< Offset: 0x0C - ASSIST_DEBUG_CORE_0_INTR_CLR_REG
        volatile uint32_t CORE_0_AREA_DRAM0_0_MIN;  ///< Offset: 0x10 - ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_REG
        volatile uint32_t CORE_0_AREA_DRAM0_0_MAX;  ///< Offset: 0x14 - ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_REG
        volatile uint32_t CORE_0_AREA_DRAM0_1_MIN;  ///< Offset: 0x18 - ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_REG
        volatile uint32_t CORE_0_AREA_DRAM0_1_MAX;  ///< Offset: 0x1C - ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_REG
        volatile uint32_t CORE_0_AREA_PIF_0_MIN;  ///< Offset: 0x20 - ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_REG
        volatile uint32_t CORE_0_AREA_PIF_0_MAX;  ///< Offset: 0x24 - ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_REG
        volatile uint32_t CORE_0_AREA_PIF_1_MIN;  ///< Offset: 0x28 - ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_REG
        volatile uint32_t CORE_0_AREA_PIF_1_MAX;  ///< Offset: 0x2C - ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_REG
        volatile uint32_t CORE_0_AREA_PC;  ///< Offset: 0x30 - ASSIST_DEBUG_CORE_0_AREA_PC_REG
        volatile uint32_t CORE_0_AREA_SP;  ///< Offset: 0x34 - ASSIST_DEBUG_CORE_0_AREA_SP_REG
        volatile uint32_t CORE_0_SP_MIN;  ///< Offset: 0x38 - ASSIST_DEBUG_CORE_0_SP_MIN_REG
        volatile uint32_t CORE_0_SP_MAX;  ///< Offset: 0x3C - ASSIST_DEBUG_CORE_0_SP_MAX_REG
        volatile uint32_t CORE_0_SP_PC;  ///< Offset: 0x40 - ASSIST_DEBUG_CORE_0_SP_PC_REG
        volatile uint32_t CORE_0_RCD_EN;  ///< Offset: 0x44 - ASSIST_DEBUG_CORE_0_RCD_EN_REG
        volatile uint32_t CORE_0_RCD_PDEBUGPC;  ///< Offset: 0x48 - ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_REG
        volatile uint32_t CORE_0_RCD_PDEBUGSP;  ///< Offset: 0x4C - ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_REG
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x50 - ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_REG
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x54 - ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_REG
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x58 - ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_REG
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x5C - ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_REG
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0x60 - ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_REG
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0x64 - ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_3_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x68 - ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x6C - ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_REG
        volatile uint32_t LOG_SETTING;  ///< Offset: 0x70 - ASSIST_DEBUG_LOG_SETTING
        volatile uint32_t LOG_DATA_0;  ///< Offset: 0x74 - ASSIST_DEBUG_LOG_DATA_0_REG
        volatile uint32_t LOG_DATA_MASK;  ///< Offset: 0x78 - ASSIST_DEBUG_LOG_DATA_MASK_REG
        volatile uint32_t LOG_MIN;  ///< Offset: 0x7C - ASSIST_DEBUG_LOG_MIN_REG
        volatile uint32_t LOG_MAX;  ///< Offset: 0x80 - ASSIST_DEBUG_LOG_MAX_REG
        volatile uint32_t LOG_MEM_START;  ///< Offset: 0x84 - ASSIST_DEBUG_LOG_MEM_START_REG
        volatile uint32_t LOG_MEM_END;  ///< Offset: 0x88 - ASSIST_DEBUG_LOG_MEM_END_REG
        volatile uint32_t LOG_MEM_WRITING_ADDR;  ///< Offset: 0x8C - ASSIST_DEBUG_LOG_MEM_WRITING_ADDR_REG
        volatile uint32_t LOG_MEM_FULL_FLAG;  ///< Offset: 0x90 - ASSIST_DEBUG_LOG_MEM_FULL_FLAG_REG
        volatile uint32_t C0RE_0_LASTPC_BEFORE_EXCEPTION;  ///< Offset: 0x94 - ASSIST_DEBUG_C0RE_0_LASTPC_BEFORE_EXCEPTION
        volatile uint32_t C0RE_0_DEBUG_MODE;  ///< Offset: 0x98 - ASSIST_DEBUG_C0RE_0_DEBUG_MODE
        volatile uint32_t DATE;  ///< Offset: 0x1FC - ASSIST_DEBUG_DATE_REG
    };

    /// Peripheral instances
    inline Registers* ASSIST_DEBUG = reinterpret_cast<Registers*>(ASSIST_DEBUG_BASE);

    // Bit definitions
    /// CORE_0_MONTR_ENA Register bits
    namespace core_0_montr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< reg_core_0_area_dram0_0_rd_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< reg_core_0_area_dram0_0_wr_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< reg_core_0_area_dram0_1_rd_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< reg_core_0_area_dram0_1_wr_ena
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_ENA = (1U << 4);  ///< reg_core_0_area_pif_0_rd_ena
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_ENA = (1U << 5);  ///< reg_core_0_area_pif_0_wr_ena
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_ENA = (1U << 6);  ///< reg_core_0_area_pif_1_rd_ena
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_ENA = (1U << 7);  ///< reg_core_0_area_pif_1_wr_ena
        constexpr uint32_t CORE_0_SP_SPILL_MIN_ENA = (1U << 8);  ///< reg_core_0_sp_spill_min_ena
        constexpr uint32_t CORE_0_SP_SPILL_MAX_ENA = (1U << 9);  ///< reg_core_0_sp_spill_max_ena
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< reg_core_0_iram0_exception_monitor_ena
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< reg_core_0_dram0_exception_monitor_ena
    }

    /// CORE_0_INTR_RAW Register bits
    namespace core_0_intr_raw_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< reg_core_0_area_dram0_0_rd_raw
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< reg_core_0_area_dram0_0_wr_raw
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< reg_core_0_area_dram0_1_rd_raw
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< reg_core_0_area_dram0_1_wr_raw
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_RAW = (1U << 4);  ///< reg_core_0_area_pif_0_rd_raw
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_RAW = (1U << 5);  ///< reg_core_0_area_pif_0_wr_raw
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_RAW = (1U << 6);  ///< reg_core_0_area_pif_1_rd_raw
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_RAW = (1U << 7);  ///< reg_core_0_area_pif_1_wr_raw
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RAW = (1U << 8);  ///< reg_core_0_sp_spill_min_raw
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RAW = (1U << 9);  ///< reg_core_0_sp_spill_max_raw
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< reg_core_0_iram0_exception_monitor_raw
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< reg_core_0_dram0_exception_monitor_raw
    }

    /// CORE_0_INTR_ENA Register bits
    namespace core_0_intr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_INTR_ENA = (1U << 0);  ///< reg_core_0_area_dram0_0_rd_intr_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_INTR_ENA = (1U << 1);  ///< reg_core_0_area_dram0_0_wr_intr_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_INTR_ENA = (1U << 2);  ///< reg_core_0_area_dram0_1_rd_intr_ena
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_INTR_ENA = (1U << 3);  ///< reg_core_0_area_dram0_1_wr_intr_ena
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_INTR_ENA = (1U << 4);  ///< reg_core_0_area_pif_0_rd_intr_ena
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_INTR_ENA = (1U << 5);  ///< reg_core_0_area_pif_0_wr_intr_ena
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_INTR_ENA = (1U << 6);  ///< reg_core_0_area_pif_1_rd_intr_ena
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_INTR_ENA = (1U << 7);  ///< reg_core_0_area_pif_1_wr_intr_ena
        constexpr uint32_t CORE_0_SP_SPILL_MIN_INTR_ENA = (1U << 8);  ///< reg_core_0_sp_spill_min_intr_ena
        constexpr uint32_t CORE_0_SP_SPILL_MAX_INTR_ENA = (1U << 9);  ///< reg_core_0_sp_spill_max_intr_ena
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RLS = (1U << 10);  ///< reg_core_0_iram0_exception_monitor_ena
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RLS = (1U << 11);  ///< reg_core_0_dram0_exception_monitor_ena
    }

    /// CORE_0_INTR_CLR Register bits
    namespace core_0_intr_clr_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< reg_core_0_area_dram0_0_rd_clr
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< reg_core_0_area_dram0_0_wr_clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< reg_core_0_area_dram0_1_rd_clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< reg_core_0_area_dram0_1_wr_clr
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_CLR = (1U << 4);  ///< reg_core_0_area_pif_0_rd_clr
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_CLR = (1U << 5);  ///< reg_core_0_area_pif_0_wr_clr
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_CLR = (1U << 6);  ///< reg_core_0_area_pif_1_rd_clr
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_CLR = (1U << 7);  ///< reg_core_0_area_pif_1_wr_clr
        constexpr uint32_t CORE_0_SP_SPILL_MIN_CLR = (1U << 8);  ///< reg_core_0_sp_spill_min_clr
        constexpr uint32_t CORE_0_SP_SPILL_MAX_CLR = (1U << 9);  ///< reg_core_0_sp_spill_max_clr
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< reg_core_0_iram0_exception_monitor_clr
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< reg_core_0_dram0_exception_monitor_clr
    }

    /// CORE_0_AREA_DRAM0_0_MIN Register bits
    namespace core_0_area_dram0_0_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MIN = (32 << 0);  ///< reg_core_0_area_dram0_0_min
    }

    /// CORE_0_AREA_DRAM0_0_MAX Register bits
    namespace core_0_area_dram0_0_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MAX = (32 << 0);  ///< reg_core_0_area_dram0_0_max
    }

    /// CORE_0_AREA_DRAM0_1_MIN Register bits
    namespace core_0_area_dram0_1_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MIN = (32 << 0);  ///< reg_core_0_area_dram0_1_min
    }

    /// CORE_0_AREA_DRAM0_1_MAX Register bits
    namespace core_0_area_dram0_1_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MAX = (32 << 0);  ///< reg_core_0_area_dram0_1_max
    }

    /// CORE_0_AREA_PIF_0_MIN Register bits
    namespace core_0_area_pif_0_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MIN = (32 << 0);  ///< reg_core_0_area_pif_0_min
    }

    /// CORE_0_AREA_PIF_0_MAX Register bits
    namespace core_0_area_pif_0_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MAX = (32 << 0);  ///< reg_core_0_area_pif_0_max
    }

    /// CORE_0_AREA_PIF_1_MIN Register bits
    namespace core_0_area_pif_1_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MIN = (32 << 0);  ///< reg_core_0_area_pif_1_min
    }

    /// CORE_0_AREA_PIF_1_MAX Register bits
    namespace core_0_area_pif_1_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MAX = (32 << 0);  ///< reg_core_0_area_pif_1_max
    }

    /// CORE_0_AREA_PC Register bits
    namespace core_0_area_pc_bits {
        constexpr uint32_t CORE_0_AREA_PC = (32 << 0);  ///< reg_core_0_area_pc
    }

    /// CORE_0_AREA_SP Register bits
    namespace core_0_area_sp_bits {
        constexpr uint32_t CORE_0_AREA_SP = (32 << 0);  ///< reg_core_0_area_sp
    }

    /// CORE_0_SP_MIN Register bits
    namespace core_0_sp_min_bits {
        constexpr uint32_t CORE_0_SP_MIN = (32 << 0);  ///< reg_core_0_sp_min
    }

    /// CORE_0_SP_MAX Register bits
    namespace core_0_sp_max_bits {
        constexpr uint32_t CORE_0_SP_MAX = (32 << 0);  ///< reg_core_0_sp_max
    }

    /// CORE_0_SP_PC Register bits
    namespace core_0_sp_pc_bits {
        constexpr uint32_t CORE_0_SP_PC = (32 << 0);  ///< reg_core_0_sp_pc
    }

    /// CORE_0_RCD_EN Register bits
    namespace core_0_rcd_en_bits {
        constexpr uint32_t CORE_0_RCD_RECORDEN = (1U << 0);  ///< reg_core_0_rcd_recorden
        constexpr uint32_t CORE_0_RCD_PDEBUGEN = (1U << 1);  ///< reg_core_0_rcd_pdebugen
    }

    /// CORE_0_RCD_PDEBUGPC Register bits
    namespace core_0_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGPC = (32 << 0);  ///< reg_core_0_rcd_pdebugpc
    }

    /// CORE_0_RCD_PDEBUGSP Register bits
    namespace core_0_rcd_pdebugsp_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGSP = (32 << 0);  ///< reg_core_0_rcd_pdebugsp
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_0
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_0
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_0_dram0_recording_wr_0
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_0 = (4 << 25);  ///< reg_core_0_dram0_recording_byteen_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_0_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_1
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_0_dram0_recording_wr_1
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_1 = (4 << 25);  ///< reg_core_0_dram0_recording_byteen_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_0_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_1
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_x_iram0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_0
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_x_iram0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_1
    }

    /// LOG_SETTING Register bits
    namespace log_setting_bits {
        constexpr uint32_t LOG_ENA = (3 << 0);  ///< reg_log_ena
        constexpr uint32_t LOG_MODE = (4 << 3);  ///< reg_log_mode
        constexpr uint32_t LOG_MEM_LOOP_ENABLE = (1U << 7);  ///< reg_log_mem_loop_enable
    }

    /// LOG_DATA_0 Register bits
    namespace log_data_0_bits {
        constexpr uint32_t LOG_DATA_0 = (32 << 0);  ///< reg_log_data_0
    }

    /// LOG_DATA_MASK Register bits
    namespace log_data_mask_bits {
        constexpr uint32_t LOG_DATA_SIZE = (16 << 0);  ///< reg_log_data_size
    }

    /// LOG_MIN Register bits
    namespace log_min_bits {
        constexpr uint32_t LOG_MIN = (32 << 0);  ///< reg_log_min
    }

    /// LOG_MAX Register bits
    namespace log_max_bits {
        constexpr uint32_t LOG_MAX = (32 << 0);  ///< reg_log_max
    }

    /// LOG_MEM_START Register bits
    namespace log_mem_start_bits {
        constexpr uint32_t LOG_MEM_START = (32 << 0);  ///< reg_log_mem_start
    }

    /// LOG_MEM_END Register bits
    namespace log_mem_end_bits {
        constexpr uint32_t LOG_MEM_END = (32 << 0);  ///< reg_log_mem_end
    }

    /// LOG_MEM_WRITING_ADDR Register bits
    namespace log_mem_writing_addr_bits {
        constexpr uint32_t LOG_MEM_WRITING_ADDR = (32 << 0);  ///< reg_log_mem_writing_addr
    }

    /// LOG_MEM_FULL_FLAG Register bits
    namespace log_mem_full_flag_bits {
        constexpr uint32_t LOG_MEM_FULL_FLAG = (1U << 0);  ///< reg_log_mem_full_flag
        constexpr uint32_t CLR_LOG_MEM_FULL_FLAG = (1U << 1);  ///< reg_clr_log_mem_full_flag
    }

    /// C0RE_0_LASTPC_BEFORE_EXCEPTION Register bits
    namespace c0re_0_lastpc_before_exception_bits {
        constexpr uint32_t CORE_0_LASTPC_BEFORE_EXC = (32 << 0);  ///< reg_core_0_lastpc_before_exc
    }

    /// C0RE_0_DEBUG_MODE Register bits
    namespace c0re_0_debug_mode_bits {
        constexpr uint32_t CORE_0_DEBUG_MODE = (1U << 0);  ///< reg_core_0_debug_mode
        constexpr uint32_t CORE_0_DEBUG_MODULE_ACTIVE = (1U << 1);  ///< reg_core_0_debug_module_active
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t ASSIST_DEBUG_DATE = (28 << 0);  ///< reg_assist_debug_date
    }

}

// ============================================================================
// BB Peripheral
// ============================================================================

namespace bb {
    /// Base addresses
    constexpr uint32_t BB_BASE = 0x6001D000;

    /// BB Register structure
    struct Registers {
        volatile uint32_t BBPD_CTRL;  ///< Offset: 0x54 - Baseband control register
    };

    /// Peripheral instances
    inline Registers* BB = reinterpret_cast<Registers*>(BB_BASE);

    // Bit definitions
    /// BBPD_CTRL Register bits
    namespace bbpd_ctrl_bits {
        constexpr uint32_t DC_EST_FORCE_PD = (1U << 0);  ///< DC_EST_FORCE_PD
        constexpr uint32_t DC_EST_FORCE_PU = (1U << 1);  ///< DC_EST_FORCE_PU
        constexpr uint32_t FFT_FORCE_PD = (1U << 2);  ///< FFT_FORCE_PD
        constexpr uint32_t FFT_FORCE_PU = (1U << 3);  ///< FFT_FORCE_PU
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x6003F000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t INT_RAW_CH0;  ///< Offset: 0x00 - DMA_INT_RAW_CH0_REG.
        volatile uint32_t INT_ST_CH0;  ///< Offset: 0x04 - DMA_INT_ST_CH0_REG.
        volatile uint32_t INT_ENA_CH0;  ///< Offset: 0x08 - DMA_INT_ENA_CH0_REG.
        volatile uint32_t INT_CLR_CH0;  ///< Offset: 0x0C - DMA_INT_CLR_CH0_REG.
        volatile uint32_t INT_RAW_CH1;  ///< Offset: 0x10 - DMA_INT_RAW_CH1_REG.
        volatile uint32_t INT_ST_CH1;  ///< Offset: 0x14 - DMA_INT_ST_CH1_REG.
        volatile uint32_t INT_ENA_CH1;  ///< Offset: 0x18 - DMA_INT_ENA_CH1_REG.
        volatile uint32_t INT_CLR_CH1;  ///< Offset: 0x1C - DMA_INT_CLR_CH1_REG.
        volatile uint32_t INT_RAW_CH2;  ///< Offset: 0x20 - DMA_INT_RAW_CH2_REG.
        volatile uint32_t INT_ST_CH2;  ///< Offset: 0x24 - DMA_INT_ST_CH2_REG.
        volatile uint32_t INT_ENA_CH2;  ///< Offset: 0x28 - DMA_INT_ENA_CH2_REG.
        volatile uint32_t INT_CLR_CH2;  ///< Offset: 0x2C - DMA_INT_CLR_CH2_REG.
        volatile uint32_t AHB_TEST;  ///< Offset: 0x40 - DMA_AHB_TEST_REG.
        volatile uint32_t MISC_CONF;  ///< Offset: 0x44 - DMA_MISC_CONF_REG.
        volatile uint32_t DATE;  ///< Offset: 0x48 - DMA_DATE_REG.
        volatile uint32_t IN_CONF0_CH0;  ///< Offset: 0x70 - DMA_IN_CONF0_CH0_REG.
        volatile uint32_t IN_CONF1_CH0;  ///< Offset: 0x74 - DMA_IN_CONF1_CH0_REG.
        volatile uint32_t INFIFO_STATUS_CH0;  ///< Offset: 0x78 - DMA_INFIFO_STATUS_CH0_REG.
        volatile uint32_t IN_POP_CH0;  ///< Offset: 0x7C - DMA_IN_POP_CH0_REG.
        volatile uint32_t IN_LINK_CH0;  ///< Offset: 0x80 - DMA_IN_LINK_CH0_REG.
        volatile uint32_t IN_STATE_CH0;  ///< Offset: 0x84 - DMA_IN_STATE_CH0_REG.
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH0;  ///< Offset: 0x88 - DMA_IN_SUC_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH0;  ///< Offset: 0x8C - DMA_IN_ERR_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t IN_DSCR_CH0;  ///< Offset: 0x90 - DMA_IN_DSCR_CH0_REG.
        volatile uint32_t IN_DSCR_BF0_CH0;  ///< Offset: 0x94 - DMA_IN_DSCR_BF0_CH0_REG.
        volatile uint32_t IN_DSCR_BF1_CH0;  ///< Offset: 0x98 - DMA_IN_DSCR_BF1_CH0_REG.
        volatile uint32_t IN_PRI_CH0;  ///< Offset: 0x9C - DMA_IN_PRI_CH0_REG.
        volatile uint32_t IN_PERI_SEL_CH0;  ///< Offset: 0xA0 - DMA_IN_PERI_SEL_CH0_REG.
        volatile uint32_t OUT_CONF0_CH0;  ///< Offset: 0xD0 - DMA_OUT_CONF0_CH0_REG.
        volatile uint32_t OUT_CONF1_CH0;  ///< Offset: 0xD4 - DMA_OUT_CONF1_CH0_REG.
        volatile uint32_t OUTFIFO_STATUS_CH0;  ///< Offset: 0xD8 - DMA_OUTFIFO_STATUS_CH0_REG.
        volatile uint32_t OUT_PUSH_CH0;  ///< Offset: 0xDC - DMA_OUT_PUSH_CH0_REG.
        volatile uint32_t OUT_LINK_CH0;  ///< Offset: 0xE0 - DMA_OUT_LINK_CH0_REG.
        volatile uint32_t OUT_STATE_CH0;  ///< Offset: 0xE4 - DMA_OUT_STATE_CH0_REG.
        volatile uint32_t OUT_EOF_DES_ADDR_CH0;  ///< Offset: 0xE8 - DMA_OUT_EOF_DES_ADDR_CH0_REG.
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH0;  ///< Offset: 0xEC - DMA_OUT_EOF_BFR_DES_ADDR_CH0_REG.
        volatile uint32_t OUT_DSCR_CH0;  ///< Offset: 0xF0 - DMA_OUT_DSCR_CH0_REG.
        volatile uint32_t OUT_DSCR_BF0_CH0;  ///< Offset: 0xF4 - DMA_OUT_DSCR_BF0_CH0_REG.
        volatile uint32_t OUT_DSCR_BF1_CH0;  ///< Offset: 0xF8 - DMA_OUT_DSCR_BF1_CH0_REG.
        volatile uint32_t OUT_PRI_CH0;  ///< Offset: 0xFC - DMA_OUT_PRI_CH0_REG.
        volatile uint32_t OUT_PERI_SEL_CH0;  ///< Offset: 0x100 - DMA_OUT_PERI_SEL_CH0_REG.
        volatile uint32_t IN_CONF0_CH1;  ///< Offset: 0x130 - DMA_IN_CONF0_CH1_REG.
        volatile uint32_t IN_CONF1_CH1;  ///< Offset: 0x134 - DMA_IN_CONF1_CH1_REG.
        volatile uint32_t INFIFO_STATUS_CH1;  ///< Offset: 0x138 - DMA_INFIFO_STATUS_CH1_REG.
        volatile uint32_t IN_POP_CH1;  ///< Offset: 0x13C - DMA_IN_POP_CH1_REG.
        volatile uint32_t IN_LINK_CH1;  ///< Offset: 0x140 - DMA_IN_LINK_CH1_REG.
        volatile uint32_t IN_STATE_CH1;  ///< Offset: 0x144 - DMA_IN_STATE_CH1_REG.
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH1;  ///< Offset: 0x148 - DMA_IN_SUC_EOF_DES_ADDR_CH1_REG.
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH1;  ///< Offset: 0x14C - DMA_IN_ERR_EOF_DES_ADDR_CH1_REG.
        volatile uint32_t IN_DSCR_CH1;  ///< Offset: 0x150 - DMA_IN_DSCR_CH1_REG.
        volatile uint32_t IN_DSCR_BF0_CH1;  ///< Offset: 0x154 - DMA_IN_DSCR_BF0_CH1_REG.
        volatile uint32_t IN_DSCR_BF1_CH1;  ///< Offset: 0x158 - DMA_IN_DSCR_BF1_CH1_REG.
        volatile uint32_t IN_PRI_CH1;  ///< Offset: 0x15C - DMA_IN_PRI_CH1_REG.
        volatile uint32_t IN_PERI_SEL_CH1;  ///< Offset: 0x160 - DMA_IN_PERI_SEL_CH1_REG.
        volatile uint32_t OUT_CONF0_CH1;  ///< Offset: 0x190 - DMA_OUT_CONF0_CH1_REG.
        volatile uint32_t OUT_CONF1_CH1;  ///< Offset: 0x194 - DMA_OUT_CONF1_CH1_REG.
        volatile uint32_t OUTFIFO_STATUS_CH1;  ///< Offset: 0x198 - DMA_OUTFIFO_STATUS_CH1_REG.
        volatile uint32_t OUT_PUSH_CH1;  ///< Offset: 0x19C - DMA_OUT_PUSH_CH1_REG.
        volatile uint32_t OUT_LINK_CH1;  ///< Offset: 0x1A0 - DMA_OUT_LINK_CH1_REG.
        volatile uint32_t OUT_STATE_CH1;  ///< Offset: 0x1A4 - DMA_OUT_STATE_CH1_REG.
        volatile uint32_t OUT_EOF_DES_ADDR_CH1;  ///< Offset: 0x1A8 - DMA_OUT_EOF_DES_ADDR_CH1_REG.
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH1;  ///< Offset: 0x1AC - DMA_OUT_EOF_BFR_DES_ADDR_CH1_REG.
        volatile uint32_t OUT_DSCR_CH1;  ///< Offset: 0x1B0 - DMA_OUT_DSCR_CH1_REG.
        volatile uint32_t OUT_DSCR_BF0_CH1;  ///< Offset: 0x1B4 - DMA_OUT_DSCR_BF0_CH1_REG.
        volatile uint32_t OUT_DSCR_BF1_CH1;  ///< Offset: 0x1B8 - DMA_OUT_DSCR_BF1_CH1_REG.
        volatile uint32_t OUT_PRI_CH1;  ///< Offset: 0x1BC - DMA_OUT_PRI_CH1_REG.
        volatile uint32_t OUT_PERI_SEL_CH1;  ///< Offset: 0x1C0 - DMA_OUT_PERI_SEL_CH1_REG.
        volatile uint32_t IN_CONF0_CH2;  ///< Offset: 0x1F0 - DMA_IN_CONF0_CH2_REG.
        volatile uint32_t IN_CONF1_CH2;  ///< Offset: 0x1F4 - DMA_IN_CONF1_CH2_REG.
        volatile uint32_t INFIFO_STATUS_CH2;  ///< Offset: 0x1F8 - DMA_INFIFO_STATUS_CH2_REG.
        volatile uint32_t IN_POP_CH2;  ///< Offset: 0x1FC - DMA_IN_POP_CH2_REG.
        volatile uint32_t IN_LINK_CH2;  ///< Offset: 0x200 - DMA_IN_LINK_CH2_REG.
        volatile uint32_t IN_STATE_CH2;  ///< Offset: 0x204 - DMA_IN_STATE_CH2_REG.
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH2;  ///< Offset: 0x208 - DMA_IN_SUC_EOF_DES_ADDR_CH2_REG.
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH2;  ///< Offset: 0x20C - DMA_IN_ERR_EOF_DES_ADDR_CH2_REG.
        volatile uint32_t IN_DSCR_CH2;  ///< Offset: 0x210 - DMA_IN_DSCR_CH2_REG.
        volatile uint32_t IN_DSCR_BF0_CH2;  ///< Offset: 0x214 - DMA_IN_DSCR_BF0_CH2_REG.
        volatile uint32_t IN_DSCR_BF1_CH2;  ///< Offset: 0x218 - DMA_IN_DSCR_BF1_CH2_REG.
        volatile uint32_t IN_PRI_CH2;  ///< Offset: 0x21C - DMA_IN_PRI_CH2_REG.
        volatile uint32_t IN_PERI_SEL_CH2;  ///< Offset: 0x220 - DMA_IN_PERI_SEL_CH2_REG.
        volatile uint32_t OUT_CONF0_CH2;  ///< Offset: 0x250 - DMA_OUT_CONF0_CH2_REG.
        volatile uint32_t OUT_CONF1_CH2;  ///< Offset: 0x254 - DMA_OUT_CONF1_CH2_REG.
        volatile uint32_t OUTFIFO_STATUS_CH2;  ///< Offset: 0x258 - DMA_OUTFIFO_STATUS_CH2_REG.
        volatile uint32_t OUT_PUSH_CH2;  ///< Offset: 0x25C - DMA_OUT_PUSH_CH2_REG.
        volatile uint32_t OUT_LINK_CH2;  ///< Offset: 0x260 - DMA_OUT_LINK_CH2_REG.
        volatile uint32_t OUT_STATE_CH2;  ///< Offset: 0x264 - DMA_OUT_STATE_CH2_REG.
        volatile uint32_t OUT_EOF_DES_ADDR_CH2;  ///< Offset: 0x268 - DMA_OUT_EOF_DES_ADDR_CH2_REG.
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH2;  ///< Offset: 0x26C - DMA_OUT_EOF_BFR_DES_ADDR_CH2_REG.
        volatile uint32_t OUT_DSCR_CH2;  ///< Offset: 0x270 - DMA_OUT_DSCR_CH2_REG.
        volatile uint32_t OUT_DSCR_BF0_CH2;  ///< Offset: 0x274 - DMA_OUT_DSCR_BF0_CH2_REG.
        volatile uint32_t OUT_DSCR_BF1_CH2;  ///< Offset: 0x278 - DMA_OUT_DSCR_BF1_CH2_REG.
        volatile uint32_t OUT_PRI_CH2;  ///< Offset: 0x27C - DMA_OUT_PRI_CH2_REG.
        volatile uint32_t OUT_PERI_SEL_CH2;  ///< Offset: 0x280 - DMA_OUT_PERI_SEL_CH2_REG.
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// INT_RAW_CH0 Register bits
    namespace int_raw_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0, the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals, this raw interrupt is reserved.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error, including owner error, the second and third word error of inlink descriptor for Rx channel 0.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error, including owner error, the second and third word error of outlink descriptor for Tx channel 0.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed, but there is no more inlink for Rx channel 0.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
    }

    /// INT_ST_CH0 Register bits
    namespace int_st_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_ENA_CH0 Register bits
    namespace int_ena_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_CLR_CH0 Register bits
    namespace int_clr_ch0_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_RAW_CH1 Register bits
    namespace int_raw_ch1_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 1.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 1. For UHCI0, the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 1.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 1. For other peripherals, this raw interrupt is reserved.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 1.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 1.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error, including owner error, the second and third word error of inlink descriptor for Rx channel 1.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error, including owner error, the second and third word error of outlink descriptor for Tx channel 1.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed, but there is no more inlink for Rx channel 1.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 1.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 1 is overflow.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 1 is underflow.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 1 is overflow.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 1 is underflow.
    }

    /// INT_ST_CH1 Register bits
    namespace int_st_ch1_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_ENA_CH1 Register bits
    namespace int_ena_ch1_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_CLR_CH1 Register bits
    namespace int_clr_ch1_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_RAW_CH2 Register bits
    namespace int_raw_ch2_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 2.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 2. For UHCI0, the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 2.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 2. For other peripherals, this raw interrupt is reserved.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 2.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 2.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error, including owner error, the second and third word error of inlink descriptor for Rx channel 2.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error, including owner error, the second and third word error of outlink descriptor for Tx channel 2.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed, but there is no more inlink for Rx channel 2.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 2.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 2 is overflow.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 2 is underflow.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 2 is overflow.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 2 is underflow.
    }

    /// INT_ST_CH2 Register bits
    namespace int_st_ch2_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_ENA_CH2 Register bits
    namespace int_ena_ch2_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// INT_CLR_CH2 Register bits
    namespace int_clr_ch2_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DONE = (1U << 3);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 4);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 5);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 6);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 7);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 8);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 9);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 10);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 11);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 12);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< reserved
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< reserved
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t AHBM_RST_INTER = (1U << 0);  ///< Set this bit, then clear this bit to reset the internal ahb FSM.
        constexpr uint32_t ARB_PRI_DIS = (1U << 2);  ///< Set this bit to disable priority arbitration function.
        constexpr uint32_t CLK_EN = (1U << 3);  ///< reg_clk_en
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

    /// IN_CONF0_CH0 Register bits
    namespace in_conf0_ch0_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
    }

    /// IN_CONF1_CH0 Register bits
    namespace in_conf1_ch0_bits {
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH0 Register bits
    namespace infifo_status_ch0_bits {
        constexpr uint32_t INFIFO_FULL = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
        constexpr uint32_t IN_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH0 Register bits
    namespace in_pop_ch0_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH0 Register bits
    namespace in_link_ch0_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address, when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH0 Register bits
    namespace in_state_ch0_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH0 Register bits
    namespace in_suc_eof_des_addr_ch0_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH0 Register bits
    namespace in_err_eof_des_addr_ch0_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH0 Register bits
    namespace in_dscr_ch0_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH0 Register bits
    namespace in_dscr_bf0_ch0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH0 Register bits
    namespace in_dscr_bf1_ch0_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH0 Register bits
    namespace in_pri_ch0_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 0. The larger of the value, the higher of the priority.
    }

    /// IN_PERI_SEL_CH0 Register bits
    namespace in_peri_sel_ch0_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// OUT_CONF0_CH0 Register bits
    namespace out_conf0_ch0_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 0 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 transmitting data when accessing internal SRAM.
    }

    /// OUT_CONF1_CH0 Register bits
    namespace out_conf1_ch0_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH0 Register bits
    namespace outfifo_status_ch0_bits {
        constexpr uint32_t OUTFIFO_FULL = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUT_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH0 Register bits
    namespace out_push_ch0_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH0 Register bits
    namespace out_link_ch0_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH0 Register bits
    namespace out_state_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH0 Register bits
    namespace out_eof_des_addr_ch0_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH0 Register bits
    namespace out_eof_bfr_des_addr_ch0_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH0 Register bits
    namespace out_dscr_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH0 Register bits
    namespace out_dscr_bf0_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH0 Register bits
    namespace out_dscr_bf1_ch0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH0 Register bits
    namespace out_pri_ch0_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 0. The larger of the value, the higher of the priority.
    }

    /// OUT_PERI_SEL_CH0 Register bits
    namespace out_peri_sel_ch0_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// IN_CONF0_CH1 Register bits
    namespace in_conf0_ch1_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 1 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 1 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 1 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
    }

    /// IN_CONF1_CH1 Register bits
    namespace in_conf1_ch1_bits {
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH1 Register bits
    namespace infifo_status_ch1_bits {
        constexpr uint32_t INFIFO_FULL = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 1.
        constexpr uint32_t INFIFO_EMPTY = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 1.
        constexpr uint32_t INFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 1.
        constexpr uint32_t IN_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH1 Register bits
    namespace in_pop_ch1_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH1 Register bits
    namespace in_link_ch1_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address, when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH1 Register bits
    namespace in_state_ch1_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH1 Register bits
    namespace in_suc_eof_des_addr_ch1_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH1 Register bits
    namespace in_err_eof_des_addr_ch1_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH1 Register bits
    namespace in_dscr_ch1_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH1 Register bits
    namespace in_dscr_bf0_ch1_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH1 Register bits
    namespace in_dscr_bf1_ch1_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH1 Register bits
    namespace in_pri_ch1_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 1. The larger of the value, the higher of the priority.
    }

    /// IN_PERI_SEL_CH1 Register bits
    namespace in_peri_sel_ch1_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 1. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// OUT_CONF0_CH1 Register bits
    namespace out_conf0_ch1_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
    }

    /// OUT_CONF1_CH1 Register bits
    namespace out_conf1_ch1_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH1 Register bits
    namespace outfifo_status_ch1_bits {
        constexpr uint32_t OUTFIFO_FULL = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 1.
        constexpr uint32_t OUTFIFO_EMPTY = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 1.
        constexpr uint32_t OUTFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 1.
        constexpr uint32_t OUT_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH1 Register bits
    namespace out_push_ch1_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH1 Register bits
    namespace out_link_ch1_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH1 Register bits
    namespace out_state_ch1_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH1 Register bits
    namespace out_eof_des_addr_ch1_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH1 Register bits
    namespace out_eof_bfr_des_addr_ch1_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH1 Register bits
    namespace out_dscr_ch1_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH1 Register bits
    namespace out_dscr_bf0_ch1_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH1 Register bits
    namespace out_dscr_bf1_ch1_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH1 Register bits
    namespace out_pri_ch1_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 1. The larger of the value, the higher of the priority.
    }

    /// OUT_PERI_SEL_CH1 Register bits
    namespace out_peri_sel_ch1_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 1. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// IN_CONF0_CH2 Register bits
    namespace in_conf0_ch2_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 2 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 2 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 2 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
    }

    /// IN_CONF1_CH2 Register bits
    namespace in_conf1_ch2_bits {
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH2 Register bits
    namespace infifo_status_ch2_bits {
        constexpr uint32_t INFIFO_FULL = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 2.
        constexpr uint32_t INFIFO_EMPTY = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 2.
        constexpr uint32_t INFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 2.
        constexpr uint32_t IN_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH2 Register bits
    namespace in_pop_ch2_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH2 Register bits
    namespace in_link_ch2_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address, when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH2 Register bits
    namespace in_state_ch2_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH2 Register bits
    namespace in_suc_eof_des_addr_ch2_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH2 Register bits
    namespace in_err_eof_des_addr_ch2_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH2 Register bits
    namespace in_dscr_ch2_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH2 Register bits
    namespace in_dscr_bf0_ch2_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH2 Register bits
    namespace in_dscr_bf1_ch2_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH2 Register bits
    namespace in_pri_ch2_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 2. The larger of the value, the higher of the priority.
    }

    /// IN_PERI_SEL_CH2 Register bits
    namespace in_peri_sel_ch2_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 2. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

    /// OUT_CONF0_CH2 Register bits
    namespace out_conf0_ch2_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 2 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 2 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 2 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 2 transmitting data when accessing internal SRAM.
    }

    /// OUT_CONF1_CH2 Register bits
    namespace out_conf1_ch2_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH2 Register bits
    namespace outfifo_status_ch2_bits {
        constexpr uint32_t OUTFIFO_FULL = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 2.
        constexpr uint32_t OUTFIFO_EMPTY = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 2.
        constexpr uint32_t OUTFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 2.
        constexpr uint32_t OUT_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH2 Register bits
    namespace out_push_ch2_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH2 Register bits
    namespace out_link_ch2_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH2 Register bits
    namespace out_state_ch2_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH2 Register bits
    namespace out_eof_des_addr_ch2_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH2 Register bits
    namespace out_eof_bfr_des_addr_ch2_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH2 Register bits
    namespace out_dscr_ch2_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH2 Register bits
    namespace out_dscr_bf0_ch2_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH2 Register bits
    namespace out_dscr_bf1_ch2_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH2 Register bits
    namespace out_pri_ch2_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 2. The larger of the value, the higher of the priority.
    }

    /// OUT_PERI_SEL_CH2 Register bits
    namespace out_peri_sel_ch2_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 2. 0:SPI2. 1: reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8: ADC_DAC.
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x6003D000;

    /// DS Register structure
    struct Registers {
        volatile uint32_t Y_MEM__;  ///< Offset: 0x00 - memory that stores Y (renamed from Y_MEM__)
        volatile uint32_t M_MEM__;  ///< Offset: 0x200 - memory that stores M (renamed from M_MEM__)
        volatile uint32_t RB_MEM__;  ///< Offset: 0x400 - memory that stores Rb (renamed from RB_MEM__)
        volatile uint32_t BOX_MEM__;  ///< Offset: 0x600 - memory that stores BOX (renamed from BOX_MEM__)
        volatile uint32_t X_MEM__;  ///< Offset: 0x800 - memory that stores X (renamed from X_MEM__)
        volatile uint32_t Z_MEM__;  ///< Offset: 0xA00 - memory that stores Z (renamed from Z_MEM__)
        volatile uint32_t SET_START;  ///< Offset: 0xE00 - DS start control register
        volatile uint32_t SET_CONTINUE;  ///< Offset: 0xE04 - DS continue control register
        volatile uint32_t SET_FINISH;  ///< Offset: 0xE08 - DS finish control register
        volatile uint32_t QUERY_BUSY;  ///< Offset: 0xE0C - DS query busy register
        volatile uint32_t QUERY_KEY_WRONG;  ///< Offset: 0xE10 - DS query key-wrong counter register
        volatile uint32_t QUERY_CHECK;  ///< Offset: 0xE14 - DS query check result register
        volatile uint32_t DATE;  ///< Offset: 0xE20 - DS version control register
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// SET_START Register bits
    namespace set_start_bits {
        constexpr uint32_t SET_START = (1U << 0);  ///< set this bit to start DS operation.
    }

    /// SET_CONTINUE Register bits
    namespace set_continue_bits {
        constexpr uint32_t SET_CONTINUE = (1U << 0);  ///< set this bit to continue DS operation.
    }

    /// SET_FINISH Register bits
    namespace set_finish_bits {
        constexpr uint32_t SET_FINISH = (1U << 0);  ///< Set this bit to finish DS process.
    }

    /// QUERY_BUSY Register bits
    namespace query_busy_bits {
        constexpr uint32_t QUERY_BUSY = (1U << 0);  ///< digital signature state. 1'b0: idle, 1'b1: busy
    }

    /// QUERY_KEY_WRONG Register bits
    namespace query_key_wrong_bits {
        constexpr uint32_t QUERY_KEY_WRONG = (4 << 0);  ///< digital signature key wrong counter
    }

    /// QUERY_CHECK Register bits
    namespace query_check_bits {
        constexpr uint32_t MD_ERROR = (1U << 0);  ///< MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
        constexpr uint32_t PADDING_BAD = (1U << 1);  ///< padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< ds version information
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x60008800;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA0;  ///< Offset: 0x00 - Register 0 that stores data to be programmed.
        volatile uint32_t PGM_DATA1;  ///< Offset: 0x04 - Register 1 that stores data to be programmed.
        volatile uint32_t PGM_DATA2;  ///< Offset: 0x08 - Register 2 that stores data to be programmed.
        volatile uint32_t PGM_DATA3;  ///< Offset: 0x0C - Register 3 that stores data to be programmed.
        volatile uint32_t PGM_DATA4;  ///< Offset: 0x10 - Register 4 that stores data to be programmed.
        volatile uint32_t PGM_DATA5;  ///< Offset: 0x14 - Register 5 that stores data to be programmed.
        volatile uint32_t PGM_DATA6;  ///< Offset: 0x18 - Register 6 that stores data to be programmed.
        volatile uint32_t PGM_DATA7;  ///< Offset: 0x1C - Register 7 that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE0;  ///< Offset: 0x20 - Register 0 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE1;  ///< Offset: 0x24 - Register 1 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE2;  ///< Offset: 0x28 - Register 2 that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - BLOCK0 data register 0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - BLOCK0 data register 1.
        volatile uint32_t RD_REPEAT_DATA1;  ///< Offset: 0x34 - BLOCK0 data register 2.
        volatile uint32_t RD_REPEAT_DATA2;  ///< Offset: 0x38 - BLOCK0 data register 3.
        volatile uint32_t RD_REPEAT_DATA3;  ///< Offset: 0x3C - BLOCK0 data register 4.
        volatile uint32_t RD_REPEAT_DATA4;  ///< Offset: 0x40 - BLOCK0 data register 5.
        volatile uint32_t RD_MAC_SPI_SYS_0;  ///< Offset: 0x44 - BLOCK1 data register 0.
        volatile uint32_t RD_MAC_SPI_SYS_1;  ///< Offset: 0x48 - BLOCK1 data register 1.
        volatile uint32_t RD_MAC_SPI_SYS_2;  ///< Offset: 0x4C - BLOCK1 data register 2.
        volatile uint32_t RD_MAC_SPI_SYS_3;  ///< Offset: 0x50 - BLOCK1 data register 3.
        volatile uint32_t RD_MAC_SPI_SYS_4;  ///< Offset: 0x54 - BLOCK1 data register 4.
        volatile uint32_t RD_MAC_SPI_SYS_5;  ///< Offset: 0x58 - BLOCK1 data register 5.
        volatile uint32_t RD_SYS_PART1_DATA0;  ///< Offset: 0x5C - Register 0 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA1;  ///< Offset: 0x60 - Register 1 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA2;  ///< Offset: 0x64 - Register 2 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA3;  ///< Offset: 0x68 - Register 3 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA4;  ///< Offset: 0x6C - Register 4 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA5;  ///< Offset: 0x70 - Register 5 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA6;  ///< Offset: 0x74 - Register 6 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA7;  ///< Offset: 0x78 - Register 7 of BLOCK2 (system).
        volatile uint32_t RD_USR_DATA0;  ///< Offset: 0x7C - Register 0 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA1;  ///< Offset: 0x80 - Register 1 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA2;  ///< Offset: 0x84 - Register 2 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA3;  ///< Offset: 0x88 - Register 3 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA4;  ///< Offset: 0x8C - Register 4 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA5;  ///< Offset: 0x90 - Register 5 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA6;  ///< Offset: 0x94 - Register 6 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA7;  ///< Offset: 0x98 - Register 7 of BLOCK3 (user).
        volatile uint32_t RD_KEY0_DATA0;  ///< Offset: 0x9C - Register 0 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA1;  ///< Offset: 0xA0 - Register 1 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA2;  ///< Offset: 0xA4 - Register 2 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA3;  ///< Offset: 0xA8 - Register 3 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA4;  ///< Offset: 0xAC - Register 4 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA5;  ///< Offset: 0xB0 - Register 5 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA6;  ///< Offset: 0xB4 - Register 6 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA7;  ///< Offset: 0xB8 - Register 7 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY1_DATA0;  ///< Offset: 0xBC - Register 0 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA1;  ///< Offset: 0xC0 - Register 1 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA2;  ///< Offset: 0xC4 - Register 2 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA3;  ///< Offset: 0xC8 - Register 3 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA4;  ///< Offset: 0xCC - Register 4 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA5;  ///< Offset: 0xD0 - Register 5 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA6;  ///< Offset: 0xD4 - Register 6 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA7;  ///< Offset: 0xD8 - Register 7 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY2_DATA0;  ///< Offset: 0xDC - Register 0 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA1;  ///< Offset: 0xE0 - Register 1 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA2;  ///< Offset: 0xE4 - Register 2 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA3;  ///< Offset: 0xE8 - Register 3 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA4;  ///< Offset: 0xEC - Register 4 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA5;  ///< Offset: 0xF0 - Register 5 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA6;  ///< Offset: 0xF4 - Register 6 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA7;  ///< Offset: 0xF8 - Register 7 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY3_DATA0;  ///< Offset: 0xFC - Register 0 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA1;  ///< Offset: 0x100 - Register 1 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA2;  ///< Offset: 0x104 - Register 2 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA3;  ///< Offset: 0x108 - Register 3 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA4;  ///< Offset: 0x10C - Register 4 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA5;  ///< Offset: 0x110 - Register 5 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA6;  ///< Offset: 0x114 - Register 6 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA7;  ///< Offset: 0x118 - Register 7 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY4_DATA0;  ///< Offset: 0x11C - Register 0 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA1;  ///< Offset: 0x120 - Register 1 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA2;  ///< Offset: 0x124 - Register 2 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA3;  ///< Offset: 0x128 - Register 3 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA4;  ///< Offset: 0x12C - Register 4 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA5;  ///< Offset: 0x130 - Register 5 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA6;  ///< Offset: 0x134 - Register 6 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA7;  ///< Offset: 0x138 - Register 7 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY5_DATA0;  ///< Offset: 0x13C - Register 0 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA1;  ///< Offset: 0x140 - Register 1 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA2;  ///< Offset: 0x144 - Register 2 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA3;  ///< Offset: 0x148 - Register 3 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA4;  ///< Offset: 0x14C - Register 4 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA5;  ///< Offset: 0x150 - Register 5 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA6;  ///< Offset: 0x154 - Register 6 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA7;  ///< Offset: 0x158 - Register 7 of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA0;  ///< Offset: 0x15C - Register 0 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA1;  ///< Offset: 0x160 - Register 1 of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA2;  ///< Offset: 0x164 - Register 2 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA3;  ///< Offset: 0x168 - Register 3 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA4;  ///< Offset: 0x16C - Register 4 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA5;  ///< Offset: 0x170 - Register 5 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA6;  ///< Offset: 0x174 - Register 6 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA7;  ///< Offset: 0x178 - Register 7 of BLOCK10 (system).
        volatile uint32_t RD_REPEAT_ERR0;  ///< Offset: 0x17C - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR1;  ///< Offset: 0x180 - Programming error record register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR2;  ///< Offset: 0x184 - Programming error record register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR3;  ///< Offset: 0x188 - Programming error record register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR4;  ///< Offset: 0x190 - Programming error record register 4 of BLOCK0.
        volatile uint32_t RD_RS_ERR0;  ///< Offset: 0x1C0 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t RD_RS_ERR1;  ///< Offset: 0x1C4 - Programming error record register 1 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x1C8 - eFuse clock configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x1CC - eFuse operation mode configuration register.
        volatile uint32_t STATUS;  ///< Offset: 0x1D0 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x1D4 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1D8 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x1DC - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x1E0 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x1E4 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x1E8 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x1EC - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x1F0 - Configuration register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x1F4 - Configuration register 2 of eFuse programming timing parameters.
        volatile uint32_t DATE;  ///< Offset: 0x1FC - eFuse version register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA0 Register bits
    namespace pgm_data0_bits {
        constexpr uint32_t PGM_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit data to be programmed.
    }

    /// PGM_DATA1 Register bits
    namespace pgm_data1_bits {
        constexpr uint32_t PGM_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit data to be programmed.
    }

    /// PGM_DATA2 Register bits
    namespace pgm_data2_bits {
        constexpr uint32_t PGM_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit data to be programmed.
    }

    /// PGM_DATA3 Register bits
    namespace pgm_data3_bits {
        constexpr uint32_t PGM_DATA_3 = (32 << 0);  ///< The content of the 3rd 32-bit data to be programmed.
    }

    /// PGM_DATA4 Register bits
    namespace pgm_data4_bits {
        constexpr uint32_t PGM_DATA_4 = (32 << 0);  ///< The content of the 4th 32-bit data to be programmed.
    }

    /// PGM_DATA5 Register bits
    namespace pgm_data5_bits {
        constexpr uint32_t PGM_DATA_5 = (32 << 0);  ///< The content of the 5th 32-bit data to be programmed.
    }

    /// PGM_DATA6 Register bits
    namespace pgm_data6_bits {
        constexpr uint32_t PGM_DATA_6 = (32 << 0);  ///< The content of the 6th 32-bit data to be programmed.
    }

    /// PGM_DATA7 Register bits
    namespace pgm_data7_bits {
        constexpr uint32_t PGM_DATA_7 = (32 << 0);  ///< The content of the 7th 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE0 Register bits
    namespace pgm_check_value0_bits {
        constexpr uint32_t PGM_RS_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE1 Register bits
    namespace pgm_check_value1_bits {
        constexpr uint32_t PGM_RS_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE2 Register bits
    namespace pgm_check_value2_bits {
        constexpr uint32_t PGM_RS_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (32 << 0);  ///< Disable programming of individual eFuses.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (7 << 0);  ///< Set this bit to disable reading from BlOCK4-10.
        constexpr uint32_t DIS_RTC_RAM_BOOT = (1U << 7);  ///< Set this bit to disable boot from RTC RAM.
        constexpr uint32_t DIS_ICACHE = (1U << 8);  ///< Set this bit to disable Icache.
        constexpr uint32_t DIS_USB_JTAG = (1U << 9);  ///< Set this bit to disable function of usb switch to jtag in module of usb device.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE = (1U << 10);  ///< Set this bit to disable Icache in download mode (boot_mode[3:0] is 0, 1, 2, 3, 6, 7).
        constexpr uint32_t DIS_USB_DEVICE = (1U << 11);  ///< Set this bit to disable usb device.
        constexpr uint32_t DIS_FORCE_DOWNLOAD = (1U << 12);  ///< Set this bit to disable the function that forces chip into download mode.
        constexpr uint32_t RPT4_RESERVED6 = (1U << 13);  ///< Reserved (used for four backups method).
        constexpr uint32_t DIS_CAN = (1U << 14);  ///< Set this bit to disable CAN function.
        constexpr uint32_t JTAG_SEL_ENABLE = (1U << 15);  ///< Set this bit to enable selection between usb_to_jtag and pad_to_jtag through strapping gpio10 when both reg_dis_usb_jtag and reg_dis_pad_jtag are equal to 0.
        constexpr uint32_t SOFT_DIS_JTAG = (3 << 16);  ///< Set these bits to disable JTAG in the soft way (odd number 1 means disable ). JTAG can be enabled in HMAC module.
        constexpr uint32_t DIS_PAD_JTAG = (1U << 19);  ///< Set this bit to disable JTAG in the hard way. JTAG is disabled permanently.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 20);  ///< Set this bit to disable flash encryption when in download boot modes.
        constexpr uint32_t USB_DREFH = (2 << 21);  ///< Controls single-end input threshold vrefh, 1.76 V to 2 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_DREFL = (2 << 23);  ///< Controls single-end input threshold vrefl, 0.8 V to 1.04 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_EXCHG_PINS = (1U << 25);  ///< Set this bit to exchange USB D+ and D- pins.
        constexpr uint32_t VDD_SPI_AS_GPIO = (1U << 26);  ///< Set this bit to vdd spi pin function as gpio.
        constexpr uint32_t BTLC_GPIO_ENABLE = (2 << 27);  ///< Enable btlc gpio.
        constexpr uint32_t POWERGLITCH_EN = (1U << 29);  ///< Set this bit to enable power glitch function.
        constexpr uint32_t POWER_GLITCH_DSENSE = (2 << 30);  ///< Sample delay configuration of power glitch.
    }

    /// RD_REPEAT_DATA1 Register bits
    namespace rd_repeat_data1_bits {
        constexpr uint32_t RPT4_RESERVED2 = (16 << 0);  ///< Reserved (used for four backups method).
        constexpr uint32_t WDT_DELAY_SEL = (2 << 16);  ///< Selects RTC watchdog timeout threshold, in unit of slow clock cycle. 0: 40000. 1: 80000. 2: 160000. 3:320000.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT = (3 << 18);  ///< Set this bit to enable SPI boot encrypt/decrypt. Odd number of 1: enable. even number of 1: disable.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0 = (1U << 21);  ///< Set this bit to enable revoking first secure boot key.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1 = (1U << 22);  ///< Set this bit to enable revoking second secure boot key.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2 = (1U << 23);  ///< Set this bit to enable revoking third secure boot key.
        constexpr uint32_t KEY_PURPOSE_0 = (4 << 24);  ///< Purpose of Key0.
        constexpr uint32_t KEY_PURPOSE_1 = (4 << 28);  ///< Purpose of Key1.
    }

    /// RD_REPEAT_DATA2 Register bits
    namespace rd_repeat_data2_bits {
        constexpr uint32_t KEY_PURPOSE_2 = (4 << 0);  ///< Purpose of Key2.
        constexpr uint32_t KEY_PURPOSE_3 = (4 << 4);  ///< Purpose of Key3.
        constexpr uint32_t KEY_PURPOSE_4 = (4 << 8);  ///< Purpose of Key4.
        constexpr uint32_t KEY_PURPOSE_5 = (4 << 12);  ///< Purpose of Key5.
        constexpr uint32_t RPT4_RESERVED3 = (4 << 16);  ///< Reserved (used for four backups method).
        constexpr uint32_t SECURE_BOOT_EN = (1U << 20);  ///< Set this bit to enable secure boot.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE = (1U << 21);  ///< Set this bit to enable revoking aggressive secure boot.
        constexpr uint32_t RPT4_RESERVED0 = (6 << 22);  ///< Reserved (used for four backups method).
        constexpr uint32_t FLASH_TPUW = (4 << 28);  ///< Configures flash waiting time after power-up, in unit of ms. If the value is less than 15, the waiting time is the configurable value; Otherwise, the waiting time is twice the configurable value.
    }

    /// RD_REPEAT_DATA3 Register bits
    namespace rd_repeat_data3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 0);  ///< Set this bit to disable download mode (boot_mode[3:0] = 0, 1, 2, 3, 6, 7).
        constexpr uint32_t DIS_LEGACY_SPI_BOOT = (1U << 1);  ///< Set this bit to disable Legacy SPI boot mode (boot_mode[3:0] = 4).
        constexpr uint32_t UART_PRINT_CHANNEL = (1U << 2);  ///< Selectes the default UART print channel. 0: UART0. 1: UART1.
        constexpr uint32_t FLASH_ECC_MODE = (1U << 3);  ///< Set ECC mode in ROM, 0: ROM would Enable Flash ECC 16to18 byte mode. 1:ROM would use 16to17 byte mode.
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE = (1U << 4);  ///< Set this bit to disable UART download mode through USB.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 5);  ///< Set this bit to enable secure UART download mode.
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 6);  ///< Set the default UARTboot message output mode. 00: Enabled. 01: Enabled when GPIO8 is low at reset. 10: Enabled when GPIO8 is high at reset. 11:disabled.
        constexpr uint32_t PIN_POWER_SELECTION = (1U << 8);  ///< GPIO33-GPIO37 power supply selection in ROM code. 0: VDD3P3_CPU. 1: VDD_SPI.
        constexpr uint32_t FLASH_TYPE = (1U << 9);  ///< Set the maximum lines of SPI flash. 0: four lines. 1: eight lines.
        constexpr uint32_t FLASH_PAGE_SIZE = (2 << 10);  ///< Set Flash page size.
        constexpr uint32_t FLASH_ECC_EN = (1U << 12);  ///< Set 1 to enable ECC for flash boot.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 13);  ///< Set this bit to force ROM code to send a resume command during SPI boot.
        constexpr uint32_t SECURE_VERSION = (16 << 14);  ///< Secure version (used by ESP-IDF anti-rollback feature).
        constexpr uint32_t RPT4_RESERVED1 = (2 << 30);  ///< Reserved (used for four backups method).
    }

    /// RD_REPEAT_DATA4 Register bits
    namespace rd_repeat_data4_bits {
        constexpr uint32_t RPT4_RESERVED4 = (24 << 0);  ///< Reserved (used for four backups method).
    }

    /// RD_MAC_SPI_SYS_0 Register bits
    namespace rd_mac_spi_sys_0_bits {
        constexpr uint32_t MAC_0 = (32 << 0);  ///< Stores the low 32 bits of MAC address.
    }

    /// RD_MAC_SPI_SYS_1 Register bits
    namespace rd_mac_spi_sys_1_bits {
        constexpr uint32_t MAC_1 = (16 << 0);  ///< Stores the high 16 bits of MAC address.
        constexpr uint32_t SPI_PAD_CONF_0 = (16 << 16);  ///< Stores the zeroth part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_2 Register bits
    namespace rd_mac_spi_sys_2_bits {
        constexpr uint32_t SPI_PAD_CONF_1 = (32 << 0);  ///< Stores the first part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_3 Register bits
    namespace rd_mac_spi_sys_3_bits {
        constexpr uint32_t SPI_PAD_CONF_2 = (18 << 0);  ///< Stores the second part of SPI_PAD_CONF.
        constexpr uint32_t SYS_DATA_PART0_0 = (14 << 18);  ///< Stores the fist 14 bits of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_4 Register bits
    namespace rd_mac_spi_sys_4_bits {
        constexpr uint32_t SYS_DATA_PART0_1 = (32 << 0);  ///< Stores the fist 32 bits of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_5 Register bits
    namespace rd_mac_spi_sys_5_bits {
        constexpr uint32_t SYS_DATA_PART0_2 = (32 << 0);  ///< Stores the second 32 bits of the zeroth part of system data.
    }

    /// RD_SYS_PART1_DATA0 Register bits
    namespace rd_sys_part1_data0_bits {
        constexpr uint32_t SYS_DATA_PART1_0 = (32 << 0);  ///< Stores the zeroth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA1 Register bits
    namespace rd_sys_part1_data1_bits {
        constexpr uint32_t SYS_DATA_PART1_1 = (32 << 0);  ///< Stores the first 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA2 Register bits
    namespace rd_sys_part1_data2_bits {
        constexpr uint32_t SYS_DATA_PART1_2 = (32 << 0);  ///< Stores the second 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA3 Register bits
    namespace rd_sys_part1_data3_bits {
        constexpr uint32_t SYS_DATA_PART1_3 = (32 << 0);  ///< Stores the third 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA4 Register bits
    namespace rd_sys_part1_data4_bits {
        constexpr uint32_t SYS_DATA_PART1_4 = (32 << 0);  ///< Stores the fourth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA5 Register bits
    namespace rd_sys_part1_data5_bits {
        constexpr uint32_t SYS_DATA_PART1_5 = (32 << 0);  ///< Stores the fifth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA6 Register bits
    namespace rd_sys_part1_data6_bits {
        constexpr uint32_t SYS_DATA_PART1_6 = (32 << 0);  ///< Stores the sixth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA7 Register bits
    namespace rd_sys_part1_data7_bits {
        constexpr uint32_t SYS_DATA_PART1_7 = (32 << 0);  ///< Stores the seventh 32 bits of the first part of system data.
    }

    /// RD_USR_DATA0 Register bits
    namespace rd_usr_data0_bits {
        constexpr uint32_t USR_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA1 Register bits
    namespace rd_usr_data1_bits {
        constexpr uint32_t USR_DATA1 = (32 << 0);  ///< Stores the first 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA2 Register bits
    namespace rd_usr_data2_bits {
        constexpr uint32_t USR_DATA2 = (32 << 0);  ///< Stores the second 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA3 Register bits
    namespace rd_usr_data3_bits {
        constexpr uint32_t USR_DATA3 = (32 << 0);  ///< Stores the third 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA4 Register bits
    namespace rd_usr_data4_bits {
        constexpr uint32_t USR_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA5 Register bits
    namespace rd_usr_data5_bits {
        constexpr uint32_t USR_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA6 Register bits
    namespace rd_usr_data6_bits {
        constexpr uint32_t USR_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA7 Register bits
    namespace rd_usr_data7_bits {
        constexpr uint32_t USR_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of BLOCK3 (user).
    }

    /// RD_KEY0_DATA0 Register bits
    namespace rd_key0_data0_bits {
        constexpr uint32_t KEY0_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA1 Register bits
    namespace rd_key0_data1_bits {
        constexpr uint32_t KEY0_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY0.
    }

    /// RD_KEY0_DATA2 Register bits
    namespace rd_key0_data2_bits {
        constexpr uint32_t KEY0_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY0.
    }

    /// RD_KEY0_DATA3 Register bits
    namespace rd_key0_data3_bits {
        constexpr uint32_t KEY0_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY0.
    }

    /// RD_KEY0_DATA4 Register bits
    namespace rd_key0_data4_bits {
        constexpr uint32_t KEY0_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA5 Register bits
    namespace rd_key0_data5_bits {
        constexpr uint32_t KEY0_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA6 Register bits
    namespace rd_key0_data6_bits {
        constexpr uint32_t KEY0_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA7 Register bits
    namespace rd_key0_data7_bits {
        constexpr uint32_t KEY0_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY0.
    }

    /// RD_KEY1_DATA0 Register bits
    namespace rd_key1_data0_bits {
        constexpr uint32_t KEY1_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA1 Register bits
    namespace rd_key1_data1_bits {
        constexpr uint32_t KEY1_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY1.
    }

    /// RD_KEY1_DATA2 Register bits
    namespace rd_key1_data2_bits {
        constexpr uint32_t KEY1_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY1.
    }

    /// RD_KEY1_DATA3 Register bits
    namespace rd_key1_data3_bits {
        constexpr uint32_t KEY1_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY1.
    }

    /// RD_KEY1_DATA4 Register bits
    namespace rd_key1_data4_bits {
        constexpr uint32_t KEY1_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA5 Register bits
    namespace rd_key1_data5_bits {
        constexpr uint32_t KEY1_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA6 Register bits
    namespace rd_key1_data6_bits {
        constexpr uint32_t KEY1_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA7 Register bits
    namespace rd_key1_data7_bits {
        constexpr uint32_t KEY1_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY1.
    }

    /// RD_KEY2_DATA0 Register bits
    namespace rd_key2_data0_bits {
        constexpr uint32_t KEY2_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA1 Register bits
    namespace rd_key2_data1_bits {
        constexpr uint32_t KEY2_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY2.
    }

    /// RD_KEY2_DATA2 Register bits
    namespace rd_key2_data2_bits {
        constexpr uint32_t KEY2_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY2.
    }

    /// RD_KEY2_DATA3 Register bits
    namespace rd_key2_data3_bits {
        constexpr uint32_t KEY2_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY2.
    }

    /// RD_KEY2_DATA4 Register bits
    namespace rd_key2_data4_bits {
        constexpr uint32_t KEY2_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA5 Register bits
    namespace rd_key2_data5_bits {
        constexpr uint32_t KEY2_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA6 Register bits
    namespace rd_key2_data6_bits {
        constexpr uint32_t KEY2_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA7 Register bits
    namespace rd_key2_data7_bits {
        constexpr uint32_t KEY2_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY2.
    }

    /// RD_KEY3_DATA0 Register bits
    namespace rd_key3_data0_bits {
        constexpr uint32_t KEY3_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA1 Register bits
    namespace rd_key3_data1_bits {
        constexpr uint32_t KEY3_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY3.
    }

    /// RD_KEY3_DATA2 Register bits
    namespace rd_key3_data2_bits {
        constexpr uint32_t KEY3_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY3.
    }

    /// RD_KEY3_DATA3 Register bits
    namespace rd_key3_data3_bits {
        constexpr uint32_t KEY3_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY3.
    }

    /// RD_KEY3_DATA4 Register bits
    namespace rd_key3_data4_bits {
        constexpr uint32_t KEY3_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA5 Register bits
    namespace rd_key3_data5_bits {
        constexpr uint32_t KEY3_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA6 Register bits
    namespace rd_key3_data6_bits {
        constexpr uint32_t KEY3_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA7 Register bits
    namespace rd_key3_data7_bits {
        constexpr uint32_t KEY3_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY3.
    }

    /// RD_KEY4_DATA0 Register bits
    namespace rd_key4_data0_bits {
        constexpr uint32_t KEY4_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA1 Register bits
    namespace rd_key4_data1_bits {
        constexpr uint32_t KEY4_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY4.
    }

    /// RD_KEY4_DATA2 Register bits
    namespace rd_key4_data2_bits {
        constexpr uint32_t KEY4_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY4.
    }

    /// RD_KEY4_DATA3 Register bits
    namespace rd_key4_data3_bits {
        constexpr uint32_t KEY4_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY4.
    }

    /// RD_KEY4_DATA4 Register bits
    namespace rd_key4_data4_bits {
        constexpr uint32_t KEY4_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA5 Register bits
    namespace rd_key4_data5_bits {
        constexpr uint32_t KEY4_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA6 Register bits
    namespace rd_key4_data6_bits {
        constexpr uint32_t KEY4_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA7 Register bits
    namespace rd_key4_data7_bits {
        constexpr uint32_t KEY4_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY4.
    }

    /// RD_KEY5_DATA0 Register bits
    namespace rd_key5_data0_bits {
        constexpr uint32_t KEY5_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA1 Register bits
    namespace rd_key5_data1_bits {
        constexpr uint32_t KEY5_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY5.
    }

    /// RD_KEY5_DATA2 Register bits
    namespace rd_key5_data2_bits {
        constexpr uint32_t KEY5_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY5.
    }

    /// RD_KEY5_DATA3 Register bits
    namespace rd_key5_data3_bits {
        constexpr uint32_t KEY5_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY5.
    }

    /// RD_KEY5_DATA4 Register bits
    namespace rd_key5_data4_bits {
        constexpr uint32_t KEY5_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA5 Register bits
    namespace rd_key5_data5_bits {
        constexpr uint32_t KEY5_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA6 Register bits
    namespace rd_key5_data6_bits {
        constexpr uint32_t KEY5_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA7 Register bits
    namespace rd_key5_data7_bits {
        constexpr uint32_t KEY5_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY5.
    }

    /// RD_SYS_PART2_DATA0 Register bits
    namespace rd_sys_part2_data0_bits {
        constexpr uint32_t SYS_DATA_PART2_0 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA1 Register bits
    namespace rd_sys_part2_data1_bits {
        constexpr uint32_t SYS_DATA_PART2_1 = (32 << 0);  ///< Stores the 1st 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA2 Register bits
    namespace rd_sys_part2_data2_bits {
        constexpr uint32_t SYS_DATA_PART2_2 = (32 << 0);  ///< Stores the 2nd 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA3 Register bits
    namespace rd_sys_part2_data3_bits {
        constexpr uint32_t SYS_DATA_PART2_3 = (32 << 0);  ///< Stores the 3rd 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA4 Register bits
    namespace rd_sys_part2_data4_bits {
        constexpr uint32_t SYS_DATA_PART2_4 = (32 << 0);  ///< Stores the 4th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA5 Register bits
    namespace rd_sys_part2_data5_bits {
        constexpr uint32_t SYS_DATA_PART2_5 = (32 << 0);  ///< Stores the 5th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA6 Register bits
    namespace rd_sys_part2_data6_bits {
        constexpr uint32_t SYS_DATA_PART2_6 = (32 << 0);  ///< Stores the 6th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA7 Register bits
    namespace rd_sys_part2_data7_bits {
        constexpr uint32_t SYS_DATA_PART2_7 = (32 << 0);  ///< Stores the 7th 32 bits of the 2nd part of system data.
    }

    /// RD_REPEAT_ERR0 Register bits
    namespace rd_repeat_err0_bits {
        constexpr uint32_t RD_DIS_ERR = (7 << 0);  ///< If any bit in RD_DIS is 1, then it indicates a programming error.
        constexpr uint32_t DIS_RTC_RAM_BOOT_ERR = (1U << 7);  ///< If DIS_RTC_RAM_BOOT is 1, then it indicates a programming error.
        constexpr uint32_t DIS_ICACHE_ERR = (1U << 8);  ///< If DIS_ICACHE is 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_JTAG_ERR = (1U << 9);  ///< If DIS_USB_JTAG is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE_ERR = (1U << 10);  ///< If DIS_DOWNLOAD_ICACHE is 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_DEVICE_ERR = (1U << 11);  ///< If DIS_USB_DEVICE is 1, then it indicates a programming error.
        constexpr uint32_t DIS_FORCE_DOWNLOAD_ERR = (1U << 12);  ///< If DIS_FORCE_DOWNLOAD is 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED6_ERR = (1U << 13);  ///< Reserved.
        constexpr uint32_t DIS_CAN_ERR = (1U << 14);  ///< If DIS_CAN is 1, then it indicates a programming error.
        constexpr uint32_t JTAG_SEL_ENABLE_ERR = (1U << 15);  ///< If JTAG_SEL_ENABLE is 1, then it indicates a programming error.
        constexpr uint32_t SOFT_DIS_JTAG_ERR = (3 << 16);  ///< If SOFT_DIS_JTAG is 1, then it indicates a programming error.
        constexpr uint32_t DIS_PAD_JTAG_ERR = (1U << 19);  ///< If DIS_PAD_JTAG is 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 20);  ///< If DIS_DOWNLOAD_MANUAL_ENCRYPT is 1, then it indicates a programming error.
        constexpr uint32_t USB_DREFH_ERR = (2 << 21);  ///< If any bit in USB_DREFH is 1, then it indicates a programming error.
        constexpr uint32_t USB_DREFL_ERR = (2 << 23);  ///< If any bit in USB_DREFL is 1, then it indicates a programming error.
        constexpr uint32_t USB_EXCHG_PINS_ERR = (1U << 25);  ///< If USB_EXCHG_PINS is 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_AS_GPIO_ERR = (1U << 26);  ///< If VDD_SPI_AS_GPIO is 1, then it indicates a programming error.
        constexpr uint32_t BTLC_GPIO_ENABLE_ERR = (2 << 27);  ///< If any bit in BTLC_GPIO_ENABLE is 1, then it indicates a programming error.
        constexpr uint32_t POWERGLITCH_EN_ERR = (1U << 29);  ///< If POWERGLITCH_EN is 1, then it indicates a programming error.
        constexpr uint32_t POWER_GLITCH_DSENSE_ERR = (2 << 30);  ///< If any bit in POWER_GLITCH_DSENSE is 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR1 Register bits
    namespace rd_repeat_err1_bits {
        constexpr uint32_t RPT4_RESERVED2_ERR = (16 << 0);  ///< Reserved.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 16);  ///< If any bit in WDT_DELAY_SEL is 1, then it indicates a programming error.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT_ERR = (3 << 18);  ///< If any bit in SPI_BOOT_CRYPT_CNT is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0_ERR = (1U << 21);  ///< If SECURE_BOOT_KEY_REVOKE0 is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1_ERR = (1U << 22);  ///< If SECURE_BOOT_KEY_REVOKE1 is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2_ERR = (1U << 23);  ///< If SECURE_BOOT_KEY_REVOKE2 is 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_0_ERR = (4 << 24);  ///< If any bit in KEY_PURPOSE_0 is 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_1_ERR = (4 << 28);  ///< If any bit in KEY_PURPOSE_1 is 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR2 Register bits
    namespace rd_repeat_err2_bits {
        constexpr uint32_t KEY_PURPOSE_2_ERR = (4 << 0);  ///< If any bit in KEY_PURPOSE_2 is 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_3_ERR = (4 << 4);  ///< If any bit in KEY_PURPOSE_3 is 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_4_ERR = (4 << 8);  ///< If any bit in KEY_PURPOSE_4 is 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_5_ERR = (4 << 12);  ///< If any bit in KEY_PURPOSE_5 is 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED3_ERR = (4 << 16);  ///< Reserved.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 20);  ///< If SECURE_BOOT_EN is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = (1U << 21);  ///< If SECURE_BOOT_AGGRESSIVE_REVOKE is 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED0_ERR = (6 << 22);  ///< Reserved.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 28);  ///< If any bit in FLASH_TPUM is 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR3 Register bits
    namespace rd_repeat_err3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 0);  ///< If DIS_DOWNLOAD_MODE is 1, then it indicates a programming error.
        constexpr uint32_t DIS_LEGACY_SPI_BOOT_ERR = (1U << 1);  ///< If DIS_LEGACY_SPI_BOOT is 1, then it indicates a programming error.
        constexpr uint32_t UART_PRINT_CHANNEL_ERR = (1U << 2);  ///< If UART_PRINT_CHANNEL is 1, then it indicates a programming error.
        constexpr uint32_t FLASH_ECC_MODE_ERR = (1U << 3);  ///< If FLASH_ECC_MODE is 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE_ERR = (1U << 4);  ///< If DIS_USB_DOWNLOAD_MODE is 1, then it indicates a programming error.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 5);  ///< If ENABLE_SECURITY_DOWNLOAD is 1, then it indicates a programming error.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 6);  ///< If any bit in UART_PRINT_CONTROL is 1, then it indicates a programming error.
        constexpr uint32_t PIN_POWER_SELECTION_ERR = (1U << 8);  ///< If PIN_POWER_SELECTION is 1, then it indicates a programming error.
        constexpr uint32_t FLASH_TYPE_ERR = (1U << 9);  ///< If FLASH_TYPE is 1, then it indicates a programming error.
        constexpr uint32_t FLASH_PAGE_SIZE_ERR = (2 << 10);  ///< If any bits in FLASH_PAGE_SIZE is 1, then it indicates a programming error.
        constexpr uint32_t FLASH_ECC_EN_ERR = (1U << 12);  ///< If FLASH_ECC_EN_ERR is 1, then it indicates a programming error.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 13);  ///< If FORCE_SEND_RESUME is 1, then it indicates a programming error.
        constexpr uint32_t SECURE_VERSION_ERR = (16 << 14);  ///< If any bit in SECURE_VERSION is 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED1_ERR = (2 << 30);  ///< Reserved.
    }

    /// RD_REPEAT_ERR4 Register bits
    namespace rd_repeat_err4_bits {
        constexpr uint32_t RPT4_RESERVED4_ERR = (24 << 0);  ///< Reserved.
    }

    /// RD_RS_ERR0 Register bits
    namespace rd_rs_err0_bits {
        constexpr uint32_t MAC_SPI_8M_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t MAC_SPI_8M_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART1_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART1_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t USR_DATA_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t USR_DATA_FAIL = (1U << 11);  ///< 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t KEY0_ERR_NUM = (3 << 12);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY0_FAIL = (1U << 15);  ///< 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY1_ERR_NUM = (3 << 16);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY1_FAIL = (1U << 19);  ///< 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY2_ERR_NUM = (3 << 20);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY2_FAIL = (1U << 23);  ///< 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY3_ERR_NUM = (3 << 24);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY3_FAIL = (1U << 27);  ///< 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY4_ERR_NUM = (3 << 28);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY4_FAIL = (1U << 31);  ///< 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
    }

    /// RD_RS_ERR1 Register bits
    namespace rd_rs_err1_bits {
        constexpr uint32_t KEY5_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY5_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of KEY5 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EFUSE_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to force eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit and force to activate clock signal of eFuse SRAM.
        constexpr uint32_t EFUSE_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< Set this bit and force to enable clock signal of eFuse memory.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: Operate programming command 0x5AA5: Operate read command.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t REPEAT_ERR_CNT = (8 << 10);  ///< Indicates the number of error bits during programming BLOCK0.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (4 << 2);  ///< The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the initial read time of eFuse.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores eFuse version.
    }

}

// ============================================================================
// EXTMEM Peripheral
// ============================================================================

namespace extmem {
    /// Base addresses
    constexpr uint32_t EXTMEM_BASE = 0x600C4000;

    /// EXTMEM Register structure
    struct Registers {
        volatile uint32_t ICACHE_CTRL;  ///< Offset: 0x00 - This description will be updated in the near future.
        volatile uint32_t ICACHE_CTRL1;  ///< Offset: 0x04 - This description will be updated in the near future.
        volatile uint32_t ICACHE_TAG_POWER_CTRL;  ///< Offset: 0x08 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOCK_CTRL;  ///< Offset: 0x0C - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOCK_SCT0_ADDR;  ///< Offset: 0x10 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOCK_SCT1_ADDR;  ///< Offset: 0x14 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOCK_SCT_SIZE;  ///< Offset: 0x18 - This description will be updated in the near future.
        volatile uint32_t ICACHE_LOCK_CTRL;  ///< Offset: 0x1C - This description will be updated in the near future.
        volatile uint32_t ICACHE_LOCK_ADDR;  ///< Offset: 0x20 - This description will be updated in the near future.
        volatile uint32_t ICACHE_LOCK_SIZE;  ///< Offset: 0x24 - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_CTRL;  ///< Offset: 0x28 - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_ADDR;  ///< Offset: 0x2C - This description will be updated in the near future.
        volatile uint32_t ICACHE_SYNC_SIZE;  ///< Offset: 0x30 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOAD_CTRL;  ///< Offset: 0x34 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOAD_ADDR;  ///< Offset: 0x38 - This description will be updated in the near future.
        volatile uint32_t ICACHE_PRELOAD_SIZE;  ///< Offset: 0x3C - This description will be updated in the near future.
        volatile uint32_t ICACHE_AUTOLOAD_CTRL;  ///< Offset: 0x40 - This description will be updated in the near future.
        volatile uint32_t ICACHE_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x44 - This description will be updated in the near future.
        volatile uint32_t ICACHE_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x48 - This description will be updated in the near future.
        volatile uint32_t ICACHE_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x4C - This description will be updated in the near future.
        volatile uint32_t ICACHE_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x50 - This description will be updated in the near future.
        volatile uint32_t IBUS_TO_FLASH_START_VADDR;  ///< Offset: 0x54 - This description will be updated in the near future.
        volatile uint32_t IBUS_TO_FLASH_END_VADDR;  ///< Offset: 0x58 - This description will be updated in the near future.
        volatile uint32_t DBUS_TO_FLASH_START_VADDR;  ///< Offset: 0x5C - This description will be updated in the near future.
        volatile uint32_t DBUS_TO_FLASH_END_VADDR;  ///< Offset: 0x60 - This description will be updated in the near future.
        volatile uint32_t CACHE_ACS_CNT_CLR;  ///< Offset: 0x64 - This description will be updated in the near future.
        volatile uint32_t IBUS_ACS_MISS_CNT;  ///< Offset: 0x68 - This description will be updated in the near future.
        volatile uint32_t IBUS_ACS_CNT;  ///< Offset: 0x6C - This description will be updated in the near future.
        volatile uint32_t DBUS_ACS_FLASH_MISS_CNT;  ///< Offset: 0x70 - This description will be updated in the near future.
        volatile uint32_t DBUS_ACS_CNT;  ///< Offset: 0x74 - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_ENA;  ///< Offset: 0x78 - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_CLR;  ///< Offset: 0x7C - This description will be updated in the near future.
        volatile uint32_t CACHE_ILG_INT_ST;  ///< Offset: 0x80 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_ENA;  ///< Offset: 0x84 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_CLR;  ///< Offset: 0x88 - This description will be updated in the near future.
        volatile uint32_t CORE0_ACS_CACHE_INT_ST;  ///< Offset: 0x8C - This description will be updated in the near future.
        volatile uint32_t CORE0_DBUS_REJECT_ST;  ///< Offset: 0x90 - This description will be updated in the near future.
        volatile uint32_t CORE0_DBUS_REJECT_VADDR;  ///< Offset: 0x94 - This description will be updated in the near future.
        volatile uint32_t CORE0_IBUS_REJECT_ST;  ///< Offset: 0x98 - This description will be updated in the near future.
        volatile uint32_t CORE0_IBUS_REJECT_VADDR;  ///< Offset: 0x9C - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_FAULT_CONTENT;  ///< Offset: 0xA0 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_FAULT_VADDR;  ///< Offset: 0xA4 - This description will be updated in the near future.
        volatile uint32_t CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0xA8 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_POWER_CTRL;  ///< Offset: 0xAC - This description will be updated in the near future.
        volatile uint32_t CACHE_STATE;  ///< Offset: 0xB0 - This description will be updated in the near future.
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE;  ///< Offset: 0xB4 - This description will be updated in the near future.
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON;  ///< Offset: 0xB8 - This description will be updated in the near future.
        volatile uint32_t CACHE_PRELOAD_INT_CTRL;  ///< Offset: 0xBC - This description will be updated in the near future.
        volatile uint32_t CACHE_SYNC_INT_CTRL;  ///< Offset: 0xC0 - This description will be updated in the near future.
        volatile uint32_t CACHE_MMU_OWNER;  ///< Offset: 0xC4 - This description will be updated in the near future.
        volatile uint32_t CACHE_CONF_MISC;  ///< Offset: 0xC8 - This description will be updated in the near future.
        volatile uint32_t ICACHE_FREEZE;  ///< Offset: 0xCC - This description will be updated in the near future.
        volatile uint32_t ICACHE_ATOMIC_OPERATE_ENA;  ///< Offset: 0xD0 - This description will be updated in the near future.
        volatile uint32_t CACHE_REQUEST;  ///< Offset: 0xD4 - This description will be updated in the near future.
        volatile uint32_t IBUS_PMS_TBL_LOCK;  ///< Offset: 0xD8 - This description will be updated in the near future.
        volatile uint32_t IBUS_PMS_TBL_BOUNDARY0;  ///< Offset: 0xDC - This description will be updated in the near future.
        volatile uint32_t IBUS_PMS_TBL_BOUNDARY1;  ///< Offset: 0xE0 - This description will be updated in the near future.
        volatile uint32_t IBUS_PMS_TBL_BOUNDARY2;  ///< Offset: 0xE4 - This description will be updated in the near future.
        volatile uint32_t IBUS_PMS_TBL_ATTR;  ///< Offset: 0xE8 - This description will be updated in the near future.
        volatile uint32_t DBUS_PMS_TBL_LOCK;  ///< Offset: 0xEC - This description will be updated in the near future.
        volatile uint32_t DBUS_PMS_TBL_BOUNDARY0;  ///< Offset: 0xF0 - This description will be updated in the near future.
        volatile uint32_t DBUS_PMS_TBL_BOUNDARY1;  ///< Offset: 0xF4 - This description will be updated in the near future.
        volatile uint32_t DBUS_PMS_TBL_BOUNDARY2;  ///< Offset: 0xF8 - This description will be updated in the near future.
        volatile uint32_t DBUS_PMS_TBL_ATTR;  ///< Offset: 0xFC - This description will be updated in the near future.
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x100 - This description will be updated in the near future.
        volatile uint32_t REG_DATE;  ///< Offset: 0x3FC - This description will be updated in the near future.
    };

    /// Peripheral instances
    inline Registers* EXTMEM = reinterpret_cast<Registers*>(EXTMEM_BASE);

    // Bit definitions
    /// ICACHE_CTRL Register bits
    namespace icache_ctrl_bits {
        constexpr uint32_t ICACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
    }

    /// ICACHE_CTRL1 Register bits
    namespace icache_ctrl1_bits {
        constexpr uint32_t ICACHE_SHUT_IBUS = (1U << 0);  ///< The bit is used to disable core0 ibus, 0: enable, 1: disable
        constexpr uint32_t ICACHE_SHUT_DBUS = (1U << 1);  ///< The bit is used to disable core1 ibus, 0: enable, 1: disable
    }

    /// ICACHE_TAG_POWER_CTRL Register bits
    namespace icache_tag_power_ctrl_bits {
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of icache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power down
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power icache tag memory up, 0: follow rtc_lslp, 1: power up
    }

    /// ICACHE_PRELOCK_CTRL Register bits
    namespace icache_prelock_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function.
        constexpr uint32_t ICACHE_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function.
    }

    /// ICACHE_PRELOCK_SCT0_ADDR Register bits
    namespace icache_prelock_sct0_addr_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the first start virtual address of data prelock, which is combined with ICACHE_PRELOCK_SCT0_SIZE_REG
    }

    /// ICACHE_PRELOCK_SCT1_ADDR Register bits
    namespace icache_prelock_sct1_addr_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the second start virtual address of data prelock, which is combined with ICACHE_PRELOCK_SCT1_SIZE_REG
    }

    /// ICACHE_PRELOCK_SCT_SIZE Register bits
    namespace icache_prelock_sct_size_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT1_SIZE = (16 << 0);  ///< The bits are used to configure the second length of data locking, which is combined with ICACHE_PRELOCK_SCT1_ADDR_REG
        constexpr uint32_t ICACHE_PRELOCK_SCT0_SIZE = (16 << 16);  ///< The bits are used to configure the first length of data locking, which is combined with ICACHE_PRELOCK_SCT0_ADDR_REG
    }

    /// ICACHE_LOCK_CTRL Register bits
    namespace icache_lock_ctrl_bits {
        constexpr uint32_t ICACHE_LOCK_ENA = (1U << 0);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done.
        constexpr uint32_t ICACHE_UNLOCK_ENA = (1U << 1);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done.
        constexpr uint32_t ICACHE_LOCK_DONE = (1U << 2);  ///< The bit is used to indicate unlock/lock operation is finished.
    }

    /// ICACHE_LOCK_ADDR Register bits
    namespace icache_lock_addr_bits {
        constexpr uint32_t ICACHE_LOCK_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for lock operations. It should be combined with ICACHE_LOCK_SIZE_REG.
    }

    /// ICACHE_LOCK_SIZE Register bits
    namespace icache_lock_size_bits {
        constexpr uint32_t ICACHE_LOCK_SIZE = (16 << 0);  ///< The bits are used to configure the length for lock operations. The bits are the counts of cache block. It should be combined with ICACHE_LOCK_ADDR_REG.
    }

    /// ICACHE_SYNC_CTRL Register bits
    namespace icache_sync_ctrl_bits {
        constexpr uint32_t ICACHE_INVALIDATE_ENA = (1U << 0);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t ICACHE_SYNC_DONE = (1U << 1);  ///< The bit is used to indicate invalidate operation is finished.
    }

    /// ICACHE_SYNC_ADDR Register bits
    namespace icache_sync_addr_bits {
        constexpr uint32_t ICACHE_SYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for clean operations. It should be combined with ICACHE_SYNC_SIZE_REG.
    }

    /// ICACHE_SYNC_SIZE Register bits
    namespace icache_sync_size_bits {
        constexpr uint32_t ICACHE_SYNC_SIZE = (23 << 0);  ///< The bits are used to configure the length for sync operations. The bits are the counts of cache block. It should be combined with ICACHE_SYNC_ADDR_REG.
    }

    /// ICACHE_PRELOAD_CTRL Register bits
    namespace icache_preload_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation. It will be cleared by hardware after preload operation done.
        constexpr uint32_t ICACHE_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate preload operation is finished.
        constexpr uint32_t ICACHE_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 1: descending, 0: ascending.
    }

    /// ICACHE_PRELOAD_ADDR Register bits
    namespace icache_preload_addr_bits {
        constexpr uint32_t ICACHE_PRELOAD_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for preload operation. It should be combined with ICACHE_PRELOAD_SIZE_REG.
    }

    /// ICACHE_PRELOAD_SIZE Register bits
    namespace icache_preload_size_bits {
        constexpr uint32_t ICACHE_PRELOAD_SIZE = (16 << 0);  ///< The bits are used to configure the length for preload operation. The bits are the counts of cache block. It should be combined with ICACHE_PRELOAD_ADDR_REG..
    }

    /// ICACHE_AUTOLOAD_CTRL Register bits
    namespace icache_autoload_ctrl_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_ENA = (1U << 0);  ///< The bits are used to enable the first section for autoload operation.
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_ENA = (1U << 1);  ///< The bits are used to enable the second section for autoload operation.
        constexpr uint32_t ICACHE_AUTOLOAD_ENA = (1U << 2);  ///< The bit is used to enable and disable autoload operation. It is combined with icache_autoload_done. 1: enable, 0: disable.
        constexpr uint32_t ICACHE_AUTOLOAD_DONE = (1U << 3);  ///< The bit is used to indicate autoload operation is finished.
        constexpr uint32_t ICACHE_AUTOLOAD_ORDER = (1U << 4);  ///< The bits are used to configure the direction of autoload. 1: descending, 0: ascending.
        constexpr uint32_t ICACHE_AUTOLOAD_RQST = (2 << 5);  ///< The bits are used to configure trigger conditions for autoload. 0/3: cache miss, 1: cache hit, 2: both cache miss and hit.
    }

    /// ICACHE_AUTOLOAD_SCT0_ADDR Register bits
    namespace icache_autoload_sct0_addr_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the first section for autoload operation. It should be combined with icache_autoload_sct0_ena.
    }

    /// ICACHE_AUTOLOAD_SCT0_SIZE Register bits
    namespace icache_autoload_sct0_size_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_SIZE = (27 << 0);  ///< The bits are used to configure the length of the first section for autoload operation. It should be combined with icache_autoload_sct0_ena.
    }

    /// ICACHE_AUTOLOAD_SCT1_ADDR Register bits
    namespace icache_autoload_sct1_addr_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the second section for autoload operation. It should be combined with icache_autoload_sct1_ena.
    }

    /// ICACHE_AUTOLOAD_SCT1_SIZE Register bits
    namespace icache_autoload_sct1_size_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_SIZE = (27 << 0);  ///< The bits are used to configure the length of the second section for autoload operation. It should be combined with icache_autoload_sct1_ena.
    }

    /// IBUS_TO_FLASH_START_VADDR Register bits
    namespace ibus_to_flash_start_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// IBUS_TO_FLASH_END_VADDR Register bits
    namespace ibus_to_flash_end_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// DBUS_TO_FLASH_START_VADDR Register bits
    namespace dbus_to_flash_start_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// DBUS_TO_FLASH_END_VADDR Register bits
    namespace dbus_to_flash_end_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// CACHE_ACS_CNT_CLR Register bits
    namespace cache_acs_cnt_clr_bits {
        constexpr uint32_t IBUS_ACS_CNT_CLR = (1U << 0);  ///< The bit is used to clear ibus counter.
        constexpr uint32_t DBUS_ACS_CNT_CLR = (1U << 1);  ///< The bit is used to clear dbus counter.
    }

    /// IBUS_ACS_MISS_CNT Register bits
    namespace ibus_acs_miss_cnt_bits {
        constexpr uint32_t IBUS_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by ibus access flash.
    }

    /// IBUS_ACS_CNT Register bits
    namespace ibus_acs_cnt_bits {
        constexpr uint32_t IBUS_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of ibus access flash through icache.
    }

    /// DBUS_ACS_FLASH_MISS_CNT Register bits
    namespace dbus_acs_flash_miss_cnt_bits {
        constexpr uint32_t DBUS_ACS_FLASH_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus access flash.
    }

    /// DBUS_ACS_CNT Register bits
    namespace dbus_acs_cnt_bits {
        constexpr uint32_t DBUS_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of dbus access flash through icache.
    }

    /// CACHE_ILG_INT_ENA Register bits
    namespace cache_ilg_int_ena_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by mmu entry fault.
        constexpr uint32_t IBUS_CNT_OVF_INT_ENA = (1U << 7);  ///< The bit is used to enable interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_CLR Register bits
    namespace cache_ilg_int_clr_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by mmu entry fault.
        constexpr uint32_t IBUS_CNT_OVF_INT_CLR = (1U << 7);  ///< The bit is used to clear interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_CLR = (1U << 8);  ///< The bit is used to clear interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_ST Register bits
    namespace cache_ilg_int_st_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_ST = (1U << 0);  ///< The bit is used to indicate interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_ST = (1U << 1);  ///< The bit is used to indicate interrupt by preload configurations fault.
        constexpr uint32_t MMU_ENTRY_FAULT_ST = (1U << 5);  ///< The bit is used to indicate interrupt by mmu entry fault.
        constexpr uint32_t IBUS_ACS_CNT_OVF_ST = (1U << 7);  ///< The bit is used to indicate interrupt by ibus access flash/spiram counter overflow.
        constexpr uint32_t IBUS_ACS_MISS_CNT_OVF_ST = (1U << 8);  ///< The bit is used to indicate interrupt by ibus access flash/spiram miss counter overflow.
        constexpr uint32_t DBUS_ACS_CNT_OVF_ST = (1U << 9);  ///< The bit is used to indicate interrupt by dbus access flash/spiram counter overflow.
        constexpr uint32_t DBUS_ACS_FLASH_MISS_CNT_OVF_ST = (1U << 10);  ///< The bit is used to indicate interrupt by dbus access flash miss counter overflow.
    }

    /// CORE0_ACS_CACHE_INT_ENA Register bits
    namespace core0_acs_cache_int_ena_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding ibus is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_IC_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding dbus is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_IC_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by dbus trying to write icache
    }

    /// CORE0_ACS_CACHE_INT_CLR Register bits
    namespace core0_acs_cache_int_clr_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_IC_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding dbus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_IC_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by dbus trying to write icache
    }

    /// CORE0_ACS_CACHE_INT_ST Register bits
    namespace core0_acs_cache_int_st_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_ICACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access icache while the core0_ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_ICACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_ST = (1U << 2);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_ICACHE_ST = (1U << 3);  ///< The bit is used to indicate interrupt by cpu access icache while the core0_dbus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_ST = (1U << 4);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_WR_ICACHE_ST = (1U << 5);  ///< The bit is used to indicate interrupt by dbus trying to write icache
    }

    /// CORE0_DBUS_REJECT_ST Register bits
    namespace core0_dbus_reject_st_bits {
        constexpr uint32_t CORE0_DBUS_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of CPU access dbus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE0_DBUS_WORLD = (1U << 3);  ///< The bit is used to indicate the world of CPU access dbus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_DBUS_REJECT_VADDR Register bits
    namespace core0_dbus_reject_vaddr_bits {
        constexpr uint32_t CORE0_DBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access dbus when authentication fail.
    }

    /// CORE0_IBUS_REJECT_ST Register bits
    namespace core0_ibus_reject_st_bits {
        constexpr uint32_t CORE0_IBUS_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of CPU access ibus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able
        constexpr uint32_t CORE0_IBUS_WORLD = (1U << 3);  ///< The bit is used to indicate the world of CPU access ibus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_IBUS_REJECT_VADDR Register bits
    namespace core0_ibus_reject_vaddr_bits {
        constexpr uint32_t CORE0_IBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access ibus when authentication fail.
    }

    /// CACHE_MMU_FAULT_CONTENT Register bits
    namespace cache_mmu_fault_content_bits {
        constexpr uint32_t CACHE_MMU_FAULT_CONTENT = (10 << 0);  ///< The bits are used to indicate the content of mmu entry which cause mmu fault..
        constexpr uint32_t CACHE_MMU_FAULT_CODE = (4 << 10);  ///< The right-most 3 bits are used to indicate the operations which cause mmu fault occurrence. 0: default, 1: cpu miss, 2: preload miss, 3: writeback, 4: cpu miss evict recovery address, 5: load miss evict recovery address, 6: external dma tx, 7: external dma rx. The most significant bit is used to indicate this operation occurs in which one icache.
    }

    /// CACHE_MMU_FAULT_VADDR Register bits
    namespace cache_mmu_fault_vaddr_bits {
        constexpr uint32_t CACHE_MMU_FAULT_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address which cause mmu fault..
    }

    /// CACHE_WRAP_AROUND_CTRL Register bits
    namespace cache_wrap_around_ctrl_bits {
        constexpr uint32_t CACHE_FLASH_WRAP_AROUND = (1U << 0);  ///< The bit is used to enable wrap around mode when read data from flash.
    }

    /// CACHE_MMU_POWER_CTRL Register bits
    namespace cache_mmu_power_ctrl_bits {
        constexpr uint32_t CACHE_MMU_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to enable clock gating to save power when access mmu memory, 0: enable, 1: disable
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power down
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power up
    }

    /// CACHE_STATE Register bits
    namespace cache_state_bits {
        constexpr uint32_t ICACHE_STATE = (12 << 0);  ///< The bit is used to indicate whether icache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
    }

    /// CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE Register bits
    namespace cache_encrypt_decrypt_record_disable_bits {
        constexpr uint32_t RECORD_DISABLE_DB_ENCRYPT = (1U << 0);  ///< Reserved.
        constexpr uint32_t RECORD_DISABLE_G0CB_DECRYPT = (1U << 1);  ///< Reserved.
    }

    /// CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON Register bits
    namespace cache_encrypt_decrypt_clk_force_on_bits {
        constexpr uint32_t CLK_FORCE_ON_MANUAL_CRYPT = (1U << 0);  ///< The bit is used to close clock gating of manual crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_AUTO_CRYPT = (1U << 1);  ///< The bit is used to close clock gating of automatic crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_CRYPT = (1U << 2);  ///< The bit is used to close clock gating of external memory encrypt and decrypt clock. 1: close gating, 0: open clock gating.
    }

    /// CACHE_PRELOAD_INT_CTRL Register bits
    namespace cache_preload_int_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache pre-load done.
    }

    /// CACHE_SYNC_INT_CTRL Register bits
    namespace cache_sync_int_ctrl_bits {
        constexpr uint32_t ICACHE_SYNC_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache sync done.
    }

    /// CACHE_MMU_OWNER Register bits
    namespace cache_mmu_owner_bits {
        constexpr uint32_t CACHE_MMU_OWNER = (4 << 0);  ///< The bits are used to specify the owner of MMU.bit0/bit2: ibus, bit1/bit3: dbus
    }

    /// CACHE_CONF_MISC Register bits
    namespace cache_conf_misc_bits {
        constexpr uint32_t CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT = (1U << 0);  ///< The bit is used to disable checking mmu entry fault by preload operation.
        constexpr uint32_t CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT = (1U << 1);  ///< The bit is used to disable checking mmu entry fault by sync operation.
        constexpr uint32_t CACHE_TRACE_ENA = (1U << 2);  ///< The bit is used to enable cache trace function.
    }

    /// ICACHE_FREEZE Register bits
    namespace icache_freeze_bits {
        constexpr uint32_t ENA = (1U << 0);  ///< The bit is used to enable icache freeze mode
        constexpr uint32_t MODE = (1U << 1);  ///< The bit is used to configure freeze mode, 0: assert busy if CPU miss 1: assert hit if CPU miss
        constexpr uint32_t DONE = (1U << 2);  ///< The bit is used to indicate icache freeze success
    }

    /// ICACHE_ATOMIC_OPERATE_ENA Register bits
    namespace icache_atomic_operate_ena_bits {
        constexpr uint32_t ICACHE_ATOMIC_OPERATE_ENA = (1U << 0);  ///< The bit is used to activate icache atomic operation protection. In this case, sync/lock operation can not interrupt miss-work. This feature does not work during invalidateAll operation.
    }

    /// CACHE_REQUEST Register bits
    namespace cache_request_bits {
        constexpr uint32_t BYPASS = (1U << 0);  ///< The bit is used to disable request recording which could cause performance issue
    }

    /// IBUS_PMS_TBL_LOCK Register bits
    namespace ibus_pms_tbl_lock_bits {
        constexpr uint32_t IBUS_PMS_LOCK = (1U << 0);  ///< The bit is used to configure the ibus permission control section boundary0
    }

    /// IBUS_PMS_TBL_BOUNDARY0 Register bits
    namespace ibus_pms_tbl_boundary0_bits {
        constexpr uint32_t IBUS_PMS_BOUNDARY0 = (12 << 0);  ///< The bit is used to configure the ibus permission control section boundary0
    }

    /// IBUS_PMS_TBL_BOUNDARY1 Register bits
    namespace ibus_pms_tbl_boundary1_bits {
        constexpr uint32_t IBUS_PMS_BOUNDARY1 = (12 << 0);  ///< The bit is used to configure the ibus permission control section boundary1
    }

    /// IBUS_PMS_TBL_BOUNDARY2 Register bits
    namespace ibus_pms_tbl_boundary2_bits {
        constexpr uint32_t IBUS_PMS_BOUNDARY2 = (12 << 0);  ///< The bit is used to configure the ibus permission control section boundary2
    }

    /// IBUS_PMS_TBL_ATTR Register bits
    namespace ibus_pms_tbl_attr_bits {
        constexpr uint32_t IBUS_PMS_SCT1_ATTR = (4 << 0);  ///< The bit is used to configure attribute of the ibus permission control section1, bit0: fetch in world0, bit1: load in world0, bit2: fetch in world1, bit3: load in world1
        constexpr uint32_t IBUS_PMS_SCT2_ATTR = (4 << 4);  ///< The bit is used to configure attribute of the ibus permission control section2, bit0: fetch in world0, bit1: load in world0, bit2: fetch in world1, bit3: load in world1
    }

    /// DBUS_PMS_TBL_LOCK Register bits
    namespace dbus_pms_tbl_lock_bits {
        constexpr uint32_t DBUS_PMS_LOCK = (1U << 0);  ///< The bit is used to configure the ibus permission control section boundary0
    }

    /// DBUS_PMS_TBL_BOUNDARY0 Register bits
    namespace dbus_pms_tbl_boundary0_bits {
        constexpr uint32_t DBUS_PMS_BOUNDARY0 = (12 << 0);  ///< The bit is used to configure the dbus permission control section boundary0
    }

    /// DBUS_PMS_TBL_BOUNDARY1 Register bits
    namespace dbus_pms_tbl_boundary1_bits {
        constexpr uint32_t DBUS_PMS_BOUNDARY1 = (12 << 0);  ///< The bit is used to configure the dbus permission control section boundary1
    }

    /// DBUS_PMS_TBL_BOUNDARY2 Register bits
    namespace dbus_pms_tbl_boundary2_bits {
        constexpr uint32_t DBUS_PMS_BOUNDARY2 = (12 << 0);  ///< The bit is used to configure the dbus permission control section boundary2
    }

    /// DBUS_PMS_TBL_ATTR Register bits
    namespace dbus_pms_tbl_attr_bits {
        constexpr uint32_t DBUS_PMS_SCT1_ATTR = (2 << 0);  ///< The bit is used to configure attribute of the dbus permission control section1, bit0: load in world0, bit2: load in world1
        constexpr uint32_t DBUS_PMS_SCT2_ATTR = (2 << 2);  ///< The bit is used to configure attribute of the dbus permission control section2, bit0: load in world0, bit2: load in world1
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock gate enable.
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version information
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x60004000;
    constexpr uint32_t GPIO_SD_BASE = 0x60004F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t BT_SELECT;  ///< Offset: 0x00 - GPIO bit select register
        volatile uint32_t OUT;  ///< Offset: 0x04 - GPIO output register
        volatile uint32_t OUT_W1TS;  ///< Offset: 0x08 - GPIO output set register
        volatile uint32_t OUT_W1TC;  ///< Offset: 0x0C - GPIO output clear register
        volatile uint32_t SDIO_SELECT;  ///< Offset: 0x1C - GPIO sdio select register
        volatile uint32_t ENABLE;  ///< Offset: 0x20 - GPIO output enable register
        volatile uint32_t ENABLE_W1TS;  ///< Offset: 0x24 - GPIO output enable set register
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x28 - GPIO output enable clear register
        volatile uint32_t STRAP;  ///< Offset: 0x38 - pad strapping register
        volatile uint32_t IN;  ///< Offset: 0x3C - GPIO input register
        volatile uint32_t STATUS;  ///< Offset: 0x44 - GPIO interrupt status register
        volatile uint32_t STATUS_W1TS;  ///< Offset: 0x48 - GPIO interrupt status set register
        volatile uint32_t STATUS_W1TC;  ///< Offset: 0x4C - GPIO interrupt status clear register
        volatile uint32_t PCPU_INT;  ///< Offset: 0x5C - GPIO PRO_CPU interrupt status register
        volatile uint32_t PCPU_NMI_INT;  ///< Offset: 0x60 - GPIO PRO_CPU(not shielded) interrupt status register
        volatile uint32_t CPUSDIO_INT;  ///< Offset: 0x64 - GPIO CPUSDIO interrupt status register
        volatile uint32_t PIN;  ///< Offset: 0x74 - GPIO pin configuration register (renamed from PIN)
        volatile uint32_t STATUS_NEXT;  ///< Offset: 0x14C - GPIO interrupt source register
        volatile uint32_t FUNC_IN_SEL_CFG;  ///< Offset: 0x154 - GPIO input function configuration register (renamed from FUNC_IN_SEL_CFG)
        volatile uint32_t FUNC_OUT_SEL_CFG;  ///< Offset: 0x554 - GPIO output function select register (renamed from FUNC_OUT_SEL_CFG)
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x62C - GPIO clock gate register
        volatile uint32_t REG_DATE;  ///< Offset: 0x6FC - GPIO version register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);

    // Bit definitions
    /// BT_SELECT Register bits
    namespace bt_select_bits {
        constexpr uint32_t BT_SEL = (32 << 0);  ///< GPIO bit select register
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t DATA_ORIG = (26 << 0);  ///< GPIO output register for GPIO0-25
    }

    /// OUT_W1TS Register bits
    namespace out_w1ts_bits {
        constexpr uint32_t OUT_W1TS = (26 << 0);  ///< GPIO output set register for GPIO0-25
    }

    /// OUT_W1TC Register bits
    namespace out_w1tc_bits {
        constexpr uint32_t OUT_W1TC = (26 << 0);  ///< GPIO output clear register for GPIO0-25
    }

    /// SDIO_SELECT Register bits
    namespace sdio_select_bits {
        constexpr uint32_t SDIO_SEL = (8 << 0);  ///< GPIO sdio select register
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t DATA = (26 << 0);  ///< GPIO output enable register for GPIO0-25
    }

    /// ENABLE_W1TS Register bits
    namespace enable_w1ts_bits {
        constexpr uint32_t ENABLE_W1TS = (26 << 0);  ///< GPIO output enable set register for GPIO0-25
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (26 << 0);  ///< GPIO output enable clear register for GPIO0-25
    }

    /// STRAP Register bits
    namespace strap_bits {
        constexpr uint32_t STRAPPING = (16 << 0);  ///< pad strapping register
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t DATA_NEXT = (26 << 0);  ///< GPIO input register for GPIO0-25
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INTERRUPT = (26 << 0);  ///< GPIO interrupt status register for GPIO0-25
    }

    /// STATUS_W1TS Register bits
    namespace status_w1ts_bits {
        constexpr uint32_t STATUS_W1TS = (26 << 0);  ///< GPIO interrupt status set register for GPIO0-25
    }

    /// STATUS_W1TC Register bits
    namespace status_w1tc_bits {
        constexpr uint32_t STATUS_W1TC = (26 << 0);  ///< GPIO interrupt status clear register for GPIO0-25
    }

    /// PCPU_INT Register bits
    namespace pcpu_int_bits {
        constexpr uint32_t PROCPU_INT = (26 << 0);  ///< GPIO PRO_CPU interrupt status register for GPIO0-25
    }

    /// PCPU_NMI_INT Register bits
    namespace pcpu_nmi_int_bits {
        constexpr uint32_t PROCPU_NMI_INT = (26 << 0);  ///< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-25
    }

    /// CPUSDIO_INT Register bits
    namespace cpusdio_int_bits {
        constexpr uint32_t SDIO_INT = (26 << 0);  ///< GPIO CPUSDIO interrupt status register for GPIO0-25
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t SYNC2_BYPASS = (2 << 0);  ///< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< set this bit to select pad driver. 1:open-drain. 0:normal.
        constexpr uint32_t SYNC1_BYPASS = (2 << 3);  ///< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t INT_TYPE = (3 << 7);  ///< set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
        constexpr uint32_t WAKEUP_ENABLE = (1U << 10);  ///< set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
        constexpr uint32_t CONFIG = (2 << 11);  ///< reserved
        constexpr uint32_t INT_ENA = (5 << 13);  ///< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
    }

    /// STATUS_NEXT Register bits
    namespace status_next_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT = (26 << 0);  ///< GPIO interrupt source register for GPIO0-25
    }

    /// FUNC_IN_SEL_CFG Register bits
    namespace func_in_sel_cfg_bits {
        constexpr uint32_t IN_SEL = (5 << 0);  ///< set this value: s=0-53: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
        constexpr uint32_t IN_INV_SEL = (1U << 5);  ///< set this bit to invert input signal. 1:invert. 0:not invert.
        constexpr uint32_t SEL = (1U << 6);  ///< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
    }

    /// FUNC_OUT_SEL_CFG Register bits
    namespace func_out_sel_cfg_bits {
        constexpr uint32_t OUT_SEL = (8 << 0);  ///< The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-255: output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals GPIO_OUT_REG[n].
        constexpr uint32_t INV_SEL = (1U << 8);  ///< set this bit to invert output signal.1:invert.0:not invert.
        constexpr uint32_t OEN_SEL = (1U << 9);  ///< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
        constexpr uint32_t OEN_INV_SEL = (1U << 10);  ///< set this bit to invert output enable signal.1:invert.0:not invert.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable GPIO clock gate
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x60013000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - I2C_SCL_LOW_PERIOD_REG
        volatile uint32_t CTR;  ///< Offset: 0x04 - I2C_CTR_REG
        volatile uint32_t SR;  ///< Offset: 0x08 - I2C_SR_REG
        volatile uint32_t TO;  ///< Offset: 0x0C - I2C_TO_REG
        volatile uint32_t SLAVE_ADDR;  ///< Offset: 0x10 - I2C_SLAVE_ADDR_REG
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - I2C_FIFO_ST_REG
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - I2C_FIFO_CONF_REG
        volatile uint32_t DATA;  ///< Offset: 0x1C - I2C_FIFO_DATA_REG
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - I2C_INT_RAW_REG
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - I2C_INT_CLR_REG
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - I2C_INT_ENA_REG
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - I2C_INT_STATUS_REG
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - I2C_SDA_HOLD_REG
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - I2C_SDA_SAMPLE_REG
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - I2C_SCL_HIGH_PERIOD_REG
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - I2C_SCL_START_HOLD_REG
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - I2C_SCL_RSTART_SETUP_REG
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - I2C_SCL_STOP_HOLD_REG
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - I2C_SCL_STOP_SETUP_REG
        volatile uint32_t FILTER_CFG;  ///< Offset: 0x50 - I2C_FILTER_CFG_REG
        volatile uint32_t CLK_CONF;  ///< Offset: 0x54 - I2C_CLK_CONF_REG
        volatile uint32_t COMD;  ///< Offset: 0x58 - I2C_COMD%s_REG (renamed from COMD)
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x78 - I2C_SCL_ST_TIME_OUT_REG
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x7C - I2C_SCL_MAIN_ST_TIME_OUT_REG
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0x80 - I2C_SCL_SP_CONF_REG
        volatile uint32_t SCL_STRETCH_CONF;  ///< Offset: 0x84 - I2C_SCL_STRETCH_CONF_REG
        volatile uint32_t DATE;  ///< Offset: 0xF8 - I2C_DATE_REG
        volatile uint32_t TXFIFO_START_ADDR;  ///< Offset: 0x100 - I2C_TXFIFO_START_ADDR_REG
        volatile uint32_t RXFIFO_START_ADDR;  ///< Offset: 0x180 - I2C_RXFIFO_START_ADDR_REG
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (9 << 0);  ///< reg_scl_low_period
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< reg_sda_force_out
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< reg_scl_force_out
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< reg_sample_scl_level
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< reg_rx_full_ack_level
        constexpr uint32_t MS_MODE = (1U << 4);  ///< reg_ms_mode
        constexpr uint32_t TRANS_START = (1U << 5);  ///< reg_trans_start
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< reg_tx_lsb_first
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< reg_rx_lsb_first
        constexpr uint32_t CLK_EN = (1U << 8);  ///< reg_clk_en
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< reg_arbitration_en
        constexpr uint32_t FSM_RST = (1U << 10);  ///< reg_fsm_rst
        constexpr uint32_t CONF_UPGATE = (1U << 11);  ///< reg_conf_upgate
        constexpr uint32_t SLV_TX_AUTO_START_EN = (1U << 12);  ///< reg_slv_tx_auto_start_en
        constexpr uint32_t ADDR_10BIT_RW_CHECK_EN = (1U << 13);  ///< reg_addr_10bit_rw_check_en
        constexpr uint32_t ADDR_BROADCASTING_EN = (1U << 14);  ///< reg_addr_broadcasting_en
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< reg_resp_rec
        constexpr uint32_t SLAVE_RW = (1U << 1);  ///< reg_slave_rw
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< reg_arb_lost
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< reg_bus_busy
        constexpr uint32_t SLAVE_ADDRESSED = (1U << 5);  ///< reg_slave_addressed
        constexpr uint32_t RXFIFO_CNT = (6 << 8);  ///< reg_rxfifo_cnt
        constexpr uint32_t STRETCH_CAUSE = (2 << 14);  ///< reg_stretch_cause
        constexpr uint32_t TXFIFO_CNT = (6 << 18);  ///< reg_txfifo_cnt
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< reg_scl_main_state_last
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< reg_scl_state_last
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (5 << 0);  ///< reg_time_out_value
        constexpr uint32_t TIME_OUT_EN = (1U << 5);  ///< reg_time_out_en
    }

    /// SLAVE_ADDR Register bits
    namespace slave_addr_bits {
        constexpr uint32_t SLAVE_ADDR = (15 << 0);  ///< reg_slave_addr
        constexpr uint32_t ADDR_10BIT_EN = (1U << 31);  ///< reg_addr_10bit_en
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_RADDR = (5 << 0);  ///< reg_rxfifo_raddr
        constexpr uint32_t RXFIFO_WADDR = (5 << 5);  ///< reg_rxfifo_waddr
        constexpr uint32_t TXFIFO_RADDR = (5 << 10);  ///< reg_txfifo_raddr
        constexpr uint32_t TXFIFO_WADDR = (5 << 15);  ///< reg_txfifo_waddr
        constexpr uint32_t SLAVE_RW_POINT = (8 << 22);  ///< reg_slave_rw_point
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (5 << 0);  ///< reg_rxfifo_wm_thrhd
        constexpr uint32_t TXFIFO_WM_THRHD = (5 << 5);  ///< reg_txfifo_wm_thrhd
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< reg_nonfifo_en
        constexpr uint32_t FIFO_ADDR_CFG_EN = (1U << 11);  ///< reg_fifo_addr_cfg_en
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< reg_rx_fifo_rst
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< reg_tx_fifo_rst
        constexpr uint32_t FIFO_PRT_EN = (1U << 14);  ///< reg_fifo_prt_en
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< reg_fifo_rdata
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< reg_rxfifo_wm_int_raw
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< reg_txfifo_wm_int_raw
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< reg_rxfifo_ovf_int_raw
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< reg_end_detect_int_raw
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< reg_byte_trans_done_int_raw
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< reg_arbitration_lost_int_raw
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< reg_mst_txfifo_udf_int_raw
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< reg_trans_complete_int_raw
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< reg_time_out_int_raw
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< reg_trans_start_int_raw
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< reg_nack_int_raw
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< reg_txfifo_ovf_int_raw
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< reg_rxfifo_udf_int_raw
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< reg_scl_st_to_int_raw
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< reg_scl_main_st_to_int_raw
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< reg_det_start_int_raw
        constexpr uint32_t SLAVE_STRETCH_INT_RAW = (1U << 16);  ///< reg_slave_stretch_int_raw
        constexpr uint32_t GENERAL_CALL_INT_RAW = (1U << 17);  ///< reg_general_call_int_raw
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< reg_rxfifo_wm_int_clr
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< reg_txfifo_wm_int_clr
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< reg_rxfifo_ovf_int_clr
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< reg_end_detect_int_clr
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< reg_byte_trans_done_int_clr
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< reg_arbitration_lost_int_clr
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< reg_mst_txfifo_udf_int_clr
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< reg_trans_complete_int_clr
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< reg_time_out_int_clr
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< reg_trans_start_int_clr
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< reg_nack_int_clr
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< reg_txfifo_ovf_int_clr
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< reg_rxfifo_udf_int_clr
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< reg_scl_st_to_int_clr
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< reg_scl_main_st_to_int_clr
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< reg_det_start_int_clr
        constexpr uint32_t SLAVE_STRETCH_INT_CLR = (1U << 16);  ///< reg_slave_stretch_int_clr
        constexpr uint32_t GENERAL_CALL_INT_CLR = (1U << 17);  ///< reg_general_call_int_clr
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< reg_rxfifo_wm_int_ena
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< reg_txfifo_wm_int_ena
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< reg_rxfifo_ovf_int_ena
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< reg_end_detect_int_ena
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< reg_byte_trans_done_int_ena
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< reg_arbitration_lost_int_ena
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< reg_mst_txfifo_udf_int_ena
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< reg_trans_complete_int_ena
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< reg_time_out_int_ena
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< reg_trans_start_int_ena
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< reg_nack_int_ena
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< reg_txfifo_ovf_int_ena
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< reg_rxfifo_udf_int_ena
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< reg_scl_st_to_int_ena
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< reg_scl_main_st_to_int_ena
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< reg_det_start_int_ena
        constexpr uint32_t SLAVE_STRETCH_INT_ENA = (1U << 16);  ///< reg_slave_stretch_int_ena
        constexpr uint32_t GENERAL_CALL_INT_ENA = (1U << 17);  ///< reg_general_call_int_ena
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< reg_rxfifo_wm_int_st
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< reg_txfifo_wm_int_st
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< reg_rxfifo_ovf_int_st
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< reg_end_detect_int_st
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< reg_byte_trans_done_int_st
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< reg_arbitration_lost_int_st
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< reg_mst_txfifo_udf_int_st
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< reg_trans_complete_int_st
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< reg_time_out_int_st
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< reg_trans_start_int_st
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< reg_nack_int_st
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< reg_txfifo_ovf_int_st
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< reg_rxfifo_udf_int_st
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< reg_scl_st_to_int_st
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< reg_scl_main_st_to_int_st
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< reg_det_start_int_st
        constexpr uint32_t SLAVE_STRETCH_INT_ST = (1U << 16);  ///< reg_slave_stretch_int_st
        constexpr uint32_t GENERAL_CALL_INT_ST = (1U << 17);  ///< reg_general_call_int_st
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_sda_hold_time
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_sda_sample_time
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (9 << 0);  ///< reg_scl_high_period
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (7 << 9);  ///< reg_scl_wait_high_period
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_scl_start_hold_time
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_scl_rstart_setup_time
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_scl_stop_hold_time
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< reg_scl_stop_setup_time
    }

    /// FILTER_CFG Register bits
    namespace filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< reg_scl_filter_thres
        constexpr uint32_t SDA_FILTER_THRES = (4 << 4);  ///< reg_sda_filter_thres
        constexpr uint32_t SCL_FILTER_EN = (1U << 8);  ///< reg_scl_filter_en
        constexpr uint32_t SDA_FILTER_EN = (1U << 9);  ///< reg_sda_filter_en
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_NUM = (8 << 0);  ///< reg_sclk_div_num
        constexpr uint32_t SCLK_DIV_A = (6 << 8);  ///< reg_sclk_div_a
        constexpr uint32_t SCLK_DIV_B = (6 << 14);  ///< reg_sclk_div_b
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< reg_sclk_sel
        constexpr uint32_t SCLK_ACTIVE = (1U << 21);  ///< reg_sclk_active
    }

    /// COMD Register bits
    namespace comd_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< reg_command
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< reg_command_done
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO_I2C = (5 << 0);  ///< reg_scl_st_to_regno more than 23
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO_I2C = (5 << 0);  ///< reg_scl_main_st_to_regno more than 23
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< reg_scl_rst_slv_en
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< reg_scl_rst_slv_num
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< reg_scl_pd_en
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< reg_sda_pd_en
    }

    /// SCL_STRETCH_CONF Register bits
    namespace scl_stretch_conf_bits {
        constexpr uint32_t STRETCH_PROTECT_NUM = (10 << 0);  ///< reg_stretch_protect_num
        constexpr uint32_t SLAVE_SCL_STRETCH_EN = (1U << 10);  ///< reg_slave_scl_stretch_en
        constexpr uint32_t SLAVE_SCL_STRETCH_CLR = (1U << 11);  ///< reg_slave_scl_stretch_clr
        constexpr uint32_t SLAVE_BYTE_ACK_CTL_EN = (1U << 12);  ///< reg_slave_byte_ack_ctl_en
        constexpr uint32_t SLAVE_BYTE_ACK_LVL = (1U << 13);  ///< reg_slave_byte_ack_lvl
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< reg_date
    }

    /// TXFIFO_START_ADDR Register bits
    namespace txfifo_start_addr_bits {
        constexpr uint32_t TXFIFO_START_ADDR = (32 << 0);  ///< reg_txfifo_start_addr.
    }

    /// RXFIFO_START_ADDR Register bits
    namespace rxfifo_start_addr_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (32 << 0);  ///< reg_rxfifo_start_addr.
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x6002D000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - I2S interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - I2S interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - I2S interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - I2S interrupt clear register.
        volatile uint32_t RX_CONF;  ///< Offset: 0x20 - I2S RX configure register
        volatile uint32_t TX_CONF;  ///< Offset: 0x24 - I2S TX configure register
        volatile uint32_t RX_CONF1;  ///< Offset: 0x28 - I2S RX configure register 1
        volatile uint32_t TX_CONF1;  ///< Offset: 0x2C - I2S TX configure register 1
        volatile uint32_t RX_CLKM_CONF;  ///< Offset: 0x30 - I2S RX clock configure register
        volatile uint32_t TX_CLKM_CONF;  ///< Offset: 0x34 - I2S TX clock configure register
        volatile uint32_t RX_CLKM_DIV_CONF;  ///< Offset: 0x38 - I2S RX module clock divider configure register
        volatile uint32_t TX_CLKM_DIV_CONF;  ///< Offset: 0x3C - I2S TX module clock divider configure register
        volatile uint32_t TX_PCM2PDM_CONF;  ///< Offset: 0x40 - I2S TX PCM2PDM configuration register
        volatile uint32_t TX_PCM2PDM_CONF1;  ///< Offset: 0x44 - I2S TX PCM2PDM configuration register
        volatile uint32_t RX_TDM_CTRL;  ///< Offset: 0x50 - I2S TX TDM mode control register
        volatile uint32_t TX_TDM_CTRL;  ///< Offset: 0x54 - I2S TX TDM mode control register
        volatile uint32_t RX_TIMING;  ///< Offset: 0x58 - I2S RX timing control register
        volatile uint32_t TX_TIMING;  ///< Offset: 0x5C - I2S TX timing control register
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x60 - I2S HUNG configure register.
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x64 - I2S RX data number control register.
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x68 - I2S signal data register
        volatile uint32_t STATE;  ///< Offset: 0x6C - I2S TX status register
        volatile uint32_t DATE;  ///< Offset: 0x80 - Version control register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the i2s_tx_hung_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 1);  ///< Set this bit to clear the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear the i2s_tx_hung_int interrupt
    }

    /// RX_CONF Register bits
    namespace rx_conf_bits {
        constexpr uint32_t RX_RESET = (1U << 0);  ///< Set this bit to reset receiver
        constexpr uint32_t RX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Rx AFIFO
        constexpr uint32_t RX_START = (1U << 2);  ///< Set this bit to start receiving data
        constexpr uint32_t RX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave receiver mode
        constexpr uint32_t RX_MONO = (1U << 5);  ///< Set this bit to enable receiver in mono mode
        constexpr uint32_t RX_BIG_ENDIAN = (1U << 7);  ///< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t RX_UPDATE = (1U << 8);  ///< Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t RX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
        constexpr uint32_t RX_PCM_CONF = (2 << 10);  ///< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t RX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for received data.
        constexpr uint32_t RX_STOP_MODE = (2 << 13);  ///< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
        constexpr uint32_t RX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
        constexpr uint32_t RX_24_FILL_EN = (1U << 16);  ///< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
        constexpr uint32_t RX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when receiving left channel data, and WS is 1in right channel. 1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
        constexpr uint32_t RX_BIT_ORDER = (1U << 18);  ///< I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
        constexpr uint32_t RX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Rx mode . 0: Disable.
        constexpr uint32_t RX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Rx mode . 0: Disable.
    }

    /// TX_CONF Register bits
    namespace tx_conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< Set this bit to reset transmitter
        constexpr uint32_t TX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Tx AFIFO
        constexpr uint32_t TX_START = (1U << 2);  ///< Set this bit to start transmitting data
        constexpr uint32_t TX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave transmitter mode
        constexpr uint32_t TX_MONO = (1U << 5);  ///< Set this bit to enable transmitter in mono mode
        constexpr uint32_t TX_CHAN_EQUAL = (1U << 6);  ///< 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
        constexpr uint32_t TX_BIG_ENDIAN = (1U << 7);  ///< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t TX_UPDATE = (1U << 8);  ///< Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t TX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
        constexpr uint32_t TX_PCM_CONF = (2 << 10);  ///< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t TX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for transmitted data.
        constexpr uint32_t TX_STOP_EN = (1U << 13);  ///< Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
        constexpr uint32_t TX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
        constexpr uint32_t TX_24_FILL_EN = (1U << 16);  ///< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
        constexpr uint32_t TX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when sending left channel data, and WS is 1in right channel. 1: WS should be 1 when sending left channel data, and WS is 0in right channel.
        constexpr uint32_t TX_BIT_ORDER = (1U << 18);  ///< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
        constexpr uint32_t TX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Tx mode . 0: Disable.
        constexpr uint32_t TX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Tx mode . 0: Disable.
        constexpr uint32_t TX_CHAN_MOD = (3 << 24);  ///< I2S transmitter channel mode configuration bits.
        constexpr uint32_t SIG_LOOPBACK = (1U << 27);  ///< Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
    }

    /// RX_CONF1 Register bits
    namespace rx_conf1_bits {
        constexpr uint32_t RX_TDM_WS_WIDTH = (7 << 0);  ///< The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0] +1) * T_bck
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 7);  ///< Bit clock configuration bits in receiver mode.
        constexpr uint32_t RX_BITS_MOD = (5 << 13);  ///< Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t RX_HALF_SAMPLE_BITS = (6 << 18);  ///< I2S Rx half sample bits -1.
        constexpr uint32_t RX_TDM_CHAN_BITS = (5 << 24);  ///< The Rx bit number for each channel minus 1in TDM mode.
        constexpr uint32_t RX_MSB_SHIFT = (1U << 29);  ///< Set this bit to enable receiver in Phillips standard mode
    }

    /// TX_CONF1 Register bits
    namespace tx_conf1_bits {
        constexpr uint32_t TX_TDM_WS_WIDTH = (7 << 0);  ///< The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0] +1) * T_bck
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 7);  ///< Bit clock configuration bits in transmitter mode.
        constexpr uint32_t TX_BITS_MOD = (5 << 13);  ///< Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t TX_HALF_SAMPLE_BITS = (6 << 18);  ///< I2S Tx half sample bits -1.
        constexpr uint32_t TX_TDM_CHAN_BITS = (5 << 24);  ///< The Tx bit number for each channel minus 1in TDM mode.
        constexpr uint32_t TX_MSB_SHIFT = (1U << 29);  ///< Set this bit to enable transmitter in Phillips standard mode
        constexpr uint32_t TX_BCK_NO_DLY = (1U << 30);  ///< 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
    }

    /// RX_CLKM_CONF Register bits
    namespace rx_clkm_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t RX_CLK_ACTIVE = (1U << 26);  ///< I2S Rx module clock enable signal.
        constexpr uint32_t RX_CLK_SEL = (2 << 27);  ///< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t MCLK_SEL = (1U << 29);  ///< 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module clock as I2S_MCLK_OUT.
    }

    /// TX_CLKM_CONF Register bits
    namespace tx_clkm_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div. So the average combination will be: for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
        constexpr uint32_t TX_CLK_ACTIVE = (1U << 26);  ///< I2S Tx module clock enable signal.
        constexpr uint32_t TX_CLK_SEL = (2 << 27);  ///< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t CLK_EN = (1U << 29);  ///< Set this bit to enable clk gate
    }

    /// RX_CLKM_DIV_CONF Register bits
    namespace rx_clkm_div_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t RX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t RX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t RX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
    }

    /// TX_CLKM_DIV_CONF Register bits
    namespace tx_clkm_div_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t TX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t TX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t TX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
    }

    /// TX_PCM2PDM_CONF Register bits
    namespace tx_pcm2pdm_conf_bits {
        constexpr uint32_t TX_PDM_HP_BYPASS = (1U << 0);  ///< I2S TX PDM bypass hp filter or not. The option has been removed.
        constexpr uint32_t TX_PDM_SINC_OSR2 = (4 << 1);  ///< I2S TX PDM OSR2 value
        constexpr uint32_t TX_PDM_PRESCALE = (8 << 5);  ///< I2S TX PDM prescale for sigmadelta
        constexpr uint32_t TX_PDM_HP_IN_SHIFT = (2 << 13);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_LP_IN_SHIFT = (2 << 15);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SINC_IN_SHIFT = (2 << 17);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_IN_SHIFT = (2 << 19);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER2 = (1U << 21);  ///< I2S TX PDM sigmadelta dither2 value
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER = (1U << 22);  ///< I2S TX PDM sigmadelta dither value
        constexpr uint32_t TX_PDM_DAC_2OUT_EN = (1U << 23);  ///< I2S TX PDM dac mode enable
        constexpr uint32_t TX_PDM_DAC_MODE_EN = (1U << 24);  ///< I2S TX PDM dac 2channel enable
        constexpr uint32_t PCM2PDM_CONV_EN = (1U << 25);  ///< I2S TX PDM Converter enable
    }

    /// TX_PCM2PDM_CONF1 Register bits
    namespace tx_pcm2pdm_conf1_bits {
        constexpr uint32_t TX_PDM_FP = (10 << 0);  ///< I2S TX PDM Fp
        constexpr uint32_t TX_PDM_FS = (10 << 10);  ///< I2S TX PDM Fs
        constexpr uint32_t TX_IIR_HP_MULT12_5 = (3 << 20);  ///< The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
        constexpr uint32_t TX_IIR_HP_MULT12_0 = (3 << 23);  ///< The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
    }

    /// RX_TDM_CTRL Register bits
    namespace rx_tdm_ctrl_bits {
        constexpr uint32_t RX_TDM_PDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data input of I2S RX TDM channel 10. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data input of I2S RX TDM channel 11. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data input of I2S RX TDM channel 12. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data input of I2S RX TDM channel 13. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data input of I2S RX TDM channel 14. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data input of I2S RX TDM channel 15. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
    }

    /// TX_TDM_CTRL Register bits
    namespace tx_tdm_ctrl_bits {
        constexpr uint32_t TX_TDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data output of I2S TX TDM channel 0. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data output of I2S TX TDM channel 1. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data output of I2S TX TDM channel 2. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data output of I2S TX TDM channel 3. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data output of I2S TX TDM channel 4. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data output of I2S TX TDM channel 5. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data output of I2S TX TDM channel 6. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data output of I2S TX TDM channel 7. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data output of I2S TX TDM channel 8. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data output of I2S TX TDM channel 9. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data output of I2S TX TDM channel 10. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data output of I2S TX TDM channel 11. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data output of I2S TX TDM channel 12. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data output of I2S TX TDM channel 13. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data output of I2S TX TDM channel 14. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data output of I2S TX TDM channel 15. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
        constexpr uint32_t TX_TDM_SKIP_MSK_EN = (1U << 20);  ///< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1) channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
    }

    /// RX_TIMING Register bits
    namespace rx_timing_bits {
        constexpr uint32_t RX_SD_IN_DM = (2 << 0);  ///< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// TX_TIMING Register bits
    namespace tx_timing_bits {
        constexpr uint32_t TX_SD_OUT_DM = (2 << 0);  ///< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_SD1_OUT_DM = (2 << 4);  ///< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for FIFO timeout
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (12 << 0);  ///< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SINGLE_DATA = (32 << 0);  ///< The configured constant channel data to be sent out.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< 1: i2s_tx is idle state. 0: i2s_tx is working.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< I2S version control register
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x600C2000;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t MAC_INTR_MAP;  ///< Offset: 0x00 - mac intr map register
        volatile uint32_t MAC_NMI_MAP;  ///< Offset: 0x04 - mac nmi_intr map register
        volatile uint32_t PWR_INTR_MAP;  ///< Offset: 0x08 - pwr intr map register
        volatile uint32_t BB_INT_MAP;  ///< Offset: 0x0C - bb intr map register
        volatile uint32_t BT_MAC_INT_MAP;  ///< Offset: 0x10 - bt intr map register
        volatile uint32_t BT_BB_INT_MAP;  ///< Offset: 0x14 - bb_bt intr map register
        volatile uint32_t BT_BB_NMI_MAP;  ///< Offset: 0x18 - bb_bt_nmi intr map register
        volatile uint32_t RWBT_IRQ_MAP;  ///< Offset: 0x1C - rwbt intr map register
        volatile uint32_t RWBLE_IRQ_MAP;  ///< Offset: 0x20 - rwble intr map register
        volatile uint32_t RWBT_NMI_MAP;  ///< Offset: 0x24 - rwbt_nmi intr map register
        volatile uint32_t RWBLE_NMI_MAP;  ///< Offset: 0x28 - rwble_nmi intr map register
        volatile uint32_t I2C_MST_INT_MAP;  ///< Offset: 0x2C - i2c intr map register
        volatile uint32_t SLC0_INTR_MAP;  ///< Offset: 0x30 - slc0 intr map register
        volatile uint32_t SLC1_INTR_MAP;  ///< Offset: 0x34 - slc1 intr map register
        volatile uint32_t APB_CTRL_INTR_MAP;  ///< Offset: 0x38 - apb_ctrl intr map register
        volatile uint32_t UHCI0_INTR_MAP;  ///< Offset: 0x3C - uchi0 intr map register
        volatile uint32_t GPIO_INTERRUPT_PRO_MAP;  ///< Offset: 0x40 - gpio intr map register
        volatile uint32_t GPIO_INTERRUPT_PRO_NMI_MAP;  ///< Offset: 0x44 - gpio_pro intr map register
        volatile uint32_t SPI_INTR_1_MAP;  ///< Offset: 0x48 - gpio_pro_nmi intr map register
        volatile uint32_t SPI_INTR_2_MAP;  ///< Offset: 0x4C - spi1 intr map register
        volatile uint32_t I2S1_INT_MAP;  ///< Offset: 0x50 - spi2 intr map register
        volatile uint32_t UART_INTR_MAP;  ///< Offset: 0x54 - i2s1 intr map register
        volatile uint32_t UART1_INTR_MAP;  ///< Offset: 0x58 - uart1 intr map register
        volatile uint32_t LEDC_INT_MAP;  ///< Offset: 0x5C - ledc intr map register
        volatile uint32_t EFUSE_INT_MAP;  ///< Offset: 0x60 - efuse intr map register
        volatile uint32_t CAN_INT_MAP;  ///< Offset: 0x64 - can intr map register
        volatile uint32_t USB_INTR_MAP;  ///< Offset: 0x68 - usb intr map register
        volatile uint32_t RTC_CORE_INTR_MAP;  ///< Offset: 0x6C - rtc intr map register
        volatile uint32_t RMT_INTR_MAP;  ///< Offset: 0x70 - rmt intr map register
        volatile uint32_t I2C_EXT0_INTR_MAP;  ///< Offset: 0x74 - i2c intr map register
        volatile uint32_t TIMER_INT1_MAP;  ///< Offset: 0x78 - timer1 intr map register
        volatile uint32_t TIMER_INT2_MAP;  ///< Offset: 0x7C - timer2 intr map register
        volatile uint32_t TG_T0_INT_MAP;  ///< Offset: 0x80 - tg to intr map register
        volatile uint32_t TG_WDT_INT_MAP;  ///< Offset: 0x84 - tg wdt intr map register
        volatile uint32_t TG1_T0_INT_MAP;  ///< Offset: 0x88 - tg1 to intr map register
        volatile uint32_t TG1_WDT_INT_MAP;  ///< Offset: 0x8C - tg1 wdt intr map register
        volatile uint32_t CACHE_IA_INT_MAP;  ///< Offset: 0x90 - cache ia intr map register
        volatile uint32_t SYSTIMER_TARGET0_INT_MAP;  ///< Offset: 0x94 - systimer intr map register
        volatile uint32_t SYSTIMER_TARGET1_INT_MAP;  ///< Offset: 0x98 - systimer target1 intr map register
        volatile uint32_t SYSTIMER_TARGET2_INT_MAP;  ///< Offset: 0x9C - systimer target2 intr map register
        volatile uint32_t SPI_MEM_REJECT_INTR_MAP;  ///< Offset: 0xA0 - spi mem reject intr map register
        volatile uint32_t ICACHE_PRELOAD_INT_MAP;  ///< Offset: 0xA4 - icache perload intr map register
        volatile uint32_t ICACHE_SYNC_INT_MAP;  ///< Offset: 0xA8 - icache sync intr map register
        volatile uint32_t APB_ADC_INT_MAP;  ///< Offset: 0xAC - adc intr map register
        volatile uint32_t DMA_CH0_INT_MAP;  ///< Offset: 0xB0 - dma ch0 intr map register
        volatile uint32_t DMA_CH1_INT_MAP;  ///< Offset: 0xB4 - dma ch1 intr map register
        volatile uint32_t DMA_CH2_INT_MAP;  ///< Offset: 0xB8 - dma ch2 intr map register
        volatile uint32_t RSA_INT_MAP;  ///< Offset: 0xBC - rsa intr map register
        volatile uint32_t AES_INT_MAP;  ///< Offset: 0xC0 - aes intr map register
        volatile uint32_t SHA_INT_MAP;  ///< Offset: 0xC4 - sha intr map register
        volatile uint32_t CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0xC8 - cpu from cpu 0 intr map register
        volatile uint32_t CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0xCC - cpu from cpu 0 intr map register
        volatile uint32_t CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0xD0 - cpu from cpu 1 intr map register
        volatile uint32_t CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0xD4 - cpu from cpu 3 intr map register
        volatile uint32_t ASSIST_DEBUG_INTR_MAP;  ///< Offset: 0xD8 - assist debug intr map register
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0xDC - dma pms violatile intr map register
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0xE0 - iram0 pms violatile intr map register
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0xE4 - mac intr map register
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0xE8 - mac intr map register
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;  ///< Offset: 0xEC - mac intr map register
        volatile uint32_t BACKUP_PMS_VIOLATE_INTR_MAP;  ///< Offset: 0xF0 - mac intr map register
        volatile uint32_t CACHE_CORE0_ACS_INT_MAP;  ///< Offset: 0xF4 - mac intr map register
        volatile uint32_t INTR_STATUS_REG_0;  ///< Offset: 0xF8 - mac intr map register
        volatile uint32_t INTR_STATUS_REG_1;  ///< Offset: 0xFC - mac intr map register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x100 - mac intr map register
        volatile uint32_t CPU_INT_ENABLE;  ///< Offset: 0x104 - mac intr map register
        volatile uint32_t CPU_INT_TYPE;  ///< Offset: 0x108 - mac intr map register
        volatile uint32_t CPU_INT_CLEAR;  ///< Offset: 0x10C - mac intr map register
        volatile uint32_t CPU_INT_EIP_STATUS;  ///< Offset: 0x110 - mac intr map register
        volatile uint32_t CPU_INT_PRI_0;  ///< Offset: 0x114 - mac intr map register
        volatile uint32_t CPU_INT_PRI_1;  ///< Offset: 0x118 - mac intr map register
        volatile uint32_t CPU_INT_PRI_2;  ///< Offset: 0x11C - mac intr map register
        volatile uint32_t CPU_INT_PRI_3;  ///< Offset: 0x120 - mac intr map register
        volatile uint32_t CPU_INT_PRI_4;  ///< Offset: 0x124 - mac intr map register
        volatile uint32_t CPU_INT_PRI_5;  ///< Offset: 0x128 - mac intr map register
        volatile uint32_t CPU_INT_PRI_6;  ///< Offset: 0x12C - mac intr map register
        volatile uint32_t CPU_INT_PRI_7;  ///< Offset: 0x130 - mac intr map register
        volatile uint32_t CPU_INT_PRI_8;  ///< Offset: 0x134 - mac intr map register
        volatile uint32_t CPU_INT_PRI_9;  ///< Offset: 0x138 - mac intr map register
        volatile uint32_t CPU_INT_PRI_10;  ///< Offset: 0x13C - mac intr map register
        volatile uint32_t CPU_INT_PRI_11;  ///< Offset: 0x140 - mac intr map register
        volatile uint32_t CPU_INT_PRI_12;  ///< Offset: 0x144 - mac intr map register
        volatile uint32_t CPU_INT_PRI_13;  ///< Offset: 0x148 - mac intr map register
        volatile uint32_t CPU_INT_PRI_14;  ///< Offset: 0x14C - mac intr map register
        volatile uint32_t CPU_INT_PRI_15;  ///< Offset: 0x150 - mac intr map register
        volatile uint32_t CPU_INT_PRI_16;  ///< Offset: 0x154 - mac intr map register
        volatile uint32_t CPU_INT_PRI_17;  ///< Offset: 0x158 - mac intr map register
        volatile uint32_t CPU_INT_PRI_18;  ///< Offset: 0x15C - mac intr map register
        volatile uint32_t CPU_INT_PRI_19;  ///< Offset: 0x160 - mac intr map register
        volatile uint32_t CPU_INT_PRI_20;  ///< Offset: 0x164 - mac intr map register
        volatile uint32_t CPU_INT_PRI_21;  ///< Offset: 0x168 - mac intr map register
        volatile uint32_t CPU_INT_PRI_22;  ///< Offset: 0x16C - mac intr map register
        volatile uint32_t CPU_INT_PRI_23;  ///< Offset: 0x170 - mac intr map register
        volatile uint32_t CPU_INT_PRI_24;  ///< Offset: 0x174 - mac intr map register
        volatile uint32_t CPU_INT_PRI_25;  ///< Offset: 0x178 - mac intr map register
        volatile uint32_t CPU_INT_PRI_26;  ///< Offset: 0x17C - mac intr map register
        volatile uint32_t CPU_INT_PRI_27;  ///< Offset: 0x180 - mac intr map register
        volatile uint32_t CPU_INT_PRI_28;  ///< Offset: 0x184 - mac intr map register
        volatile uint32_t CPU_INT_PRI_29;  ///< Offset: 0x188 - mac intr map register
        volatile uint32_t CPU_INT_PRI_30;  ///< Offset: 0x18C - mac intr map register
        volatile uint32_t CPU_INT_PRI_31;  ///< Offset: 0x190 - mac intr map register
        volatile uint32_t CPU_INT_THRESH;  ///< Offset: 0x194 - mac intr map register
        volatile uint32_t INTERRUPT_REG_DATE;  ///< Offset: 0x7FC - mac intr map register
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);

    // Bit definitions
    /// MAC_INTR_MAP Register bits
    namespace mac_intr_map_bits {
        constexpr uint32_t MAC_INTR_MAP = (5 << 0);  ///< core0_mac_intr_map
    }

    /// MAC_NMI_MAP Register bits
    namespace mac_nmi_map_bits {
        constexpr uint32_t MAC_NMI_MAP = (5 << 0);  ///< reg_core0_mac_nmi_map
    }

    /// PWR_INTR_MAP Register bits
    namespace pwr_intr_map_bits {
        constexpr uint32_t PWR_INTR_MAP = (5 << 0);  ///< reg_core0_pwr_intr_map
    }

    /// BB_INT_MAP Register bits
    namespace bb_int_map_bits {
        constexpr uint32_t BB_INT_MAP = (5 << 0);  ///< reg_core0_bb_int_map
    }

    /// BT_MAC_INT_MAP Register bits
    namespace bt_mac_int_map_bits {
        constexpr uint32_t BT_MAC_INT_MAP = (5 << 0);  ///< reg_core0_bt_mac_int_map
    }

    /// BT_BB_INT_MAP Register bits
    namespace bt_bb_int_map_bits {
        constexpr uint32_t BT_BB_INT_MAP = (5 << 0);  ///< reg_core0_bt_bb_int_map
    }

    /// BT_BB_NMI_MAP Register bits
    namespace bt_bb_nmi_map_bits {
        constexpr uint32_t BT_BB_NMI_MAP = (5 << 0);  ///< reg_core0_bt_bb_nmi_map
    }

    /// RWBT_IRQ_MAP Register bits
    namespace rwbt_irq_map_bits {
        constexpr uint32_t RWBT_IRQ_MAP = (5 << 0);  ///< reg_core0_rwbt_irq_map
    }

    /// RWBLE_IRQ_MAP Register bits
    namespace rwble_irq_map_bits {
        constexpr uint32_t RWBLE_IRQ_MAP = (5 << 0);  ///< reg_core0_rwble_irq_map
    }

    /// RWBT_NMI_MAP Register bits
    namespace rwbt_nmi_map_bits {
        constexpr uint32_t RWBT_NMI_MAP = (5 << 0);  ///< reg_core0_rwbt_nmi_map
    }

    /// RWBLE_NMI_MAP Register bits
    namespace rwble_nmi_map_bits {
        constexpr uint32_t RWBLE_NMI_MAP = (5 << 0);  ///< reg_core0_rwble_nmi_map
    }

    /// I2C_MST_INT_MAP Register bits
    namespace i2c_mst_int_map_bits {
        constexpr uint32_t I2C_MST_INT_MAP = (5 << 0);  ///< reg_core0_i2c_mst_int_map
    }

    /// SLC0_INTR_MAP Register bits
    namespace slc0_intr_map_bits {
        constexpr uint32_t SLC0_INTR_MAP = (5 << 0);  ///< reg_core0_slc0_intr_map
    }

    /// SLC1_INTR_MAP Register bits
    namespace slc1_intr_map_bits {
        constexpr uint32_t SLC1_INTR_MAP = (5 << 0);  ///< reg_core0_slc1_intr_map
    }

    /// APB_CTRL_INTR_MAP Register bits
    namespace apb_ctrl_intr_map_bits {
        constexpr uint32_t APB_CTRL_INTR_MAP = (5 << 0);  ///< reg_core0_apb_ctrl_intr_map
    }

    /// UHCI0_INTR_MAP Register bits
    namespace uhci0_intr_map_bits {
        constexpr uint32_t UHCI0_INTR_MAP = (5 << 0);  ///< reg_core0_uhci0_intr_map
    }

    /// GPIO_INTERRUPT_PRO_MAP Register bits
    namespace gpio_interrupt_pro_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< reg_core0_gpio_interrupt_pro_map
    }

    /// GPIO_INTERRUPT_PRO_NMI_MAP Register bits
    namespace gpio_interrupt_pro_nmi_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< reg_core0_gpio_interrupt_pro_nmi_map
    }

    /// SPI_INTR_1_MAP Register bits
    namespace spi_intr_1_map_bits {
        constexpr uint32_t SPI_INTR_1_MAP = (5 << 0);  ///< reg_core0_spi_intr_1_map
    }

    /// SPI_INTR_2_MAP Register bits
    namespace spi_intr_2_map_bits {
        constexpr uint32_t SPI_INTR_2_MAP = (5 << 0);  ///< reg_core0_spi_intr_2_map
    }

    /// I2S1_INT_MAP Register bits
    namespace i2s1_int_map_bits {
        constexpr uint32_t I2S1_INT_MAP = (5 << 0);  ///< reg_core0_i2s1_int_map
    }

    /// UART_INTR_MAP Register bits
    namespace uart_intr_map_bits {
        constexpr uint32_t UART_INTR_MAP = (5 << 0);  ///< reg_core0_uart_intr_map
    }

    /// UART1_INTR_MAP Register bits
    namespace uart1_intr_map_bits {
        constexpr uint32_t UART1_INTR_MAP = (5 << 0);  ///< reg_core0_uart1_intr_map
    }

    /// LEDC_INT_MAP Register bits
    namespace ledc_int_map_bits {
        constexpr uint32_t LEDC_INT_MAP = (5 << 0);  ///< reg_core0_ledc_int_map
    }

    /// EFUSE_INT_MAP Register bits
    namespace efuse_int_map_bits {
        constexpr uint32_t EFUSE_INT_MAP = (5 << 0);  ///< reg_core0_efuse_int_map
    }

    /// CAN_INT_MAP Register bits
    namespace can_int_map_bits {
        constexpr uint32_t CAN_INT_MAP = (5 << 0);  ///< reg_core0_can_int_map
    }

    /// USB_INTR_MAP Register bits
    namespace usb_intr_map_bits {
        constexpr uint32_t USB_INTR_MAP = (5 << 0);  ///< reg_core0_usb_intr_map
    }

    /// RTC_CORE_INTR_MAP Register bits
    namespace rtc_core_intr_map_bits {
        constexpr uint32_t RTC_CORE_INTR_MAP = (5 << 0);  ///< reg_core0_rtc_core_intr_map
    }

    /// RMT_INTR_MAP Register bits
    namespace rmt_intr_map_bits {
        constexpr uint32_t RMT_INTR_MAP = (5 << 0);  ///< reg_core0_rmt_intr_map
    }

    /// I2C_EXT0_INTR_MAP Register bits
    namespace i2c_ext0_intr_map_bits {
        constexpr uint32_t I2C_EXT0_INTR_MAP = (5 << 0);  ///< reg_core0_i2c_ext0_intr_map
    }

    /// TIMER_INT1_MAP Register bits
    namespace timer_int1_map_bits {
        constexpr uint32_t TIMER_INT1_MAP = (5 << 0);  ///< reg_core0_timer_int1_map
    }

    /// TIMER_INT2_MAP Register bits
    namespace timer_int2_map_bits {
        constexpr uint32_t TIMER_INT2_MAP = (5 << 0);  ///< reg_core0_timer_int2_map
    }

    /// TG_T0_INT_MAP Register bits
    namespace tg_t0_int_map_bits {
        constexpr uint32_t TG_T0_INT_MAP = (5 << 0);  ///< reg_core0_tg_t0_int_map
    }

    /// TG_WDT_INT_MAP Register bits
    namespace tg_wdt_int_map_bits {
        constexpr uint32_t TG_WDT_INT_MAP = (5 << 0);  ///< reg_core0_tg_wdt_int_map
    }

    /// TG1_T0_INT_MAP Register bits
    namespace tg1_t0_int_map_bits {
        constexpr uint32_t TG1_T0_INT_MAP = (5 << 0);  ///< reg_core0_tg1_t0_int_map
    }

    /// TG1_WDT_INT_MAP Register bits
    namespace tg1_wdt_int_map_bits {
        constexpr uint32_t TG1_WDT_INT_MAP = (5 << 0);  ///< reg_core0_tg1_wdt_int_map
    }

    /// CACHE_IA_INT_MAP Register bits
    namespace cache_ia_int_map_bits {
        constexpr uint32_t CACHE_IA_INT_MAP = (5 << 0);  ///< reg_core0_cache_ia_int_map
    }

    /// SYSTIMER_TARGET0_INT_MAP Register bits
    namespace systimer_target0_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET0_INT_MAP = (5 << 0);  ///< reg_core0_systimer_target0_int_map
    }

    /// SYSTIMER_TARGET1_INT_MAP Register bits
    namespace systimer_target1_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET1_INT_MAP = (5 << 0);  ///< reg_core0_systimer_target1_int_map
    }

    /// SYSTIMER_TARGET2_INT_MAP Register bits
    namespace systimer_target2_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET2_INT_MAP = (5 << 0);  ///< reg_core0_systimer_target2_int_map
    }

    /// SPI_MEM_REJECT_INTR_MAP Register bits
    namespace spi_mem_reject_intr_map_bits {
        constexpr uint32_t SPI_MEM_REJECT_INTR_MAP = (5 << 0);  ///< reg_core0_spi_mem_reject_intr_map
    }

    /// ICACHE_PRELOAD_INT_MAP Register bits
    namespace icache_preload_int_map_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_MAP = (5 << 0);  ///< reg_core0_icache_preload_int_map
    }

    /// ICACHE_SYNC_INT_MAP Register bits
    namespace icache_sync_int_map_bits {
        constexpr uint32_t ICACHE_SYNC_INT_MAP = (5 << 0);  ///< reg_core0_icache_sync_int_map
    }

    /// APB_ADC_INT_MAP Register bits
    namespace apb_adc_int_map_bits {
        constexpr uint32_t APB_ADC_INT_MAP = (5 << 0);  ///< reg_core0_apb_adc_int_map
    }

    /// DMA_CH0_INT_MAP Register bits
    namespace dma_ch0_int_map_bits {
        constexpr uint32_t DMA_CH0_INT_MAP = (5 << 0);  ///< reg_core0_dma_ch0_int_map
    }

    /// DMA_CH1_INT_MAP Register bits
    namespace dma_ch1_int_map_bits {
        constexpr uint32_t DMA_CH1_INT_MAP = (5 << 0);  ///< reg_core0_dma_ch1_int_map
    }

    /// DMA_CH2_INT_MAP Register bits
    namespace dma_ch2_int_map_bits {
        constexpr uint32_t DMA_CH2_INT_MAP = (5 << 0);  ///< reg_core0_dma_ch2_int_map
    }

    /// RSA_INT_MAP Register bits
    namespace rsa_int_map_bits {
        constexpr uint32_t RSA_INT_MAP = (5 << 0);  ///< reg_core0_rsa_int_map
    }

    /// AES_INT_MAP Register bits
    namespace aes_int_map_bits {
        constexpr uint32_t AES_INT_MAP = (5 << 0);  ///< reg_core0_aes_int_map
    }

    /// SHA_INT_MAP Register bits
    namespace sha_int_map_bits {
        constexpr uint32_t SHA_INT_MAP = (5 << 0);  ///< reg_core0_sha_int_map
    }

    /// CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< reg_core0_cpu_intr_from_cpu_0_map
    }

    /// CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< reg_core0_cpu_intr_from_cpu_1_map
    }

    /// CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< reg_core0_cpu_intr_from_cpu_2_map
    }

    /// CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< reg_core0_cpu_intr_from_cpu_3_map
    }

    /// ASSIST_DEBUG_INTR_MAP Register bits
    namespace assist_debug_intr_map_bits {
        constexpr uint32_t ASSIST_DEBUG_INTR_MAP = (5 << 0);  ///< reg_core0_assist_debug_intr_map
    }

    /// DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace dma_apbperi_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< reg_core0_dma_apbperi_pms_monitor_violate_intr_map
    }

    /// CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_iram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< reg_core0_core_0_iram0_pms_monitor_violate_intr_map
    }

    /// CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_dram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< reg_core0_core_0_dram0_pms_monitor_violate_intr_map
    }

    /// CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_pif_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< reg_core0_core_0_pif_pms_monitor_violate_intr_map
    }

    /// CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP Register bits
    namespace core_0_pif_pms_monitor_violate_size_intr_map_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP = (5 << 0);  ///< reg_core0_core_0_pif_pms_monitor_violate_size_intr_map
    }

    /// BACKUP_PMS_VIOLATE_INTR_MAP Register bits
    namespace backup_pms_violate_intr_map_bits {
        constexpr uint32_t BACKUP_PMS_VIOLATE_INTR_MAP = (5 << 0);  ///< reg_core0_backup_pms_violate_intr_map
    }

    /// CACHE_CORE0_ACS_INT_MAP Register bits
    namespace cache_core0_acs_int_map_bits {
        constexpr uint32_t CACHE_CORE0_ACS_INT_MAP = (5 << 0);  ///< reg_core0_cache_core0_acs_int_map
    }

    /// INTR_STATUS_REG_0 Register bits
    namespace intr_status_reg_0_bits {
        constexpr uint32_t INTR_STATUS_0 = (32 << 0);  ///< reg_core0_intr_status_0
    }

    /// INTR_STATUS_REG_1 Register bits
    namespace intr_status_reg_1_bits {
        constexpr uint32_t INTR_STATUS_1 = (32 << 0);  ///< reg_core0_intr_status_1
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< reg_core0_reg_clk_en
    }

    /// CPU_INT_ENABLE Register bits
    namespace cpu_int_enable_bits {
        constexpr uint32_t CPU_INT_ENABLE = (32 << 0);  ///< reg_core0_cpu_int_enable
    }

    /// CPU_INT_TYPE Register bits
    namespace cpu_int_type_bits {
        constexpr uint32_t CPU_INT_TYPE = (32 << 0);  ///< reg_core0_cpu_int_type
    }

    /// CPU_INT_CLEAR Register bits
    namespace cpu_int_clear_bits {
        constexpr uint32_t CPU_INT_CLEAR = (32 << 0);  ///< reg_core0_cpu_int_clear
    }

    /// CPU_INT_EIP_STATUS Register bits
    namespace cpu_int_eip_status_bits {
        constexpr uint32_t CPU_INT_EIP_STATUS = (32 << 0);  ///< reg_core0_cpu_int_eip_status
    }

    /// CPU_INT_PRI_0 Register bits
    namespace cpu_int_pri_0_bits {
        constexpr uint32_t CPU_PRI_0_MAP = (4 << 0);  ///< reg_core0_cpu_pri_0_map
    }

    /// CPU_INT_PRI_1 Register bits
    namespace cpu_int_pri_1_bits {
        constexpr uint32_t CPU_PRI_1_MAP = (4 << 0);  ///< reg_core0_cpu_pri_1_map
    }

    /// CPU_INT_PRI_2 Register bits
    namespace cpu_int_pri_2_bits {
        constexpr uint32_t CPU_PRI_2_MAP = (4 << 0);  ///< reg_core0_cpu_pri_2_map
    }

    /// CPU_INT_PRI_3 Register bits
    namespace cpu_int_pri_3_bits {
        constexpr uint32_t CPU_PRI_3_MAP = (4 << 0);  ///< reg_core0_cpu_pri_3_map
    }

    /// CPU_INT_PRI_4 Register bits
    namespace cpu_int_pri_4_bits {
        constexpr uint32_t CPU_PRI_4_MAP = (4 << 0);  ///< reg_core0_cpu_pri_4_map
    }

    /// CPU_INT_PRI_5 Register bits
    namespace cpu_int_pri_5_bits {
        constexpr uint32_t CPU_PRI_5_MAP = (4 << 0);  ///< reg_core0_cpu_pri_5_map
    }

    /// CPU_INT_PRI_6 Register bits
    namespace cpu_int_pri_6_bits {
        constexpr uint32_t CPU_PRI_6_MAP = (4 << 0);  ///< reg_core0_cpu_pri_6_map
    }

    /// CPU_INT_PRI_7 Register bits
    namespace cpu_int_pri_7_bits {
        constexpr uint32_t CPU_PRI_7_MAP = (4 << 0);  ///< reg_core0_cpu_pri_7_map
    }

    /// CPU_INT_PRI_8 Register bits
    namespace cpu_int_pri_8_bits {
        constexpr uint32_t CPU_PRI_8_MAP = (4 << 0);  ///< reg_core0_cpu_pri_8_map
    }

    /// CPU_INT_PRI_9 Register bits
    namespace cpu_int_pri_9_bits {
        constexpr uint32_t CPU_PRI_9_MAP = (4 << 0);  ///< reg_core0_cpu_pri_9_map
    }

    /// CPU_INT_PRI_10 Register bits
    namespace cpu_int_pri_10_bits {
        constexpr uint32_t CPU_PRI_10_MAP = (4 << 0);  ///< reg_core0_cpu_pri_10_map
    }

    /// CPU_INT_PRI_11 Register bits
    namespace cpu_int_pri_11_bits {
        constexpr uint32_t CPU_PRI_11_MAP = (4 << 0);  ///< reg_core0_cpu_pri_11_map
    }

    /// CPU_INT_PRI_12 Register bits
    namespace cpu_int_pri_12_bits {
        constexpr uint32_t CPU_PRI_12_MAP = (4 << 0);  ///< reg_core0_cpu_pri_12_map
    }

    /// CPU_INT_PRI_13 Register bits
    namespace cpu_int_pri_13_bits {
        constexpr uint32_t CPU_PRI_13_MAP = (4 << 0);  ///< reg_core0_cpu_pri_13_map
    }

    /// CPU_INT_PRI_14 Register bits
    namespace cpu_int_pri_14_bits {
        constexpr uint32_t CPU_PRI_14_MAP = (4 << 0);  ///< reg_core0_cpu_pri_14_map
    }

    /// CPU_INT_PRI_15 Register bits
    namespace cpu_int_pri_15_bits {
        constexpr uint32_t CPU_PRI_15_MAP = (4 << 0);  ///< reg_core0_cpu_pri_15_map
    }

    /// CPU_INT_PRI_16 Register bits
    namespace cpu_int_pri_16_bits {
        constexpr uint32_t CPU_PRI_16_MAP = (4 << 0);  ///< reg_core0_cpu_pri_16_map
    }

    /// CPU_INT_PRI_17 Register bits
    namespace cpu_int_pri_17_bits {
        constexpr uint32_t CPU_PRI_17_MAP = (4 << 0);  ///< reg_core0_cpu_pri_17_map
    }

    /// CPU_INT_PRI_18 Register bits
    namespace cpu_int_pri_18_bits {
        constexpr uint32_t CPU_PRI_18_MAP = (4 << 0);  ///< reg_core0_cpu_pri_18_map
    }

    /// CPU_INT_PRI_19 Register bits
    namespace cpu_int_pri_19_bits {
        constexpr uint32_t CPU_PRI_19_MAP = (4 << 0);  ///< reg_core0_cpu_pri_19_map
    }

    /// CPU_INT_PRI_20 Register bits
    namespace cpu_int_pri_20_bits {
        constexpr uint32_t CPU_PRI_20_MAP = (4 << 0);  ///< reg_core0_cpu_pri_20_map
    }

    /// CPU_INT_PRI_21 Register bits
    namespace cpu_int_pri_21_bits {
        constexpr uint32_t CPU_PRI_21_MAP = (4 << 0);  ///< reg_core0_cpu_pri_21_map
    }

    /// CPU_INT_PRI_22 Register bits
    namespace cpu_int_pri_22_bits {
        constexpr uint32_t CPU_PRI_22_MAP = (4 << 0);  ///< reg_core0_cpu_pri_22_map
    }

    /// CPU_INT_PRI_23 Register bits
    namespace cpu_int_pri_23_bits {
        constexpr uint32_t CPU_PRI_23_MAP = (4 << 0);  ///< reg_core0_cpu_pri_23_map
    }

    /// CPU_INT_PRI_24 Register bits
    namespace cpu_int_pri_24_bits {
        constexpr uint32_t CPU_PRI_24_MAP = (4 << 0);  ///< reg_core0_cpu_pri_24_map
    }

    /// CPU_INT_PRI_25 Register bits
    namespace cpu_int_pri_25_bits {
        constexpr uint32_t CPU_PRI_25_MAP = (4 << 0);  ///< reg_core0_cpu_pri_25_map
    }

    /// CPU_INT_PRI_26 Register bits
    namespace cpu_int_pri_26_bits {
        constexpr uint32_t CPU_PRI_26_MAP = (4 << 0);  ///< reg_core0_cpu_pri_26_map
    }

    /// CPU_INT_PRI_27 Register bits
    namespace cpu_int_pri_27_bits {
        constexpr uint32_t CPU_PRI_27_MAP = (4 << 0);  ///< reg_core0_cpu_pri_27_map
    }

    /// CPU_INT_PRI_28 Register bits
    namespace cpu_int_pri_28_bits {
        constexpr uint32_t CPU_PRI_28_MAP = (4 << 0);  ///< reg_core0_cpu_pri_28_map
    }

    /// CPU_INT_PRI_29 Register bits
    namespace cpu_int_pri_29_bits {
        constexpr uint32_t CPU_PRI_29_MAP = (4 << 0);  ///< reg_core0_cpu_pri_29_map
    }

    /// CPU_INT_PRI_30 Register bits
    namespace cpu_int_pri_30_bits {
        constexpr uint32_t CPU_PRI_30_MAP = (4 << 0);  ///< reg_core0_cpu_pri_30_map
    }

    /// CPU_INT_PRI_31 Register bits
    namespace cpu_int_pri_31_bits {
        constexpr uint32_t CPU_PRI_31_MAP = (4 << 0);  ///< reg_core0_cpu_pri_31_map
    }

    /// CPU_INT_THRESH Register bits
    namespace cpu_int_thresh_bits {
        constexpr uint32_t CPU_INT_THRESH = (4 << 0);  ///< reg_core0_cpu_int_thresh
    }

    /// INTERRUPT_REG_DATE Register bits
    namespace interrupt_reg_date_bits {
        constexpr uint32_t INTERRUPT_REG_DATE = (28 << 0);  ///< reg_core0_interrupt_reg_date
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x60009000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - Clock Output Configuration Register
        volatile uint32_t GPIO;  ///< Offset: 0x04 - IO MUX Configure Register for pad XTAL_32K_P (renamed from GPIO)
        volatile uint32_t DATE;  ///< Offset: 0xFC - IO MUX Version Control Register
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t CLK_OUT1 = (4 << 0);  ///< If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT2 = (4 << 4);  ///< If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT3 = (4 << 8);  ///< If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
    }

    /// GPIO Register bits
    namespace gpio_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function 2; etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x60019000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH_CONF0;  ///< Offset: 0x00 - LEDC_LSCH%s_CONF%s. (renamed from CH_CONF0)
        volatile uint32_t CH_HPOINT;  ///< Offset: 0x04 - LEDC_LSCH%s_HPOINT. (renamed from CH_HPOINT)
        volatile uint32_t CH_DUTY;  ///< Offset: 0x08 - LEDC_LSCH%s_DUTY. (renamed from CH_DUTY)
        volatile uint32_t CH_CONF1;  ///< Offset: 0x0C - LEDC_LSCH%s_CONF1. (renamed from CH_CONF1)
        volatile uint32_t CH_DUTY_R;  ///< Offset: 0x10 - LEDC_LSCH%s_DUTY_R. (renamed from CH_DUTY_R)
        volatile uint32_t TIMER_CONF;  ///< Offset: 0xA0 - LEDC_LSTIMER%s_CONF. (renamed from TIMER_CONF)
        volatile uint32_t TIMER_VALUE;  ///< Offset: 0xA4 - LEDC_LSTIMER%s_VALUE. (renamed from TIMER_VALUE)
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - LEDC_INT_RAW.
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - LEDC_INT_ST.
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - LEDC_INT_ENA.
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - LEDC_INT_CLR.
        volatile uint32_t CONF;  ///< Offset: 0xD0 - LEDC_CONF.
        volatile uint32_t DATE;  ///< Offset: 0xFC - LEDC_DATE.
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);

    // Bit definitions
    /// CH_CONF0 Register bits
    namespace ch_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< reg_timer_sel_lsch0.
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< reg_sig_out_en_lsch0.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< reg_idle_lv_lsch0.
        constexpr uint32_t PARA_UP = (1U << 4);  ///< reg_para_up_lsch0.
        constexpr uint32_t OVF_NUM = (10 << 5);  ///< reg_ovf_num_lsch0.
        constexpr uint32_t OVF_CNT_EN = (1U << 15);  ///< reg_ovf_cnt_en_lsch0.
        constexpr uint32_t OVF_CNT_RESET = (1U << 16);  ///< reg_ovf_cnt_reset_lsch0.
    }

    /// CH_HPOINT Register bits
    namespace ch_hpoint_bits {
        constexpr uint32_t HPOINT = (14 << 0);  ///< reg_hpoint_lsch0.
    }

    /// CH_DUTY Register bits
    namespace ch_duty_bits {
        constexpr uint32_t DUTY = (19 << 0);  ///< reg_duty_lsch0.
    }

    /// CH_CONF1 Register bits
    namespace ch_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< reg_duty_scale_lsch0.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< reg_duty_cycle_lsch0.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< reg_duty_num_lsch0.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< reg_duty_inc_lsch0.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< reg_duty_start_lsch0.
    }

    /// CH_DUTY_R Register bits
    namespace ch_duty_r_bits {
        constexpr uint32_t DUTY_R = (19 << 0);  ///< reg_duty_lsch0_r.
    }

    /// TIMER_CONF Register bits
    namespace timer_conf_bits {
        constexpr uint32_t DUTY_RES = (4 << 0);  ///< reg_lstimer0_duty_res.
        constexpr uint32_t CLK_DIV = (18 << 4);  ///< reg_clk_div_lstimer0.
        constexpr uint32_t PAUSE = (1U << 22);  ///< reg_lstimer0_pause.
        constexpr uint32_t RST = (1U << 23);  ///< reg_lstimer0_rst.
        constexpr uint32_t TICK_SEL = (1U << 24);  ///< reg_tick_sel_lstimer0.
        constexpr uint32_t PARA_UP = (1U << 25);  ///< reg_lstimer0_para_up.
    }

    /// TIMER_VALUE Register bits
    namespace timer_value_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< reg_lstimer0_cnt.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t LSTIMER0_OVF_INT_RAW = (1U << 0);  ///< reg_lstimer0_ovf_int_raw.
        constexpr uint32_t LSTIMER1_OVF_INT_RAW = (1U << 1);  ///< reg_lstimer1_ovf_int_raw.
        constexpr uint32_t LSTIMER2_OVF_INT_RAW = (1U << 2);  ///< reg_lstimer2_ovf_int_raw.
        constexpr uint32_t LSTIMER3_OVF_INT_RAW = (1U << 3);  ///< reg_lstimer3_ovf_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_RAW = (1U << 4);  ///< reg_duty_chng_end_lsch0_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_RAW = (1U << 5);  ///< reg_duty_chng_end_lsch1_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_RAW = (1U << 6);  ///< reg_duty_chng_end_lsch2_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_RAW = (1U << 7);  ///< reg_duty_chng_end_lsch3_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_RAW = (1U << 8);  ///< reg_duty_chng_end_lsch4_int_raw.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_RAW = (1U << 9);  ///< reg_duty_chng_end_lsch5_int_raw.
        constexpr uint32_t OVF_CNT_LSCH0_INT_RAW = (1U << 10);  ///< reg_ovf_cnt_lsch0_int_raw.
        constexpr uint32_t OVF_CNT_LSCH1_INT_RAW = (1U << 11);  ///< reg_ovf_cnt_lsch1_int_raw.
        constexpr uint32_t OVF_CNT_LSCH2_INT_RAW = (1U << 12);  ///< reg_ovf_cnt_lsch2_int_raw.
        constexpr uint32_t OVF_CNT_LSCH3_INT_RAW = (1U << 13);  ///< reg_ovf_cnt_lsch3_int_raw.
        constexpr uint32_t OVF_CNT_LSCH4_INT_RAW = (1U << 14);  ///< reg_ovf_cnt_lsch4_int_raw.
        constexpr uint32_t OVF_CNT_LSCH5_INT_RAW = (1U << 15);  ///< reg_ovf_cnt_lsch5_int_raw.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t LSTIMER0_OVF_INT_ST = (1U << 0);  ///< reg_lstimer0_ovf_int_st.
        constexpr uint32_t LSTIMER1_OVF_INT_ST = (1U << 1);  ///< reg_lstimer1_ovf_int_st.
        constexpr uint32_t LSTIMER2_OVF_INT_ST = (1U << 2);  ///< reg_lstimer2_ovf_int_st.
        constexpr uint32_t LSTIMER3_OVF_INT_ST = (1U << 3);  ///< reg_lstimer3_ovf_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_ST = (1U << 4);  ///< reg_duty_chng_end_lsch0_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_ST = (1U << 5);  ///< reg_duty_chng_end_lsch1_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_ST = (1U << 6);  ///< reg_duty_chng_end_lsch2_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_ST = (1U << 7);  ///< reg_duty_chng_end_lsch3_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_ST = (1U << 8);  ///< reg_duty_chng_end_lsch4_int_st.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_ST = (1U << 9);  ///< reg_duty_chng_end_lsch5_int_st.
        constexpr uint32_t OVF_CNT_LSCH0_INT_ST = (1U << 10);  ///< reg_ovf_cnt_lsch0_int_st.
        constexpr uint32_t OVF_CNT_LSCH1_INT_ST = (1U << 11);  ///< reg_ovf_cnt_lsch1_int_st.
        constexpr uint32_t OVF_CNT_LSCH2_INT_ST = (1U << 12);  ///< reg_ovf_cnt_lsch2_int_st.
        constexpr uint32_t OVF_CNT_LSCH3_INT_ST = (1U << 13);  ///< reg_ovf_cnt_lsch3_int_st.
        constexpr uint32_t OVF_CNT_LSCH4_INT_ST = (1U << 14);  ///< reg_ovf_cnt_lsch4_int_st.
        constexpr uint32_t OVF_CNT_LSCH5_INT_ST = (1U << 15);  ///< reg_ovf_cnt_lsch5_int_st.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t LSTIMER0_OVF_INT_ENA = (1U << 0);  ///< reg_lstimer0_ovf_int_ena.
        constexpr uint32_t LSTIMER1_OVF_INT_ENA = (1U << 1);  ///< reg_lstimer1_ovf_int_ena.
        constexpr uint32_t LSTIMER2_OVF_INT_ENA = (1U << 2);  ///< reg_lstimer2_ovf_int_ena.
        constexpr uint32_t LSTIMER3_OVF_INT_ENA = (1U << 3);  ///< reg_lstimer3_ovf_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_ENA = (1U << 4);  ///< reg_duty_chng_end_lsch0_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_ENA = (1U << 5);  ///< reg_duty_chng_end_lsch1_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_ENA = (1U << 6);  ///< reg_duty_chng_end_lsch2_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_ENA = (1U << 7);  ///< reg_duty_chng_end_lsch3_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_ENA = (1U << 8);  ///< reg_duty_chng_end_lsch4_int_ena.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_ENA = (1U << 9);  ///< reg_duty_chng_end_lsch5_int_ena.
        constexpr uint32_t OVF_CNT_LSCH0_INT_ENA = (1U << 10);  ///< reg_ovf_cnt_lsch0_int_ena.
        constexpr uint32_t OVF_CNT_LSCH1_INT_ENA = (1U << 11);  ///< reg_ovf_cnt_lsch1_int_ena.
        constexpr uint32_t OVF_CNT_LSCH2_INT_ENA = (1U << 12);  ///< reg_ovf_cnt_lsch2_int_ena.
        constexpr uint32_t OVF_CNT_LSCH3_INT_ENA = (1U << 13);  ///< reg_ovf_cnt_lsch3_int_ena.
        constexpr uint32_t OVF_CNT_LSCH4_INT_ENA = (1U << 14);  ///< reg_ovf_cnt_lsch4_int_ena.
        constexpr uint32_t OVF_CNT_LSCH5_INT_ENA = (1U << 15);  ///< reg_ovf_cnt_lsch5_int_ena.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t LSTIMER0_OVF_INT_CLR = (1U << 0);  ///< reg_lstimer0_ovf_int_clr.
        constexpr uint32_t LSTIMER1_OVF_INT_CLR = (1U << 1);  ///< reg_lstimer1_ovf_int_clr.
        constexpr uint32_t LSTIMER2_OVF_INT_CLR = (1U << 2);  ///< reg_lstimer2_ovf_int_clr.
        constexpr uint32_t LSTIMER3_OVF_INT_CLR = (1U << 3);  ///< reg_lstimer3_ovf_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH0_INT_CLR = (1U << 4);  ///< reg_duty_chng_end_lsch0_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH1_INT_CLR = (1U << 5);  ///< reg_duty_chng_end_lsch1_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH2_INT_CLR = (1U << 6);  ///< reg_duty_chng_end_lsch2_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH3_INT_CLR = (1U << 7);  ///< reg_duty_chng_end_lsch3_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH4_INT_CLR = (1U << 8);  ///< reg_duty_chng_end_lsch4_int_clr.
        constexpr uint32_t DUTY_CHNG_END_LSCH5_INT_CLR = (1U << 9);  ///< reg_duty_chng_end_lsch5_int_clr.
        constexpr uint32_t OVF_CNT_LSCH0_INT_CLR = (1U << 10);  ///< reg_ovf_cnt_lsch0_int_clr.
        constexpr uint32_t OVF_CNT_LSCH1_INT_CLR = (1U << 11);  ///< reg_ovf_cnt_lsch1_int_clr.
        constexpr uint32_t OVF_CNT_LSCH2_INT_CLR = (1U << 12);  ///< reg_ovf_cnt_lsch2_int_clr.
        constexpr uint32_t OVF_CNT_LSCH3_INT_CLR = (1U << 13);  ///< reg_ovf_cnt_lsch3_int_clr.
        constexpr uint32_t OVF_CNT_LSCH4_INT_CLR = (1U << 14);  ///< reg_ovf_cnt_lsch4_int_clr.
        constexpr uint32_t OVF_CNT_LSCH5_INT_CLR = (1U << 15);  ///< reg_ovf_cnt_lsch5_int_clr.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< reg_apb_clk_sel.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< reg_clk_en.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LEDC_DATE = (32 << 0);  ///< reg_ledc_date.
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x60016000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t CHDATA;  ///< Offset: 0x00 - RMT_CH%sDATA_REG. (renamed from CHDATA)
        volatile uint32_t CH_TX_CONF0;  ///< Offset: 0x10 - RMT_CH%sCONF%s_REG. (renamed from CH_TX_CONF0)
        volatile uint32_t CH_RX_CONF0;  ///< Offset: 0x18 - RMT_CH2CONF0_REG. (renamed from CH_RX_CONF0)
        volatile uint32_t CH_RX_CONF1;  ///< Offset: 0x1C - RMT_CH2CONF1_REG. (renamed from CH_RX_CONF1)
        volatile uint32_t CH_TX_STATUS;  ///< Offset: 0x28 - RMT_CH%sSTATUS_REG. (renamed from CH_TX_STATUS)
        volatile uint32_t CH_RX_STATUS;  ///< Offset: 0x30 - RMT_CH2STATUS_REG. (renamed from CH_RX_STATUS)
        volatile uint32_t INT_RAW;  ///< Offset: 0x38 - RMT_INT_RAW_REG.
        volatile uint32_t INT_ST;  ///< Offset: 0x3C - RMT_INT_ST_REG.
        volatile uint32_t INT_ENA;  ///< Offset: 0x40 - RMT_INT_ENA_REG.
        volatile uint32_t INT_CLR;  ///< Offset: 0x44 - RMT_INT_CLR_REG.
        volatile uint32_t CHCARRIER_DUTY;  ///< Offset: 0x48 - RMT_CH%sCARRIER_DUTY_REG. (renamed from CHCARRIER_DUTY)
        volatile uint32_t CH_RX_CARRIER_RM;  ///< Offset: 0x50 - RMT_CH2_RX_CARRIER_RM_REG. (renamed from CH_RX_CARRIER_RM)
        volatile uint32_t CH_TX_LIM;  ///< Offset: 0x58 - RMT_CH%s_TX_LIM_REG. (renamed from CH_TX_LIM)
        volatile uint32_t CH_RX_LIM;  ///< Offset: 0x60 - RMT_CH2_RX_LIM_REG. (renamed from CH_RX_LIM)
        volatile uint32_t SYS_CONF;  ///< Offset: 0x68 - RMT_SYS_CONF_REG.
        volatile uint32_t TX_SIM;  ///< Offset: 0x6C - RMT_TX_SIM_REG.
        volatile uint32_t REF_CNT_RST;  ///< Offset: 0x70 - RMT_REF_CNT_RST_REG.
        volatile uint32_t DATE;  ///< Offset: 0xCC - RMT_DATE_REG.
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// CHDATA Register bits
    namespace chdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Reserved.
    }

    /// CH_TX_CONF0 Register bits
    namespace ch_tx_conf0_bits {
        constexpr uint32_t TX_START = (1U << 0);  ///< reg_tx_start_ch0.
        constexpr uint32_t MEM_RD_RST = (1U << 1);  ///< reg_mem_rd_rst_ch0.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< reg_apb_mem_rst_ch0.
        constexpr uint32_t TX_CONTI_MODE = (1U << 3);  ///< reg_tx_conti_mode_ch0.
        constexpr uint32_t MEM_TX_WRAP_EN = (1U << 4);  ///< reg_mem_tx_wrap_en_ch0.
        constexpr uint32_t IDLE_OUT_LV = (1U << 5);  ///< reg_idle_out_lv_ch0.
        constexpr uint32_t IDLE_OUT_EN = (1U << 6);  ///< reg_idle_out_en_ch0.
        constexpr uint32_t TX_STOP = (1U << 7);  ///< reg_tx_stop_ch0.
        constexpr uint32_t DIV_CNT = (8 << 8);  ///< reg_div_cnt_ch0.
        constexpr uint32_t MEM_SIZE = (3 << 16);  ///< reg_mem_size_ch0.
        constexpr uint32_t CARRIER_EFF_EN = (1U << 20);  ///< reg_carrier_eff_en_ch0.
        constexpr uint32_t CARRIER_EN = (1U << 21);  ///< reg_carrier_en_ch0.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 22);  ///< reg_carrier_out_lv_ch0.
        constexpr uint32_t AFIFO_RST = (1U << 23);  ///< reg_afifo_rst_ch0.
        constexpr uint32_t CONF_UPDATE = (1U << 24);  ///< reg_reg_conf_update_ch0.
    }

    /// CH_RX_CONF0 Register bits
    namespace ch_rx_conf0_bits {
        constexpr uint32_t DIV_CNT = (8 << 0);  ///< reg_div_cnt_ch2.
        constexpr uint32_t IDLE_THRES = (15 << 8);  ///< reg_idle_thres_ch2.
        constexpr uint32_t MEM_SIZE = (3 << 23);  ///< reg_mem_size_ch2.
        constexpr uint32_t CARRIER_EN = (1U << 28);  ///< reg_carrier_en_ch2.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 29);  ///< reg_carrier_out_lv_ch2.
    }

    /// CH_RX_CONF1 Register bits
    namespace ch_rx_conf1_bits {
        constexpr uint32_t RX_EN = (1U << 0);  ///< reg_rx_en_ch2.
        constexpr uint32_t MEM_WR_RST = (1U << 1);  ///< reg_mem_wr_rst_ch2.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< reg_apb_mem_rst_ch2.
        constexpr uint32_t MEM_OWNER = (1U << 3);  ///< reg_mem_owner_ch2.
        constexpr uint32_t RX_FILTER_EN = (1U << 4);  ///< reg_rx_filter_en_ch2.
        constexpr uint32_t RX_FILTER_THRES = (8 << 5);  ///< reg_rx_filter_thres_ch2.
        constexpr uint32_t MEM_RX_WRAP_EN = (1U << 13);  ///< reg_mem_rx_wrap_en_ch2.
        constexpr uint32_t AFIFO_RST = (1U << 14);  ///< reg_afifo_rst_ch2.
        constexpr uint32_t CONF_UPDATE = (1U << 15);  ///< reg_conf_update_ch2.
    }

    /// CH_TX_STATUS Register bits
    namespace ch_tx_status_bits {
        constexpr uint32_t MEM_RADDR_EX = (9 << 0);  ///< reg_mem_raddr_ex_ch0.
        constexpr uint32_t STATE = (3 << 9);  ///< reg_state_ch0.
        constexpr uint32_t APB_MEM_WADDR = (9 << 12);  ///< reg_apb_mem_waddr_ch0.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 21);  ///< reg_apb_mem_rd_err_ch0.
        constexpr uint32_t MEM_EMPTY = (1U << 22);  ///< reg_mem_empty_ch0.
        constexpr uint32_t APB_MEM_WR_ERR = (1U << 23);  ///< reg_apb_mem_wr_err_ch0.
        constexpr uint32_t APB_MEM_RADDR = (8 << 24);  ///< reg_apb_mem_raddr_ch0.
    }

    /// CH_RX_STATUS Register bits
    namespace ch_rx_status_bits {
        constexpr uint32_t MEM_WADDR_EX = (9 << 0);  ///< reg_mem_waddr_ex_ch2.
        constexpr uint32_t APB_MEM_RADDR = (9 << 12);  ///< reg_apb_mem_raddr_ch2.
        constexpr uint32_t STATE = (3 << 22);  ///< reg_state_ch2.
        constexpr uint32_t MEM_OWNER_ERR = (1U << 25);  ///< reg_mem_owner_err_ch2.
        constexpr uint32_t MEM_FULL = (1U << 26);  ///< reg_mem_full_ch2.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 27);  ///< reg_apb_mem_rd_err_ch2.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< reg_ch%s_tx_end_int_raw. (renamed from CH_TX_END)
        constexpr uint32_t CH_RX_END = (1U << 2);  ///< reg_ch2_rx_end_int_raw. (renamed from CH_RX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< reg_ch%s_err_int_raw. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_RX_ERR = (1U << 6);  ///< reg_ch2_err_int_raw. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< reg_ch%s_tx_thr_event_int_raw. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 10);  ///< reg_ch2_rx_thr_event_int_raw. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< reg_ch%s_tx_loop_int_raw. (renamed from CH_TX_LOOP)
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< reg_ch%s_tx_end_int_st. (renamed from CH_TX_END)
        constexpr uint32_t CH_RX_END = (1U << 2);  ///< reg_ch2_rx_end_int_st. (renamed from CH_RX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< reg_ch%s_err_int_st. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_RX_ERR = (1U << 6);  ///< reg_ch2_err_int_st. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< reg_ch%s_tx_thr_event_int_st. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 10);  ///< reg_ch2_rx_thr_event_int_st. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< reg_ch%s_tx_loop_int_st. (renamed from CH_TX_LOOP)
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< reg_ch%s_tx_end_int_ena. (renamed from CH_TX_END)
        constexpr uint32_t CH_RX_END = (1U << 2);  ///< reg_ch2_rx_end_int_ena. (renamed from CH_RX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< reg_ch%s_err_int_ena. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_RX_ERR = (1U << 6);  ///< reg_ch2_err_int_ena. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< reg_ch%s_tx_thr_event_int_ena. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 10);  ///< reg_ch2_rx_thr_event_int_ena. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< reg_ch%s_tx_loop_int_ena. (renamed from CH_TX_LOOP)
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< reg_ch%s_tx_end_int_clr. (renamed from CH_TX_END)
        constexpr uint32_t CH_RX_END = (1U << 2);  ///< reg_ch2_rx_end_int_clr. (renamed from CH_RX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< reg_ch%s_err_int_clr. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_RX_ERR = (1U << 6);  ///< reg_ch2_err_int_clr. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< reg_ch%s_tx_thr_event_int_clr. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 10);  ///< reg_ch2_rx_thr_event_int_clr. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< reg_ch%s_tx_loop_int_clr. (renamed from CH_TX_LOOP)
    }

    /// CHCARRIER_DUTY Register bits
    namespace chcarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW = (16 << 0);  ///< reg_carrier_low_ch0.
        constexpr uint32_t CARRIER_HIGH = (16 << 16);  ///< reg_carrier_high_ch0.
    }

    /// CH_RX_CARRIER_RM Register bits
    namespace ch_rx_carrier_rm_bits {
        constexpr uint32_t CARRIER_LOW_THRES = (16 << 0);  ///< reg_carrier_low_thres_ch2.
        constexpr uint32_t CARRIER_HIGH_THRES = (16 << 16);  ///< reg_carrier_high_thres_ch2.
    }

    /// CH_TX_LIM Register bits
    namespace ch_tx_lim_bits {
        constexpr uint32_t TX_LIM = (9 << 0);  ///< reg_rmt_tx_lim_ch0.
        constexpr uint32_t TX_LOOP_NUM = (10 << 9);  ///< reg_rmt_tx_loop_num_ch0.
        constexpr uint32_t TX_LOOP_CNT_EN = (1U << 19);  ///< reg_rmt_tx_loop_cnt_en_ch0.
        constexpr uint32_t LOOP_COUNT_RESET = (1U << 20);  ///< reg_loop_count_reset_ch0.
    }

    /// CH_RX_LIM Register bits
    namespace ch_rx_lim_bits {
        constexpr uint32_t RX_LIM = (9 << 0);  ///< reg_rmt_rx_lim_ch2.
    }

    /// SYS_CONF Register bits
    namespace sys_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< reg_apb_fifo_mask.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< reg_mem_clk_force_on.
        constexpr uint32_t MEM_FORCE_PD = (1U << 2);  ///< reg_rmt_mem_force_pd.
        constexpr uint32_t MEM_FORCE_PU = (1U << 3);  ///< reg_rmt_mem_force_pu.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 4);  ///< reg_rmt_sclk_div_num.
        constexpr uint32_t SCLK_DIV_A = (6 << 12);  ///< reg_rmt_sclk_div_a.
        constexpr uint32_t SCLK_DIV_B = (6 << 18);  ///< reg_rmt_sclk_div_b.
        constexpr uint32_t SCLK_SEL = (2 << 24);  ///< reg_rmt_sclk_sel.
        constexpr uint32_t SCLK_ACTIVE = (1U << 26);  ///< reg_rmt_sclk_active.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< reg_clk_en.
    }

    /// TX_SIM Register bits
    namespace tx_sim_bits {
        constexpr uint32_t TX_SIM_CH0 = (1U << 0);  ///< reg_rmt_tx_sim_ch0.
        constexpr uint32_t TX_SIM_CH1 = (1U << 1);  ///< reg_rmt_tx_sim_ch1.
        constexpr uint32_t TX_SIM_EN = (1U << 2);  ///< reg_rmt_tx_sim_en.
    }

    /// REF_CNT_RST Register bits
    namespace ref_cnt_rst_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< reg_ref_cnt_rst_ch0.
        constexpr uint32_t CH1 = (1U << 1);  ///< reg_ref_cnt_rst_ch1.
        constexpr uint32_t CH2 = (1U << 2);  ///< reg_ref_cnt_rst_ch2.
        constexpr uint32_t CH3 = (1U << 3);  ///< reg_ref_cnt_rst_ch3.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< reg_rmt_date.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x60026000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0xB0 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_CNTL_BASE = 0x60008000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t OPTIONS0;  ///< Offset: 0x00 - rtc configure register
        volatile uint32_t SLP_TIMER0;  ///< Offset: 0x04 - rtc configure register
        volatile uint32_t SLP_TIMER1;  ///< Offset: 0x08 - rtc configure register
        volatile uint32_t TIME_UPDATE;  ///< Offset: 0x0C - rtc configure register
        volatile uint32_t TIME_LOW0;  ///< Offset: 0x10 - rtc configure register
        volatile uint32_t TIME_HIGH0;  ///< Offset: 0x14 - rtc configure register
        volatile uint32_t STATE0;  ///< Offset: 0x18 - rtc configure register
        volatile uint32_t TIMER1;  ///< Offset: 0x1C - rtc configure register
        volatile uint32_t TIMER2;  ///< Offset: 0x20 - rtc configure register
        volatile uint32_t TIMER3;  ///< Offset: 0x24 - rtc configure register
        volatile uint32_t TIMER4;  ///< Offset: 0x28 - rtc configure register
        volatile uint32_t TIMER5;  ///< Offset: 0x2C - rtc configure register
        volatile uint32_t TIMER6;  ///< Offset: 0x30 - rtc configure register
        volatile uint32_t ANA_CONF;  ///< Offset: 0x34 - rtc configure register
        volatile uint32_t RESET_STATE;  ///< Offset: 0x38 - rtc configure register
        volatile uint32_t WAKEUP_STATE;  ///< Offset: 0x3C - rtc configure register
        volatile uint32_t INT_ENA_RTC;  ///< Offset: 0x40 - rtc configure register
        volatile uint32_t INT_RAW_RTC;  ///< Offset: 0x44 - rtc configure register
        volatile uint32_t INT_ST_RTC;  ///< Offset: 0x48 - rtc configure register
        volatile uint32_t INT_CLR_RTC;  ///< Offset: 0x4C - rtc configure register
        volatile uint32_t STORE0;  ///< Offset: 0x50 - rtc configure register
        volatile uint32_t STORE1;  ///< Offset: 0x54 - rtc configure register
        volatile uint32_t STORE2;  ///< Offset: 0x58 - rtc configure register
        volatile uint32_t STORE3;  ///< Offset: 0x5C - rtc configure register
        volatile uint32_t EXT_XTL_CONF;  ///< Offset: 0x60 - rtc configure register
        volatile uint32_t EXT_WAKEUP_CONF;  ///< Offset: 0x64 - rtc configure register
        volatile uint32_t SLP_REJECT_CONF;  ///< Offset: 0x68 - rtc configure register
        volatile uint32_t CPU_PERIOD_CONF;  ///< Offset: 0x6C - rtc configure register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x70 - rtc configure register
        volatile uint32_t SLOW_CLK_CONF;  ///< Offset: 0x74 - rtc configure register
        volatile uint32_t SDIO_CONF;  ///< Offset: 0x78 - rtc configure register
        volatile uint32_t BIAS_CONF;  ///< Offset: 0x7C - rtc configure register
        volatile uint32_t RTC_CNTL;  ///< Offset: 0x80 - rtc configure register
        volatile uint32_t PWC;  ///< Offset: 0x84 - rtc configure register
        volatile uint32_t DIG_PWC;  ///< Offset: 0x88 - rtc configure register
        volatile uint32_t DIG_ISO;  ///< Offset: 0x8C - rtc configure register
        volatile uint32_t WDTCONFIG0;  ///< Offset: 0x90 - rtc configure register
        volatile uint32_t WDTCONFIG1;  ///< Offset: 0x94 - rtc configure register
        volatile uint32_t WDTCONFIG2;  ///< Offset: 0x98 - rtc configure register
        volatile uint32_t WDTCONFIG3;  ///< Offset: 0x9C - rtc configure register
        volatile uint32_t WDTCONFIG4;  ///< Offset: 0xA0 - rtc configure register
        volatile uint32_t WDTFEED;  ///< Offset: 0xA4 - rtc configure register
        volatile uint32_t WDTWPROTECT;  ///< Offset: 0xA8 - rtc configure register
        volatile uint32_t SWD_CONF;  ///< Offset: 0xAC - rtc configure register
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0xB0 - rtc configure register
        volatile uint32_t SW_CPU_STALL;  ///< Offset: 0xB4 - rtc configure register
        volatile uint32_t STORE4;  ///< Offset: 0xB8 - rtc configure register
        volatile uint32_t STORE5;  ///< Offset: 0xBC - rtc configure register
        volatile uint32_t STORE6;  ///< Offset: 0xC0 - rtc configure register
        volatile uint32_t STORE7;  ///< Offset: 0xC4 - rtc configure register
        volatile uint32_t LOW_POWER_ST;  ///< Offset: 0xC8 - rtc configure register
        volatile uint32_t DIAG0;  ///< Offset: 0xCC - rtc configure register
        volatile uint32_t PAD_HOLD;  ///< Offset: 0xD0 - rtc configure register
        volatile uint32_t DIG_PAD_HOLD;  ///< Offset: 0xD4 - rtc configure register
        volatile uint32_t BROWN_OUT;  ///< Offset: 0xD8 - rtc configure register
        volatile uint32_t TIME_LOW1;  ///< Offset: 0xDC - rtc configure register
        volatile uint32_t TIME_HIGH1;  ///< Offset: 0xE0 - rtc configure register
        volatile uint32_t XTAL32K_CLK_FACTOR;  ///< Offset: 0xE4 - rtc configure register
        volatile uint32_t XTAL32K_CONF;  ///< Offset: 0xE8 - rtc configure register
        volatile uint32_t USB_CONF;  ///< Offset: 0xEC - rtc configure register
        volatile uint32_t SLP_REJECT_CAUSE;  ///< Offset: 0xF0 - RTC_CNTL_RTC_SLP_REJECT_CAUSE_REG
        volatile uint32_t OPTION1;  ///< Offset: 0xF4 - rtc configure register
        volatile uint32_t SLP_WAKEUP_CAUSE;  ///< Offset: 0xF8 - RTC_CNTL_RTC_SLP_WAKEUP_CAUSE_REG
        volatile uint32_t ULP_CP_TIMER_1;  ///< Offset: 0xFC - rtc configure register
        volatile uint32_t INT_ENA_RTC_W1TS;  ///< Offset: 0x100 - rtc configure register
        volatile uint32_t INT_ENA_RTC_W1TC;  ///< Offset: 0x104 - rtc configure register
        volatile uint32_t RETENTION_CTRL;  ///< Offset: 0x108 - rtc configure register
        volatile uint32_t FIB_SEL;  ///< Offset: 0x10C - rtc configure register
        volatile uint32_t GPIO_WAKEUP;  ///< Offset: 0x110 - rtc configure register
        volatile uint32_t DBG_SEL;  ///< Offset: 0x114 - rtc configure register
        volatile uint32_t DBG_MAP;  ///< Offset: 0x118 - rtc configure register
        volatile uint32_t SENSOR_CTRL;  ///< Offset: 0x11C - rtc configure register
        volatile uint32_t DBG_SAR_SEL;  ///< Offset: 0x120 - rtc configure register
        volatile uint32_t PG_CTRL;  ///< Offset: 0x124 - rtc configure register
        volatile uint32_t DATE;  ///< Offset: 0x1FC - rtc configure register
    };

    /// Peripheral instances
    inline Registers* RTC_CNTL = reinterpret_cast<Registers*>(RTC_CNTL_BASE);

    // Bit definitions
    /// OPTIONS0 Register bits
    namespace options0_bits {
        constexpr uint32_t SW_STALL_APPCPU_C0 = (2 << 0);  ///< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
        constexpr uint32_t SW_STALL_PROCPU_C0 = (2 << 2);  ///< {reg_sw_stall_procpu_c1[5:0], reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall PRO CPU
        constexpr uint32_t SW_APPCPU_RST = (1U << 4);  ///< APP CPU SW reset
        constexpr uint32_t SW_PROCPU_RST = (1U << 5);  ///< PRO CPU SW reset
        constexpr uint32_t BB_I2C_FORCE_PD = (1U << 6);  ///< BB_I2C force power down
        constexpr uint32_t BB_I2C_FORCE_PU = (1U << 7);  ///< BB_I2C force power up
        constexpr uint32_t BBPLL_I2C_FORCE_PD = (1U << 8);  ///< BB_PLL _I2C force power down
        constexpr uint32_t BBPLL_I2C_FORCE_PU = (1U << 9);  ///< BB_PLL_I2C force power up
        constexpr uint32_t BBPLL_FORCE_PD = (1U << 10);  ///< BB_PLL force power down
        constexpr uint32_t BBPLL_FORCE_PU = (1U << 11);  ///< BB_PLL force power up
        constexpr uint32_t XTL_FORCE_PD = (1U << 12);  ///< crystall force power down
        constexpr uint32_t XTL_FORCE_PU = (1U << 13);  ///< crystall force power up
        constexpr uint32_t XTL_EN_WAIT = (4 << 14);  ///< wait bias_sleep and current source wakeup
        constexpr uint32_t XTL_EXT_CTR_SEL = (3 << 20);  ///< analog configure
        constexpr uint32_t XTL_FORCE_ISO = (1U << 23);  ///< analog configure
        constexpr uint32_t PLL_FORCE_ISO = (1U << 24);  ///< analog configure
        constexpr uint32_t ANALOG_FORCE_ISO = (1U << 25);  ///< analog configure
        constexpr uint32_t XTL_FORCE_NOISO = (1U << 26);  ///< analog configure
        constexpr uint32_t PLL_FORCE_NOISO = (1U << 27);  ///< analog configure
        constexpr uint32_t ANALOG_FORCE_NOISO = (1U << 28);  ///< analog configure
        constexpr uint32_t DG_WRAP_FORCE_RST = (1U << 29);  ///< digital wrap force reset in deep sleep
        constexpr uint32_t DG_WRAP_FORCE_NORST = (1U << 30);  ///< digital core force no reset in deep sleep
        constexpr uint32_t SW_SYS_RST = (1U << 31);  ///< SW system reset
    }

    /// SLP_TIMER0 Register bits
    namespace slp_timer0_bits {
        constexpr uint32_t SLP_VAL_LO = (32 << 0);  ///< configure the sleep time
    }

    /// SLP_TIMER1 Register bits
    namespace slp_timer1_bits {
        constexpr uint32_t SLP_VAL_HI = (16 << 0);  ///< RTC sleep timer high 16 bits
        constexpr uint32_t MAIN_TIMER_ALARM_EN = (1U << 16);  ///< timer alarm enable bit
    }

    /// TIME_UPDATE Register bits
    namespace time_update_bits {
        constexpr uint32_t TIMER_SYS_STALL = (1U << 27);  ///< Enable to record system stall time
        constexpr uint32_t TIMER_XTL_OFF = (1U << 28);  ///< Enable to record 40M XTAL OFF time
        constexpr uint32_t TIMER_SYS_RST = (1U << 29);  ///< enable to record system reset time
        constexpr uint32_t TIME_UPDATE = (1U << 31);  ///< Set 1: to update register with RTC timer
    }

    /// TIME_LOW0 Register bits
    namespace time_low0_bits {
        constexpr uint32_t TIMER_VALUE0_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH0 Register bits
    namespace time_high0_bits {
        constexpr uint32_t TIMER_VALUE0_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t SW_CPU_INT = (1U << 0);  ///< rtc software interrupt to main cpu
        constexpr uint32_t SLP_REJECT_CAUSE_CLR = (1U << 1);  ///< clear rtc sleep reject cause
        constexpr uint32_t APB2RTC_BRIDGE_SEL = (1U << 22);  ///< 1: APB to RTC using bridge
        constexpr uint32_t SDIO_ACTIVE_IND = (1U << 28);  ///< SDIO active indication
        constexpr uint32_t SLP_WAKEUP = (1U << 29);  ///< leep wakeup bit
        constexpr uint32_t SLP_REJECT = (1U << 30);  ///< leep reject bit
        constexpr uint32_t SLEEP_EN = (1U << 31);  ///< sleep enable bit
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t CPU_STALL_EN = (1U << 0);  ///< CPU stall enable bit
        constexpr uint32_t CPU_STALL_WAIT = (5 << 1);  ///< CPU stall wait cycles in fast_clk_rtc
        constexpr uint32_t CK8M_WAIT = (8 << 6);  ///< CK8M wait cycles in slow_clk_rtc
        constexpr uint32_t XTL_BUF_WAIT = (10 << 14);  ///< XTAL wait cycles in slow_clk_rtc
        constexpr uint32_t PLL_BUF_WAIT = (8 << 24);  ///< PLL wait cycles in slow_clk_rtc
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t MIN_TIME_CK8M_OFF = (8 << 24);  ///< minimal cycles in slow_clk_rtc for CK8M in power down state
    }

    /// TIMER3 Register bits
    namespace timer3_bits {
        constexpr uint32_t WIFI_WAIT_TIMER = (9 << 0);  ///< wifi power domain wakeup time
        constexpr uint32_t WIFI_POWERUP_TIMER = (7 << 9);  ///< wifi power domain power on time
        constexpr uint32_t BT_WAIT_TIMER = (9 << 16);  ///< bt power domain wakeup time
        constexpr uint32_t BT_POWERUP_TIMER = (7 << 25);  ///< bt power domain power on time
    }

    /// TIMER4 Register bits
    namespace timer4_bits {
        constexpr uint32_t CPU_TOP_WAIT_TIMER = (9 << 0);  ///< cpu top power domain wakeup time
        constexpr uint32_t CPU_TOP_POWERUP_TIMER = (7 << 9);  ///< cpu top power domain power on time
        constexpr uint32_t DG_WRAP_WAIT_TIMER = (9 << 16);  ///< digital wrap power domain wakeup time
        constexpr uint32_t DG_WRAP_POWERUP_TIMER = (7 << 25);  ///< digital wrap power domain power on time
    }

    /// TIMER5 Register bits
    namespace timer5_bits {
        constexpr uint32_t MIN_SLP_VAL = (8 << 8);  ///< minimal sleep cycles in slow_clk_rtc
    }

    /// TIMER6 Register bits
    namespace timer6_bits {
        constexpr uint32_t DG_PERI_WAIT_TIMER = (9 << 16);  ///< digital peri power domain wakeup time
        constexpr uint32_t DG_PERI_POWERUP_TIMER = (7 << 25);  ///< digital peri power domain power on time
    }

    /// ANA_CONF Register bits
    namespace ana_conf_bits {
        constexpr uint32_t RESET_POR_FORCE_PD = (1U << 18);  ///< force no bypass i2c power on reset
        constexpr uint32_t RESET_POR_FORCE_PU = (1U << 19);  ///< force bypass i2c power on reset
        constexpr uint32_t GLITCH_RST_EN = (1U << 20);  ///< enable glitch reset
        constexpr uint32_t SAR_I2C_PU = (1U << 22);  ///< PLLA force power up
        constexpr uint32_t PLLA_FORCE_PD = (1U << 23);  ///< PLLA force power down
        constexpr uint32_t PLLA_FORCE_PU = (1U << 24);  ///< PLLA force power up
        constexpr uint32_t BBPLL_CAL_SLP_START = (1U << 25);  ///< start BBPLL calibration during sleep
        constexpr uint32_t PVTMON_PU = (1U << 26);  ///< 1: PVTMON power up
        constexpr uint32_t TXRF_I2C_PU = (1U << 27);  ///< 1: TXRF_I2C power up
        constexpr uint32_t RFRX_PBUS_PU = (1U << 28);  ///< 1: RFRX_PBUS power up
        constexpr uint32_t CKGEN_I2C_PU = (1U << 30);  ///< 1: CKGEN_I2C power up
        constexpr uint32_t PLL_I2C_PU = (1U << 31);  ///< power up pll i2c
    }

    /// RESET_STATE Register bits
    namespace reset_state_bits {
        constexpr uint32_t RESET_CAUSE_PROCPU = (6 << 0);  ///< reset cause of PRO CPU
        constexpr uint32_t RESET_CAUSE_APPCPU = (6 << 6);  ///< reset cause of APP CPU
        constexpr uint32_t STAT_VECTOR_SEL_APPCPU = (1U << 12);  ///< APP CPU state vector sel
        constexpr uint32_t STAT_VECTOR_SEL_PROCPU = (1U << 13);  ///< PRO CPU state vector sel
        constexpr uint32_t ALL_RESET_FLAG_PROCPU = (1U << 14);  ///< PRO CPU reset_flag
        constexpr uint32_t ALL_RESET_FLAG_APPCPU = (1U << 15);  ///< APP CPU reset flag
        constexpr uint32_t ALL_RESET_FLAG_CLR_PROCPU = (1U << 16);  ///< clear PRO CPU reset_flag
        constexpr uint32_t ALL_RESET_FLAG_CLR_APPCPU = (1U << 17);  ///< clear APP CPU reset flag
        constexpr uint32_t OCD_HALT_ON_RESET_APPCPU = (1U << 18);  ///< APPCPU OcdHaltOnReset
        constexpr uint32_t OCD_HALT_ON_RESET_PROCPU = (1U << 19);  ///< PROCPU OcdHaltOnReset
        constexpr uint32_t JTAG_RESET_FLAG_PROCPU = (1U << 20);  ///< configure jtag reset configure
        constexpr uint32_t JTAG_RESET_FLAG_APPCPU = (1U << 21);  ///< configure jtag reset configure
        constexpr uint32_t JTAG_RESET_FLAG_CLR_PROCPU = (1U << 22);  ///< configure jtag reset configure
        constexpr uint32_t JTAG_RESET_FLAG_CLR_APPCPU = (1U << 23);  ///< configure jtag reset configure
        constexpr uint32_t DRESET_MASK_APPCPU = (1U << 24);  ///< configure dreset configure
        constexpr uint32_t DRESET_MASK_PROCPU = (1U << 25);  ///< configure dreset configure
    }

    /// WAKEUP_STATE Register bits
    namespace wakeup_state_bits {
        constexpr uint32_t WAKEUP_ENA = (17 << 15);  ///< wakeup enable bitmap
    }

    /// INT_ENA_RTC Register bits
    namespace int_ena_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t WDT_INT_ENA = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SWD_INT_ENA = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t XTAL32K_DEAD_INT_ENA = (1U << 16);  ///< enable xtal32k_dead interrupt
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 19);  ///< enbale gitch det interrupt
        constexpr uint32_t BBPLL_CAL_INT_ENA = (1U << 20);  ///< enbale bbpll cal end interrupt
    }

    /// INT_RAW_RTC Register bits
    namespace int_raw_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_RAW = (1U << 0);  ///< sleep wakeup interrupt raw
        constexpr uint32_t SLP_REJECT_INT_RAW = (1U << 1);  ///< sleep reject interrupt raw
        constexpr uint32_t WDT_INT_RAW = (1U << 3);  ///< RTC WDT interrupt raw
        constexpr uint32_t BROWN_OUT_INT_RAW = (1U << 9);  ///< brown out interrupt raw
        constexpr uint32_t MAIN_TIMER_INT_RAW = (1U << 10);  ///< RTC main timer interrupt raw
        constexpr uint32_t SWD_INT_RAW = (1U << 15);  ///< super watch dog interrupt raw
        constexpr uint32_t XTAL32K_DEAD_INT_RAW = (1U << 16);  ///< xtal32k dead detection interrupt raw
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 19);  ///< glitch_det_interrupt_raw
        constexpr uint32_t BBPLL_CAL_INT_RAW = (1U << 20);  ///< bbpll cal end interrupt state
    }

    /// INT_ST_RTC Register bits
    namespace int_st_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ST = (1U << 0);  ///< sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_ST = (1U << 1);  ///< sleep reject interrupt state
        constexpr uint32_t WDT_INT_ST = (1U << 3);  ///< RTC WDT interrupt state
        constexpr uint32_t BROWN_OUT_INT_ST = (1U << 9);  ///< brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_ST = (1U << 10);  ///< RTC main timer interrupt state
        constexpr uint32_t SWD_INT_ST = (1U << 15);  ///< super watch dog interrupt state
        constexpr uint32_t XTAL32K_DEAD_INT_ST = (1U << 16);  ///< xtal32k dead detection interrupt state
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 19);  ///< glitch_det_interrupt state
        constexpr uint32_t BBPLL_CAL_INT_ST = (1U << 20);  ///< bbpll cal end interrupt state
    }

    /// INT_CLR_RTC Register bits
    namespace int_clr_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_CLR = (1U << 0);  ///< Clear sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_CLR = (1U << 1);  ///< Clear sleep reject interrupt state
        constexpr uint32_t WDT_INT_CLR = (1U << 3);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t BROWN_OUT_INT_CLR = (1U << 9);  ///< Clear brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_CLR = (1U << 10);  ///< Clear RTC main timer interrupt state
        constexpr uint32_t SWD_INT_CLR = (1U << 15);  ///< Clear super watch dog interrupt state
        constexpr uint32_t XTAL32K_DEAD_INT_CLR = (1U << 16);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 19);  ///< Clear glitch det interrupt state
        constexpr uint32_t BBPLL_CAL_INT_CLR = (1U << 20);  ///< clear bbpll cal end interrupt state
    }

    /// STORE0 Register bits
    namespace store0_bits {
        constexpr uint32_t SCRATCH0 = (32 << 0);  ///< reserved register
    }

    /// STORE1 Register bits
    namespace store1_bits {
        constexpr uint32_t SCRATCH1 = (32 << 0);  ///< reserved register
    }

    /// STORE2 Register bits
    namespace store2_bits {
        constexpr uint32_t SCRATCH2 = (32 << 0);  ///< reserved register
    }

    /// STORE3 Register bits
    namespace store3_bits {
        constexpr uint32_t SCRATCH3 = (32 << 0);  ///< reserved register
    }

    /// EXT_XTL_CONF Register bits
    namespace ext_xtl_conf_bits {
        constexpr uint32_t XTAL32K_WDT_EN = (1U << 0);  ///< xtal 32k watch dog enable
        constexpr uint32_t XTAL32K_WDT_CLK_FO = (1U << 1);  ///< xtal 32k watch dog clock force on
        constexpr uint32_t XTAL32K_WDT_RESET = (1U << 2);  ///< xtal 32k watch dog sw reset
        constexpr uint32_t XTAL32K_EXT_CLK_FO = (1U << 3);  ///< xtal 32k external xtal clock force on
        constexpr uint32_t XTAL32K_AUTO_BACKUP = (1U << 4);  ///< xtal 32k switch to back up clock when xtal is dead
        constexpr uint32_t XTAL32K_AUTO_RESTART = (1U << 5);  ///< xtal 32k restart xtal when xtal is dead
        constexpr uint32_t XTAL32K_AUTO_RETURN = (1U << 6);  ///< xtal 32k switch back xtal when xtal is restarted
        constexpr uint32_t XTAL32K_XPD_FORCE = (1U << 7);  ///< Xtal 32k xpd control by sw or fsm
        constexpr uint32_t ENCKINIT_XTAL_32K = (1U << 8);  ///< apply an internal clock to help xtal 32k to start
        constexpr uint32_t DBUF_XTAL_32K = (1U << 9);  ///< 0: single-end buffer 1: differential buffer
        constexpr uint32_t DGM_XTAL_32K = (3 << 10);  ///< xtal_32k gm control
        constexpr uint32_t DRES_XTAL_32K = (3 << 13);  ///< DRES_XTAL_32K
        constexpr uint32_t XPD_XTAL_32K = (1U << 16);  ///< XPD_XTAL_32K
        constexpr uint32_t DAC_XTAL_32K = (3 << 17);  ///< DAC_XTAL_32K
        constexpr uint32_t WDT_STATE = (3 << 20);  ///< state of 32k_wdt
        constexpr uint32_t XTAL32K_GPIO_SEL = (1U << 23);  ///< XTAL_32K sel. 0: external XTAL_32K
        constexpr uint32_t XTL_EXT_CTR_LV = (1U << 30);  ///< 0: power down XTAL at high level
        constexpr uint32_t XTL_EXT_CTR_EN = (1U << 31);  ///< enable gpio configure xtal power on
    }

    /// EXT_WAKEUP_CONF Register bits
    namespace ext_wakeup_conf_bits {
        constexpr uint32_t GPIO_WAKEUP_FILTER = (1U << 31);  ///< enable filter for gpio wakeup event
    }

    /// SLP_REJECT_CONF Register bits
    namespace slp_reject_conf_bits {
        constexpr uint32_t SLEEP_REJECT_ENA = (18 << 12);  ///< sleep reject enable
        constexpr uint32_t LIGHT_SLP_REJECT_EN = (1U << 30);  ///< enable reject for light sleep
        constexpr uint32_t DEEP_SLP_REJECT_EN = (1U << 31);  ///< enable reject for deep sleep
    }

    /// CPU_PERIOD_CONF Register bits
    namespace cpu_period_conf_bits {
        constexpr uint32_t CPUSEL_CONF = (1U << 29);  ///< CPU sel option
        constexpr uint32_t CPUPERIOD_SEL = (2 << 30);  ///< CPU clk sel option
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t EFUSE_CLK_FORCE_GATING = (1U << 1);  ///< efuse_clk_force_gating
        constexpr uint32_t EFUSE_CLK_FORCE_NOGATING = (1U << 2);  ///< efuse_clk_force_nogating
        constexpr uint32_t CK8M_DIV_SEL_VLD = (1U << 3);  ///< used to sync reg_ck8m_div_sel bus. Clear vld before set reg_ck8m_div_sel
        constexpr uint32_t CK8M_DIV = (2 << 4);  ///< CK8M_D256_OUT divider. 00: div128
        constexpr uint32_t ENB_CK8M = (1U << 6);  ///< disable CK8M and CK8M_D256_OUT
        constexpr uint32_t ENB_CK8M_DIV = (1U << 7);  ///< 1: CK8M_D256_OUT is actually CK8M
        constexpr uint32_t DIG_XTAL32K_EN = (1U << 8);  ///< enable CK_XTAL_32K for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_D256_EN = (1U << 9);  ///< enable CK8M_D256_OUT for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_EN = (1U << 10);  ///< enable CK8M for digital core (no relationship with RTC core)
        constexpr uint32_t CK8M_DIV_SEL = (3 << 12);  ///< divider = reg_ck8m_div_sel + 1
        constexpr uint32_t XTAL_FORCE_NOGATING = (1U << 15);  ///< XTAL force no gating during sleep
        constexpr uint32_t CK8M_FORCE_NOGATING = (1U << 16);  ///< CK8M force no gating during sleep
        constexpr uint32_t CK8M_DFREQ = (8 << 17);  ///< CK8M_DFREQ
        constexpr uint32_t CK8M_FORCE_PD = (1U << 25);  ///< CK8M force power down
        constexpr uint32_t CK8M_FORCE_PU = (1U << 26);  ///< CK8M force power up
        constexpr uint32_t XTAL_GLOBAL_FORCE_GATING = (1U << 27);  ///< force enable xtal clk gating
        constexpr uint32_t XTAL_GLOBAL_FORCE_NOGATING = (1U << 28);  ///< force bypass xtal clk gating
        constexpr uint32_t FAST_CLK_RTC_SEL = (1U << 29);  ///< fast_clk_rtc sel. 0: XTAL div 4
        constexpr uint32_t ANA_CLK_RTC_SEL = (2 << 30);  ///< slelect rtc slow clk
    }

    /// SLOW_CLK_CONF Register bits
    namespace slow_clk_conf_bits {
        constexpr uint32_t ANA_CLK_DIV_VLD = (1U << 22);  ///< used to sync div bus. clear vld before set reg_rtc_ana_clk_div
        constexpr uint32_t ANA_CLK_DIV = (8 << 23);  ///< the clk divider num of RTC_CLK
        constexpr uint32_t SLOW_CLK_NEXT_EDGE = (1U << 31);  ///< flag rtc_slow_clk_next_edge
    }

    /// SDIO_CONF Register bits
    namespace sdio_conf_bits {
        constexpr uint32_t SDIO_TIMER_TARGET = (8 << 0);  ///< timer count to apply reg_sdio_dcap after sdio power on
        constexpr uint32_t SDIO_DTHDRV = (2 << 9);  ///< Tieh = 1 mode drive ability. Initially set to 0 to limit charge current
        constexpr uint32_t SDIO_DCAP = (2 << 11);  ///< ability to prevent LDO from overshoot
        constexpr uint32_t SDIO_INITI = (2 << 13);  ///< add resistor from ldo output to ground. 0: no res
        constexpr uint32_t SDIO_EN_INITI = (1U << 15);  ///< 0 to set init[1:0]=0
        constexpr uint32_t SDIO_DCURLIM = (3 << 16);  ///< tune current limit threshold when tieh = 0. About 800mA/(8+d)
        constexpr uint32_t SDIO_MODECURLIM = (1U << 19);  ///< select current limit mode
        constexpr uint32_t SDIO_ENCURLIM = (1U << 20);  ///< enable current limit
        constexpr uint32_t SDIO_REG_PD_EN = (1U << 21);  ///< power down SDIO_REG in sleep. Only active when reg_sdio_force = 0
        constexpr uint32_t SDIO_FORCE = (1U << 22);  ///< 1: use SW option to control SDIO_REG
        constexpr uint32_t SDIO_TIEH = (1U << 23);  ///< SW option for SDIO_TIEH. Only active when reg_sdio_force = 1
        constexpr uint32_t _1P8_READY = (1U << 24);  ///< read only register for REG1P8_READY
        constexpr uint32_t DREFL_SDIO = (2 << 25);  ///< SW option for DREFL_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFM_SDIO = (2 << 27);  ///< SW option for DREFM_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFH_SDIO = (2 << 29);  ///< SW option for DREFH_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t XPD_SDIO = (1U << 31);  ///< XPD_SDIO
    }

    /// BIAS_CONF Register bits
    namespace bias_conf_bits {
        constexpr uint32_t DG_VDD_DRV_B_SLP = (8 << 0);  ///< DG_VDD_DRV_B_SLP
        constexpr uint32_t DG_VDD_DRV_B_SLP_EN = (1U << 8);  ///< DG_VDD_DRV_B_SLP_EN
        constexpr uint32_t BIAS_BUF_IDLE = (1U << 10);  ///< bias buf when rtc in normal work state
        constexpr uint32_t BIAS_BUF_WAKE = (1U << 11);  ///< bias buf when rtc in wakeup state
        constexpr uint32_t BIAS_BUF_DEEP_SLP = (1U << 12);  ///< bias buf when rtc in sleep state
        constexpr uint32_t BIAS_BUF_MONITOR = (1U << 13);  ///< bias buf when rtc in monitor state
        constexpr uint32_t PD_CUR_DEEP_SLP = (1U << 14);  ///< xpd cur when rtc in sleep_state
        constexpr uint32_t PD_CUR_MONITOR = (1U << 15);  ///< xpd cur when rtc in monitor state
        constexpr uint32_t BIAS_SLEEP_DEEP_SLP = (1U << 16);  ///< bias_sleep when rtc in sleep_state
        constexpr uint32_t BIAS_SLEEP_MONITOR = (1U << 17);  ///< bias_sleep when rtc in monitor state
        constexpr uint32_t DBG_ATTEN_DEEP_SLP = (4 << 18);  ///< DBG_ATTEN when rtc in sleep state
        constexpr uint32_t DBG_ATTEN_MONITOR = (4 << 22);  ///< DBG_ATTEN when rtc in monitor state
    }

    /// RTC_CNTL Register bits
    namespace rtc_cntl_bits {
        constexpr uint32_t DIG_REG_CAL_EN = (1U << 7);  ///< software enable digital regulator cali
        constexpr uint32_t SCK_DCAP = (8 << 14);  ///< SCK_DCAP
        constexpr uint32_t DBOOST_FORCE_PD = (1U << 28);  ///< RTC_DBOOST force power down
        constexpr uint32_t DBOOST_FORCE_PU = (1U << 29);  ///< RTC_DBOOST force power up
        constexpr uint32_t REGULATOR_FORCE_PD = (1U << 30);  ///< RTC_REG force power down (for RTC_REG power down means decrease the voltage to 0.8v or lower )
        constexpr uint32_t REGULATOR_FORCE_PU = (1U << 31);  ///< RTC_REG force power up
    }

    /// PWC Register bits
    namespace pwc_bits {
        constexpr uint32_t PAD_FORCE_HOLD = (1U << 21);  ///< rtc pad force hold
    }

    /// DIG_PWC Register bits
    namespace dig_pwc_bits {
        constexpr uint32_t VDD_SPI_PWR_DRV = (2 << 0);  ///< vdd_spi drv's software value
        constexpr uint32_t VDD_SPI_PWR_FORCE = (1U << 2);  ///< vdd_spi drv use software value
        constexpr uint32_t LSLP_MEM_FORCE_PD = (1U << 3);  ///< memories in digital core force PD in sleep
        constexpr uint32_t LSLP_MEM_FORCE_PU = (1U << 4);  ///< memories in digital core force PU in sleep
        constexpr uint32_t BT_FORCE_PD = (1U << 11);  ///< bt force power down
        constexpr uint32_t BT_FORCE_PU = (1U << 12);  ///< bt force power up
        constexpr uint32_t DG_PERI_FORCE_PD = (1U << 13);  ///< digital peri force power down
        constexpr uint32_t DG_PERI_FORCE_PU = (1U << 14);  ///< digital peri force power up
        constexpr uint32_t FASTMEM_FORCE_LPD = (1U << 15);  ///< fastmemory retention mode in sleep
        constexpr uint32_t FASTMEM_FORCE_LPU = (1U << 16);  ///< fastmemory donlt entry retention mode in sleep
        constexpr uint32_t WIFI_FORCE_PD = (1U << 17);  ///< wifi force power down
        constexpr uint32_t WIFI_FORCE_PU = (1U << 18);  ///< wifi force power up
        constexpr uint32_t DG_WRAP_FORCE_PD = (1U << 19);  ///< digital core force power down
        constexpr uint32_t DG_WRAP_FORCE_PU = (1U << 20);  ///< digital core force power up
        constexpr uint32_t CPU_TOP_FORCE_PD = (1U << 21);  ///< cpu core force power down
        constexpr uint32_t CPU_TOP_FORCE_PU = (1U << 22);  ///< cpu force power up
        constexpr uint32_t BT_PD_EN = (1U << 27);  ///< enable power down bt in sleep
        constexpr uint32_t DG_PERI_PD_EN = (1U << 28);  ///< enable power down digital peri in sleep
        constexpr uint32_t CPU_TOP_PD_EN = (1U << 29);  ///< enable power down cpu in sleep
        constexpr uint32_t WIFI_PD_EN = (1U << 30);  ///< enable power down wifi in sleep
        constexpr uint32_t DG_WRAP_PD_EN = (1U << 31);  ///< enable power down digital wrap in sleep
    }

    /// DIG_ISO Register bits
    namespace dig_iso_bits {
        constexpr uint32_t FORCE_OFF = (1U << 7);  ///< DIG_ISO force off
        constexpr uint32_t FORCE_ON = (1U << 8);  ///< DIG_ISO force on
        constexpr uint32_t DG_PAD_AUTOHOLD = (1U << 9);  ///< read only register to indicate digital pad auto-hold status
        constexpr uint32_t CLR_DG_PAD_AUTOHOLD = (1U << 10);  ///< wtite only register to clear digital pad auto-hold
        constexpr uint32_t DG_PAD_AUTOHOLD_EN = (1U << 11);  ///< digital pad enable auto-hold
        constexpr uint32_t DG_PAD_FORCE_NOISO = (1U << 12);  ///< digital pad force no ISO
        constexpr uint32_t DG_PAD_FORCE_ISO = (1U << 13);  ///< digital pad force ISO
        constexpr uint32_t DG_PAD_FORCE_UNHOLD = (1U << 14);  ///< digital pad force un-hold
        constexpr uint32_t DG_PAD_FORCE_HOLD = (1U << 15);  ///< digital pad force hold
        constexpr uint32_t BT_FORCE_ISO = (1U << 22);  ///< bt force ISO
        constexpr uint32_t BT_FORCE_NOISO = (1U << 23);  ///< bt force no ISO
        constexpr uint32_t DG_PERI_FORCE_ISO = (1U << 24);  ///< Digital peri force ISO
        constexpr uint32_t DG_PERI_FORCE_NOISO = (1U << 25);  ///< digital peri force no ISO
        constexpr uint32_t CPU_TOP_FORCE_ISO = (1U << 26);  ///< cpu force ISO
        constexpr uint32_t CPU_TOP_FORCE_NOISO = (1U << 27);  ///< cpu force no ISO
        constexpr uint32_t WIFI_FORCE_ISO = (1U << 28);  ///< wifi force ISO
        constexpr uint32_t WIFI_FORCE_NOISO = (1U << 29);  ///< wifi force no ISO
        constexpr uint32_t DG_WRAP_FORCE_ISO = (1U << 30);  ///< digital core force ISO
        constexpr uint32_t DG_WRAP_FORCE_NOISO = (1U << 31);  ///< digital core force no ISO
    }

    /// WDTCONFIG0 Register bits
    namespace wdtconfig0_bits {
        constexpr uint32_t WDT_CHIP_RESET_WIDTH = (8 << 0);  ///< chip reset siginal pulse width
        constexpr uint32_t WDT_CHIP_RESET_EN = (1U << 8);  ///< wdt reset whole chip enable
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< pause WDT in sleep
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 10);  ///< enable WDT reset APP CPU
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< enable WDT reset PRO CPU
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< enable WDT in flash boot
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< system reset counter length
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< CPU reset counter length
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< 1: interrupt stage en
        constexpr uint32_t WDT_EN = (1U << 31);  ///< enable rtc wdt
    }

    /// WDTCONFIG1 Register bits
    namespace wdtconfig1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< the hold time of stage0
    }

    /// WDTCONFIG2 Register bits
    namespace wdtconfig2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< the hold time of stage1
    }

    /// WDTCONFIG3 Register bits
    namespace wdtconfig3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< the hold time of stage2
    }

    /// WDTCONFIG4 Register bits
    namespace wdtconfig4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< the hold time of stage3
    }

    /// WDTFEED Register bits
    namespace wdtfeed_bits {
        constexpr uint32_t WDT_FEED = (1U << 31);  ///< sw feed rtc wdt
    }

    /// WDTWPROTECT Register bits
    namespace wdtwprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< the key of rtc wdt
    }

    /// SWD_CONF Register bits
    namespace swd_conf_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< swd reset flag
        constexpr uint32_t SWD_FEED_INT = (1U << 1);  ///< swd interrupt for feeding
        constexpr uint32_t SWD_BYPASS_RST = (1U << 17);  ///< Bypass swd rst
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 18);  ///< adjust signal width send to swd
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 28);  ///< reset swd reset flag
        constexpr uint32_t SWD_FEED = (1U << 29);  ///< Sw feed swd
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< disabel SWD
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 31);  ///< automatically feed swd when int comes
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< the key of super wdt
    }

    /// SW_CPU_STALL Register bits
    namespace sw_cpu_stall_bits {
        constexpr uint32_t SW_STALL_APPCPU_C1 = (6 << 20);  ///< {reg_sw_stall_appcpu_c1[5:0]
        constexpr uint32_t SW_STALL_PROCPU_C1 = (6 << 26);  ///< stall cpu by software
    }

    /// STORE4 Register bits
    namespace store4_bits {
        constexpr uint32_t SCRATCH4 = (32 << 0);  ///< reserved register
    }

    /// STORE5 Register bits
    namespace store5_bits {
        constexpr uint32_t SCRATCH5 = (32 << 0);  ///< reserved register
    }

    /// STORE6 Register bits
    namespace store6_bits {
        constexpr uint32_t SCRATCH6 = (32 << 0);  ///< reserved register
    }

    /// STORE7 Register bits
    namespace store7_bits {
        constexpr uint32_t SCRATCH7 = (32 << 0);  ///< reserved register
    }

    /// LOW_POWER_ST Register bits
    namespace low_power_st_bits {
        constexpr uint32_t XPD_ROM0 = (1U << 0);  ///< rom0 power down
        constexpr uint32_t XPD_DIG_DCDC = (1U << 2);  ///< External DCDC power down
        constexpr uint32_t PERI_ISO = (1U << 3);  ///< rtc peripheral iso
        constexpr uint32_t XPD_RTC_PERI = (1U << 4);  ///< rtc peripheral power down
        constexpr uint32_t WIFI_ISO = (1U << 5);  ///< wifi iso
        constexpr uint32_t XPD_WIFI = (1U << 6);  ///< wifi wrap power down
        constexpr uint32_t DIG_ISO = (1U << 7);  ///< digital wrap iso
        constexpr uint32_t XPD_DIG = (1U << 8);  ///< digital wrap power down
        constexpr uint32_t TOUCH_STATE_START = (1U << 9);  ///< touch should start to work
        constexpr uint32_t TOUCH_STATE_SWITCH = (1U << 10);  ///< touch is about to working. Switch rtc main state
        constexpr uint32_t TOUCH_STATE_SLP = (1U << 11);  ///< touch is in sleep state
        constexpr uint32_t TOUCH_STATE_DONE = (1U << 12);  ///< touch is done
        constexpr uint32_t COCPU_STATE_START = (1U << 13);  ///< ulp/cocpu should start to work
        constexpr uint32_t COCPU_STATE_SWITCH = (1U << 14);  ///< ulp/cocpu is about to working. Switch rtc main state
        constexpr uint32_t COCPU_STATE_SLP = (1U << 15);  ///< ulp/cocpu is in sleep state
        constexpr uint32_t COCPU_STATE_DONE = (1U << 16);  ///< ulp/cocpu is done
        constexpr uint32_t MAIN_STATE_XTAL_ISO = (1U << 17);  ///< no use any more
        constexpr uint32_t MAIN_STATE_PLL_ON = (1U << 18);  ///< rtc main state machine is in states that pll should be running
        constexpr uint32_t RDY_FOR_WAKEUP = (1U << 19);  ///< rtc is ready to receive wake up trigger from wake up source
        constexpr uint32_t MAIN_STATE_WAIT_END = (1U << 20);  ///< rtc main state machine has been waited for some cycles
        constexpr uint32_t IN_WAKEUP_STATE = (1U << 21);  ///< rtc main state machine is in the states of wakeup process
        constexpr uint32_t IN_LOW_POWER_STATE = (1U << 22);  ///< rtc main state machine is in the states of low power
        constexpr uint32_t MAIN_STATE_IN_WAIT_8M = (1U << 23);  ///< rtc main state machine is in wait 8m state
        constexpr uint32_t MAIN_STATE_IN_WAIT_PLL = (1U << 24);  ///< rtc main state machine is in wait pll state
        constexpr uint32_t MAIN_STATE_IN_WAIT_XTL = (1U << 25);  ///< rtc main state machine is in wait xtal state
        constexpr uint32_t MAIN_STATE_IN_SLP = (1U << 26);  ///< rtc main state machine is in sleep state
        constexpr uint32_t MAIN_STATE_IN_IDLE = (1U << 27);  ///< rtc main state machine is in idle state
        constexpr uint32_t MAIN_STATE = (4 << 28);  ///< rtc main state machine status
    }

    /// DIAG0 Register bits
    namespace diag0_bits {
        constexpr uint32_t LOW_POWER_DIAG1 = (32 << 0);  ///< LOW_POWER_DIAG1
    }

    /// PAD_HOLD Register bits
    namespace pad_hold_bits {
        constexpr uint32_t GPIO_PIN0_HOLD = (1U << 0);  ///< the hold configure of rtc gpio0
        constexpr uint32_t GPIO_PIN1_HOLD = (1U << 1);  ///< the hold configure of rtc gpio1
        constexpr uint32_t GPIO_PIN2_HOLD = (1U << 2);  ///< the hold configure of rtc gpio2
        constexpr uint32_t GPIO_PIN3_HOLD = (1U << 3);  ///< the hold configure of rtc gpio3
        constexpr uint32_t GPIO_PIN4_HOLD = (1U << 4);  ///< the hold configure of rtc gpio4
        constexpr uint32_t GPIO_PIN5_HOLD = (1U << 5);  ///< the hold configure of rtc gpio5
    }

    /// DIG_PAD_HOLD Register bits
    namespace dig_pad_hold_bits {
        constexpr uint32_t DIG_PAD_HOLD = (32 << 0);  ///< the configure of digital pad
    }

    /// BROWN_OUT Register bits
    namespace brown_out_bits {
        constexpr uint32_t BROWN_OUT_INT_WAIT = (10 << 4);  ///< brown out interrupt wait cycles
        constexpr uint32_t BROWN_OUT_CLOSE_FLASH_ENA = (1U << 14);  ///< enable close flash when brown out happens
        constexpr uint32_t BROWN_OUT_PD_RF_ENA = (1U << 15);  ///< enable power down RF when brown out happens
        constexpr uint32_t BROWN_OUT_RST_WAIT = (10 << 16);  ///< brown out reset wait cycles
        constexpr uint32_t BROWN_OUT_RST_ENA = (1U << 26);  ///< enable brown out reset
        constexpr uint32_t BROWN_OUT_RST_SEL = (1U << 27);  ///< 1: 4-pos reset
        constexpr uint32_t BROWN_OUT_ANA_RST_EN = (1U << 28);  ///< brown_out origin reset enable
        constexpr uint32_t BROWN_OUT_CNT_CLR = (1U << 29);  ///< clear brown out counter
        constexpr uint32_t BROWN_OUT_ENA = (1U << 30);  ///< enable brown out
        constexpr uint32_t DET = (1U << 31);  ///< the flag of brown det from analog
    }

    /// TIME_LOW1 Register bits
    namespace time_low1_bits {
        constexpr uint32_t TIMER_VALUE1_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH1 Register bits
    namespace time_high1_bits {
        constexpr uint32_t TIMER_VALUE1_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// XTAL32K_CLK_FACTOR Register bits
    namespace xtal32k_clk_factor_bits {
        constexpr uint32_t XTAL32K_CLK_FACTOR = (32 << 0);  ///< xtal 32k watch dog backup clock factor
    }

    /// XTAL32K_CONF Register bits
    namespace xtal32k_conf_bits {
        constexpr uint32_t XTAL32K_RETURN_WAIT = (4 << 0);  ///< cycles to wait to return noral xtal 32k
        constexpr uint32_t XTAL32K_RESTART_WAIT = (16 << 4);  ///< cycles to wait to repower on xtal 32k
        constexpr uint32_t XTAL32K_WDT_TIMEOUT = (8 << 20);  ///< If no clock detected for this amount of time
        constexpr uint32_t XTAL32K_STABLE_THRES = (4 << 28);  ///< if restarted xtal32k period is smaller than this
    }

    /// USB_CONF Register bits
    namespace usb_conf_bits {
        constexpr uint32_t IO_MUX_RESET_DISABLE = (1U << 18);  ///< disable io_mux reset
    }

    /// SLP_REJECT_CAUSE Register bits
    namespace slp_reject_cause_bits {
        constexpr uint32_t REJECT_CAUSE = (18 << 0);  ///< sleep reject cause
    }

    /// OPTION1 Register bits
    namespace option1_bits {
        constexpr uint32_t FORCE_DOWNLOAD_BOOT = (1U << 0);  ///< force chip entry download mode
    }

    /// SLP_WAKEUP_CAUSE Register bits
    namespace slp_wakeup_cause_bits {
        constexpr uint32_t WAKEUP_CAUSE = (17 << 0);  ///< sleep wakeup cause
    }

    /// ULP_CP_TIMER_1 Register bits
    namespace ulp_cp_timer_1_bits {
        constexpr uint32_t ULP_CP_TIMER_SLP_CYCLE = (24 << 8);  ///< sleep cycles for ULP-coprocessor timer
    }

    /// INT_ENA_RTC_W1TS Register bits
    namespace int_ena_rtc_w1ts_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TS = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TS = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t WDT_INT_ENA_W1TS = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TS = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TS = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SWD_INT_ENA_W1TS = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t XTAL32K_DEAD_INT_ENA_W1TS = (1U << 16);  ///< enable xtal32k_dead interrupt
        constexpr uint32_t GLITCH_DET_INT_ENA_W1TS = (1U << 19);  ///< enbale gitch det interrupt
        constexpr uint32_t BBPLL_CAL_INT_ENA_W1TS = (1U << 20);  ///< enbale bbpll cal interrupt
    }

    /// INT_ENA_RTC_W1TC Register bits
    namespace int_ena_rtc_w1tc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TC = (1U << 0);  ///< clear sleep wakeup interrupt enable
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TC = (1U << 1);  ///< clear sleep reject interrupt enable
        constexpr uint32_t WDT_INT_ENA_W1TC = (1U << 3);  ///< clear RTC WDT interrupt enable
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TC = (1U << 9);  ///< clear brown out interrupt enable
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TC = (1U << 10);  ///< Clear RTC main timer interrupt enable
        constexpr uint32_t SWD_INT_ENA_W1TC = (1U << 15);  ///< clear super watch dog interrupt enable
        constexpr uint32_t XTAL32K_DEAD_INT_ENA_W1TC = (1U << 16);  ///< clear xtal32k_dead interrupt enable
        constexpr uint32_t GLITCH_DET_INT_ENA_W1TC = (1U << 19);  ///< clear gitch det interrupt enable
        constexpr uint32_t BBPLL_CAL_INT_ENA_W1TC = (1U << 20);  ///< clear bbpll cal interrupt enable
    }

    /// RETENTION_CTRL Register bits
    namespace retention_ctrl_bits {
        constexpr uint32_t RETENTION_CLK_SEL = (1U << 18);  ///< Retention clk sel
        constexpr uint32_t RETENTION_DONE_WAIT = (3 << 19);  ///< Retention done wait time
        constexpr uint32_t RETENTION_CLKOFF_WAIT = (4 << 22);  ///< Retention clkoff wait time
        constexpr uint32_t RETENTION_EN = (1U << 26);  ///< enable cpu retention when light sleep
        constexpr uint32_t RETENTION_WAIT = (5 << 27);  ///< wait cycles for rention operation
    }

    /// FIB_SEL Register bits
    namespace fib_sel_bits {
        constexpr uint32_t FIB_SEL = (3 << 0);  ///< select use analog fib signal
    }

    /// GPIO_WAKEUP Register bits
    namespace gpio_wakeup_bits {
        constexpr uint32_t GPIO_WAKEUP_STATUS = (6 << 0);  ///< rtc gpio wakeup flag
        constexpr uint32_t GPIO_WAKEUP_STATUS_CLR = (1U << 6);  ///< clear rtc gpio wakeup flag
        constexpr uint32_t GPIO_PIN_CLK_GATE = (1U << 7);  ///< enable rtc io clk gate
        constexpr uint32_t GPIO_PIN5_INT_TYPE = (3 << 8);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN4_INT_TYPE = (3 << 11);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN3_INT_TYPE = (3 << 14);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN2_INT_TYPE = (3 << 17);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN1_INT_TYPE = (3 << 20);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN0_INT_TYPE = (3 << 23);  ///< configure gpio wakeup type
        constexpr uint32_t GPIO_PIN5_WAKEUP_ENABLE = (1U << 26);  ///< enable wakeup from rtc gpio5
        constexpr uint32_t GPIO_PIN4_WAKEUP_ENABLE = (1U << 27);  ///< enable wakeup from rtc gpio4
        constexpr uint32_t GPIO_PIN3_WAKEUP_ENABLE = (1U << 28);  ///< enable wakeup from rtc gpio3
        constexpr uint32_t GPIO_PIN2_WAKEUP_ENABLE = (1U << 29);  ///< enable wakeup from rtc gpio2
        constexpr uint32_t GPIO_PIN1_WAKEUP_ENABLE = (1U << 30);  ///< enable wakeup from rtc gpio1
        constexpr uint32_t GPIO_PIN0_WAKEUP_ENABLE = (1U << 31);  ///< enable wakeup from rtc gpio0
    }

    /// DBG_SEL Register bits
    namespace dbg_sel_bits {
        constexpr uint32_t DEBUG_12M_NO_GATING = (1U << 1);  ///< use for debug
        constexpr uint32_t DEBUG_BIT_SEL = (5 << 2);  ///< use for debug
        constexpr uint32_t DEBUG_SEL0 = (5 << 7);  ///< use for debug
        constexpr uint32_t DEBUG_SEL1 = (5 << 12);  ///< use for debug
        constexpr uint32_t DEBUG_SEL2 = (5 << 17);  ///< use for debug
        constexpr uint32_t DEBUG_SEL3 = (5 << 22);  ///< use for debug
        constexpr uint32_t DEBUG_SEL4 = (5 << 27);  ///< use for debug
    }

    /// DBG_MAP Register bits
    namespace dbg_map_bits {
        constexpr uint32_t GPIO_PIN5_MUX_SEL = (1U << 2);  ///< use for debug
        constexpr uint32_t GPIO_PIN4_MUX_SEL = (1U << 3);  ///< use for debug
        constexpr uint32_t GPIO_PIN3_MUX_SEL = (1U << 4);  ///< use for debug
        constexpr uint32_t GPIO_PIN2_MUX_SEL = (1U << 5);  ///< use for debug
        constexpr uint32_t GPIO_PIN1_MUX_SEL = (1U << 6);  ///< use for debug
        constexpr uint32_t GPIO_PIN0_MUX_SEL = (1U << 7);  ///< use for debug
        constexpr uint32_t GPIO_PIN5_FUN_SEL = (4 << 8);  ///< use for debug
        constexpr uint32_t GPIO_PIN4_FUN_SEL = (4 << 12);  ///< use for debug
        constexpr uint32_t GPIO_PIN3_FUN_SEL = (4 << 16);  ///< use for debug
        constexpr uint32_t GPIO_PIN2_FUN_SEL = (4 << 20);  ///< use for debug
        constexpr uint32_t GPIO_PIN1_FUN_SEL = (4 << 24);  ///< use for debug
        constexpr uint32_t GPIO_PIN0_FUN_SEL = (4 << 28);  ///< use for debug
    }

    /// SENSOR_CTRL Register bits
    namespace sensor_ctrl_bits {
        constexpr uint32_t SAR2_PWDET_CCT = (3 << 27);  ///< reg_sar2_pwdet_cct
        constexpr uint32_t FORCE_XPD_SAR = (2 << 30);  ///< force power up SAR
    }

    /// DBG_SAR_SEL Register bits
    namespace dbg_sar_sel_bits {
        constexpr uint32_t SAR_DEBUG_SEL = (5 << 27);  ///< use for debug
    }

    /// PG_CTRL Register bits
    namespace pg_ctrl_bits {
        constexpr uint32_t POWER_GLITCH_DSENSE = (2 << 26);  ///< power glitch desense
        constexpr uint32_t POWER_GLITCH_FORCE_PD = (1U << 28);  ///< force disable power glitch
        constexpr uint32_t POWER_GLITCH_FORCE_PU = (1U << 29);  ///< force enable power glitch
        constexpr uint32_t POWER_GLITCH_EFUSE_SEL = (1U << 30);  ///< use efuse value control power glitch enable
        constexpr uint32_t POWER_GLITCH_EN = (1U << 31);  ///< enable power glitch
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< verision
    }

}

// ============================================================================
// SENSITIVE Peripheral
// ============================================================================

namespace sensitive {
    /// Base addresses
    constexpr uint32_t SENSITIVE_BASE = 0x600C1000;

    /// SENSITIVE Register structure
    struct Registers {
        volatile uint32_t ROM_TABLE_LOCK;  ///< Offset: 0x00 - SENSITIVE_ROM_TABLE_LOCK_REG
        volatile uint32_t ROM_TABLE;  ///< Offset: 0x04 - SENSITIVE_ROM_TABLE_REG
        volatile uint32_t PRIVILEGE_MODE_SEL_LOCK;  ///< Offset: 0x08 - SENSITIVE_PRIVILEGE_MODE_SEL_LOCK_REG
        volatile uint32_t PRIVILEGE_MODE_SEL;  ///< Offset: 0x0C - SENSITIVE_PRIVILEGE_MODE_SEL_REG
        volatile uint32_t APB_PERIPHERAL_ACCESS_0;  ///< Offset: 0x10 - SENSITIVE_APB_PERIPHERAL_ACCESS_0_REG
        volatile uint32_t APB_PERIPHERAL_ACCESS_1;  ///< Offset: 0x14 - SENSITIVE_APB_PERIPHERAL_ACCESS_1_REG
        volatile uint32_t INTERNAL_SRAM_USAGE_0;  ///< Offset: 0x18 - SENSITIVE_INTERNAL_SRAM_USAGE_0_REG
        volatile uint32_t INTERNAL_SRAM_USAGE_1;  ///< Offset: 0x1C - SENSITIVE_INTERNAL_SRAM_USAGE_1_REG
        volatile uint32_t INTERNAL_SRAM_USAGE_3;  ///< Offset: 0x20 - SENSITIVE_INTERNAL_SRAM_USAGE_3_REG
        volatile uint32_t INTERNAL_SRAM_USAGE_4;  ///< Offset: 0x24 - SENSITIVE_INTERNAL_SRAM_USAGE_4_REG
        volatile uint32_t CACHE_TAG_ACCESS_0;  ///< Offset: 0x28 - SENSITIVE_CACHE_TAG_ACCESS_0_REG
        volatile uint32_t CACHE_TAG_ACCESS_1;  ///< Offset: 0x2C - SENSITIVE_CACHE_TAG_ACCESS_1_REG
        volatile uint32_t CACHE_MMU_ACCESS_0;  ///< Offset: 0x30 - SENSITIVE_CACHE_MMU_ACCESS_0_REG
        volatile uint32_t CACHE_MMU_ACCESS_1;  ///< Offset: 0x34 - SENSITIVE_CACHE_MMU_ACCESS_1_REG
        volatile uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_0;  ///< Offset: 0x38 - SENSITIVE_DMA_APBPERI_SPI2_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_1;  ///< Offset: 0x3C - SENSITIVE_DMA_APBPERI_SPI2_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_0;  ///< Offset: 0x40 - SENSITIVE_DMA_APBPERI_UCHI0_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_1;  ///< Offset: 0x44 - SENSITIVE_DMA_APBPERI_UCHI0_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_0;  ///< Offset: 0x48 - SENSITIVE_DMA_APBPERI_I2S0_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_1;  ///< Offset: 0x4C - SENSITIVE_DMA_APBPERI_I2S0_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_0;  ///< Offset: 0x50 - SENSITIVE_DMA_APBPERI_MAC_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_1;  ///< Offset: 0x54 - SENSITIVE_DMA_APBPERI_MAC_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0;  ///< Offset: 0x58 - SENSITIVE_DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1;  ///< Offset: 0x5C - SENSITIVE_DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_0;  ///< Offset: 0x60 - SENSITIVE_DMA_APBPERI_LC_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_1;  ///< Offset: 0x64 - SENSITIVE_DMA_APBPERI_LC_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_0;  ///< Offset: 0x68 - SENSITIVE_DMA_APBPERI_AES_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_1;  ///< Offset: 0x6C - SENSITIVE_DMA_APBPERI_AES_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_0;  ///< Offset: 0x70 - SENSITIVE_DMA_APBPERI_SHA_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_1;  ///< Offset: 0x74 - SENSITIVE_DMA_APBPERI_SHA_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0;  ///< Offset: 0x78 - SENSITIVE_DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0_REG
        volatile uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1;  ///< Offset: 0x7C - SENSITIVE_DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1_REG
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_0;  ///< Offset: 0x80 - SENSITIVE_DMA_APBPERI_PMS_MONITOR_0_REG
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_1;  ///< Offset: 0x84 - SENSITIVE_DMA_APBPERI_PMS_MONITOR_1_REG
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_2;  ///< Offset: 0x88 - SENSITIVE_DMA_APBPERI_PMS_MONITOR_2_REG
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_3;  ///< Offset: 0x8C - SENSITIVE_DMA_APBPERI_PMS_MONITOR_3_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0;  ///< Offset: 0x90 - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1;  ///< Offset: 0x94 - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2;  ///< Offset: 0x98 - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3;  ///< Offset: 0x9C - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4;  ///< Offset: 0xA0 - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5;  ///< Offset: 0xA4 - SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_0;  ///< Offset: 0xA8 - SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_1;  ///< Offset: 0xAC - SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_1_REG
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_2;  ///< Offset: 0xB0 - SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_0;  ///< Offset: 0xB4 - SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_1;  ///< Offset: 0xB8 - SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_2;  ///< Offset: 0xBC - SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_2_REG
        volatile uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_0;  ///< Offset: 0xC0 - SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG
        volatile uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_1;  ///< Offset: 0xC4 - SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_0;  ///< Offset: 0xC8 - SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_1;  ///< Offset: 0xCC - SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_2;  ///< Offset: 0xD0 - SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_2_REG
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_3;  ///< Offset: 0xD4 - SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_3_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_0;  ///< Offset: 0xD8 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_1;  ///< Offset: 0xDC - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_1_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_2;  ///< Offset: 0xE0 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_2_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_3;  ///< Offset: 0xE4 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_3_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_4;  ///< Offset: 0xE8 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_4_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_5;  ///< Offset: 0xEC - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_5_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_6;  ///< Offset: 0xF0 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_6_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_7;  ///< Offset: 0xF4 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_7_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_8;  ///< Offset: 0xF8 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_8_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_9;  ///< Offset: 0xFC - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_10;  ///< Offset: 0x100 - SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_0;  ///< Offset: 0x104 - SENSITIVE_REGION_PMS_CONSTRAIN_0_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_1;  ///< Offset: 0x108 - SENSITIVE_REGION_PMS_CONSTRAIN_1_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_2;  ///< Offset: 0x10C - SENSITIVE_REGION_PMS_CONSTRAIN_2_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_3;  ///< Offset: 0x110 - SENSITIVE_REGION_PMS_CONSTRAIN_3_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_4;  ///< Offset: 0x114 - SENSITIVE_REGION_PMS_CONSTRAIN_4_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_5;  ///< Offset: 0x118 - SENSITIVE_REGION_PMS_CONSTRAIN_5_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_6;  ///< Offset: 0x11C - SENSITIVE_REGION_PMS_CONSTRAIN_6_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_7;  ///< Offset: 0x120 - SENSITIVE_REGION_PMS_CONSTRAIN_7_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_8;  ///< Offset: 0x124 - SENSITIVE_REGION_PMS_CONSTRAIN_8_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_9;  ///< Offset: 0x128 - SENSITIVE_REGION_PMS_CONSTRAIN_9_REG
        volatile uint32_t REGION_PMS_CONSTRAIN_10;  ///< Offset: 0x12C - SENSITIVE_REGION_PMS_CONSTRAIN_10_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_0;  ///< Offset: 0x130 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_1;  ///< Offset: 0x134 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_2;  ///< Offset: 0x138 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_2_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_3;  ///< Offset: 0x13C - SENSITIVE_CORE_0_PIF_PMS_MONITOR_3_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_4;  ///< Offset: 0x140 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_4_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_5;  ///< Offset: 0x144 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_5_REG
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_6;  ///< Offset: 0x148 - SENSITIVE_CORE_0_PIF_PMS_MONITOR_6_REG
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_0;  ///< Offset: 0x14C - SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_0_REG
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_1;  ///< Offset: 0x150 - SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_1_REG
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_2;  ///< Offset: 0x154 - SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_2_REG
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_3;  ///< Offset: 0x158 - SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_3_REG
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_4;  ///< Offset: 0x15C - SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_4_REG
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_0;  ///< Offset: 0x160 - SENSITIVE_BACKUP_BUS_PMS_MONITOR_0_REG
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_1;  ///< Offset: 0x164 - SENSITIVE_BACKUP_BUS_PMS_MONITOR_1_REG
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_2;  ///< Offset: 0x168 - SENSITIVE_BACKUP_BUS_PMS_MONITOR_2_REG
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_3;  ///< Offset: 0x16C - SENSITIVE_BACKUP_BUS_PMS_MONITOR_3_REG
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x170 - SENSITIVE_CLOCK_GATE_REG_REG
        volatile uint32_t DATE;  ///< Offset: 0xFFC - SENSITIVE_DATE_REG
    };

    /// Peripheral instances
    inline Registers* SENSITIVE = reinterpret_cast<Registers*>(SENSITIVE_BASE);

    // Bit definitions
    /// ROM_TABLE_LOCK Register bits
    namespace rom_table_lock_bits {
        constexpr uint32_t ROM_TABLE_LOCK = (1U << 0);  ///< rom_table_lock
    }

    /// ROM_TABLE Register bits
    namespace rom_table_bits {
        constexpr uint32_t ROM_TABLE = (32 << 0);  ///< rom_table
    }

    /// PRIVILEGE_MODE_SEL_LOCK Register bits
    namespace privilege_mode_sel_lock_bits {
        constexpr uint32_t PRIVILEGE_MODE_SEL_LOCK = (1U << 0);  ///< privilege_mode_sel_lock
    }

    /// PRIVILEGE_MODE_SEL Register bits
    namespace privilege_mode_sel_bits {
        constexpr uint32_t PRIVILEGE_MODE_SEL = (1U << 0);  ///< privilege_mode_sel
    }

    /// APB_PERIPHERAL_ACCESS_0 Register bits
    namespace apb_peripheral_access_0_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_LOCK = (1U << 0);  ///< apb_peripheral_access_lock
    }

    /// APB_PERIPHERAL_ACCESS_1 Register bits
    namespace apb_peripheral_access_1_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_SPLIT_BURST = (1U << 0);  ///< apb_peripheral_access_split_burst
    }

    /// INTERNAL_SRAM_USAGE_0 Register bits
    namespace internal_sram_usage_0_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_LOCK = (1U << 0);  ///< internal_sram_usage_lock
    }

    /// INTERNAL_SRAM_USAGE_1 Register bits
    namespace internal_sram_usage_1_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_CPU_CACHE = (1U << 0);  ///< internal_sram_usage_cpu_cache
        constexpr uint32_t INTERNAL_SRAM_USAGE_CPU_SRAM = (3 << 1);  ///< internal_sram_usage_cpu_sram
    }

    /// INTERNAL_SRAM_USAGE_3 Register bits
    namespace internal_sram_usage_3_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_MAC_DUMP_SRAM = (3 << 0);  ///< internal_sram_usage_mac_dump_sram
        constexpr uint32_t INTERNAL_SRAM_ALLOC_MAC_DUMP = (1U << 3);  ///< internal_sram_alloc_mac_dump
    }

    /// INTERNAL_SRAM_USAGE_4 Register bits
    namespace internal_sram_usage_4_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_LOG_SRAM = (1U << 0);  ///< internal_sram_usage_log_sram
    }

    /// CACHE_TAG_ACCESS_0 Register bits
    namespace cache_tag_access_0_bits {
        constexpr uint32_t CACHE_TAG_ACCESS_LOCK = (1U << 0);  ///< cache_tag_access_lock
    }

    /// CACHE_TAG_ACCESS_1 Register bits
    namespace cache_tag_access_1_bits {
        constexpr uint32_t PRO_I_TAG_RD_ACS = (1U << 0);  ///< pro_i_tag_rd_acs
        constexpr uint32_t PRO_I_TAG_WR_ACS = (1U << 1);  ///< pro_i_tag_wr_acs
        constexpr uint32_t PRO_D_TAG_RD_ACS = (1U << 2);  ///< pro_d_tag_rd_acs
        constexpr uint32_t PRO_D_TAG_WR_ACS = (1U << 3);  ///< pro_d_tag_wr_acs
    }

    /// CACHE_MMU_ACCESS_0 Register bits
    namespace cache_mmu_access_0_bits {
        constexpr uint32_t CACHE_MMU_ACCESS_LOCK = (1U << 0);  ///< cache_mmu_access_lock
    }

    /// CACHE_MMU_ACCESS_1 Register bits
    namespace cache_mmu_access_1_bits {
        constexpr uint32_t PRO_MMU_RD_ACS = (1U << 0);  ///< pro_mmu_rd_acs
        constexpr uint32_t PRO_MMU_WR_ACS = (1U << 1);  ///< pro_mmu_wr_acs
    }

    /// DMA_APBPERI_SPI2_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_spi2_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_spi2_pms_constrain_lock
    }

    /// DMA_APBPERI_SPI2_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_spi2_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_spi2_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_spi2_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_spi2_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_spi2_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_spi2_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_spi2_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_spi2_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_spi2_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_UCHI0_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_uchi0_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_uchi0_pms_constrain_lock
    }

    /// DMA_APBPERI_UCHI0_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_uchi0_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_I2S0_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_i2s0_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_i2s0_pms_constrain_lock
    }

    /// DMA_APBPERI_I2S0_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_i2s0_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_MAC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_mac_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_mac_pms_constrain_lock
    }

    /// DMA_APBPERI_MAC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_mac_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_mac_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_mac_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_mac_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_mac_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_mac_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_mac_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_mac_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_mac_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_backup_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_backup_pms_constrain_lock
    }

    /// DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_backup_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_backup_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_backup_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_backup_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_backup_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_backup_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_backup_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_backup_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_backup_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_LC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_lc_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_lc_pms_constrain_lock
    }

    /// DMA_APBPERI_LC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_lc_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_lc_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_lc_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_lc_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_lc_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_lc_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_lc_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_lc_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_lc_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_AES_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_aes_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_aes_pms_constrain_lock
    }

    /// DMA_APBPERI_AES_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_aes_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_aes_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_aes_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_aes_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_aes_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_aes_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_aes_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_aes_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_aes_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_SHA_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_sha_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_sha_pms_constrain_lock
    }

    /// DMA_APBPERI_SHA_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_sha_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_sha_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_sha_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_sha_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_sha_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_sha_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_sha_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_sha_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_sha_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_adc_dac_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< dma_apbperi_adc_dac_pms_constrain_lock
    }

    /// DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_adc_dac_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_3
    }

    /// DMA_APBPERI_PMS_MONITOR_0 Register bits
    namespace dma_apbperi_pms_monitor_0_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_LOCK = (1U << 0);  ///< dma_apbperi_pms_monitor_lock
    }

    /// DMA_APBPERI_PMS_MONITOR_1 Register bits
    namespace dma_apbperi_pms_monitor_1_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< dma_apbperi_pms_monitor_violate_clr
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< dma_apbperi_pms_monitor_violate_en
    }

    /// DMA_APBPERI_PMS_MONITOR_2 Register bits
    namespace dma_apbperi_pms_monitor_2_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< dma_apbperi_pms_monitor_violate_intr
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 1);  ///< dma_apbperi_pms_monitor_violate_status_world
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_ADDR = (24 << 3);  ///< dma_apbperi_pms_monitor_violate_status_addr
    }

    /// DMA_APBPERI_PMS_MONITOR_3 Register bits
    namespace dma_apbperi_pms_monitor_3_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 0);  ///< dma_apbperi_pms_monitor_violate_status_wr
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_BYTEEN = (4 << 1);  ///< dma_apbperi_pms_monitor_violate_status_byteen
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_LOCK = (1U << 0);  ///< core_x_iram0_dram0_dma_split_line_constrain_lock
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_0 = (2 << 0);  ///< core_x_iram0_dram0_dma_sram_category_0
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_1 = (2 << 2);  ///< core_x_iram0_dram0_dma_sram_category_1
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_2 = (2 << 4);  ///< core_x_iram0_dram0_dma_sram_category_2
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR = (8 << 14);  ///< core_x_iram0_dram0_dma_sram_splitaddr
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_2_bits {
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_0 = (2 << 0);  ///< core_x_iram0_sram_line_0_category_0
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_1 = (2 << 2);  ///< core_x_iram0_sram_line_0_category_1
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_2 = (2 << 4);  ///< core_x_iram0_sram_line_0_category_2
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_SPLITADDR = (8 << 14);  ///< core_x_iram0_sram_line_0_splitaddr
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_3_bits {
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_0 = (2 << 0);  ///< core_x_iram0_sram_line_1_category_0
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_1 = (2 << 2);  ///< core_x_iram0_sram_line_1_category_1
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_2 = (2 << 4);  ///< core_x_iram0_sram_line_1_category_2
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_SPLITADDR = (8 << 14);  ///< core_x_iram0_sram_line_1_splitaddr
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_4_bits {
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_0 = (2 << 0);  ///< core_x_dram0_dma_sram_line_0_category_0
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_1 = (2 << 2);  ///< core_x_dram0_dma_sram_line_0_category_1
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_2 = (2 << 4);  ///< core_x_dram0_dma_sram_line_0_category_2
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR = (8 << 14);  ///< core_x_dram0_dma_sram_line_0_splitaddr
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_5_bits {
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_0 = (2 << 0);  ///< core_x_dram0_dma_sram_line_1_category_0
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_1 = (2 << 2);  ///< core_x_dram0_dma_sram_line_1_category_1
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_2 = (2 << 4);  ///< core_x_dram0_dma_sram_line_1_category_2
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_SPLITADDR = (8 << 14);  ///< core_x_dram0_dma_sram_line_1_splitaddr
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_0 Register bits
    namespace core_x_iram0_pms_constrain_0_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< core_x_iram0_pms_constrain_lock
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_1 Register bits
    namespace core_x_iram0_pms_constrain_1_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (3 << 0);  ///< core_x_iram0_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (3 << 3);  ///< core_x_iram0_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (3 << 6);  ///< core_x_iram0_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (3 << 9);  ///< core_x_iram0_pms_constrain_sram_world_1_pms_3
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0 = (3 << 12);  ///< core_x_iram0_pms_constrain_sram_world_1_cachedataarray_pms_0
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS = (3 << 18);  ///< core_x_iram0_pms_constrain_rom_world_1_pms
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_2 Register bits
    namespace core_x_iram0_pms_constrain_2_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (3 << 0);  ///< core_x_iram0_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (3 << 3);  ///< core_x_iram0_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (3 << 6);  ///< core_x_iram0_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (3 << 9);  ///< core_x_iram0_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0 = (3 << 12);  ///< core_x_iram0_pms_constrain_sram_world_0_cachedataarray_pms_0
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS = (3 << 18);  ///< core_x_iram0_pms_constrain_rom_world_0_pms
    }

    /// CORE_0_IRAM0_PMS_MONITOR_0 Register bits
    namespace core_0_iram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< core_0_iram0_pms_monitor_lock
    }

    /// CORE_0_IRAM0_PMS_MONITOR_1 Register bits
    namespace core_0_iram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< core_0_iram0_pms_monitor_violate_clr
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< core_0_iram0_pms_monitor_violate_en
    }

    /// CORE_0_IRAM0_PMS_MONITOR_2 Register bits
    namespace core_0_iram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< core_0_iram0_pms_monitor_violate_intr
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 1);  ///< core_0_iram0_pms_monitor_violate_status_wr
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE = (1U << 2);  ///< core_0_iram0_pms_monitor_violate_status_loadstore
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 3);  ///< core_0_iram0_pms_monitor_violate_status_world
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (24 << 5);  ///< core_0_iram0_pms_monitor_violate_status_addr
    }

    /// CORE_X_DRAM0_PMS_CONSTRAIN_0 Register bits
    namespace core_x_dram0_pms_constrain_0_bits {
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< core_x_dram0_pms_constrain_lock
    }

    /// CORE_X_DRAM0_PMS_CONSTRAIN_1 Register bits
    namespace core_x_dram0_pms_constrain_1_bits {
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< core_x_dram0_pms_constrain_sram_world_0_pms_0
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< core_x_dram0_pms_constrain_sram_world_0_pms_1
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< core_x_dram0_pms_constrain_sram_world_0_pms_2
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< core_x_dram0_pms_constrain_sram_world_0_pms_3
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< core_x_dram0_pms_constrain_sram_world_1_pms_0
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< core_x_dram0_pms_constrain_sram_world_1_pms_1
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< core_x_dram0_pms_constrain_sram_world_1_pms_2
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< core_x_dram0_pms_constrain_sram_world_1_pms_3
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS = (2 << 24);  ///< core_x_dram0_pms_constrain_rom_world_0_pms
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS = (2 << 26);  ///< core_x_dram0_pms_constrain_rom_world_1_pms
    }

    /// CORE_0_DRAM0_PMS_MONITOR_0 Register bits
    namespace core_0_dram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< core_0_dram0_pms_monitor_lock
    }

    /// CORE_0_DRAM0_PMS_MONITOR_1 Register bits
    namespace core_0_dram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< core_0_dram0_pms_monitor_violate_clr
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< core_0_dram0_pms_monitor_violate_en
    }

    /// CORE_0_DRAM0_PMS_MONITOR_2 Register bits
    namespace core_0_dram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< core_0_dram0_pms_monitor_violate_intr
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK = (1U << 1);  ///< core_0_dram0_pms_monitor_violate_status_lock
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 2);  ///< core_0_dram0_pms_monitor_violate_status_world
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (24 << 4);  ///< core_0_dram0_pms_monitor_violate_status_addr
    }

    /// CORE_0_DRAM0_PMS_MONITOR_3 Register bits
    namespace core_0_dram0_pms_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 0);  ///< core_0_dram0_pms_monitor_violate_status_wr
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN = (4 << 1);  ///< core_0_dram0_pms_monitor_violate_status_byteen
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_0 Register bits
    namespace core_0_pif_pms_constrain_0_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< core_0_pif_pms_constrain_lock
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_1 Register bits
    namespace core_0_pif_pms_constrain_1_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART = (2 << 0);  ///< core_0_pif_pms_constrain_world_0_uart
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1 = (2 << 2);  ///< core_0_pif_pms_constrain_world_0_g0spi_1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0 = (2 << 4);  ///< core_0_pif_pms_constrain_world_0_g0spi_0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_GPIO = (2 << 6);  ///< core_0_pif_pms_constrain_world_0_gpio
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE2 = (2 << 8);  ///< core_0_pif_pms_constrain_world_0_fe2
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE = (2 << 10);  ///< core_0_pif_pms_constrain_world_0_fe
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMER = (2 << 12);  ///< core_0_pif_pms_constrain_world_0_timer
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RTC = (2 << 14);  ///< core_0_pif_pms_constrain_world_0_rtc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX = (2 << 16);  ///< core_0_pif_pms_constrain_world_0_io_mux
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WDG = (2 << 18);  ///< core_0_pif_pms_constrain_world_0_wdg
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_MISC = (2 << 24);  ///< core_0_pif_pms_constrain_world_0_misc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C = (2 << 26);  ///< core_0_pif_pms_constrain_world_0_i2c
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART1 = (2 << 30);  ///< core_0_pif_pms_constrain_world_0_uart1
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_2 Register bits
    namespace core_0_pif_pms_constrain_2_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT = (2 << 0);  ///< core_0_pif_pms_constrain_world_0_bt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0 = (2 << 4);  ///< core_0_pif_pms_constrain_world_0_i2c_ext0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0 = (2 << 6);  ///< core_0_pif_pms_constrain_world_0_uhci0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RMT = (2 << 10);  ///< core_0_pif_pms_constrain_world_0_rmt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LEDC = (2 << 16);  ///< core_0_pif_pms_constrain_world_0_ledc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BB = (2 << 22);  ///< core_0_pif_pms_constrain_world_0_bb
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP = (2 << 26);  ///< core_0_pif_pms_constrain_world_0_timergroup
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1 = (2 << 28);  ///< core_0_pif_pms_constrain_world_0_timergroup1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER = (2 << 30);  ///< core_0_pif_pms_constrain_world_0_systimer
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_3 Register bits
    namespace core_0_pif_pms_constrain_3_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2 = (2 << 0);  ///< core_0_pif_pms_constrain_world_0_spi_2
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL = (2 << 4);  ///< core_0_pif_pms_constrain_world_0_apb_ctrl
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CAN = (2 << 10);  ///< core_0_pif_pms_constrain_world_0_can
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S1 = (2 << 14);  ///< core_0_pif_pms_constrain_world_0_i2s1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RWBT = (2 << 22);  ///< core_0_pif_pms_constrain_world_0_rwbt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC = (2 << 26);  ///< core_0_pif_pms_constrain_world_0_wifimac
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWR = (2 << 28);  ///< core_0_pif_pms_constrain_world_0_pwr
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_4 Register bits
    namespace core_0_pif_pms_constrain_4_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP = (2 << 2);  ///< core_0_pif_pms_constrain_world_0_usb_wrap
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI = (2 << 4);  ///< core_0_pif_pms_constrain_world_0_crypto_peri
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA = (2 << 6);  ///< core_0_pif_pms_constrain_world_0_crypto_dma
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC = (2 << 8);  ///< core_0_pif_pms_constrain_world_0_apb_adc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR = (2 << 12);  ///< core_0_pif_pms_constrain_world_0_bt_pwr
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE = (2 << 14);  ///< core_0_pif_pms_constrain_world_0_usb_device
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM = (2 << 16);  ///< core_0_pif_pms_constrain_world_0_system
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE = (2 << 18);  ///< core_0_pif_pms_constrain_world_0_sensitive
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT = (2 << 20);  ///< core_0_pif_pms_constrain_world_0_interrupt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY = (2 << 22);  ///< core_0_pif_pms_constrain_world_0_dma_copy
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG = (2 << 24);  ///< core_0_pif_pms_constrain_world_0_cache_config
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_AD = (2 << 26);  ///< core_0_pif_pms_constrain_world_0_ad
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DIO = (2 << 28);  ///< core_0_pif_pms_constrain_world_0_dio
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER = (2 << 30);  ///< core_0_pif_pms_constrain_world_0_world_controller
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_5 Register bits
    namespace core_0_pif_pms_constrain_5_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART = (2 << 0);  ///< core_0_pif_pms_constrain_world_1_uart
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1 = (2 << 2);  ///< core_0_pif_pms_constrain_world_1_g0spi_1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0 = (2 << 4);  ///< core_0_pif_pms_constrain_world_1_g0spi_0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_GPIO = (2 << 6);  ///< core_0_pif_pms_constrain_world_1_gpio
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE2 = (2 << 8);  ///< core_0_pif_pms_constrain_world_1_fe2
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE = (2 << 10);  ///< core_0_pif_pms_constrain_world_1_fe
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMER = (2 << 12);  ///< core_0_pif_pms_constrain_world_1_timer
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RTC = (2 << 14);  ///< core_0_pif_pms_constrain_world_1_rtc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX = (2 << 16);  ///< core_0_pif_pms_constrain_world_1_io_mux
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WDG = (2 << 18);  ///< core_0_pif_pms_constrain_world_1_wdg
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_MISC = (2 << 24);  ///< core_0_pif_pms_constrain_world_1_misc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C = (2 << 26);  ///< core_0_pif_pms_constrain_world_1_i2c
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART1 = (2 << 30);  ///< core_0_pif_pms_constrain_world_1_uart1
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_6 Register bits
    namespace core_0_pif_pms_constrain_6_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT = (2 << 0);  ///< core_0_pif_pms_constrain_world_1_bt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0 = (2 << 4);  ///< core_0_pif_pms_constrain_world_1_i2c_ext0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0 = (2 << 6);  ///< core_0_pif_pms_constrain_world_1_uhci0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RMT = (2 << 10);  ///< core_0_pif_pms_constrain_world_1_rmt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LEDC = (2 << 16);  ///< core_0_pif_pms_constrain_world_1_ledc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BB = (2 << 22);  ///< core_0_pif_pms_constrain_world_1_bb
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP = (2 << 26);  ///< core_0_pif_pms_constrain_world_1_timergroup
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1 = (2 << 28);  ///< core_0_pif_pms_constrain_world_1_timergroup1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER = (2 << 30);  ///< core_0_pif_pms_constrain_world_1_systimer
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_7 Register bits
    namespace core_0_pif_pms_constrain_7_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2 = (2 << 0);  ///< core_0_pif_pms_constrain_world_1_spi_2
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL = (2 << 4);  ///< core_0_pif_pms_constrain_world_1_apb_ctrl
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CAN = (2 << 10);  ///< core_0_pif_pms_constrain_world_1_can
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S1 = (2 << 14);  ///< core_0_pif_pms_constrain_world_1_i2s1
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RWBT = (2 << 22);  ///< core_0_pif_pms_constrain_world_1_rwbt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC = (2 << 26);  ///< core_0_pif_pms_constrain_world_1_wifimac
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWR = (2 << 28);  ///< core_0_pif_pms_constrain_world_1_pwr
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_8 Register bits
    namespace core_0_pif_pms_constrain_8_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP = (2 << 2);  ///< core_0_pif_pms_constrain_world_1_usb_wrap
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI = (2 << 4);  ///< core_0_pif_pms_constrain_world_1_crypto_peri
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA = (2 << 6);  ///< core_0_pif_pms_constrain_world_1_crypto_dma
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC = (2 << 8);  ///< core_0_pif_pms_constrain_world_1_apb_adc
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR = (2 << 12);  ///< core_0_pif_pms_constrain_world_1_bt_pwr
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE = (2 << 14);  ///< core_0_pif_pms_constrain_world_1_usb_device
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM = (2 << 16);  ///< core_0_pif_pms_constrain_world_1_system
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE = (2 << 18);  ///< core_0_pif_pms_constrain_world_1_sensitive
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT = (2 << 20);  ///< core_0_pif_pms_constrain_world_1_interrupt
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY = (2 << 22);  ///< core_0_pif_pms_constrain_world_1_dma_copy
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG = (2 << 24);  ///< core_0_pif_pms_constrain_world_1_cache_config
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_AD = (2 << 26);  ///< core_0_pif_pms_constrain_world_1_ad
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DIO = (2 << 28);  ///< core_0_pif_pms_constrain_world_1_dio
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER = (2 << 30);  ///< core_0_pif_pms_constrain_world_1_world_controller
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_9 Register bits
    namespace core_0_pif_pms_constrain_9_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0 = (11 << 0);  ///< core_0_pif_pms_constrain_rtcfast_spltaddr_world_0
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1 = (11 << 11);  ///< core_0_pif_pms_constrain_rtcfast_spltaddr_world_1
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_10 Register bits
    namespace core_0_pif_pms_constrain_10_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L = (3 << 0);  ///< core_0_pif_pms_constrain_rtcfast_world_0_l
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H = (3 << 3);  ///< core_0_pif_pms_constrain_rtcfast_world_0_h
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L = (3 << 6);  ///< core_0_pif_pms_constrain_rtcfast_world_1_l
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H = (3 << 9);  ///< core_0_pif_pms_constrain_rtcfast_world_1_h
    }

    /// REGION_PMS_CONSTRAIN_0 Register bits
    namespace region_pms_constrain_0_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< region_pms_constrain_lock
    }

    /// REGION_PMS_CONSTRAIN_1 Register bits
    namespace region_pms_constrain_1_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_0 = (2 << 0);  ///< region_pms_constrain_world_0_area_0
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_1 = (2 << 2);  ///< region_pms_constrain_world_0_area_1
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_2 = (2 << 4);  ///< region_pms_constrain_world_0_area_2
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_3 = (2 << 6);  ///< region_pms_constrain_world_0_area_3
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_4 = (2 << 8);  ///< region_pms_constrain_world_0_area_4
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_5 = (2 << 10);  ///< region_pms_constrain_world_0_area_5
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_0_AREA_6 = (2 << 12);  ///< region_pms_constrain_world_0_area_6
    }

    /// REGION_PMS_CONSTRAIN_2 Register bits
    namespace region_pms_constrain_2_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_0 = (2 << 0);  ///< region_pms_constrain_world_1_area_0
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_1 = (2 << 2);  ///< region_pms_constrain_world_1_area_1
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_2 = (2 << 4);  ///< region_pms_constrain_world_1_area_2
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_3 = (2 << 6);  ///< region_pms_constrain_world_1_area_3
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_4 = (2 << 8);  ///< region_pms_constrain_world_1_area_4
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_5 = (2 << 10);  ///< region_pms_constrain_world_1_area_5
        constexpr uint32_t REGION_PMS_CONSTRAIN_WORLD_1_AREA_6 = (2 << 12);  ///< region_pms_constrain_world_1_area_6
    }

    /// REGION_PMS_CONSTRAIN_3 Register bits
    namespace region_pms_constrain_3_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_0 = (30 << 0);  ///< region_pms_constrain_addr_0
    }

    /// REGION_PMS_CONSTRAIN_4 Register bits
    namespace region_pms_constrain_4_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_1 = (30 << 0);  ///< region_pms_constrain_addr_1
    }

    /// REGION_PMS_CONSTRAIN_5 Register bits
    namespace region_pms_constrain_5_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_2 = (30 << 0);  ///< region_pms_constrain_addr_2
    }

    /// REGION_PMS_CONSTRAIN_6 Register bits
    namespace region_pms_constrain_6_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_3 = (30 << 0);  ///< region_pms_constrain_addr_3
    }

    /// REGION_PMS_CONSTRAIN_7 Register bits
    namespace region_pms_constrain_7_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_4 = (30 << 0);  ///< region_pms_constrain_addr_4
    }

    /// REGION_PMS_CONSTRAIN_8 Register bits
    namespace region_pms_constrain_8_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_5 = (30 << 0);  ///< region_pms_constrain_addr_5
    }

    /// REGION_PMS_CONSTRAIN_9 Register bits
    namespace region_pms_constrain_9_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_6 = (30 << 0);  ///< region_pms_constrain_addr_6
    }

    /// REGION_PMS_CONSTRAIN_10 Register bits
    namespace region_pms_constrain_10_bits {
        constexpr uint32_t REGION_PMS_CONSTRAIN_ADDR_7 = (30 << 0);  ///< region_pms_constrain_addr_7
    }

    /// CORE_0_PIF_PMS_MONITOR_0 Register bits
    namespace core_0_pif_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_LOCK = (1U << 0);  ///< core_0_pif_pms_monitor_lock
    }

    /// CORE_0_PIF_PMS_MONITOR_1 Register bits
    namespace core_0_pif_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< core_0_pif_pms_monitor_violate_clr
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< core_0_pif_pms_monitor_violate_en
    }

    /// CORE_0_PIF_PMS_MONITOR_2 Register bits
    namespace core_0_pif_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< core_0_pif_pms_monitor_violate_intr
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0 = (1U << 1);  ///< core_0_pif_pms_monitor_violate_status_hport_0
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE = (3 << 2);  ///< core_0_pif_pms_monitor_violate_status_hsize
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE = (1U << 5);  ///< core_0_pif_pms_monitor_violate_status_hwrite
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD = (2 << 6);  ///< core_0_pif_pms_monitor_violate_status_hworld
    }

    /// CORE_0_PIF_PMS_MONITOR_3 Register bits
    namespace core_0_pif_pms_monitor_3_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR = (32 << 0);  ///< core_0_pif_pms_monitor_violate_status_haddr
    }

    /// CORE_0_PIF_PMS_MONITOR_4 Register bits
    namespace core_0_pif_pms_monitor_4_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR = (1U << 0);  ///< core_0_pif_pms_monitor_nonword_violate_clr
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN = (1U << 1);  ///< core_0_pif_pms_monitor_nonword_violate_en
    }

    /// CORE_0_PIF_PMS_MONITOR_5 Register bits
    namespace core_0_pif_pms_monitor_5_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR = (1U << 0);  ///< core_0_pif_pms_monitor_nonword_violate_intr
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE = (2 << 1);  ///< core_0_pif_pms_monitor_nonword_violate_status_hsize
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD = (2 << 3);  ///< core_0_pif_pms_monitor_nonword_violate_status_hworld
    }

    /// CORE_0_PIF_PMS_MONITOR_6 Register bits
    namespace core_0_pif_pms_monitor_6_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR = (32 << 0);  ///< core_0_pif_pms_monitor_nonword_violate_status_haddr
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_0 Register bits
    namespace backup_bus_pms_constrain_0_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< backup_bus_pms_constrain_lock
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_1 Register bits
    namespace backup_bus_pms_constrain_1_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART = (2 << 0);  ///< backup_bus_pms_constrain_uart
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_1 = (2 << 2);  ///< backup_bus_pms_constrain_g0spi_1
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_0 = (2 << 4);  ///< backup_bus_pms_constrain_g0spi_0
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_GPIO = (2 << 6);  ///< backup_bus_pms_constrain_gpio
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE2 = (2 << 8);  ///< backup_bus_pms_constrain_fe2
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE = (2 << 10);  ///< backup_bus_pms_constrain_fe
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMER = (2 << 12);  ///< backup_bus_pms_constrain_timer
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTC = (2 << 14);  ///< backup_bus_pms_constrain_rtc
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_IO_MUX = (2 << 16);  ///< backup_bus_pms_constrain_io_mux
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_WDG = (2 << 18);  ///< backup_bus_pms_constrain_wdg
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_MISC = (2 << 24);  ///< backup_bus_pms_constrain_misc
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C = (2 << 26);  ///< backup_bus_pms_constrain_i2c
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART1 = (2 << 30);  ///< backup_bus_pms_constrain_uart1
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_2 Register bits
    namespace backup_bus_pms_constrain_2_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT = (2 << 0);  ///< backup_bus_pms_constrain_bt
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT0 = (2 << 4);  ///< backup_bus_pms_constrain_i2c_ext0
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UHCI0 = (2 << 6);  ///< backup_bus_pms_constrain_uhci0
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RMT = (2 << 10);  ///< backup_bus_pms_constrain_rmt
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_LEDC = (2 << 16);  ///< backup_bus_pms_constrain_ledc
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BB = (2 << 22);  ///< backup_bus_pms_constrain_bb
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP = (2 << 26);  ///< backup_bus_pms_constrain_timergroup
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP1 = (2 << 28);  ///< backup_bus_pms_constrain_timergroup1
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SYSTIMER = (2 << 30);  ///< backup_bus_pms_constrain_systimer
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_3 Register bits
    namespace backup_bus_pms_constrain_3_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SPI_2 = (2 << 0);  ///< backup_bus_pms_constrain_spi_2
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_CTRL = (2 << 4);  ///< backup_bus_pms_constrain_apb_ctrl
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CAN = (2 << 10);  ///< backup_bus_pms_constrain_can
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2S1 = (2 << 14);  ///< backup_bus_pms_constrain_i2s1
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RWBT = (2 << 22);  ///< backup_bus_pms_constrain_rwbt
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_WIFIMAC = (2 << 26);  ///< backup_bus_pms_constrain_wifimac
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWR = (2 << 28);  ///< backup_bus_pms_constrain_pwr
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_4 Register bits
    namespace backup_bus_pms_constrain_4_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_WRAP = (2 << 2);  ///< backup_bus_pms_constrain_usb_wrap
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_PERI = (2 << 4);  ///< backup_bus_pms_constrain_crypto_peri
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_DMA = (2 << 6);  ///< backup_bus_pms_constrain_crypto_dma
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_ADC = (2 << 8);  ///< backup_bus_pms_constrain_apb_adc
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT_PWR = (2 << 12);  ///< backup_bus_pms_constrain_bt_pwr
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_DEVICE = (2 << 14);  ///< backup_bus_pms_constrain_usb_device
    }

    /// BACKUP_BUS_PMS_MONITOR_0 Register bits
    namespace backup_bus_pms_monitor_0_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_LOCK = (1U << 0);  ///< backup_bus_pms_monitor_lock
    }

    /// BACKUP_BUS_PMS_MONITOR_1 Register bits
    namespace backup_bus_pms_monitor_1_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< backup_bus_pms_monitor_violate_clr
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< backup_bus_pms_monitor_violate_en
    }

    /// BACKUP_BUS_PMS_MONITOR_2 Register bits
    namespace backup_bus_pms_monitor_2_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< backup_bus_pms_monitor_violate_intr
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HTRANS = (2 << 1);  ///< backup_bus_pms_monitor_violate_status_htrans
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HSIZE = (3 << 3);  ///< backup_bus_pms_monitor_violate_status_hsize
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HWRITE = (1U << 6);  ///< backup_bus_pms_monitor_violate_status_hwrite
    }

    /// BACKUP_BUS_PMS_MONITOR_3 Register bits
    namespace backup_bus_pms_monitor_3_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_HADDR = (32 << 0);  ///< backup_bus_pms_monitor_violate_haddr
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clk_en
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< reg_date
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x60003000;
    constexpr uint32_t SPI1_BASE = 0x60002000;
    constexpr uint32_t SPI2_BASE = 0x60024000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x08 - SPI0 control register.
        volatile uint32_t CTRL1;  ///< Offset: 0x0C - SPI0 control1 register.
        volatile uint32_t CTRL2;  ///< Offset: 0x10 - SPI0 control2 register.
        volatile uint32_t CLOCK;  ///< Offset: 0x14 - SPI clock division control register.
        volatile uint32_t USER;  ///< Offset: 0x18 - SPI0 user register.
        volatile uint32_t USER1;  ///< Offset: 0x1C - SPI0 user1 register.
        volatile uint32_t USER2;  ///< Offset: 0x20 - SPI0 user2 register.
        volatile uint32_t RD_STATUS;  ///< Offset: 0x2C - SPI0 read control register.
        volatile uint32_t MISC;  ///< Offset: 0x34 - SPI0 misc register
        volatile uint32_t CACHE_FCTRL;  ///< Offset: 0x3C - SPI0 bit mode control register.
        volatile uint32_t FSM;  ///< Offset: 0x54 - SPI0 FSM status register
        volatile uint32_t TIMING_CALI;  ///< Offset: 0xA8 - SPI0 timing calibration register
        volatile uint32_t DIN_MODE;  ///< Offset: 0xAC - SPI0 input delay mode control register
        volatile uint32_t DIN_NUM;  ///< Offset: 0xB0 - SPI0 input delay number control register
        volatile uint32_t DOUT_MODE;  ///< Offset: 0xB4 - SPI0 output delay mode control register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xDC - SPI0 clk_gate register
        volatile uint32_t CORE_CLK_SEL;  ///< Offset: 0xE0 - SPI0 module clock select register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FDUMMY_OUT = (1U << 3);  ///< In the dummy phase the signal level of spi is output by the spi controller.
        constexpr uint32_t FCMD_DUAL = (1U << 7);  ///< Apply 2 signals during command phase 1:enable 0: disable
        constexpr uint32_t FCMD_QUAD = (1U << 8);  ///< Apply 4 signals during command phase 1:enable 0: disable
        constexpr uint32_t FASTRD_MODE = (1U << 13);  ///< This bit enable the bits: spi_mem_fread_qio, spi_mem_fread_dio, spi_mem_fread_qout and spi_mem_fread_dout. 1: enable 0: disable.
        constexpr uint32_t FREAD_DUAL = (1U << 14);  ///< In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low
        constexpr uint32_t D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low
        constexpr uint32_t FREAD_QUAD = (1U << 20);  ///< In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low.
        constexpr uint32_t FREAD_DIO = (1U << 23);  ///< In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t FREAD_QIO = (1U << 24);  ///< In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t CLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
        constexpr uint32_t RXFIFO_RST = (1U << 30);  ///< SPI0 RX FIFO reset signal.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CS_SETUP_TIME = (5 << 0);  ///< (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
        constexpr uint32_t CS_HOLD_TIME = (5 << 5);  ///< Spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
        constexpr uint32_t CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SYNC_RESET = (1U << 31);  ///< The FSM will be reset.
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLKCNT_L = (8 << 0);  ///< In the master mode it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t CLKCNT_H = (8 << 8);  ///< In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t CLKCNT_N = (8 << 16);  ///< In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t CLK_EQU_SYSCLK = (1U << 31);  ///< Set this bit in 1-division mode.
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t CS_HOLD = (1U << 6);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t CS_SETUP = (1U << 7);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t CK_OUT_EDGE = (1U << 9);  ///< the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay mode.
        constexpr uint32_t USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable.
        constexpr uint32_t USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation.
    }

    /// USER1 Register bits
    namespace user1_bits {
        constexpr uint32_t USR_DUMMY_CYCLELEN = (6 << 0);  ///< The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        constexpr uint32_t USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of address phase. The register value shall be (bit_num-1).
    }

    /// USER2 Register bits
    namespace user2_bits {
        constexpr uint32_t USR_COMMAND_VALUE = (16 << 0);  ///< The value of command.
        constexpr uint32_t USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1)
    }

    /// RD_STATUS Register bits
    namespace rd_status_bits {
        constexpr uint32_t WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode bit.
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t TRANS_END = (1U << 3);  ///< The bit is used to indicate the spi0_mst_st controlled transmitting is done.
        constexpr uint32_t TRANS_END_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt of spi0_mst_st controlled transmitting is done.
        constexpr uint32_t CSPI_ST_TRANS_END = (1U << 5);  ///< The bit is used to indicate the spi0_slv_st controlled transmitting is done.
        constexpr uint32_t CSPI_ST_TRANS_END_INT_ENA = (1U << 6);  ///< The bit is used to enable the interrupt of spi0_slv_st controlled transmitting is done.
        constexpr uint32_t CK_IDLE_EDGE = (1U << 9);  ///< 1: spi clk line is high when idle 0: spi clk line is low when idle
        constexpr uint32_t CS_KEEP_ACTIVE = (1U << 10);  ///< spi cs line keep low when the bit is set.
    }

    /// CACHE_FCTRL Register bits
    namespace cache_fctrl_bits {
        constexpr uint32_t CACHE_REQ_EN = (1U << 0);  ///< For SPI0, Cache access enable, 1: enable, 0:disable.
        constexpr uint32_t CACHE_USR_ADDR_4BYTE = (1U << 1);  ///< For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
        constexpr uint32_t CACHE_FLASH_USR_CMD = (1U << 2);  ///< For SPI0, cache read flash for user define command, 1: enable, 0:disable.
        constexpr uint32_t FDIN_DUAL = (1U << 3);  ///< For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FDOUT_DUAL = (1U << 4);  ///< For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FADDR_DUAL = (1U << 5);  ///< For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t FDIN_QUAD = (1U << 6);  ///< For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t FDOUT_QUAD = (1U << 7);  ///< For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t FADDR_QUAD = (1U << 8);  ///< For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
    }

    /// FSM Register bits
    namespace fsm_bits {
        constexpr uint32_t CSPI_ST = (4 << 0);  ///< The current status of SPI0 slave FSM: spi0_slv_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
        constexpr uint32_t EM_ST = (3 << 4);  ///< The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:EM_CACHE_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
        constexpr uint32_t CSPI_LOCK_DELAY_TIME = (5 << 7);  ///< The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
    }

    /// TIMING_CALI Register bits
    namespace timing_cali_bits {
        constexpr uint32_t TIMING_CLK_ENA = (1U << 0);  ///< The bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t TIMING_CALI = (1U << 1);  ///< The bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< add extra dummy spi clock cycle length for spi clock calibration.
    }

    /// DIN_MODE Register bits
    namespace din_mode_bits {
        constexpr uint32_t DIN0_MODE = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN1_MODE = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN2_MODE = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t DIN3_MODE = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// DIN_NUM Register bits
    namespace din_num_bits {
        constexpr uint32_t DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// DOUT_MODE Register bits
    namespace dout_mode_bits {
        constexpr uint32_t DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Register clock gate enable signal. 1: Enable. 0: Disable.
    }

    /// CORE_CLK_SEL Register bits
    namespace core_clk_sel_bits {
        constexpr uint32_t SPI01_CLK_SEL = (2 << 0);  ///< When the digital system clock selects PLL clock and the frequency of PLL clock is 480MHz, the value of reg_spi01_clk_sel: 0: SPI0/1 module clock (clk) is 80MHz. 1: SPI0/1 module clock (clk) is 120MHz. 2: SPI0/1 module clock (clk) 160MHz. 3: Not used. When the digital system clock selects PLL clock and the frequency of PLL clock is 320MHz, the value of reg_spi01_clk_sel: 0: SPI0/1 module clock (clk) is 80MHz. 1: SPI0/1 module clock (clk) is 80MHz. 2: SPI0/1 module clock (clk) 160MHz. 3: Not used.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< SPI register version.
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x600C0000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t CPU_PERI_CLK_EN;  ///< Offset: 0x00 - cpu_peripheral clock gating register
        volatile uint32_t CPU_PERI_RST_EN;  ///< Offset: 0x04 - cpu_peripheral reset register
        volatile uint32_t CPU_PER_CONF;  ///< Offset: 0x08 - cpu clock config register
        volatile uint32_t MEM_PD_MASK;  ///< Offset: 0x0C - memory power down mask register
        volatile uint32_t PERIP_CLK_EN0;  ///< Offset: 0x10 - peripheral clock gating register
        volatile uint32_t PERIP_CLK_EN1;  ///< Offset: 0x14 - peripheral clock gating register
        volatile uint32_t PERIP_RST_EN0;  ///< Offset: 0x18 - reserved
        volatile uint32_t PERIP_RST_EN1;  ///< Offset: 0x1C - peripheral reset register
        volatile uint32_t BT_LPCK_DIV_INT;  ///< Offset: 0x20 - clock config register
        volatile uint32_t BT_LPCK_DIV_FRAC;  ///< Offset: 0x24 - clock config register
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x28 - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x2C - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x30 - interrupt generate register
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x34 - interrupt generate register
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x38 - rsa memory power control register
        volatile uint32_t EDMA_CTRL;  ///< Offset: 0x3C - EDMA clock and reset register
        volatile uint32_t CACHE_CONTROL;  ///< Offset: 0x40 - cache control register
        volatile uint32_t EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL;  ///< Offset: 0x44 - SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG
        volatile uint32_t RTC_FASTMEM_CONFIG;  ///< Offset: 0x48 - fast memory config register
        volatile uint32_t RTC_FASTMEM_CRC;  ///< Offset: 0x4C - reserved
        volatile uint32_t REDUNDANT_ECO_CTRL;  ///< Offset: 0x50 - eco register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x54 - clock gating register
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x58 - system clock config register
        volatile uint32_t MEM_PVT;  ///< Offset: 0x5C - mem pvt register
        volatile uint32_t COMB_PVT_LVT_CONF;  ///< Offset: 0x60 - mem pvt register
        volatile uint32_t COMB_PVT_NVT_CONF;  ///< Offset: 0x64 - mem pvt register
        volatile uint32_t COMB_PVT_HVT_CONF;  ///< Offset: 0x68 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE0;  ///< Offset: 0x6C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE0;  ///< Offset: 0x70 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE0;  ///< Offset: 0x74 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE1;  ///< Offset: 0x78 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE1;  ///< Offset: 0x7C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE1;  ///< Offset: 0x80 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE2;  ///< Offset: 0x84 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE2;  ///< Offset: 0x88 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE2;  ///< Offset: 0x8C - mem pvt register
        volatile uint32_t COMB_PVT_ERR_LVT_SITE3;  ///< Offset: 0x90 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_NVT_SITE3;  ///< Offset: 0x94 - mem pvt register
        volatile uint32_t COMB_PVT_ERR_HVT_SITE3;  ///< Offset: 0x98 - mem pvt register
        volatile uint32_t SYSTEM_REG_DATE;  ///< Offset: 0xFFC - Version register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// CPU_PERI_CLK_EN Register bits
    namespace cpu_peri_clk_en_bits {
        constexpr uint32_t CLK_EN_ASSIST_DEBUG = (1U << 6);  ///< reg_clk_en_assist_debug
        constexpr uint32_t CLK_EN_DEDICATED_GPIO = (1U << 7);  ///< reg_clk_en_dedicated_gpio
    }

    /// CPU_PERI_RST_EN Register bits
    namespace cpu_peri_rst_en_bits {
        constexpr uint32_t RST_EN_ASSIST_DEBUG = (1U << 6);  ///< reg_rst_en_assist_debug
        constexpr uint32_t RST_EN_DEDICATED_GPIO = (1U << 7);  ///< reg_rst_en_dedicated_gpio
    }

    /// CPU_PER_CONF Register bits
    namespace cpu_per_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< reg_cpuperiod_sel
        constexpr uint32_t PLL_FREQ_SEL = (1U << 2);  ///< reg_pll_freq_sel
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 3);  ///< reg_cpu_wait_mode_force_on
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 4);  ///< reg_cpu_waiti_delay_num
    }

    /// MEM_PD_MASK Register bits
    namespace mem_pd_mask_bits {
        constexpr uint32_t LSLP_MEM_PD_MASK = (1U << 0);  ///< reg_lslp_mem_pd_mask
    }

    /// PERIP_CLK_EN0 Register bits
    namespace perip_clk_en0_bits {
        constexpr uint32_t TIMERS_CLK_EN = (1U << 0);  ///< reg_timers_clk_en
        constexpr uint32_t SPI01_CLK_EN = (1U << 1);  ///< reg_spi01_clk_en
        constexpr uint32_t UART_CLK_EN = (1U << 2);  ///< reg_uart_clk_en
        constexpr uint32_t WDG_CLK_EN = (1U << 3);  ///< reg_wdg_clk_en
        constexpr uint32_t I2S0_CLK_EN = (1U << 4);  ///< reg_i2s0_clk_en
        constexpr uint32_t UART1_CLK_EN = (1U << 5);  ///< reg_uart1_clk_en
        constexpr uint32_t SPI2_CLK_EN = (1U << 6);  ///< reg_spi2_clk_en
        constexpr uint32_t I2C_EXT0_CLK_EN = (1U << 7);  ///< reg_ext0_clk_en
        constexpr uint32_t UHCI0_CLK_EN = (1U << 8);  ///< reg_uhci0_clk_en
        constexpr uint32_t RMT_CLK_EN = (1U << 9);  ///< reg_rmt_clk_en
        constexpr uint32_t PCNT_CLK_EN = (1U << 10);  ///< reg_pcnt_clk_en
        constexpr uint32_t LEDC_CLK_EN = (1U << 11);  ///< reg_ledc_clk_en
        constexpr uint32_t UHCI1_CLK_EN = (1U << 12);  ///< reg_uhci1_clk_en
        constexpr uint32_t TIMERGROUP_CLK_EN = (1U << 13);  ///< reg_timergroup_clk_en
        constexpr uint32_t EFUSE_CLK_EN = (1U << 14);  ///< reg_efuse_clk_en
        constexpr uint32_t TIMERGROUP1_CLK_EN = (1U << 15);  ///< reg_timergroup1_clk_en
        constexpr uint32_t SPI3_CLK_EN = (1U << 16);  ///< reg_spi3_clk_en
        constexpr uint32_t PWM0_CLK_EN = (1U << 17);  ///< reg_pwm0_clk_en
        constexpr uint32_t EXT1_CLK_EN = (1U << 18);  ///< reg_ext1_clk_en
        constexpr uint32_t TWAI_CLK_EN = (1U << 19);  ///< reg_can_clk_en
        constexpr uint32_t PWM1_CLK_EN = (1U << 20);  ///< reg_pwm1_clk_en
        constexpr uint32_t I2S1_CLK_EN = (1U << 21);  ///< reg_i2s1_clk_en
        constexpr uint32_t SPI2_DMA_CLK_EN = (1U << 22);  ///< reg_spi2_dma_clk_en
        constexpr uint32_t USB_DEVICE_CLK_EN = (1U << 23);  ///< reg_usb_device_clk_en
        constexpr uint32_t UART_MEM_CLK_EN = (1U << 24);  ///< reg_uart_mem_clk_en
        constexpr uint32_t PWM2_CLK_EN = (1U << 25);  ///< reg_pwm2_clk_en
        constexpr uint32_t PWM3_CLK_EN = (1U << 26);  ///< reg_pwm3_clk_en
        constexpr uint32_t SPI3_DMA_CLK_EN = (1U << 27);  ///< reg_spi3_dma_clk_en
        constexpr uint32_t APB_SARADC_CLK_EN = (1U << 28);  ///< reg_apb_saradc_clk_en
        constexpr uint32_t SYSTIMER_CLK_EN = (1U << 29);  ///< reg_systimer_clk_en
        constexpr uint32_t ADC2_ARB_CLK_EN = (1U << 30);  ///< reg_adc2_arb_clk_en
        constexpr uint32_t SPI4_CLK_EN = (1U << 31);  ///< reg_spi4_clk_en
    }

    /// PERIP_CLK_EN1 Register bits
    namespace perip_clk_en1_bits {
        constexpr uint32_t CRYPTO_AES_CLK_EN = (1U << 1);  ///< reg_crypto_aes_clk_en
        constexpr uint32_t CRYPTO_SHA_CLK_EN = (1U << 2);  ///< reg_crypto_sha_clk_en
        constexpr uint32_t CRYPTO_RSA_CLK_EN = (1U << 3);  ///< reg_crypto_rsa_clk_en
        constexpr uint32_t CRYPTO_DS_CLK_EN = (1U << 4);  ///< reg_crypto_ds_clk_en
        constexpr uint32_t CRYPTO_HMAC_CLK_EN = (1U << 5);  ///< reg_crypto_hmac_clk_en
        constexpr uint32_t DMA_CLK_EN = (1U << 6);  ///< reg_dma_clk_en
        constexpr uint32_t SDIO_HOST_CLK_EN = (1U << 7);  ///< reg_sdio_host_clk_en
        constexpr uint32_t LCD_CAM_CLK_EN = (1U << 8);  ///< reg_lcd_cam_clk_en
        constexpr uint32_t UART2_CLK_EN = (1U << 9);  ///< reg_uart2_clk_en
        constexpr uint32_t TSENS_CLK_EN = (1U << 10);  ///< reg_tsens_clk_en
    }

    /// PERIP_RST_EN0 Register bits
    namespace perip_rst_en0_bits {
        constexpr uint32_t TIMERS_RST = (1U << 0);  ///< reg_timers_rst
        constexpr uint32_t SPI01_RST = (1U << 1);  ///< reg_spi01_rst
        constexpr uint32_t UART_RST = (1U << 2);  ///< reg_uart_rst
        constexpr uint32_t WDG_RST = (1U << 3);  ///< reg_wdg_rst
        constexpr uint32_t I2S0_RST = (1U << 4);  ///< reg_i2s0_rst
        constexpr uint32_t UART1_RST = (1U << 5);  ///< reg_uart1_rst
        constexpr uint32_t SPI2_RST = (1U << 6);  ///< reg_spi2_rst
        constexpr uint32_t I2C_EXT0_RST = (1U << 7);  ///< reg_ext0_rst
        constexpr uint32_t UHCI0_RST = (1U << 8);  ///< reg_uhci0_rst
        constexpr uint32_t RMT_RST = (1U << 9);  ///< reg_rmt_rst
        constexpr uint32_t PCNT_RST = (1U << 10);  ///< reg_pcnt_rst
        constexpr uint32_t LEDC_RST = (1U << 11);  ///< reg_ledc_rst
        constexpr uint32_t UHCI1_RST = (1U << 12);  ///< reg_uhci1_rst
        constexpr uint32_t TIMERGROUP_RST = (1U << 13);  ///< reg_timergroup_rst
        constexpr uint32_t EFUSE_RST = (1U << 14);  ///< reg_efuse_rst
        constexpr uint32_t TIMERGROUP1_RST = (1U << 15);  ///< reg_timergroup1_rst
        constexpr uint32_t SPI3_RST = (1U << 16);  ///< reg_spi3_rst
        constexpr uint32_t PWM0_RST = (1U << 17);  ///< reg_pwm0_rst
        constexpr uint32_t EXT1_RST = (1U << 18);  ///< reg_ext1_rst
        constexpr uint32_t TWAI_RST = (1U << 19);  ///< reg_can_rst
        constexpr uint32_t PWM1_RST = (1U << 20);  ///< reg_pwm1_rst
        constexpr uint32_t I2S1_RST = (1U << 21);  ///< reg_i2s1_rst
        constexpr uint32_t SPI2_DMA_RST = (1U << 22);  ///< reg_spi2_dma_rst
        constexpr uint32_t USB_DEVICE_RST = (1U << 23);  ///< reg_usb_device_rst
        constexpr uint32_t UART_MEM_RST = (1U << 24);  ///< reg_uart_mem_rst
        constexpr uint32_t PWM2_RST = (1U << 25);  ///< reg_pwm2_rst
        constexpr uint32_t PWM3_RST = (1U << 26);  ///< reg_pwm3_rst
        constexpr uint32_t SPI3_DMA_RST = (1U << 27);  ///< reg_spi3_dma_rst
        constexpr uint32_t APB_SARADC_RST = (1U << 28);  ///< reg_apb_saradc_rst
        constexpr uint32_t SYSTIMER_RST = (1U << 29);  ///< reg_systimer_rst
        constexpr uint32_t ADC2_ARB_RST = (1U << 30);  ///< reg_adc2_arb_rst
        constexpr uint32_t SPI4_RST = (1U << 31);  ///< reg_spi4_rst
    }

    /// PERIP_RST_EN1 Register bits
    namespace perip_rst_en1_bits {
        constexpr uint32_t CRYPTO_AES_RST = (1U << 1);  ///< reg_crypto_aes_rst
        constexpr uint32_t CRYPTO_SHA_RST = (1U << 2);  ///< reg_crypto_sha_rst
        constexpr uint32_t CRYPTO_RSA_RST = (1U << 3);  ///< reg_crypto_rsa_rst
        constexpr uint32_t CRYPTO_DS_RST = (1U << 4);  ///< reg_crypto_ds_rst
        constexpr uint32_t CRYPTO_HMAC_RST = (1U << 5);  ///< reg_crypto_hmac_rst
        constexpr uint32_t DMA_RST = (1U << 6);  ///< reg_dma_rst
        constexpr uint32_t SDIO_HOST_RST = (1U << 7);  ///< reg_sdio_host_rst
        constexpr uint32_t LCD_CAM_RST = (1U << 8);  ///< reg_lcd_cam_rst
        constexpr uint32_t UART2_RST = (1U << 9);  ///< reg_uart2_rst
        constexpr uint32_t TSENS_RST = (1U << 10);  ///< reg_tsens_rst
    }

    /// BT_LPCK_DIV_INT Register bits
    namespace bt_lpck_div_int_bits {
        constexpr uint32_t BT_LPCK_DIV_NUM = (12 << 0);  ///< reg_bt_lpck_div_num
    }

    /// BT_LPCK_DIV_FRAC Register bits
    namespace bt_lpck_div_frac_bits {
        constexpr uint32_t BT_LPCK_DIV_B = (12 << 0);  ///< reg_bt_lpck_div_b
        constexpr uint32_t BT_LPCK_DIV_A = (12 << 12);  ///< reg_bt_lpck_div_a
        constexpr uint32_t LPCLK_SEL_RTC_SLOW = (1U << 24);  ///< reg_lpclk_sel_rtc_slow
        constexpr uint32_t LPCLK_SEL_8M = (1U << 25);  ///< reg_lpclk_sel_8m
        constexpr uint32_t LPCLK_SEL_XTAL = (1U << 26);  ///< reg_lpclk_sel_xtal
        constexpr uint32_t LPCLK_SEL_XTAL32K = (1U << 27);  ///< reg_lpclk_sel_xtal32k
        constexpr uint32_t LPCLK_RTC_EN = (1U << 28);  ///< reg_lpclk_rtc_en
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< reg_cpu_intr_from_cpu_0
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< reg_cpu_intr_from_cpu_1
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< reg_cpu_intr_from_cpu_2
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< reg_cpu_intr_from_cpu_3
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_PD = (1U << 0);  ///< reg_rsa_mem_pd
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< reg_rsa_mem_force_pu
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 2);  ///< reg_rsa_mem_force_pd
    }

    /// EDMA_CTRL Register bits
    namespace edma_ctrl_bits {
        constexpr uint32_t EDMA_CLK_ON = (1U << 0);  ///< reg_edma_clk_on
        constexpr uint32_t EDMA_RESET = (1U << 1);  ///< reg_edma_reset
    }

    /// CACHE_CONTROL Register bits
    namespace cache_control_bits {
        constexpr uint32_t ICACHE_CLK_ON = (1U << 0);  ///< reg_icache_clk_on
        constexpr uint32_t ICACHE_RESET = (1U << 1);  ///< reg_icache_reset
        constexpr uint32_t DCACHE_CLK_ON = (1U << 2);  ///< reg_dcache_clk_on
        constexpr uint32_t DCACHE_RESET = (1U << 3);  ///< reg_dcache_reset
    }

    /// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL Register bits
    namespace external_device_encrypt_decrypt_control_bits {
        constexpr uint32_t ENABLE_SPI_MANUAL_ENCRYPT = (1U << 0);  ///< reg_enable_spi_manual_encrypt
        constexpr uint32_t ENABLE_DOWNLOAD_DB_ENCRYPT = (1U << 1);  ///< reg_enable_download_db_encrypt
        constexpr uint32_t ENABLE_DOWNLOAD_G0CB_DECRYPT = (1U << 2);  ///< reg_enable_download_g0cb_decrypt
        constexpr uint32_t ENABLE_DOWNLOAD_MANUAL_ENCRYPT = (1U << 3);  ///< reg_enable_download_manual_encrypt
    }

    /// RTC_FASTMEM_CONFIG Register bits
    namespace rtc_fastmem_config_bits {
        constexpr uint32_t RTC_MEM_CRC_START = (1U << 8);  ///< reg_rtc_mem_crc_start
        constexpr uint32_t RTC_MEM_CRC_ADDR = (11 << 9);  ///< reg_rtc_mem_crc_addr
        constexpr uint32_t RTC_MEM_CRC_LEN = (11 << 20);  ///< reg_rtc_mem_crc_len
        constexpr uint32_t RTC_MEM_CRC_FINISH = (1U << 31);  ///< reg_rtc_mem_crc_finish
    }

    /// RTC_FASTMEM_CRC Register bits
    namespace rtc_fastmem_crc_bits {
        constexpr uint32_t RTC_MEM_CRC_RES = (32 << 0);  ///< reg_rtc_mem_crc_res
    }

    /// REDUNDANT_ECO_CTRL Register bits
    namespace redundant_eco_ctrl_bits {
        constexpr uint32_t REDUNDANT_ECO_DRIVE = (1U << 0);  ///< reg_redundant_eco_drive
        constexpr uint32_t REDUNDANT_ECO_RESULT = (1U << 1);  ///< reg_redundant_eco_result
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< reg_clk_en
    }

    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< reg_pre_div_cnt
        constexpr uint32_t SOC_CLK_SEL = (2 << 10);  ///< reg_soc_clk_sel
        constexpr uint32_t CLK_XTAL_FREQ = (7 << 12);  ///< reg_clk_xtal_freq
        constexpr uint32_t CLK_DIV_EN = (1U << 19);  ///< reg_clk_div_en
    }

    /// MEM_PVT Register bits
    namespace mem_pvt_bits {
        constexpr uint32_t MEM_PATH_LEN = (4 << 0);  ///< reg_mem_path_len
        constexpr uint32_t MEM_ERR_CNT_CLR = (1U << 4);  ///< reg_mem_err_cnt_clr
        constexpr uint32_t MONITOR_EN = (1U << 5);  ///< reg_mem_pvt_monitor_en
        constexpr uint32_t MEM_TIMING_ERR_CNT = (16 << 6);  ///< reg_mem_timing_err_cnt
        constexpr uint32_t MEM_VT_SEL = (2 << 22);  ///< reg_mem_vt_sel
    }

    /// COMB_PVT_LVT_CONF Register bits
    namespace comb_pvt_lvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_LVT = (5 << 0);  ///< reg_comb_path_len_lvt
        constexpr uint32_t COMB_ERR_CNT_CLR_LVT = (1U << 5);  ///< reg_comb_err_cnt_clr_lvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_LVT = (1U << 6);  ///< reg_comb_pvt_monitor_en_lvt
    }

    /// COMB_PVT_NVT_CONF Register bits
    namespace comb_pvt_nvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_NVT = (5 << 0);  ///< reg_comb_path_len_nvt
        constexpr uint32_t COMB_ERR_CNT_CLR_NVT = (1U << 5);  ///< reg_comb_err_cnt_clr_nvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_NVT = (1U << 6);  ///< reg_comb_pvt_monitor_en_nvt
    }

    /// COMB_PVT_HVT_CONF Register bits
    namespace comb_pvt_hvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_HVT = (5 << 0);  ///< reg_comb_path_len_hvt
        constexpr uint32_t COMB_ERR_CNT_CLR_HVT = (1U << 5);  ///< reg_comb_err_cnt_clr_hvt
        constexpr uint32_t COMB_PVT_MONITOR_EN_HVT = (1U << 6);  ///< reg_comb_pvt_monitor_en_hvt
    }

    /// COMB_PVT_ERR_LVT_SITE0 Register bits
    namespace comb_pvt_err_lvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site0
    }

    /// COMB_PVT_ERR_NVT_SITE0 Register bits
    namespace comb_pvt_err_nvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site0
    }

    /// COMB_PVT_ERR_HVT_SITE0 Register bits
    namespace comb_pvt_err_hvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE0 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site0
    }

    /// COMB_PVT_ERR_LVT_SITE1 Register bits
    namespace comb_pvt_err_lvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site1
    }

    /// COMB_PVT_ERR_NVT_SITE1 Register bits
    namespace comb_pvt_err_nvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site1
    }

    /// COMB_PVT_ERR_HVT_SITE1 Register bits
    namespace comb_pvt_err_hvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE1 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site1
    }

    /// COMB_PVT_ERR_LVT_SITE2 Register bits
    namespace comb_pvt_err_lvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site2
    }

    /// COMB_PVT_ERR_NVT_SITE2 Register bits
    namespace comb_pvt_err_nvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site2
    }

    /// COMB_PVT_ERR_HVT_SITE2 Register bits
    namespace comb_pvt_err_hvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE2 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site2
    }

    /// COMB_PVT_ERR_LVT_SITE3 Register bits
    namespace comb_pvt_err_lvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_lvt_site3
    }

    /// COMB_PVT_ERR_NVT_SITE3 Register bits
    namespace comb_pvt_err_nvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_nvt_site3
    }

    /// COMB_PVT_ERR_HVT_SITE3 Register bits
    namespace comb_pvt_err_hvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE3 = (16 << 0);  ///< reg_comb_timing_err_cnt_hvt_site3
    }

    /// SYSTEM_REG_DATE Register bits
    namespace system_reg_date_bits {
        constexpr uint32_t SYSTEM_REG_DATE = (28 << 0);  ///< reg_system_reg_date
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t SYSTIMER_BASE = 0x60023000;
    constexpr uint32_t TIMG0_BASE = 0x6001F000;
    constexpr uint32_t TIMG1_BASE = 0x60020000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x00 - SYSTIMER_CONF.
        volatile uint32_t UNIT0_OP;  ///< Offset: 0x04 - SYSTIMER_UNIT0_OP.
        volatile uint32_t UNIT1_OP;  ///< Offset: 0x08 - SYSTIMER_UNIT1_OP.
        volatile uint32_t UNIT0_LOAD_HI;  ///< Offset: 0x0C - SYSTIMER_UNIT0_LOAD_HI.
        volatile uint32_t UNIT0_LOAD_LO;  ///< Offset: 0x10 - SYSTIMER_UNIT0_LOAD_LO.
        volatile uint32_t UNIT1_LOAD_HI;  ///< Offset: 0x14 - SYSTIMER_UNIT1_LOAD_HI.
        volatile uint32_t UNIT1_LOAD_LO;  ///< Offset: 0x18 - SYSTIMER_UNIT1_LOAD_LO.
        volatile uint32_t TARGET0_HI;  ///< Offset: 0x1C - SYSTIMER_TARGET0_HI.
        volatile uint32_t TARGET0_LO;  ///< Offset: 0x20 - SYSTIMER_TARGET0_LO.
        volatile uint32_t TARGET1_HI;  ///< Offset: 0x24 - SYSTIMER_TARGET1_HI.
        volatile uint32_t TARGET1_LO;  ///< Offset: 0x28 - SYSTIMER_TARGET1_LO.
        volatile uint32_t TARGET2_HI;  ///< Offset: 0x2C - SYSTIMER_TARGET2_HI.
        volatile uint32_t TARGET2_LO;  ///< Offset: 0x30 - SYSTIMER_TARGET2_LO.
        volatile uint32_t TARGET0_CONF;  ///< Offset: 0x34 - SYSTIMER_TARGET0_CONF.
        volatile uint32_t TARGET1_CONF;  ///< Offset: 0x38 - SYSTIMER_TARGET1_CONF.
        volatile uint32_t TARGET2_CONF;  ///< Offset: 0x3C - SYSTIMER_TARGET2_CONF.
        volatile uint32_t UNIT0_VALUE_HI;  ///< Offset: 0x40 - SYSTIMER_UNIT0_VALUE_HI.
        volatile uint32_t UNIT0_VALUE_LO;  ///< Offset: 0x44 - SYSTIMER_UNIT0_VALUE_LO.
        volatile uint32_t UNIT1_VALUE_HI;  ///< Offset: 0x48 - SYSTIMER_UNIT1_VALUE_HI.
        volatile uint32_t UNIT1_VALUE_LO;  ///< Offset: 0x4C - SYSTIMER_UNIT1_VALUE_LO.
        volatile uint32_t COMP0_LOAD;  ///< Offset: 0x50 - SYSTIMER_COMP0_LOAD.
        volatile uint32_t COMP1_LOAD;  ///< Offset: 0x54 - SYSTIMER_COMP1_LOAD.
        volatile uint32_t COMP2_LOAD;  ///< Offset: 0x58 - SYSTIMER_COMP2_LOAD.
        volatile uint32_t UNIT0_LOAD;  ///< Offset: 0x5C - SYSTIMER_UNIT0_LOAD.
        volatile uint32_t UNIT1_LOAD;  ///< Offset: 0x60 - SYSTIMER_UNIT1_LOAD.
        volatile uint32_t INT_ENA;  ///< Offset: 0x64 - SYSTIMER_INT_ENA.
        volatile uint32_t INT_RAW;  ///< Offset: 0x68 - SYSTIMER_INT_RAW.
        volatile uint32_t INT_CLR;  ///< Offset: 0x6C - SYSTIMER_INT_CLR.
        volatile uint32_t INT_ST;  ///< Offset: 0x70 - SYSTIMER_INT_ST.
        volatile uint32_t DATE;  ///< Offset: 0xFC - SYSTIMER_DATE.
    };

    /// Peripheral instances
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t SYSTIMER_CLK_FO = (1U << 0);  ///< systimer clock force on
        constexpr uint32_t TARGET2_WORK_EN = (1U << 22);  ///< target2 work enable
        constexpr uint32_t TARGET1_WORK_EN = (1U << 23);  ///< target1 work enable
        constexpr uint32_t TARGET0_WORK_EN = (1U << 24);  ///< target0 work enable
        constexpr uint32_t TIMER_UNIT1_CORE1_STALL_EN = (1U << 25);  ///< If timer unit1 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT1_CORE0_STALL_EN = (1U << 26);  ///< If timer unit1 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT0_CORE1_STALL_EN = (1U << 27);  ///< If timer unit0 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT0_CORE0_STALL_EN = (1U << 28);  ///< If timer unit0 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT1_WORK_EN = (1U << 29);  ///< timer unit1 work enable
        constexpr uint32_t TIMER_UNIT0_WORK_EN = (1U << 30);  ///< timer unit0 work enable
        constexpr uint32_t CLK_EN = (1U << 31);  ///< register file clk gating
    }

    /// UNIT0_OP Register bits
    namespace unit0_op_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_VALID = (1U << 29);  ///< reg_timer_unit0_value_valid
        constexpr uint32_t TIMER_UNIT0_UPDATE = (1U << 30);  ///< update timer_unit0
    }

    /// UNIT1_OP Register bits
    namespace unit1_op_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_VALID = (1U << 29);  ///< timer value is sync and valid
        constexpr uint32_t TIMER_UNIT1_UPDATE = (1U << 30);  ///< update timer unit1
    }

    /// UNIT0_LOAD_HI Register bits
    namespace unit0_load_hi_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_HI = (20 << 0);  ///< timer unit0 load high 32 bit
    }

    /// UNIT0_LOAD_LO Register bits
    namespace unit0_load_lo_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_LO = (32 << 0);  ///< timer unit0 load low 32 bit
    }

    /// UNIT1_LOAD_HI Register bits
    namespace unit1_load_hi_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_HI = (20 << 0);  ///< timer unit1 load high 32 bit
    }

    /// UNIT1_LOAD_LO Register bits
    namespace unit1_load_lo_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_LO = (32 << 0);  ///< timer unit1 load low 32 bit
    }

    /// TARGET0_HI Register bits
    namespace target0_hi_bits {
        constexpr uint32_t TIMER_TARGET0_HI = (20 << 0);  ///< timer taget0 high 32 bit
    }

    /// TARGET0_LO Register bits
    namespace target0_lo_bits {
        constexpr uint32_t TIMER_TARGET0_LO = (32 << 0);  ///< timer taget0 low 32 bit
    }

    /// TARGET1_HI Register bits
    namespace target1_hi_bits {
        constexpr uint32_t TIMER_TARGET1_HI = (20 << 0);  ///< timer taget1 high 32 bit
    }

    /// TARGET1_LO Register bits
    namespace target1_lo_bits {
        constexpr uint32_t TIMER_TARGET1_LO = (32 << 0);  ///< timer taget1 low 32 bit
    }

    /// TARGET2_HI Register bits
    namespace target2_hi_bits {
        constexpr uint32_t TIMER_TARGET2_HI = (20 << 0);  ///< timer taget2 high 32 bit
    }

    /// TARGET2_LO Register bits
    namespace target2_lo_bits {
        constexpr uint32_t TIMER_TARGET2_LO = (32 << 0);  ///< timer taget2 low 32 bit
    }

    /// TARGET0_CONF Register bits
    namespace target0_conf_bits {
        constexpr uint32_t TARGET0_PERIOD = (26 << 0);  ///< target0 period
        constexpr uint32_t TARGET0_PERIOD_MODE = (1U << 30);  ///< Set target0 to period mode
        constexpr uint32_t TARGET0_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET1_CONF Register bits
    namespace target1_conf_bits {
        constexpr uint32_t TARGET1_PERIOD = (26 << 0);  ///< target1 period
        constexpr uint32_t TARGET1_PERIOD_MODE = (1U << 30);  ///< Set target1 to period mode
        constexpr uint32_t TARGET1_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET2_CONF Register bits
    namespace target2_conf_bits {
        constexpr uint32_t TARGET2_PERIOD = (26 << 0);  ///< target2 period
        constexpr uint32_t TARGET2_PERIOD_MODE = (1U << 30);  ///< Set target2 to period mode
        constexpr uint32_t TARGET2_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// UNIT0_VALUE_HI Register bits
    namespace unit0_value_hi_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_HI = (20 << 0);  ///< timer read value high 32bit
    }

    /// UNIT0_VALUE_LO Register bits
    namespace unit0_value_lo_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_LO = (32 << 0);  ///< timer read value low 32bit
    }

    /// UNIT1_VALUE_HI Register bits
    namespace unit1_value_hi_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_HI = (20 << 0);  ///< timer read value high 32bit
    }

    /// UNIT1_VALUE_LO Register bits
    namespace unit1_value_lo_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_LO = (32 << 0);  ///< timer read value low 32bit
    }

    /// COMP0_LOAD Register bits
    namespace comp0_load_bits {
        constexpr uint32_t TIMER_COMP0_LOAD = (1U << 0);  ///< timer comp0 load value
    }

    /// COMP1_LOAD Register bits
    namespace comp1_load_bits {
        constexpr uint32_t TIMER_COMP1_LOAD = (1U << 0);  ///< timer comp1 load value
    }

    /// COMP2_LOAD Register bits
    namespace comp2_load_bits {
        constexpr uint32_t TIMER_COMP2_LOAD = (1U << 0);  ///< timer comp2 load value
    }

    /// UNIT0_LOAD Register bits
    namespace unit0_load_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD = (1U << 0);  ///< timer unit0 load value
    }

    /// UNIT1_LOAD Register bits
    namespace unit1_load_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD = (1U << 0);  ///< timer unit1 load value
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TARGET0_INT_ENA = (1U << 0);  ///< interupt0 enable
        constexpr uint32_t TARGET1_INT_ENA = (1U << 1);  ///< interupt1 enable
        constexpr uint32_t TARGET2_INT_ENA = (1U << 2);  ///< interupt2 enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TARGET0_INT_RAW = (1U << 0);  ///< interupt0 raw
        constexpr uint32_t TARGET1_INT_RAW = (1U << 1);  ///< interupt1 raw
        constexpr uint32_t TARGET2_INT_RAW = (1U << 2);  ///< interupt2 raw
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TARGET0_INT_CLR = (1U << 0);  ///< interupt0 clear
        constexpr uint32_t TARGET1_INT_CLR = (1U << 1);  ///< interupt1 clear
        constexpr uint32_t TARGET2_INT_CLR = (1U << 2);  ///< interupt2 clear
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TARGET0_INT_ST = (1U << 0);  ///< reg_target0_int_st
        constexpr uint32_t TARGET1_INT_ST = (1U << 1);  ///< reg_target1_int_st
        constexpr uint32_t TARGET2_INT_ST = (1U << 2);  ///< reg_target2_int_st
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< reg_date
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x6002B000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t CMD;  ///< Offset: 0x04 - Command Register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - Interrupt Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bus Timing Register 0
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bus Timing Register 1
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - Arbitration Lost Capture Register
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - Error Code Capture Register
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - Error Warning Limit Register
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Receive Error Counter Register
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Transmit Error Counter Register
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12
        volatile uint32_t RX_MESSAGE_CNT;  ///< Offset: 0x74 - Receive Message Counter Register
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock Divider register
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< This bit is used to configure the operating mode of the TWAI Controller. 1: Reset mode; 0: Operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: Listen only mode. In this mode the nodes will only receive messages from the bus, without generating the acknowledge signal nor updating the RX error counter.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: Self test mode. In this mode the TX nodes can perform a successful transmission without receiving the acknowledge signal. This mode is often used to test a single node with the self reception request command.
        constexpr uint32_t RX_FILTER_MODE = (1U << 3);  ///< This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single filter mode.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQ = (1U << 0);  ///< Set the bit to 1 to allow the driving nodes start transmission.
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< Set the bit to 1 to cancel a pending transmission request.
        constexpr uint32_t RELEASE_BUF = (1U << 2);  ///< Set the bit to 1 to release the RX buffer.
        constexpr uint32_t CLR_OVERRUN = (1U << 3);  ///< Set the bit to 1 to clear the data overrun status bit.
        constexpr uint32_t SELF_RX_REQ = (1U << 4);  ///< Self reception request command. Set the bit to 1 to allow a message be transmitted and received simultaneously.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RX_BUF_ST = (1U << 0);  ///< 1: The data in the RX buffer is not empty, with at least one received data packet.
        constexpr uint32_t OVERRUN_ST = (1U << 1);  ///< 1: The RX FIFO is full and data overrun has occurred.
        constexpr uint32_t TX_BUF_ST = (1U << 2);  ///< 1: The TX buffer is empty, the CPU may write a message into it.
        constexpr uint32_t TX_COMPLETE = (1U << 3);  ///< 1: The TWAI controller has successfully received a packet from the bus.
        constexpr uint32_t RX_ST = (1U << 4);  ///< 1: The TWAI Controller is receiving a message from the bus.
        constexpr uint32_t TX_ST = (1U << 5);  ///< 1: The TWAI Controller is transmitting a message to the bus.
        constexpr uint32_t ERR_ST = (1U << 6);  ///< 1: At least one of the RX/TX error counter has reached or exceeded the value set in register TWAI_ERR_WARNING_LIMIT_REG.
        constexpr uint32_t BUS_OFF_ST = (1U << 7);  ///< 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
        constexpr uint32_t MISS_ST = (1U << 8);  ///< This bit reflects whether the data packet in the RX FIFO is complete. 1: The current packet is missing; 0: The current packet is complete
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_INT_ST = (1U << 0);  ///< Receive interrupt. If this bit is set to 1, it indicates there are messages to be handled in the RX FIFO.
        constexpr uint32_t TX_INT_ST = (1U << 1);  ///< Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis- sion is finished and a new transmission is able to execute.
        constexpr uint32_t ERR_WARN_INT_ST = (1U << 2);  ///< Error warning interrupt. If this bit is set to 1, it indicates the error status signal and the bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or from 1 to 0).
        constexpr uint32_t OVERRUN_INT_ST = (1U << 3);  ///< Data overrun interrupt. If this bit is set to 1, it indicates a data overrun interrupt is generated in the RX FIFO.
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< Error passive interrupt. If this bit is set to 1, it indicates the TWAI Controller is switched between error active status and error passive status due to the change of error counters.
        constexpr uint32_t ARB_LOST_INT_ST = (1U << 6);  ///< Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration lost interrupt is generated.
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< Error interrupt. If this bit is set to 1, it indicates an error is detected on the bus.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable receive interrupt.
        constexpr uint32_t TX_INT_ENA = (1U << 1);  ///< Set this bit to 1 to enable transmit interrupt.
        constexpr uint32_t ERR_WARN_INT_ENA = (1U << 2);  ///< Set this bit to 1 to enable error warning interrupt.
        constexpr uint32_t OVERRUN_INT_ENA = (1U << 3);  ///< Set this bit to 1 to enable data overrun interrupt.
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< Set this bit to 1 to enable error passive interrupt.
        constexpr uint32_t ARB_LOST_INT_ENA = (1U << 6);  ///< Set this bit to 1 to enable arbitration lost interrupt.
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< Set this bit to 1 to enable error interrupt.
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (14 << 0);  ///< Baud Rate Prescaler, determines the frequency dividing ratio.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 14);  ///< Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEG1 = (4 << 0);  ///< The width of PBS1.
        constexpr uint32_t TIME_SEG2 = (3 << 4);  ///< The width of PBS2.
        constexpr uint32_t TIME_SAMP = (1U << 7);  ///< The number of sample points. 0: the bus is sampled once; 1: the bus is sampled three times
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARB_LOST_CAP = (5 << 0);  ///< This register contains information about the bit position of lost arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ECC_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors, see Table 181 for details.
        constexpr uint32_t ECC_DIRECTION = (1U << 5);  ///< This register contains information about transmission direction of the node when error occurs. 1: Error occurs when receiving a message; 0: Error occurs when transmitting a message
        constexpr uint32_t ECC_TYPE = (2 << 6);  ///< This register contains information about error types: 00: bit error; 01: form error; 10: stuff error; 11: other type of error
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< Error warning threshold. In the case when any of a error counter value exceeds the threshold, or all the error counter values are below the threshold, an error warning interrupt will be triggered (given the enable signal is valid).
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register, reflects value changes under reception status.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register, reflects value changes under transmission status.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t TX_BYTE_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, it stores the 0th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t TX_BYTE_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, it stores the 1st byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t TX_BYTE_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, it stores the 2nd byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t TX_BYTE_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, it stores the 3rd byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t TX_BYTE_4 = (8 << 0);  ///< In reset mode, it is acceptance code register 4 with R/W Permission. In operation mode, it stores the 4th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t TX_BYTE_5 = (8 << 0);  ///< In reset mode, it is acceptance code register 5 with R/W Permission. In operation mode, it stores the 5th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t TX_BYTE_6 = (8 << 0);  ///< In reset mode, it is acceptance code register 6 with R/W Permission. In operation mode, it stores the 6th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t TX_BYTE_7 = (8 << 0);  ///< In reset mode, it is acceptance code register 7 with R/W Permission. In operation mode, it stores the 7th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t TX_BYTE_8 = (8 << 0);  ///< In operation mode, it stores the 8th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t TX_BYTE_9 = (8 << 0);  ///< In operation mode, it stores the 9th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t TX_BYTE_10 = (8 << 0);  ///< In operation mode, it stores the 10th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t TX_BYTE_11 = (8 << 0);  ///< In operation mode, it stores the 11th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t TX_BYTE_12 = (8 << 0);  ///< In operation mode, it stores the 12th byte of the data to be transmitted or received. In operation mode, writing writes to the transmit buffer while reading reads from the receive buffer.
    }

    /// RX_MESSAGE_CNT Register bits
    namespace rx_message_cnt_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< This register reflects the number of messages available within the RX FIFO.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to configure frequency dividing coefficients of the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< This bit can be configured under reset mode. 1: Disable the external CLKOUT pin; 0: Enable the external CLKOUT pin
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x60000000;
    constexpr uint32_t UART1_BASE = 0x60010000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0;  ///< Offset: 0x20 - a
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t LOWPULSE;  ///< Offset: 0x28 - Autobaud minimum low pulse duration register
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x2C - Autobaud minimum high pulse duration register
        volatile uint32_t RXD_CNT;  ///< Offset: 0x30 - Autobaud edge change count register
        volatile uint32_t FLOW_CONF;  ///< Offset: 0x34 - Software flow-control configuration
        volatile uint32_t SLEEP_CONF;  ///< Offset: 0x38 - Sleep-mode configuration
        volatile uint32_t SWFC_CONF0;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x64 - Tx-FIFO write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x68 - Rx-FIFO write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x6C - UART transmit and receive status.
        volatile uint32_t POSPULSE;  ///< Offset: 0x70 - Autobaud high pulse register
        volatile uint32_t NEGPULSE;  ///< Offset: 0x74 - Autobaud low pulse register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x78 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x7C - UART Version register
        volatile uint32_t ID;  ///< Offset: 0x80 - UART ID register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters, after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for rs485_clash_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear the rs485_parity_err_int_raw interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear the rs485_frm_err_int_raw interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear the rs485_clash_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value, the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (10 << 0);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (10 << 16);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t SW_RTS = (1U << 6);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t SW_DTR = (1U << 7);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t TXD_BRK = (1U << 8);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 9);  ///< Set this bit to enable IrDA loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 10);  ///< This is the start enable bit for IrDA transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 11);  ///< 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 12);  ///< Set this bit to invert the level of IrDA transmitter.
        constexpr uint32_t IRDA_RX_INV = (1U << 13);  ///< Set this bit to invert the level of IrDA receiver.
        constexpr uint32_t LOOPBACK = (1U << 14);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 15);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t IRDA_EN = (1U << 16);  ///< Set this bit to enable IrDA protocol.
        constexpr uint32_t RXFIFO_RST = (1U << 17);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 18);  ///< Set this bit to reset the uart transmit-FIFO.
        constexpr uint32_t RXD_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t CTS_INV = (1U << 20);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 21);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t TXD_INV = (1U << 22);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t RTS_INV = (1U << 23);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 24);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t CLK_EN = (1U << 25);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
        constexpr uint32_t ERR_WR_MASK = (1U << 26);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t AUTOBAUD_EN = (1U << 27);  ///< This is the enable bit for detecting baudrate.
        constexpr uint32_t MEM_CLK_EN = (1U << 28);  ///< UART memory clock gate enable signal.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (9 << 0);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (9 << 9);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 18);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 19);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 20);  ///< This is the flow enable bit for UART receiver.
        constexpr uint32_t RX_TOUT_EN = (1U << 21);  ///< This is the enble bit for uart receiver's timeout function.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of rxd edge change. It is used in baud rate-detect process.
    }

    /// FLOW_CONF Register bits
    namespace flow_conf_bits {
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 0);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 1);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 2);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 3);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 4);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 5);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SLEEP_CONF Register bits
    namespace sleep_conf_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
    }

    /// SWFC_CONF0 Register bits
    namespace swfc_conf0_bits {
        constexpr uint32_t XOFF_THRESHOLD = (9 << 0);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1, it will send a Xoff char.
        constexpr uint32_t XOFF_CHAR = (8 << 9);  ///< This register stores the Xoff flow control char.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (9 << 0);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1, it will send a Xon char.
        constexpr uint32_t XON_CHAR = (8 << 9);  ///< This register stores the Xon flow control char.
    }

    /// TXBRK_CONF Register bits
    namespace txbrk_conf_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose the rs485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t RX_SIZE = (3 << 1);  ///< This register is used to configure the amount of mem allocated for receive-FIFO. The default number is 128 bytes.
        constexpr uint32_t TX_SIZE = (3 << 4);  ///< This register is used to configure the amount of mem allocated for transmit-FIFO. The default number is 128 bytes.
        constexpr uint32_t RX_FLOW_THRHD = (9 << 7);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 16);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
        constexpr uint32_t MEM_FORCE_PD = (1U << 26);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 27);  ///< Set this bit to force power up UART memory.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t APB_TX_WADDR = (10 << 0);  ///< This register stores the offset address in Tx-FIFO when software writes Tx-FIFO via APB.
        constexpr uint32_t TX_RADDR = (10 << 11);  ///< This register stores the offset address in Tx-FIFO when Tx-FSM reads data via Tx-FIFO_Ctrl.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t APB_RX_RADDR = (10 << 0);  ///< This register stores the offset address in RX-FIFO when software reads data from Rx-FIFO via APB. UART0 is 10'h100. UART1 is 10'h180.
        constexpr uint32_t RX_WADDR = (10 << 11);  ///< This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl writes Rx-FIFO. UART0 is 10'h100. UART1 is 10'h180.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_B = (6 << 0);  ///< The denominator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_A = (6 << 6);  ///< The numerator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t SCLK_SEL = (2 << 20);  ///< UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.
        constexpr uint32_t SCLK_EN = (1U << 22);  ///< Set this bit to enable UART Tx/Rx clock.
        constexpr uint32_t RST_CORE = (1U << 23);  ///< Write 1 then write 0 to this bit, reset UART Tx/Rx.
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t RX_SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit, reset UART Tx.
        constexpr uint32_t RX_RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit, reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (30 << 0);  ///< This register is used to configure the uart_id.
        constexpr uint32_t HIGH_SPEED = (1U << 30);  ///< This bit used to select synchronize mode. 1: Registers are auto synchronized into UART Core clock and UART core should be keep the same with APB clock. 0: After configure registers, software needs to write 1 to UART_REG_UPDATE to synchronize registers.
        constexpr uint32_t REG_UPDATE = (1U << 31);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x60014000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - a
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - a
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - a
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - a
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - a
        volatile uint32_t CONF1;  ///< Offset: 0x14 - a
        volatile uint32_t STATE0;  ///< Offset: 0x18 - a
        volatile uint32_t STATE1;  ///< Offset: 0x1C - a
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x20 - a
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x24 - a
        volatile uint32_t ACK_NUM;  ///< Offset: 0x28 - a
        volatile uint32_t RX_HEAD;  ///< Offset: 0x2C - a
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x30 - a
        volatile uint32_t REG_Q0_WORD0;  ///< Offset: 0x34 - a
        volatile uint32_t REG_Q0_WORD1;  ///< Offset: 0x38 - a
        volatile uint32_t REG_Q1_WORD0;  ///< Offset: 0x3C - a
        volatile uint32_t REG_Q1_WORD1;  ///< Offset: 0x40 - a
        volatile uint32_t REG_Q2_WORD0;  ///< Offset: 0x44 - a
        volatile uint32_t REG_Q2_WORD1;  ///< Offset: 0x48 - a
        volatile uint32_t REG_Q3_WORD0;  ///< Offset: 0x4C - a
        volatile uint32_t REG_Q3_WORD1;  ///< Offset: 0x50 - a
        volatile uint32_t REG_Q4_WORD0;  ///< Offset: 0x54 - a
        volatile uint32_t REG_Q4_WORD1;  ///< Offset: 0x58 - a
        volatile uint32_t REG_Q5_WORD0;  ///< Offset: 0x5C - a
        volatile uint32_t REG_Q5_WORD1;  ///< Offset: 0x60 - a
        volatile uint32_t REG_Q6_WORD0;  ///< Offset: 0x64 - a
        volatile uint32_t REG_Q6_WORD1;  ///< Offset: 0x68 - a
        volatile uint32_t ESC_CONF0;  ///< Offset: 0x6C - a
        volatile uint32_t ESC_CONF1;  ///< Offset: 0x70 - a
        volatile uint32_t ESC_CONF2;  ///< Offset: 0x74 - a
        volatile uint32_t ESC_CONF3;  ///< Offset: 0x78 - a
        volatile uint32_t PKT_THRES;  ///< Offset: 0x7C - a
        volatile uint32_t DATE;  ///< Offset: 0x80 - a
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t TX_RST = (1U << 0);  ///< Write 1, then write 0 to this bit to reset decode state machine.
        constexpr uint32_t RX_RST = (1U << 1);  ///< Write 1, then write 0 to this bit to reset encode state machine.
        constexpr uint32_t UART0_CE = (1U << 2);  ///< Set this bit to link up HCI and UART0.
        constexpr uint32_t UART1_CE = (1U << 3);  ///< Set this bit to link up HCI and UART1.
        constexpr uint32_t SEPER_EN = (1U << 5);  ///< Set this bit to separate the data frame using a special char.
        constexpr uint32_t HEAD_EN = (1U << 6);  ///< Set this bit to encode the data packet with a formatting header.
        constexpr uint32_t CRC_REC_EN = (1U << 7);  ///< Set this bit to enable UHCI to receive the 16 bit CRC.
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 8);  ///< If this bit is set to 1, UHCI will end the payload receiving process when UART has been in idle state.
        constexpr uint32_t LEN_EOF_EN = (1U << 9);  ///< If this bit is set to 1, UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI decoder receiving payload data is end when 0xc0 is received.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 10);  ///< Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
        constexpr uint32_t CLK_EN = (1U << 11);  ///< 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 12);  ///< If this bit is set to 1, UHCI will end payload receive process when NULL frame is received by UART.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_RAW = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_RAW = (1U << 5);  ///< a
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 6);  ///< This is the interrupt raw bit. Triggered when there are some errors in EOF in the
        constexpr uint32_t APP_CTRL0_INT_RAW = (1U << 7);  ///< Soft control int raw bit.
        constexpr uint32_t APP_CTRL1_INT_RAW = (1U << 8);  ///< Soft control int raw bit.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_ST = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_ST = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_ST = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_ST = (1U << 8);  ///< a
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_ENA = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_ENA = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_ENA = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_ENA = (1U << 8);  ///< a
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_CLR = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_CLR = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_CLR = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_CLR = (1U << 8);  ///< a
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< a
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< a
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< a
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< a
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< a
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< a
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< a
        constexpr uint32_t SW_START = (1U << 8);  ///< a
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t RX_ERR_CAUSE = (3 << 0);  ///< a
        constexpr uint32_t DECODE_STATE = (3 << 3);  ///< a
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t ENCODE_STATE = (3 << 0);  ///< a
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< a
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< a
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< a
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< a
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< a
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< a
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< a
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< a
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< a
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< a
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< a
    }

    /// ACK_NUM Register bits
    namespace ack_num_bits {
        constexpr uint32_t ACK_NUM = (3 << 0);  ///< a
        constexpr uint32_t LOAD = (1U << 3);  ///< a
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< a
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< a
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< a
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< a
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< a
    }

    /// REG_Q0_WORD0 Register bits
    namespace reg_q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q0_WORD1 Register bits
    namespace reg_q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q1_WORD0 Register bits
    namespace reg_q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q1_WORD1 Register bits
    namespace reg_q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q2_WORD0 Register bits
    namespace reg_q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q2_WORD1 Register bits
    namespace reg_q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q3_WORD0 Register bits
    namespace reg_q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q3_WORD1 Register bits
    namespace reg_q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q4_WORD0 Register bits
    namespace reg_q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q4_WORD1 Register bits
    namespace reg_q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q5_WORD0 Register bits
    namespace reg_q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q5_WORD1 Register bits
    namespace reg_q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q6_WORD0 Register bits
    namespace reg_q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q6_WORD1 Register bits
    namespace reg_q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< a
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< a
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< a
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< a
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< a
    }

}

// ============================================================================
// UHCI1 Peripheral
// ============================================================================

namespace uhci1 {
    /// Base addresses
    constexpr uint32_t UHCI1_BASE = 0x6000C000;

    /// UHCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* UHCI1 = reinterpret_cast<Registers*>(UHCI1_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_DEVICE_BASE = 0x60043000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP1;  ///< Offset: 0x00 - USB_DEVICE_EP1_REG.
        volatile uint32_t EP1_CONF;  ///< Offset: 0x04 - USB_DEVICE_EP1_CONF_REG.
        volatile uint32_t INT_RAW;  ///< Offset: 0x08 - USB_DEVICE_INT_RAW_REG.
        volatile uint32_t INT_ST;  ///< Offset: 0x0C - USB_DEVICE_INT_ST_REG.
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - USB_DEVICE_INT_ENA_REG.
        volatile uint32_t INT_CLR;  ///< Offset: 0x14 - USB_DEVICE_INT_CLR_REG.
        volatile uint32_t CONF0;  ///< Offset: 0x18 - USB_DEVICE_CONF0_REG.
        volatile uint32_t TEST;  ///< Offset: 0x1C - USB_DEVICE_TEST_REG.
        volatile uint32_t JFIFO_ST;  ///< Offset: 0x20 - USB_DEVICE_JFIFO_ST_REG.
        volatile uint32_t FRAM_NUM;  ///< Offset: 0x24 - USB_DEVICE_FRAM_NUM_REG.
        volatile uint32_t IN_EP0_ST;  ///< Offset: 0x28 - USB_DEVICE_IN_EP0_ST_REG.
        volatile uint32_t IN_EP1_ST;  ///< Offset: 0x2C - USB_DEVICE_IN_EP1_ST_REG.
        volatile uint32_t IN_EP2_ST;  ///< Offset: 0x30 - USB_DEVICE_IN_EP2_ST_REG.
        volatile uint32_t IN_EP3_ST;  ///< Offset: 0x34 - USB_DEVICE_IN_EP3_ST_REG.
        volatile uint32_t OUT_EP0_ST;  ///< Offset: 0x38 - USB_DEVICE_OUT_EP0_ST_REG.
        volatile uint32_t OUT_EP1_ST;  ///< Offset: 0x3C - USB_DEVICE_OUT_EP1_ST_REG.
        volatile uint32_t OUT_EP2_ST;  ///< Offset: 0x40 - USB_DEVICE_OUT_EP2_ST_REG.
        volatile uint32_t MISC_CONF;  ///< Offset: 0x44 - USB_DEVICE_MISC_CONF_REG.
        volatile uint32_t MEM_CONF;  ///< Offset: 0x48 - USB_DEVICE_MEM_CONF_REG.
        volatile uint32_t DATE;  ///< Offset: 0x80 - USB_DEVICE_DATE_REG.
    };

    /// Peripheral instances
    inline Registers* USB_DEVICE = reinterpret_cast<Registers*>(USB_DEVICE_BASE);

    // Bit definitions
    /// EP1 Register bits
    namespace ep1_bits {
        constexpr uint32_t RDWR_BYTE = (8 << 0);  ///< Write and read byte data to/from UART Tx/Rx FIFO through this field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes) into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many data is received, then read data from UART Rx FIFO.
    }

    /// EP1_CONF Register bits
    namespace ep1_conf_bits {
        constexpr uint32_t WR_DONE = (1U << 0);  ///< Set this bit to indicate writing byte data to UART Tx FIFO is done.
        constexpr uint32_t SERIAL_IN_EP_DATA_FREE = (1U << 1);  ///< 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is read by USB Host.
        constexpr uint32_t SERIAL_OUT_EP_DATA_AVAIL = (1U << 2);  ///< 1'b1: Indicate there is data in UART Rx FIFO.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when flush cmd is received for IN endpoint 2 of JTAG.
        constexpr uint32_t SOF_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when SOF frame is received.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when Serial Port OUT Endpoint received one packet.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_RAW = (1U << 3);  ///< The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
        constexpr uint32_t PID_ERR_INT_RAW = (1U << 4);  ///< The raw interrupt bit turns to high level when pid error is detected.
        constexpr uint32_t CRC5_ERR_INT_RAW = (1U << 5);  ///< The raw interrupt bit turns to high level when CRC5 error is detected.
        constexpr uint32_t CRC16_ERR_INT_RAW = (1U << 6);  ///< The raw interrupt bit turns to high level when CRC16 error is detected.
        constexpr uint32_t STUFF_ERR_INT_RAW = (1U << 7);  ///< The raw interrupt bit turns to high level when stuff error is detected.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_RAW = (1U << 8);  ///< The raw interrupt bit turns to high level when IN token for IN endpoint 1 is received.
        constexpr uint32_t USB_BUS_RESET_INT_RAW = (1U << 9);  ///< The raw interrupt bit turns to high level when usb bus reset is detected.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_RAW = (1U << 10);  ///< The raw interrupt bit turns to high level when OUT endpoint 1 received packet with zero palyload.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_RAW = (1U << 11);  ///< The raw interrupt bit turns to high level when OUT endpoint 2 received packet with zero palyload.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_ST = (1U << 3);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_ST = (1U << 4);  ///< The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_ST = (1U << 5);  ///< The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_ST = (1U << 6);  ///< The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_ST = (1U << 7);  ///< The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_ST = (1U << 8);  ///< The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_ST = (1U << 9);  ///< The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ST = (1U << 10);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ST = (1U << 11);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_CLR = (1U << 0);  ///< Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_CLR = (1U << 1);  ///< Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_CLR = (1U << 2);  ///< Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_CLR = (1U << 3);  ///< Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_CLR = (1U << 4);  ///< Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_CLR = (1U << 5);  ///< Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_CLR = (1U << 7);  ///< Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_CLR = (1U << 8);  ///< Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_CLR = (1U << 9);  ///< Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_CLR = (1U << 10);  ///< Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_CLR = (1U << 11);  ///< Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PHY_SEL = (1U << 0);  ///< Select internal/external PHY
        constexpr uint32_t EXCHG_PINS_OVERRIDE = (1U << 1);  ///< Enable software control USB D+ D- exchange
        constexpr uint32_t EXCHG_PINS = (1U << 2);  ///< USB D+ D- exchange
        constexpr uint32_t VREFH = (2 << 3);  ///< Control single-end input high threshold,1.76V to 2V, step 80mV
        constexpr uint32_t VREFL = (2 << 5);  ///< Control single-end input low threshold,0.8V to 1.04V, step 80mV
        constexpr uint32_t VREF_OVERRIDE = (1U << 7);  ///< Enable software control input threshold
        constexpr uint32_t PAD_PULL_OVERRIDE = (1U << 8);  ///< Enable software control USB D+ D- pullup pulldown
        constexpr uint32_t DP_PULLUP = (1U << 9);  ///< Control USB D+ pull up.
        constexpr uint32_t DP_PULLDOWN = (1U << 10);  ///< Control USB D+ pull down.
        constexpr uint32_t DM_PULLUP = (1U << 11);  ///< Control USB D- pull up.
        constexpr uint32_t DM_PULLDOWN = (1U << 12);  ///< Control USB D- pull down.
        constexpr uint32_t PULLUP_VALUE = (1U << 13);  ///< Control pull up value.
        constexpr uint32_t USB_PAD_ENABLE = (1U << 14);  ///< Enable USB pad function.
    }

    /// TEST Register bits
    namespace test_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< Enable test of the USB pad
        constexpr uint32_t USB_OE = (1U << 1);  ///< USB pad oen in test
        constexpr uint32_t TX_DP = (1U << 2);  ///< USB D+ tx value in test
        constexpr uint32_t TX_DM = (1U << 3);  ///< USB D- tx value in test
    }

    /// JFIFO_ST Register bits
    namespace jfifo_st_bits {
        constexpr uint32_t IN_FIFO_CNT = (2 << 0);  ///< JTAT in fifo counter.
        constexpr uint32_t IN_FIFO_EMPTY = (1U << 2);  ///< 1: JTAG in fifo is empty.
        constexpr uint32_t IN_FIFO_FULL = (1U << 3);  ///< 1: JTAG in fifo is full.
        constexpr uint32_t OUT_FIFO_CNT = (2 << 4);  ///< JTAT out fifo counter.
        constexpr uint32_t OUT_FIFO_EMPTY = (1U << 6);  ///< 1: JTAG out fifo is empty.
        constexpr uint32_t OUT_FIFO_FULL = (1U << 7);  ///< 1: JTAG out fifo is full.
        constexpr uint32_t IN_FIFO_RESET = (1U << 8);  ///< Write 1 to reset JTAG in fifo.
        constexpr uint32_t OUT_FIFO_RESET = (1U << 9);  ///< Write 1 to reset JTAG out fifo.
    }

    /// FRAM_NUM Register bits
    namespace fram_num_bits {
        constexpr uint32_t SOF_FRAME_INDEX = (11 << 0);  ///< Frame index of received SOF frame.
    }

    /// IN_EP0_ST Register bits
    namespace in_ep0_st_bits {
        constexpr uint32_t IN_EP0_STATE = (2 << 0);  ///< State of IN Endpoint 0.
        constexpr uint32_t IN_EP0_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 0.
        constexpr uint32_t IN_EP0_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 0.
    }

    /// IN_EP1_ST Register bits
    namespace in_ep1_st_bits {
        constexpr uint32_t IN_EP1_STATE = (2 << 0);  ///< State of IN Endpoint 1.
        constexpr uint32_t IN_EP1_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 1.
        constexpr uint32_t IN_EP1_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 1.
    }

    /// IN_EP2_ST Register bits
    namespace in_ep2_st_bits {
        constexpr uint32_t IN_EP2_STATE = (2 << 0);  ///< State of IN Endpoint 2.
        constexpr uint32_t IN_EP2_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 2.
        constexpr uint32_t IN_EP2_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 2.
    }

    /// IN_EP3_ST Register bits
    namespace in_ep3_st_bits {
        constexpr uint32_t IN_EP3_STATE = (2 << 0);  ///< State of IN Endpoint 3.
        constexpr uint32_t IN_EP3_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 3.
        constexpr uint32_t IN_EP3_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 3.
    }

    /// OUT_EP0_ST Register bits
    namespace out_ep0_st_bits {
        constexpr uint32_t OUT_EP0_STATE = (2 << 0);  ///< State of OUT Endpoint 0.
        constexpr uint32_t OUT_EP0_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
        constexpr uint32_t OUT_EP0_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 0.
    }

    /// OUT_EP1_ST Register bits
    namespace out_ep1_st_bits {
        constexpr uint32_t OUT_EP1_STATE = (2 << 0);  ///< State of OUT Endpoint 1.
        constexpr uint32_t OUT_EP1_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
        constexpr uint32_t OUT_EP1_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 1.
        constexpr uint32_t OUT_EP1_REC_DATA_CNT = (7 << 16);  ///< Data count in OUT endpoint 1 when one packet is received.
    }

    /// OUT_EP2_ST Register bits
    namespace out_ep2_st_bits {
        constexpr uint32_t OUT_EP2_STATE = (2 << 0);  ///< State of OUT Endpoint 2.
        constexpr uint32_t OUT_EP2_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
        constexpr uint32_t OUT_EP2_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 2.
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t USB_MEM_PD = (1U << 0);  ///< 1: power down usb memory.
        constexpr uint32_t USB_MEM_CLK_EN = (1U << 1);  ///< 1: Force clock on for usb memory.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

}


} // namespace alloy::generated::esp32-c3

#endif // ALLOY_GENERATED_ESP32-C3_PERIPHERALS_HPP