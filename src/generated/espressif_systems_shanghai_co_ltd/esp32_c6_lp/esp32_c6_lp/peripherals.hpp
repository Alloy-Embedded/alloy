/// Auto-generated code for ESP32-C6-LP
/// Generated by Alloy Code Generator
/// Source: espressif_esp32c6.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:05
#ifndef ALLOY_GENERATED_ESP32-C6-LP_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-C6-LP_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-c6-lp {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_lp = true;
    constexpr uint32_t num_lp_instances = 7;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct lp_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits

    // USART-specific traits
    constexpr bool has_lp_uart = true;
}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LP_I2C_BASE = 0x600B1800;
    constexpr uint32_t LP_I2C_ANA_MST_BASE = 0x600B2400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - Configures the low level width of the SCL Clock
        volatile uint32_t CTR;  ///< Offset: 0x04 - Transmission setting
        volatile uint32_t SR;  ///< Offset: 0x08 - Describe I2C work status.
        volatile uint32_t TO;  ///< Offset: 0x0C - Setting time out control for receiving data.
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - FIFO status register.
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - FIFO configuration register.
        volatile uint32_t DATA;  ///< Offset: 0x1C - Rx FIFO read data.
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Interrupt clear bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Interrupt enable bits
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - Status of captured I2C communication events
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - Configures the hold time after a negative SCL edge.
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - Configures the sample time after a positive SCL edge.
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - Configures the high level width of SCL
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - Configures the delay between the SDA and SCL negative...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - Configures the delay between the positive edge of SCL...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - Configures the delay after the SCL clock edge for a stop...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - Configures the delay between the SDA and SCL positive...
        volatile uint32_t FILTER_CFG;  ///< Offset: 0x50 - SCL and SDA filter configuration register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x54 - I2C CLK configuration register
        volatile uint32_t COMD0;  ///< Offset: 0x58 - I2C command register 0
        volatile uint32_t COMD1;  ///< Offset: 0x5C - I2C command register 1
        volatile uint32_t COMD2;  ///< Offset: 0x60 - I2C command register 2
        volatile uint32_t COMD3;  ///< Offset: 0x64 - I2C command register 3
        volatile uint32_t COMD4;  ///< Offset: 0x68 - I2C command register 4
        volatile uint32_t COMD5;  ///< Offset: 0x6C - I2C command register 5
        volatile uint32_t COMD6;  ///< Offset: 0x70 - I2C command register 6
        volatile uint32_t COMD7;  ///< Offset: 0x74 - I2C command register 7
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x78 - SCL status time out register
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x7C - SCL main status time out register
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0x80 - Power configuration register
        volatile uint32_t DATE;  ///< Offset: 0xF8 - Version register
        volatile uint32_t TXFIFO_START_ADDR;  ///< Offset: 0x100 - I2C TXFIFO base address register
        volatile uint32_t RXFIFO_START_ADDR;  ///< Offset: 0x180 - I2C RXFIFO base address register
    };

    /// Peripheral instances
    inline Registers* LP_I2C = reinterpret_cast<Registers*>(LP_I2C_BASE);
    inline Registers* LP_I2C_ANA_MST = reinterpret_cast<Registers*>(LP_I2C_ANA_MST_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 1: direct output, 0: open drain output.
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 1: direct output, 0: open drain output.
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< This register is used to select the sample mode. 1: sample SDA data on the SCL low level. 0: sample SDA data on the SCL high level.
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending the data in txfifo.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit, 0: send data from the most significant bit.
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received data. 1: receive data from the least significant bit, 0: receive data from the most significant bit.
        constexpr uint32_t CLK_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< This is the enable bit for arbitration_lost.
        constexpr uint32_t FSM_RST = (1U << 10);  ///< This register is used to reset the scl FMS.
        constexpr uint32_t CONF_UPGATE = (1U << 11);  ///< synchronization bit
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< When the I2C controller loses control of SCL line, this register changes to 1.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
        constexpr uint32_t RXFIFO_CNT = (5 << 8);  ///< This field represents the amount of data needed to be sent.
        constexpr uint32_t TXFIFO_CNT = (5 << 18);  ///< This field stores the amount of received data in RAM.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This field indicates the states of the state machine used to produce SCL. 0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (5 << 0);  ///< This register is used to configure the timeout for receiving a data bit in APB clock cycles.
        constexpr uint32_t TIME_OUT_EN = (1U << 5);  ///< This is the enable bit for time out control.
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_RADDR = (4 << 0);  ///< This is the offset address of the APB reading from rxfifo
        constexpr uint32_t RXFIFO_WADDR = (4 << 5);  ///< This is the offset address of i2c module receiving data and writing to rxfifo.
        constexpr uint32_t TXFIFO_RADDR = (4 << 10);  ///< This is the offset address of i2c module reading from txfifo.
        constexpr uint32_t TXFIFO_WADDR = (4 << 15);  ///< This is the offset address of APB bus writing to txfifo.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (4 << 0);  ///< The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[3:0], reg_rxfifo_wm_int_raw bit will be valid.
        constexpr uint32_t TXFIFO_WM_THRHD = (4 << 5);  ///< The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[3:0], reg_txfifo_wm_int_raw bit will be valid.
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enable APB nonfifo access.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset rx-fifo.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset tx-fifo.
        constexpr uint32_t FIFO_PRT_EN = (1U << 14);  ///< The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The value of rx FIFO read data.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< Set this bit to clear I2C_DET_START_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< The interrupt enable bit for I2C_DET_START_INT interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2C_DET_START_INT interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time to hold the data after the negative edge of SCL, in I2C module clock cycles.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL setup to high level and remains high in master mode, in I2C module clock cycles.
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (7 << 9);  ///< This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the negative edge of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the delay after the STOP condition, in I2C module clock cycles.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the positive edge of SDA, in I2C module clock cycles.
    }

    /// FILTER_CFG Register bits
    namespace filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< When a pulse on the SCL input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SDA_FILTER_THRES = (4 << 4);  ///< When a pulse on the SDA input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 8);  ///< This is the filter enable bit for SCL.
        constexpr uint32_t SDA_FILTER_EN = (1U << 9);  ///< This is the filter enable bit for SDA.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_NUM = (8 << 0);  ///< the integral part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_A = (6 << 8);  ///< the numerator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_B = (6 << 14);  ///< the denominator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
        constexpr uint32_t SCLK_ACTIVE = (1U << 21);  ///< The clock switch for i2c module
    }

    /// COMD0 Register bits
    namespace comd0_bits {
        constexpr uint32_t COMMAND0 = (14 << 0);  ///< This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND0_DONE = (1U << 31);  ///< When command 0 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD1 Register bits
    namespace comd1_bits {
        constexpr uint32_t COMMAND1 = (14 << 0);  ///< This is the content of command 1. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND1_DONE = (1U << 31);  ///< When command 1 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD2 Register bits
    namespace comd2_bits {
        constexpr uint32_t COMMAND2 = (14 << 0);  ///< This is the content of command 2. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND2_DONE = (1U << 31);  ///< When command 2 is done in I2C Master mode, this bit changes to high Level.
    }

    /// COMD3 Register bits
    namespace comd3_bits {
        constexpr uint32_t COMMAND3 = (14 << 0);  ///< This is the content of command 3. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND3_DONE = (1U << 31);  ///< When command 3 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD4 Register bits
    namespace comd4_bits {
        constexpr uint32_t COMMAND4 = (14 << 0);  ///< This is the content of command 4. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND4_DONE = (1U << 31);  ///< When command 4 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD5 Register bits
    namespace comd5_bits {
        constexpr uint32_t COMMAND5 = (14 << 0);  ///< This is the content of command 5. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND5_DONE = (1U << 31);  ///< When command 5 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD6 Register bits
    namespace comd6_bits {
        constexpr uint32_t COMMAND6 = (14 << 0);  ///< This is the content of command 6. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND6_DONE = (1U << 31);  ///< When command 6 is done in I2C Master mode, this bit changes to high level.
    }

    /// COMD7 Register bits
    namespace comd7_bits {
        constexpr uint32_t COMMAND7 = (14 << 0);  ///< This is the content of command 7. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND7_DONE = (1U << 31);  ///< When command 7 is done in I2C Master mode, this bit changes to high level.
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_FSM state unchanged period. It should be o more than 23
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the the version register.
    }

    /// TXFIFO_START_ADDR Register bits
    namespace txfifo_start_addr_bits {
        constexpr uint32_t TXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C txfifo first address.
    }

    /// RXFIFO_START_ADDR Register bits
    namespace rxfifo_start_addr_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C rxfifo first address.
    }

}

// ============================================================================
// LP Peripheral
// ============================================================================

namespace lp {
    /// Base addresses
    constexpr uint32_t LP_PERI_BASE = 0x600B2800;
    constexpr uint32_t LP_ANA_PERI_BASE = 0x600B2C00;
    constexpr uint32_t LP_AON_BASE = 0x600B1000;
    constexpr uint32_t LP_APM_BASE = 0x600B3800;
    constexpr uint32_t LP_CLKRST_BASE = 0x600B0400;
    constexpr uint32_t LP_IO_MUX_BASE = 0x600B2000;
    constexpr uint32_t LP_TEE_BASE = 0x600B3400;

    /// LP Register structure
    struct Registers {
        volatile uint32_t CLK_EN;  ///< Offset: 0x00 - need_des
        volatile uint32_t RESET_EN;  ///< Offset: 0x04 - need_des
        volatile uint32_t RNG_DATA;  ///< Offset: 0x08 - need_des
        volatile uint32_t CPU;  ///< Offset: 0x0C - need_des
        volatile uint32_t BUS_TIMEOUT;  ///< Offset: 0x10 - need_des
        volatile uint32_t BUS_TIMEOUT_ADDR;  ///< Offset: 0x14 - need_des
        volatile uint32_t BUS_TIMEOUT_UID;  ///< Offset: 0x18 - need_des
        volatile uint32_t MEM_CTRL;  ///< Offset: 0x1C - need_des
        volatile uint32_t INTERRUPT_SOURCE;  ///< Offset: 0x20 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_PERI = reinterpret_cast<Registers*>(LP_PERI_BASE);
    inline Registers* LP_ANA_PERI = reinterpret_cast<Registers*>(LP_ANA_PERI_BASE);
    inline Registers* LP_AON = reinterpret_cast<Registers*>(LP_AON_BASE);
    inline Registers* LP_APM = reinterpret_cast<Registers*>(LP_APM_BASE);
    inline Registers* LP_CLKRST = reinterpret_cast<Registers*>(LP_CLKRST_BASE);
    inline Registers* LP_IO_MUX = reinterpret_cast<Registers*>(LP_IO_MUX_BASE);
    inline Registers* LP_TEE = reinterpret_cast<Registers*>(LP_TEE_BASE);

    // Bit definitions
    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t LP_TOUCH_CK_EN = (1U << 23);  ///< need_des
        constexpr uint32_t RNG_CK_EN = (1U << 24);  ///< need_des
        constexpr uint32_t OTP_DBG_CK_EN = (1U << 25);  ///< need_des
        constexpr uint32_t LP_UART_CK_EN = (1U << 26);  ///< need_des
        constexpr uint32_t LP_IO_CK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t LP_EXT_I2C_CK_EN = (1U << 28);  ///< need_des
        constexpr uint32_t LP_ANA_I2C_CK_EN = (1U << 29);  ///< need_des
        constexpr uint32_t EFUSE_CK_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_CK_EN = (1U << 31);  ///< need_des
    }

    /// RESET_EN Register bits
    namespace reset_en_bits {
        constexpr uint32_t BUS_RESET_EN = (1U << 23);  ///< need_des
        constexpr uint32_t LP_TOUCH_RESET_EN = (1U << 24);  ///< need_des
        constexpr uint32_t OTP_DBG_RESET_EN = (1U << 25);  ///< need_des
        constexpr uint32_t LP_UART_RESET_EN = (1U << 26);  ///< need_des
        constexpr uint32_t LP_IO_RESET_EN = (1U << 27);  ///< need_des
        constexpr uint32_t LP_EXT_I2C_RESET_EN = (1U << 28);  ///< need_des
        constexpr uint32_t LP_ANA_I2C_RESET_EN = (1U << 29);  ///< need_des
        constexpr uint32_t EFUSE_RESET_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_RESET_EN = (1U << 31);  ///< need_des
    }

    /// RNG_DATA Register bits
    namespace rng_data_bits {
        constexpr uint32_t RND_DATA = (32 << 0);  ///< need_des
    }

    /// CPU Register bits
    namespace cpu_bits {
        constexpr uint32_t LPCORE_DBGM_UNAVALIABLE = (1U << 31);  ///< need_des
    }

    /// BUS_TIMEOUT Register bits
    namespace bus_timeout_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_THRES = (16 << 14);  ///< need_des
        constexpr uint32_t LP_PERI_TIMEOUT_INT_CLEAR = (1U << 30);  ///< need_des
        constexpr uint32_t LP_PERI_TIMEOUT_PROTECT_EN = (1U << 31);  ///< need_des
    }

    /// BUS_TIMEOUT_ADDR Register bits
    namespace bus_timeout_addr_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_ADDR = (32 << 0);  ///< need_des
    }

    /// BUS_TIMEOUT_UID Register bits
    namespace bus_timeout_uid_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_UID = (7 << 0);  ///< need_des
    }

    /// MEM_CTRL Register bits
    namespace mem_ctrl_bits {
        constexpr uint32_t UART_WAKEUP_FLAG_CLR = (1U << 0);  ///< need_des
        constexpr uint32_t UART_WAKEUP_FLAG = (1U << 1);  ///< need_des
        constexpr uint32_t UART_WAKEUP_EN = (1U << 29);  ///< need_des
        constexpr uint32_t UART_MEM_FORCE_PD = (1U << 30);  ///< need_des
        constexpr uint32_t UART_MEM_FORCE_PU = (1U << 31);  ///< need_des
    }

    /// INTERRUPT_SOURCE Register bits
    namespace interrupt_source_bits {
        constexpr uint32_t LP_INTERRUPT_SOURCE = (6 << 0);  ///< BIT5~BIT0: pmu_lp_int, modem_lp_int, lp_timer_lp_int, lp_uart_int, lp_i2c_int, lp_io_int
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LPPERI_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LP_TIMER_BASE = 0x600B0C00;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TAR0_LOW;  ///< Offset: 0x00 - need_des
        volatile uint32_t TAR0_HIGH;  ///< Offset: 0x04 - need_des
        volatile uint32_t TAR1_LOW;  ///< Offset: 0x08 - need_des
        volatile uint32_t TAR1_HIGH;  ///< Offset: 0x0C - need_des
        volatile uint32_t UPDATE;  ///< Offset: 0x10 - need_des
        volatile uint32_t MAIN_BUF0_LOW;  ///< Offset: 0x14 - need_des
        volatile uint32_t MAIN_BUF0_HIGH;  ///< Offset: 0x18 - need_des
        volatile uint32_t MAIN_BUF1_LOW;  ///< Offset: 0x1C - need_des
        volatile uint32_t MAIN_BUF1_HIGH;  ///< Offset: 0x20 - need_des
        volatile uint32_t MAIN_OVERFLOW;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ST;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_ENA;  ///< Offset: 0x30 - need_des
        volatile uint32_t INT_CLR;  ///< Offset: 0x34 - need_des
        volatile uint32_t LP_INT_RAW;  ///< Offset: 0x38 - need_des
        volatile uint32_t LP_INT_ST;  ///< Offset: 0x3C - need_des
        volatile uint32_t LP_INT_ENA;  ///< Offset: 0x40 - need_des
        volatile uint32_t LP_INT_CLR;  ///< Offset: 0x44 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_TIMER = reinterpret_cast<Registers*>(LP_TIMER_BASE);

    // Bit definitions
    /// TAR0_LOW Register bits
    namespace tar0_low_bits {
        constexpr uint32_t MAIN_TIMER_TAR_LOW0 = (32 << 0);  ///< need_des
    }

    /// TAR0_HIGH Register bits
    namespace tar0_high_bits {
        constexpr uint32_t MAIN_TIMER_TAR_HIGH0 = (16 << 0);  ///< need_des
        constexpr uint32_t MAIN_TIMER_TAR_EN0 = (1U << 31);  ///< need_des
    }

    /// TAR1_LOW Register bits
    namespace tar1_low_bits {
        constexpr uint32_t MAIN_TIMER_TAR_LOW1 = (32 << 0);  ///< need_des
    }

    /// TAR1_HIGH Register bits
    namespace tar1_high_bits {
        constexpr uint32_t MAIN_TIMER_TAR_HIGH1 = (16 << 0);  ///< need_des
        constexpr uint32_t MAIN_TIMER_TAR_EN1 = (1U << 31);  ///< need_des
    }

    /// UPDATE Register bits
    namespace update_bits {
        constexpr uint32_t MAIN_TIMER_UPDATE = (1U << 28);  ///< need_des
        constexpr uint32_t MAIN_TIMER_XTAL_OFF = (1U << 29);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_STALL = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_RST = (1U << 31);  ///< need_des
    }

    /// MAIN_BUF0_LOW Register bits
    namespace main_buf0_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF0_HIGH Register bits
    namespace main_buf0_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_BUF1_LOW Register bits
    namespace main_buf1_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF1_HIGH Register bits
    namespace main_buf1_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_OVERFLOW Register bits
    namespace main_overflow_bits {
        constexpr uint32_t MAIN_TIMER_ALARM_LOAD = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t OVERFLOW_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t OVERFLOW_ST = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t OVERFLOW_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t OVERFLOW_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_INT_RAW Register bits
    namespace lp_int_raw_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// LP_INT_ST Register bits
    namespace lp_int_st_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_ST = (1U << 31);  ///< need_des
    }

    /// LP_INT_ENA Register bits
    namespace lp_int_ena_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// LP_INT_CLR Register bits
    namespace lp_int_clr_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LP_UART_BASE = 0x600B1400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV_SYNC;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0_SYNC;  ///< Offset: 0x20 - Configuration register 0
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t HWFC_CONF_SYNC;  ///< Offset: 0x2C - Hardware flow-control configuration
        volatile uint32_t SLEEP_CONF0;  ///< Offset: 0x30 - UART sleep configure register 0
        volatile uint32_t SLEEP_CONF1;  ///< Offset: 0x34 - UART sleep configure register 1
        volatile uint32_t SLEEP_CONF2;  ///< Offset: 0x38 - UART sleep configure register 2
        volatile uint32_t SWFC_CONF0_SYNC;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF_SYNC;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF_SYNC;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF_SYNC;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT_SYNC;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT_SYNC;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT_SYNC;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR_SYNC;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART memory power configuration
        volatile uint32_t TOUT_CONF_SYNC;  ///< Offset: 0x64 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x68 - Tx-SRAM write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x6C - Rx-SRAM write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x70 - UART transmit and receive status.
        volatile uint32_t CLK_CONF;  ///< Offset: 0x88 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x8C - UART Version register
        volatile uint32_t AFIFO_STATUS;  ///< Offset: 0x90 - UART AFIFO Status
        volatile uint32_t REG_UPDATE;  ///< Offset: 0x98 - UART Registers Configuration Update register
        volatile uint32_t ID;  ///< Offset: 0x9C - UART ID register
    };

    /// Peripheral instances
    inline Registers* LP_UART = reinterpret_cast<Registers*>(LP_UART_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV_SYNC Register bits
    namespace clkdiv_sync_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t CLKDIV_FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (5 << 3);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (5 << 19);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0_SYNC Register bits
    namespace conf0_sync_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t TXD_BRK = (1U << 6);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t LOOPBACK = (1U << 12);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 13);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t RXD_INV = (1U << 15);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t TXD_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 17);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t ERR_WR_MASK = (1U << 18);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t MEM_CLK_EN = (1U << 20);  ///< UART memory clock gate enable signal.
        constexpr uint32_t SW_RTS = (1U << 21);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t RXFIFO_RST = (1U << 22);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 23);  ///< Set this bit to reset the uart transmit-FIFO.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (5 << 3);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (5 << 11);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t CTS_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 17);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t RTS_INV = (1U << 18);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t SW_DTR = (1U << 20);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t CLK_EN = (1U << 21);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// HWFC_CONF_SYNC Register bits
    namespace hwfc_conf_sync_bits {
        constexpr uint32_t RX_FLOW_THRHD = (5 << 3);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 8);  ///< This is the flow enable bit for UART receiver.
    }

    /// SLEEP_CONF0 Register bits
    namespace sleep_conf0_bits {
        constexpr uint32_t WK_CHAR1 = (8 << 0);  ///< This register restores the specified wake up char1 to wake up
        constexpr uint32_t WK_CHAR2 = (8 << 8);  ///< This register restores the specified wake up char2 to wake up
        constexpr uint32_t WK_CHAR3 = (8 << 16);  ///< This register restores the specified wake up char3 to wake up
        constexpr uint32_t WK_CHAR4 = (8 << 24);  ///< This register restores the specified wake up char4 to wake up
    }

    /// SLEEP_CONF1 Register bits
    namespace sleep_conf1_bits {
        constexpr uint32_t WK_CHAR0 = (8 << 0);  ///< This register restores the specified char0 to wake up
    }

    /// SLEEP_CONF2 Register bits
    namespace sleep_conf2_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
        constexpr uint32_t RX_WAKE_UP_THRHD = (5 << 13);  ///< In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
        constexpr uint32_t WK_CHAR_NUM = (3 << 18);  ///< This register is used to select number of wake up char.
        constexpr uint32_t WK_CHAR_MASK = (5 << 21);  ///< This register is used to mask wake up char.
        constexpr uint32_t WK_MODE_SEL = (2 << 26);  ///< This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
    }

    /// SWFC_CONF0_SYNC Register bits
    namespace swfc_conf0_sync_bits {
        constexpr uint32_t XON_CHAR = (8 << 0);  ///< This register stores the Xon flow control char.
        constexpr uint32_t XOFF_CHAR = (8 << 8);  ///< This register stores the Xoff flow control char.
        constexpr uint32_t XON_XOFF_STILL_SEND = (1U << 16);  ///< In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 17);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 18);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 19);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 20);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 21);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 22);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (5 << 3);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1 it will send a Xon char.
        constexpr uint32_t XOFF_THRESHOLD = (5 << 11);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1 it will send a Xoff char.
    }

    /// TXBRK_CONF_SYNC Register bits
    namespace txbrk_conf_sync_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF_SYNC Register bits
    namespace idle_conf_sync_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF_SYNC Register bits
    namespace rs485_conf_sync_bits {
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
    }

    /// AT_CMD_PRECNT_SYNC Register bits
    namespace at_cmd_precnt_sync_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT_SYNC Register bits
    namespace at_cmd_postcnt_sync_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT_SYNC Register bits
    namespace at_cmd_gaptout_sync_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR_SYNC Register bits
    namespace at_cmd_char_sync_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t MEM_FORCE_PD = (1U << 25);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 26);  ///< Set this bit to force power up UART memory.
    }

    /// TOUT_CONF_SYNC Register bits
    namespace tout_conf_sync_bits {
        constexpr uint32_t RX_TOUT_EN = (1U << 0);  ///< This is the enble bit for uart receiver's timeout function.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 1);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 2);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t TX_SRAM_WADDR = (5 << 3);  ///< This register stores the offset write address in Tx-SRAM.
        constexpr uint32_t TX_SRAM_RADDR = (5 << 12);  ///< This register stores the offset read address in Tx-SRAM.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t RX_SRAM_RADDR = (5 << 3);  ///< This register stores the offset read address in RX-SRAM.
        constexpr uint32_t RX_SRAM_WADDR = (5 << 12);  ///< This register stores the offset write address in Rx-SRAM.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_B = (6 << 0);  ///< The denominator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_A = (6 << 6);  ///< The numerator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t SCLK_SEL = (2 << 20);  ///< UART clock source select. 1: 80Mhz. 2: 8Mhz. 3: XTAL.
        constexpr uint32_t SCLK_EN = (1U << 22);  ///< Set this bit to enable UART Tx/Rx clock.
        constexpr uint32_t RST_CORE = (1U << 23);  ///< Write 1 then write 0 to this bit to reset UART Tx/Rx.
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t RX_SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit to reset UART Tx.
        constexpr uint32_t RX_RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit to reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// AFIFO_STATUS Register bits
    namespace afifo_status_bits {
        constexpr uint32_t TX_AFIFO_FULL = (1U << 0);  ///< Full signal of APB TX AFIFO.
        constexpr uint32_t TX_AFIFO_EMPTY = (1U << 1);  ///< Empty signal of APB TX AFIFO.
        constexpr uint32_t RX_AFIFO_FULL = (1U << 2);  ///< Full signal of APB RX AFIFO.
        constexpr uint32_t RX_AFIFO_EMPTY = (1U << 3);  ///< Empty signal of APB RX AFIFO.
    }

    /// REG_UPDATE Register bits
    namespace reg_update_bits {
        constexpr uint32_t REG_UPDATE = (1U << 0);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< This register is used to configure the uart_id.
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t LP_WDT_BASE = 0x600B1C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t CONFIG0;  ///< Offset: 0x00 - need_des
        volatile uint32_t CONFIG1;  ///< Offset: 0x04 - need_des
        volatile uint32_t CONFIG2;  ///< Offset: 0x08 - need_des
        volatile uint32_t CONFIG3;  ///< Offset: 0x0C - need_des
        volatile uint32_t CONFIG4;  ///< Offset: 0x10 - need_des
        volatile uint32_t FEED;  ///< Offset: 0x14 - need_des
        volatile uint32_t WPROTECT;  ///< Offset: 0x18 - need_des
        volatile uint32_t SWD_CONFIG;  ///< Offset: 0x1C - need_des
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0x20 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_ST;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ENA;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_CLR;  ///< Offset: 0x30 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_WDT = reinterpret_cast<Registers*>(LP_WDT_BASE);

    // Bit definitions
    /// CONFIG0 Register bits
    namespace config0_bits {
        constexpr uint32_t WDT_CHIP_RESET_WIDTH = (8 << 0);  ///< need_des
        constexpr uint32_t WDT_CHIP_RESET_EN = (1U << 8);  ///< need_des
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< need_des
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 10);  ///< need_des
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< need_des
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< need_des
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< need_des
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< need_des
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< need_des
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< need_des
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< need_des
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< need_des
        constexpr uint32_t WDT_EN = (1U << 31);  ///< need_des
    }

    /// CONFIG1 Register bits
    namespace config1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG2 Register bits
    namespace config2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG3 Register bits
    namespace config3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG4 Register bits
    namespace config4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< need_des
    }

    /// FEED Register bits
    namespace feed_bits {
        constexpr uint32_t RTC_WDT_FEED = (1U << 31);  ///< need_des
    }

    /// WPROTECT Register bits
    namespace wprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< need_des
    }

    /// SWD_CONFIG Register bits
    namespace swd_config_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< need_des
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 18);  ///< need_des
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 19);  ///< need_des
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 20);  ///< need_des
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< need_des
        constexpr uint32_t SWD_FEED = (1U << 31);  ///< need_des
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t SUPER_WDT_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t SUPER_WDT_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t SUPER_WDT_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t SUPER_WDT_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LP_WDT_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}


} // namespace alloy::generated::esp32-c6-lp

#endif // ALLOY_GENERATED_ESP32-C6-LP_PERIPHERALS_HPP