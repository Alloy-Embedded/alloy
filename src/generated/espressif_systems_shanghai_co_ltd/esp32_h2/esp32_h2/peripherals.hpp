/// Auto-generated code for ESP32-H2
/// Generated by Alloy Code Generator
/// Source: espressif_esp32h2.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:10
#ifndef ALLOY_GENERATED_ESP32-H2_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-H2_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-h2 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 4;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_assist = true;
    constexpr uint32_t num_assist_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_ecc = true;
    constexpr uint32_t num_ecc_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_hp = true;
    constexpr uint32_t num_hp_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 1;
    constexpr bool has_intpri = true;
    constexpr uint32_t num_intpri_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 2;
    constexpr bool has_lp = true;
    constexpr uint32_t num_lp_instances = 5;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 4;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_mem = true;
    constexpr uint32_t num_mem_instances = 1;
    constexpr bool has_modem = true;
    constexpr uint32_t num_modem_instances = 2;
    constexpr bool has_otp = true;
    constexpr uint32_t num_otp_instances = 1;
    constexpr bool has_parl = true;
    constexpr uint32_t num_parl_instances = 1;
    constexpr bool has_pau = true;
    constexpr uint32_t num_pau_instances = 1;
    constexpr bool has_pcnt = true;
    constexpr uint32_t num_pcnt_instances = 1;
    constexpr bool has_pcr = true;
    constexpr uint32_t num_pcr_instances = 1;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_soc = true;
    constexpr uint32_t num_soc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_tee = true;
    constexpr uint32_t num_tee_instances = 1;
    constexpr bool has_trace = true;
    constexpr uint32_t num_trace_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct assist_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct hp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct intpri_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct lp_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct modem_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct otp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct parl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcnt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct soc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct tee_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trace_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x60088000;
    constexpr uint32_t HMAC_BASE = 0x6008D000;
    constexpr uint32_t RSA_BASE = 0x6008A000;
    constexpr uint32_t SHA_BASE = 0x60089000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t KEY_0;  ///< Offset: 0x00 - Key material key_0 configure register
        volatile uint32_t KEY_1;  ///< Offset: 0x04 - Key material key_1 configure register
        volatile uint32_t KEY_2;  ///< Offset: 0x08 - Key material key_2 configure register
        volatile uint32_t KEY_3;  ///< Offset: 0x0C - Key material key_3 configure register
        volatile uint32_t KEY_4;  ///< Offset: 0x10 - Key material key_4 configure register
        volatile uint32_t KEY_5;  ///< Offset: 0x14 - Key material key_5 configure register
        volatile uint32_t KEY_6;  ///< Offset: 0x18 - Key material key_6 configure register
        volatile uint32_t KEY_7;  ///< Offset: 0x1C - Key material key_7 configure register
        volatile uint32_t TEXT_IN_0;  ///< Offset: 0x20 - source text material text_in_0 configure register
        volatile uint32_t TEXT_IN_1;  ///< Offset: 0x24 - source text material text_in_1 configure register
        volatile uint32_t TEXT_IN_2;  ///< Offset: 0x28 - source text material text_in_2 configure register
        volatile uint32_t TEXT_IN_3;  ///< Offset: 0x2C - source text material text_in_3 configure register
        volatile uint32_t TEXT_OUT_0;  ///< Offset: 0x30 - result text material text_out_0 configure register
        volatile uint32_t TEXT_OUT_1;  ///< Offset: 0x34 - result text material text_out_1 configure register
        volatile uint32_t TEXT_OUT_2;  ///< Offset: 0x38 - result text material text_out_2 configure register
        volatile uint32_t TEXT_OUT_3;  ///< Offset: 0x3C - result text material text_out_3 configure register
        volatile uint32_t MODE;  ///< Offset: 0x40 - AES Mode register
        volatile uint32_t ENDIAN;  ///< Offset: 0x44 - AES Endian configure register
        volatile uint32_t TRIGGER;  ///< Offset: 0x48 - AES trigger register
        volatile uint32_t STATE;  ///< Offset: 0x4C - AES state register
        volatile uint32_t IV_MEM[%s];  ///< Offset: 0x50 - The memory that stores initialization vector
        volatile uint32_t H_MEM[%s];  ///< Offset: 0x60 - The memory that stores GCM hash subkey
        volatile uint32_t J0_MEM[%s];  ///< Offset: 0x70 - The memory that stores J0
        volatile uint32_t T0_MEM[%s];  ///< Offset: 0x80 - The memory that stores T0
        volatile uint32_t DMA_ENABLE;  ///< Offset: 0x90 - DMA-AES working mode register
        volatile uint32_t BLOCK_MODE;  ///< Offset: 0x94 - AES cipher block mode register
        volatile uint32_t BLOCK_NUM;  ///< Offset: 0x98 - AES block number register
        volatile uint32_t INC_SEL;  ///< Offset: 0x9C - Standard incrementing function configure register
        volatile uint32_t AAD_BLOCK_NUM;  ///< Offset: 0xA0 - Additional Authential Data block number register
        volatile uint32_t REMAINDER_BIT_NUM;  ///< Offset: 0xA4 - AES remainder bit number register
        volatile uint32_t CONTINUE;  ///< Offset: 0xA8 - AES continue register
        volatile uint32_t INT_CLEAR;  ///< Offset: 0xAC - AES Interrupt clear register
        volatile uint32_t INT_ENA;  ///< Offset: 0xB0 - AES Interrupt enable register
        volatile uint32_t DATE;  ///< Offset: 0xB4 - AES version control register
        volatile uint32_t DMA_EXIT;  ///< Offset: 0xB8 - AES-DMA exit config
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* HMAC = reinterpret_cast<Registers*>(HMAC_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);

    // Bit definitions
    /// KEY_0 Register bits
    namespace key_0_bits {
        constexpr uint32_t KEY_0 = (32 << 0);  ///< This bits stores key_0 that is a part of key material.
    }

    /// KEY_1 Register bits
    namespace key_1_bits {
        constexpr uint32_t KEY_1 = (32 << 0);  ///< This bits stores key_1 that is a part of key material.
    }

    /// KEY_2 Register bits
    namespace key_2_bits {
        constexpr uint32_t KEY_2 = (32 << 0);  ///< This bits stores key_2 that is a part of key material.
    }

    /// KEY_3 Register bits
    namespace key_3_bits {
        constexpr uint32_t KEY_3 = (32 << 0);  ///< This bits stores key_3 that is a part of key material.
    }

    /// KEY_4 Register bits
    namespace key_4_bits {
        constexpr uint32_t KEY_4 = (32 << 0);  ///< This bits stores key_4 that is a part of key material.
    }

    /// KEY_5 Register bits
    namespace key_5_bits {
        constexpr uint32_t KEY_5 = (32 << 0);  ///< This bits stores key_5 that is a part of key material.
    }

    /// KEY_6 Register bits
    namespace key_6_bits {
        constexpr uint32_t KEY_6 = (32 << 0);  ///< This bits stores key_6 that is a part of key material.
    }

    /// KEY_7 Register bits
    namespace key_7_bits {
        constexpr uint32_t KEY_7 = (32 << 0);  ///< This bits stores key_7 that is a part of key material.
    }

    /// TEXT_IN_0 Register bits
    namespace text_in_0_bits {
        constexpr uint32_t TEXT_IN_0 = (32 << 0);  ///< This bits stores text_in_0 that is a part of source text material.
    }

    /// TEXT_IN_1 Register bits
    namespace text_in_1_bits {
        constexpr uint32_t TEXT_IN_1 = (32 << 0);  ///< This bits stores text_in_1 that is a part of source text material.
    }

    /// TEXT_IN_2 Register bits
    namespace text_in_2_bits {
        constexpr uint32_t TEXT_IN_2 = (32 << 0);  ///< This bits stores text_in_2 that is a part of source text material.
    }

    /// TEXT_IN_3 Register bits
    namespace text_in_3_bits {
        constexpr uint32_t TEXT_IN_3 = (32 << 0);  ///< This bits stores text_in_3 that is a part of source text material.
    }

    /// TEXT_OUT_0 Register bits
    namespace text_out_0_bits {
        constexpr uint32_t TEXT_OUT_0 = (32 << 0);  ///< This bits stores text_out_0 that is a part of result text material.
    }

    /// TEXT_OUT_1 Register bits
    namespace text_out_1_bits {
        constexpr uint32_t TEXT_OUT_1 = (32 << 0);  ///< This bits stores text_out_1 that is a part of result text material.
    }

    /// TEXT_OUT_2 Register bits
    namespace text_out_2_bits {
        constexpr uint32_t TEXT_OUT_2 = (32 << 0);  ///< This bits stores text_out_2 that is a part of result text material.
    }

    /// TEXT_OUT_3 Register bits
    namespace text_out_3_bits {
        constexpr uint32_t TEXT_OUT_3 = (32 << 0);  ///< This bits stores text_out_3 that is a part of result text material.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< This bits decides which one operation mode will be used. 3'd0: AES-EN-128, 3'd1: AES-EN-192, 3'd2: AES-EN-256, 3'd4: AES-DE-128, 3'd5: AES-DE-192, 3'd6: AES-DE-256.
    }

    /// ENDIAN Register bits
    namespace endian_bits {
        constexpr uint32_t ENDIAN = (6 << 0);  ///< endian. [1:0] key endian, [3:2] text_in endian or in_stream endian, [5:4] text_out endian or out_stream endian
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< Set this bit to start AES calculation.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< Those bits shows AES status. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
    }

    /// DMA_ENABLE Register bits
    namespace dma_enable_bits {
        constexpr uint32_t DMA_ENABLE = (1U << 0);  ///< 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
    }

    /// BLOCK_MODE Register bits
    namespace block_mode_bits {
        constexpr uint32_t BLOCK_MODE = (3 << 0);  ///< Those bits decides which block mode will be used. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: GCM, 0x7: reserved.
    }

    /// BLOCK_NUM Register bits
    namespace block_num_bits {
        constexpr uint32_t BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of Plaintext/ciphertext block.
    }

    /// INC_SEL Register bits
    namespace inc_sel_bits {
        constexpr uint32_t INC_SEL = (1U << 0);  ///< This bit decides the standard incrementing function. 0: INC32. 1: INC128.
    }

    /// AAD_BLOCK_NUM Register bits
    namespace aad_block_num_bits {
        constexpr uint32_t AAD_BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of AAD block.
    }

    /// REMAINDER_BIT_NUM Register bits
    namespace remainder_bit_num_bits {
        constexpr uint32_t REMAINDER_BIT_NUM = (7 << 0);  ///< Those bits stores the number of remainder bit.
    }

    /// CONTINUE Register bits
    namespace continue_bits {
        constexpr uint32_t CONTINUE = (1U << 0);  ///< Set this bit to continue GCM operation.
    }

    /// INT_CLEAR Register bits
    namespace int_clear_bits {
        constexpr uint32_t INT_CLEAR = (1U << 0);  ///< Set this bit to clear the AES interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t INT_ENA = (1U << 0);  ///< Set this bit to enable interrupt that occurs when DMA-AES calculation is done.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< This bits stores the version information of AES.
    }

    /// DMA_EXIT Register bits
    namespace dma_exit_bits {
        constexpr uint32_t DMA_EXIT = (1U << 0);  ///< Set this register to leave calculation done stage. Recommend to use it after software finishes reading DMA's output buffer.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t APB_SARADC_BASE = 0x6000E000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - digital saradc configure register
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - digital saradc configure register
        volatile uint32_t FILTER_CTRL1;  ///< Offset: 0x08 - digital saradc configure register
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - digital saradc configure register
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - digital saradc configure register
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - digital saradc configure register
        volatile uint32_t SAR_PATT_TAB1;  ///< Offset: 0x18 - digital saradc configure register
        volatile uint32_t SAR_PATT_TAB2;  ///< Offset: 0x1C - digital saradc configure register
        volatile uint32_t ONETIME_SAMPLE;  ///< Offset: 0x20 - digital saradc configure register
        volatile uint32_t ARB_CTRL;  ///< Offset: 0x24 - digital saradc configure register
        volatile uint32_t FILTER_CTRL0;  ///< Offset: 0x28 - digital saradc configure register
        volatile uint32_t SAR1DATA_STATUS;  ///< Offset: 0x2C - digital saradc configure register
        volatile uint32_t SAR2DATA_STATUS;  ///< Offset: 0x30 - digital saradc configure register
        volatile uint32_t THRES0_CTRL;  ///< Offset: 0x34 - digital saradc configure register
        volatile uint32_t THRES1_CTRL;  ///< Offset: 0x38 - digital saradc configure register
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x3C - digital saradc configure register
        volatile uint32_t INT_ENA;  ///< Offset: 0x40 - digital saradc int register
        volatile uint32_t INT_RAW;  ///< Offset: 0x44 - digital saradc int register
        volatile uint32_t INT_ST;  ///< Offset: 0x48 - digital saradc int register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - digital saradc int register
        volatile uint32_t DMA_CONF;  ///< Offset: 0x50 - digital saradc configure register
        volatile uint32_t CLKM_CONF;  ///< Offset: 0x54 - digital saradc configure register
        volatile uint32_t APB_TSENS_CTRL;  ///< Offset: 0x58 - digital tsens configure register
        volatile uint32_t TSENS_CTRL2;  ///< Offset: 0x5C - digital tsens configure register
        volatile uint32_t CALI;  ///< Offset: 0x60 - digital saradc configure register
        volatile uint32_t APB_TSENS_WAKE;  ///< Offset: 0x64 - digital tsens configure register
        volatile uint32_t APB_TSENS_SAMPLE;  ///< Offset: 0x68 - digital tsens configure register
        volatile uint32_t CTRL_DATE;  ///< Offset: 0x3FC - version
    };

    /// Peripheral instances
    inline Registers* APB_SARADC = reinterpret_cast<Registers*>(APB_SARADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SARADC_START_FORCE = (1U << 0);  ///< select software enable saradc sample
        constexpr uint32_t SARADC_START = (1U << 1);  ///< software enable saradc sample
        constexpr uint32_t SARADC_SAR_CLK_GATED = (1U << 6);  ///< SAR clock gated
        constexpr uint32_t SARADC_SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SARADC_SAR_PATT_LEN = (3 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SARADC_XPD_SAR_FORCE = (2 << 27);  ///< force option to xpd sar blocks
        constexpr uint32_t SARADC2_PWDET_DRV = (1U << 29);  ///< enable saradc2 power detect driven func.
        constexpr uint32_t SARADC_WAIT_ARB_CYCLE = (2 << 30);  ///< wait arbit signal stable after sar_done
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t SARADC_MEAS_NUM_LIMIT = (1U << 0);  ///< enable max meas num
        constexpr uint32_t SARADC_MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SARADC_SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_TIMER_TARGET = (12 << 12);  ///< to set saradc timer target
        constexpr uint32_t SARADC_TIMER_EN = (1U << 24);  ///< to enable saradc timer trigger
    }

    /// FILTER_CTRL1 Register bits
    namespace filter_ctrl1_bits {
        constexpr uint32_t APB_SARADC_FILTER_FACTOR1 = (3 << 26);  ///< Factor of saradc filter1
        constexpr uint32_t APB_SARADC_FILTER_FACTOR0 = (3 << 29);  ///< Factor of saradc filter0
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t SARADC_XPD_WAIT = (8 << 0);  ///< saradc_xpd_wait
        constexpr uint32_t SARADC_RSTB_WAIT = (8 << 8);  ///< saradc_rstb_wait
        constexpr uint32_t SARADC_STANDBY_WAIT = (8 << 16);  ///< saradc_standby_wait
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SARADC_SAR1_STATUS = (32 << 0);  ///< saradc1 status about data and channel
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SARADC_SAR2_STATUS = (32 << 0);  ///< saradc2 status about data and channel
    }

    /// SAR_PATT_TAB1 Register bits
    namespace sar_patt_tab1_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// SAR_PATT_TAB2 Register bits
    namespace sar_patt_tab2_bits {
        constexpr uint32_t SARADC_SAR_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item one byte)
    }

    /// ONETIME_SAMPLE Register bits
    namespace onetime_sample_bits {
        constexpr uint32_t SARADC_ONETIME_ATTEN = (2 << 23);  ///< configure onetime atten
        constexpr uint32_t SARADC_ONETIME_CHANNEL = (4 << 25);  ///< configure onetime channel
        constexpr uint32_t SARADC_ONETIME_START = (1U << 29);  ///< trigger adc onetime sample
        constexpr uint32_t SARADC2_ONETIME_SAMPLE = (1U << 30);  ///< enable adc2 onetime sample
        constexpr uint32_t SARADC1_ONETIME_SAMPLE = (1U << 31);  ///< enable adc1 onetime sample
    }

    /// ARB_CTRL Register bits
    namespace arb_ctrl_bits {
        constexpr uint32_t ADC_ARB_APB_FORCE = (1U << 2);  ///< adc2 arbiter force to enableapb controller
        constexpr uint32_t ADC_ARB_RTC_FORCE = (1U << 3);  ///< adc2 arbiter force to enable rtc controller
        constexpr uint32_t ADC_ARB_WIFI_FORCE = (1U << 4);  ///< adc2 arbiter force to enable wifi controller
        constexpr uint32_t ADC_ARB_GRANT_FORCE = (1U << 5);  ///< adc2 arbiter force grant
        constexpr uint32_t ADC_ARB_APB_PRIORITY = (2 << 6);  ///< Set adc2 arbiterapb priority
        constexpr uint32_t ADC_ARB_RTC_PRIORITY = (2 << 8);  ///< Set adc2 arbiter rtc priority
        constexpr uint32_t ADC_ARB_WIFI_PRIORITY = (2 << 10);  ///< Set adc2 arbiter wifi priority
        constexpr uint32_t ADC_ARB_FIX_PRIORITY = (1U << 12);  ///< adc2 arbiter uses fixed priority
    }

    /// FILTER_CTRL0 Register bits
    namespace filter_ctrl0_bits {
        constexpr uint32_t APB_SARADC_FILTER_CHANNEL1 = (4 << 18);  ///< configure filter1 to adc channel
        constexpr uint32_t APB_SARADC_FILTER_CHANNEL0 = (4 << 22);  ///< configure filter0 to adc channel
        constexpr uint32_t APB_SARADC_FILTER_RESET = (1U << 31);  ///< enable apb_adc1_filter
    }

    /// SAR1DATA_STATUS Register bits
    namespace sar1data_status_bits {
        constexpr uint32_t APB_SARADC1_DATA = (17 << 0);  ///< saradc1 data
    }

    /// SAR2DATA_STATUS Register bits
    namespace sar2data_status_bits {
        constexpr uint32_t APB_SARADC2_DATA = (17 << 0);  ///< saradc2 data
    }

    /// THRES0_CTRL Register bits
    namespace thres0_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES0_CHANNEL = (4 << 0);  ///< configure thres0 to adc channel
        constexpr uint32_t APB_SARADC_THRES0_HIGH = (13 << 5);  ///< saradc thres0 monitor thres
        constexpr uint32_t APB_SARADC_THRES0_LOW = (13 << 18);  ///< saradc thres0 monitor thres
    }

    /// THRES1_CTRL Register bits
    namespace thres1_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES1_CHANNEL = (4 << 0);  ///< configure thres1 to adc channel
        constexpr uint32_t APB_SARADC_THRES1_HIGH = (13 << 5);  ///< saradc thres1 monitor thres
        constexpr uint32_t APB_SARADC_THRES1_LOW = (13 << 18);  ///< saradc thres1 monitor thres
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t APB_SARADC_THRES_ALL_EN = (1U << 27);  ///< enable thres to all channel
        constexpr uint32_t APB_SARADC_THRES1_EN = (1U << 30);  ///< enable thres1
        constexpr uint32_t APB_SARADC_THRES0_EN = (1U << 31);  ///< enable thres0
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t APB_SARADC_TSENS_INT_ENA = (1U << 25);  ///< tsens low interrupt enable
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_ENA = (1U << 26);  ///< saradc thres1 low interrupt enable
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_ENA = (1U << 27);  ///< saradc thres0 low interrupt enable
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_ENA = (1U << 28);  ///< saradc thres1 high interrupt enable
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_ENA = (1U << 29);  ///< saradc thres0 high interrupt enable
        constexpr uint32_t APB_SARADC2_DONE_INT_ENA = (1U << 30);  ///< saradc2 done interrupt enable
        constexpr uint32_t APB_SARADC1_DONE_INT_ENA = (1U << 31);  ///< saradc1 done interrupt enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t APB_SARADC_TSENS_INT_RAW = (1U << 25);  ///< saradc tsens interrupt raw
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_RAW = (1U << 26);  ///< saradc thres1 low interrupt raw
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_RAW = (1U << 27);  ///< saradc thres0 low interrupt raw
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_RAW = (1U << 28);  ///< saradc thres1 high interrupt raw
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_RAW = (1U << 29);  ///< saradc thres0 high interrupt raw
        constexpr uint32_t APB_SARADC2_DONE_INT_RAW = (1U << 30);  ///< saradc2 done interrupt raw
        constexpr uint32_t APB_SARADC1_DONE_INT_RAW = (1U << 31);  ///< saradc1 done interrupt raw
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t APB_SARADC_TSENS_INT_ST = (1U << 25);  ///< saradc tsens interrupt state
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_ST = (1U << 26);  ///< saradc thres1 low interrupt state
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_ST = (1U << 27);  ///< saradc thres0 low interrupt state
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_ST = (1U << 28);  ///< saradc thres1 high interrupt state
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_ST = (1U << 29);  ///< saradc thres0 high interrupt state
        constexpr uint32_t APB_SARADC2_DONE_INT_ST = (1U << 30);  ///< saradc2 done interrupt state
        constexpr uint32_t APB_SARADC1_DONE_INT_ST = (1U << 31);  ///< saradc1 done interrupt state
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t APB_SARADC_TSENS_INT_CLR = (1U << 25);  ///< saradc tsens interrupt clear
        constexpr uint32_t APB_SARADC_THRES1_LOW_INT_CLR = (1U << 26);  ///< saradc thres1 low interrupt clear
        constexpr uint32_t APB_SARADC_THRES0_LOW_INT_CLR = (1U << 27);  ///< saradc thres0 low interrupt clear
        constexpr uint32_t APB_SARADC_THRES1_HIGH_INT_CLR = (1U << 28);  ///< saradc thres1 high interrupt clear
        constexpr uint32_t APB_SARADC_THRES0_HIGH_INT_CLR = (1U << 29);  ///< saradc thres0 high interrupt clear
        constexpr uint32_t APB_SARADC2_DONE_INT_CLR = (1U << 30);  ///< saradc2 done interrupt clear
        constexpr uint32_t APB_SARADC1_DONE_INT_CLR = (1U << 31);  ///< saradc1 done interrupt clear
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< the dma_in_suc_eof gen when sample cnt = spi_eof_num
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< reset_apb_adc_state
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< enable apb_adc use spi_dma
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value
        constexpr uint32_t CLK_EN = (1U << 20);  ///< reg clk en
        constexpr uint32_t CLK_SEL = (2 << 21);  ///< Set this bit to enable clk_apll
    }

    /// APB_TSENS_CTRL Register bits
    namespace apb_tsens_ctrl_bits {
        constexpr uint32_t TSENS_OUT = (8 << 0);  ///< temperature sensor data out
        constexpr uint32_t TSENS_IN_INV = (1U << 13);  ///< invert temperature sensor data
        constexpr uint32_t TSENS_CLK_DIV = (8 << 14);  ///< temperature sensor clock divider
        constexpr uint32_t TSENS_PU = (1U << 22);  ///< temperature sensor power up
    }

    /// TSENS_CTRL2 Register bits
    namespace tsens_ctrl2_bits {
        constexpr uint32_t TSENS_XPD_WAIT = (12 << 0);  ///< the time that power up tsens need wait
        constexpr uint32_t TSENS_XPD_FORCE = (2 << 12);  ///< force power up tsens
        constexpr uint32_t TSENS_CLK_INV = (1U << 14);  ///< inv tsens clk
        constexpr uint32_t TSENS_CLK_SEL = (1U << 15);  ///< tsens clk select
    }

    /// CALI Register bits
    namespace cali_bits {
        constexpr uint32_t APB_SARADC_CALI_CFG = (17 << 0);  ///< saradc cali factor
    }

    /// APB_TSENS_WAKE Register bits
    namespace apb_tsens_wake_bits {
        constexpr uint32_t WAKEUP_TH_LOW = (8 << 0);  ///< reg_wakeup_th_low
        constexpr uint32_t WAKEUP_TH_HIGH = (8 << 8);  ///< reg_wakeup_th_high
        constexpr uint32_t WAKEUP_OVER_UPPER_TH = (1U << 16);  ///< reg_wakeup_over_upper_th
        constexpr uint32_t WAKEUP_MODE = (1U << 17);  ///< reg_wakeup_mode
        constexpr uint32_t WAKEUP_EN = (1U << 18);  ///< reg_wakeup_en
    }

    /// APB_TSENS_SAMPLE Register bits
    namespace apb_tsens_sample_bits {
        constexpr uint32_t TSENS_SAMPLE_RATE = (16 << 0);  ///< HW sample rate
        constexpr uint32_t TSENS_SAMPLE_EN = (1U << 16);  ///< HW sample en
    }

    /// CTRL_DATE Register bits
    namespace ctrl_date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< version
    }

}

// ============================================================================
// ASSIST Peripheral
// ============================================================================

namespace assist {
    /// Base addresses
    constexpr uint32_t ASSIST_DEBUG_BASE = 0x600C2000;

    /// ASSIST Register structure
    struct Registers {
        volatile uint32_t CORE_0_MONTR_ENA;  ///< Offset: 0x00 - core0 monitor enable configuration register
        volatile uint32_t CORE_0_INTR_RAW;  ///< Offset: 0x04 - core0 monitor interrupt status register
        volatile uint32_t CORE_0_INTR_ENA;  ///< Offset: 0x08 - core0 monitor interrupt enable register
        volatile uint32_t CORE_0_INTR_CLR;  ///< Offset: 0x0C - core0 monitor interrupt clr register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MIN;  ///< Offset: 0x10 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MAX;  ///< Offset: 0x14 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MIN;  ///< Offset: 0x18 - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MAX;  ///< Offset: 0x1C - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MIN;  ///< Offset: 0x20 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MAX;  ///< Offset: 0x24 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MIN;  ///< Offset: 0x28 - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MAX;  ///< Offset: 0x2C - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PC;  ///< Offset: 0x30 - core0 area pc status register
        volatile uint32_t CORE_0_AREA_SP;  ///< Offset: 0x34 - core0 area sp status register
        volatile uint32_t CORE_0_SP_MIN;  ///< Offset: 0x38 - stack min value
        volatile uint32_t CORE_0_SP_MAX;  ///< Offset: 0x3C - stack max value
        volatile uint32_t CORE_0_SP_PC;  ///< Offset: 0x40 - stack monitor pc status register
        volatile uint32_t CORE_0_RCD_EN;  ///< Offset: 0x44 - record enable configuration register
        volatile uint32_t CORE_0_RCD_PDEBUGPC;  ///< Offset: 0x48 - record status regsiter
        volatile uint32_t CORE_0_RCD_PDEBUGSP;  ///< Offset: 0x4C - record status regsiter
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x50 - exception monitor status register0
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x54 - exception monitor status register1
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x58 - exception monitor status register2
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x5C - exception monitor status register3
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0x60 - exception monitor status register4
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0x64 - exception monitor status register5
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x68 - exception monitor status register6
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x6C - exception monitor status register7
        volatile uint32_t C0RE_0_LASTPC_BEFORE_EXCEPTION;  ///< Offset: 0x70 - cpu status register
        volatile uint32_t C0RE_0_DEBUG_MODE;  ///< Offset: 0x74 - cpu status register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x78 - clock register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - version register
    };

    /// Peripheral instances
    inline Registers* ASSIST_DEBUG = reinterpret_cast<Registers*>(ASSIST_DEBUG_BASE);

    // Bit definitions
    /// CORE_0_MONTR_ENA Register bits
    namespace core_0_montr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< Core0 dram0 area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< Core0 dram0 area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< Core0 dram0 area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< Core0 dram0 area1 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_ENA = (1U << 4);  ///< Core0 PIF area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_ENA = (1U << 5);  ///< Core0 PIF area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_ENA = (1U << 6);  ///< Core0 PIF area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_ENA = (1U << 7);  ///< Core0 PIF area1 write monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_ENA = (1U << 8);  ///< Core0 stackpoint underflow monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_ENA = (1U << 9);  ///< Core0 stackpoint overflow monitor enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< IBUS busy monitor enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< DBUS busy monitor enbale
    }

    /// CORE_0_INTR_RAW Register bits
    namespace core_0_intr_raw_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_RAW = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_RAW = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_RAW = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_RAW = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RAW = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RAW = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt status
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< IBUS busy monitor interrupt status
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< DBUS busy monitor initerrupt status
    }

    /// CORE_0_INTR_ENA Register bits
    namespace core_0_intr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_INTR_ENA = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_INTR_ENA = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_INTR_ENA = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_INTR_ENA = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_INTR_ENA = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_INTR_ENA = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_INTR_ENA = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_INTR_ENA = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_INTR_ENA = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_INTR_ENA = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 10);  ///< IBUS busy monitor interrupt enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 11);  ///< DBUS busy monitor interrupt enbale
    }

    /// CORE_0_INTR_CLR Register bits
    namespace core_0_intr_clr_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_CLR = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_CLR = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_CLR = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_CLR = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MIN_CLR = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MAX_CLR = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt clr
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< IBUS busy monitor interrupt clr
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< DBUS busy monitor interrupt clr
    }

    /// CORE_0_AREA_DRAM0_0_MIN Register bits
    namespace core_0_area_dram0_0_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MIN = (32 << 0);  ///< Core0 dram0 region0 start addr
    }

    /// CORE_0_AREA_DRAM0_0_MAX Register bits
    namespace core_0_area_dram0_0_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MAX = (32 << 0);  ///< Core0 dram0 region0 end addr
    }

    /// CORE_0_AREA_DRAM0_1_MIN Register bits
    namespace core_0_area_dram0_1_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MIN = (32 << 0);  ///< Core0 dram0 region1 start addr
    }

    /// CORE_0_AREA_DRAM0_1_MAX Register bits
    namespace core_0_area_dram0_1_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MAX = (32 << 0);  ///< Core0 dram0 region1 end addr
    }

    /// CORE_0_AREA_PIF_0_MIN Register bits
    namespace core_0_area_pif_0_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MIN = (32 << 0);  ///< Core0 PIF region0 start addr
    }

    /// CORE_0_AREA_PIF_0_MAX Register bits
    namespace core_0_area_pif_0_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MAX = (32 << 0);  ///< Core0 PIF region0 end addr
    }

    /// CORE_0_AREA_PIF_1_MIN Register bits
    namespace core_0_area_pif_1_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MIN = (32 << 0);  ///< Core0 PIF region1 start addr
    }

    /// CORE_0_AREA_PIF_1_MAX Register bits
    namespace core_0_area_pif_1_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MAX = (32 << 0);  ///< Core0 PIF region1 end addr
    }

    /// CORE_0_AREA_PC Register bits
    namespace core_0_area_pc_bits {
        constexpr uint32_t CORE_0_AREA_PC = (32 << 0);  ///< the stackpointer when first touch region monitor interrupt
    }

    /// CORE_0_AREA_SP Register bits
    namespace core_0_area_sp_bits {
        constexpr uint32_t CORE_0_AREA_SP = (32 << 0);  ///< the PC when first touch region monitor interrupt
    }

    /// CORE_0_SP_MIN Register bits
    namespace core_0_sp_min_bits {
        constexpr uint32_t CORE_0_SP_MIN = (32 << 0);  ///< core0 sp region configuration regsiter
    }

    /// CORE_0_SP_MAX Register bits
    namespace core_0_sp_max_bits {
        constexpr uint32_t CORE_0_SP_MAX = (32 << 0);  ///< core0 sp pc status register
    }

    /// CORE_0_SP_PC Register bits
    namespace core_0_sp_pc_bits {
        constexpr uint32_t CORE_0_SP_PC = (32 << 0);  ///< This regsiter stores the PC when trigger stack monitor.
    }

    /// CORE_0_RCD_EN Register bits
    namespace core_0_rcd_en_bits {
        constexpr uint32_t CORE_0_RCD_RECORDEN = (1U << 0);  ///< Set 1 to enable record PC
        constexpr uint32_t CORE_0_RCD_PDEBUGEN = (1U << 1);  ///< Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
    }

    /// CORE_0_RCD_PDEBUGPC Register bits
    namespace core_0_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGPC = (32 << 0);  ///< recorded PC
    }

    /// CORE_0_RCD_PDEBUGSP Register bits
    namespace core_0_rcd_pdebugsp_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGSP = (32 << 0);  ///< recorded sp
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_0
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_0
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_0_dram0_recording_wr_0
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_0 = (4 << 25);  ///< reg_core_0_dram0_recording_byteen_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_0_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_1
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_0_dram0_recording_wr_1
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_1 = (4 << 25);  ///< reg_core_0_dram0_recording_byteen_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_0_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_1
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_x_iram0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_0
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_x_iram0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_1
    }

    /// C0RE_0_LASTPC_BEFORE_EXCEPTION Register bits
    namespace c0re_0_lastpc_before_exception_bits {
        constexpr uint32_t CORE_0_LASTPC_BEFORE_EXC = (32 << 0);  ///< cpu's lastpc before exception
    }

    /// C0RE_0_DEBUG_MODE Register bits
    namespace c0re_0_debug_mode_bits {
        constexpr uint32_t CORE_0_DEBUG_MODE = (1U << 0);  ///< cpu debug mode status, 1 means cpu enter debug mode.
        constexpr uint32_t CORE_0_DEBUG_MODULE_ACTIVE = (1U << 1);  ///< cpu debug_module active status
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Set 1 force on the clock gate
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t ASSIST_DEBUG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x60080000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t IN_INT_RAW_CH%s;  ///< Offset: 0x00 - Raw status interrupt of channel 0
        volatile uint32_t IN_INT_ST_CH%s;  ///< Offset: 0x04 - Masked interrupt of channel 0
        volatile uint32_t IN_INT_ENA_CH%s;  ///< Offset: 0x08 - Interrupt enable bits of channel 0
        volatile uint32_t IN_INT_CLR_CH%s;  ///< Offset: 0x0C - Interrupt clear bits of channel 0
        volatile uint32_t OUT_INT_RAW_CH%s;  ///< Offset: 0x30 - Raw status interrupt of channel 0
        volatile uint32_t OUT_INT_ST_CH%s;  ///< Offset: 0x34 - Masked interrupt of channel 0
        volatile uint32_t OUT_INT_ENA_CH%s;  ///< Offset: 0x38 - Interrupt enable bits of channel 0
        volatile uint32_t OUT_INT_CLR_CH%s;  ///< Offset: 0x3C - Interrupt clear bits of channel 0
        volatile uint32_t AHB_TEST;  ///< Offset: 0x60 - reserved
        volatile uint32_t MISC_CONF;  ///< Offset: 0x64 - MISC register
        volatile uint32_t DATE;  ///< Offset: 0x68 - Version control register
        volatile uint32_t IN_CONF0_CH%s;  ///< Offset: 0x70 - Configure 0 register of Rx channel 0
        volatile uint32_t IN_CONF1_CH%s;  ///< Offset: 0x74 - Configure 1 register of Rx channel 0
        volatile uint32_t INFIFO_STATUS_CH%s;  ///< Offset: 0x78 - Receive FIFO status of Rx channel 0
        volatile uint32_t IN_POP_CH%s;  ///< Offset: 0x7C - Pop control register of Rx channel 0
        volatile uint32_t IN_LINK_CH%s;  ///< Offset: 0x80 - Link descriptor configure and control register of Rx channel 0
        volatile uint32_t IN_STATE_CH%s;  ///< Offset: 0x84 - Receive status of Rx channel 0
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH%s;  ///< Offset: 0x88 - Inlink descriptor address when EOF occurs of Rx channel 0
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH%s;  ///< Offset: 0x8C - Inlink descriptor address when errors occur of Rx channel 0
        volatile uint32_t IN_DSCR_CH%s;  ///< Offset: 0x90 - Current inlink descriptor address of Rx channel 0
        volatile uint32_t IN_DSCR_BF0_CH%s;  ///< Offset: 0x94 - The last inlink descriptor address of Rx channel 0
        volatile uint32_t IN_DSCR_BF1_CH%s;  ///< Offset: 0x98 - The second-to-last inlink descriptor address of Rx channel 0
        volatile uint32_t IN_PRI_CH%s;  ///< Offset: 0x9C - Priority register of Rx channel 0
        volatile uint32_t IN_PERI_SEL_CH%s;  ///< Offset: 0xA0 - Peripheral selection of Rx channel 0
        volatile uint32_t OUT_CONF1_CH%s;  ///< Offset: 0xD4 - Configure 1 register of Tx channel 0
        volatile uint32_t OUTFIFO_STATUS_CH%s;  ///< Offset: 0xD8 - Transmit FIFO status of Tx channel 0
        volatile uint32_t OUT_PUSH_CH%s;  ///< Offset: 0xDC - Push control register of Rx channel 0
        volatile uint32_t OUT_LINK_CH%s;  ///< Offset: 0xE0 - Link descriptor configure and control register of Tx channel 0
        volatile uint32_t OUT_STATE_CH%s;  ///< Offset: 0xE4 - Transmit status of Tx channel 0
        volatile uint32_t OUT_EOF_DES_ADDR_CH%s;  ///< Offset: 0xE8 - Outlink descriptor address when EOF occurs of Tx channel 0
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH%s;  ///< Offset: 0xEC - The last outlink descriptor address when EOF occurs of...
        volatile uint32_t OUT_DSCR_CH%s;  ///< Offset: 0xF0 - Current inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_DSCR_BF0_CH%s;  ///< Offset: 0xF4 - The last inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_DSCR_BF1_CH%s;  ///< Offset: 0xF8 - The second-to-last inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_PRI_CH%s;  ///< Offset: 0xFC - Priority register of Tx channel 0.
        volatile uint32_t OUT_PERI_SEL_CH%s;  ///< Offset: 0x100 - Peripheral selection of Tx channel 0
        volatile uint32_t OUT_CONF0_CH%s;  ///< Offset: 0x190 - Configure 0 register of Tx channel 1
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// IN_INT_RAW_CH%s Register bits
    namespace in_int_raw_ch%s_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
        constexpr uint32_t INFIFO_OVF = (1U << 5);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF = (1U << 6);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
    }

    /// IN_INT_ST_CH%s Register bits
    namespace in_int_st_ch%s_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 5);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 6);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// IN_INT_ENA_CH%s Register bits
    namespace in_int_ena_ch%s_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 5);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 6);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// IN_INT_CLR_CH%s Register bits
    namespace in_int_clr_ch%s_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF = (1U << 5);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF = (1U << 6);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_RAW_CH%s Register bits
    namespace out_int_raw_ch%s_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
        constexpr uint32_t OUTFIFO_OVF = (1U << 4);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF = (1U << 5);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
    }

    /// OUT_INT_ST_CH%s Register bits
    namespace out_int_st_ch%s_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 4);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 5);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_ENA_CH%s Register bits
    namespace out_int_ena_ch%s_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 4);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 5);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_CLR_CH%s Register bits
    namespace out_int_clr_ch%s_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF = (1U << 4);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF = (1U << 5);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< reserved
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< reserved
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t AHBM_RST_INTER = (1U << 0);  ///< Set this bit then clear this bit to reset the internal ahb FSM.
        constexpr uint32_t ARB_PRI_DIS = (1U << 2);  ///< Set this bit to disable priority arbitration function.
        constexpr uint32_t CLK_EN = (1U << 3);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

    /// IN_CONF0_CH%s Register bits
    namespace in_conf0_ch%s_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
        constexpr uint32_t IN_ETM_EN = (1U << 5);  ///< Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
    }

    /// IN_CONF1_CH%s Register bits
    namespace in_conf1_ch%s_bits {
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH%s Register bits
    namespace infifo_status_ch%s_bits {
        constexpr uint32_t INFIFO_FULL = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
        constexpr uint32_t IN_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH%s Register bits
    namespace in_pop_ch%s_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH%s Register bits
    namespace in_link_ch%s_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH%s Register bits
    namespace in_state_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH%s Register bits
    namespace in_suc_eof_des_addr_ch%s_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH%s Register bits
    namespace in_err_eof_des_addr_ch%s_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH%s Register bits
    namespace in_dscr_ch%s_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH%s Register bits
    namespace in_dscr_bf0_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH%s Register bits
    namespace in_dscr_bf1_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH%s Register bits
    namespace in_pri_ch%s_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 0. The larger of the value the higher of the priority.
    }

    /// IN_PERI_SEL_CH%s Register bits
    namespace in_peri_sel_ch%s_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
    }

    /// OUT_CONF1_CH%s Register bits
    namespace out_conf1_ch%s_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH%s Register bits
    namespace outfifo_status_ch%s_bits {
        constexpr uint32_t OUTFIFO_FULL = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUT_REMAIN_UNDER_1B = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH%s Register bits
    namespace out_push_ch%s_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH%s Register bits
    namespace out_link_ch%s_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH%s Register bits
    namespace out_state_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH%s Register bits
    namespace out_eof_des_addr_ch%s_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH%s Register bits
    namespace out_eof_bfr_des_addr_ch%s_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH%s Register bits
    namespace out_dscr_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH%s Register bits
    namespace out_dscr_bf0_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH%s Register bits
    namespace out_dscr_bf1_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH%s Register bits
    namespace out_pri_ch%s_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 0. The larger of the value the higher of the priority.
    }

    /// OUT_PERI_SEL_CH%s Register bits
    namespace out_peri_sel_ch%s_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
    }

    /// OUT_CONF0_CH%s Register bits
    namespace out_conf0_ch%s_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
        constexpr uint32_t OUT_ETM_EN = (1U << 6);  ///< Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x6008C000;

    /// DS Register structure
    struct Registers {
        volatile uint32_t Y_MEM[%s];  ///< Offset: 0x00 - memory that stores Y
        volatile uint32_t M_MEM[%s];  ///< Offset: 0x200 - memory that stores M
        volatile uint32_t RB_MEM[%s];  ///< Offset: 0x400 - memory that stores Rb
        volatile uint32_t BOX_MEM[%s];  ///< Offset: 0x600 - memory that stores BOX
        volatile uint32_t IV_MEM[%s];  ///< Offset: 0x630 - memory that stores IV
        volatile uint32_t X_MEM[%s];  ///< Offset: 0x800 - memory that stores X
        volatile uint32_t Z_MEM[%s];  ///< Offset: 0xA00 - memory that stores Z
        volatile uint32_t SET_START;  ///< Offset: 0xE00 - DS start control register
        volatile uint32_t SET_CONTINUE;  ///< Offset: 0xE04 - DS continue control register
        volatile uint32_t SET_FINISH;  ///< Offset: 0xE08 - DS finish control register
        volatile uint32_t QUERY_BUSY;  ///< Offset: 0xE0C - DS query busy register
        volatile uint32_t QUERY_KEY_WRONG;  ///< Offset: 0xE10 - DS query key-wrong counter register
        volatile uint32_t QUERY_CHECK;  ///< Offset: 0xE14 - DS query check result register
        volatile uint32_t DATE;  ///< Offset: 0xE20 - DS version control register
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// SET_START Register bits
    namespace set_start_bits {
        constexpr uint32_t SET_START = (1U << 0);  ///< set this bit to start DS operation.
    }

    /// SET_CONTINUE Register bits
    namespace set_continue_bits {
        constexpr uint32_t SET_CONTINUE = (1U << 0);  ///< set this bit to continue DS operation.
    }

    /// SET_FINISH Register bits
    namespace set_finish_bits {
        constexpr uint32_t SET_FINISH = (1U << 0);  ///< Set this bit to finish DS process.
    }

    /// QUERY_BUSY Register bits
    namespace query_busy_bits {
        constexpr uint32_t QUERY_BUSY = (1U << 0);  ///< digital signature state. 1'b0: idle, 1'b1: busy
    }

    /// QUERY_KEY_WRONG Register bits
    namespace query_key_wrong_bits {
        constexpr uint32_t QUERY_KEY_WRONG = (4 << 0);  ///< digital signature key wrong counter
    }

    /// QUERY_CHECK Register bits
    namespace query_check_bits {
        constexpr uint32_t MD_ERROR = (1U << 0);  ///< MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
        constexpr uint32_t PADDING_BAD = (1U << 1);  ///< padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< ds version information
    }

}

// ============================================================================
// ECC Peripheral
// ============================================================================

namespace ecc {
    /// Base addresses
    constexpr uint32_t ECC_BASE = 0x6008B000;

    /// ECC Register structure
    struct Registers {
        volatile uint32_t MULT_INT_RAW;  ///< Offset: 0x0C - ECC interrupt raw register, valid in level.
        volatile uint32_t MULT_INT_ST;  ///< Offset: 0x10 - ECC interrupt status register.
        volatile uint32_t MULT_INT_ENA;  ///< Offset: 0x14 - ECC interrupt enable register.
        volatile uint32_t MULT_INT_CLR;  ///< Offset: 0x18 - ECC interrupt clear register.
        volatile uint32_t MULT_CONF;  ///< Offset: 0x1C - ECC configure register
        volatile uint32_t MULT_DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t K_MEM[%s];  ///< Offset: 0x100 - The memory that stores k.
        volatile uint32_t PX_MEM[%s];  ///< Offset: 0x120 - The memory that stores Px.
        volatile uint32_t PY_MEM[%s];  ///< Offset: 0x140 - The memory that stores Py.
        volatile uint32_t QX_MEM%s;  ///< Offset: 0x160 - The memory that stores Qx
        volatile uint32_t QY_MEM%s;  ///< Offset: 0x180 - The memory that stores Qy
        volatile uint32_t QZ_MEM%s;  ///< Offset: 0x1A0 - The memory that stores Qz
    };

    /// Peripheral instances
    inline Registers* ECC = reinterpret_cast<Registers*>(ECC_BASE);

    // Bit definitions
    /// MULT_INT_RAW Register bits
    namespace mult_int_raw_bits {
        constexpr uint32_t CALC_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_ST Register bits
    namespace mult_int_st_bits {
        constexpr uint32_t CALC_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_ENA Register bits
    namespace mult_int_ena_bits {
        constexpr uint32_t CALC_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_CLR Register bits
    namespace mult_int_clr_bits {
        constexpr uint32_t CALC_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the ecc_calc_done_int interrupt
    }

    /// MULT_CONF Register bits
    namespace mult_conf_bits {
        constexpr uint32_t START = (1U << 0);  ///< Write 1 to start caculation of ECC Accelerator. This bit will be self-cleared after the caculatrion is done.
        constexpr uint32_t RESET = (1U << 1);  ///< Write 1 to reset ECC Accelerator.
        constexpr uint32_t KEY_LENGTH = (1U << 2);  ///< The key length mode bit of ECC Accelerator. 0: P-192. 1: P-256.
        constexpr uint32_t MOD_BASE = (1U << 3);  ///< The mod base of mod operation, only valid in work_mode 8-11. 0: n(order of curve). 1: p(mod base of curve)
        constexpr uint32_t WORK_MODE = (4 << 4);  ///< The work mode bits of ECC Accelerator. 0: Point Mult Mode. 1: Reserved. 2: Point verification mode. 3: Point Verif+mult mode. 4: Jacobian Point Mult Mode. 5: Point Add Mode. 6: Jacobian Point Verification Mode. 7: Point Verif + Jacobian Mult Mode. 8: mod addition. 9. mod substraction. 10: mod multiplication. 11: mod division.
        constexpr uint32_t SECURITY_MODE = (1U << 8);  ///< Reserved
        constexpr uint32_t VERIFICATION_RESULT = (1U << 29);  ///< The verification result bit of ECC Accelerator, only valid when calculation is done.
        constexpr uint32_t CLK_EN = (1U << 30);  ///< Write 1 to force on register clock gate.
        constexpr uint32_t MEM_CLOCK_GATE_FORCE_ON = (1U << 31);  ///< ECC memory clock gate force on register
    }

    /// MULT_DATE Register bits
    namespace mult_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< ECC mult version control register
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x600B0800;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA0;  ///< Offset: 0x00 - Register 0 that stores data to be programmed.
        volatile uint32_t PGM_DATA1;  ///< Offset: 0x04 - Register 1 that stores data to be programmed.
        volatile uint32_t PGM_DATA2;  ///< Offset: 0x08 - Register 2 that stores data to be programmed.
        volatile uint32_t PGM_DATA3;  ///< Offset: 0x0C - Register 3 that stores data to be programmed.
        volatile uint32_t PGM_DATA4;  ///< Offset: 0x10 - Register 4 that stores data to be programmed.
        volatile uint32_t PGM_DATA5;  ///< Offset: 0x14 - Register 5 that stores data to be programmed.
        volatile uint32_t PGM_DATA6;  ///< Offset: 0x18 - Register 6 that stores data to be programmed.
        volatile uint32_t PGM_DATA7;  ///< Offset: 0x1C - Register 7 that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE0;  ///< Offset: 0x20 - Register 0 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE1;  ///< Offset: 0x24 - Register 1 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE2;  ///< Offset: 0x28 - Register 2 that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - BLOCK0 data register 0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - BLOCK0 data register 1.
        volatile uint32_t RD_REPEAT_DATA1;  ///< Offset: 0x34 - BLOCK0 data register 2.
        volatile uint32_t RD_REPEAT_DATA2;  ///< Offset: 0x38 - BLOCK0 data register 3.
        volatile uint32_t RD_REPEAT_DATA3;  ///< Offset: 0x3C - BLOCK0 data register 4.
        volatile uint32_t RD_REPEAT_DATA4;  ///< Offset: 0x40 - BLOCK0 data register 5.
        volatile uint32_t RD_MAC_SYS_0;  ///< Offset: 0x44 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_1;  ///< Offset: 0x48 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_2;  ///< Offset: 0x4C - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_3;  ///< Offset: 0x50 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_4;  ///< Offset: 0x54 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_5;  ///< Offset: 0x58 - BLOCK1 data register $n.
        volatile uint32_t RD_SYS_PART1_DATA0;  ///< Offset: 0x5C - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA1;  ///< Offset: 0x60 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA2;  ///< Offset: 0x64 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA3;  ///< Offset: 0x68 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA4;  ///< Offset: 0x6C - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA5;  ///< Offset: 0x70 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA6;  ///< Offset: 0x74 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA7;  ///< Offset: 0x78 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_USR_DATA0;  ///< Offset: 0x7C - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA1;  ///< Offset: 0x80 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA2;  ///< Offset: 0x84 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA3;  ///< Offset: 0x88 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA4;  ///< Offset: 0x8C - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA5;  ///< Offset: 0x90 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA6;  ///< Offset: 0x94 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA7;  ///< Offset: 0x98 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_KEY0_DATA0;  ///< Offset: 0x9C - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA1;  ///< Offset: 0xA0 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA2;  ///< Offset: 0xA4 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA3;  ///< Offset: 0xA8 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA4;  ///< Offset: 0xAC - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA5;  ///< Offset: 0xB0 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA6;  ///< Offset: 0xB4 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA7;  ///< Offset: 0xB8 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY1_DATA0;  ///< Offset: 0xBC - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA1;  ///< Offset: 0xC0 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA2;  ///< Offset: 0xC4 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA3;  ///< Offset: 0xC8 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA4;  ///< Offset: 0xCC - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA5;  ///< Offset: 0xD0 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA6;  ///< Offset: 0xD4 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA7;  ///< Offset: 0xD8 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY2_DATA0;  ///< Offset: 0xDC - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA1;  ///< Offset: 0xE0 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA2;  ///< Offset: 0xE4 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA3;  ///< Offset: 0xE8 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA4;  ///< Offset: 0xEC - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA5;  ///< Offset: 0xF0 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA6;  ///< Offset: 0xF4 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA7;  ///< Offset: 0xF8 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY3_DATA0;  ///< Offset: 0xFC - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA1;  ///< Offset: 0x100 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA2;  ///< Offset: 0x104 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA3;  ///< Offset: 0x108 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA4;  ///< Offset: 0x10C - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA5;  ///< Offset: 0x110 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA6;  ///< Offset: 0x114 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA7;  ///< Offset: 0x118 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY4_DATA0;  ///< Offset: 0x11C - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA1;  ///< Offset: 0x120 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA2;  ///< Offset: 0x124 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA3;  ///< Offset: 0x128 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA4;  ///< Offset: 0x12C - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA5;  ///< Offset: 0x130 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA6;  ///< Offset: 0x134 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA7;  ///< Offset: 0x138 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY5_DATA0;  ///< Offset: 0x13C - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA1;  ///< Offset: 0x140 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA2;  ///< Offset: 0x144 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA3;  ///< Offset: 0x148 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA4;  ///< Offset: 0x14C - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA5;  ///< Offset: 0x150 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA6;  ///< Offset: 0x154 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA7;  ///< Offset: 0x158 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA0;  ///< Offset: 0x15C - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA1;  ///< Offset: 0x160 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA2;  ///< Offset: 0x164 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA3;  ///< Offset: 0x168 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA4;  ///< Offset: 0x16C - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA5;  ///< Offset: 0x170 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA6;  ///< Offset: 0x174 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA7;  ///< Offset: 0x178 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_REPEAT_ERR0;  ///< Offset: 0x17C - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR1;  ///< Offset: 0x180 - Programming error record register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR2;  ///< Offset: 0x184 - Programming error record register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR3;  ///< Offset: 0x188 - Programming error record register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR4;  ///< Offset: 0x18C - Programming error record register 4 of BLOCK0.
        volatile uint32_t RD_RS_ERR0;  ///< Offset: 0x1C0 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t RD_RS_ERR1;  ///< Offset: 0x1C4 - Programming error record register 1 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x1C8 - eFuse clcok configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x1CC - eFuse operation mode configuraiton register
        volatile uint32_t STATUS;  ///< Offset: 0x1D0 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x1D4 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1D8 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x1DC - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x1E0 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x1E4 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x1E8 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x1EC - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x1F0 - Configurarion register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x1F4 - Configurarion register 2 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF0_RS_BYPASS;  ///< Offset: 0x1F8 - Configurarion register0 of eFuse programming time...
        volatile uint32_t DATE;  ///< Offset: 0x1FC - eFuse version register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA0 Register bits
    namespace pgm_data0_bits {
        constexpr uint32_t PGM_DATA_0 = (32 << 0);  ///< Configures the 0th 32-bit data to be programmed.
    }

    /// PGM_DATA1 Register bits
    namespace pgm_data1_bits {
        constexpr uint32_t PGM_DATA_1 = (32 << 0);  ///< Configures the 1st 32-bit data to be programmed.
    }

    /// PGM_DATA2 Register bits
    namespace pgm_data2_bits {
        constexpr uint32_t PGM_DATA_2 = (32 << 0);  ///< Configures the 2nd 32-bit data to be programmed.
    }

    /// PGM_DATA3 Register bits
    namespace pgm_data3_bits {
        constexpr uint32_t PGM_DATA_3 = (32 << 0);  ///< Configures the 3rd 32-bit data to be programmed.
    }

    /// PGM_DATA4 Register bits
    namespace pgm_data4_bits {
        constexpr uint32_t PGM_DATA_4 = (32 << 0);  ///< Configures the 4th 32-bit data to be programmed.
    }

    /// PGM_DATA5 Register bits
    namespace pgm_data5_bits {
        constexpr uint32_t PGM_DATA_5 = (32 << 0);  ///< Configures the 5th 32-bit data to be programmed.
    }

    /// PGM_DATA6 Register bits
    namespace pgm_data6_bits {
        constexpr uint32_t PGM_DATA_6 = (32 << 0);  ///< Configures the 6th 32-bit data to be programmed.
    }

    /// PGM_DATA7 Register bits
    namespace pgm_data7_bits {
        constexpr uint32_t PGM_DATA_7 = (32 << 0);  ///< Configures the 7th 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE0 Register bits
    namespace pgm_check_value0_bits {
        constexpr uint32_t PGM_RS_DATA_0 = (32 << 0);  ///< Configures the 0th 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE1 Register bits
    namespace pgm_check_value1_bits {
        constexpr uint32_t PGM_RS_DATA_1 = (32 << 0);  ///< Configures the 1st 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE2 Register bits
    namespace pgm_check_value2_bits {
        constexpr uint32_t PGM_RS_DATA_2 = (32 << 0);  ///< Configures the 2nd 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (32 << 0);  ///< Represents whether programming of individual eFuse memory bit is disabled or enabled. 1: Disabled. 0 Enabled.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (7 << 0);  ///< Represents whether reading of individual eFuse block(block4~block10) is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t RPT4_RESERVED0_4 = (1U << 7);  ///< Reserved.
        constexpr uint32_t DIS_ICACHE = (1U << 8);  ///< Represents whether icache is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_USB_JTAG = (1U << 9);  ///< Represents whether the function of usb switch to jtag is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t POWERGLITCH_EN = (1U << 10);  ///< Represents whether power glitch function is enabled. 1: enabled. 0: disabled.
        constexpr uint32_t DIS_USB_SERIAL_JTAG = (1U << 11);  ///< Represents whether USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_FORCE_DOWNLOAD = (1U << 12);  ///< Represents whether the function that forces chip into download mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t SPI_DOWNLOAD_MSPI_DIS = (1U << 13);  ///< Represents whether SPI0 controller during boot_mode_download is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_CAN = (1U << 14);  ///< Represents whether TWAI function is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t JTAG_SEL_ENABLE = (1U << 15);  ///< Represents whether the selection between usb_to_jtag and pad_to_jtag through strapping gpio15 when both EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are equal to 0 is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SOFT_DIS_JTAG = (3 << 16);  ///< Represents whether JTAG is disabled in soft way. Odd number: disabled. Even number: enabled.
        constexpr uint32_t DIS_PAD_JTAG = (1U << 19);  ///< Represents whether JTAG is disabled in the hard way(permanently). 1: disabled. 0: enabled.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 20);  ///< Represents whether flash encrypt function is disabled or enabled(except in SPI boot mode). 1: disabled. 0: enabled.
        constexpr uint32_t USB_DREFH = (2 << 21);  ///< Represents the single-end input threhold vrefh, 1.76 V to 2 V with step of 80 mV.
        constexpr uint32_t USB_DREFL = (2 << 23);  ///< Represents the single-end input threhold vrefl, 1.76 V to 2 V with step of 80 mV.
        constexpr uint32_t USB_EXCHG_PINS = (1U << 25);  ///< Represents whether the D+ and D- pins is exchanged. 1: exchanged. 0: not exchanged.
        constexpr uint32_t VDD_SPI_AS_GPIO = (1U << 26);  ///< Represents whether vdd spi pin is functioned as gpio. 1: functioned. 0: not functioned.
        constexpr uint32_t RPT4_RESERVED0_2 = (2 << 27);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED0_1 = (1U << 29);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED0_0 = (2 << 30);  ///< Reserved.
    }

    /// RD_REPEAT_DATA1 Register bits
    namespace rd_repeat_data1_bits {
        constexpr uint32_t RPT4_RESERVED1_1 = (16 << 0);  ///< Reserved.
        constexpr uint32_t WDT_DELAY_SEL = (2 << 16);  ///< Represents whether RTC watchdog timeout threshold is selected at startup. 1: selected. 0: not selected.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT = (3 << 18);  ///< Represents whether SPI boot encrypt/decrypt is disabled or enabled. Odd number of 1: enabled. Even number of 1: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0 = (1U << 21);  ///< Represents whether revoking first secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1 = (1U << 22);  ///< Represents whether revoking second secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2 = (1U << 23);  ///< Represents whether revoking third secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t KEY_PURPOSE_0 = (4 << 24);  ///< Represents the purpose of Key0.
        constexpr uint32_t KEY_PURPOSE_1 = (4 << 28);  ///< Represents the purpose of Key1.
    }

    /// RD_REPEAT_DATA2 Register bits
    namespace rd_repeat_data2_bits {
        constexpr uint32_t KEY_PURPOSE_2 = (4 << 0);  ///< Represents the purpose of Key2.
        constexpr uint32_t KEY_PURPOSE_3 = (4 << 4);  ///< Represents the purpose of Key3.
        constexpr uint32_t KEY_PURPOSE_4 = (4 << 8);  ///< Represents the purpose of Key4.
        constexpr uint32_t KEY_PURPOSE_5 = (4 << 12);  ///< Represents the purpose of Key5.
        constexpr uint32_t SEC_DPA_LEVEL = (2 << 16);  ///< Represents the spa secure level by configuring the clock random divide mode.
        constexpr uint32_t ECDSA_FORCE_USE_HARDWARE_K = (1U << 18);  ///< Represents whether hardware random number k is forced used in ESDCA. 1: force used. 0: not force used.
        constexpr uint32_t CRYPT_DPA_ENABLE = (1U << 19);  ///< Represents whether anti-dpa attack is enabled. 1:enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_EN = (1U << 20);  ///< Represents whether secure boot is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE = (1U << 21);  ///< Represents whether revoking aggressive secure boot is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t RPT4_RESERVED2_0 = (6 << 22);  ///< Reserved.
        constexpr uint32_t FLASH_TPUW = (4 << 28);  ///< Represents the flash waiting time after power-up, in unit of ms. When the value less than 15, the waiting time is the programmed value. Otherwise, the waiting time is 2 times the programmed value.
    }

    /// RD_REPEAT_DATA3 Register bits
    namespace rd_repeat_data3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 0);  ///< Represents whether Download mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_DIRECT_BOOT = (1U << 1);  ///< Represents whether direct boot mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_USB_PRINT = (1U << 2);  ///< Represents whether print from USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t RPT4_RESERVED3_5 = (1U << 3);  ///< Reserved.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE = (1U << 4);  ///< Represents whether the USB-Serial-JTAG download function is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 5);  ///< Represents whether security download is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 6);  ///< Represents the type of UART printing. 00: force enable printing. 01: enable printing when GPIO8 is reset at low level. 10: enable printing when GPIO8 is reset at high level. 11: force disable printing.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 8);  ///< Represents whether ROM code is forced to send a resume command during SPI boot. 1: forced. 0:not forced.
        constexpr uint32_t SECURE_VERSION = (16 << 9);  ///< Represents the version used by ESP-IDF anti-rollback feature.
        constexpr uint32_t SECURE_BOOT_DISABLE_FAST_WAKE = (1U << 25);  ///< Represents whether FAST VERIFY ON WAKE is disabled or enabled when Secure Boot is enabled. 1: disabled. 0: enabled.
        constexpr uint32_t HYS_EN_PAD0 = (6 << 26);  ///< Represents whether the hysteresis function of corresponding PAD is enabled. 1: enabled. 0:disabled.
    }

    /// RD_REPEAT_DATA4 Register bits
    namespace rd_repeat_data4_bits {
        constexpr uint32_t HYS_EN_PAD1 = (22 << 0);  ///< Represents whether the hysteresis function of corresponding PAD is enabled. 1: enabled. 0:disabled.
        constexpr uint32_t RPT4_RESERVED4_1 = (2 << 22);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED4_0 = (8 << 24);  ///< Reserved.
    }

    /// RD_MAC_SYS_0 Register bits
    namespace rd_mac_sys_0_bits {
        constexpr uint32_t MAC_0 = (32 << 0);  ///< Stores the low 32 bits of MAC address.
    }

    /// RD_MAC_SYS_1 Register bits
    namespace rd_mac_sys_1_bits {
        constexpr uint32_t MAC_1 = (16 << 0);  ///< Stores the high 16 bits of MAC address.
        constexpr uint32_t MAC_EXT = (16 << 16);  ///< Stores the extended bits of MAC address.
    }

    /// RD_MAC_SYS_2 Register bits
    namespace rd_mac_sys_2_bits {
        constexpr uint32_t MAC_RESERVED_1 = (14 << 0);  ///< Reserved.
        constexpr uint32_t MAC_RESERVED_0 = (18 << 14);  ///< Reserved.
    }

    /// RD_MAC_SYS_3 Register bits
    namespace rd_mac_sys_3_bits {
        constexpr uint32_t MAC_RESERVED_2 = (18 << 0);  ///< Reserved.
        constexpr uint32_t SYS_DATA_PART0_0 = (14 << 18);  ///< Stores the first 14 bits of the zeroth part of system data.
    }

    /// RD_MAC_SYS_4 Register bits
    namespace rd_mac_sys_4_bits {
        constexpr uint32_t SYS_DATA_PART0_1 = (32 << 0);  ///< Stores the first 32 bits of the zeroth part of system data.
    }

    /// RD_MAC_SYS_5 Register bits
    namespace rd_mac_sys_5_bits {
        constexpr uint32_t SYS_DATA_PART0_2 = (32 << 0);  ///< Stores the second 32 bits of the zeroth part of system data.
    }

    /// RD_SYS_PART1_DATA0 Register bits
    namespace rd_sys_part1_data0_bits {
        constexpr uint32_t SYS_DATA_PART1_0 = (32 << 0);  ///< Stores the zeroth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA1 Register bits
    namespace rd_sys_part1_data1_bits {
        constexpr uint32_t SYS_DATA_PART1_1 = (32 << 0);  ///< Stores the first 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA2 Register bits
    namespace rd_sys_part1_data2_bits {
        constexpr uint32_t SYS_DATA_PART1_2 = (32 << 0);  ///< Stores the second 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA3 Register bits
    namespace rd_sys_part1_data3_bits {
        constexpr uint32_t SYS_DATA_PART1_3 = (32 << 0);  ///< Stores the third 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA4 Register bits
    namespace rd_sys_part1_data4_bits {
        constexpr uint32_t SYS_DATA_PART1_4 = (32 << 0);  ///< Stores the fourth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA5 Register bits
    namespace rd_sys_part1_data5_bits {
        constexpr uint32_t SYS_DATA_PART1_5 = (32 << 0);  ///< Stores the fifth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA6 Register bits
    namespace rd_sys_part1_data6_bits {
        constexpr uint32_t SYS_DATA_PART1_6 = (32 << 0);  ///< Stores the sixth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA7 Register bits
    namespace rd_sys_part1_data7_bits {
        constexpr uint32_t SYS_DATA_PART1_7 = (32 << 0);  ///< Stores the seventh 32 bits of the first part of system data.
    }

    /// RD_USR_DATA0 Register bits
    namespace rd_usr_data0_bits {
        constexpr uint32_t USR_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA1 Register bits
    namespace rd_usr_data1_bits {
        constexpr uint32_t USR_DATA1 = (32 << 0);  ///< Stores the first 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA2 Register bits
    namespace rd_usr_data2_bits {
        constexpr uint32_t USR_DATA2 = (32 << 0);  ///< Stores the second 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA3 Register bits
    namespace rd_usr_data3_bits {
        constexpr uint32_t USR_DATA3 = (32 << 0);  ///< Stores the third 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA4 Register bits
    namespace rd_usr_data4_bits {
        constexpr uint32_t USR_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA5 Register bits
    namespace rd_usr_data5_bits {
        constexpr uint32_t USR_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA6 Register bits
    namespace rd_usr_data6_bits {
        constexpr uint32_t USR_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA7 Register bits
    namespace rd_usr_data7_bits {
        constexpr uint32_t USR_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of BLOCK3 (user).
    }

    /// RD_KEY0_DATA0 Register bits
    namespace rd_key0_data0_bits {
        constexpr uint32_t KEY0_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA1 Register bits
    namespace rd_key0_data1_bits {
        constexpr uint32_t KEY0_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY0.
    }

    /// RD_KEY0_DATA2 Register bits
    namespace rd_key0_data2_bits {
        constexpr uint32_t KEY0_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY0.
    }

    /// RD_KEY0_DATA3 Register bits
    namespace rd_key0_data3_bits {
        constexpr uint32_t KEY0_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY0.
    }

    /// RD_KEY0_DATA4 Register bits
    namespace rd_key0_data4_bits {
        constexpr uint32_t KEY0_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA5 Register bits
    namespace rd_key0_data5_bits {
        constexpr uint32_t KEY0_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA6 Register bits
    namespace rd_key0_data6_bits {
        constexpr uint32_t KEY0_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA7 Register bits
    namespace rd_key0_data7_bits {
        constexpr uint32_t KEY0_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY0.
    }

    /// RD_KEY1_DATA0 Register bits
    namespace rd_key1_data0_bits {
        constexpr uint32_t KEY1_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA1 Register bits
    namespace rd_key1_data1_bits {
        constexpr uint32_t KEY1_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY1.
    }

    /// RD_KEY1_DATA2 Register bits
    namespace rd_key1_data2_bits {
        constexpr uint32_t KEY1_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY1.
    }

    /// RD_KEY1_DATA3 Register bits
    namespace rd_key1_data3_bits {
        constexpr uint32_t KEY1_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY1.
    }

    /// RD_KEY1_DATA4 Register bits
    namespace rd_key1_data4_bits {
        constexpr uint32_t KEY1_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA5 Register bits
    namespace rd_key1_data5_bits {
        constexpr uint32_t KEY1_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA6 Register bits
    namespace rd_key1_data6_bits {
        constexpr uint32_t KEY1_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA7 Register bits
    namespace rd_key1_data7_bits {
        constexpr uint32_t KEY1_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY1.
    }

    /// RD_KEY2_DATA0 Register bits
    namespace rd_key2_data0_bits {
        constexpr uint32_t KEY2_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA1 Register bits
    namespace rd_key2_data1_bits {
        constexpr uint32_t KEY2_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY2.
    }

    /// RD_KEY2_DATA2 Register bits
    namespace rd_key2_data2_bits {
        constexpr uint32_t KEY2_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY2.
    }

    /// RD_KEY2_DATA3 Register bits
    namespace rd_key2_data3_bits {
        constexpr uint32_t KEY2_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY2.
    }

    /// RD_KEY2_DATA4 Register bits
    namespace rd_key2_data4_bits {
        constexpr uint32_t KEY2_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA5 Register bits
    namespace rd_key2_data5_bits {
        constexpr uint32_t KEY2_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA6 Register bits
    namespace rd_key2_data6_bits {
        constexpr uint32_t KEY2_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA7 Register bits
    namespace rd_key2_data7_bits {
        constexpr uint32_t KEY2_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY2.
    }

    /// RD_KEY3_DATA0 Register bits
    namespace rd_key3_data0_bits {
        constexpr uint32_t KEY3_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA1 Register bits
    namespace rd_key3_data1_bits {
        constexpr uint32_t KEY3_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY3.
    }

    /// RD_KEY3_DATA2 Register bits
    namespace rd_key3_data2_bits {
        constexpr uint32_t KEY3_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY3.
    }

    /// RD_KEY3_DATA3 Register bits
    namespace rd_key3_data3_bits {
        constexpr uint32_t KEY3_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY3.
    }

    /// RD_KEY3_DATA4 Register bits
    namespace rd_key3_data4_bits {
        constexpr uint32_t KEY3_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA5 Register bits
    namespace rd_key3_data5_bits {
        constexpr uint32_t KEY3_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA6 Register bits
    namespace rd_key3_data6_bits {
        constexpr uint32_t KEY3_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA7 Register bits
    namespace rd_key3_data7_bits {
        constexpr uint32_t KEY3_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY3.
    }

    /// RD_KEY4_DATA0 Register bits
    namespace rd_key4_data0_bits {
        constexpr uint32_t KEY4_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA1 Register bits
    namespace rd_key4_data1_bits {
        constexpr uint32_t KEY4_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY4.
    }

    /// RD_KEY4_DATA2 Register bits
    namespace rd_key4_data2_bits {
        constexpr uint32_t KEY4_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY4.
    }

    /// RD_KEY4_DATA3 Register bits
    namespace rd_key4_data3_bits {
        constexpr uint32_t KEY4_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY4.
    }

    /// RD_KEY4_DATA4 Register bits
    namespace rd_key4_data4_bits {
        constexpr uint32_t KEY4_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA5 Register bits
    namespace rd_key4_data5_bits {
        constexpr uint32_t KEY4_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA6 Register bits
    namespace rd_key4_data6_bits {
        constexpr uint32_t KEY4_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA7 Register bits
    namespace rd_key4_data7_bits {
        constexpr uint32_t KEY4_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY4.
    }

    /// RD_KEY5_DATA0 Register bits
    namespace rd_key5_data0_bits {
        constexpr uint32_t KEY5_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA1 Register bits
    namespace rd_key5_data1_bits {
        constexpr uint32_t KEY5_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY5.
    }

    /// RD_KEY5_DATA2 Register bits
    namespace rd_key5_data2_bits {
        constexpr uint32_t KEY5_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY5.
    }

    /// RD_KEY5_DATA3 Register bits
    namespace rd_key5_data3_bits {
        constexpr uint32_t KEY5_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY5.
    }

    /// RD_KEY5_DATA4 Register bits
    namespace rd_key5_data4_bits {
        constexpr uint32_t KEY5_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA5 Register bits
    namespace rd_key5_data5_bits {
        constexpr uint32_t KEY5_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA6 Register bits
    namespace rd_key5_data6_bits {
        constexpr uint32_t KEY5_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA7 Register bits
    namespace rd_key5_data7_bits {
        constexpr uint32_t KEY5_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY5.
    }

    /// RD_SYS_PART2_DATA0 Register bits
    namespace rd_sys_part2_data0_bits {
        constexpr uint32_t SYS_DATA_PART2_0 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA1 Register bits
    namespace rd_sys_part2_data1_bits {
        constexpr uint32_t SYS_DATA_PART2_1 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA2 Register bits
    namespace rd_sys_part2_data2_bits {
        constexpr uint32_t SYS_DATA_PART2_2 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA3 Register bits
    namespace rd_sys_part2_data3_bits {
        constexpr uint32_t SYS_DATA_PART2_3 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA4 Register bits
    namespace rd_sys_part2_data4_bits {
        constexpr uint32_t SYS_DATA_PART2_4 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA5 Register bits
    namespace rd_sys_part2_data5_bits {
        constexpr uint32_t SYS_DATA_PART2_5 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA6 Register bits
    namespace rd_sys_part2_data6_bits {
        constexpr uint32_t SYS_DATA_PART2_6 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA7 Register bits
    namespace rd_sys_part2_data7_bits {
        constexpr uint32_t SYS_DATA_PART2_7 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_REPEAT_ERR0 Register bits
    namespace rd_repeat_err0_bits {
        constexpr uint32_t RD_DIS_ERR = (7 << 0);  ///< Indicates a programming error of RD_DIS.
        constexpr uint32_t RPT4_RESERVED0_ERR_4 = (1U << 7);  ///< Reserved.
        constexpr uint32_t DIS_ICACHE_ERR = (1U << 8);  ///< Indicates a programming error of DIS_ICACHE.
        constexpr uint32_t DIS_USB_JTAG_ERR = (1U << 9);  ///< Indicates a programming error of DIS_USB_JTAG.
        constexpr uint32_t POWERGLITCH_EN_ERR = (1U << 10);  ///< Indicates a programming error of POWERGLITCH_EN.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_ERR = (1U << 11);  ///< Indicates a programming error of DIS_USB_DEVICE.
        constexpr uint32_t DIS_FORCE_DOWNLOAD_ERR = (1U << 12);  ///< Indicates a programming error of DIS_FORCE_DOWNLOAD.
        constexpr uint32_t SPI_DOWNLOAD_MSPI_DIS_ERR = (1U << 13);  ///< Indicates a programming error of SPI_DOWNLOAD_MSPI_DIS.
        constexpr uint32_t DIS_TWAI_ERR = (1U << 14);  ///< Indicates a programming error of DIS_CAN.
        constexpr uint32_t JTAG_SEL_ENABLE_ERR = (1U << 15);  ///< Indicates a programming error of JTAG_SEL_ENABLE.
        constexpr uint32_t SOFT_DIS_JTAG_ERR = (3 << 16);  ///< Indicates a programming error of SOFT_DIS_JTAG.
        constexpr uint32_t DIS_PAD_JTAG_ERR = (1U << 19);  ///< Indicates a programming error of DIS_PAD_JTAG.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 20);  ///< Indicates a programming error of DIS_DOWNLOAD_MANUAL_ENCRYPT.
        constexpr uint32_t USB_DREFH_ERR = (2 << 21);  ///< Indicates a programming error of USB_DREFH.
        constexpr uint32_t USB_DREFL_ERR = (2 << 23);  ///< Indicates a programming error of USB_DREFL.
        constexpr uint32_t USB_EXCHG_PINS_ERR = (1U << 25);  ///< Indicates a programming error of USB_EXCHG_PINS.
        constexpr uint32_t VDD_SPI_AS_GPIO_ERR = (1U << 26);  ///< Indicates a programming error of VDD_SPI_AS_GPIO.
        constexpr uint32_t RPT4_RESERVED0_ERR_2 = (2 << 27);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED0_ERR_1 = (1U << 29);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED0_ERR_0 = (2 << 30);  ///< Reserved.
    }

    /// RD_REPEAT_ERR1 Register bits
    namespace rd_repeat_err1_bits {
        constexpr uint32_t RPT4_RESERVED1_ERR_0 = (16 << 0);  ///< Reserved.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 16);  ///< Indicates a programming error of WDT_DELAY_SEL.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT_ERR = (3 << 18);  ///< Indicates a programming error of SPI_BOOT_CRYPT_CNT.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0_ERR = (1U << 21);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE0.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1_ERR = (1U << 22);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE1.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2_ERR = (1U << 23);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE2.
        constexpr uint32_t KEY_PURPOSE_0_ERR = (4 << 24);  ///< Indicates a programming error of KEY_PURPOSE_0.
        constexpr uint32_t KEY_PURPOSE_1_ERR = (4 << 28);  ///< Indicates a programming error of KEY_PURPOSE_1.
    }

    /// RD_REPEAT_ERR2 Register bits
    namespace rd_repeat_err2_bits {
        constexpr uint32_t KEY_PURPOSE_2_ERR = (4 << 0);  ///< Indicates a programming error of KEY_PURPOSE_2.
        constexpr uint32_t KEY_PURPOSE_3_ERR = (4 << 4);  ///< Indicates a programming error of KEY_PURPOSE_3.
        constexpr uint32_t KEY_PURPOSE_4_ERR = (4 << 8);  ///< Indicates a programming error of KEY_PURPOSE_4.
        constexpr uint32_t KEY_PURPOSE_5_ERR = (4 << 12);  ///< Indicates a programming error of KEY_PURPOSE_5.
        constexpr uint32_t SEC_DPA_LEVEL_ERR = (2 << 16);  ///< Indicates a programming error of SEC_DPA_LEVEL.
        constexpr uint32_t RPT4_RESERVED2_ERR_1 = (1U << 18);  ///< Reserved.
        constexpr uint32_t CRYPT_DPA_ENABLE_ERR = (1U << 19);  ///< Indicates a programming error of CRYPT_DPA_ENABLE.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 20);  ///< Indicates a programming error of SECURE_BOOT_EN.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = (1U << 21);  ///< Indicates a programming error of SECURE_BOOT_AGGRESSIVE_REVOKE.
        constexpr uint32_t RPT4_RESERVED2_ERR_0 = (6 << 22);  ///< Reserved.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 28);  ///< Indicates a programming error of FLASH_TPUW.
    }

    /// RD_REPEAT_ERR3 Register bits
    namespace rd_repeat_err3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 0);  ///< Indicates a programming error of DIS_DOWNLOAD_MODE.
        constexpr uint32_t DIS_DIRECT_BOOT_ERR = (1U << 1);  ///< Indicates a programming error of DIS_DIRECT_BOOT.
        constexpr uint32_t USB_PRINT_ERR = (1U << 2);  ///< Indicates a programming error of UART_PRINT_CHANNEL.
        constexpr uint32_t RPT4_RESERVED3_ERR_5 = (1U << 3);  ///< Reserved.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR = (1U << 4);  ///< Indicates a programming error of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 5);  ///< Indicates a programming error of ENABLE_SECURITY_DOWNLOAD.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 6);  ///< Indicates a programming error of UART_PRINT_CONTROL.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 8);  ///< Indicates a programming error of FORCE_SEND_RESUME.
        constexpr uint32_t SECURE_VERSION_ERR = (16 << 9);  ///< Indicates a programming error of SECURE VERSION.
        constexpr uint32_t SECURE_BOOT_DISABLE_FAST_WAKE_ERR = (1U << 25);  ///< Indicates a programming error of SECURE_BOOT_DISABLE_FAST_WAKE.
        constexpr uint32_t HYS_EN_PAD0_ERR = (6 << 26);  ///< Indicates a programming error of HYS_EN_PAD0.
    }

    /// RD_REPEAT_ERR4 Register bits
    namespace rd_repeat_err4_bits {
        constexpr uint32_t HYS_EN_PAD1_ERR = (22 << 0);  ///< Indicates a programming error of HYS_EN_PAD1.
        constexpr uint32_t RPT4_RESERVED4_ERR_1 = (2 << 22);  ///< Reserved.
        constexpr uint32_t RPT4_RESERVED4_ERR_0 = (8 << 24);  ///< Reserved.
    }

    /// RD_RS_ERR0 Register bits
    namespace rd_rs_err0_bits {
        constexpr uint32_t MAC_SPI_8M_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t MAC_SPI_8M_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART1_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART1_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t USR_DATA_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t USR_DATA_FAIL = (1U << 11);  ///< 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t KEY0_ERR_NUM = (3 << 12);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY0_FAIL = (1U << 15);  ///< 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY1_ERR_NUM = (3 << 16);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY1_FAIL = (1U << 19);  ///< 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY2_ERR_NUM = (3 << 20);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY2_FAIL = (1U << 23);  ///< 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY3_ERR_NUM = (3 << 24);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY3_FAIL = (1U << 27);  ///< 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY4_ERR_NUM = (3 << 28);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY4_FAIL = (1U << 31);  ///< 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
    }

    /// RD_RS_ERR1 Register bits
    namespace rd_rs_err1_bits {
        constexpr uint32_t KEY5_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY5_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of key5 is reliable 1: Means that programming key5 failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t MEM_FORCE_PD = (1U << 0);  ///< Set this bit to force eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit and force to activate clock signal of eFuse SRAM.
        constexpr uint32_t MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< Set this bit to force enable eFuse register configuration clock signal.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: programming operation command 0x5AA5: read operation command.
        constexpr uint32_t CFG_ECDSA_BLK = (4 << 16);  ///< Configures which block to use for ECDSA key output.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t BLK0_VALID_BIT_CNT = (10 << 10);  ///< Indicates the number of block valid bit.
        constexpr uint32_t CUR_ECDSA_BLK = (4 << 20);  ///< Indicates which block is used for ECDSA key output.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (4 << 2);  ///< The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t THR_A = (8 << 0);  ///< Configures the read hold time.
        constexpr uint32_t TRD = (8 << 8);  ///< Configures the read time.
        constexpr uint32_t TSUR_A = (8 << 16);  ///< Configures the read setup time.
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the waiting time of reading eFuse memory.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t TSUP_A = (8 << 0);  ///< Configures the programming setup time.
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
        constexpr uint32_t THP_A = (8 << 24);  ///< Configures the programming hold time.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
        constexpr uint32_t TPGM = (16 << 16);  ///< Configures the active programming time.
    }

    /// WR_TIM_CONF0_RS_BYPASS Register bits
    namespace wr_tim_conf0_rs_bypass_bits {
        constexpr uint32_t BYPASS_RS_CORRECTION = (1U << 0);  ///< Set this bit to bypass reed solomon correction step.
        constexpr uint32_t BYPASS_RS_BLK_NUM = (11 << 1);  ///< Configures block number of programming twice operation.
        constexpr uint32_t UPDATE = (1U << 12);  ///< Set this bit to update multi-bit register signals.
        constexpr uint32_t TPGM_INACTIVE = (8 << 13);  ///< Configures the inactive programming time.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores eFuse version.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x60091000;
    constexpr uint32_t GPIO_SD_BASE = 0x60091F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t BT_SELECT;  ///< Offset: 0x00 - GPIO bit select register
        volatile uint32_t OUT;  ///< Offset: 0x04 - GPIO output register for GPIO0-31
        volatile uint32_t OUT_W1TS;  ///< Offset: 0x08 - GPIO output set register for GPIO0-31
        volatile uint32_t OUT_W1TC;  ///< Offset: 0x0C - GPIO output clear register for GPIO0-31
        volatile uint32_t SDIO_SELECT;  ///< Offset: 0x1C - GPIO sdio select register
        volatile uint32_t ENABLE;  ///< Offset: 0x20 - GPIO output enable register for GPIO0-31
        volatile uint32_t ENABLE_W1TS;  ///< Offset: 0x24 - GPIO output enable set register for GPIO0-31
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x28 - GPIO output enable clear register for GPIO0-31
        volatile uint32_t STRAP;  ///< Offset: 0x38 - pad strapping register
        volatile uint32_t IN;  ///< Offset: 0x3C - GPIO input register for GPIO0-31
        volatile uint32_t STATUS;  ///< Offset: 0x44 - GPIO interrupt status register for GPIO0-31
        volatile uint32_t STATUS_W1TS;  ///< Offset: 0x48 - GPIO interrupt status set register for GPIO0-31
        volatile uint32_t STATUS_W1TC;  ///< Offset: 0x4C - GPIO interrupt status clear register for GPIO0-31
        volatile uint32_t PCPU_INT;  ///< Offset: 0x5C - GPIO PRO_CPU interrupt status register for GPIO0-31
        volatile uint32_t PCPU_NMI_INT;  ///< Offset: 0x60 - GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
        volatile uint32_t CPUSDIO_INT;  ///< Offset: 0x64 - GPIO CPUSDIO interrupt status register for GPIO0-31
        volatile uint32_t PIN%s;  ///< Offset: 0x74 - GPIO pin configuration register
        volatile uint32_t STATUS_NEXT;  ///< Offset: 0x14C - GPIO interrupt source register for GPIO0-31
        volatile uint32_t FUNC%s_IN_SEL_CFG;  ///< Offset: 0x154 - GPIO input function configuration register
        volatile uint32_t FUNC%s_OUT_SEL_CFG;  ///< Offset: 0x554 - GPIO output function select register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x62C - GPIO clock gate register
        volatile uint32_t DATE;  ///< Offset: 0x6FC - GPIO version register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);

    // Bit definitions
    /// BT_SELECT Register bits
    namespace bt_select_bits {
        constexpr uint32_t BT_SEL = (32 << 0);  ///< GPIO bit select register
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t DATA_ORIG = (32 << 0);  ///< GPIO output register for GPIO0-31
    }

    /// OUT_W1TS Register bits
    namespace out_w1ts_bits {
        constexpr uint32_t OUT_W1TS = (32 << 0);  ///< GPIO output set register for GPIO0-31
    }

    /// OUT_W1TC Register bits
    namespace out_w1tc_bits {
        constexpr uint32_t OUT_W1TC = (32 << 0);  ///< GPIO output clear register for GPIO0-31
    }

    /// SDIO_SELECT Register bits
    namespace sdio_select_bits {
        constexpr uint32_t SDIO_SEL = (8 << 0);  ///< GPIO sdio select register
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< GPIO output enable register for GPIO0-31
    }

    /// ENABLE_W1TS Register bits
    namespace enable_w1ts_bits {
        constexpr uint32_t ENABLE_W1TS = (32 << 0);  ///< GPIO output enable set register for GPIO0-31
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (32 << 0);  ///< GPIO output enable clear register for GPIO0-31
    }

    /// STRAP Register bits
    namespace strap_bits {
        constexpr uint32_t STRAPPING = (16 << 0);  ///< pad strapping register
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t DATA_NEXT = (32 << 0);  ///< GPIO input register for GPIO0-31
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INTERRUPT = (32 << 0);  ///< GPIO interrupt status register for GPIO0-31
    }

    /// STATUS_W1TS Register bits
    namespace status_w1ts_bits {
        constexpr uint32_t STATUS_W1TS = (32 << 0);  ///< GPIO interrupt status set register for GPIO0-31
    }

    /// STATUS_W1TC Register bits
    namespace status_w1tc_bits {
        constexpr uint32_t STATUS_W1TC = (32 << 0);  ///< GPIO interrupt status clear register for GPIO0-31
    }

    /// PCPU_INT Register bits
    namespace pcpu_int_bits {
        constexpr uint32_t PROCPU_INT = (32 << 0);  ///< GPIO PRO_CPU interrupt status register for GPIO0-31
    }

    /// PCPU_NMI_INT Register bits
    namespace pcpu_nmi_int_bits {
        constexpr uint32_t PROCPU_NMI_INT = (32 << 0);  ///< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
    }

    /// CPUSDIO_INT Register bits
    namespace cpusdio_int_bits {
        constexpr uint32_t SDIO_INT = (32 << 0);  ///< GPIO CPUSDIO interrupt status register for GPIO0-31
    }

    /// PIN%s Register bits
    namespace pin%s_bits {
        constexpr uint32_t SYNC2_BYPASS = (2 << 0);  ///< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< set this bit to select pad driver. 1:open-drain. 0:normal.
        constexpr uint32_t SYNC1_BYPASS = (2 << 3);  ///< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t INT_TYPE = (3 << 7);  ///< set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
        constexpr uint32_t WAKEUP_ENABLE = (1U << 10);  ///< set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
        constexpr uint32_t CONFIG = (2 << 11);  ///< reserved
        constexpr uint32_t INT_ENA = (5 << 13);  ///< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
    }

    /// STATUS_NEXT Register bits
    namespace status_next_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT = (32 << 0);  ///< GPIO interrupt source register for GPIO0-31
    }

    /// FUNC%s_IN_SEL_CFG Register bits
    namespace func%s_in_sel_cfg_bits {
        constexpr uint32_t IN_SEL = (6 << 0);  ///< set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
        constexpr uint32_t IN_INV_SEL = (1U << 6);  ///< set this bit to invert input signal. 1:invert. 0:not invert.
        constexpr uint32_t SEL = (1U << 7);  ///< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
    }

    /// FUNC%s_OUT_SEL_CFG Register bits
    namespace func%s_out_sel_cfg_bits {
        constexpr uint32_t OUT_SEL = (8 << 0);  ///< The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
        constexpr uint32_t INV_SEL = (1U << 8);  ///< set this bit to invert output signal.1:invert.0:not invert.
        constexpr uint32_t OEN_SEL = (1U << 9);  ///< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
        constexpr uint32_t OEN_INV_SEL = (1U << 10);  ///< set this bit to invert output enable signal.1:invert.0:not invert.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable GPIO clock gate
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// HP Peripheral
// ============================================================================

namespace hp {
    /// Base addresses
    constexpr uint32_t HP_APM_BASE = 0x60099000;
    constexpr uint32_t HP_SYS_BASE = 0x60095000;

    /// HP Register structure
    struct Registers {
        volatile uint32_t REGION_FILTER_EN;  ///< Offset: 0x00 - Region filter enable register
        volatile uint32_t REGION0_ADDR_START;  ///< Offset: 0x04 - Region address register
        volatile uint32_t REGION0_ADDR_END;  ///< Offset: 0x08 - Region address register
        volatile uint32_t REGION0_PMS_ATTR;  ///< Offset: 0x0C - Region access authority attribute register
        volatile uint32_t REGION1_ADDR_START;  ///< Offset: 0x10 - Region address register
        volatile uint32_t REGION1_ADDR_END;  ///< Offset: 0x14 - Region address register
        volatile uint32_t REGION1_PMS_ATTR;  ///< Offset: 0x18 - Region access authority attribute register
        volatile uint32_t REGION2_ADDR_START;  ///< Offset: 0x1C - Region address register
        volatile uint32_t REGION2_ADDR_END;  ///< Offset: 0x20 - Region address register
        volatile uint32_t REGION2_PMS_ATTR;  ///< Offset: 0x24 - Region access authority attribute register
        volatile uint32_t REGION3_ADDR_START;  ///< Offset: 0x28 - Region address register
        volatile uint32_t REGION3_ADDR_END;  ///< Offset: 0x2C - Region address register
        volatile uint32_t REGION3_PMS_ATTR;  ///< Offset: 0x30 - Region access authority attribute register
        volatile uint32_t REGION4_ADDR_START;  ///< Offset: 0x34 - Region address register
        volatile uint32_t REGION4_ADDR_END;  ///< Offset: 0x38 - Region address register
        volatile uint32_t REGION4_PMS_ATTR;  ///< Offset: 0x3C - Region access authority attribute register
        volatile uint32_t REGION5_ADDR_START;  ///< Offset: 0x40 - Region address register
        volatile uint32_t REGION5_ADDR_END;  ///< Offset: 0x44 - Region address register
        volatile uint32_t REGION5_PMS_ATTR;  ///< Offset: 0x48 - Region access authority attribute register
        volatile uint32_t REGION6_ADDR_START;  ///< Offset: 0x4C - Region address register
        volatile uint32_t REGION6_ADDR_END;  ///< Offset: 0x50 - Region address register
        volatile uint32_t REGION6_PMS_ATTR;  ///< Offset: 0x54 - Region access authority attribute register
        volatile uint32_t REGION7_ADDR_START;  ///< Offset: 0x58 - Region address register
        volatile uint32_t REGION7_ADDR_END;  ///< Offset: 0x5C - Region address register
        volatile uint32_t REGION7_PMS_ATTR;  ///< Offset: 0x60 - Region access authority attribute register
        volatile uint32_t REGION8_ADDR_START;  ///< Offset: 0x64 - Region address register
        volatile uint32_t REGION8_ADDR_END;  ///< Offset: 0x68 - Region address register
        volatile uint32_t REGION8_PMS_ATTR;  ///< Offset: 0x6C - Region access authority attribute register
        volatile uint32_t REGION9_ADDR_START;  ///< Offset: 0x70 - Region address register
        volatile uint32_t REGION9_ADDR_END;  ///< Offset: 0x74 - Region address register
        volatile uint32_t REGION9_PMS_ATTR;  ///< Offset: 0x78 - Region access authority attribute register
        volatile uint32_t REGION10_ADDR_START;  ///< Offset: 0x7C - Region address register
        volatile uint32_t REGION10_ADDR_END;  ///< Offset: 0x80 - Region address register
        volatile uint32_t REGION10_PMS_ATTR;  ///< Offset: 0x84 - Region access authority attribute register
        volatile uint32_t REGION11_ADDR_START;  ///< Offset: 0x88 - Region address register
        volatile uint32_t REGION11_ADDR_END;  ///< Offset: 0x8C - Region address register
        volatile uint32_t REGION11_PMS_ATTR;  ///< Offset: 0x90 - Region access authority attribute register
        volatile uint32_t REGION12_ADDR_START;  ///< Offset: 0x94 - Region address register
        volatile uint32_t REGION12_ADDR_END;  ///< Offset: 0x98 - Region address register
        volatile uint32_t REGION12_PMS_ATTR;  ///< Offset: 0x9C - Region access authority attribute register
        volatile uint32_t REGION13_ADDR_START;  ///< Offset: 0xA0 - Region address register
        volatile uint32_t REGION13_ADDR_END;  ///< Offset: 0xA4 - Region address register
        volatile uint32_t REGION13_PMS_ATTR;  ///< Offset: 0xA8 - Region access authority attribute register
        volatile uint32_t REGION14_ADDR_START;  ///< Offset: 0xAC - Region address register
        volatile uint32_t REGION14_ADDR_END;  ///< Offset: 0xB0 - Region address register
        volatile uint32_t REGION14_PMS_ATTR;  ///< Offset: 0xB4 - Region access authority attribute register
        volatile uint32_t REGION15_ADDR_START;  ///< Offset: 0xB8 - Region address register
        volatile uint32_t REGION15_ADDR_END;  ///< Offset: 0xBC - Region address register
        volatile uint32_t REGION15_PMS_ATTR;  ///< Offset: 0xC0 - Region access authority attribute register
        volatile uint32_t FUNC_CTRL;  ///< Offset: 0xC4 - PMS function control register
        volatile uint32_t M0_STATUS;  ///< Offset: 0xC8 - M0 status register
        volatile uint32_t M0_STATUS_CLR;  ///< Offset: 0xCC - M0 status clear register
        volatile uint32_t M0_EXCEPTION_INFO0;  ///< Offset: 0xD0 - M0 exception_info0 register
        volatile uint32_t M0_EXCEPTION_INFO1;  ///< Offset: 0xD4 - M0 exception_info1 register
        volatile uint32_t M1_STATUS;  ///< Offset: 0xD8 - M1 status register
        volatile uint32_t M1_STATUS_CLR;  ///< Offset: 0xDC - M1 status clear register
        volatile uint32_t M1_EXCEPTION_INFO0;  ///< Offset: 0xE0 - M1 exception_info0 register
        volatile uint32_t M1_EXCEPTION_INFO1;  ///< Offset: 0xE4 - M1 exception_info1 register
        volatile uint32_t M2_STATUS;  ///< Offset: 0xE8 - M2 status register
        volatile uint32_t M2_STATUS_CLR;  ///< Offset: 0xEC - M2 status clear register
        volatile uint32_t M2_EXCEPTION_INFO0;  ///< Offset: 0xF0 - M2 exception_info0 register
        volatile uint32_t M2_EXCEPTION_INFO1;  ///< Offset: 0xF4 - M2 exception_info1 register
        volatile uint32_t M3_STATUS;  ///< Offset: 0xF8 - M3 status register
        volatile uint32_t M3_STATUS_CLR;  ///< Offset: 0xFC - M3 status clear register
        volatile uint32_t M3_EXCEPTION_INFO0;  ///< Offset: 0x100 - M3 exception_info0 register
        volatile uint32_t M3_EXCEPTION_INFO1;  ///< Offset: 0x104 - M3 exception_info1 register
        volatile uint32_t INT_EN;  ///< Offset: 0x108 - APM interrupt enable register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x10C - clock gating register
        volatile uint32_t DATE;  ///< Offset: 0x7FC - Version register
    };

    /// Peripheral instances
    inline Registers* HP_APM = reinterpret_cast<Registers*>(HP_APM_BASE);
    inline Registers* HP_SYS = reinterpret_cast<Registers*>(HP_SYS_BASE);

    // Bit definitions
    /// REGION_FILTER_EN Register bits
    namespace region_filter_en_bits {
        constexpr uint32_t REGION_FILTER_EN = (16 << 0);  ///< Region filter enable
    }

    /// REGION0_ADDR_START Register bits
    namespace region0_addr_start_bits {
        constexpr uint32_t REGION0_ADDR_START = (32 << 0);  ///< Start address of region0
    }

    /// REGION0_ADDR_END Register bits
    namespace region0_addr_end_bits {
        constexpr uint32_t REGION0_ADDR_END = (32 << 0);  ///< End address of region0
    }

    /// REGION0_PMS_ATTR Register bits
    namespace region0_pms_attr_bits {
        constexpr uint32_t REGION0_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION0_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION0_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION0_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION0_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION0_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION0_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION0_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION0_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION1_ADDR_START Register bits
    namespace region1_addr_start_bits {
        constexpr uint32_t REGION1_ADDR_START = (32 << 0);  ///< Start address of region1
    }

    /// REGION1_ADDR_END Register bits
    namespace region1_addr_end_bits {
        constexpr uint32_t REGION1_ADDR_END = (32 << 0);  ///< End address of region1
    }

    /// REGION1_PMS_ATTR Register bits
    namespace region1_pms_attr_bits {
        constexpr uint32_t REGION1_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION1_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION1_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION1_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION1_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION1_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION1_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION1_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION1_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION2_ADDR_START Register bits
    namespace region2_addr_start_bits {
        constexpr uint32_t REGION2_ADDR_START = (32 << 0);  ///< Start address of region2
    }

    /// REGION2_ADDR_END Register bits
    namespace region2_addr_end_bits {
        constexpr uint32_t REGION2_ADDR_END = (32 << 0);  ///< End address of region2
    }

    /// REGION2_PMS_ATTR Register bits
    namespace region2_pms_attr_bits {
        constexpr uint32_t REGION2_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION2_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION2_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION2_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION2_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION2_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION2_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION2_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION2_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION3_ADDR_START Register bits
    namespace region3_addr_start_bits {
        constexpr uint32_t REGION3_ADDR_START = (32 << 0);  ///< Start address of region3
    }

    /// REGION3_ADDR_END Register bits
    namespace region3_addr_end_bits {
        constexpr uint32_t REGION3_ADDR_END = (32 << 0);  ///< End address of region3
    }

    /// REGION3_PMS_ATTR Register bits
    namespace region3_pms_attr_bits {
        constexpr uint32_t REGION3_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION3_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION3_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION3_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION3_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION3_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION3_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION3_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION3_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION4_ADDR_START Register bits
    namespace region4_addr_start_bits {
        constexpr uint32_t REGION4_ADDR_START = (32 << 0);  ///< Start address of region4
    }

    /// REGION4_ADDR_END Register bits
    namespace region4_addr_end_bits {
        constexpr uint32_t REGION4_ADDR_END = (32 << 0);  ///< End address of region4
    }

    /// REGION4_PMS_ATTR Register bits
    namespace region4_pms_attr_bits {
        constexpr uint32_t REGION4_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION4_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION4_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION4_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION4_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION4_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION4_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION4_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION4_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION5_ADDR_START Register bits
    namespace region5_addr_start_bits {
        constexpr uint32_t REGION5_ADDR_START = (32 << 0);  ///< Start address of region5
    }

    /// REGION5_ADDR_END Register bits
    namespace region5_addr_end_bits {
        constexpr uint32_t REGION5_ADDR_END = (32 << 0);  ///< End address of region5
    }

    /// REGION5_PMS_ATTR Register bits
    namespace region5_pms_attr_bits {
        constexpr uint32_t REGION5_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION5_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION5_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION5_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION5_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION5_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION5_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION5_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION5_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION6_ADDR_START Register bits
    namespace region6_addr_start_bits {
        constexpr uint32_t REGION6_ADDR_START = (32 << 0);  ///< Start address of region6
    }

    /// REGION6_ADDR_END Register bits
    namespace region6_addr_end_bits {
        constexpr uint32_t REGION6_ADDR_END = (32 << 0);  ///< End address of region6
    }

    /// REGION6_PMS_ATTR Register bits
    namespace region6_pms_attr_bits {
        constexpr uint32_t REGION6_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION6_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION6_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION6_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION6_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION6_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION6_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION6_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION6_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION7_ADDR_START Register bits
    namespace region7_addr_start_bits {
        constexpr uint32_t REGION7_ADDR_START = (32 << 0);  ///< Start address of region7
    }

    /// REGION7_ADDR_END Register bits
    namespace region7_addr_end_bits {
        constexpr uint32_t REGION7_ADDR_END = (32 << 0);  ///< End address of region7
    }

    /// REGION7_PMS_ATTR Register bits
    namespace region7_pms_attr_bits {
        constexpr uint32_t REGION7_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION7_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION7_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION7_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION7_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION7_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION7_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION7_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION7_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION8_ADDR_START Register bits
    namespace region8_addr_start_bits {
        constexpr uint32_t REGION8_ADDR_START = (32 << 0);  ///< Start address of region8
    }

    /// REGION8_ADDR_END Register bits
    namespace region8_addr_end_bits {
        constexpr uint32_t REGION8_ADDR_END = (32 << 0);  ///< End address of region8
    }

    /// REGION8_PMS_ATTR Register bits
    namespace region8_pms_attr_bits {
        constexpr uint32_t REGION8_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION8_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION8_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION8_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION8_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION8_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION8_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION8_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION8_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION9_ADDR_START Register bits
    namespace region9_addr_start_bits {
        constexpr uint32_t REGION9_ADDR_START = (32 << 0);  ///< Start address of region9
    }

    /// REGION9_ADDR_END Register bits
    namespace region9_addr_end_bits {
        constexpr uint32_t REGION9_ADDR_END = (32 << 0);  ///< End address of region9
    }

    /// REGION9_PMS_ATTR Register bits
    namespace region9_pms_attr_bits {
        constexpr uint32_t REGION9_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION9_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION9_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION9_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION9_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION9_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION9_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION9_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION9_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION10_ADDR_START Register bits
    namespace region10_addr_start_bits {
        constexpr uint32_t REGION10_ADDR_START = (32 << 0);  ///< Start address of region10
    }

    /// REGION10_ADDR_END Register bits
    namespace region10_addr_end_bits {
        constexpr uint32_t REGION10_ADDR_END = (32 << 0);  ///< End address of region10
    }

    /// REGION10_PMS_ATTR Register bits
    namespace region10_pms_attr_bits {
        constexpr uint32_t REGION10_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION10_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION10_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION10_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION10_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION10_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION10_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION10_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION10_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION11_ADDR_START Register bits
    namespace region11_addr_start_bits {
        constexpr uint32_t REGION11_ADDR_START = (32 << 0);  ///< Start address of region11
    }

    /// REGION11_ADDR_END Register bits
    namespace region11_addr_end_bits {
        constexpr uint32_t REGION11_ADDR_END = (32 << 0);  ///< End address of region11
    }

    /// REGION11_PMS_ATTR Register bits
    namespace region11_pms_attr_bits {
        constexpr uint32_t REGION11_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION11_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION11_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION11_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION11_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION11_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION11_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION11_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION11_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION12_ADDR_START Register bits
    namespace region12_addr_start_bits {
        constexpr uint32_t REGION12_ADDR_START = (32 << 0);  ///< Start address of region12
    }

    /// REGION12_ADDR_END Register bits
    namespace region12_addr_end_bits {
        constexpr uint32_t REGION12_ADDR_END = (32 << 0);  ///< End address of region12
    }

    /// REGION12_PMS_ATTR Register bits
    namespace region12_pms_attr_bits {
        constexpr uint32_t REGION12_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION12_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION12_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION12_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION12_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION12_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION12_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION12_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION12_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION13_ADDR_START Register bits
    namespace region13_addr_start_bits {
        constexpr uint32_t REGION13_ADDR_START = (32 << 0);  ///< Start address of region13
    }

    /// REGION13_ADDR_END Register bits
    namespace region13_addr_end_bits {
        constexpr uint32_t REGION13_ADDR_END = (32 << 0);  ///< End address of region13
    }

    /// REGION13_PMS_ATTR Register bits
    namespace region13_pms_attr_bits {
        constexpr uint32_t REGION13_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION13_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION13_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION13_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION13_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION13_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION13_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION13_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION13_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION14_ADDR_START Register bits
    namespace region14_addr_start_bits {
        constexpr uint32_t REGION14_ADDR_START = (32 << 0);  ///< Start address of region14
    }

    /// REGION14_ADDR_END Register bits
    namespace region14_addr_end_bits {
        constexpr uint32_t REGION14_ADDR_END = (32 << 0);  ///< End address of region14
    }

    /// REGION14_PMS_ATTR Register bits
    namespace region14_pms_attr_bits {
        constexpr uint32_t REGION14_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION14_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION14_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION14_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION14_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION14_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION14_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION14_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION14_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// REGION15_ADDR_START Register bits
    namespace region15_addr_start_bits {
        constexpr uint32_t REGION15_ADDR_START = (32 << 0);  ///< Start address of region15
    }

    /// REGION15_ADDR_END Register bits
    namespace region15_addr_end_bits {
        constexpr uint32_t REGION15_ADDR_END = (32 << 0);  ///< End address of region15
    }

    /// REGION15_PMS_ATTR Register bits
    namespace region15_pms_attr_bits {
        constexpr uint32_t REGION15_R0_PMS_X = (1U << 0);  ///< Region execute authority in REE_MODE0
        constexpr uint32_t REGION15_R0_PMS_W = (1U << 1);  ///< Region write authority in REE_MODE0
        constexpr uint32_t REGION15_R0_PMS_R = (1U << 2);  ///< Region read authority in REE_MODE0
        constexpr uint32_t REGION15_R1_PMS_X = (1U << 4);  ///< Region execute authority in REE_MODE1
        constexpr uint32_t REGION15_R1_PMS_W = (1U << 5);  ///< Region write authority in REE_MODE1
        constexpr uint32_t REGION15_R1_PMS_R = (1U << 6);  ///< Region read authority in REE_MODE1
        constexpr uint32_t REGION15_R2_PMS_X = (1U << 8);  ///< Region execute authority in REE_MODE2
        constexpr uint32_t REGION15_R2_PMS_W = (1U << 9);  ///< Region write authority in REE_MODE2
        constexpr uint32_t REGION15_R2_PMS_R = (1U << 10);  ///< Region read authority in REE_MODE2
    }

    /// FUNC_CTRL Register bits
    namespace func_ctrl_bits {
        constexpr uint32_t M0_PMS_FUNC_EN = (1U << 0);  ///< PMS M0 function enable
        constexpr uint32_t M1_PMS_FUNC_EN = (1U << 1);  ///< PMS M1 function enable
        constexpr uint32_t M2_PMS_FUNC_EN = (1U << 2);  ///< PMS M2 function enable
        constexpr uint32_t M3_PMS_FUNC_EN = (1U << 3);  ///< PMS M3 function enable
    }

    /// M0_STATUS Register bits
    namespace m0_status_bits {
        constexpr uint32_t M0_EXCEPTION_STATUS = (2 << 0);  ///< Exception status
    }

    /// M0_STATUS_CLR Register bits
    namespace m0_status_clr_bits {
        constexpr uint32_t M0_REGION_STATUS_CLR = (1U << 0);  ///< Clear exception status
    }

    /// M0_EXCEPTION_INFO0 Register bits
    namespace m0_exception_info0_bits {
        constexpr uint32_t M0_EXCEPTION_REGION = (16 << 0);  ///< Exception region
        constexpr uint32_t M0_EXCEPTION_MODE = (2 << 16);  ///< Exception mode
        constexpr uint32_t M0_EXCEPTION_ID = (5 << 18);  ///< Exception id information
    }

    /// M0_EXCEPTION_INFO1 Register bits
    namespace m0_exception_info1_bits {
        constexpr uint32_t M0_EXCEPTION_ADDR = (32 << 0);  ///< Exception addr
    }

    /// M1_STATUS Register bits
    namespace m1_status_bits {
        constexpr uint32_t M1_EXCEPTION_STATUS = (2 << 0);  ///< Exception status
    }

    /// M1_STATUS_CLR Register bits
    namespace m1_status_clr_bits {
        constexpr uint32_t M1_REGION_STATUS_CLR = (1U << 0);  ///< Clear exception status
    }

    /// M1_EXCEPTION_INFO0 Register bits
    namespace m1_exception_info0_bits {
        constexpr uint32_t M1_EXCEPTION_REGION = (16 << 0);  ///< Exception region
        constexpr uint32_t M1_EXCEPTION_MODE = (2 << 16);  ///< Exception mode
        constexpr uint32_t M1_EXCEPTION_ID = (5 << 18);  ///< Exception id information
    }

    /// M1_EXCEPTION_INFO1 Register bits
    namespace m1_exception_info1_bits {
        constexpr uint32_t M1_EXCEPTION_ADDR = (32 << 0);  ///< Exception addr
    }

    /// M2_STATUS Register bits
    namespace m2_status_bits {
        constexpr uint32_t M2_EXCEPTION_STATUS = (2 << 0);  ///< Exception status
    }

    /// M2_STATUS_CLR Register bits
    namespace m2_status_clr_bits {
        constexpr uint32_t M2_REGION_STATUS_CLR = (1U << 0);  ///< Clear exception status
    }

    /// M2_EXCEPTION_INFO0 Register bits
    namespace m2_exception_info0_bits {
        constexpr uint32_t M2_EXCEPTION_REGION = (16 << 0);  ///< Exception region
        constexpr uint32_t M2_EXCEPTION_MODE = (2 << 16);  ///< Exception mode
        constexpr uint32_t M2_EXCEPTION_ID = (5 << 18);  ///< Exception id information
    }

    /// M2_EXCEPTION_INFO1 Register bits
    namespace m2_exception_info1_bits {
        constexpr uint32_t M2_EXCEPTION_ADDR = (32 << 0);  ///< Exception addr
    }

    /// M3_STATUS Register bits
    namespace m3_status_bits {
        constexpr uint32_t M3_EXCEPTION_STATUS = (2 << 0);  ///< Exception status
    }

    /// M3_STATUS_CLR Register bits
    namespace m3_status_clr_bits {
        constexpr uint32_t M3_REGION_STATUS_CLR = (1U << 0);  ///< Clear exception status
    }

    /// M3_EXCEPTION_INFO0 Register bits
    namespace m3_exception_info0_bits {
        constexpr uint32_t M3_EXCEPTION_REGION = (16 << 0);  ///< Exception region
        constexpr uint32_t M3_EXCEPTION_MODE = (2 << 16);  ///< Exception mode
        constexpr uint32_t M3_EXCEPTION_ID = (5 << 18);  ///< Exception id information
    }

    /// M3_EXCEPTION_INFO1 Register bits
    namespace m3_exception_info1_bits {
        constexpr uint32_t M3_EXCEPTION_ADDR = (32 << 0);  ///< Exception addr
    }

    /// INT_EN Register bits
    namespace int_en_bits {
        constexpr uint32_t M0_APM_INT_EN = (1U << 0);  ///< APM M0 interrupt enable
        constexpr uint32_t M1_APM_INT_EN = (1U << 1);  ///< APM M1 interrupt enable
        constexpr uint32_t M2_APM_INT_EN = (1U << 2);  ///< APM M2 interrupt enable
        constexpr uint32_t M3_APM_INT_EN = (1U << 3);  ///< APM M3 interrupt enable
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< reg_clk_en
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< reg_date
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x60004000;
    constexpr uint32_t I2C1_BASE = 0x60005000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - Configures the low level width of the SCL Clock
        volatile uint32_t CTR;  ///< Offset: 0x04 - Transmission setting
        volatile uint32_t SR;  ///< Offset: 0x08 - Describe I2C work status.
        volatile uint32_t TO;  ///< Offset: 0x0C - Setting time out control for receiving data.
        volatile uint32_t SLAVE_ADDR;  ///< Offset: 0x10 - Local slave address setting
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - FIFO status register.
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - FIFO configuration register.
        volatile uint32_t DATA;  ///< Offset: 0x1C - Rx FIFO read data.
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Interrupt clear bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Interrupt enable bits
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - Status of captured I2C communication events
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - Configures the hold time after a negative SCL edge.
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - Configures the sample time after a positive SCL edge.
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - Configures the high level width of SCL
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - Configures the delay between the SDA and SCL negative...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - Configures the delay between the positive edge of SCL...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - Configures the delay after the SCL clock edge for a stop...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - Configures the delay between the SDA and SCL positive...
        volatile uint32_t FILTER_CFG;  ///< Offset: 0x50 - SCL and SDA filter configuration register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x54 - I2C CLK configuration register
        volatile uint32_t COMD%s;  ///< Offset: 0x58 - I2C command register %s
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x78 - SCL status time out register
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x7C - SCL main status time out register
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0x80 - Power configuration register
        volatile uint32_t SCL_STRETCH_CONF;  ///< Offset: 0x84 - Set SCL stretch of I2C slave
        volatile uint32_t DATE;  ///< Offset: 0xF8 - Version register
        volatile uint32_t TXFIFO_START_ADDR;  ///< Offset: 0x100 - I2C TXFIFO base address register
        volatile uint32_t RXFIFO_START_ADDR;  ///< Offset: 0x180 - I2C RXFIFO base address register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 1: direct output, 0: open drain output.
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 1: direct output, 0: open drain output.
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< This register is used to select the sample mode. 1: sample SDA data on the SCL low level. 0: sample SDA data on the SCL high level.
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        constexpr uint32_t MS_MODE = (1U << 4);  ///< Set this bit to configure the module as an I2C Master. Clear this bit to configure the module as an I2C Slave.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending the data in txfifo.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit, 0: send data from the most significant bit.
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received data. 1: receive data from the least significant bit, 0: receive data from the most significant bit.
        constexpr uint32_t CLK_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< This is the enable bit for arbitration_lost.
        constexpr uint32_t FSM_RST = (1U << 10);  ///< This register is used to reset the scl FMS.
        constexpr uint32_t CONF_UPGATE = (1U << 11);  ///< synchronization bit
        constexpr uint32_t SLV_TX_AUTO_START_EN = (1U << 12);  ///< This is the enable bit for slave to send data automatically
        constexpr uint32_t ADDR_10BIT_RW_CHECK_EN = (1U << 13);  ///< This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
        constexpr uint32_t ADDR_BROADCASTING_EN = (1U << 14);  ///< This is the enable bit to support the 7bit general call function.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        constexpr uint32_t SLAVE_RW = (1U << 1);  ///< When in slave mode, 1: master reads from slave, 0: master writes to slave.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< When the I2C controller loses control of SCL line, this register changes to 1.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
        constexpr uint32_t SLAVE_ADDRESSED = (1U << 5);  ///< When configured as an I2C Slave, and the address sent by the master is equal to the address of the slave, then this bit will be of high level.
        constexpr uint32_t RXFIFO_CNT = (6 << 8);  ///< This field represents the amount of data needed to be sent.
        constexpr uint32_t STRETCH_CAUSE = (2 << 14);  ///< The cause of stretching SCL low in slave mode. 0: stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
        constexpr uint32_t TXFIFO_CNT = (6 << 18);  ///< This field stores the amount of received data in RAM.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This field indicates the states of the state machine used to produce SCL. 0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (5 << 0);  ///< This register is used to configure the timeout for receiving a data bit in APB clock cycles.
        constexpr uint32_t TIME_OUT_EN = (1U << 5);  ///< This is the enable bit for time out control.
    }

    /// SLAVE_ADDR Register bits
    namespace slave_addr_bits {
        constexpr uint32_t SLAVE_ADDR = (15 << 0);  ///< When configured as an I2C Slave, this field is used to configure the slave address.
        constexpr uint32_t ADDR_10BIT_EN = (1U << 31);  ///< This field is used to enable the slave 10-bit addressing mode in master mode.
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_RADDR = (5 << 0);  ///< This is the offset address of the APB reading from rxfifo
        constexpr uint32_t RXFIFO_WADDR = (5 << 5);  ///< This is the offset address of i2c module receiving data and writing to rxfifo.
        constexpr uint32_t TXFIFO_RADDR = (5 << 10);  ///< This is the offset address of i2c module reading from txfifo.
        constexpr uint32_t TXFIFO_WADDR = (5 << 15);  ///< This is the offset address of APB bus writing to txfifo.
        constexpr uint32_t SLAVE_RW_POINT = (8 << 22);  ///< The received data in I2C slave mode.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (5 << 0);  ///< The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
        constexpr uint32_t TXFIFO_WM_THRHD = (5 << 5);  ///< The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enable APB nonfifo access.
        constexpr uint32_t FIFO_ADDR_CFG_EN = (1U << 11);  ///< When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset rx-fifo.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset tx-fifo.
        constexpr uint32_t FIFO_PRT_EN = (1U << 14);  ///< The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The value of rx FIFO read data.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_RAW = (1U << 16);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_RAW = (1U << 17);  ///< The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
        constexpr uint32_t SLAVE_ADDR_UNMATCH_INT_RAW = (1U << 18);  ///< The raw interrupt bit for I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< Set this bit to clear I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_CLR = (1U << 16);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_CLR = (1U << 17);  ///< Set this bit to clear I2C_GENARAL_CALL_INT interrupt.
        constexpr uint32_t SLAVE_ADDR_UNMATCH_INT_CLR = (1U << 18);  ///< Set this bit to clear I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< The interrupt enable bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ENA = (1U << 16);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_ENA = (1U << 17);  ///< The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
        constexpr uint32_t SLAVE_ADDR_UNMATCH_INT_ENA = (1U << 18);  ///< The interrupt enable bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ST = (1U << 16);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_ST = (1U << 17);  ///< The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
        constexpr uint32_t SLAVE_ADDR_UNMATCH_INT_ST = (1U << 18);  ///< The masked interrupt status bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time to hold the data after the negative edge of SCL, in I2C module clock cycles.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (7 << 9);  ///< This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the negative edge of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the delay after the STOP condition, in I2C module clock cycles.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the positive edge of SDA, in I2C module clock cycles.
    }

    /// FILTER_CFG Register bits
    namespace filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< When a pulse on the SCL input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SDA_FILTER_THRES = (4 << 4);  ///< When a pulse on the SDA input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 8);  ///< This is the filter enable bit for SCL.
        constexpr uint32_t SDA_FILTER_EN = (1U << 9);  ///< This is the filter enable bit for SDA.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_NUM = (8 << 0);  ///< the integral part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_A = (6 << 8);  ///< the numerator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_B = (6 << 14);  ///< the denominator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
        constexpr uint32_t SCLK_ACTIVE = (1U << 21);  ///< The clock switch for i2c module
    }

    /// COMD%s Register bits
    namespace comd%s_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< When command 0 is done in I2C Master mode, this bit changes to high level.
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_FSM state unchanged period. It should be o more than 23
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
    }

    /// SCL_STRETCH_CONF Register bits
    namespace scl_stretch_conf_bits {
        constexpr uint32_t STRETCH_PROTECT_NUM = (10 << 0);  ///< Configure the period of I2C slave stretching SCL line.
        constexpr uint32_t SLAVE_SCL_STRETCH_EN = (1U << 10);  ///< The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
        constexpr uint32_t SLAVE_SCL_STRETCH_CLR = (1U << 11);  ///< Set this bit to clear the I2C slave SCL stretch function.
        constexpr uint32_t SLAVE_BYTE_ACK_CTL_EN = (1U << 12);  ///< The enable bit for slave to control ACK level function.
        constexpr uint32_t SLAVE_BYTE_ACK_LVL = (1U << 13);  ///< Set the ACK level when slave controlling ACK level function enables.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the the version register.
    }

    /// TXFIFO_START_ADDR Register bits
    namespace txfifo_start_addr_bits {
        constexpr uint32_t TXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C txfifo first address.
    }

    /// RXFIFO_START_ADDR Register bits
    namespace rxfifo_start_addr_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C rxfifo first address.
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x6000D000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - I2S interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - I2S interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - I2S interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - I2S interrupt clear register.
        volatile uint32_t RX_CONF;  ///< Offset: 0x20 - I2S RX configure register
        volatile uint32_t TX_CONF;  ///< Offset: 0x24 - I2S TX configure register
        volatile uint32_t RX_CONF1;  ///< Offset: 0x28 - I2S RX configure register 1
        volatile uint32_t TX_CONF1;  ///< Offset: 0x2C - I2S TX configure register 1
        volatile uint32_t RX_CLKM_CONF;  ///< Offset: 0x30 - I2S RX clock configure register
        volatile uint32_t TX_CLKM_CONF;  ///< Offset: 0x34 - I2S TX clock configure register
        volatile uint32_t RX_CLKM_DIV_CONF;  ///< Offset: 0x38 - I2S RX module clock divider configure register
        volatile uint32_t TX_CLKM_DIV_CONF;  ///< Offset: 0x3C - I2S TX module clock divider configure register
        volatile uint32_t TX_PCM2PDM_CONF;  ///< Offset: 0x40 - I2S TX PCM2PDM configuration register
        volatile uint32_t TX_PCM2PDM_CONF1;  ///< Offset: 0x44 - I2S TX PCM2PDM configuration register
        volatile uint32_t RX_TDM_CTRL;  ///< Offset: 0x50 - I2S TX TDM mode control register
        volatile uint32_t TX_TDM_CTRL;  ///< Offset: 0x54 - I2S TX TDM mode control register
        volatile uint32_t RX_TIMING;  ///< Offset: 0x58 - I2S RX timing control register
        volatile uint32_t TX_TIMING;  ///< Offset: 0x5C - I2S TX timing control register
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x60 - I2S HUNG configure register.
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x64 - I2S RX data number control register.
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x68 - I2S signal data register
        volatile uint32_t STATE;  ///< Offset: 0x6C - I2S TX status register
        volatile uint32_t ETM_CONF;  ///< Offset: 0x70 - I2S ETM configure register
        volatile uint32_t DATE;  ///< Offset: 0x80 - Version control register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the i2s_tx_hung_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 1);  ///< Set this bit to clear the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear the i2s_tx_hung_int interrupt
    }

    /// RX_CONF Register bits
    namespace rx_conf_bits {
        constexpr uint32_t RX_RESET = (1U << 0);  ///< Set this bit to reset receiver
        constexpr uint32_t RX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Rx AFIFO
        constexpr uint32_t RX_START = (1U << 2);  ///< Set this bit to start receiving data
        constexpr uint32_t RX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave receiver mode
        constexpr uint32_t RX_STOP_MODE = (2 << 4);  ///< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
        constexpr uint32_t RX_MONO = (1U << 6);  ///< Set this bit to enable receiver in mono mode
        constexpr uint32_t RX_BIG_ENDIAN = (1U << 7);  ///< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t RX_UPDATE = (1U << 8);  ///< Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t RX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
        constexpr uint32_t RX_PCM_CONF = (2 << 10);  ///< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t RX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for received data.
        constexpr uint32_t RX_MSB_SHIFT = (1U << 13);  ///< Set this bit to enable receiver in Phillips standard mode
        constexpr uint32_t RX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
        constexpr uint32_t RX_24_FILL_EN = (1U << 16);  ///< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
        constexpr uint32_t RX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when receiving left channel data, and WS is 1in right channel. 1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
        constexpr uint32_t RX_BIT_ORDER = (1U << 18);  ///< I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
        constexpr uint32_t RX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Rx mode . 0: Disable.
        constexpr uint32_t RX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Rx mode . 0: Disable.
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 21);  ///< Bit clock configuration bits in receiver mode.
    }

    /// TX_CONF Register bits
    namespace tx_conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< Set this bit to reset transmitter
        constexpr uint32_t TX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Tx AFIFO
        constexpr uint32_t TX_START = (1U << 2);  ///< Set this bit to start transmitting data
        constexpr uint32_t TX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave transmitter mode
        constexpr uint32_t TX_STOP_EN = (1U << 4);  ///< Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
        constexpr uint32_t TX_CHAN_EQUAL = (1U << 5);  ///< 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
        constexpr uint32_t TX_MONO = (1U << 6);  ///< Set this bit to enable transmitter in mono mode
        constexpr uint32_t TX_BIG_ENDIAN = (1U << 7);  ///< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t TX_UPDATE = (1U << 8);  ///< Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t TX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
        constexpr uint32_t TX_PCM_CONF = (2 << 10);  ///< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t TX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for transmitted data.
        constexpr uint32_t TX_MSB_SHIFT = (1U << 13);  ///< Set this bit to enable transmitter in Phillips standard mode
        constexpr uint32_t TX_BCK_NO_DLY = (1U << 14);  ///< 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
        constexpr uint32_t TX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
        constexpr uint32_t TX_24_FILL_EN = (1U << 16);  ///< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
        constexpr uint32_t TX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when sending left channel data, and WS is 1in right channel. 1: WS should be 1 when sending left channel data, and WS is 0in right channel.
        constexpr uint32_t TX_BIT_ORDER = (1U << 18);  ///< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
        constexpr uint32_t TX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Tx mode . 0: Disable.
        constexpr uint32_t TX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Tx mode . 0: Disable.
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 21);  ///< Bit clock configuration bits in transmitter mode.
        constexpr uint32_t TX_CHAN_MOD = (3 << 27);  ///< I2S transmitter channel mode configuration bits.
        constexpr uint32_t SIG_LOOPBACK = (1U << 30);  ///< Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
    }

    /// RX_CONF1 Register bits
    namespace rx_conf1_bits {
        constexpr uint32_t RX_TDM_WS_WIDTH = (9 << 0);  ///< The width of rx_ws_out at idle level in TDM mode is (I2S_RX_TDM_WS_WIDTH[8:0] +1) * T_bck
        constexpr uint32_t RX_BITS_MOD = (5 << 14);  ///< Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t RX_HALF_SAMPLE_BITS = (8 << 19);  ///< I2S Rx half sample bits -1.
        constexpr uint32_t RX_TDM_CHAN_BITS = (5 << 27);  ///< The Rx bit number for each channel minus 1in TDM mode.
    }

    /// TX_CONF1 Register bits
    namespace tx_conf1_bits {
        constexpr uint32_t TX_TDM_WS_WIDTH = (9 << 0);  ///< The width of tx_ws_out at idle level in TDM mode is (I2S_TX_TDM_WS_WIDTH[8:0] +1) * T_bck
        constexpr uint32_t TX_BITS_MOD = (5 << 14);  ///< Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t TX_HALF_SAMPLE_BITS = (8 << 19);  ///< I2S Tx half sample bits -1.
        constexpr uint32_t TX_TDM_CHAN_BITS = (5 << 27);  ///< The Tx bit number for each channel minus 1in TDM mode.
    }

    /// RX_CLKM_CONF Register bits
    namespace rx_clkm_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t RX_CLK_ACTIVE = (1U << 26);  ///< I2S Rx module clock enable signal.
        constexpr uint32_t RX_CLK_SEL = (2 << 27);  ///< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t MCLK_SEL = (1U << 29);  ///< 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module clock as I2S_MCLK_OUT.
    }

    /// TX_CLKM_CONF Register bits
    namespace tx_clkm_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div. So the average combination will be: for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
        constexpr uint32_t TX_CLK_ACTIVE = (1U << 26);  ///< I2S Tx module clock enable signal.
        constexpr uint32_t TX_CLK_SEL = (2 << 27);  ///< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t CLK_EN = (1U << 29);  ///< Set this bit to enable clk gate
    }

    /// RX_CLKM_DIV_CONF Register bits
    namespace rx_clkm_div_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t RX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t RX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t RX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
    }

    /// TX_CLKM_DIV_CONF Register bits
    namespace tx_clkm_div_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t TX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t TX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t TX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
    }

    /// TX_PCM2PDM_CONF Register bits
    namespace tx_pcm2pdm_conf_bits {
        constexpr uint32_t TX_PDM_HP_BYPASS = (1U << 0);  ///< I2S TX PDM bypass hp filter or not. The option has been removed.
        constexpr uint32_t TX_PDM_SINC_OSR2 = (4 << 1);  ///< I2S TX PDM OSR2 value
        constexpr uint32_t TX_PDM_PRESCALE = (8 << 5);  ///< I2S TX PDM prescale for sigmadelta
        constexpr uint32_t TX_PDM_HP_IN_SHIFT = (2 << 13);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_LP_IN_SHIFT = (2 << 15);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SINC_IN_SHIFT = (2 << 17);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_IN_SHIFT = (2 << 19);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER2 = (1U << 21);  ///< I2S TX PDM sigmadelta dither2 value
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER = (1U << 22);  ///< I2S TX PDM sigmadelta dither value
        constexpr uint32_t TX_PDM_DAC_2OUT_EN = (1U << 23);  ///< I2S TX PDM dac mode enable
        constexpr uint32_t TX_PDM_DAC_MODE_EN = (1U << 24);  ///< I2S TX PDM dac 2channel enable
        constexpr uint32_t PCM2PDM_CONV_EN = (1U << 25);  ///< I2S TX PDM Converter enable
    }

    /// TX_PCM2PDM_CONF1 Register bits
    namespace tx_pcm2pdm_conf1_bits {
        constexpr uint32_t TX_PDM_FP = (10 << 0);  ///< I2S TX PDM Fp
        constexpr uint32_t TX_PDM_FS = (10 << 10);  ///< I2S TX PDM Fs
        constexpr uint32_t TX_IIR_HP_MULT12_5 = (3 << 20);  ///< The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
        constexpr uint32_t TX_IIR_HP_MULT12_0 = (3 << 23);  ///< The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
    }

    /// RX_TDM_CTRL Register bits
    namespace rx_tdm_ctrl_bits {
        constexpr uint32_t RX_TDM_PDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data input of I2S RX TDM channel 10. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data input of I2S RX TDM channel 11. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data input of I2S RX TDM channel 12. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data input of I2S RX TDM channel 13. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data input of I2S RX TDM channel 14. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data input of I2S RX TDM channel 15. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
    }

    /// TX_TDM_CTRL Register bits
    namespace tx_tdm_ctrl_bits {
        constexpr uint32_t TX_TDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data output of I2S TX TDM channel 0. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data output of I2S TX TDM channel 1. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data output of I2S TX TDM channel 2. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data output of I2S TX TDM channel 3. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data output of I2S TX TDM channel 4. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data output of I2S TX TDM channel 5. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data output of I2S TX TDM channel 6. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data output of I2S TX TDM channel 7. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data output of I2S TX TDM channel 8. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data output of I2S TX TDM channel 9. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data output of I2S TX TDM channel 10. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data output of I2S TX TDM channel 11. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data output of I2S TX TDM channel 12. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data output of I2S TX TDM channel 13. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data output of I2S TX TDM channel 14. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data output of I2S TX TDM channel 15. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
        constexpr uint32_t TX_TDM_SKIP_MSK_EN = (1U << 20);  ///< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1) channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
    }

    /// RX_TIMING Register bits
    namespace rx_timing_bits {
        constexpr uint32_t RX_SD_IN_DM = (2 << 0);  ///< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// TX_TIMING Register bits
    namespace tx_timing_bits {
        constexpr uint32_t TX_SD_OUT_DM = (2 << 0);  ///< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_SD1_OUT_DM = (2 << 4);  ///< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for FIFO timeout
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (12 << 0);  ///< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SINGLE_DATA = (32 << 0);  ///< The configured constant channel data to be sent out.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< 1: i2s_tx is idle state. 0: i2s_tx is working.
    }

    /// ETM_CONF Register bits
    namespace etm_conf_bits {
        constexpr uint32_t ETM_TX_SEND_WORD_NUM = (10 << 0);  ///< I2S ETM send x words event. When sending word number of reg_etm_tx_send_word_num[9:0], i2s will trigger an etm event.
        constexpr uint32_t ETM_RX_RECEIVE_WORD_NUM = (10 << 10);  ///< I2S ETM receive x words event. When receiving word number of reg_etm_rx_receive_word_num[9:0], i2s will trigger an etm event.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< I2S version control register
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x60010000;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t PMU_INTR_MAP;  ///< Offset: 0x00 - register description
        volatile uint32_t EFUSE_INTR_MAP;  ///< Offset: 0x04 - register description
        volatile uint32_t LP_RTC_TIMER_INTR_MAP;  ///< Offset: 0x08 - register description
        volatile uint32_t LP_BLE_TIMER_INTR_MAP;  ///< Offset: 0x0C - register description
        volatile uint32_t LP_WDT_INTR_MAP;  ///< Offset: 0x10 - register description
        volatile uint32_t LP_PERI_TIMEOUT_INTR_MAP;  ///< Offset: 0x14 - register description
        volatile uint32_t LP_APM_M0_INTR_MAP;  ///< Offset: 0x18 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x1C - register description
        volatile uint32_t CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x20 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x24 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x28 - register description
        volatile uint32_t ASSIST_DEBUG_INTR_MAP;  ///< Offset: 0x2C - register description
        volatile uint32_t TRACE_INTR_MAP;  ///< Offset: 0x30 - register description
        volatile uint32_t CACHE_INTR_MAP;  ///< Offset: 0x34 - register description
        volatile uint32_t CPU_PERI_TIMEOUT_INTR_MAP;  ///< Offset: 0x38 - register description
        volatile uint32_t BT_MAC_INTR_MAP;  ///< Offset: 0x3C - register description
        volatile uint32_t BT_BB_INTR_MAP;  ///< Offset: 0x40 - register description
        volatile uint32_t BT_BB_NMI_MAP;  ///< Offset: 0x44 - register description
        volatile uint32_t COEX_INTR_MAP;  ///< Offset: 0x48 - register description
        volatile uint32_t BLE_TIMER_INTR_MAP;  ///< Offset: 0x4C - register description
        volatile uint32_t BLE_SEC_INTR_MAP;  ///< Offset: 0x50 - register description
        volatile uint32_t ZB_MAC_INTR_MAP;  ///< Offset: 0x54 - register description
        volatile uint32_t GPIO_INTERRUPT_PRO_MAP;  ///< Offset: 0x58 - register description
        volatile uint32_t GPIO_INTERRUPT_PRO_NMI_MAP;  ///< Offset: 0x5C - register description
        volatile uint32_t PAU_INTR_MAP;  ///< Offset: 0x60 - register description
        volatile uint32_t HP_PERI_TIMEOUT_INTR_MAP;  ///< Offset: 0x64 - register description
        volatile uint32_t HP_APM_M0_INTR_MAP;  ///< Offset: 0x68 - register description
        volatile uint32_t HP_APM_M1_INTR_MAP;  ///< Offset: 0x6C - register description
        volatile uint32_t HP_APM_M2_INTR_MAP;  ///< Offset: 0x70 - register description
        volatile uint32_t HP_APM_M3_INTR_MAP;  ///< Offset: 0x74 - register description
        volatile uint32_t MSPI_INTR_MAP;  ///< Offset: 0x78 - register description
        volatile uint32_t I2S1_INTR_MAP;  ///< Offset: 0x7C - register description
        volatile uint32_t UHCI0_INTR_MAP;  ///< Offset: 0x80 - register description
        volatile uint32_t UART0_INTR_MAP;  ///< Offset: 0x84 - register description
        volatile uint32_t UART1_INTR_MAP;  ///< Offset: 0x88 - register description
        volatile uint32_t LEDC_INTR_MAP;  ///< Offset: 0x8C - register description
        volatile uint32_t CAN0_INTR_MAP;  ///< Offset: 0x90 - register description
        volatile uint32_t USB_INTR_MAP;  ///< Offset: 0x94 - register description
        volatile uint32_t RMT_INTR_MAP;  ///< Offset: 0x98 - register description
        volatile uint32_t I2C_EXT0_INTR_MAP;  ///< Offset: 0x9C - register description
        volatile uint32_t I2C_EXT1_INTR_MAP;  ///< Offset: 0xA0 - register description
        volatile uint32_t TG0_T0_INTR_MAP;  ///< Offset: 0xA4 - register description
        volatile uint32_t TG0_WDT_INTR_MAP;  ///< Offset: 0xA8 - register description
        volatile uint32_t TG1_T0_INTR_MAP;  ///< Offset: 0xAC - register description
        volatile uint32_t TG1_WDT_INTR_MAP;  ///< Offset: 0xB0 - register description
        volatile uint32_t SYSTIMER_TARGET0_INTR_MAP;  ///< Offset: 0xB4 - register description
        volatile uint32_t SYSTIMER_TARGET1_INTR_MAP;  ///< Offset: 0xB8 - register description
        volatile uint32_t SYSTIMER_TARGET2_INTR_MAP;  ///< Offset: 0xBC - register description
        volatile uint32_t APB_ADC_INTR_MAP;  ///< Offset: 0xC0 - register description
        volatile uint32_t PWM_INTR_MAP;  ///< Offset: 0xC4 - register description
        volatile uint32_t PCNT_INTR_MAP;  ///< Offset: 0xC8 - register description
        volatile uint32_t PARL_IO_TX_INTR_MAP;  ///< Offset: 0xCC - register description
        volatile uint32_t PARL_IO_RX_INTR_MAP;  ///< Offset: 0xD0 - register description
        volatile uint32_t DMA_IN_CH0_INTR_MAP;  ///< Offset: 0xD4 - register description
        volatile uint32_t DMA_IN_CH1_INTR_MAP;  ///< Offset: 0xD8 - register description
        volatile uint32_t DMA_IN_CH2_INTR_MAP;  ///< Offset: 0xDC - register description
        volatile uint32_t DMA_OUT_CH0_INTR_MAP;  ///< Offset: 0xE0 - register description
        volatile uint32_t DMA_OUT_CH1_INTR_MAP;  ///< Offset: 0xE4 - register description
        volatile uint32_t DMA_OUT_CH2_INTR_MAP;  ///< Offset: 0xE8 - register description
        volatile uint32_t GPSPI2_INTR_MAP;  ///< Offset: 0xEC - register description
        volatile uint32_t AES_INTR_MAP;  ///< Offset: 0xF0 - register description
        volatile uint32_t SHA_INTR_MAP;  ///< Offset: 0xF4 - register description
        volatile uint32_t RSA_INTR_MAP;  ///< Offset: 0xF8 - register description
        volatile uint32_t ECC_INTR_MAP;  ///< Offset: 0xFC - register description
        volatile uint32_t ECDSA_INTR_MAP;  ///< Offset: 0x100 - register description
        volatile uint32_t INTR_STATUS_REG_0;  ///< Offset: 0x104 - register description
        volatile uint32_t INTR_STATUS_REG_1;  ///< Offset: 0x108 - register description
        volatile uint32_t INT_STATUS_REG_2;  ///< Offset: 0x10C - register description
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x110 - register description
        volatile uint32_t INTERRUPT_REG_DATE;  ///< Offset: 0x7FC - register description
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);

    // Bit definitions
    /// PMU_INTR_MAP Register bits
    namespace pmu_intr_map_bits {
        constexpr uint32_t PMU_INTR_MAP = (5 << 0);  ///< CORE0_PMU_INTR mapping register
    }

    /// EFUSE_INTR_MAP Register bits
    namespace efuse_intr_map_bits {
        constexpr uint32_t EFUSE_INTR_MAP = (5 << 0);  ///< CORE0_EFUSE_INTR mapping register
    }

    /// LP_RTC_TIMER_INTR_MAP Register bits
    namespace lp_rtc_timer_intr_map_bits {
        constexpr uint32_t LP_RTC_TIMER_INTR_MAP = (5 << 0);  ///< CORE0_LP_RTC_TIMER_INTR mapping register
    }

    /// LP_BLE_TIMER_INTR_MAP Register bits
    namespace lp_ble_timer_intr_map_bits {
        constexpr uint32_t LP_BLE_TIMER_INTR_MAP = (5 << 0);  ///< CORE0_LP_BLE_TIMER_INTR mapping register
    }

    /// LP_WDT_INTR_MAP Register bits
    namespace lp_wdt_intr_map_bits {
        constexpr uint32_t LP_WDT_INTR_MAP = (5 << 0);  ///< CORE0_LP_WDT_INTR mapping register
    }

    /// LP_PERI_TIMEOUT_INTR_MAP Register bits
    namespace lp_peri_timeout_intr_map_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_INTR_MAP = (5 << 0);  ///< CORE0_LP_PERI_TIMEOUT_INTR mapping register
    }

    /// LP_APM_M0_INTR_MAP Register bits
    namespace lp_apm_m0_intr_map_bits {
        constexpr uint32_t LP_APM_M0_INTR_MAP = (5 << 0);  ///< CORE0_LP_APM_M0_INTR mapping register
    }

    /// CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< CORE0_CPU_INTR_FROM_CPU_0 mapping register
    }

    /// CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< CORE0_CPU_INTR_FROM_CPU_1 mapping register
    }

    /// CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< CORE0_CPU_INTR_FROM_CPU_2 mapping register
    }

    /// CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< CORE0_CPU_INTR_FROM_CPU_3 mapping register
    }

    /// ASSIST_DEBUG_INTR_MAP Register bits
    namespace assist_debug_intr_map_bits {
        constexpr uint32_t ASSIST_DEBUG_INTR_MAP = (5 << 0);  ///< CORE0_ASSIST_DEBUG_INTR mapping register
    }

    /// TRACE_INTR_MAP Register bits
    namespace trace_intr_map_bits {
        constexpr uint32_t TRACE_INTR_MAP = (5 << 0);  ///< CORE0_TRACE_INTR mapping register
    }

    /// CACHE_INTR_MAP Register bits
    namespace cache_intr_map_bits {
        constexpr uint32_t CACHE_INTR_MAP = (5 << 0);  ///< CORE0_CACHE_INTR mapping register
    }

    /// CPU_PERI_TIMEOUT_INTR_MAP Register bits
    namespace cpu_peri_timeout_intr_map_bits {
        constexpr uint32_t CPU_PERI_TIMEOUT_INTR_MAP = (5 << 0);  ///< CORE0_CPU_PERI_TIMEOUT_INTR mapping register
    }

    /// BT_MAC_INTR_MAP Register bits
    namespace bt_mac_intr_map_bits {
        constexpr uint32_t BT_MAC_INTR_MAP = (5 << 0);  ///< CORE0_BT_MAC_INTR mapping register
    }

    /// BT_BB_INTR_MAP Register bits
    namespace bt_bb_intr_map_bits {
        constexpr uint32_t BT_BB_INTR_MAP = (5 << 0);  ///< CORE0_BT_BB_INTR mapping register
    }

    /// BT_BB_NMI_MAP Register bits
    namespace bt_bb_nmi_map_bits {
        constexpr uint32_t BT_BB_NMI_MAP = (5 << 0);  ///< CORE0_BT_BB_NMI mapping register
    }

    /// COEX_INTR_MAP Register bits
    namespace coex_intr_map_bits {
        constexpr uint32_t COEX_INTR_MAP = (5 << 0);  ///< CORE0_COEX_INTR mapping register
    }

    /// BLE_TIMER_INTR_MAP Register bits
    namespace ble_timer_intr_map_bits {
        constexpr uint32_t BLE_TIMER_INTR_MAP = (5 << 0);  ///< CORE0_BLE_TIMER_INTR mapping register
    }

    /// BLE_SEC_INTR_MAP Register bits
    namespace ble_sec_intr_map_bits {
        constexpr uint32_t BLE_SEC_INTR_MAP = (5 << 0);  ///< CORE0_BLE_SEC_INTR mapping register
    }

    /// ZB_MAC_INTR_MAP Register bits
    namespace zb_mac_intr_map_bits {
        constexpr uint32_t ZB_MAC_INTR_MAP = (5 << 0);  ///< CORE0_ZB_MAC_INTR mapping register
    }

    /// GPIO_INTERRUPT_PRO_MAP Register bits
    namespace gpio_interrupt_pro_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< CORE0_GPIO_INTERRUPT_PRO mapping register
    }

    /// GPIO_INTERRUPT_PRO_NMI_MAP Register bits
    namespace gpio_interrupt_pro_nmi_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< CORE0_GPIO_INTERRUPT_PRO_NMI mapping register
    }

    /// PAU_INTR_MAP Register bits
    namespace pau_intr_map_bits {
        constexpr uint32_t PAU_INTR_MAP = (5 << 0);  ///< CORE0_PAU_INTR mapping register
    }

    /// HP_PERI_TIMEOUT_INTR_MAP Register bits
    namespace hp_peri_timeout_intr_map_bits {
        constexpr uint32_t HP_PERI_TIMEOUT_INTR_MAP = (5 << 0);  ///< CORE0_HP_PERI_TIMEOUT_INTR mapping register
    }

    /// HP_APM_M0_INTR_MAP Register bits
    namespace hp_apm_m0_intr_map_bits {
        constexpr uint32_t HP_APM_M0_INTR_MAP = (5 << 0);  ///< CORE0_HP_APM_M0_INTR mapping register
    }

    /// HP_APM_M1_INTR_MAP Register bits
    namespace hp_apm_m1_intr_map_bits {
        constexpr uint32_t HP_APM_M1_INTR_MAP = (5 << 0);  ///< CORE0_HP_APM_M1_INTR mapping register
    }

    /// HP_APM_M2_INTR_MAP Register bits
    namespace hp_apm_m2_intr_map_bits {
        constexpr uint32_t HP_APM_M2_INTR_MAP = (5 << 0);  ///< CORE0_HP_APM_M2_INTR mapping register
    }

    /// HP_APM_M3_INTR_MAP Register bits
    namespace hp_apm_m3_intr_map_bits {
        constexpr uint32_t HP_APM_M3_INTR_MAP = (5 << 0);  ///< CORE0_HP_APM_M3_INTR mapping register
    }

    /// MSPI_INTR_MAP Register bits
    namespace mspi_intr_map_bits {
        constexpr uint32_t MSPI_INTR_MAP = (5 << 0);  ///< CORE0_MSPI_INTR mapping register
    }

    /// I2S1_INTR_MAP Register bits
    namespace i2s1_intr_map_bits {
        constexpr uint32_t I2S1_INTR_MAP = (5 << 0);  ///< CORE0_I2S1_INTR mapping register
    }

    /// UHCI0_INTR_MAP Register bits
    namespace uhci0_intr_map_bits {
        constexpr uint32_t UHCI0_INTR_MAP = (5 << 0);  ///< CORE0_UHCI0_INTR mapping register
    }

    /// UART0_INTR_MAP Register bits
    namespace uart0_intr_map_bits {
        constexpr uint32_t UART0_INTR_MAP = (5 << 0);  ///< CORE0_UART0_INTR mapping register
    }

    /// UART1_INTR_MAP Register bits
    namespace uart1_intr_map_bits {
        constexpr uint32_t UART1_INTR_MAP = (5 << 0);  ///< CORE0_UART1_INTR mapping register
    }

    /// LEDC_INTR_MAP Register bits
    namespace ledc_intr_map_bits {
        constexpr uint32_t LEDC_INTR_MAP = (5 << 0);  ///< CORE0_LEDC_INTR mapping register
    }

    /// CAN0_INTR_MAP Register bits
    namespace can0_intr_map_bits {
        constexpr uint32_t CAN0_INTR_MAP = (5 << 0);  ///< CORE0_CAN0_INTR mapping register
    }

    /// USB_INTR_MAP Register bits
    namespace usb_intr_map_bits {
        constexpr uint32_t USB_INTR_MAP = (5 << 0);  ///< CORE0_USB_INTR mapping register
    }

    /// RMT_INTR_MAP Register bits
    namespace rmt_intr_map_bits {
        constexpr uint32_t RMT_INTR_MAP = (5 << 0);  ///< CORE0_RMT_INTR mapping register
    }

    /// I2C_EXT0_INTR_MAP Register bits
    namespace i2c_ext0_intr_map_bits {
        constexpr uint32_t I2C_EXT0_INTR_MAP = (5 << 0);  ///< CORE0_I2C_EXT0_INTR mapping register
    }

    /// I2C_EXT1_INTR_MAP Register bits
    namespace i2c_ext1_intr_map_bits {
        constexpr uint32_t I2C_EXT1_INTR_MAP = (5 << 0);  ///< CORE0_I2C_EXT1_INTR mapping register
    }

    /// TG0_T0_INTR_MAP Register bits
    namespace tg0_t0_intr_map_bits {
        constexpr uint32_t TG0_T0_INTR_MAP = (5 << 0);  ///< CORE0_TG0_T0_INTR mapping register
    }

    /// TG0_WDT_INTR_MAP Register bits
    namespace tg0_wdt_intr_map_bits {
        constexpr uint32_t TG0_WDT_INTR_MAP = (5 << 0);  ///< CORE0_TG0_WDT_INTR mapping register
    }

    /// TG1_T0_INTR_MAP Register bits
    namespace tg1_t0_intr_map_bits {
        constexpr uint32_t TG1_T0_INTR_MAP = (5 << 0);  ///< CORE0_TG1_T0_INTR mapping register
    }

    /// TG1_WDT_INTR_MAP Register bits
    namespace tg1_wdt_intr_map_bits {
        constexpr uint32_t TG1_WDT_INTR_MAP = (5 << 0);  ///< CORE0_TG1_WDT_INTR mapping register
    }

    /// SYSTIMER_TARGET0_INTR_MAP Register bits
    namespace systimer_target0_intr_map_bits {
        constexpr uint32_t SYSTIMER_TARGET0_INTR_MAP = (5 << 0);  ///< CORE0_SYSTIMER_TARGET0_INTR mapping register
    }

    /// SYSTIMER_TARGET1_INTR_MAP Register bits
    namespace systimer_target1_intr_map_bits {
        constexpr uint32_t SYSTIMER_TARGET1_INTR_MAP = (5 << 0);  ///< CORE0_SYSTIMER_TARGET1_INTR mapping register
    }

    /// SYSTIMER_TARGET2_INTR_MAP Register bits
    namespace systimer_target2_intr_map_bits {
        constexpr uint32_t SYSTIMER_TARGET2_INTR_MAP = (5 << 0);  ///< CORE0_SYSTIMER_TARGET2_INTR mapping register
    }

    /// APB_ADC_INTR_MAP Register bits
    namespace apb_adc_intr_map_bits {
        constexpr uint32_t APB_ADC_INTR_MAP = (5 << 0);  ///< CORE0_APB_ADC_INTR mapping register
    }

    /// PWM_INTR_MAP Register bits
    namespace pwm_intr_map_bits {
        constexpr uint32_t PWM_INTR_MAP = (5 << 0);  ///< CORE0_PWM_INTR mapping register
    }

    /// PCNT_INTR_MAP Register bits
    namespace pcnt_intr_map_bits {
        constexpr uint32_t PCNT_INTR_MAP = (5 << 0);  ///< CORE0_PCNT_INTR mapping register
    }

    /// PARL_IO_TX_INTR_MAP Register bits
    namespace parl_io_tx_intr_map_bits {
        constexpr uint32_t PARL_IO_TX_INTR_MAP = (5 << 0);  ///< CORE0_PARL_IO_TX_INTR mapping register
    }

    /// PARL_IO_RX_INTR_MAP Register bits
    namespace parl_io_rx_intr_map_bits {
        constexpr uint32_t PARL_IO_RX_INTR_MAP = (5 << 0);  ///< CORE0_PARL_IO_RX_INTR mapping register
    }

    /// DMA_IN_CH0_INTR_MAP Register bits
    namespace dma_in_ch0_intr_map_bits {
        constexpr uint32_t DMA_IN_CH0_INTR_MAP = (5 << 0);  ///< CORE0_DMA_IN_CH0_INTR mapping register
    }

    /// DMA_IN_CH1_INTR_MAP Register bits
    namespace dma_in_ch1_intr_map_bits {
        constexpr uint32_t DMA_IN_CH1_INTR_MAP = (5 << 0);  ///< CORE0_DMA_IN_CH1_INTR mapping register
    }

    /// DMA_IN_CH2_INTR_MAP Register bits
    namespace dma_in_ch2_intr_map_bits {
        constexpr uint32_t DMA_IN_CH2_INTR_MAP = (5 << 0);  ///< CORE0_DMA_IN_CH2_INTR mapping register
    }

    /// DMA_OUT_CH0_INTR_MAP Register bits
    namespace dma_out_ch0_intr_map_bits {
        constexpr uint32_t DMA_OUT_CH0_INTR_MAP = (5 << 0);  ///< CORE0_DMA_OUT_CH0_INTR mapping register
    }

    /// DMA_OUT_CH1_INTR_MAP Register bits
    namespace dma_out_ch1_intr_map_bits {
        constexpr uint32_t DMA_OUT_CH1_INTR_MAP = (5 << 0);  ///< CORE0_DMA_OUT_CH1_INTR mapping register
    }

    /// DMA_OUT_CH2_INTR_MAP Register bits
    namespace dma_out_ch2_intr_map_bits {
        constexpr uint32_t DMA_OUT_CH2_INTR_MAP = (5 << 0);  ///< CORE0_DMA_OUT_CH2_INTR mapping register
    }

    /// GPSPI2_INTR_MAP Register bits
    namespace gpspi2_intr_map_bits {
        constexpr uint32_t GPSPI2_INTR_MAP = (5 << 0);  ///< CORE0_GPSPI2_INTR mapping register
    }

    /// AES_INTR_MAP Register bits
    namespace aes_intr_map_bits {
        constexpr uint32_t AES_INTR_MAP = (5 << 0);  ///< CORE0_AES_INTR mapping register
    }

    /// SHA_INTR_MAP Register bits
    namespace sha_intr_map_bits {
        constexpr uint32_t SHA_INTR_MAP = (5 << 0);  ///< CORE0_SHA_INTR mapping register
    }

    /// RSA_INTR_MAP Register bits
    namespace rsa_intr_map_bits {
        constexpr uint32_t RSA_INTR_MAP = (5 << 0);  ///< CORE0_RSA_INTR mapping register
    }

    /// ECC_INTR_MAP Register bits
    namespace ecc_intr_map_bits {
        constexpr uint32_t ECC_INTR_MAP = (5 << 0);  ///< CORE0_ECC_INTR mapping register
    }

    /// ECDSA_INTR_MAP Register bits
    namespace ecdsa_intr_map_bits {
        constexpr uint32_t ECDSA_INTR_MAP = (5 << 0);  ///< CORE0_ECDSA_INTR mapping register
    }

    /// INTR_STATUS_REG_0 Register bits
    namespace intr_status_reg_0_bits {
        constexpr uint32_t INTR_STATUS_0 = (32 << 0);  ///< Status register for interrupt sources 0~31 mapping register
    }

    /// INTR_STATUS_REG_1 Register bits
    namespace intr_status_reg_1_bits {
        constexpr uint32_t INTR_STATUS_1 = (32 << 0);  ///< Status register for interrupt sources 32~63 mapping register
    }

    /// INT_STATUS_REG_2 Register bits
    namespace int_status_reg_2_bits {
        constexpr uint32_t INT_STATUS_2 = (32 << 0);  ///< Status register for interrupt sources 64~95 mapping register
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< Clock register
    }

    /// INTERRUPT_REG_DATE Register bits
    namespace interrupt_reg_date_bits {
        constexpr uint32_t INTERRUPT_REG_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// INTPRI Peripheral
// ============================================================================

namespace intpri {
    /// Base addresses
    constexpr uint32_t INTPRI_BASE = 0x600C5000;

    /// INTPRI Register structure
    struct Registers {
        volatile uint32_t CPU_INT_ENABLE;  ///< Offset: 0x00 - register description
        volatile uint32_t CPU_INT_TYPE;  ///< Offset: 0x04 - register description
        volatile uint32_t CPU_INT_EIP_STATUS;  ///< Offset: 0x08 - register description
        volatile uint32_t CPU_INT_PRI_0;  ///< Offset: 0x0C - register description
        volatile uint32_t CPU_INT_PRI_1;  ///< Offset: 0x10 - register description
        volatile uint32_t CPU_INT_PRI_2;  ///< Offset: 0x14 - register description
        volatile uint32_t CPU_INT_PRI_3;  ///< Offset: 0x18 - register description
        volatile uint32_t CPU_INT_PRI_4;  ///< Offset: 0x1C - register description
        volatile uint32_t CPU_INT_PRI_5;  ///< Offset: 0x20 - register description
        volatile uint32_t CPU_INT_PRI_6;  ///< Offset: 0x24 - register description
        volatile uint32_t CPU_INT_PRI_7;  ///< Offset: 0x28 - register description
        volatile uint32_t CPU_INT_PRI_8;  ///< Offset: 0x2C - register description
        volatile uint32_t CPU_INT_PRI_9;  ///< Offset: 0x30 - register description
        volatile uint32_t CPU_INT_PRI_10;  ///< Offset: 0x34 - register description
        volatile uint32_t CPU_INT_PRI_11;  ///< Offset: 0x38 - register description
        volatile uint32_t CPU_INT_PRI_12;  ///< Offset: 0x3C - register description
        volatile uint32_t CPU_INT_PRI_13;  ///< Offset: 0x40 - register description
        volatile uint32_t CPU_INT_PRI_14;  ///< Offset: 0x44 - register description
        volatile uint32_t CPU_INT_PRI_15;  ///< Offset: 0x48 - register description
        volatile uint32_t CPU_INT_PRI_16;  ///< Offset: 0x4C - register description
        volatile uint32_t CPU_INT_PRI_17;  ///< Offset: 0x50 - register description
        volatile uint32_t CPU_INT_PRI_18;  ///< Offset: 0x54 - register description
        volatile uint32_t CPU_INT_PRI_19;  ///< Offset: 0x58 - register description
        volatile uint32_t CPU_INT_PRI_20;  ///< Offset: 0x5C - register description
        volatile uint32_t CPU_INT_PRI_21;  ///< Offset: 0x60 - register description
        volatile uint32_t CPU_INT_PRI_22;  ///< Offset: 0x64 - register description
        volatile uint32_t CPU_INT_PRI_23;  ///< Offset: 0x68 - register description
        volatile uint32_t CPU_INT_PRI_24;  ///< Offset: 0x6C - register description
        volatile uint32_t CPU_INT_PRI_25;  ///< Offset: 0x70 - register description
        volatile uint32_t CPU_INT_PRI_26;  ///< Offset: 0x74 - register description
        volatile uint32_t CPU_INT_PRI_27;  ///< Offset: 0x78 - register description
        volatile uint32_t CPU_INT_PRI_28;  ///< Offset: 0x7C - register description
        volatile uint32_t CPU_INT_PRI_29;  ///< Offset: 0x80 - register description
        volatile uint32_t CPU_INT_PRI_30;  ///< Offset: 0x84 - register description
        volatile uint32_t CPU_INT_PRI_31;  ///< Offset: 0x88 - register description
        volatile uint32_t CPU_INT_THRESH;  ///< Offset: 0x8C - register description
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x90 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x94 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x98 - register description
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x9C - register description
        volatile uint32_t DATE;  ///< Offset: 0xA0 - register description
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xA4 - register description
        volatile uint32_t CPU_INT_CLEAR;  ///< Offset: 0xA8 - register description
        volatile uint32_t RND_ECO;  ///< Offset: 0xAC - redcy eco register.
        volatile uint32_t RND_ECO_LOW;  ///< Offset: 0xB0 - redcy eco low register.
        volatile uint32_t RND_ECO_HIGH;  ///< Offset: 0x3FC - redcy eco high register.
    };

    /// Peripheral instances
    inline Registers* INTPRI = reinterpret_cast<Registers*>(INTPRI_BASE);

    // Bit definitions
    /// CPU_INT_ENABLE Register bits
    namespace cpu_int_enable_bits {
        constexpr uint32_t CPU_INT_ENABLE = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_TYPE Register bits
    namespace cpu_int_type_bits {
        constexpr uint32_t CPU_INT_TYPE = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_EIP_STATUS Register bits
    namespace cpu_int_eip_status_bits {
        constexpr uint32_t CPU_INT_EIP_STATUS = (32 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_0 Register bits
    namespace cpu_int_pri_0_bits {
        constexpr uint32_t CPU_PRI_0_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_1 Register bits
    namespace cpu_int_pri_1_bits {
        constexpr uint32_t CPU_PRI_1_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_2 Register bits
    namespace cpu_int_pri_2_bits {
        constexpr uint32_t CPU_PRI_2_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_3 Register bits
    namespace cpu_int_pri_3_bits {
        constexpr uint32_t CPU_PRI_3_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_4 Register bits
    namespace cpu_int_pri_4_bits {
        constexpr uint32_t CPU_PRI_4_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_5 Register bits
    namespace cpu_int_pri_5_bits {
        constexpr uint32_t CPU_PRI_5_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_6 Register bits
    namespace cpu_int_pri_6_bits {
        constexpr uint32_t CPU_PRI_6_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_7 Register bits
    namespace cpu_int_pri_7_bits {
        constexpr uint32_t CPU_PRI_7_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_8 Register bits
    namespace cpu_int_pri_8_bits {
        constexpr uint32_t CPU_PRI_8_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_9 Register bits
    namespace cpu_int_pri_9_bits {
        constexpr uint32_t CPU_PRI_9_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_10 Register bits
    namespace cpu_int_pri_10_bits {
        constexpr uint32_t CPU_PRI_10_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_11 Register bits
    namespace cpu_int_pri_11_bits {
        constexpr uint32_t CPU_PRI_11_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_12 Register bits
    namespace cpu_int_pri_12_bits {
        constexpr uint32_t CPU_PRI_12_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_13 Register bits
    namespace cpu_int_pri_13_bits {
        constexpr uint32_t CPU_PRI_13_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_14 Register bits
    namespace cpu_int_pri_14_bits {
        constexpr uint32_t CPU_PRI_14_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_15 Register bits
    namespace cpu_int_pri_15_bits {
        constexpr uint32_t CPU_PRI_15_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_16 Register bits
    namespace cpu_int_pri_16_bits {
        constexpr uint32_t CPU_PRI_16_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_17 Register bits
    namespace cpu_int_pri_17_bits {
        constexpr uint32_t CPU_PRI_17_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_18 Register bits
    namespace cpu_int_pri_18_bits {
        constexpr uint32_t CPU_PRI_18_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_19 Register bits
    namespace cpu_int_pri_19_bits {
        constexpr uint32_t CPU_PRI_19_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_20 Register bits
    namespace cpu_int_pri_20_bits {
        constexpr uint32_t CPU_PRI_20_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_21 Register bits
    namespace cpu_int_pri_21_bits {
        constexpr uint32_t CPU_PRI_21_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_22 Register bits
    namespace cpu_int_pri_22_bits {
        constexpr uint32_t CPU_PRI_22_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_23 Register bits
    namespace cpu_int_pri_23_bits {
        constexpr uint32_t CPU_PRI_23_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_24 Register bits
    namespace cpu_int_pri_24_bits {
        constexpr uint32_t CPU_PRI_24_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_25 Register bits
    namespace cpu_int_pri_25_bits {
        constexpr uint32_t CPU_PRI_25_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_26 Register bits
    namespace cpu_int_pri_26_bits {
        constexpr uint32_t CPU_PRI_26_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_27 Register bits
    namespace cpu_int_pri_27_bits {
        constexpr uint32_t CPU_PRI_27_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_28 Register bits
    namespace cpu_int_pri_28_bits {
        constexpr uint32_t CPU_PRI_28_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_29 Register bits
    namespace cpu_int_pri_29_bits {
        constexpr uint32_t CPU_PRI_29_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_30 Register bits
    namespace cpu_int_pri_30_bits {
        constexpr uint32_t CPU_PRI_30_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_PRI_31 Register bits
    namespace cpu_int_pri_31_bits {
        constexpr uint32_t CPU_PRI_31_MAP = (4 << 0);  ///< Need add description
    }

    /// CPU_INT_THRESH Register bits
    namespace cpu_int_thresh_bits {
        constexpr uint32_t CPU_INT_THRESH = (8 << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< Need add description
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< Need add description
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Need add description
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Need add description
    }

    /// CPU_INT_CLEAR Register bits
    namespace cpu_int_clear_bits {
        constexpr uint32_t CPU_INT_CLEAR = (32 << 0);  ///< Need add description
    }

    /// RND_ECO Register bits
    namespace rnd_eco_bits {
        constexpr uint32_t REDCY_ENA = (1U << 0);  ///< Only reserved for ECO.
        constexpr uint32_t REDCY_RESULT = (1U << 1);  ///< Only reserved for ECO.
    }

    /// RND_ECO_LOW Register bits
    namespace rnd_eco_low_bits {
        constexpr uint32_t REDCY_LOW = (32 << 0);  ///< Only reserved for ECO.
    }

    /// RND_ECO_HIGH Register bits
    namespace rnd_eco_high_bits {
        constexpr uint32_t REDCY_HIGH = (32 << 0);  ///< Only reserved for ECO.
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x60090000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - Clock Output Configuration Register
        volatile uint32_t GPIO%s;  ///< Offset: 0x04 - IO MUX Configure Register for pad GPIO0
        volatile uint32_t MODEM_DIAG_EN;  ///< Offset: 0xBC - GPIO MATRIX Configure Register for modem diag
        volatile uint32_t DATE;  ///< Offset: 0xFC - IO MUX Version Control Register
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t CLK_OUT1 = (5 << 0);  ///< If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT2 = (5 << 5);  ///< If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT3 = (5 << 10);  ///< If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
    }

    /// GPIO%s Register bits
    namespace gpio%s_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled. 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
        constexpr uint32_t HYS_EN = (1U << 16);  ///< Software enables hysteresis function for the pad. 1: Hysteresis enabled. 0: Hysteresis disabled.
        constexpr uint32_t HYS_SEL = (1U << 17);  ///< Select enabling signals of the pad from software and efuse hardware. 1: Select enabling siganl from slftware. 0: Select enabling signal from efuse hardware.
    }

    /// MODEM_DIAG_EN Register bits
    namespace modem_diag_en_bits {
        constexpr uint32_t MODEM_DIAG_EN = (32 << 0);  ///< bit i to enable modem_diag[i] into gpio matrix. 1:enable modem_diag[i] into gpio matrix. 0:enable other signals into gpio matrix
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x60008000;
    constexpr uint32_t MCPWM0_BASE = 0x60014000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for channel %s
        volatile uint32_t CH%s_HPOINT;  ///< Offset: 0x04 - High point register for channel %s
        volatile uint32_t CH%s_DUTY;  ///< Offset: 0x08 - Initial duty cycle for channel %s
        volatile uint32_t CH%s_CONF1;  ///< Offset: 0x0C - Configuration register 1 for channel %s
        volatile uint32_t CH%s_DUTY_R;  ///< Offset: 0x10 - Current duty cycle for channel %s
        volatile uint32_t TIMER%s_CONF;  ///< Offset: 0xA0 - Timer %s configuration
        volatile uint32_t TIMER%s_VALUE;  ///< Offset: 0xA4 - Timer %s current counter value
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear bits
        volatile uint32_t CH%s_GAMMA_WR;  ///< Offset: 0x100 - Ledc ch%s gamma ram write register.
        volatile uint32_t CH%s_GAMMA_WR_ADDR;  ///< Offset: 0x104 - Ledc ch%s gamma ram write address register.
        volatile uint32_t CH%s_GAMMA_RD_ADDR;  ///< Offset: 0x108 - Ledc ch%s gamma ram read address register.
        volatile uint32_t CH%s_GAMMA_RD_DATA;  ///< Offset: 0x10C - Ledc ch%s gamma ram read data register.
        volatile uint32_t CH%s_GAMMA_CONF;  ///< Offset: 0x180 - Ledc ch%s gamma config register.
        volatile uint32_t EVT_TASK_EN0;  ///< Offset: 0x1A0 - Ledc event task enable bit register0.
        volatile uint32_t EVT_TASK_EN1;  ///< Offset: 0x1A4 - Ledc event task enable bit register1.
        volatile uint32_t EVT_TASK_EN2;  ///< Offset: 0x1A8 - Ledc event task enable bit register2.
        volatile uint32_t TIMER%s_CMP;  ///< Offset: 0x1B0 - Ledc timer%s compare value register.
        volatile uint32_t TIMER%s_CNT_CAP;  ///< Offset: 0x1C0 - Ledc timer%s count value capture register.
        volatile uint32_t CONF;  ///< Offset: 0x1F0 - Global ledc configuration register
        volatile uint32_t DATE;  ///< Offset: 0x1FC - Version control register
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);
    inline Registers* MCPWM0 = reinterpret_cast<Registers*>(MCPWM0_BASE);

    // Bit definitions
    /// CH%s_CONF0 Register bits
    namespace ch%s_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< This field is used to select one of timers for channel %s. 0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< Set this bit to enable signal output on channel %s.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
        constexpr uint32_t PARA_UP = (1U << 4);  ///< This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
        constexpr uint32_t OVF_NUM = (10 << 5);  ///< This register is used to configure the maximum times of overflow minus 1. The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
        constexpr uint32_t OVF_CNT_EN = (1U << 15);  ///< This bit is used to enable the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET = (1U << 16);  ///< Set this bit to reset the ovf_cnt of channel %s.
    }

    /// CH%s_HPOINT Register bits
    namespace ch%s_hpoint_bits {
        constexpr uint32_t HPOINT = (20 << 0);  ///< The output value changes to high when the selected timers has reached the value specified by this register.
    }

    /// CH%s_DUTY Register bits
    namespace ch%s_duty_bits {
        constexpr uint32_t DUTY = (25 << 0);  ///< This register is used to change the output duty by controlling the Lpoint. The output value turns to low when the selected timers has reached the Lpoint.
    }

    /// CH%s_CONF1 Register bits
    namespace ch%s_conf1_bits {
        constexpr uint32_t DUTY_START = (1U << 31);  ///< Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
    }

    /// CH%s_DUTY_R Register bits
    namespace ch%s_duty_r_bits {
        constexpr uint32_t DUTY_CH_R = (25 << 0);  ///< This register stores the current duty of output signal on channel %s.
    }

    /// TIMER%s_CONF Register bits
    namespace timer%s_conf_bits {
        constexpr uint32_t DUTY_RES = (5 << 0);  ///< This register is used to control the range of the counter in timer %s.
        constexpr uint32_t CLK_DIV = (18 << 5);  ///< This register is used to configure the divisor for the divider in timer %s. The least significant eight bits represent the fractional part.
        constexpr uint32_t PAUSE = (1U << 23);  ///< This bit is used to suspend the counter in timer %s.
        constexpr uint32_t RST = (1U << 24);  ///< This bit is used to reset timer %s. The counter will show 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 25);  ///< This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate. 1'h0: SLOW_CLK 1'h1: REF_TICK
        constexpr uint32_t PARA_UP = (1U << 26);  ///< Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
    }

    /// TIMER%s_VALUE Register bits
    namespace timer%s_value_bits {
        constexpr uint32_t TIMER_CNT = (20 << 0);  ///< This register stores the current counter value of timer %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TIMER0_OVF_INT_RAW = (1U << 0);  ///< Triggered when the timer0 has reached its maximum counter value.
        constexpr uint32_t TIMER1_OVF_INT_RAW = (1U << 1);  ///< Triggered when the timer1 has reached its maximum counter value.
        constexpr uint32_t TIMER2_OVF_INT_RAW = (1U << 2);  ///< Triggered when the timer2 has reached its maximum counter value.
        constexpr uint32_t TIMER3_OVF_INT_RAW = (1U << 3);  ///< Triggered when the timer3 has reached its maximum counter value.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_RAW = (1U << 4);  ///< Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_RAW = (1U << 5);  ///< Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_RAW = (1U << 6);  ///< Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_RAW = (1U << 7);  ///< Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_RAW = (1U << 8);  ///< Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_RAW = (1U << 9);  ///< Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
        constexpr uint32_t OVF_CNT_CH0_INT_RAW = (1U << 12);  ///< Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
        constexpr uint32_t OVF_CNT_CH1_INT_RAW = (1U << 13);  ///< Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
        constexpr uint32_t OVF_CNT_CH2_INT_RAW = (1U << 14);  ///< Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
        constexpr uint32_t OVF_CNT_CH3_INT_RAW = (1U << 15);  ///< Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
        constexpr uint32_t OVF_CNT_CH4_INT_RAW = (1U << 16);  ///< Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
        constexpr uint32_t OVF_CNT_CH5_INT_RAW = (1U << 17);  ///< Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TIMER0_OVF_INT_ST = (1U << 0);  ///< This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER1_OVF_INT_ST = (1U << 1);  ///< This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER2_OVF_INT_ST = (1U << 2);  ///< This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER3_OVF_INT_ST = (1U << 3);  ///< This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ST = (1U << 4);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ST = (1U << 5);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ST = (1U << 6);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ST = (1U << 7);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ST = (1U << 8);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ST = (1U << 9);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH0_INT_ST = (1U << 12);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH1_INT_ST = (1U << 13);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH2_INT_ST = (1U << 14);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH3_INT_ST = (1U << 15);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH4_INT_ST = (1U << 16);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH5_INT_ST = (1U << 17);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TIMER0_OVF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_ENA = (1U << 16);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_ENA = (1U << 17);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TIMER0_OVF_INT_CLR = (1U << 0);  ///< Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_CLR = (1U << 1);  ///< Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_CLR = (1U << 3);  ///< Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_CLR = (1U << 4);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_CLR = (1U << 5);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_CLR = (1U << 6);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_CLR = (1U << 7);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_CLR = (1U << 8);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_CLR = (1U << 9);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_CLR = (1U << 12);  ///< Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_CLR = (1U << 13);  ///< Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_CLR = (1U << 14);  ///< Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_CLR = (1U << 15);  ///< Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_CLR = (1U << 16);  ///< Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_CLR = (1U << 17);  ///< Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
    }

    /// CH%s_GAMMA_WR Register bits
    namespace ch%s_gamma_wr_bits {
        constexpr uint32_t CH_GAMMA_DUTY_INC = (1U << 0);  ///< Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase 0: Decrease.
        constexpr uint32_t CH_GAMMA_DUTY_CYCLE = (10 << 1);  ///< Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
        constexpr uint32_t CH_GAMMA_SCALE = (10 << 11);  ///< Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
        constexpr uint32_t CH_GAMMA_DUTY_NUM = (10 << 21);  ///< Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
    }

    /// CH%s_GAMMA_WR_ADDR Register bits
    namespace ch%s_gamma_wr_addr_bits {
        constexpr uint32_t CH_GAMMA_WR_ADDR = (4 << 0);  ///< Ledc ch%s gamma ram write address.
    }

    /// CH%s_GAMMA_RD_ADDR Register bits
    namespace ch%s_gamma_rd_addr_bits {
        constexpr uint32_t CH_GAMMA_RD_ADDR = (4 << 0);  ///< Ledc ch%s gamma ram read address.
    }

    /// CH%s_GAMMA_RD_DATA Register bits
    namespace ch%s_gamma_rd_data_bits {
        constexpr uint32_t CH_GAMMA_RD_DATA = (31 << 0);  ///< Ledc ch%s gamma ram read data.
    }

    /// CH%s_GAMMA_CONF Register bits
    namespace ch%s_gamma_conf_bits {
        constexpr uint32_t CH_GAMMA_ENTRY_NUM = (5 << 0);  ///< Ledc ch%s gamma entry num.
        constexpr uint32_t CH_GAMMA_PAUSE = (1U << 5);  ///< Ledc ch%s gamma pause, write 1 to pause.
        constexpr uint32_t CH_GAMMA_RESUME = (1U << 6);  ///< Ledc ch%s gamma resume, write 1 to resume.
    }

    /// EVT_TASK_EN0 Register bits
    namespace evt_task_en0_bits {
        constexpr uint32_t EVT_DUTY_CHNG_END_CH0_EN = (1U << 0);  ///< Ledc ch0 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_DUTY_CHNG_END_CH1_EN = (1U << 1);  ///< Ledc ch1 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_DUTY_CHNG_END_CH2_EN = (1U << 2);  ///< Ledc ch2 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_DUTY_CHNG_END_CH3_EN = (1U << 3);  ///< Ledc ch3 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_DUTY_CHNG_END_CH4_EN = (1U << 4);  ///< Ledc ch4 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_DUTY_CHNG_END_CH5_EN = (1U << 5);  ///< Ledc ch5 duty change end event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH0_EN = (1U << 8);  ///< Ledc ch0 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH1_EN = (1U << 9);  ///< Ledc ch1 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH2_EN = (1U << 10);  ///< Ledc ch2 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH3_EN = (1U << 11);  ///< Ledc ch3 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH4_EN = (1U << 12);  ///< Ledc ch4 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_OVF_CNT_PLS_CH5_EN = (1U << 13);  ///< Ledc ch5 overflow count pulse event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME_OVF_TIMER0_EN = (1U << 16);  ///< Ledc timer0 overflow event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME_OVF_TIMER1_EN = (1U << 17);  ///< Ledc timer1 overflow event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME_OVF_TIMER2_EN = (1U << 18);  ///< Ledc timer2 overflow event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME_OVF_TIMER3_EN = (1U << 19);  ///< Ledc timer3 overflow event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME0_CMP_EN = (1U << 20);  ///< Ledc timer0 compare event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME1_CMP_EN = (1U << 21);  ///< Ledc timer1 compare event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME2_CMP_EN = (1U << 22);  ///< Ledc timer2 compare event enable register, write 1 to enable this event.
        constexpr uint32_t EVT_TIME3_CMP_EN = (1U << 23);  ///< Ledc timer3 compare event enable register, write 1 to enable this event.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH0_EN = (1U << 24);  ///< Ledc ch0 duty scale update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH1_EN = (1U << 25);  ///< Ledc ch1 duty scale update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH2_EN = (1U << 26);  ///< Ledc ch2 duty scale update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH3_EN = (1U << 27);  ///< Ledc ch3 duty scale update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH4_EN = (1U << 28);  ///< Ledc ch4 duty scale update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH5_EN = (1U << 29);  ///< Ledc ch5 duty scale update task enable register, write 1 to enable this task.
    }

    /// EVT_TASK_EN1 Register bits
    namespace evt_task_en1_bits {
        constexpr uint32_t TASK_TIMER0_RES_UPDATE_EN = (1U << 0);  ///< Ledc timer0 res update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER1_RES_UPDATE_EN = (1U << 1);  ///< Ledc timer1 res update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER2_RES_UPDATE_EN = (1U << 2);  ///< Ledc timer2 res update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER3_RES_UPDATE_EN = (1U << 3);  ///< Ledc timer3 res update task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER0_CAP_EN = (1U << 4);  ///< Ledc timer0 capture task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER1_CAP_EN = (1U << 5);  ///< Ledc timer1 capture task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER2_CAP_EN = (1U << 6);  ///< Ledc timer2 capture task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER3_CAP_EN = (1U << 7);  ///< Ledc timer3 capture task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH0_EN = (1U << 8);  ///< Ledc ch0 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH1_EN = (1U << 9);  ///< Ledc ch1 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH2_EN = (1U << 10);  ///< Ledc ch2 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH3_EN = (1U << 11);  ///< Ledc ch3 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH4_EN = (1U << 12);  ///< Ledc ch4 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_SIG_OUT_DIS_CH5_EN = (1U << 13);  ///< Ledc ch5 signal out disable task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH0_EN = (1U << 16);  ///< Ledc ch0 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH1_EN = (1U << 17);  ///< Ledc ch1 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH2_EN = (1U << 18);  ///< Ledc ch2 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH3_EN = (1U << 19);  ///< Ledc ch3 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH4_EN = (1U << 20);  ///< Ledc ch4 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_OVF_CNT_RST_CH5_EN = (1U << 21);  ///< Ledc ch5 overflow count reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER0_RST_EN = (1U << 24);  ///< Ledc timer0 reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER1_RST_EN = (1U << 25);  ///< Ledc timer1 reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER2_RST_EN = (1U << 26);  ///< Ledc timer2 reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER3_RST_EN = (1U << 27);  ///< Ledc timer3 reset task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER0_PAUSE_RESUME_EN = (1U << 28);  ///< Ledc timer0 pause resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER1_PAUSE_RESUME_EN = (1U << 29);  ///< Ledc timer1 pause resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER2_PAUSE_RESUME_EN = (1U << 30);  ///< Ledc timer2 pause resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_TIMER3_PAUSE_RESUME_EN = (1U << 31);  ///< Ledc timer3 pause resume task enable register, write 1 to enable this task.
    }

    /// EVT_TASK_EN2 Register bits
    namespace evt_task_en2_bits {
        constexpr uint32_t TASK_GAMMA_RESTART_CH0_EN = (1U << 0);  ///< Ledc ch0 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESTART_CH1_EN = (1U << 1);  ///< Ledc ch1 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESTART_CH2_EN = (1U << 2);  ///< Ledc ch2 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESTART_CH3_EN = (1U << 3);  ///< Ledc ch3 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESTART_CH4_EN = (1U << 4);  ///< Ledc ch4 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESTART_CH5_EN = (1U << 5);  ///< Ledc ch5 gamma restart task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH0_EN = (1U << 8);  ///< Ledc ch0 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH1_EN = (1U << 9);  ///< Ledc ch1 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH2_EN = (1U << 10);  ///< Ledc ch2 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH3_EN = (1U << 11);  ///< Ledc ch3 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH4_EN = (1U << 12);  ///< Ledc ch4 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_PAUSE_CH5_EN = (1U << 13);  ///< Ledc ch5 gamma pause task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH0_EN = (1U << 16);  ///< Ledc ch0 gamma resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH1_EN = (1U << 17);  ///< Ledc ch1 gamma resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH2_EN = (1U << 18);  ///< Ledc ch2 gamma resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH3_EN = (1U << 19);  ///< Ledc ch3 gamma resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH4_EN = (1U << 20);  ///< Ledc ch4 gamma resume task enable register, write 1 to enable this task.
        constexpr uint32_t TASK_GAMMA_RESUME_CH5_EN = (1U << 21);  ///< Ledc ch5 gamma resume task enable register, write 1 to enable this task.
    }

    /// TIMER%s_CMP Register bits
    namespace timer%s_cmp_bits {
        constexpr uint32_t TIMER_CMP = (20 << 0);  ///< This register stores ledc timer%s compare value.
    }

    /// TIMER%s_CNT_CAP Register bits
    namespace timer%s_cnt_cap_bits {
        constexpr uint32_t TIMER_CNT_CAP = (20 << 0);  ///< This register stores ledc timer%s count value.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< This bit is used to select clock source for the 4 timers . 2'd1: APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH0 = (1U << 2);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH1 = (1U << 3);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH2 = (1U << 4);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH3 = (1U << 5);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH4 = (1U << 6);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH5 = (1U << 7);  ///< This bit is used to control clock. 1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< This bit is used to control clock. 1'b1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LEDC_DATE = (28 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// LP Peripheral
// ============================================================================

namespace lp {
    /// Base addresses
    constexpr uint32_t LP_PERI_BASE = 0x600B2800;
    constexpr uint32_t LP_ANA_BASE = 0x600B2C00;
    constexpr uint32_t LP_AON_BASE = 0x600B1000;
    constexpr uint32_t LP_APM_BASE = 0x600B3800;
    constexpr uint32_t LP_CLKRST_BASE = 0x600B0400;

    /// LP Register structure
    struct Registers {
        volatile uint32_t CLK_EN;  ///< Offset: 0x00 - need_des
        volatile uint32_t RESET_EN;  ///< Offset: 0x04 - need_des
        volatile uint32_t RNG_DATA;  ///< Offset: 0x08 - need_des
        volatile uint32_t CPU;  ///< Offset: 0x0C - need_des
        volatile uint32_t BUS_TIMEOUT;  ///< Offset: 0x10 - need_des
        volatile uint32_t BUS_TIMEOUT_ADDR;  ///< Offset: 0x14 - need_des
        volatile uint32_t BUS_TIMEOUT_UID;  ///< Offset: 0x18 - need_des
        volatile uint32_t MEM_CTRL;  ///< Offset: 0x1C - need_des
        volatile uint32_t INTERRUPT_SOURCE;  ///< Offset: 0x20 - need_des
        volatile uint32_t DEBUG_SEL0;  ///< Offset: 0x24 - need des
        volatile uint32_t DEBUG_SEL1;  ///< Offset: 0x28 - need des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_PERI = reinterpret_cast<Registers*>(LP_PERI_BASE);
    inline Registers* LP_ANA = reinterpret_cast<Registers*>(LP_ANA_BASE);
    inline Registers* LP_AON = reinterpret_cast<Registers*>(LP_AON_BASE);
    inline Registers* LP_APM = reinterpret_cast<Registers*>(LP_APM_BASE);
    inline Registers* LP_CLKRST = reinterpret_cast<Registers*>(LP_CLKRST_BASE);

    // Bit definitions
    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t RNG_CK_EN = (1U << 24);  ///< need_des
        constexpr uint32_t OTP_DBG_CK_EN = (1U << 25);  ///< need_des
        constexpr uint32_t LP_UART_CK_EN = (1U << 26);  ///< need_des
        constexpr uint32_t LP_IO_CK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t LP_EXT_I2C_CK_EN = (1U << 28);  ///< need_des
        constexpr uint32_t LP_ANA_I2C_CK_EN = (1U << 29);  ///< need_des
        constexpr uint32_t EFUSE_CK_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_CK_EN = (1U << 31);  ///< need_des
    }

    /// RESET_EN Register bits
    namespace reset_en_bits {
        constexpr uint32_t BUS_RESET_EN = (1U << 23);  ///< need_des
        constexpr uint32_t LP_BLE_TIMER_RESET_EN = (1U << 24);  ///< need_des
        constexpr uint32_t OTP_DBG_RESET_EN = (1U << 25);  ///< need_des
        constexpr uint32_t LP_UART_RESET_EN = (1U << 26);  ///< need_des
        constexpr uint32_t LP_IO_RESET_EN = (1U << 27);  ///< need_des
        constexpr uint32_t LP_EXT_I2C_RESET_EN = (1U << 28);  ///< need_des
        constexpr uint32_t LP_ANA_I2C_RESET_EN = (1U << 29);  ///< need_des
        constexpr uint32_t EFUSE_RESET_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_RESET_EN = (1U << 31);  ///< need_des
    }

    /// RNG_DATA Register bits
    namespace rng_data_bits {
        constexpr uint32_t RND_DATA = (32 << 0);  ///< need_des
    }

    /// CPU Register bits
    namespace cpu_bits {
        constexpr uint32_t LPCORE_DBGM_UNAVALIABLE = (1U << 31);  ///< need_des
    }

    /// BUS_TIMEOUT Register bits
    namespace bus_timeout_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_THRES = (16 << 14);  ///< need_des
        constexpr uint32_t LP_PERI_TIMEOUT_INT_CLEAR = (1U << 30);  ///< need_des
        constexpr uint32_t LP_PERI_TIMEOUT_PROTECT_EN = (1U << 31);  ///< need_des
    }

    /// BUS_TIMEOUT_ADDR Register bits
    namespace bus_timeout_addr_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_ADDR = (32 << 0);  ///< need_des
    }

    /// BUS_TIMEOUT_UID Register bits
    namespace bus_timeout_uid_bits {
        constexpr uint32_t LP_PERI_TIMEOUT_UID = (7 << 0);  ///< need_des
    }

    /// MEM_CTRL Register bits
    namespace mem_ctrl_bits {
        constexpr uint32_t UART_WAKEUP_FLAG_CLR = (1U << 0);  ///< need_des
        constexpr uint32_t UART_WAKEUP_FLAG = (1U << 1);  ///< need_des
        constexpr uint32_t UART_WAKEUP_EN = (1U << 29);  ///< need_des
        constexpr uint32_t UART_MEM_FORCE_PD = (1U << 30);  ///< need_des
        constexpr uint32_t UART_MEM_FORCE_PU = (1U << 31);  ///< need_des
    }

    /// INTERRUPT_SOURCE Register bits
    namespace interrupt_source_bits {
        constexpr uint32_t LP_INTERRUPT_SOURCE = (6 << 0);  ///< BIT5~BIT0: pmu_lp_int, modem_lp_int, lp_timer_lp_int, lp_uart_int, lp_i2c_int, lp_io_int
    }

    /// DEBUG_SEL0 Register bits
    namespace debug_sel0_bits {
        constexpr uint32_t DEBUG_SEL0 = (7 << 0);  ///< need des
        constexpr uint32_t DEBUG_SEL1 = (7 << 7);  ///< need des
        constexpr uint32_t DEBUG_SEL2 = (7 << 14);  ///< need des
        constexpr uint32_t DEBUG_SEL3 = (7 << 21);  ///< need des
    }

    /// DEBUG_SEL1 Register bits
    namespace debug_sel1_bits {
        constexpr uint32_t DEBUG_SEL4 = (7 << 0);  ///< need des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LPPERI_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LP_TIMER_BASE = 0x600B0C00;
    constexpr uint32_t SYSTIMER_BASE = 0x6000B000;
    constexpr uint32_t TIMG0_BASE = 0x60009000;
    constexpr uint32_t TIMG1_BASE = 0x6000A000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TAR0_LOW;  ///< Offset: 0x00 - need_des
        volatile uint32_t TAR0_HIGH;  ///< Offset: 0x04 - need_des
        volatile uint32_t UPDATE;  ///< Offset: 0x10 - need_des
        volatile uint32_t MAIN_BUF0_LOW;  ///< Offset: 0x14 - need_des
        volatile uint32_t MAIN_BUF0_HIGH;  ///< Offset: 0x18 - need_des
        volatile uint32_t MAIN_BUF1_LOW;  ///< Offset: 0x1C - need_des
        volatile uint32_t MAIN_BUF1_HIGH;  ///< Offset: 0x20 - need_des
        volatile uint32_t MAIN_OVERFLOW;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ST;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_ENA;  ///< Offset: 0x30 - need_des
        volatile uint32_t INT_CLR;  ///< Offset: 0x34 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_TIMER = reinterpret_cast<Registers*>(LP_TIMER_BASE);
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// TAR0_LOW Register bits
    namespace tar0_low_bits {
        constexpr uint32_t MAIN_TIMER_TAR_LOW0 = (32 << 0);  ///< need_des
    }

    /// TAR0_HIGH Register bits
    namespace tar0_high_bits {
        constexpr uint32_t MAIN_TIMER_TAR_HIGH0 = (16 << 0);  ///< need_des
        constexpr uint32_t MAIN_TIMER_TAR_EN0 = (1U << 31);  ///< need_des
    }

    /// UPDATE Register bits
    namespace update_bits {
        constexpr uint32_t MAIN_TIMER_UPDATE = (1U << 28);  ///< need_des
        constexpr uint32_t MAIN_TIMER_XTAL_OFF = (1U << 29);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_STALL = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_RST = (1U << 31);  ///< need_des
    }

    /// MAIN_BUF0_LOW Register bits
    namespace main_buf0_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF0_HIGH Register bits
    namespace main_buf0_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_BUF1_LOW Register bits
    namespace main_buf1_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF1_HIGH Register bits
    namespace main_buf1_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_OVERFLOW Register bits
    namespace main_overflow_bits {
        constexpr uint32_t MAIN_TIMER_ALARM_LOAD = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t OVERFLOW_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t OVERFLOW_ST = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t OVERFLOW_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t OVERFLOW_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t LP_WDT_BASE = 0x600B1C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDTCONFIG0;  ///< Offset: 0x00 - need_des
        volatile uint32_t CONFIG1;  ///< Offset: 0x04 - need_des
        volatile uint32_t CONFIG2;  ///< Offset: 0x08 - need_des
        volatile uint32_t CONFIG3;  ///< Offset: 0x0C - need_des
        volatile uint32_t CONFIG4;  ///< Offset: 0x10 - need_des
        volatile uint32_t CONFIG5;  ///< Offset: 0x14 - need_des
        volatile uint32_t WDTFEED;  ///< Offset: 0x18 - need_des
        volatile uint32_t WDTWPROTECT;  ///< Offset: 0x1C - need_des
        volatile uint32_t SWD_CONF;  ///< Offset: 0x20 - need_des
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ST_RTC;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_ENA_RTC;  ///< Offset: 0x30 - need_des
        volatile uint32_t INT_CLR_RTC;  ///< Offset: 0x34 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_WDT = reinterpret_cast<Registers*>(LP_WDT_BASE);

    // Bit definitions
    /// WDTCONFIG0 Register bits
    namespace wdtconfig0_bits {
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< need_des
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 10);  ///< need_des
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< need_des
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< need_des
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< need_des
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< need_des
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< need_des
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< need_des
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< need_des
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< need_des
        constexpr uint32_t WDT_EN = (1U << 31);  ///< need_des
    }

    /// CONFIG1 Register bits
    namespace config1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG2 Register bits
    namespace config2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG3 Register bits
    namespace config3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG4 Register bits
    namespace config4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG5 Register bits
    namespace config5_bits {
        constexpr uint32_t CHIP_RESET_TARGET = (8 << 0);  ///< need_des
        constexpr uint32_t CHIP_RESET_EN = (1U << 8);  ///< need_des
        constexpr uint32_t CHIP_RESET_KEY = (8 << 9);  ///< need_des
    }

    /// WDTFEED Register bits
    namespace wdtfeed_bits {
        constexpr uint32_t RTC_WDT_FEED = (1U << 31);  ///< need_des
    }

    /// WDTWPROTECT Register bits
    namespace wdtwprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< need_des
    }

    /// SWD_CONF Register bits
    namespace swd_conf_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< need_des
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 18);  ///< need_des
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 19);  ///< need_des
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 20);  ///< need_des
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< need_des
        constexpr uint32_t SWD_FEED = (1U << 31);  ///< need_des
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t SUPER_WDT_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST_RTC Register bits
    namespace int_st_rtc_bits {
        constexpr uint32_t SUPER_WDT_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t WDT_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA_RTC Register bits
    namespace int_ena_rtc_bits {
        constexpr uint32_t SUPER_WDT_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t WDT_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR_RTC Register bits
    namespace int_clr_rtc_bits {
        constexpr uint32_t SUPER_WDT_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t WDT_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LP_WDT_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// MEM Peripheral
// ============================================================================

namespace mem {
    /// Base addresses
    constexpr uint32_t MEM_MONITOR_BASE = 0x60092000;

    /// MEM Register structure
    struct Registers {
        volatile uint32_t LOG_SETTING;  ///< Offset: 0x00 - log config regsiter
        volatile uint32_t LOG_CHECK_DATA;  ///< Offset: 0x04 - check data regsiter
        volatile uint32_t LOG_DATA_MASK;  ///< Offset: 0x08 - check data mask register
        volatile uint32_t LOG_MIN;  ///< Offset: 0x0C - log boundary regsiter
        volatile uint32_t LOG_MAX;  ///< Offset: 0x10 - log boundary regsiter
        volatile uint32_t LOG_MEM_START;  ///< Offset: 0x14 - log message store range register
        volatile uint32_t LOG_MEM_END;  ///< Offset: 0x18 - log message store range register
        volatile uint32_t LOG_MEM_CURRENT_ADDR;  ///< Offset: 0x1C - current writing address.
        volatile uint32_t LOG_MEM_ADDR_UPDATE;  ///< Offset: 0x20 - writing address update
        volatile uint32_t LOG_MEM_FULL_FLAG;  ///< Offset: 0x24 - full flag status register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x28 - clock gate force on register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - version register
    };

    /// Peripheral instances
    inline Registers* MEM_MONITOR = reinterpret_cast<Registers*>(MEM_MONITOR_BASE);

    // Bit definitions
    /// LOG_SETTING Register bits
    namespace log_setting_bits {
        constexpr uint32_t LOG_ENA = (3 << 0);  ///< enable bus log. BIT0: hp-cpu, BIT1: lp-cpu, BIT2: DMA.823 don't support lp-cpu
        constexpr uint32_t LOG_MODE = (4 << 3);  ///< This field must be onehot. 4'b0001 : WR monitor, 4'b0010: WORD monitor, 4'b0100: HALFWORD monitor, 4'b1000: BYTE monitor.
        constexpr uint32_t LOG_MEM_LOOP_ENABLE = (1U << 7);  ///< Set 1 enable mem_loop, it will loop write at the range of MEM_START and MEM_END
    }

    /// LOG_CHECK_DATA Register bits
    namespace log_check_data_bits {
        constexpr uint32_t LOG_CHECK_DATA = (32 << 0);  ///< The special check data, when write this special data, it will trigger logging.
    }

    /// LOG_DATA_MASK Register bits
    namespace log_data_mask_bits {
        constexpr uint32_t LOG_DATA_MASK = (4 << 0);  ///< byte mask enable, BIT0 mask the first byte of MEM_MONITOR_LOG_CHECK_DATA, and BIT1 mask second byte, and so on.
    }

    /// LOG_MIN Register bits
    namespace log_min_bits {
        constexpr uint32_t LOG_MIN = (32 << 0);  ///< the min address of log range
    }

    /// LOG_MAX Register bits
    namespace log_max_bits {
        constexpr uint32_t LOG_MAX = (32 << 0);  ///< the max address of log range
    }

    /// LOG_MEM_START Register bits
    namespace log_mem_start_bits {
        constexpr uint32_t LOG_MEM_START = (32 << 0);  ///< the start address of writing logging message
    }

    /// LOG_MEM_END Register bits
    namespace log_mem_end_bits {
        constexpr uint32_t LOG_MEM_END = (32 << 0);  ///< the end address of writing logging message
    }

    /// LOG_MEM_CURRENT_ADDR Register bits
    namespace log_mem_current_addr_bits {
        constexpr uint32_t LOG_MEM_CURRENT_ADDR = (32 << 0);  ///< means next writing address
    }

    /// LOG_MEM_ADDR_UPDATE Register bits
    namespace log_mem_addr_update_bits {
        constexpr uint32_t LOG_MEM_ADDR_UPDATE = (1U << 0);  ///< Set 1 to updata MEM_MONITOR_LOG_MEM_CURRENT_ADDR, when set 1, MEM_MONITOR_LOG_MEM_CURRENT_ADDR will update to MEM_MONITOR_LOG_MEM_START
    }

    /// LOG_MEM_FULL_FLAG Register bits
    namespace log_mem_full_flag_bits {
        constexpr uint32_t LOG_MEM_FULL_FLAG = (1U << 0);  ///< 1 means memory write loop at least one time at the range of MEM_START and MEM_END
        constexpr uint32_t CLR_LOG_MEM_FULL_FLAG = (1U << 1);  ///< Set 1 to clr MEM_MONITOR_LOG_MEM_FULL_FLAG
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Set 1 to force on the clk of mem_monitor register
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// MODEM Peripheral
// ============================================================================

namespace modem {
    /// Base addresses
    constexpr uint32_t MODEM_LPCON_BASE = 0x600AD000;
    constexpr uint32_t MODEM_SYSCON_BASE = 0x600A5400;

    /// MODEM Register structure
    struct Registers {
        volatile uint32_t TEST_CONF;  ///< Offset: 0x00 - 
        volatile uint32_t COEX_LP_CLK_CONF;  ///< Offset: 0x04 - 
        volatile uint32_t CLK_CONF;  ///< Offset: 0x08 - 
        volatile uint32_t CLK_CONF_FORCE_ON;  ///< Offset: 0x0C - 
        volatile uint32_t TICK_CONF;  ///< Offset: 0x10 - 
        volatile uint32_t RST_CONF;  ///< Offset: 0x14 - 
        volatile uint32_t MEM_CONF;  ///< Offset: 0x18 - 
        volatile uint32_t DATE;  ///< Offset: 0x1C - 
    };

    /// Peripheral instances
    inline Registers* MODEM_LPCON = reinterpret_cast<Registers*>(MODEM_LPCON_BASE);
    inline Registers* MODEM_SYSCON = reinterpret_cast<Registers*>(MODEM_SYSCON_BASE);

    // Bit definitions
    /// TEST_CONF Register bits
    namespace test_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< CLK_EN
    }

    /// COEX_LP_CLK_CONF Register bits
    namespace coex_lp_clk_conf_bits {
        constexpr uint32_t CLK_COEX_LP_SEL_OSC_SLOW = (1U << 0);  ///< CLK_COEX_LP_SEL_OSC_SLOW
        constexpr uint32_t CLK_COEX_LP_SEL_OSC_FAST = (1U << 1);  ///< CLK_COEX_LP_SEL_OSC_FAST
        constexpr uint32_t CLK_COEX_LP_SEL_XTAL = (1U << 2);  ///< CLK_COEX_LP_SEL_XTAL
        constexpr uint32_t CLK_COEX_LP_SEL_XTAL32K = (1U << 3);  ///< CLK_COEX_LP_SEL_XTAL32K
        constexpr uint32_t CLK_COEX_LP_DIV_NUM = (12 << 4);  ///< CLK_COEX_LP_DIV_NUM
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t CLK_COEX_EN = (1U << 1);  ///< CLK_COEX_EN
        constexpr uint32_t CLK_I2C_MST_EN = (1U << 2);  ///< CLK_I2C_MST_EN
        constexpr uint32_t CLK_FE_MEM_EN = (1U << 5);  ///< CLK_FE_MEM_EN
    }

    /// CLK_CONF_FORCE_ON Register bits
    namespace clk_conf_force_on_bits {
        constexpr uint32_t CLK_COEX_FO = (1U << 1);  ///< CLK_COEX_FO
        constexpr uint32_t CLK_I2C_MST_FO = (1U << 2);  ///< CLK_I2C_MST_FO
        constexpr uint32_t CLK_FE_MEM_FO = (1U << 5);  ///< CLK_FE_MEM_FO
    }

    /// TICK_CONF Register bits
    namespace tick_conf_bits {
        constexpr uint32_t PWR_TICK_TARGET = (6 << 0);  ///< PWR_TICK_TARGET
    }

    /// RST_CONF Register bits
    namespace rst_conf_bits {
        constexpr uint32_t RST_COEX = (1U << 1);  ///< RST_COEX
        constexpr uint32_t RST_I2C_MST = (1U << 2);  ///< RST_I2C_MST
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 2);  ///< AGC_MEM_FORCE_PU
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 3);  ///< AGC_MEM_FORCE_PD
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 4);  ///< PBUS_MEM_FORCE_PU
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 5);  ///< PBUS_MEM_FORCE_PD
        constexpr uint32_t I2C_MST_MEM_FORCE_PU = (1U << 8);  ///< I2C_MST_MEM_FORCE_PU
        constexpr uint32_t I2C_MST_MEM_FORCE_PD = (1U << 9);  ///< I2C_MST_MEM_FORCE_PD
        constexpr uint32_t CHAN_FREQ_MEM_FORCE_PU = (1U << 10);  ///< CHAN_FREQ_MEM_FORCE_PU
        constexpr uint32_t CHAN_FREQ_MEM_FORCE_PD = (1U << 11);  ///< CHAN_FREQ_MEM_FORCE_PD
        constexpr uint32_t MODEM_PWR_MEM_WP = (3 << 12);  ///< MODEM_PWR_MEM_WP
        constexpr uint32_t MODEM_PWR_MEM_WA = (3 << 15);  ///< MODEM_PWR_MEM_WA
        constexpr uint32_t MODEM_PWR_MEM_RA = (2 << 18);  ///< MODEM_PWR_MEM_RA
        constexpr uint32_t MODEM_PWR_MEM_RM = (4 << 20);  ///< MODEM_PWR_MEM_RM
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< DATE
    }

}

// ============================================================================
// OTP Peripheral
// ============================================================================

namespace otp {
    /// Base addresses
    constexpr uint32_t OTP_DEBUG_BASE = 0x600B3C00;

    /// OTP Register structure
    struct Registers {
        volatile uint32_t WR_DIS;  ///< Offset: 0x00 - Otp debuger block0 data register1.
        volatile uint32_t BLK0_BACKUP1_W1;  ///< Offset: 0x04 - Otp debuger block0 data register2.
        volatile uint32_t BLK0_BACKUP1_W2;  ///< Offset: 0x08 - Otp debuger block0 data register3.
        volatile uint32_t BLK0_BACKUP1_W3;  ///< Offset: 0x0C - Otp debuger block0 data register4.
        volatile uint32_t BLK0_BACKUP1_W4;  ///< Offset: 0x10 - Otp debuger block0 data register5.
        volatile uint32_t BLK0_BACKUP1_W5;  ///< Offset: 0x14 - Otp debuger block0 data register6.
        volatile uint32_t BLK0_BACKUP2_W1;  ///< Offset: 0x18 - Otp debuger block0 data register7.
        volatile uint32_t BLK0_BACKUP2_W2;  ///< Offset: 0x1C - Otp debuger block0 data register8.
        volatile uint32_t BLK0_BACKUP2_W3;  ///< Offset: 0x20 - Otp debuger block0 data register9.
        volatile uint32_t BLK0_BACKUP2_W4;  ///< Offset: 0x24 - Otp debuger block0 data register10.
        volatile uint32_t BLK0_BACKUP2_W5;  ///< Offset: 0x28 - Otp debuger block0 data register11.
        volatile uint32_t BLK0_BACKUP3_W1;  ///< Offset: 0x2C - Otp debuger block0 data register12.
        volatile uint32_t BLK0_BACKUP3_W2;  ///< Offset: 0x30 - Otp debuger block0 data register13.
        volatile uint32_t BLK0_BACKUP3_W3;  ///< Offset: 0x34 - Otp debuger block0 data register14.
        volatile uint32_t BLK0_BACKUP3_W4;  ///< Offset: 0x38 - Otp debuger block0 data register15.
        volatile uint32_t BLK0_BACKUP3_W5;  ///< Offset: 0x3C - Otp debuger block0 data register16.
        volatile uint32_t BLK0_BACKUP4_W1;  ///< Offset: 0x40 - Otp debuger block0 data register17.
        volatile uint32_t BLK0_BACKUP4_W2;  ///< Offset: 0x44 - Otp debuger block0 data register18.
        volatile uint32_t BLK0_BACKUP4_W3;  ///< Offset: 0x48 - Otp debuger block0 data register19.
        volatile uint32_t BLK0_BACKUP4_W4;  ///< Offset: 0x4C - Otp debuger block0 data register20.
        volatile uint32_t BLK0_BACKUP4_W5;  ///< Offset: 0x50 - Otp debuger block0 data register21.
        volatile uint32_t BLK1_W1;  ///< Offset: 0x54 - Otp debuger block1 data register1.
        volatile uint32_t BLK1_W2;  ///< Offset: 0x58 - Otp debuger block1 data register2.
        volatile uint32_t BLK1_W3;  ///< Offset: 0x5C - Otp debuger block1 data register3.
        volatile uint32_t BLK1_W4;  ///< Offset: 0x60 - Otp debuger block1 data register4.
        volatile uint32_t BLK1_W5;  ///< Offset: 0x64 - Otp debuger block1 data register5.
        volatile uint32_t BLK1_W6;  ///< Offset: 0x68 - Otp debuger block1 data register6.
        volatile uint32_t BLK1_W7;  ///< Offset: 0x6C - Otp debuger block1 data register7.
        volatile uint32_t BLK1_W8;  ///< Offset: 0x70 - Otp debuger block1 data register8.
        volatile uint32_t BLK1_W9;  ///< Offset: 0x74 - Otp debuger block1 data register9.
        volatile uint32_t BLK2_W1;  ///< Offset: 0x78 - Otp debuger block2 data register1.
        volatile uint32_t BLK2_W2;  ///< Offset: 0x7C - Otp debuger block2 data register2.
        volatile uint32_t BLK2_W3;  ///< Offset: 0x80 - Otp debuger block2 data register3.
        volatile uint32_t BLK2_W4;  ///< Offset: 0x84 - Otp debuger block2 data register4.
        volatile uint32_t BLK2_W5;  ///< Offset: 0x88 - Otp debuger block2 data register5.
        volatile uint32_t BLK2_W6;  ///< Offset: 0x8C - Otp debuger block2 data register6.
        volatile uint32_t BLK2_W7;  ///< Offset: 0x90 - Otp debuger block2 data register7.
        volatile uint32_t BLK2_W8;  ///< Offset: 0x94 - Otp debuger block2 data register8.
        volatile uint32_t BLK2_W9;  ///< Offset: 0x98 - Otp debuger block2 data register9.
        volatile uint32_t BLK2_W10;  ///< Offset: 0x9C - Otp debuger block2 data register10.
        volatile uint32_t BLK2_W11;  ///< Offset: 0xA0 - Otp debuger block2 data register11.
        volatile uint32_t BLK3_W1;  ///< Offset: 0xA4 - Otp debuger block3 data register1.
        volatile uint32_t BLK3_W2;  ///< Offset: 0xA8 - Otp debuger block3 data register2.
        volatile uint32_t BLK3_W3;  ///< Offset: 0xAC - Otp debuger block3 data register3.
        volatile uint32_t BLK3_W4;  ///< Offset: 0xB0 - Otp debuger block3 data register4.
        volatile uint32_t BLK3_W5;  ///< Offset: 0xB4 - Otp debuger block3 data register5.
        volatile uint32_t BLK3_W6;  ///< Offset: 0xB8 - Otp debuger block3 data register6.
        volatile uint32_t BLK3_W7;  ///< Offset: 0xBC - Otp debuger block3 data register7.
        volatile uint32_t BLK3_W8;  ///< Offset: 0xC0 - Otp debuger block3 data register8.
        volatile uint32_t BLK3_W9;  ///< Offset: 0xC4 - Otp debuger block3 data register9.
        volatile uint32_t BLK3_W10;  ///< Offset: 0xC8 - Otp debuger block3 data register10.
        volatile uint32_t BLK3_W11;  ///< Offset: 0xCC - Otp debuger block3 data register11.
        volatile uint32_t BLK4_W1;  ///< Offset: 0xD0 - Otp debuger block4 data register1.
        volatile uint32_t BLK4_W2;  ///< Offset: 0xD4 - Otp debuger block4 data register2.
        volatile uint32_t BLK4_W3;  ///< Offset: 0xD8 - Otp debuger block4 data register3.
        volatile uint32_t BLK4_W4;  ///< Offset: 0xDC - Otp debuger block4 data register4.
        volatile uint32_t BLK4_W5;  ///< Offset: 0xE0 - Otp debuger block4 data register5.
        volatile uint32_t BLK4_W6;  ///< Offset: 0xE4 - Otp debuger block4 data register6.
        volatile uint32_t BLK4_W7;  ///< Offset: 0xE8 - Otp debuger block4 data register7.
        volatile uint32_t BLK4_W8;  ///< Offset: 0xEC - Otp debuger block4 data register8.
        volatile uint32_t BLK4_W9;  ///< Offset: 0xF0 - Otp debuger block4 data register9.
        volatile uint32_t BLK4_W10;  ///< Offset: 0xF4 - Otp debuger block4 data registe10.
        volatile uint32_t BLK4_W11;  ///< Offset: 0xF8 - Otp debuger block4 data register11.
        volatile uint32_t BLK5_W1;  ///< Offset: 0xFC - Otp debuger block5 data register1.
        volatile uint32_t BLK5_W2;  ///< Offset: 0x100 - Otp debuger block5 data register2.
        volatile uint32_t BLK5_W3;  ///< Offset: 0x104 - Otp debuger block5 data register3.
        volatile uint32_t BLK5_W4;  ///< Offset: 0x108 - Otp debuger block5 data register4.
        volatile uint32_t BLK5_W5;  ///< Offset: 0x10C - Otp debuger block5 data register5.
        volatile uint32_t BLK5_W6;  ///< Offset: 0x110 - Otp debuger block5 data register6.
        volatile uint32_t BLK5_W7;  ///< Offset: 0x114 - Otp debuger block5 data register7.
        volatile uint32_t BLK5_W8;  ///< Offset: 0x118 - Otp debuger block5 data register8.
        volatile uint32_t BLK5_W9;  ///< Offset: 0x11C - Otp debuger block5 data register9.
        volatile uint32_t BLK5_W10;  ///< Offset: 0x120 - Otp debuger block5 data register10.
        volatile uint32_t BLK5_W11;  ///< Offset: 0x124 - Otp debuger block5 data register11.
        volatile uint32_t BLK6_W1;  ///< Offset: 0x128 - Otp debuger block6 data register1.
        volatile uint32_t BLK6_W2;  ///< Offset: 0x12C - Otp debuger block6 data register2.
        volatile uint32_t BLK6_W3;  ///< Offset: 0x130 - Otp debuger block6 data register3.
        volatile uint32_t BLK6_W4;  ///< Offset: 0x134 - Otp debuger block6 data register4.
        volatile uint32_t BLK6_W5;  ///< Offset: 0x138 - Otp debuger block6 data register5.
        volatile uint32_t BLK6_W6;  ///< Offset: 0x13C - Otp debuger block6 data register6.
        volatile uint32_t BLK6_W7;  ///< Offset: 0x140 - Otp debuger block6 data register7.
        volatile uint32_t BLK6_W8;  ///< Offset: 0x144 - Otp debuger block6 data register8.
        volatile uint32_t BLK6_W9;  ///< Offset: 0x148 - Otp debuger block6 data register9.
        volatile uint32_t BLK6_W10;  ///< Offset: 0x14C - Otp debuger block6 data register10.
        volatile uint32_t BLK6_W11;  ///< Offset: 0x150 - Otp debuger block6 data register11.
        volatile uint32_t BLK7_W1;  ///< Offset: 0x154 - Otp debuger block7 data register1.
        volatile uint32_t BLK7_W2;  ///< Offset: 0x158 - Otp debuger block7 data register2.
        volatile uint32_t BLK7_W3;  ///< Offset: 0x15C - Otp debuger block7 data register3.
        volatile uint32_t BLK7_W4;  ///< Offset: 0x160 - Otp debuger block7 data register4.
        volatile uint32_t BLK7_W5;  ///< Offset: 0x164 - Otp debuger block7 data register5.
        volatile uint32_t BLK7_W6;  ///< Offset: 0x168 - Otp debuger block7 data register6.
        volatile uint32_t BLK7_W7;  ///< Offset: 0x16C - Otp debuger block7 data register7.
        volatile uint32_t BLK7_W8;  ///< Offset: 0x170 - Otp debuger block7 data register8.
        volatile uint32_t BLK7_W9;  ///< Offset: 0x174 - Otp debuger block7 data register9.
        volatile uint32_t BLK7_W10;  ///< Offset: 0x178 - Otp debuger block7 data register10.
        volatile uint32_t BLK7_W11;  ///< Offset: 0x17C - Otp debuger block7 data register11.
        volatile uint32_t BLK8_W1;  ///< Offset: 0x180 - Otp debuger block8 data register1.
        volatile uint32_t BLK8_W2;  ///< Offset: 0x184 - Otp debuger block8 data register2.
        volatile uint32_t BLK8_W3;  ///< Offset: 0x188 - Otp debuger block8 data register3.
        volatile uint32_t BLK8_W4;  ///< Offset: 0x18C - Otp debuger block8 data register4.
        volatile uint32_t BLK8_W5;  ///< Offset: 0x190 - Otp debuger block8 data register5.
        volatile uint32_t BLK8_W6;  ///< Offset: 0x194 - Otp debuger block8 data register6.
        volatile uint32_t BLK8_W7;  ///< Offset: 0x198 - Otp debuger block8 data register7.
        volatile uint32_t BLK8_W8;  ///< Offset: 0x19C - Otp debuger block8 data register8.
        volatile uint32_t BLK8_W9;  ///< Offset: 0x1A0 - Otp debuger block8 data register9.
        volatile uint32_t BLK8_W10;  ///< Offset: 0x1A4 - Otp debuger block8 data register10.
        volatile uint32_t BLK8_W11;  ///< Offset: 0x1A8 - Otp debuger block8 data register11.
        volatile uint32_t BLK9_W1;  ///< Offset: 0x1AC - Otp debuger block9 data register1.
        volatile uint32_t BLK9_W2;  ///< Offset: 0x1B0 - Otp debuger block9 data register2.
        volatile uint32_t BLK9_W3;  ///< Offset: 0x1B4 - Otp debuger block9 data register3.
        volatile uint32_t BLK9_W4;  ///< Offset: 0x1B8 - Otp debuger block9 data register4.
        volatile uint32_t BLK9_W5;  ///< Offset: 0x1BC - Otp debuger block9 data register5.
        volatile uint32_t BLK9_W6;  ///< Offset: 0x1C0 - Otp debuger block9 data register6.
        volatile uint32_t BLK9_W7;  ///< Offset: 0x1C4 - Otp debuger block9 data register7.
        volatile uint32_t BLK9_W8;  ///< Offset: 0x1C8 - Otp debuger block9 data register8.
        volatile uint32_t BLK9_W9;  ///< Offset: 0x1CC - Otp debuger block9 data register9.
        volatile uint32_t BLK9_W10;  ///< Offset: 0x1D0 - Otp debuger block9 data register10.
        volatile uint32_t BLK9_W11;  ///< Offset: 0x1D4 - Otp debuger block9 data register11.
        volatile uint32_t BLK10_W1;  ///< Offset: 0x1D8 - Otp debuger block10 data register1.
        volatile uint32_t BLK10_W2;  ///< Offset: 0x1DC - Otp debuger block10 data register2.
        volatile uint32_t BLK10_W3;  ///< Offset: 0x1E0 - Otp debuger block10 data register3.
        volatile uint32_t BLK10_W4;  ///< Offset: 0x1E4 - Otp debuger block10 data register4.
        volatile uint32_t BLK10_W5;  ///< Offset: 0x1E8 - Otp debuger block10 data register5.
        volatile uint32_t BLK10_W6;  ///< Offset: 0x1EC - Otp debuger block10 data register6.
        volatile uint32_t BLK10_W7;  ///< Offset: 0x1F0 - Otp debuger block10 data register7.
        volatile uint32_t BLK10_W8;  ///< Offset: 0x1F4 - Otp debuger block10 data register8.
        volatile uint32_t BLK10_W9;  ///< Offset: 0x1F8 - Otp debuger block10 data register9.
        volatile uint32_t BLK10_W10;  ///< Offset: 0x1FC - Otp debuger block10 data register10.
        volatile uint32_t BLK10_W11;  ///< Offset: 0x200 - Otp debuger block10 data register11.
        volatile uint32_t CLK;  ///< Offset: 0x204 - Otp debuger clk_en configuration register.
        volatile uint32_t APB2OTP_EN;  ///< Offset: 0x208 - Otp_debuger apb2otp enable configuration register.
        volatile uint32_t DATE;  ///< Offset: 0x20C - eFuse version register.
    };

    /// Peripheral instances
    inline Registers* OTP_DEBUG = reinterpret_cast<Registers*>(OTP_DEBUG_BASE);

    // Bit definitions
    /// WR_DIS Register bits
    namespace wr_dis_bits {
        constexpr uint32_t BLOCK0_WR_DIS = (32 << 0);  ///< Otp block0 write disable data.
    }

    /// BLK0_BACKUP1_W1 Register bits
    namespace blk0_backup1_w1_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP1_W1 = (32 << 0);  ///< Otp block0 backup1 word1 data.
    }

    /// BLK0_BACKUP1_W2 Register bits
    namespace blk0_backup1_w2_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP1_W2 = (32 << 0);  ///< Otp block0 backup1 word2 data.
    }

    /// BLK0_BACKUP1_W3 Register bits
    namespace blk0_backup1_w3_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP1_W3 = (32 << 0);  ///< Otp block0 backup1 word3 data.
    }

    /// BLK0_BACKUP1_W4 Register bits
    namespace blk0_backup1_w4_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP1_W4 = (32 << 0);  ///< Otp block0 backup1 word4 data.
    }

    /// BLK0_BACKUP1_W5 Register bits
    namespace blk0_backup1_w5_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP1_W5 = (32 << 0);  ///< Otp block0 backup1 word5 data.
    }

    /// BLK0_BACKUP2_W1 Register bits
    namespace blk0_backup2_w1_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP2_W1 = (32 << 0);  ///< Otp block0 backup2 word1 data.
    }

    /// BLK0_BACKUP2_W2 Register bits
    namespace blk0_backup2_w2_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP2_W2 = (32 << 0);  ///< Otp block0 backup2 word2 data.
    }

    /// BLK0_BACKUP2_W3 Register bits
    namespace blk0_backup2_w3_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP2_W3 = (32 << 0);  ///< Otp block0 backup2 word3 data.
    }

    /// BLK0_BACKUP2_W4 Register bits
    namespace blk0_backup2_w4_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP2_W4 = (32 << 0);  ///< Otp block0 backup2 word4 data.
    }

    /// BLK0_BACKUP2_W5 Register bits
    namespace blk0_backup2_w5_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP2_W5 = (32 << 0);  ///< Otp block0 backup2 word5 data.
    }

    /// BLK0_BACKUP3_W1 Register bits
    namespace blk0_backup3_w1_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP3_W1 = (32 << 0);  ///< Otp block0 backup3 word1 data.
    }

    /// BLK0_BACKUP3_W2 Register bits
    namespace blk0_backup3_w2_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP3_W2 = (32 << 0);  ///< Otp block0 backup3 word2 data.
    }

    /// BLK0_BACKUP3_W3 Register bits
    namespace blk0_backup3_w3_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP3_W3 = (32 << 0);  ///< Otp block0 backup3 word3 data.
    }

    /// BLK0_BACKUP3_W4 Register bits
    namespace blk0_backup3_w4_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP3_W4 = (32 << 0);  ///< Otp block0 backup3 word4 data.
    }

    /// BLK0_BACKUP3_W5 Register bits
    namespace blk0_backup3_w5_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP3_W5 = (32 << 0);  ///< Otp block0 backup3 word5 data.
    }

    /// BLK0_BACKUP4_W1 Register bits
    namespace blk0_backup4_w1_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP4_W1 = (32 << 0);  ///< Otp block0 backup4 word1 data.
    }

    /// BLK0_BACKUP4_W2 Register bits
    namespace blk0_backup4_w2_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP4_W2 = (32 << 0);  ///< Otp block0 backup4 word2 data.
    }

    /// BLK0_BACKUP4_W3 Register bits
    namespace blk0_backup4_w3_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP4_W3 = (32 << 0);  ///< Otp block0 backup4 word3 data.
    }

    /// BLK0_BACKUP4_W4 Register bits
    namespace blk0_backup4_w4_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP4_W4 = (32 << 0);  ///< Otp block0 backup4 word4 data.
    }

    /// BLK0_BACKUP4_W5 Register bits
    namespace blk0_backup4_w5_bits {
        constexpr uint32_t OTP_BEBUG_BLOCK0_BACKUP4_W5 = (32 << 0);  ///< Otp block0 backup4 word5 data.
    }

    /// BLK1_W1 Register bits
    namespace blk1_w1_bits {
        constexpr uint32_t BLOCK1_W1 = (32 << 0);  ///< Otp block1 word1 data.
    }

    /// BLK1_W2 Register bits
    namespace blk1_w2_bits {
        constexpr uint32_t BLOCK1_W2 = (32 << 0);  ///< Otp block1 word2 data.
    }

    /// BLK1_W3 Register bits
    namespace blk1_w3_bits {
        constexpr uint32_t BLOCK1_W3 = (32 << 0);  ///< Otp block1 word3 data.
    }

    /// BLK1_W4 Register bits
    namespace blk1_w4_bits {
        constexpr uint32_t BLOCK1_W4 = (32 << 0);  ///< Otp block1 word4 data.
    }

    /// BLK1_W5 Register bits
    namespace blk1_w5_bits {
        constexpr uint32_t BLOCK1_W5 = (32 << 0);  ///< Otp block1 word5 data.
    }

    /// BLK1_W6 Register bits
    namespace blk1_w6_bits {
        constexpr uint32_t BLOCK1_W6 = (32 << 0);  ///< Otp block1 word6 data.
    }

    /// BLK1_W7 Register bits
    namespace blk1_w7_bits {
        constexpr uint32_t BLOCK1_W7 = (32 << 0);  ///< Otp block1 word7 data.
    }

    /// BLK1_W8 Register bits
    namespace blk1_w8_bits {
        constexpr uint32_t BLOCK1_W8 = (32 << 0);  ///< Otp block1 word8 data.
    }

    /// BLK1_W9 Register bits
    namespace blk1_w9_bits {
        constexpr uint32_t BLOCK1_W9 = (32 << 0);  ///< Otp block1 word9 data.
    }

    /// BLK2_W1 Register bits
    namespace blk2_w1_bits {
        constexpr uint32_t BLOCK2_W1 = (32 << 0);  ///< Otp block2 word1 data.
    }

    /// BLK2_W2 Register bits
    namespace blk2_w2_bits {
        constexpr uint32_t BLOCK2_W2 = (32 << 0);  ///< Otp block2 word2 data.
    }

    /// BLK2_W3 Register bits
    namespace blk2_w3_bits {
        constexpr uint32_t BLOCK2_W3 = (32 << 0);  ///< Otp block2 word3 data.
    }

    /// BLK2_W4 Register bits
    namespace blk2_w4_bits {
        constexpr uint32_t BLOCK2_W4 = (32 << 0);  ///< Otp block2 word4 data.
    }

    /// BLK2_W5 Register bits
    namespace blk2_w5_bits {
        constexpr uint32_t BLOCK2_W5 = (32 << 0);  ///< Otp block2 word5 data.
    }

    /// BLK2_W6 Register bits
    namespace blk2_w6_bits {
        constexpr uint32_t BLOCK2_W6 = (32 << 0);  ///< Otp block2 word6 data.
    }

    /// BLK2_W7 Register bits
    namespace blk2_w7_bits {
        constexpr uint32_t BLOCK2_W7 = (32 << 0);  ///< Otp block2 word7 data.
    }

    /// BLK2_W8 Register bits
    namespace blk2_w8_bits {
        constexpr uint32_t BLOCK2_W8 = (32 << 0);  ///< Otp block2 word8 data.
    }

    /// BLK2_W9 Register bits
    namespace blk2_w9_bits {
        constexpr uint32_t BLOCK2_W9 = (32 << 0);  ///< Otp block2 word9 data.
    }

    /// BLK2_W10 Register bits
    namespace blk2_w10_bits {
        constexpr uint32_t BLOCK2_W10 = (32 << 0);  ///< Otp block2 word10 data.
    }

    /// BLK2_W11 Register bits
    namespace blk2_w11_bits {
        constexpr uint32_t BLOCK2_W11 = (32 << 0);  ///< Otp block2 word11 data.
    }

    /// BLK3_W1 Register bits
    namespace blk3_w1_bits {
        constexpr uint32_t BLOCK3_W1 = (32 << 0);  ///< Otp block3 word1 data.
    }

    /// BLK3_W2 Register bits
    namespace blk3_w2_bits {
        constexpr uint32_t BLOCK3_W2 = (32 << 0);  ///< Otp block3 word2 data.
    }

    /// BLK3_W3 Register bits
    namespace blk3_w3_bits {
        constexpr uint32_t BLOCK3_W3 = (32 << 0);  ///< Otp block3 word3 data.
    }

    /// BLK3_W4 Register bits
    namespace blk3_w4_bits {
        constexpr uint32_t BLOCK3_W4 = (32 << 0);  ///< Otp block3 word4 data.
    }

    /// BLK3_W5 Register bits
    namespace blk3_w5_bits {
        constexpr uint32_t BLOCK3_W5 = (32 << 0);  ///< Otp block3 word5 data.
    }

    /// BLK3_W6 Register bits
    namespace blk3_w6_bits {
        constexpr uint32_t BLOCK3_W6 = (32 << 0);  ///< Otp block3 word6 data.
    }

    /// BLK3_W7 Register bits
    namespace blk3_w7_bits {
        constexpr uint32_t BLOCK3_W7 = (32 << 0);  ///< Otp block3 word7 data.
    }

    /// BLK3_W8 Register bits
    namespace blk3_w8_bits {
        constexpr uint32_t BLOCK3_W8 = (32 << 0);  ///< Otp block3 word8 data.
    }

    /// BLK3_W9 Register bits
    namespace blk3_w9_bits {
        constexpr uint32_t BLOCK3_W9 = (32 << 0);  ///< Otp block3 word9 data.
    }

    /// BLK3_W10 Register bits
    namespace blk3_w10_bits {
        constexpr uint32_t BLOCK3_W10 = (32 << 0);  ///< Otp block3 word10 data.
    }

    /// BLK3_W11 Register bits
    namespace blk3_w11_bits {
        constexpr uint32_t BLOCK3_W11 = (32 << 0);  ///< Otp block3 word11 data.
    }

    /// BLK4_W1 Register bits
    namespace blk4_w1_bits {
        constexpr uint32_t BLOCK4_W1 = (32 << 0);  ///< Otp block4 word1 data.
    }

    /// BLK4_W2 Register bits
    namespace blk4_w2_bits {
        constexpr uint32_t BLOCK4_W2 = (32 << 0);  ///< Otp block4 word2 data.
    }

    /// BLK4_W3 Register bits
    namespace blk4_w3_bits {
        constexpr uint32_t BLOCK4_W3 = (32 << 0);  ///< Otp block4 word3 data.
    }

    /// BLK4_W4 Register bits
    namespace blk4_w4_bits {
        constexpr uint32_t BLOCK4_W4 = (32 << 0);  ///< Otp block4 word4 data.
    }

    /// BLK4_W5 Register bits
    namespace blk4_w5_bits {
        constexpr uint32_t BLOCK4_W5 = (32 << 0);  ///< Otp block4 word5 data.
    }

    /// BLK4_W6 Register bits
    namespace blk4_w6_bits {
        constexpr uint32_t BLOCK4_W6 = (32 << 0);  ///< Otp block4 word6 data.
    }

    /// BLK4_W7 Register bits
    namespace blk4_w7_bits {
        constexpr uint32_t BLOCK4_W7 = (32 << 0);  ///< Otp block4 word7 data.
    }

    /// BLK4_W8 Register bits
    namespace blk4_w8_bits {
        constexpr uint32_t BLOCK4_W8 = (32 << 0);  ///< Otp block4 word8 data.
    }

    /// BLK4_W9 Register bits
    namespace blk4_w9_bits {
        constexpr uint32_t BLOCK4_W9 = (32 << 0);  ///< Otp block4 word9 data.
    }

    /// BLK4_W10 Register bits
    namespace blk4_w10_bits {
        constexpr uint32_t BLOCK4_W10 = (32 << 0);  ///< Otp block4 word10 data.
    }

    /// BLK4_W11 Register bits
    namespace blk4_w11_bits {
        constexpr uint32_t BLOCK4_W11 = (32 << 0);  ///< Otp block4 word11 data.
    }

    /// BLK5_W1 Register bits
    namespace blk5_w1_bits {
        constexpr uint32_t BLOCK5_W1 = (32 << 0);  ///< Otp block5 word1 data.
    }

    /// BLK5_W2 Register bits
    namespace blk5_w2_bits {
        constexpr uint32_t BLOCK5_W2 = (32 << 0);  ///< Otp block5 word2 data.
    }

    /// BLK5_W3 Register bits
    namespace blk5_w3_bits {
        constexpr uint32_t BLOCK5_W3 = (32 << 0);  ///< Otp block5 word3 data.
    }

    /// BLK5_W4 Register bits
    namespace blk5_w4_bits {
        constexpr uint32_t BLOCK5_W4 = (32 << 0);  ///< Otp block5 word4 data.
    }

    /// BLK5_W5 Register bits
    namespace blk5_w5_bits {
        constexpr uint32_t BLOCK5_W5 = (32 << 0);  ///< Otp block5 word5 data.
    }

    /// BLK5_W6 Register bits
    namespace blk5_w6_bits {
        constexpr uint32_t BLOCK5_W6 = (32 << 0);  ///< Otp block5 word6 data.
    }

    /// BLK5_W7 Register bits
    namespace blk5_w7_bits {
        constexpr uint32_t BLOCK5_W7 = (32 << 0);  ///< Otp block5 word7 data.
    }

    /// BLK5_W8 Register bits
    namespace blk5_w8_bits {
        constexpr uint32_t BLOCK5_W8 = (32 << 0);  ///< Otp block5 word8 data.
    }

    /// BLK5_W9 Register bits
    namespace blk5_w9_bits {
        constexpr uint32_t BLOCK5_W9 = (32 << 0);  ///< Otp block5 word9 data.
    }

    /// BLK5_W10 Register bits
    namespace blk5_w10_bits {
        constexpr uint32_t BLOCK5_W10 = (32 << 0);  ///< Otp block5 word10 data.
    }

    /// BLK5_W11 Register bits
    namespace blk5_w11_bits {
        constexpr uint32_t BLOCK5_W11 = (32 << 0);  ///< Otp block5 word11 data.
    }

    /// BLK6_W1 Register bits
    namespace blk6_w1_bits {
        constexpr uint32_t BLOCK6_W1 = (32 << 0);  ///< Otp block6 word1 data.
    }

    /// BLK6_W2 Register bits
    namespace blk6_w2_bits {
        constexpr uint32_t BLOCK6_W2 = (32 << 0);  ///< Otp block6 word2 data.
    }

    /// BLK6_W3 Register bits
    namespace blk6_w3_bits {
        constexpr uint32_t BLOCK6_W3 = (32 << 0);  ///< Otp block6 word3 data.
    }

    /// BLK6_W4 Register bits
    namespace blk6_w4_bits {
        constexpr uint32_t BLOCK6_W4 = (32 << 0);  ///< Otp block6 word4 data.
    }

    /// BLK6_W5 Register bits
    namespace blk6_w5_bits {
        constexpr uint32_t BLOCK6_W5 = (32 << 0);  ///< Otp block6 word5 data.
    }

    /// BLK6_W6 Register bits
    namespace blk6_w6_bits {
        constexpr uint32_t BLOCK6_W6 = (32 << 0);  ///< Otp block6 word6 data.
    }

    /// BLK6_W7 Register bits
    namespace blk6_w7_bits {
        constexpr uint32_t BLOCK6_W7 = (32 << 0);  ///< Otp block6 word7 data.
    }

    /// BLK6_W8 Register bits
    namespace blk6_w8_bits {
        constexpr uint32_t BLOCK6_W8 = (32 << 0);  ///< Otp block6 word8 data.
    }

    /// BLK6_W9 Register bits
    namespace blk6_w9_bits {
        constexpr uint32_t BLOCK6_W9 = (32 << 0);  ///< Otp block6 word9 data.
    }

    /// BLK6_W10 Register bits
    namespace blk6_w10_bits {
        constexpr uint32_t BLOCK6_W10 = (32 << 0);  ///< Otp block6 word10 data.
    }

    /// BLK6_W11 Register bits
    namespace blk6_w11_bits {
        constexpr uint32_t BLOCK6_W11 = (32 << 0);  ///< Otp block6 word11 data.
    }

    /// BLK7_W1 Register bits
    namespace blk7_w1_bits {
        constexpr uint32_t BLOCK7_W1 = (32 << 0);  ///< Otp block7 word1 data.
    }

    /// BLK7_W2 Register bits
    namespace blk7_w2_bits {
        constexpr uint32_t BLOCK7_W2 = (32 << 0);  ///< Otp block7 word2 data.
    }

    /// BLK7_W3 Register bits
    namespace blk7_w3_bits {
        constexpr uint32_t BLOCK7_W3 = (32 << 0);  ///< Otp block7 word3 data.
    }

    /// BLK7_W4 Register bits
    namespace blk7_w4_bits {
        constexpr uint32_t BLOCK7_W4 = (32 << 0);  ///< Otp block7 word4 data.
    }

    /// BLK7_W5 Register bits
    namespace blk7_w5_bits {
        constexpr uint32_t BLOCK7_W5 = (32 << 0);  ///< Otp block7 word5 data.
    }

    /// BLK7_W6 Register bits
    namespace blk7_w6_bits {
        constexpr uint32_t BLOCK7_W6 = (32 << 0);  ///< Otp block7 word6 data.
    }

    /// BLK7_W7 Register bits
    namespace blk7_w7_bits {
        constexpr uint32_t BLOCK7_W7 = (32 << 0);  ///< Otp block7 word7 data.
    }

    /// BLK7_W8 Register bits
    namespace blk7_w8_bits {
        constexpr uint32_t BLOCK7_W8 = (32 << 0);  ///< Otp block7 word8 data.
    }

    /// BLK7_W9 Register bits
    namespace blk7_w9_bits {
        constexpr uint32_t BLOCK7_W9 = (32 << 0);  ///< Otp block7 word9 data.
    }

    /// BLK7_W10 Register bits
    namespace blk7_w10_bits {
        constexpr uint32_t BLOCK7_W10 = (32 << 0);  ///< Otp block7 word10 data.
    }

    /// BLK7_W11 Register bits
    namespace blk7_w11_bits {
        constexpr uint32_t BLOCK7_W11 = (32 << 0);  ///< Otp block7 word11 data.
    }

    /// BLK8_W1 Register bits
    namespace blk8_w1_bits {
        constexpr uint32_t BLOCK8_W1 = (32 << 0);  ///< Otp block8 word1 data.
    }

    /// BLK8_W2 Register bits
    namespace blk8_w2_bits {
        constexpr uint32_t BLOCK8_W2 = (32 << 0);  ///< Otp block8 word2 data.
    }

    /// BLK8_W3 Register bits
    namespace blk8_w3_bits {
        constexpr uint32_t BLOCK8_W3 = (32 << 0);  ///< Otp block8 word3 data.
    }

    /// BLK8_W4 Register bits
    namespace blk8_w4_bits {
        constexpr uint32_t BLOCK8_W4 = (32 << 0);  ///< Otp block8 word4 data.
    }

    /// BLK8_W5 Register bits
    namespace blk8_w5_bits {
        constexpr uint32_t BLOCK8_W5 = (32 << 0);  ///< Otp block8 word5 data.
    }

    /// BLK8_W6 Register bits
    namespace blk8_w6_bits {
        constexpr uint32_t BLOCK8_W6 = (32 << 0);  ///< Otp block8 word6 data.
    }

    /// BLK8_W7 Register bits
    namespace blk8_w7_bits {
        constexpr uint32_t BLOCK8_W7 = (32 << 0);  ///< Otp block8 word7 data.
    }

    /// BLK8_W8 Register bits
    namespace blk8_w8_bits {
        constexpr uint32_t BLOCK8_W8 = (32 << 0);  ///< Otp block8 word8 data.
    }

    /// BLK8_W9 Register bits
    namespace blk8_w9_bits {
        constexpr uint32_t BLOCK8_W9 = (32 << 0);  ///< Otp block8 word9 data.
    }

    /// BLK8_W10 Register bits
    namespace blk8_w10_bits {
        constexpr uint32_t BLOCK8_W10 = (32 << 0);  ///< Otp block8 word10 data.
    }

    /// BLK8_W11 Register bits
    namespace blk8_w11_bits {
        constexpr uint32_t BLOCK8_W11 = (32 << 0);  ///< Otp block8 word11 data.
    }

    /// BLK9_W1 Register bits
    namespace blk9_w1_bits {
        constexpr uint32_t BLOCK9_W1 = (32 << 0);  ///< Otp block9 word1 data.
    }

    /// BLK9_W2 Register bits
    namespace blk9_w2_bits {
        constexpr uint32_t BLOCK9_W2 = (32 << 0);  ///< Otp block9 word2 data.
    }

    /// BLK9_W3 Register bits
    namespace blk9_w3_bits {
        constexpr uint32_t BLOCK9_W3 = (32 << 0);  ///< Otp block9 word3 data.
    }

    /// BLK9_W4 Register bits
    namespace blk9_w4_bits {
        constexpr uint32_t BLOCK9_W4 = (32 << 0);  ///< Otp block9 word4 data.
    }

    /// BLK9_W5 Register bits
    namespace blk9_w5_bits {
        constexpr uint32_t BLOCK9_W5 = (32 << 0);  ///< Otp block9 word5 data.
    }

    /// BLK9_W6 Register bits
    namespace blk9_w6_bits {
        constexpr uint32_t BLOCK9_W6 = (32 << 0);  ///< Otp block9 word6 data.
    }

    /// BLK9_W7 Register bits
    namespace blk9_w7_bits {
        constexpr uint32_t BLOCK9_W7 = (32 << 0);  ///< Otp block9 word7 data.
    }

    /// BLK9_W8 Register bits
    namespace blk9_w8_bits {
        constexpr uint32_t BLOCK9_W8 = (32 << 0);  ///< Otp block9 word8 data.
    }

    /// BLK9_W9 Register bits
    namespace blk9_w9_bits {
        constexpr uint32_t BLOCK9_W9 = (32 << 0);  ///< Otp block9 word9 data.
    }

    /// BLK9_W10 Register bits
    namespace blk9_w10_bits {
        constexpr uint32_t BLOCK9_W10 = (32 << 0);  ///< Otp block9 word10 data.
    }

    /// BLK9_W11 Register bits
    namespace blk9_w11_bits {
        constexpr uint32_t BLOCK9_W11 = (32 << 0);  ///< Otp block9 word11 data.
    }

    /// BLK10_W1 Register bits
    namespace blk10_w1_bits {
        constexpr uint32_t BLOCK10_W1 = (32 << 0);  ///< Otp block10 word1 data.
    }

    /// BLK10_W2 Register bits
    namespace blk10_w2_bits {
        constexpr uint32_t BLOCK10_W2 = (32 << 0);  ///< Otp block10 word2 data.
    }

    /// BLK10_W3 Register bits
    namespace blk10_w3_bits {
        constexpr uint32_t BLOCK10_W3 = (32 << 0);  ///< Otp block10 word3 data.
    }

    /// BLK10_W4 Register bits
    namespace blk10_w4_bits {
        constexpr uint32_t BLOCK10_W4 = (32 << 0);  ///< Otp block10 word4 data.
    }

    /// BLK10_W5 Register bits
    namespace blk10_w5_bits {
        constexpr uint32_t BLOCK10_W5 = (32 << 0);  ///< Otp block10 word5 data.
    }

    /// BLK10_W6 Register bits
    namespace blk10_w6_bits {
        constexpr uint32_t BLOCK10_W6 = (32 << 0);  ///< Otp block10 word6 data.
    }

    /// BLK10_W7 Register bits
    namespace blk10_w7_bits {
        constexpr uint32_t BLOCK10_W7 = (32 << 0);  ///< Otp block10 word7 data.
    }

    /// BLK10_W8 Register bits
    namespace blk10_w8_bits {
        constexpr uint32_t BLOCK10_W8 = (32 << 0);  ///< Otp block10 word8 data.
    }

    /// BLK10_W9 Register bits
    namespace blk10_w9_bits {
        constexpr uint32_t BLOCK10_W9 = (32 << 0);  ///< Otp block10 word9 data.
    }

    /// BLK10_W10 Register bits
    namespace blk10_w10_bits {
        constexpr uint32_t BLOCK19_W10 = (32 << 0);  ///< Otp block10 word10 data.
    }

    /// BLK10_W11 Register bits
    namespace blk10_w11_bits {
        constexpr uint32_t BLOCK10_W11 = (32 << 0);  ///< Otp block10 word11 data.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Force clock on for this register file.
    }

    /// APB2OTP_EN Register bits
    namespace apb2otp_en_bits {
        constexpr uint32_t APB2OTP_EN = (1U << 0);  ///< Debug mode enable signal.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores otp_debug version.
    }

}

// ============================================================================
// PARL Peripheral
// ============================================================================

namespace parl {
    /// Base addresses
    constexpr uint32_t PARL_IO_BASE = 0x60015000;

    /// PARL Register structure
    struct Registers {
        volatile uint32_t RX_MODE_CFG;  ///< Offset: 0x00 - Parallel RX Sampling mode configuration register.
        volatile uint32_t RX_DATA_CFG;  ///< Offset: 0x04 - Parallel RX data configuration register.
        volatile uint32_t RX_GENRL_CFG;  ///< Offset: 0x08 - Parallel RX general configuration register.
        volatile uint32_t RX_START_CFG;  ///< Offset: 0x0C - Parallel RX Start configuration register.
        volatile uint32_t TX_DATA_CFG;  ///< Offset: 0x10 - Parallel TX data configuration register.
        volatile uint32_t TX_START_CFG;  ///< Offset: 0x14 - Parallel TX Start configuration register.
        volatile uint32_t TX_GENRL_CFG;  ///< Offset: 0x18 - Parallel TX general configuration register.
        volatile uint32_t FIFO_CFG;  ///< Offset: 0x1C - Parallel IO FIFO configuration register.
        volatile uint32_t REG_UPDATE;  ///< Offset: 0x20 - Parallel IO FIFO configuration register.
        volatile uint32_t ST;  ///< Offset: 0x24 - Parallel IO module status register0.
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Parallel IO interrupt enable singal configuration register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x2C - Parallel IO interrupt raw singal status register.
        volatile uint32_t INT_ST;  ///< Offset: 0x30 - Parallel IO interrupt singal status register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x34 - Parallel IO interrupt clear singal configuration register.
        volatile uint32_t RX_ST0;  ///< Offset: 0x38 - Parallel IO RX status register0
        volatile uint32_t RX_ST1;  ///< Offset: 0x3C - Parallel IO RX status register1
        volatile uint32_t TX_ST0;  ///< Offset: 0x40 - Parallel IO TX status register0
        volatile uint32_t RX_CLK_CFG;  ///< Offset: 0x44 - Parallel IO RX clk configuration register
        volatile uint32_t TX_CLK_CFG;  ///< Offset: 0x48 - Parallel IO TX clk configuration register
        volatile uint32_t CLK;  ///< Offset: 0x120 - Parallel IO clk configuration register
        volatile uint32_t VERSION;  ///< Offset: 0x3FC - Version register.
    };

    /// Peripheral instances
    inline Registers* PARL_IO = reinterpret_cast<Registers*>(PARL_IO_BASE);

    // Bit definitions
    /// RX_MODE_CFG Register bits
    namespace rx_mode_cfg_bits {
        constexpr uint32_t RX_EXT_EN_SEL = (4 << 21);  ///< Configures rx external enable signal selection from IO PAD.
        constexpr uint32_t RX_SW_EN = (1U << 25);  ///< Set this bit to enable data sampling by software.
        constexpr uint32_t RX_EXT_EN_INV = (1U << 26);  ///< Set this bit to invert the external enable signal.
        constexpr uint32_t RX_PULSE_SUBMODE_SEL = (3 << 27);  ///< Configures the rxd pulse sampling submode. 4'd0: positive pulse start(data bit included) && positive pulse end(data bit included) 4'd1: positive pulse start(data bit included) && positive pulse end (data bit excluded) 4'd2: positive pulse start(data bit excluded) && positive pulse end (data bit included) 4'd3: positive pulse start(data bit excluded) && positive pulse end (data bit excluded) 4'd4: positive pulse start(data bit included) && length end 4'd5: positive pulse start(data bit excluded) && length end
        constexpr uint32_t RX_SMP_MODE_SEL = (2 << 30);  ///< Configures the rxd sampling mode. 2'b00: external level enable mode 2'b01: external pulse enable mode 2'b10: internal software enable mode
    }

    /// RX_DATA_CFG Register bits
    namespace rx_data_cfg_bits {
        constexpr uint32_t RX_BITLEN = (19 << 9);  ///< Configures expected byte number of received data.
        constexpr uint32_t RX_DATA_ORDER_INV = (1U << 28);  ///< Set this bit to invert bit order of one byte sent from RX_FIFO to DMA.
        constexpr uint32_t RX_BUS_WID_SEL = (3 << 29);  ///< Configures the rxd bus width. 3'd0: bus width is 1. 3'd1: bus width is 2. 3'd2: bus width is 4. 3'd3: bus width is 8.
    }

    /// RX_GENRL_CFG Register bits
    namespace rx_genrl_cfg_bits {
        constexpr uint32_t RX_GATING_EN = (1U << 12);  ///< Set this bit to enable the clock gating of output rx clock.
        constexpr uint32_t RX_TIMEOUT_THRES = (16 << 13);  ///< Configures threshold of timeout counter.
        constexpr uint32_t RX_TIMEOUT_EN = (1U << 29);  ///< Set this bit to enable timeout function to generate error eof.
        constexpr uint32_t RX_EOF_GEN_SEL = (1U << 30);  ///< Configures the DMA eof generated mechanism. 1'b0: eof generated by data byte length. 1'b1: eof generated by external enable signal.
    }

    /// RX_START_CFG Register bits
    namespace rx_start_cfg_bits {
        constexpr uint32_t RX_START = (1U << 31);  ///< Set this bit to start rx data sampling.
    }

    /// TX_DATA_CFG Register bits
    namespace tx_data_cfg_bits {
        constexpr uint32_t TX_BITLEN = (19 << 9);  ///< Configures expected byte number of sent data.
        constexpr uint32_t TX_DATA_ORDER_INV = (1U << 28);  ///< Set this bit to invert bit order of one byte sent from TX_FIFO to IO data.
        constexpr uint32_t TX_BUS_WID_SEL = (3 << 29);  ///< Configures the txd bus width. 3'd0: bus width is 1. 3'd1: bus width is 2. 3'd2: bus width is 4. 3'd3: bus width is 8.
    }

    /// TX_START_CFG Register bits
    namespace tx_start_cfg_bits {
        constexpr uint32_t TX_START = (1U << 31);  ///< Set this bit to start tx data transmit.
    }

    /// TX_GENRL_CFG Register bits
    namespace tx_genrl_cfg_bits {
        constexpr uint32_t TX_IDLE_VALUE = (16 << 14);  ///< Configures bus value of transmitter in IDLE state.
        constexpr uint32_t TX_GATING_EN = (1U << 30);  ///< Set this bit to enable the clock gating of output tx clock.
        constexpr uint32_t TX_VALID_OUTPUT_EN = (1U << 31);  ///< Set this bit to enable the output of tx data valid signal.
    }

    /// FIFO_CFG Register bits
    namespace fifo_cfg_bits {
        constexpr uint32_t TX_FIFO_SRST = (1U << 30);  ///< Set this bit to reset async fifo in tx module.
        constexpr uint32_t RX_FIFO_SRST = (1U << 31);  ///< Set this bit to reset async fifo in rx module.
    }

    /// REG_UPDATE Register bits
    namespace reg_update_bits {
        constexpr uint32_t RX_REG_UPDATE = (1U << 31);  ///< Set this bit to update rx register configuration.
    }

    /// ST Register bits
    namespace st_bits {
        constexpr uint32_t TX_READY = (1U << 31);  ///< Represents the status that tx is ready to transmit.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_ENA = (1U << 0);  ///< Set this bit to enable TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_ENA = (1U << 1);  ///< Set this bit to enable RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_ENA = (1U << 2);  ///< Set this bit to enable TX_EOF_INT.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_RAW = (1U << 0);  ///< The raw interrupt status of TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_RAW = (1U << 1);  ///< The raw interrupt status of RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_RAW = (1U << 2);  ///< The raw interrupt status of TX_EOF_INT.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_ST = (1U << 0);  ///< The masked interrupt status of TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_ST = (1U << 1);  ///< The masked interrupt status of RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_ST = (1U << 2);  ///< The masked interrupt status of TX_EOF_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_CLR = (1U << 0);  ///< Set this bit to clear TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_CLR = (1U << 1);  ///< Set this bit to clear RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_CLR = (1U << 2);  ///< Set this bit to clear TX_EOF_INT.
    }

    /// RX_ST0 Register bits
    namespace rx_st0_bits {
        constexpr uint32_t RX_CNT = (4 << 9);  ///< Indicates the cycle number of reading Rx FIFO.
        constexpr uint32_t RX_FIFO_WR_BIT_CNT = (19 << 13);  ///< Indicates the current written bit number into Rx FIFO.
    }

    /// RX_ST1 Register bits
    namespace rx_st1_bits {
        constexpr uint32_t RX_FIFO_RD_BIT_CNT = (19 << 13);  ///< Indicates the current read bit number from Rx FIFO.
    }

    /// TX_ST0 Register bits
    namespace tx_st0_bits {
        constexpr uint32_t TX_CNT = (7 << 6);  ///< Indicates the cycle number of reading Tx FIFO.
        constexpr uint32_t TX_FIFO_RD_BIT_CNT = (19 << 13);  ///< Indicates the current read bit number from Tx FIFO.
    }

    /// RX_CLK_CFG Register bits
    namespace rx_clk_cfg_bits {
        constexpr uint32_t RX_CLK_I_INV = (1U << 30);  ///< Set this bit to invert the input Rx core clock.
        constexpr uint32_t RX_CLK_O_INV = (1U << 31);  ///< Set this bit to invert the output Rx core clock.
    }

    /// TX_CLK_CFG Register bits
    namespace tx_clk_cfg_bits {
        constexpr uint32_t TX_CLK_I_INV = (1U << 30);  ///< Set this bit to invert the input Tx core clock.
        constexpr uint32_t TX_CLK_O_INV = (1U << 31);  ///< Set this bit to invert the output Tx core clock.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EN = (1U << 31);  ///< Force clock on for this register file
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Version of this register file
    }

}

// ============================================================================
// PAU Peripheral
// ============================================================================

namespace pau {
    /// Base addresses
    constexpr uint32_t PAU_BASE = 0x60093000;

    /// PAU Register structure
    struct Registers {
        volatile uint32_t REGDMA_CONF;  ///< Offset: 0x00 - Peri backup control register
        volatile uint32_t REGDMA_CLK_CONF;  ///< Offset: 0x04 - Clock control register
        volatile uint32_t REGDMA_ETM_CTRL;  ///< Offset: 0x08 - ETM start ctrl reg
        volatile uint32_t REGDMA_LINK_0_ADDR;  ///< Offset: 0x0C - link_0_addr
        volatile uint32_t REGDMA_LINK_1_ADDR;  ///< Offset: 0x10 - Link_1_addr
        volatile uint32_t REGDMA_LINK_2_ADDR;  ///< Offset: 0x14 - Link_2_addr
        volatile uint32_t REGDMA_LINK_3_ADDR;  ///< Offset: 0x18 - Link_3_addr
        volatile uint32_t REGDMA_LINK_MAC_ADDR;  ///< Offset: 0x1C - Link_mac_addr
        volatile uint32_t REGDMA_CURRENT_LINK_ADDR;  ///< Offset: 0x20 - current link addr
        volatile uint32_t REGDMA_BACKUP_ADDR;  ///< Offset: 0x24 - Backup addr
        volatile uint32_t REGDMA_MEM_ADDR;  ///< Offset: 0x28 - mem addr
        volatile uint32_t REGDMA_BKP_CONF;  ///< Offset: 0x2C - backup config
        volatile uint32_t RETENTION_LINK_BASE;  ///< Offset: 0x30 - retention dma link base
        volatile uint32_t RETENTION_CFG;  ///< Offset: 0x34 - retention_cfg
        volatile uint32_t INT_ENA;  ///< Offset: 0x38 - Read only register for error and done
        volatile uint32_t INT_RAW;  ///< Offset: 0x3C - Read only register for error and done
        volatile uint32_t INT_CLR;  ///< Offset: 0x40 - Read only register for error and done
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - Read only register for error and done
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Date register.
    };

    /// Peripheral instances
    inline Registers* PAU = reinterpret_cast<Registers*>(PAU_BASE);

    // Bit definitions
    /// REGDMA_CONF Register bits
    namespace regdma_conf_bits {
        constexpr uint32_t FLOW_ERR = (3 << 0);  ///< backup error type
        constexpr uint32_t START = (1U << 3);  ///< backup start signal
        constexpr uint32_t TO_MEM = (1U << 4);  ///< backup direction(reg to mem / mem to reg)
        constexpr uint32_t LINK_SEL = (2 << 5);  ///< Link select
        constexpr uint32_t START_MAC = (1U << 7);  ///< mac sw backup start signal
        constexpr uint32_t TO_MEM_MAC = (1U << 8);  ///< mac sw backup direction(reg to mem / mem to reg)
        constexpr uint32_t SEL_MAC = (1U << 9);  ///< mac hw/sw select
    }

    /// REGDMA_CLK_CONF Register bits
    namespace regdma_clk_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock enable
    }

    /// REGDMA_ETM_CTRL Register bits
    namespace regdma_etm_ctrl_bits {
        constexpr uint32_t ETM_START_0 = (1U << 0);  ///< etm_start_0 reg
        constexpr uint32_t ETM_START_1 = (1U << 1);  ///< etm_start_1 reg
        constexpr uint32_t ETM_START_2 = (1U << 2);  ///< etm_start_2 reg
        constexpr uint32_t ETM_START_3 = (1U << 3);  ///< etm_start_3 reg
    }

    /// REGDMA_LINK_0_ADDR Register bits
    namespace regdma_link_0_addr_bits {
        constexpr uint32_t LINK_ADDR_0 = (32 << 0);  ///< link_0_addr reg
    }

    /// REGDMA_LINK_1_ADDR Register bits
    namespace regdma_link_1_addr_bits {
        constexpr uint32_t LINK_ADDR_1 = (32 << 0);  ///< Link_1_addr reg
    }

    /// REGDMA_LINK_2_ADDR Register bits
    namespace regdma_link_2_addr_bits {
        constexpr uint32_t LINK_ADDR_2 = (32 << 0);  ///< Link_2_addr reg
    }

    /// REGDMA_LINK_3_ADDR Register bits
    namespace regdma_link_3_addr_bits {
        constexpr uint32_t LINK_ADDR_3 = (32 << 0);  ///< Link_3_addr reg
    }

    /// REGDMA_LINK_MAC_ADDR Register bits
    namespace regdma_link_mac_addr_bits {
        constexpr uint32_t LINK_ADDR_MAC = (32 << 0);  ///< Link_mac_addr reg
    }

    /// REGDMA_CURRENT_LINK_ADDR Register bits
    namespace regdma_current_link_addr_bits {
        constexpr uint32_t CURRENT_LINK_ADDR = (32 << 0);  ///< current link addr reg
    }

    /// REGDMA_BACKUP_ADDR Register bits
    namespace regdma_backup_addr_bits {
        constexpr uint32_t BACKUP_ADDR = (32 << 0);  ///< backup addr reg
    }

    /// REGDMA_MEM_ADDR Register bits
    namespace regdma_mem_addr_bits {
        constexpr uint32_t MEM_ADDR = (32 << 0);  ///< mem addr reg
    }

    /// REGDMA_BKP_CONF Register bits
    namespace regdma_bkp_conf_bits {
        constexpr uint32_t READ_INTERVAL = (7 << 0);  ///< Link read_interval
        constexpr uint32_t LINK_TOUT_THRES = (10 << 7);  ///< link wait timeout threshold
        constexpr uint32_t BURST_LIMIT = (5 << 17);  ///< burst limit
        constexpr uint32_t BACKUP_TOUT_THRES = (10 << 22);  ///< Backup timeout threshold
    }

    /// RETENTION_LINK_BASE Register bits
    namespace retention_link_base_bits {
        constexpr uint32_t LINK_BASE_ADDR = (27 << 0);  ///< retention dma link base
    }

    /// RETENTION_CFG Register bits
    namespace retention_cfg_bits {
        constexpr uint32_t RET_INV_CFG = (32 << 0);  ///< retention inv scan out
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t DONE_INT_ENA = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_ENA = (1U << 1);  ///< error flag
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t DONE_INT_RAW = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_RAW = (1U << 1);  ///< error flag
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t DONE_INT_CLR = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_CLR = (1U << 1);  ///< error flag
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t DONE_INT_ST = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_ST = (1U << 1);  ///< error flag
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< REGDMA date information/ REGDMA version information.
    }

}

// ============================================================================
// PCNT Peripheral
// ============================================================================

namespace pcnt {
    /// Base addresses
    constexpr uint32_t PCNT_BASE = 0x60012000;

    /// PCNT Register structure
    struct Registers {
        volatile uint32_t U%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for unit %s
        volatile uint32_t U%s_CONF1;  ///< Offset: 0x04 - Configuration register 1 for unit %s
        volatile uint32_t U%s_CONF2;  ///< Offset: 0x08 - Configuration register 2 for unit %s
        volatile uint32_t U%s_CNT;  ///< Offset: 0x30 - Counter value for unit %s
        volatile uint32_t INT_RAW;  ///< Offset: 0x40 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - Interrupt status register
        volatile uint32_t INT_ENA;  ///< Offset: 0x48 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - Interrupt clear register
        volatile uint32_t U%s_STATUS;  ///< Offset: 0x50 - PNCT UNIT%s status register
        volatile uint32_t CTRL;  ///< Offset: 0x60 - Control register for all counters
        volatile uint32_t DATE;  ///< Offset: 0xFC - PCNT version control register
    };

    /// Peripheral instances
    inline Registers* PCNT = reinterpret_cast<Registers*>(PCNT_BASE);

    // Bit definitions
    /// U%s_CONF0 Register bits
    namespace u%s_conf0_bits {
        constexpr uint32_t FILTER_THRES = (10 << 0);  ///< This sets the maximum threshold, in APB_CLK cycles, for the filter. Any pulses with width less than this will be ignored when the filter is enabled.
        constexpr uint32_t FILTER_EN = (1U << 10);  ///< This is the enable bit for unit %s's input filter.
        constexpr uint32_t THR_ZERO_EN = (1U << 11);  ///< This is the enable bit for unit %s's zero comparator.
        constexpr uint32_t THR_H_LIM_EN = (1U << 12);  ///< This is the enable bit for unit %s's thr_h_lim comparator. Configures it to enable the high limit interrupt.
        constexpr uint32_t THR_L_LIM_EN = (1U << 13);  ///< This is the enable bit for unit %s's thr_l_lim comparator. Configures it to enable the low limit interrupt.
        constexpr uint32_t THR_THRES0_EN = (1U << 14);  ///< This is the enable bit for unit %s's thres0 comparator.
        constexpr uint32_t THR_THRES1_EN = (1U << 15);  ///< This is the enable bit for unit %s's thres1 comparator.
        constexpr uint32_t CH0_NEG_MODE = (2 << 16);  ///< This register sets the behavior when the signal input of channel 0 detects a negative edge. 1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
        constexpr uint32_t CH0_POS_MODE = (2 << 18);  ///< This register sets the behavior when the signal input of channel 0 detects a positive edge. 1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
        constexpr uint32_t CH0_HCTRL_MODE = (2 << 20);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH0_LCTRL_MODE = (2 << 22);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH1_NEG_MODE = (2 << 24);  ///< This register sets the behavior when the signal input of channel 1 detects a negative edge. 1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
        constexpr uint32_t CH1_POS_MODE = (2 << 26);  ///< This register sets the behavior when the signal input of channel 1 detects a positive edge. 1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
        constexpr uint32_t CH1_HCTRL_MODE = (2 << 28);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH1_LCTRL_MODE = (2 << 30);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
    }

    /// U%s_CONF1 Register bits
    namespace u%s_conf1_bits {
        constexpr uint32_t CNT_THRES0 = (16 << 0);  ///< This register is used to configure the thres0 value for unit %s.
        constexpr uint32_t CNT_THRES1 = (16 << 16);  ///< This register is used to configure the thres1 value for unit %s.
    }

    /// U%s_CONF2 Register bits
    namespace u%s_conf2_bits {
        constexpr uint32_t CNT_H_LIM = (16 << 0);  ///< This register is used to configure the thr_h_lim value for unit %s. When pluse_cnt reaches this value, the counter will be cleared to 0.
        constexpr uint32_t CNT_L_LIM = (16 << 16);  ///< This register is used to configure the thr_l_lim value for unit %s. When pluse_cnt reaches this value, the counter will be cleared to 0.
    }

    /// U%s_CNT Register bits
    namespace u%s_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< This register stores the current pulse count value for unit %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// U%s_STATUS Register bits
    namespace u%s_status_bits {
        constexpr uint32_t ZERO_MODE = (2 << 0);  ///< The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
        constexpr uint32_t THRES1 = (1U << 2);  ///< The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
        constexpr uint32_t THRES0 = (1U << 3);  ///< The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
        constexpr uint32_t L_LIM = (1U << 4);  ///< The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
        constexpr uint32_t H_LIM = (1U << 5);  ///< The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
        constexpr uint32_t ZERO = (1U << 6);  ///< The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CNT_RST_U0 = (1U << 0);  ///< Set this bit to clear unit 0's counter.
        constexpr uint32_t CNT_PAUSE_U0 = (1U << 1);  ///< Set this bit to freeze unit 0's counter.
        constexpr uint32_t CNT_RST_U1 = (1U << 2);  ///< Set this bit to clear unit 1's counter.
        constexpr uint32_t CNT_PAUSE_U1 = (1U << 3);  ///< Set this bit to freeze unit 1's counter.
        constexpr uint32_t CNT_RST_U2 = (1U << 4);  ///< Set this bit to clear unit 2's counter.
        constexpr uint32_t CNT_PAUSE_U2 = (1U << 5);  ///< Set this bit to freeze unit 2's counter.
        constexpr uint32_t CNT_RST_U3 = (1U << 6);  ///< Set this bit to clear unit 3's counter.
        constexpr uint32_t CNT_PAUSE_U3 = (1U << 7);  ///< Set this bit to freeze unit 3's counter.
        constexpr uint32_t CLK_EN = (1U << 16);  ///< The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the PCNT version control register.
    }

}

// ============================================================================
// PCR Peripheral
// ============================================================================

namespace pcr {
    /// Base addresses
    constexpr uint32_t PCR_BASE = 0x60096000;

    /// PCR Register structure
    struct Registers {
        volatile uint32_t UART0_CONF;  ///< Offset: 0x00 - UART0 configuration register
        volatile uint32_t UART0_SCLK_CONF;  ///< Offset: 0x04 - UART0_SCLK configuration register
        volatile uint32_t UART0_PD_CTRL;  ///< Offset: 0x08 - UART0 power control register
        volatile uint32_t UART1_CONF;  ///< Offset: 0x0C - UART1 configuration register
        volatile uint32_t UART1_SCLK_CONF;  ///< Offset: 0x10 - UART1_SCLK configuration register
        volatile uint32_t UART1_PD_CTRL;  ///< Offset: 0x14 - UART1 power control register
        volatile uint32_t MSPI_CONF;  ///< Offset: 0x18 - MSPI configuration register
        volatile uint32_t MSPI_CLK_CONF;  ///< Offset: 0x1C - MSPI_CLK configuration register
        volatile uint32_t I2C0_CONF;  ///< Offset: 0x20 - I2C configuration register
        volatile uint32_t I2C0_SCLK_CONF;  ///< Offset: 0x24 - I2C_SCLK configuration register
        volatile uint32_t I2C1_CONF;  ///< Offset: 0x28 - I2C configuration register
        volatile uint32_t I2C1_SCLK_CONF;  ///< Offset: 0x2C - I2C_SCLK configuration register
        volatile uint32_t UHCI_CONF;  ///< Offset: 0x30 - UHCI configuration register
        volatile uint32_t RMT_CONF;  ///< Offset: 0x34 - RMT configuration register
        volatile uint32_t RMT_SCLK_CONF;  ///< Offset: 0x38 - RMT_SCLK configuration register
        volatile uint32_t LEDC_CONF;  ///< Offset: 0x3C - LEDC configuration register
        volatile uint32_t LEDC_SCLK_CONF;  ///< Offset: 0x40 - LEDC_SCLK configuration register
        volatile uint32_t TIMERGROUP0_CONF;  ///< Offset: 0x44 - TIMERGROUP0 configuration register
        volatile uint32_t TIMERGROUP0_TIMER_CLK_CONF;  ///< Offset: 0x48 - TIMERGROUP0_TIMER_CLK configuration register
        volatile uint32_t TIMERGROUP0_WDT_CLK_CONF;  ///< Offset: 0x4C - TIMERGROUP0_WDT_CLK configuration register
        volatile uint32_t TIMERGROUP1_CONF;  ///< Offset: 0x50 - TIMERGROUP1 configuration register
        volatile uint32_t TIMERGROUP1_TIMER_CLK_CONF;  ///< Offset: 0x54 - TIMERGROUP1_TIMER_CLK configuration register
        volatile uint32_t TIMERGROUP1_WDT_CLK_CONF;  ///< Offset: 0x58 - TIMERGROUP1_WDT_CLK configuration register
        volatile uint32_t SYSTIMER_CONF;  ///< Offset: 0x5C - SYSTIMER configuration register
        volatile uint32_t SYSTIMER_FUNC_CLK_CONF;  ///< Offset: 0x60 - SYSTIMER_FUNC_CLK configuration register
        volatile uint32_t TWAI0_CONF;  ///< Offset: 0x64 - TWAI0 configuration register
        volatile uint32_t TWAI0_FUNC_CLK_CONF;  ///< Offset: 0x68 - TWAI0_FUNC_CLK configuration register
        volatile uint32_t I2S_CONF;  ///< Offset: 0x6C - I2S configuration register
        volatile uint32_t I2S_TX_CLKM_CONF;  ///< Offset: 0x70 - I2S_TX_CLKM configuration register
        volatile uint32_t I2S_TX_CLKM_DIV_CONF;  ///< Offset: 0x74 - I2S_TX_CLKM_DIV configuration register
        volatile uint32_t I2S_RX_CLKM_CONF;  ///< Offset: 0x78 - I2S_RX_CLKM configuration register
        volatile uint32_t I2S_RX_CLKM_DIV_CONF;  ///< Offset: 0x7C - I2S_RX_CLKM_DIV configuration register
        volatile uint32_t SARADC_CONF;  ///< Offset: 0x80 - SARADC configuration register
        volatile uint32_t SARADC_CLKM_CONF;  ///< Offset: 0x84 - SARADC_CLKM configuration register
        volatile uint32_t TSENS_CLK_CONF;  ///< Offset: 0x88 - TSENS_CLK configuration register
        volatile uint32_t USB_DEVICE_CONF;  ///< Offset: 0x8C - USB_DEVICE configuration register
        volatile uint32_t INTMTX_CONF;  ///< Offset: 0x90 - INTMTX configuration register
        volatile uint32_t PCNT_CONF;  ///< Offset: 0x94 - PCNT configuration register
        volatile uint32_t ETM_CONF;  ///< Offset: 0x98 - ETM configuration register
        volatile uint32_t PWM_CONF;  ///< Offset: 0x9C - PWM configuration register
        volatile uint32_t PWM_CLK_CONF;  ///< Offset: 0xA0 - PWM_CLK configuration register
        volatile uint32_t PARL_IO_CONF;  ///< Offset: 0xA4 - PARL_IO configuration register
        volatile uint32_t PARL_CLK_RX_CONF;  ///< Offset: 0xA8 - PARL_CLK_RX configuration register
        volatile uint32_t PARL_CLK_TX_CONF;  ///< Offset: 0xAC - PARL_CLK_TX configuration register
        volatile uint32_t PVT_MONITOR_CONF;  ///< Offset: 0xB0 - PVT_MONITOR configuration register
        volatile uint32_t PVT_MONITOR_FUNC_CLK_CONF;  ///< Offset: 0xB4 - PVT_MONITOR function clock configuration register
        volatile uint32_t GDMA_CONF;  ///< Offset: 0xB8 - GDMA configuration register
        volatile uint32_t SPI2_CONF;  ///< Offset: 0xBC - SPI2 configuration register
        volatile uint32_t SPI2_CLKM_CONF;  ///< Offset: 0xC0 - SPI2_CLKM configuration register
        volatile uint32_t AES_CONF;  ///< Offset: 0xC4 - AES configuration register
        volatile uint32_t SHA_CONF;  ///< Offset: 0xC8 - SHA configuration register
        volatile uint32_t RSA_CONF;  ///< Offset: 0xCC - RSA configuration register
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0xD0 - RSA power control register
        volatile uint32_t ECC_CONF;  ///< Offset: 0xD4 - ECC configuration register
        volatile uint32_t ECC_PD_CTRL;  ///< Offset: 0xD8 - ECC power control register
        volatile uint32_t DS_CONF;  ///< Offset: 0xDC - DS configuration register
        volatile uint32_t HMAC_CONF;  ///< Offset: 0xE0 - HMAC configuration register
        volatile uint32_t ECDSA_CONF;  ///< Offset: 0xE4 - ECDSA configuration register
        volatile uint32_t IOMUX_CONF;  ///< Offset: 0xE8 - IOMUX configuration register
        volatile uint32_t IOMUX_CLK_CONF;  ///< Offset: 0xEC - IOMUX_CLK configuration register
        volatile uint32_t MEM_MONITOR_CONF;  ///< Offset: 0xF0 - MEM_MONITOR configuration register
        volatile uint32_t REGDMA_CONF;  ///< Offset: 0xF4 - REGDMA configuration register
        volatile uint32_t TRACE_CONF;  ///< Offset: 0xF8 - TRACE configuration register
        volatile uint32_t ASSIST_CONF;  ///< Offset: 0xFC - ASSIST configuration register
        volatile uint32_t CACHE_CONF;  ///< Offset: 0x100 - CACHE configuration register
        volatile uint32_t MODEM_CONF;  ///< Offset: 0x104 - MODEM_APB configuration register
        volatile uint32_t TIMEOUT_CONF;  ///< Offset: 0x108 - TIMEOUT configuration register
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x10C - SYSCLK configuration register
        volatile uint32_t CPU_WAITI_CONF;  ///< Offset: 0x110 - CPU_WAITI configuration register
        volatile uint32_t CPU_FREQ_CONF;  ///< Offset: 0x114 - CPU_FREQ configuration register
        volatile uint32_t AHB_FREQ_CONF;  ///< Offset: 0x118 - AHB_FREQ configuration register
        volatile uint32_t APB_FREQ_CONF;  ///< Offset: 0x11C - APB_FREQ configuration register
        volatile uint32_t SYSCLK_FREQ_QUERY_0;  ///< Offset: 0x120 - SYSCLK frequency query 0 register
        volatile uint32_t PLL_DIV_CLK_EN;  ///< Offset: 0x124 - SPLL DIV clock-gating configuration register
        volatile uint32_t CTRL_CLK_OUT_EN;  ///< Offset: 0x128 - CLK_OUT_EN configuration register
        volatile uint32_t CTRL_TICK_CONF;  ///< Offset: 0x12C - TICK configuration register
        volatile uint32_t CTRL_32K_CONF;  ///< Offset: 0x130 - 32KHz clock configuration register
        volatile uint32_t SRAM_POWER_CONF_0;  ///< Offset: 0x134 - HP SRAM/ROM configuration register
        volatile uint32_t SRAM_POWER_CONF_1;  ///< Offset: 0x138 - HP SRAM/ROM configuration register
        volatile uint32_t SEC_CONF;  ///< Offset: 0x13C - xxxx
        volatile uint32_t ADC_INV_PHASE_CONF;  ///< Offset: 0x140 - xxxx
        volatile uint32_t SDM_INV_PHASE_CONF;  ///< Offset: 0x144 - xxxx
        volatile uint32_t BUS_CLK_UPDATE;  ///< Offset: 0x148 - xxxx
        volatile uint32_t SAR_CLK_DIV;  ///< Offset: 0x14C - xxxx
        volatile uint32_t PWDET_SAR_CLK_CONF;  ///< Offset: 0x150 - xxxx
        volatile uint32_t RESET_EVENT_BYPASS;  ///< Offset: 0xFF0 - reset event bypass backdoor configuration register
        volatile uint32_t FPGA_DEBUG;  ///< Offset: 0xFF4 - fpga debug register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xFF8 - PCR clock gating configure register
        volatile uint32_t DATE;  ///< Offset: 0xFFC - Date register.
    };

    /// Peripheral instances
    inline Registers* PCR = reinterpret_cast<Registers*>(PCR_BASE);

    // Bit definitions
    /// UART0_CONF Register bits
    namespace uart0_conf_bits {
        constexpr uint32_t UART0_CLK_EN = (1U << 0);  ///< Set 1 to enable uart0 apb clock
        constexpr uint32_t UART0_RST_EN = (1U << 1);  ///< Set 0 to reset uart0 module
        constexpr uint32_t UART0_READY = (1U << 2);  ///< Query this field after reset uart0 module
    }

    /// UART0_SCLK_CONF Register bits
    namespace uart0_sclk_conf_bits {
        constexpr uint32_t UART0_SCLK_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the uart0 function clock.
        constexpr uint32_t UART0_SCLK_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the uart0 function clock.
        constexpr uint32_t UART0_SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the uart0 function clock.
        constexpr uint32_t UART0_SCLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
        constexpr uint32_t UART0_SCLK_EN = (1U << 22);  ///< Set 1 to enable uart0 function clock
    }

    /// UART0_PD_CTRL Register bits
    namespace uart0_pd_ctrl_bits {
        constexpr uint32_t UART0_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power down UART0 memory.
        constexpr uint32_t UART0_MEM_FORCE_PD = (1U << 2);  ///< Set this bit to force power up UART0 memory.
    }

    /// UART1_CONF Register bits
    namespace uart1_conf_bits {
        constexpr uint32_t UART1_CLK_EN = (1U << 0);  ///< Set 1 to enable uart1 apb clock
        constexpr uint32_t UART1_RST_EN = (1U << 1);  ///< Set 0 to reset uart1 module
        constexpr uint32_t UART1_READY = (1U << 2);  ///< Query this field after reset uart1 module
    }

    /// UART1_SCLK_CONF Register bits
    namespace uart1_sclk_conf_bits {
        constexpr uint32_t UART1_SCLK_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the uart1 function clock.
        constexpr uint32_t UART1_SCLK_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the uart1 function clock.
        constexpr uint32_t UART1_SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the uart1 function clock.
        constexpr uint32_t UART1_SCLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
        constexpr uint32_t UART1_SCLK_EN = (1U << 22);  ///< Set 1 to enable uart0 function clock
    }

    /// UART1_PD_CTRL Register bits
    namespace uart1_pd_ctrl_bits {
        constexpr uint32_t UART1_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power down UART1 memory.
        constexpr uint32_t UART1_MEM_FORCE_PD = (1U << 2);  ///< Set this bit to force power up UART1 memory.
    }

    /// MSPI_CONF Register bits
    namespace mspi_conf_bits {
        constexpr uint32_t MSPI_CLK_EN = (1U << 0);  ///< Set 1 to enable mspi clock, include mspi pll clock
        constexpr uint32_t MSPI_RST_EN = (1U << 1);  ///< Set 0 to reset mspi module
        constexpr uint32_t MSPI_PLL_CLK_EN = (1U << 2);  ///< Set 1 to enable mspi pll clock
        constexpr uint32_t MSPI_CLK_SEL = (2 << 3);  ///< set this field to select clock-source.
        constexpr uint32_t MSPI_READY = (1U << 5);  ///< Query this field after reset mspi module
    }

    /// MSPI_CLK_CONF Register bits
    namespace mspi_clk_conf_bits {
        constexpr uint32_t MSPI_FAST_DIV_NUM = (8 << 0);  ///< Set as one within (0,1,2) to generate div1(default)/div2/div4 of low-speed clock-source to drive clk_mspi_fast. Only avaiable whe the clck-source is a low-speed clock-source such as XTAL/FOSC.
    }

    /// I2C0_CONF Register bits
    namespace i2c0_conf_bits {
        constexpr uint32_t I2C0_CLK_EN = (1U << 0);  ///< Set 1 to enable i2c apb clock
        constexpr uint32_t I2C0_RST_EN = (1U << 1);  ///< Set 0 to reset i2c module
        constexpr uint32_t I2C0_READY = (1U << 2);  ///< Query this field after reset i2c0 module
    }

    /// I2C0_SCLK_CONF Register bits
    namespace i2c0_sclk_conf_bits {
        constexpr uint32_t I2C0_SCLK_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C0_SCLK_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C0_SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C0_SCLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: FOSC.
        constexpr uint32_t I2C0_SCLK_EN = (1U << 22);  ///< Set 1 to enable i2c function clock
    }

    /// I2C1_CONF Register bits
    namespace i2c1_conf_bits {
        constexpr uint32_t I2C1_CLK_EN = (1U << 0);  ///< Set 1 to enable i2c apb clock
        constexpr uint32_t I2C1_RST_EN = (1U << 1);  ///< Set 0 to reset i2c module
        constexpr uint32_t I2C1_READY = (1U << 2);  ///< Query this field after reset i2c1 module
    }

    /// I2C1_SCLK_CONF Register bits
    namespace i2c1_sclk_conf_bits {
        constexpr uint32_t I2C1_SCLK_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C1_SCLK_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C1_SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the i2c function clock.
        constexpr uint32_t I2C1_SCLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: FOSC.
        constexpr uint32_t I2C1_SCLK_EN = (1U << 22);  ///< Set 1 to enable i2c function clock
    }

    /// UHCI_CONF Register bits
    namespace uhci_conf_bits {
        constexpr uint32_t UHCI_CLK_EN = (1U << 0);  ///< Set 1 to enable uhci clock
        constexpr uint32_t UHCI_RST_EN = (1U << 1);  ///< Set 0 to reset uhci module
        constexpr uint32_t UHCI_READY = (1U << 2);  ///< Query this field after reset uhci module
    }

    /// RMT_CONF Register bits
    namespace rmt_conf_bits {
        constexpr uint32_t RMT_CLK_EN = (1U << 0);  ///< Set 1 to enable rmt apb clock
        constexpr uint32_t RMT_RST_EN = (1U << 1);  ///< Set 0 to reset rmt module
        constexpr uint32_t RMT_READY = (1U << 2);  ///< Query this field after reset rmt module
    }

    /// RMT_SCLK_CONF Register bits
    namespace rmt_sclk_conf_bits {
        constexpr uint32_t SCLK_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the rmt function clock.
        constexpr uint32_t SCLK_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the rmt function clock.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the rmt function clock.
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0: do not select anyone clock, 1(default): 80MHz, 2: FOSC, 3: XTAL.
        constexpr uint32_t SCLK_EN = (1U << 21);  ///< Set 1 to enable rmt function clock
    }

    /// LEDC_CONF Register bits
    namespace ledc_conf_bits {
        constexpr uint32_t LEDC_CLK_EN = (1U << 0);  ///< Set 1 to enable ledc apb clock
        constexpr uint32_t LEDC_RST_EN = (1U << 1);  ///< Set 0 to reset ledc module
        constexpr uint32_t LEDC_READY = (1U << 2);  ///< Query this field after reset ledc module
    }

    /// LEDC_SCLK_CONF Register bits
    namespace ledc_sclk_conf_bits {
        constexpr uint32_t LEDC_SCLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): do not select anyone clock, 1: 80MHz, 2: FOSC, 3: XTAL.
        constexpr uint32_t LEDC_SCLK_EN = (1U << 22);  ///< Set 1 to enable ledc function clock
    }

    /// TIMERGROUP0_CONF Register bits
    namespace timergroup0_conf_bits {
        constexpr uint32_t TG0_CLK_EN = (1U << 0);  ///< Set 1 to enable timer_group0 apb clock
        constexpr uint32_t TG0_RST_EN = (1U << 1);  ///< Set 0 to reset timer_group0 module
        constexpr uint32_t TG0_WDT_READY = (1U << 2);  ///< Query this field after reset timer_group0 wdt module
        constexpr uint32_t TG0_TIMER0_READY = (1U << 3);  ///< Query this field after reset timer_group0 timer0 module
        constexpr uint32_t TG0_TIMER1_READY = (1U << 4);  ///< reserved
    }

    /// TIMERGROUP0_TIMER_CLK_CONF Register bits
    namespace timergroup0_timer_clk_conf_bits {
        constexpr uint32_t TG0_TIMER_CLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t TG0_TIMER_CLK_EN = (1U << 22);  ///< Set 1 to enable timer_group0 timer clock
    }

    /// TIMERGROUP0_WDT_CLK_CONF Register bits
    namespace timergroup0_wdt_clk_conf_bits {
        constexpr uint32_t TG0_WDT_CLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t TG0_WDT_CLK_EN = (1U << 22);  ///< Set 1 to enable timer_group0 wdt clock
    }

    /// TIMERGROUP1_CONF Register bits
    namespace timergroup1_conf_bits {
        constexpr uint32_t TG1_CLK_EN = (1U << 0);  ///< Set 1 to enable timer_group1 apb clock
        constexpr uint32_t TG1_RST_EN = (1U << 1);  ///< Set 0 to reset timer_group1 module
        constexpr uint32_t TG1_WDT_READY = (1U << 2);  ///< Query this field after reset timer_group1 wdt module
        constexpr uint32_t TG1_TIMER0_READY = (1U << 3);  ///< Query this field after reset timer_group1 timer0 module
        constexpr uint32_t TG1_TIMER1_READY = (1U << 4);  ///< reserved
    }

    /// TIMERGROUP1_TIMER_CLK_CONF Register bits
    namespace timergroup1_timer_clk_conf_bits {
        constexpr uint32_t TG1_TIMER_CLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t TG1_TIMER_CLK_EN = (1U << 22);  ///< Set 1 to enable timer_group1 timer clock
    }

    /// TIMERGROUP1_WDT_CLK_CONF Register bits
    namespace timergroup1_wdt_clk_conf_bits {
        constexpr uint32_t TG1_WDT_CLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t TG1_WDT_CLK_EN = (1U << 22);  ///< Set 1 to enable timer_group0 wdt clock
    }

    /// SYSTIMER_CONF Register bits
    namespace systimer_conf_bits {
        constexpr uint32_t SYSTIMER_CLK_EN = (1U << 0);  ///< Set 1 to enable systimer apb clock
        constexpr uint32_t SYSTIMER_RST_EN = (1U << 1);  ///< Set 0 to reset systimer module
        constexpr uint32_t SYSTIMER_READY = (1U << 2);  ///< Query this field after reset systimer module
    }

    /// SYSTIMER_FUNC_CLK_CONF Register bits
    namespace systimer_func_clk_conf_bits {
        constexpr uint32_t SYSTIMER_FUNC_CLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: FOSC.
        constexpr uint32_t SYSTIMER_FUNC_CLK_EN = (1U << 22);  ///< Set 1 to enable systimer function clock
    }

    /// TWAI0_CONF Register bits
    namespace twai0_conf_bits {
        constexpr uint32_t TWAI0_CLK_EN = (1U << 0);  ///< Set 1 to enable twai0 apb clock
        constexpr uint32_t TWAI0_RST_EN = (1U << 1);  ///< Set 0 to reset twai0 module
        constexpr uint32_t TWAI0_READY = (1U << 2);  ///< Query this field after reset twai0 module
    }

    /// TWAI0_FUNC_CLK_CONF Register bits
    namespace twai0_func_clk_conf_bits {
        constexpr uint32_t TWAI0_FUNC_CLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: FOSC.
        constexpr uint32_t TWAI0_FUNC_CLK_EN = (1U << 22);  ///< Set 1 to enable twai0 function clock
    }

    /// I2S_CONF Register bits
    namespace i2s_conf_bits {
        constexpr uint32_t I2S_CLK_EN = (1U << 0);  ///< Set 1 to enable i2s apb clock
        constexpr uint32_t I2S_RST_EN = (1U << 1);  ///< Set 0 to reset i2s module
        constexpr uint32_t I2S_RX_READY = (1U << 2);  ///< Query this field before using i2s rx function, after reset i2s module
        constexpr uint32_t I2S_TX_READY = (1U << 3);  ///< Query this field before using i2s tx function, after reset i2s module
    }

    /// I2S_TX_CLKM_CONF Register bits
    namespace i2s_tx_clkm_conf_bits {
        constexpr uint32_t I2S_TX_CLKM_DIV_NUM = (8 << 12);  ///< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div. So the average combination will be: for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
        constexpr uint32_t I2S_TX_CLKM_SEL = (2 << 20);  ///< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t I2S_TX_CLKM_EN = (1U << 22);  ///< Set 1 to enable i2s_tx function clock
    }

    /// I2S_TX_CLKM_DIV_CONF Register bits
    namespace i2s_tx_clkm_div_conf_bits {
        constexpr uint32_t I2S_TX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t I2S_TX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t I2S_TX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t I2S_TX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
    }

    /// I2S_RX_CLKM_CONF Register bits
    namespace i2s_rx_clkm_conf_bits {
        constexpr uint32_t I2S_RX_CLKM_DIV_NUM = (8 << 12);  ///< Integral I2S clock divider value
        constexpr uint32_t I2S_RX_CLKM_SEL = (2 << 20);  ///< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t I2S_RX_CLKM_EN = (1U << 22);  ///< Set 1 to enable i2s_rx function clock
        constexpr uint32_t I2S_MCLK_SEL = (1U << 23);  ///< This field is used to select master-clock. 0(default): clk_i2s_rx, 1: clk_i2s_tx
    }

    /// I2S_RX_CLKM_DIV_CONF Register bits
    namespace i2s_rx_clkm_div_conf_bits {
        constexpr uint32_t I2S_RX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t I2S_RX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t I2S_RX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t I2S_RX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
    }

    /// SARADC_CONF Register bits
    namespace saradc_conf_bits {
        constexpr uint32_t SARADC_CLK_EN = (1U << 0);  ///< no use
        constexpr uint32_t SARADC_RST_EN = (1U << 1);  ///< Set 0 to reset function_register of saradc module
        constexpr uint32_t SARADC_REG_CLK_EN = (1U << 2);  ///< Set 1 to enable saradc apb clock
        constexpr uint32_t SARADC_REG_RST_EN = (1U << 3);  ///< Set 0 to reset apb_register of saradc module
    }

    /// SARADC_CLKM_CONF Register bits
    namespace saradc_clkm_conf_bits {
        constexpr uint32_t SARADC_CLKM_DIV_A = (6 << 0);  ///< The denominator of the frequency divider factor of the saradc function clock.
        constexpr uint32_t SARADC_CLKM_DIV_B = (6 << 6);  ///< The numerator of the frequency divider factor of the saradc function clock.
        constexpr uint32_t SARADC_CLKM_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the saradc function clock.
        constexpr uint32_t SARADC_CLKM_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t SARADC_CLKM_EN = (1U << 22);  ///< Set 1 to enable saradc function clock
    }

    /// TSENS_CLK_CONF Register bits
    namespace tsens_clk_conf_bits {
        constexpr uint32_t TSENS_CLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0(default): FOSC, 1: XTAL.
        constexpr uint32_t TSENS_CLK_EN = (1U << 22);  ///< Set 1 to enable tsens clock
        constexpr uint32_t TSENS_RST_EN = (1U << 23);  ///< Set 0 to reset tsens module
    }

    /// USB_DEVICE_CONF Register bits
    namespace usb_device_conf_bits {
        constexpr uint32_t USB_DEVICE_CLK_EN = (1U << 0);  ///< Set 1 to enable usb_device clock
        constexpr uint32_t USB_DEVICE_RST_EN = (1U << 1);  ///< Set 0 to reset usb_device module
        constexpr uint32_t USB_DEVICE_READY = (1U << 2);  ///< Query this field after reset usb_device module
    }

    /// INTMTX_CONF Register bits
    namespace intmtx_conf_bits {
        constexpr uint32_t INTMTX_CLK_EN = (1U << 0);  ///< Set 1 to enable intmtx clock
        constexpr uint32_t INTMTX_RST_EN = (1U << 1);  ///< Set 0 to reset intmtx module
        constexpr uint32_t INTMTX_READY = (1U << 2);  ///< Query this field after reset intmtx module
    }

    /// PCNT_CONF Register bits
    namespace pcnt_conf_bits {
        constexpr uint32_t PCNT_CLK_EN = (1U << 0);  ///< Set 1 to enable pcnt clock
        constexpr uint32_t PCNT_RST_EN = (1U << 1);  ///< Set 0 to reset pcnt module
        constexpr uint32_t PCNT_READY = (1U << 2);  ///< Query this field after reset pcnt module
    }

    /// ETM_CONF Register bits
    namespace etm_conf_bits {
        constexpr uint32_t ETM_CLK_EN = (1U << 0);  ///< Set 1 to enable etm clock
        constexpr uint32_t ETM_RST_EN = (1U << 1);  ///< Set 0 to reset etm module
        constexpr uint32_t ETM_READY = (1U << 2);  ///< Query this field after reset etm module
    }

    /// PWM_CONF Register bits
    namespace pwm_conf_bits {
        constexpr uint32_t PWM_CLK_EN = (1U << 0);  ///< Set 1 to enable pwm clock
        constexpr uint32_t PWM_RST_EN = (1U << 1);  ///< Set 0 to reset pwm module
        constexpr uint32_t PWM_READY = (1U << 2);  ///< Query this field after reset pwm module
    }

    /// PWM_CLK_CONF Register bits
    namespace pwm_clk_conf_bits {
        constexpr uint32_t PWM_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor of the pwm function clock.
        constexpr uint32_t PWM_CLKM_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): do not select anyone clock, 1: 160MHz, 2: XTAL, 3: FOSC.
        constexpr uint32_t PWM_CLKM_EN = (1U << 22);  ///< set this field as 1 to activate pwm clkm.
    }

    /// PARL_IO_CONF Register bits
    namespace parl_io_conf_bits {
        constexpr uint32_t PARL_CLK_EN = (1U << 0);  ///< Set 1 to enable parl apb clock
        constexpr uint32_t PARL_RST_EN = (1U << 1);  ///< Set 0 to reset parl apb reg
        constexpr uint32_t PARL_READY = (1U << 2);  ///< Query this field after reset parl module
    }

    /// PARL_CLK_RX_CONF Register bits
    namespace parl_clk_rx_conf_bits {
        constexpr uint32_t PARL_CLK_RX_DIV_NUM = (16 << 0);  ///< The integral part of the frequency divider factor of the parl rx clock.
        constexpr uint32_t PARL_CLK_RX_SEL = (2 << 16);  ///< set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
        constexpr uint32_t PARL_CLK_RX_EN = (1U << 18);  ///< Set 1 to enable parl rx clock
        constexpr uint32_t PARL_RX_RST_EN = (1U << 19);  ///< Set 0 to reset parl rx module
    }

    /// PARL_CLK_TX_CONF Register bits
    namespace parl_clk_tx_conf_bits {
        constexpr uint32_t PARL_CLK_TX_DIV_NUM = (16 << 0);  ///< The integral part of the frequency divider factor of the parl tx clock.
        constexpr uint32_t PARL_CLK_TX_SEL = (2 << 16);  ///< set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
        constexpr uint32_t PARL_CLK_TX_EN = (1U << 18);  ///< Set 1 to enable parl tx clock
        constexpr uint32_t PARL_TX_RST_EN = (1U << 19);  ///< Set 0 to reset parl tx module
    }

    /// PVT_MONITOR_CONF Register bits
    namespace pvt_monitor_conf_bits {
        constexpr uint32_t PVT_MONITOR_CLK_EN = (1U << 0);  ///< Set 1 to enable apb clock of pvt module
        constexpr uint32_t PVT_MONITOR_RST_EN = (1U << 1);  ///< Set 0 to reset all pvt monitor module
        constexpr uint32_t PVT_MONITOR_SITE1_CLK_EN = (1U << 2);  ///< Set 1 to enable function clock of modem pvt module
        constexpr uint32_t PVT_MONITOR_SITE2_CLK_EN = (1U << 3);  ///< Set 1 to enable function clock of cpu pvt module
        constexpr uint32_t PVT_MONITOR_SITE3_CLK_EN = (1U << 4);  ///< Set 1 to enable function clock of hp_peri pvt module
    }

    /// PVT_MONITOR_FUNC_CLK_CONF Register bits
    namespace pvt_monitor_func_clk_conf_bits {
        constexpr uint32_t PVT_MONITOR_FUNC_CLK_DIV_NUM = (4 << 0);  ///< The integral part of the frequency divider factor of the pvt_monitor function clock.
        constexpr uint32_t PVT_MONITOR_FUNC_CLK_SEL = (1U << 20);  ///< set this field to select clock-source. 0: XTAL, 1(default): 160MHz drived by SPLL divided by 3.
        constexpr uint32_t PVT_MONITOR_FUNC_CLK_EN = (1U << 22);  ///< Set 1 to enable source clock of pvt sitex
    }

    /// GDMA_CONF Register bits
    namespace gdma_conf_bits {
        constexpr uint32_t GDMA_CLK_EN = (1U << 0);  ///< Set 1 to enable gdma clock
        constexpr uint32_t GDMA_RST_EN = (1U << 1);  ///< Set 0 to reset gdma module
    }

    /// SPI2_CONF Register bits
    namespace spi2_conf_bits {
        constexpr uint32_t SPI2_CLK_EN = (1U << 0);  ///< Set 1 to enable spi2 apb clock
        constexpr uint32_t SPI2_RST_EN = (1U << 1);  ///< Set 0 to reset spi2 module
        constexpr uint32_t SPI2_READY = (1U << 2);  ///< Query this field after reset spi2 module
    }

    /// SPI2_CLKM_CONF Register bits
    namespace spi2_clkm_conf_bits {
        constexpr uint32_t SPI2_CLKM_SEL = (2 << 20);  ///< set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
        constexpr uint32_t SPI2_CLKM_EN = (1U << 22);  ///< Set 1 to enable spi2 function clock
    }

    /// AES_CONF Register bits
    namespace aes_conf_bits {
        constexpr uint32_t AES_CLK_EN = (1U << 0);  ///< Set 1 to enable aes clock
        constexpr uint32_t AES_RST_EN = (1U << 1);  ///< Set 0 to reset aes module
        constexpr uint32_t AES_READY = (1U << 2);  ///< Query this field after reset aes module
    }

    /// SHA_CONF Register bits
    namespace sha_conf_bits {
        constexpr uint32_t SHA_CLK_EN = (1U << 0);  ///< Set 1 to enable sha clock
        constexpr uint32_t SHA_RST_EN = (1U << 1);  ///< Set 0 to reset sha module
        constexpr uint32_t SHA_READY = (1U << 2);  ///< Query this field after reset sha module
    }

    /// RSA_CONF Register bits
    namespace rsa_conf_bits {
        constexpr uint32_t RSA_CLK_EN = (1U << 0);  ///< Set 1 to enable rsa clock
        constexpr uint32_t RSA_RST_EN = (1U << 1);  ///< Set 0 to reset rsa module
        constexpr uint32_t RSA_READY = (1U << 2);  ///< Query this field after reset rsa module
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_PD = (1U << 0);  ///< Set this bit to power down rsa internal memory.
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up rsa internal memory
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 2);  ///< Set this bit to force power down rsa internal memory.
    }

    /// ECC_CONF Register bits
    namespace ecc_conf_bits {
        constexpr uint32_t ECC_CLK_EN = (1U << 0);  ///< Set 1 to enable ecc clock
        constexpr uint32_t ECC_RST_EN = (1U << 1);  ///< Set 0 to reset ecc module
        constexpr uint32_t ECC_READY = (1U << 2);  ///< Query this field after reset ecc module
    }

    /// ECC_PD_CTRL Register bits
    namespace ecc_pd_ctrl_bits {
        constexpr uint32_t ECC_MEM_PD = (1U << 0);  ///< Set this bit to power down ecc internal memory.
        constexpr uint32_t ECC_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up ecc internal memory
        constexpr uint32_t ECC_MEM_FORCE_PD = (1U << 2);  ///< Set this bit to force power down ecc internal memory.
    }

    /// DS_CONF Register bits
    namespace ds_conf_bits {
        constexpr uint32_t DS_CLK_EN = (1U << 0);  ///< Set 1 to enable ds clock
        constexpr uint32_t DS_RST_EN = (1U << 1);  ///< Set 0 to reset ds module
        constexpr uint32_t DS_READY = (1U << 2);  ///< Query this field after reset ds module
    }

    /// HMAC_CONF Register bits
    namespace hmac_conf_bits {
        constexpr uint32_t HMAC_CLK_EN = (1U << 0);  ///< Set 1 to enable hmac clock
        constexpr uint32_t HMAC_RST_EN = (1U << 1);  ///< Set 0 to reset hmac module
        constexpr uint32_t HMAC_READY = (1U << 2);  ///< Query this field after reset hmac module
    }

    /// ECDSA_CONF Register bits
    namespace ecdsa_conf_bits {
        constexpr uint32_t ECDSA_CLK_EN = (1U << 0);  ///< Set 1 to enable ecdsa clock
        constexpr uint32_t ECDSA_RST_EN = (1U << 1);  ///< Set 0 to reset ecdsa module
        constexpr uint32_t ECDSA_READY = (1U << 2);  ///< Query this field after reset ecdsa module
    }

    /// IOMUX_CONF Register bits
    namespace iomux_conf_bits {
        constexpr uint32_t IOMUX_CLK_EN = (1U << 0);  ///< Set 1 to enable iomux apb clock
        constexpr uint32_t IOMUX_RST_EN = (1U << 1);  ///< Set 0 to reset iomux module
    }

    /// IOMUX_CLK_CONF Register bits
    namespace iomux_clk_conf_bits {
        constexpr uint32_t IOMUX_FUNC_CLK_SEL = (2 << 20);  ///< set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
        constexpr uint32_t IOMUX_FUNC_CLK_EN = (1U << 22);  ///< Set 1 to enable iomux function clock
    }

    /// MEM_MONITOR_CONF Register bits
    namespace mem_monitor_conf_bits {
        constexpr uint32_t MEM_MONITOR_CLK_EN = (1U << 0);  ///< Set 1 to enable mem_monitor clock
        constexpr uint32_t MEM_MONITOR_RST_EN = (1U << 1);  ///< Set 0 to reset mem_monitor module
        constexpr uint32_t MEM_MONITOR_READY = (1U << 2);  ///< Query this field after reset mem_monitor module
    }

    /// REGDMA_CONF Register bits
    namespace regdma_conf_bits {
        constexpr uint32_t REGDMA_CLK_EN = (1U << 0);  ///< Set 1 to enable regdma clock
        constexpr uint32_t REGDMA_RST_EN = (1U << 1);  ///< Set 0 to reset regdma module
    }

    /// TRACE_CONF Register bits
    namespace trace_conf_bits {
        constexpr uint32_t TRACE_CLK_EN = (1U << 0);  ///< Set 1 to enable trace clock
        constexpr uint32_t TRACE_RST_EN = (1U << 1);  ///< Set 0 to reset trace module
    }

    /// ASSIST_CONF Register bits
    namespace assist_conf_bits {
        constexpr uint32_t ASSIST_CLK_EN = (1U << 0);  ///< Set 1 to enable assist clock
        constexpr uint32_t ASSIST_RST_EN = (1U << 1);  ///< Set 0 to reset assist module
    }

    /// CACHE_CONF Register bits
    namespace cache_conf_bits {
        constexpr uint32_t CACHE_CLK_EN = (1U << 0);  ///< Set 1 to enable cache clock
        constexpr uint32_t CACHE_RST_EN = (1U << 1);  ///< Set 0 to reset cache module
    }

    /// MODEM_CONF Register bits
    namespace modem_conf_bits {
        constexpr uint32_t MODEM_CLK_SEL = (1U << 0);  ///< xxxx
        constexpr uint32_t MODEM_CLK_EN = (1U << 1);  ///< xxxx
        constexpr uint32_t MODEM_RST_EN = (1U << 2);  ///< Set this file as 1 to reset modem-subsystem.
    }

    /// TIMEOUT_CONF Register bits
    namespace timeout_conf_bits {
        constexpr uint32_t CPU_TIMEOUT_RST_EN = (1U << 1);  ///< Set 0 to reset cpu_peri timeout module
        constexpr uint32_t HP_TIMEOUT_RST_EN = (1U << 2);  ///< Set 0 to reset hp_peri timeout module and hp_modem timeout module
    }

    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t LS_DIV_NUM = (8 << 0);  ///< clk_hproot is div1 of low-speed clock-source if clck-source is a low-speed clock-source such as XTAL/FOSC.
        constexpr uint32_t HS_DIV_NUM = (8 << 8);  ///< clk_hproot is div3 of SPLL if the clock-source is high-speed clock SPLL.
        constexpr uint32_t SOC_CLK_SEL = (2 << 16);  ///< This field is used to select clock source. 0: XTAL, 1: SPLL, 2: FOSC, 3: reserved.
        constexpr uint32_t CLK_XTAL_FREQ = (7 << 24);  ///< This field indicates the frequency(MHz) of XTAL.
    }

    /// CPU_WAITI_CONF Register bits
    namespace cpu_waiti_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< Reserved. This filed has been replaced by PCR_CPU_DIV_NUM
        constexpr uint32_t PLL_FREQ_SEL = (1U << 2);  ///< Reserved. This filed has been replaced by PCR_CPU_DIV_NUM
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 3);  ///< Set 1 to force cpu_waiti_clk enable.
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 4);  ///< This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
    }

    /// CPU_FREQ_CONF Register bits
    namespace cpu_freq_conf_bits {
        constexpr uint32_t CPU_DIV_NUM = (8 << 0);  ///< Set this field to generate clk_cpu drived by clk_hproot. The clk_cpu is div1(default)/div2/div4 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_AHB_DIV_NUM.
    }

    /// AHB_FREQ_CONF Register bits
    namespace ahb_freq_conf_bits {
        constexpr uint32_t AHB_DIV_NUM = (8 << 0);  ///< Set this field to generate clk_ahb drived by clk_hproot. The clk_ahb is div1(default)/div2/div4/div8 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_CPU_DIV_NUM.
    }

    /// APB_FREQ_CONF Register bits
    namespace apb_freq_conf_bits {
        constexpr uint32_t APB_DECREASE_DIV_NUM = (8 << 0);  ///< If this field's value is grater than PCR_APB_DIV_NUM, the clk_apb will be automatically down to clk_apb_decrease only when no access is on apb-bus, and will recover to the previous frequency when a new access appears on apb-bus. Set as one within (0,1,3) to set clk_apb_decrease as div1/div2/div4(default) of clk_ahb. Note that enable this function will reduce performance. Users can set this field as zero to disable the auto-decrease-apb-freq function. By default, this function is disable.
        constexpr uint32_t APB_DIV_NUM = (8 << 8);  ///< Set as one within (0,1,3) to generate clk_apb drived by clk_ahb. The clk_apb is div1(default)/div2/div4 of clk_ahb.
    }

    /// SYSCLK_FREQ_QUERY_0 Register bits
    namespace sysclk_freq_query_0_bits {
        constexpr uint32_t FOSC_FREQ = (8 << 0);  ///< This field indicates the frequency(MHz) of FOSC.
        constexpr uint32_t PLL_FREQ = (10 << 8);  ///< This field indicates the frequency(MHz) of SPLL.
    }

    /// PLL_DIV_CLK_EN Register bits
    namespace pll_div_clk_en_bits {
        constexpr uint32_t PLL_240M_CLK_EN = (1U << 0);  ///< This field is used to open 96 MHz clock (SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
        constexpr uint32_t PLL_160M_CLK_EN = (1U << 1);  ///< This field is used to open 64 MHz clock (div3 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
        constexpr uint32_t PLL_120M_CLK_EN = (1U << 2);  ///< This field is used to open 48 MHz clock (div4 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
        constexpr uint32_t PLL_80M_CLK_EN = (1U << 3);  ///< This field is used to open 32 MHz clock (div6 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
        constexpr uint32_t PLL_48M_CLK_EN = (1U << 4);  ///< This field is used to open 16 MHz clock (div10 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
        constexpr uint32_t PLL_40M_CLK_EN = (1U << 5);  ///< This field is used to open 8 MHz clock (div12 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
    }

    /// CTRL_CLK_OUT_EN Register bits
    namespace ctrl_clk_out_en_bits {
        constexpr uint32_t CLK8_OEN = (1U << 0);  ///< Set 1 to enable 8m clock
        constexpr uint32_t CLK16_OEN = (1U << 1);  ///< Set 1 to enable 16m clock
        constexpr uint32_t CLK32_OEN = (1U << 2);  ///< Set 1 to enable 32m clock
        constexpr uint32_t CLK_ADC_INF_OEN = (1U << 3);  ///< Reserved
        constexpr uint32_t CLK_DFM_INF_OEN = (1U << 4);  ///< Reserved
        constexpr uint32_t CLK_SDM_MOD_OEN = (1U << 5);  ///< Reserved
        constexpr uint32_t CLK_XTAL_OEN = (1U << 6);  ///< Set 1 to enable xtal clock
    }

    /// CTRL_TICK_CONF Register bits
    namespace ctrl_tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< ******* Description ***********
        constexpr uint32_t FOSC_TICK_NUM = (8 << 8);  ///< ******* Description ***********
        constexpr uint32_t TICK_ENABLE = (1U << 16);  ///< ******* Description ***********
        constexpr uint32_t RST_TICK_CNT = (1U << 17);  ///< ******* Description ***********
    }

    /// CTRL_32K_CONF Register bits
    namespace ctrl_32k_conf_bits {
        constexpr uint32_t CLK_32K_SEL = (2 << 0);  ///< This field indicates which one 32KHz clock will be used by timergroup. 0: OSC32K(default), 1: XTAL32K, 2/3: 32KHz from pad GPIO0.
        constexpr uint32_t _32K_MODEM_SEL = (2 << 2);  ///< This field indicates which one 32KHz clock will be used by MODEM_SYSTEM. 0: OSC32K(default), 1: XTAL32K, 2/3: 32KHz from pad GPIO0.
    }

    /// SRAM_POWER_CONF_0 Register bits
    namespace sram_power_conf_0_bits {
        constexpr uint32_t ROM_FORCE_PU = (2 << 13);  ///< Set this bit to force power up ROM
        constexpr uint32_t ROM_FORCE_PD = (2 << 15);  ///< Set this bit to force power down ROM.
        constexpr uint32_t ROM_CLKGATE_FORCE_ON = (2 << 17);  ///< 1: Force to open the clock and bypass the gate-clock when accessing the ROM. 0: A gate-clock will be used when accessing the ROM.
    }

    /// SRAM_POWER_CONF_1 Register bits
    namespace sram_power_conf_1_bits {
        constexpr uint32_t SRAM_FORCE_PU = (5 << 0);  ///< Set this bit to force power up SRAM
        constexpr uint32_t SRAM_FORCE_PD = (5 << 10);  ///< Set this bit to force power down SRAM.
        constexpr uint32_t SRAM_CLKGATE_FORCE_ON = (5 << 25);  ///< 1: Force to open the clock and bypass the gate-clock when accessing the SRAM. 0: A gate-clock will be used when accessing the SRAM.
    }

    /// SEC_CONF Register bits
    namespace sec_conf_bits {
        constexpr uint32_t SEC_CLK_SEL = (2 << 0);  ///< xxxx
    }

    /// ADC_INV_PHASE_CONF Register bits
    namespace adc_inv_phase_conf_bits {
        constexpr uint32_t CLK_ADC_INV_PHASE_ENA = (1U << 0);  ///< xxxx
    }

    /// SDM_INV_PHASE_CONF Register bits
    namespace sdm_inv_phase_conf_bits {
        constexpr uint32_t CLK_SDM_INV_PHASE_ENA = (1U << 0);  ///< xxxx
        constexpr uint32_t CLK_SDM_INV_PHASE_SEL = (3 << 1);  ///< xxxx
    }

    /// BUS_CLK_UPDATE Register bits
    namespace bus_clk_update_bits {
        constexpr uint32_t BUS_CLOCK_UPDATE = (1U << 0);  ///< xxxx
    }

    /// SAR_CLK_DIV Register bits
    namespace sar_clk_div_bits {
        constexpr uint32_t SAR2_CLK_DIV_NUM = (8 << 0);  ///< xxxx
        constexpr uint32_t SAR1_CLK_DIV_NUM = (8 << 8);  ///< xxxx
    }

    /// PWDET_SAR_CLK_CONF Register bits
    namespace pwdet_sar_clk_conf_bits {
        constexpr uint32_t PWDET_SAR_CLK_DIV_NUM = (8 << 0);  ///< xxxx
        constexpr uint32_t PWDET_SAR_READER_EN = (1U << 8);  ///< xxxx
    }

    /// RESET_EVENT_BYPASS Register bits
    namespace reset_event_bypass_bits {
        constexpr uint32_t APM = (1U << 0);  ///< This field is used to control reset event relationship for tee_reg/apm_reg/hp_system_reg. 1: tee_reg/apm_reg/hp_system_reg will only be reset by power-reset. some reset event will be bypass. 0: tee_reg/apm_reg/hp_system_reg will not only be reset by power-reset, but also some reset event.
        constexpr uint32_t RESET_EVENT_BYPASS = (1U << 1);  ///< This field is used to control reset event relationship for system-bus. 1: system bus (including arbiter/router) will only be reset by power-reset. some reset event will be bypass. 0: system bus (including arbiter/router) will not only be reset by power-reset, but also some reset event.
    }

    /// FPGA_DEBUG Register bits
    namespace fpga_debug_bits {
        constexpr uint32_t FPGA_DEBUG = (32 << 0);  ///< Only used in fpga debug.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Set this bit as 1 to force on clock gating.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< PCR version information.
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x600B0000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t HP_ACTIVE_DIG_POWER;  ///< Offset: 0x00 - need_des
        volatile uint32_t HP_ACTIVE_ICG_HP_FUNC;  ///< Offset: 0x04 - need_des
        volatile uint32_t HP_ACTIVE_ICG_HP_APB;  ///< Offset: 0x08 - need_des
        volatile uint32_t HP_ACTIVE_ICG_MODEM;  ///< Offset: 0x0C - need_des
        volatile uint32_t HP_ACTIVE_HP_SYS_CNTL;  ///< Offset: 0x10 - need_des
        volatile uint32_t HP_ACTIVE_HP_CK_POWER;  ///< Offset: 0x14 - need_des
        volatile uint32_t HP_ACTIVE_BIAS;  ///< Offset: 0x18 - need_des
        volatile uint32_t HP_ACTIVE_BACKUP;  ///< Offset: 0x1C - need_des
        volatile uint32_t HP_ACTIVE_BACKUP_CLK;  ///< Offset: 0x20 - need_des
        volatile uint32_t HP_ACTIVE_SYSCLK;  ///< Offset: 0x24 - need_des
        volatile uint32_t HP_ACTIVE_HP_REGULATOR0;  ///< Offset: 0x28 - need_des
        volatile uint32_t HP_ACTIVE_HP_REGULATOR1;  ///< Offset: 0x2C - need_des
        volatile uint32_t HP_ACTIVE_XTAL;  ///< Offset: 0x30 - need_des
        volatile uint32_t HP_MODEM_DIG_POWER;  ///< Offset: 0x34 - need_des
        volatile uint32_t HP_MODEM_ICG_HP_FUNC;  ///< Offset: 0x38 - need_des
        volatile uint32_t HP_MODEM_ICG_HP_APB;  ///< Offset: 0x3C - need_des
        volatile uint32_t HP_MODEM_ICG_MODEM;  ///< Offset: 0x40 - need_des
        volatile uint32_t HP_MODEM_HP_SYS_CNTL;  ///< Offset: 0x44 - need_des
        volatile uint32_t HP_MODEM_HP_CK_POWER;  ///< Offset: 0x48 - need_des
        volatile uint32_t HP_MODEM_BIAS;  ///< Offset: 0x4C - need_des
        volatile uint32_t HP_MODEM_BACKUP;  ///< Offset: 0x50 - need_des
        volatile uint32_t HP_MODEM_BACKUP_CLK;  ///< Offset: 0x54 - need_des
        volatile uint32_t HP_MODEM_SYSCLK;  ///< Offset: 0x58 - need_des
        volatile uint32_t HP_MODEM_HP_REGULATOR0;  ///< Offset: 0x5C - need_des
        volatile uint32_t HP_MODEM_HP_REGULATOR1;  ///< Offset: 0x60 - need_des
        volatile uint32_t HP_MODEM_XTAL;  ///< Offset: 0x64 - need_des
        volatile uint32_t HP_SLEEP_DIG_POWER;  ///< Offset: 0x68 - need_des
        volatile uint32_t HP_SLEEP_ICG_HP_FUNC;  ///< Offset: 0x6C - need_des
        volatile uint32_t HP_SLEEP_ICG_HP_APB;  ///< Offset: 0x70 - need_des
        volatile uint32_t HP_SLEEP_ICG_MODEM;  ///< Offset: 0x74 - need_des
        volatile uint32_t HP_SLEEP_HP_SYS_CNTL;  ///< Offset: 0x78 - need_des
        volatile uint32_t HP_SLEEP_HP_CK_POWER;  ///< Offset: 0x7C - need_des
        volatile uint32_t HP_SLEEP_BIAS;  ///< Offset: 0x80 - need_des
        volatile uint32_t HP_SLEEP_BACKUP;  ///< Offset: 0x84 - need_des
        volatile uint32_t HP_SLEEP_BACKUP_CLK;  ///< Offset: 0x88 - need_des
        volatile uint32_t HP_SLEEP_SYSCLK;  ///< Offset: 0x8C - need_des
        volatile uint32_t HP_SLEEP_HP_REGULATOR0;  ///< Offset: 0x90 - need_des
        volatile uint32_t HP_SLEEP_HP_REGULATOR1;  ///< Offset: 0x94 - need_des
        volatile uint32_t HP_SLEEP_XTAL;  ///< Offset: 0x98 - need_des
        volatile uint32_t HP_SLEEP_LP_REGULATOR0;  ///< Offset: 0x9C - need_des
        volatile uint32_t HP_SLEEP_LP_REGULATOR1;  ///< Offset: 0xA0 - need_des
        volatile uint32_t HP_SLEEP_LP_DCDC_RESERVE;  ///< Offset: 0xA4 - need_des
        volatile uint32_t HP_SLEEP_LP_DIG_POWER;  ///< Offset: 0xA8 - need_des
        volatile uint32_t HP_SLEEP_LP_CK_POWER;  ///< Offset: 0xAC - need_des
        volatile uint32_t LP_SLEEP_LP_BIAS_RESERVE;  ///< Offset: 0xB0 - need_des
        volatile uint32_t LP_SLEEP_LP_REGULATOR0;  ///< Offset: 0xB4 - need_des
        volatile uint32_t LP_SLEEP_LP_REGULATOR1;  ///< Offset: 0xB8 - need_des
        volatile uint32_t LP_SLEEP_XTAL;  ///< Offset: 0xBC - need_des
        volatile uint32_t LP_SLEEP_LP_DIG_POWER;  ///< Offset: 0xC0 - need_des
        volatile uint32_t LP_SLEEP_LP_CK_POWER;  ///< Offset: 0xC4 - need_des
        volatile uint32_t LP_SLEEP_BIAS;  ///< Offset: 0xC8 - need_des
        volatile uint32_t IMM_HP_CK_POWER;  ///< Offset: 0xCC - need_des
        volatile uint32_t IMM_SLEEP_SYSCLK;  ///< Offset: 0xD0 - need_des
        volatile uint32_t IMM_HP_FUNC_ICG;  ///< Offset: 0xD4 - need_des
        volatile uint32_t IMM_HP_APB_ICG;  ///< Offset: 0xD8 - need_des
        volatile uint32_t IMM_MODEM_ICG;  ///< Offset: 0xDC - need_des
        volatile uint32_t IMM_LP_ICG;  ///< Offset: 0xE0 - need_des
        volatile uint32_t IMM_PAD_HOLD_ALL;  ///< Offset: 0xE4 - need_des
        volatile uint32_t IMM_I2C_ISO;  ///< Offset: 0xE8 - need_des
        volatile uint32_t POWER_WAIT_TIMER0;  ///< Offset: 0xEC - need_des
        volatile uint32_t POWER_WAIT_TIMER1;  ///< Offset: 0xF0 - need_des
        volatile uint32_t POWER_PD_TOP_CNTL;  ///< Offset: 0xF4 - need_des
        volatile uint32_t POWER_PD_HPAON_CNTL;  ///< Offset: 0xF8 - need_des
        volatile uint32_t POWER_PD_HPCPU_CNTL;  ///< Offset: 0xFC - need_des
        volatile uint32_t POWER_PD_HPPERI_RESERVE;  ///< Offset: 0x100 - need_des
        volatile uint32_t POWER_PD_HPWIFI_CNTL;  ///< Offset: 0x104 - need_des
        volatile uint32_t POWER_PD_LPPERI_CNTL;  ///< Offset: 0x108 - need_des
        volatile uint32_t POWER_PD_MEM_CNTL;  ///< Offset: 0x10C - need_des
        volatile uint32_t POWER_PD_MEM_MASK;  ///< Offset: 0x110 - need_des
        volatile uint32_t POWER_HP_PAD;  ///< Offset: 0x114 - need_des
        volatile uint32_t POWER_VDD_SPI_CNTL;  ///< Offset: 0x118 - need_des
        volatile uint32_t POWER_CK_WAIT_CNTL;  ///< Offset: 0x11C - need_des
        volatile uint32_t SLP_WAKEUP_CNTL0;  ///< Offset: 0x120 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL1;  ///< Offset: 0x124 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL2;  ///< Offset: 0x128 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL3;  ///< Offset: 0x12C - need_des
        volatile uint32_t SLP_WAKEUP_CNTL4;  ///< Offset: 0x130 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL5;  ///< Offset: 0x134 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL6;  ///< Offset: 0x138 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL7;  ///< Offset: 0x13C - need_des
        volatile uint32_t SLP_WAKEUP_STATUS0;  ///< Offset: 0x140 - need_des
        volatile uint32_t SLP_WAKEUP_STATUS1;  ///< Offset: 0x144 - need_des
        volatile uint32_t HP_CK_POWERON;  ///< Offset: 0x148 - need_des
        volatile uint32_t HP_CK_CNTL;  ///< Offset: 0x14C - need_des
        volatile uint32_t POR_STATUS;  ///< Offset: 0x150 - need_des
        volatile uint32_t RF_PWC;  ///< Offset: 0x154 - need_des
        volatile uint32_t VDDBAT_CFG;  ///< Offset: 0x158 - need_des
        volatile uint32_t BACKUP_CFG;  ///< Offset: 0x15C - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x160 - need_des
        volatile uint32_t HP_INT_ST;  ///< Offset: 0x164 - need_des
        volatile uint32_t HP_INT_ENA;  ///< Offset: 0x168 - need_des
        volatile uint32_t HP_INT_CLR;  ///< Offset: 0x16C - need_des
        volatile uint32_t LP_INT_RAW;  ///< Offset: 0x170 - need_des
        volatile uint32_t LP_INT_ST;  ///< Offset: 0x174 - need_des
        volatile uint32_t LP_INT_ENA;  ///< Offset: 0x178 - need_des
        volatile uint32_t LP_INT_CLR;  ///< Offset: 0x17C - need_des
        volatile uint32_t LP_CPU_PWR0;  ///< Offset: 0x180 - need_des
        volatile uint32_t LP_CPU_PWR1;  ///< Offset: 0x184 - need_des
        volatile uint32_t HP_LP_CPU_COMM;  ///< Offset: 0x188 - need_des
        volatile uint32_t HP_REGULATOR_CFG;  ///< Offset: 0x18C - need_des
        volatile uint32_t MAIN_STATE;  ///< Offset: 0x190 - need_des
        volatile uint32_t PWR_STATE;  ///< Offset: 0x194 - need_des
        volatile uint32_t CLK_STATE0;  ///< Offset: 0x198 - need_des
        volatile uint32_t CLK_STATE1;  ///< Offset: 0x19C - need_des
        volatile uint32_t CLK_STATE2;  ///< Offset: 0x1A0 - need_des
        volatile uint32_t VDD_SPI_STATUS;  ///< Offset: 0x1A4 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// HP_ACTIVE_DIG_POWER Register bits
    namespace hp_active_dig_power_bits {
        constexpr uint32_t HP_ACTIVE_VDD_SPI_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_HP_MEM_PD_EN = (4 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_HP_WIFI_PD_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_HP_CPU_PD_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_HP_AON_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_ACTIVE_ICG_HP_FUNC Register bits
    namespace hp_active_icg_hp_func_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_ICG_HP_APB Register bits
    namespace hp_active_icg_hp_apb_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_ICG_MODEM Register bits
    namespace hp_active_icg_modem_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_ACTIVE_HP_SYS_CNTL Register bits
    namespace hp_active_hp_sys_cntl_bits {
        constexpr uint32_t HP_ACTIVE_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_ACTIVE_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_ACTIVE_HP_CK_POWER Register bits
    namespace hp_active_hp_ck_power_bits {
        constexpr uint32_t HP_ACTIVE_I2C_ISO_EN = (1U << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_I2C_RETENTION = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_BB_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_BBPLL_I2C = (1U << 29);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_BBPLL = (1U << 30);  ///< need_des
    }

    /// HP_ACTIVE_BIAS Register bits
    namespace hp_active_bias_bits {
        constexpr uint32_t HP_ACTIVE_XPD_TRX = (1U << 24);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_ACTIVE_BACKUP Register bits
    namespace hp_active_backup_bits {
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE = (2 << 4);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE = (2 << 6);  ///< need_des
        constexpr uint32_t HP_ACTIVE_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_RETENTION_EN = (1U << 11);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_RETENTION_EN = (1U << 12);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_CLK_SEL = (2 << 14);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_CLK_SEL = (2 << 16);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_MODE = (3 << 20);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_MODE = (3 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_EN = (1U << 30);  ///< need_des
    }

    /// HP_ACTIVE_BACKUP_CLK Register bits
    namespace hp_active_backup_clk_bits {
        constexpr uint32_t HP_ACTIVE_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_SYSCLK Register bits
    namespace hp_active_sysclk_bits {
        constexpr uint32_t HP_ACTIVE_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_ACTIVE_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_ACTIVE_HP_REGULATOR0 Register bits
    namespace hp_active_hp_regulator0_bits {
        constexpr uint32_t HP_ACTIVE_HP_POWER_DET_BYPASS = (1U << 0);  ///< need_des
        constexpr uint32_t LP_DBIAS_VOL = (5 << 4);  ///< need_des
        constexpr uint32_t HP_DBIAS_VOL = (5 << 9);  ///< need_des
        constexpr uint32_t DIG_REGULATOR0_DBIAS_SEL = (1U << 14);  ///< need_des
        constexpr uint32_t DIG_DBIAS_INIT = (1U << 15);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_ACTIVE_HP_REGULATOR1 Register bits
    namespace hp_active_hp_regulator1_bits {
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_DRV_B = (24 << 8);  ///< need_des
    }

    /// HP_ACTIVE_XTAL Register bits
    namespace hp_active_xtal_bits {
        constexpr uint32_t HP_ACTIVE_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_DIG_POWER Register bits
    namespace hp_modem_dig_power_bits {
        constexpr uint32_t HP_MODEM_VDD_SPI_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_MEM_PD_EN = (4 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_WIFI_PD_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_CPU_PD_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_AON_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_ICG_HP_FUNC Register bits
    namespace hp_modem_icg_hp_func_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_ICG_HP_APB Register bits
    namespace hp_modem_icg_hp_apb_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_ICG_MODEM Register bits
    namespace hp_modem_icg_modem_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_MODEM_HP_SYS_CNTL Register bits
    namespace hp_modem_hp_sys_cntl_bits {
        constexpr uint32_t HP_MODEM_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_MODEM_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_MODEM_HP_CK_POWER Register bits
    namespace hp_modem_hp_ck_power_bits {
        constexpr uint32_t HP_MODEM_I2C_ISO_EN = (1U << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_I2C_RETENTION = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_BB_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_BBPLL_I2C = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_BBPLL = (1U << 30);  ///< need_des
    }

    /// HP_MODEM_BIAS Register bits
    namespace hp_modem_bias_bits {
        constexpr uint32_t HP_MODEM_XPD_TRX = (1U << 24);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_BACKUP Register bits
    namespace hp_modem_backup_bits {
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE = (2 << 4);  ///< need_des
        constexpr uint32_t HP_MODEM_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_RETENTION_EN = (1U << 11);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_CLK_SEL = (2 << 14);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_MODE = (3 << 20);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_EN = (1U << 29);  ///< need_des
    }

    /// HP_MODEM_BACKUP_CLK Register bits
    namespace hp_modem_backup_clk_bits {
        constexpr uint32_t HP_MODEM_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_SYSCLK Register bits
    namespace hp_modem_sysclk_bits {
        constexpr uint32_t HP_MODEM_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_MODEM_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_MODEM_HP_REGULATOR0 Register bits
    namespace hp_modem_hp_regulator0_bits {
        constexpr uint32_t HP_MODEM_HP_POWER_DET_BYPASS = (1U << 0);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_MODEM_HP_REGULATOR1 Register bits
    namespace hp_modem_hp_regulator1_bits {
        constexpr uint32_t HP_MODEM_HP_REGULATOR_DRV_B = (24 << 8);  ///< need_des
    }

    /// HP_MODEM_XTAL Register bits
    namespace hp_modem_xtal_bits {
        constexpr uint32_t HP_MODEM_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_DIG_POWER Register bits
    namespace hp_sleep_dig_power_bits {
        constexpr uint32_t HP_SLEEP_VDD_SPI_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_HP_MEM_PD_EN = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_HP_WIFI_PD_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_HP_CPU_PD_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_HP_AON_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_ICG_HP_FUNC Register bits
    namespace hp_sleep_icg_hp_func_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_ICG_HP_APB Register bits
    namespace hp_sleep_icg_hp_apb_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_ICG_MODEM Register bits
    namespace hp_sleep_icg_modem_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_SLEEP_HP_SYS_CNTL Register bits
    namespace hp_sleep_hp_sys_cntl_bits {
        constexpr uint32_t HP_SLEEP_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_SLEEP_HP_CK_POWER Register bits
    namespace hp_sleep_hp_ck_power_bits {
        constexpr uint32_t HP_SLEEP_I2C_ISO_EN = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_I2C_RETENTION = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_BB_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_BBPLL_I2C = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_BBPLL = (1U << 30);  ///< need_des
    }

    /// HP_SLEEP_BIAS Register bits
    namespace hp_sleep_bias_bits {
        constexpr uint32_t HP_SLEEP_XPD_TRX = (1U << 24);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_BACKUP Register bits
    namespace hp_sleep_backup_bits {
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE = (2 << 6);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE = (2 << 8);  ///< need_des
        constexpr uint32_t HP_SLEEP_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_RETENTION_EN = (1U << 12);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_RETENTION_EN = (1U << 13);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_CLK_SEL = (2 << 16);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_CLK_SEL = (2 << 18);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_MODE = (3 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_MODE = (3 << 26);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_BACKUP_CLK Register bits
    namespace hp_sleep_backup_clk_bits {
        constexpr uint32_t HP_SLEEP_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_SYSCLK Register bits
    namespace hp_sleep_sysclk_bits {
        constexpr uint32_t HP_SLEEP_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_SLEEP_HP_REGULATOR0 Register bits
    namespace hp_sleep_hp_regulator0_bits {
        constexpr uint32_t HP_SLEEP_HP_POWER_DET_BYPASS = (1U << 0);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_SLEEP_HP_REGULATOR1 Register bits
    namespace hp_sleep_hp_regulator1_bits {
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_DRV_B = (24 << 8);  ///< need_des
    }

    /// HP_SLEEP_XTAL Register bits
    namespace hp_sleep_xtal_bits {
        constexpr uint32_t HP_SLEEP_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_LP_REGULATOR0 Register bits
    namespace hp_sleep_lp_regulator0_bits {
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_SLP_XPD = (1U << 21);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_XPD = (1U << 22);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_SLP_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_SLEEP_LP_REGULATOR1 Register bits
    namespace hp_sleep_lp_regulator1_bits {
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_DRV_B = (4 << 28);  ///< need_des
    }

    /// HP_SLEEP_LP_DCDC_RESERVE Register bits
    namespace hp_sleep_lp_dcdc_reserve_bits {
        constexpr uint32_t HP_SLEEP_LP_DCDC_RESERVE = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_LP_DIG_POWER Register bits
    namespace hp_sleep_lp_dig_power_bits {
        constexpr uint32_t HP_SLEEP_BOD_SOURCE_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_VDDBAT_MODE = (2 << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_MEM_DSLP = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_LP_PERI_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_LP_CK_POWER Register bits
    namespace hp_sleep_lp_ck_power_bits {
        constexpr uint32_t HP_SLEEP_XPD_LPPLL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_XTAL32K = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_RC32K = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_FOSC_CLK = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_OSC_CLK = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_BIAS_RESERVE Register bits
    namespace lp_sleep_lp_bias_reserve_bits {
        constexpr uint32_t LP_SLEEP_LP_BIAS_RESERVE = (32 << 0);  ///< need_des
    }

    /// LP_SLEEP_LP_REGULATOR0 Register bits
    namespace lp_sleep_lp_regulator0_bits {
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_SLP_XPD = (1U << 21);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_XPD = (1U << 22);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_SLP_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// LP_SLEEP_LP_REGULATOR1 Register bits
    namespace lp_sleep_lp_regulator1_bits {
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_DRV_B = (4 << 28);  ///< need_des
    }

    /// LP_SLEEP_XTAL Register bits
    namespace lp_sleep_xtal_bits {
        constexpr uint32_t LP_SLEEP_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_DIG_POWER Register bits
    namespace lp_sleep_lp_dig_power_bits {
        constexpr uint32_t LP_SLEEP_BOD_SOURCE_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t LP_SLEEP_VDDBAT_MODE = (2 << 28);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_MEM_DSLP = (1U << 30);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_LP_PERI_PD_EN = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_CK_POWER Register bits
    namespace lp_sleep_lp_ck_power_bits {
        constexpr uint32_t LP_SLEEP_XPD_LPPLL = (1U << 27);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_XTAL32K = (1U << 28);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_RC32K = (1U << 29);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_FOSC_CLK = (1U << 30);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_OSC_CLK = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_BIAS Register bits
    namespace lp_sleep_bias_bits {
        constexpr uint32_t LP_SLEEP_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// IMM_HP_CK_POWER Register bits
    namespace imm_hp_ck_power_bits {
        constexpr uint32_t TIE_LOW_GLOBAL_BBPLL_ICG = (1U << 0);  ///< need_des
        constexpr uint32_t TIE_LOW_GLOBAL_XTAL_ICG = (1U << 1);  ///< need_des
        constexpr uint32_t TIE_LOW_I2C_RETENTION = (1U << 2);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_BB_I2C = (1U << 3);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_BBPLL_I2C = (1U << 4);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_BBPLL = (1U << 5);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_XTAL = (1U << 6);  ///< need_des
        constexpr uint32_t TIE_HIGH_GLOBAL_BBPLL_ICG = (1U << 25);  ///< need_des
        constexpr uint32_t TIE_HIGH_GLOBAL_XTAL_ICG = (1U << 26);  ///< need_des
        constexpr uint32_t TIE_HIGH_I2C_RETENTION = (1U << 27);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_BB_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_BBPLL_I2C = (1U << 29);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_BBPLL = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// IMM_SLEEP_SYSCLK Register bits
    namespace imm_sleep_sysclk_bits {
        constexpr uint32_t UPDATE_DIG_ICG_SWITCH = (1U << 28);  ///< need_des
        constexpr uint32_t TIE_LOW_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t TIE_HIGH_ICG_SLP_SEL = (1U << 30);  ///< need_des
        constexpr uint32_t UPDATE_DIG_SYS_CLK_SEL = (1U << 31);  ///< need_des
    }

    /// IMM_HP_FUNC_ICG Register bits
    namespace imm_hp_func_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_FUNC_EN = (1U << 31);  ///< need_des
    }

    /// IMM_HP_APB_ICG Register bits
    namespace imm_hp_apb_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_APB_EN = (1U << 31);  ///< need_des
    }

    /// IMM_MODEM_ICG Register bits
    namespace imm_modem_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_MODEM_EN = (1U << 31);  ///< need_des
    }

    /// IMM_LP_ICG Register bits
    namespace imm_lp_icg_bits {
        constexpr uint32_t TIE_LOW_LP_ROOTCLK_SEL = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_HIGH_LP_ROOTCLK_SEL = (1U << 31);  ///< need_des
    }

    /// IMM_PAD_HOLD_ALL Register bits
    namespace imm_pad_hold_all_bits {
        constexpr uint32_t TIE_HIGH_LP_PAD_HOLD_ALL = (1U << 28);  ///< need_des
        constexpr uint32_t TIE_LOW_LP_PAD_HOLD_ALL = (1U << 29);  ///< need_des
        constexpr uint32_t TIE_HIGH_HP_PAD_HOLD_ALL = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_LOW_HP_PAD_HOLD_ALL = (1U << 31);  ///< need_des
    }

    /// IMM_I2C_ISO Register bits
    namespace imm_i2c_iso_bits {
        constexpr uint32_t TIE_HIGH_I2C_ISO_EN = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_LOW_I2C_ISO_EN = (1U << 31);  ///< need_des
    }

    /// POWER_WAIT_TIMER0 Register bits
    namespace power_wait_timer0_bits {
        constexpr uint32_t DG_HP_POWERDOWN_TIMER = (9 << 5);  ///< need_des
        constexpr uint32_t DG_HP_POWERUP_TIMER = (9 << 14);  ///< need_des
        constexpr uint32_t DG_HP_WAIT_TIMER = (9 << 23);  ///< need_des
    }

    /// POWER_WAIT_TIMER1 Register bits
    namespace power_wait_timer1_bits {
        constexpr uint32_t DG_LP_POWERDOWN_TIMER = (7 << 9);  ///< need_des
        constexpr uint32_t DG_LP_POWERUP_TIMER = (7 << 16);  ///< need_des
        constexpr uint32_t DG_LP_WAIT_TIMER = (9 << 23);  ///< need_des
    }

    /// POWER_PD_TOP_CNTL Register bits
    namespace power_pd_top_cntl_bits {
        constexpr uint32_t FORCE_TOP_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_TOP_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_TOP_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_TOP_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_TOP_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_TOP_PD = (1U << 5);  ///< need_des
        constexpr uint32_t PD_TOP_MASK = (5 << 6);  ///< need_des
        constexpr uint32_t PD_TOP_PD_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_HPAON_CNTL Register bits
    namespace power_pd_hpaon_cntl_bits {
        constexpr uint32_t FORCE_HP_AON_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_AON_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_HP_AON_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_HP_AON_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_HP_AON_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_HP_AON_PD = (1U << 5);  ///< need_des
        constexpr uint32_t PD_HP_AON_MASK = (5 << 6);  ///< need_des
        constexpr uint32_t PD_HP_AON_PD_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_HPCPU_CNTL Register bits
    namespace power_pd_hpcpu_cntl_bits {
        constexpr uint32_t FORCE_HP_CPU_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_CPU_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_HP_CPU_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_HP_CPU_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_HP_CPU_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_HP_CPU_PD = (1U << 5);  ///< need_des
        constexpr uint32_t PD_HP_CPU_MASK = (5 << 6);  ///< need_des
        constexpr uint32_t PD_HP_CPU_PD_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_HPPERI_RESERVE Register bits
    namespace power_pd_hpperi_reserve_bits {
        constexpr uint32_t HP_PERI_RESERVE = (32 << 0);  ///< need_des
    }

    /// POWER_PD_HPWIFI_CNTL Register bits
    namespace power_pd_hpwifi_cntl_bits {
        constexpr uint32_t FORCE_HP_WIFI_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_WIFI_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_HP_WIFI_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_HP_WIFI_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_HP_WIFI_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_HP_WIFI_PD = (1U << 5);  ///< need_des
        constexpr uint32_t PD_HP_WIFI_MASK = (5 << 6);  ///< need_des
        constexpr uint32_t PD_HP_WIFI_PD_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_LPPERI_CNTL Register bits
    namespace power_pd_lpperi_cntl_bits {
        constexpr uint32_t FORCE_LP_PERI_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_PD = (1U << 5);  ///< need_des
    }

    /// POWER_PD_MEM_CNTL Register bits
    namespace power_pd_mem_cntl_bits {
        constexpr uint32_t FORCE_HP_MEM_ISO = (4 << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_PD = (4 << 4);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_NO_ISO = (4 << 24);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_PU = (4 << 28);  ///< need_des
    }

    /// POWER_PD_MEM_MASK Register bits
    namespace power_pd_mem_mask_bits {
        constexpr uint32_t PD_HP_MEM2_PD_MASK = (5 << 0);  ///< need_des
        constexpr uint32_t PD_HP_MEM1_PD_MASK = (5 << 5);  ///< need_des
        constexpr uint32_t PD_HP_MEM0_PD_MASK = (5 << 10);  ///< need_des
        constexpr uint32_t PD_HP_MEM2_MASK = (5 << 17);  ///< need_des
        constexpr uint32_t PD_HP_MEM1_MASK = (5 << 22);  ///< need_des
        constexpr uint32_t PD_HP_MEM0_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_HP_PAD Register bits
    namespace power_hp_pad_bits {
        constexpr uint32_t FORCE_HP_PAD_NO_ISO_ALL = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_PAD_ISO_ALL = (1U << 1);  ///< need_des
    }

    /// POWER_VDD_SPI_CNTL Register bits
    namespace power_vdd_spi_cntl_bits {
        constexpr uint32_t VDD_SPI_PWR_WAIT = (11 << 18);  ///< need_des
        constexpr uint32_t VDD_SPI_PWR_SW = (2 << 29);  ///< need_des
        constexpr uint32_t VDD_SPI_PWR_SEL_SW = (1U << 31);  ///< need_des
    }

    /// POWER_CK_WAIT_CNTL Register bits
    namespace power_ck_wait_cntl_bits {
        constexpr uint32_t WAIT_XTL_STABLE = (16 << 0);  ///< need_des
        constexpr uint32_t WAIT_PLL_STABLE = (16 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL0 Register bits
    namespace slp_wakeup_cntl0_bits {
        constexpr uint32_t SLEEP_REQ = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL1 Register bits
    namespace slp_wakeup_cntl1_bits {
        constexpr uint32_t SLEEP_REJECT_ENA = (31 << 0);  ///< need_des
        constexpr uint32_t SLP_REJECT_EN = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL2 Register bits
    namespace slp_wakeup_cntl2_bits {
        constexpr uint32_t WAKEUP_ENA = (32 << 0);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL3 Register bits
    namespace slp_wakeup_cntl3_bits {
        constexpr uint32_t LP_MIN_SLP_VAL = (8 << 0);  ///< need_des
        constexpr uint32_t HP_MIN_SLP_VAL = (8 << 8);  ///< need_des
        constexpr uint32_t SLEEP_PRT_SEL = (2 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL4 Register bits
    namespace slp_wakeup_cntl4_bits {
        constexpr uint32_t SLP_REJECT_CAUSE_CLR = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL5 Register bits
    namespace slp_wakeup_cntl5_bits {
        constexpr uint32_t MODEM_WAIT_TARGET = (20 << 0);  ///< need_des
        constexpr uint32_t LP_ANA_WAIT_TARGET = (8 << 24);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL6 Register bits
    namespace slp_wakeup_cntl6_bits {
        constexpr uint32_t SOC_WAKEUP_WAIT = (20 << 0);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_WAIT_CFG = (2 << 30);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL7 Register bits
    namespace slp_wakeup_cntl7_bits {
        constexpr uint32_t ANA_WAIT_TARGET = (16 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_STATUS0 Register bits
    namespace slp_wakeup_status0_bits {
        constexpr uint32_t WAKEUP_CAUSE = (32 << 0);  ///< need_des
    }

    /// SLP_WAKEUP_STATUS1 Register bits
    namespace slp_wakeup_status1_bits {
        constexpr uint32_t REJECT_CAUSE = (32 << 0);  ///< need_des
    }

    /// HP_CK_POWERON Register bits
    namespace hp_ck_poweron_bits {
        constexpr uint32_t I2C_POR_WAIT_TARGET = (8 << 0);  ///< need_des
    }

    /// HP_CK_CNTL Register bits
    namespace hp_ck_cntl_bits {
        constexpr uint32_t MODIFY_ICG_CNTL_WAIT = (8 << 0);  ///< need_des
        constexpr uint32_t SWITCH_ICG_CNTL_WAIT = (8 << 8);  ///< need_des
    }

    /// POR_STATUS Register bits
    namespace por_status_bits {
        constexpr uint32_t POR_DONE = (1U << 31);  ///< need_des
    }

    /// RF_PWC Register bits
    namespace rf_pwc_bits {
        constexpr uint32_t XPD_PERIF_I2C = (1U << 27);  ///< need_des
        constexpr uint32_t XPD_RFTX_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t XPD_RFRX_I2C = (1U << 29);  ///< need_des
        constexpr uint32_t XPD_RFPLL = (1U << 30);  ///< need_des
        constexpr uint32_t XPD_FORCE_RFPLL = (1U << 31);  ///< need_des
    }

    /// VDDBAT_CFG Register bits
    namespace vddbat_cfg_bits {
        constexpr uint32_t VDDBAT_MODE = (2 << 0);  ///< need_des
        constexpr uint32_t VDDBAT_SW_UPDATE = (1U << 31);  ///< need_des
    }

    /// BACKUP_CFG Register bits
    namespace backup_cfg_bits {
        constexpr uint32_t BACKUP_SYS_CLK_NO_DIV = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t LP_CPU_EXC_INT_RAW = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_RAW = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_RAW = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// HP_INT_ST Register bits
    namespace hp_int_st_bits {
        constexpr uint32_t LP_CPU_EXC_INT_ST = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_ST = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_ST = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ST = (1U << 31);  ///< need_des
    }

    /// HP_INT_ENA Register bits
    namespace hp_int_ena_bits {
        constexpr uint32_t LP_CPU_EXC_INT_ENA = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_ENA = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_ENA = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// HP_INT_CLR Register bits
    namespace hp_int_clr_bits {
        constexpr uint32_t LP_CPU_EXC_INT_CLR = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_CLR = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_CLR = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_INT_RAW Register bits
    namespace lp_int_raw_bits {
        constexpr uint32_t LP_CPU_WAKEUP_INT_RAW = (1U << 20);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_END_INT_RAW = (1U << 21);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_RAW = (1U << 22);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_END_INT_RAW = (1U << 23);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_END_INT_RAW = (1U << 24);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_RAW = (1U << 25);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_START_INT_RAW = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_RAW = (1U << 27);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_START_INT_RAW = (1U << 28);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_START_INT_RAW = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_RAW = (1U << 31);  ///< need_des
    }

    /// LP_INT_ST Register bits
    namespace lp_int_st_bits {
        constexpr uint32_t LP_CPU_WAKEUP_INT_ST = (1U << 20);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_END_INT_ST = (1U << 21);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_ST = (1U << 22);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_END_INT_ST = (1U << 23);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_END_INT_ST = (1U << 24);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_ST = (1U << 25);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_START_INT_ST = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_ST = (1U << 27);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_START_INT_ST = (1U << 28);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_START_INT_ST = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_ST = (1U << 31);  ///< need_des
    }

    /// LP_INT_ENA Register bits
    namespace lp_int_ena_bits {
        constexpr uint32_t LP_CPU_WAKEUP_INT_ENA = (1U << 20);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_END_INT_ENA = (1U << 21);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_ENA = (1U << 22);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_END_INT_ENA = (1U << 23);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_END_INT_ENA = (1U << 24);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_ENA = (1U << 25);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_START_INT_ENA = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_ENA = (1U << 27);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_START_INT_ENA = (1U << 28);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_START_INT_ENA = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_ENA = (1U << 31);  ///< need_des
    }

    /// LP_INT_CLR Register bits
    namespace lp_int_clr_bits {
        constexpr uint32_t LP_CPU_WAKEUP_INT_CLR = (1U << 20);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_END_INT_CLR = (1U << 21);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_CLR = (1U << 22);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_END_INT_CLR = (1U << 23);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_END_INT_CLR = (1U << 24);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_CLR = (1U << 25);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_ACTIVE_START_INT_CLR = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_CLR = (1U << 27);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_MODEM_START_INT_CLR = (1U << 28);  ///< need_des
        constexpr uint32_t MODEM_SWITCH_SLEEP_START_INT_CLR = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_CPU_PWR0 Register bits
    namespace lp_cpu_pwr0_bits {
        constexpr uint32_t LP_CPU_WAITI_RDY = (1U << 0);  ///< need_des
        constexpr uint32_t LP_CPU_STALL_RDY = (1U << 1);  ///< need_des
        constexpr uint32_t LP_CPU_FORCE_STALL = (1U << 18);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_WAITI_FLAG_EN = (1U << 19);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_FLAG_EN = (1U << 20);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_WAIT = (8 << 21);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_EN = (1U << 29);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_RESET_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_BYPASS_INTR_EN = (1U << 31);  ///< need_des
    }

    /// LP_CPU_PWR1 Register bits
    namespace lp_cpu_pwr1_bits {
        constexpr uint32_t LP_CPU_WAKEUP_EN = (16 << 0);  ///< need_des
        constexpr uint32_t LP_CPU_SLEEP_REQ = (1U << 31);  ///< need_des
    }

    /// HP_LP_CPU_COMM Register bits
    namespace hp_lp_cpu_comm_bits {
        constexpr uint32_t LP_TRIGGER_HP = (1U << 30);  ///< need_des
        constexpr uint32_t HP_TRIGGER_LP = (1U << 31);  ///< need_des
    }

    /// HP_REGULATOR_CFG Register bits
    namespace hp_regulator_cfg_bits {
        constexpr uint32_t DIG_REGULATOR_EN_CAL = (1U << 31);  ///< need_des
    }

    /// MAIN_STATE Register bits
    namespace main_state_bits {
        constexpr uint32_t MAIN_LAST_ST_STATE = (7 << 11);  ///< need_des
        constexpr uint32_t MAIN_TAR_ST_STATE = (7 << 18);  ///< need_des
        constexpr uint32_t MAIN_CUR_ST_STATE = (7 << 25);  ///< need_des
    }

    /// PWR_STATE Register bits
    namespace pwr_state_bits {
        constexpr uint32_t BACKUP_ST_STATE = (5 << 13);  ///< need_des
        constexpr uint32_t LP_PWR_ST_STATE = (5 << 18);  ///< need_des
        constexpr uint32_t HP_PWR_ST_STATE = (9 << 23);  ///< need_des
    }

    /// CLK_STATE0 Register bits
    namespace clk_state0_bits {
        constexpr uint32_t STABLE_XPD_BBPLL_STATE = (1U << 0);  ///< need_des
        constexpr uint32_t STABLE_XPD_XTAL_STATE = (1U << 1);  ///< need_des
        constexpr uint32_t SYS_CLK_SLP_SEL_STATE = (1U << 15);  ///< need_des
        constexpr uint32_t SYS_CLK_SEL_STATE = (2 << 16);  ///< need_des
        constexpr uint32_t SYS_CLK_NO_DIV_STATE = (1U << 18);  ///< need_des
        constexpr uint32_t ICG_SYS_CLK_EN_STATE = (1U << 19);  ///< need_des
        constexpr uint32_t ICG_MODEM_SWITCH_STATE = (1U << 20);  ///< need_des
        constexpr uint32_t ICG_MODEM_CODE_STATE = (2 << 21);  ///< need_des
        constexpr uint32_t ICG_SLP_SEL_STATE = (1U << 23);  ///< need_des
        constexpr uint32_t ICG_GLOBAL_XTAL_STATE = (1U << 24);  ///< need_des
        constexpr uint32_t ICG_GLOBAL_PLL_STATE = (1U << 25);  ///< need_des
        constexpr uint32_t ANA_I2C_ISO_EN_STATE = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_I2C_RETENTION_STATE = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_XPD_BB_I2C_STATE = (1U << 28);  ///< need_des
        constexpr uint32_t ANA_XPD_BBPLL_I2C_STATE = (1U << 29);  ///< need_des
        constexpr uint32_t ANA_XPD_BBPLL_STATE = (1U << 30);  ///< need_des
        constexpr uint32_t ANA_XPD_XTAL_STATE = (1U << 31);  ///< need_des
    }

    /// CLK_STATE1 Register bits
    namespace clk_state1_bits {
        constexpr uint32_t ICG_FUNC_EN_STATE = (32 << 0);  ///< need_des
    }

    /// CLK_STATE2 Register bits
    namespace clk_state2_bits {
        constexpr uint32_t ICG_APB_EN_STATE = (32 << 0);  ///< need_des
    }

    /// VDD_SPI_STATUS Register bits
    namespace vdd_spi_status_bits {
        constexpr uint32_t STABLE_VDD_SPI_PWR_DRV = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t PMU_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x60007000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t CH%sDATA;  ///< Offset: 0x00 - The read and write data register for CHANNEL%s by apb...
        volatile uint32_t CH%s_TX_CONF0;  ///< Offset: 0x10 - Channel %s configure register 0
        volatile uint32_t CH%s_RX_CONF0;  ///< Offset: 0x18 - Channel %s configure register 0
        volatile uint32_t CH%s_RX_CONF1;  ///< Offset: 0x1C - Channel %s configure register 1
        volatile uint32_t CH%s_TX_STATUS;  ///< Offset: 0x28 - Channel %s status register
        volatile uint32_t CH%s_RX_STATUS;  ///< Offset: 0x30 - Channel %s status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x38 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x3C - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x40 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x44 - Interrupt clear bits
        volatile uint32_t CH%sCARRIER_DUTY;  ///< Offset: 0x48 - Channel %s duty cycle configuration register
        volatile uint32_t CH%s_RX_CARRIER_RM;  ///< Offset: 0x50 - Channel %s carrier remove register
        volatile uint32_t CH%s_TX_LIM;  ///< Offset: 0x58 - Channel %s Tx event configuration register
        volatile uint32_t CH%s_RX_LIM;  ///< Offset: 0x60 - Channel %s Rx event configuration register
        volatile uint32_t SYS_CONF;  ///< Offset: 0x68 - RMT apb configuration register
        volatile uint32_t TX_SIM;  ///< Offset: 0x6C - RMT TX synchronous register
        volatile uint32_t REF_CNT_RST;  ///< Offset: 0x70 - RMT clock divider reset register
        volatile uint32_t DATE;  ///< Offset: 0xCC - RMT version register
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// CH%sDATA Register bits
    namespace ch%sdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Read and write data for channel %s via APB FIFO.
    }

    /// CH%s_TX_CONF0 Register bits
    namespace ch%s_tx_conf0_bits {
        constexpr uint32_t TX_START = (1U << 0);  ///< Set this bit to start sending data on CHANNEL%s.
        constexpr uint32_t MEM_RD_RST = (1U << 1);  ///< Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t TX_CONTI_MODE = (1U << 3);  ///< Set this bit to restart transmission from the first data to the last data in CHANNEL%s.
        constexpr uint32_t MEM_TX_WRAP_EN = (1U << 4);  ///< This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
        constexpr uint32_t IDLE_OUT_LV = (1U << 5);  ///< This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
        constexpr uint32_t IDLE_OUT_EN = (1U << 6);  ///< This is the output enable-control bit for CHANNEL%s in IDLE state.
        constexpr uint32_t TX_STOP = (1U << 7);  ///< Set this bit to stop the transmitter of CHANNEL%s sending data out.
        constexpr uint32_t DIV_CNT = (8 << 8);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t MEM_SIZE = (3 << 16);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EFF_EN = (1U << 20);  ///< 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
        constexpr uint32_t CARRIER_EN = (1U << 21);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 22);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s. 1'h0: add carrier wave on low level. 1'h1: add carrier wave on high level.
        constexpr uint32_t AFIFO_RST = (1U << 23);  ///< Reserved
        constexpr uint32_t CONF_UPDATE = (1U << 24);  ///< synchronization bit for CHANNEL%s
    }

    /// CH%s_RX_CONF0 Register bits
    namespace ch%s_rx_conf0_bits {
        constexpr uint32_t DIV_CNT = (8 << 0);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t IDLE_THRES = (15 << 8);  ///< When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
        constexpr uint32_t MEM_SIZE = (3 << 23);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EN = (1U << 28);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 29);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s. 1'h0: add carrier wave on low level. 1'h1: add carrier wave on high level.
    }

    /// CH%s_RX_CONF1 Register bits
    namespace ch%s_rx_conf1_bits {
        constexpr uint32_t RX_EN = (1U << 0);  ///< Set this bit to enable receiver to receive data on CHANNEL%s.
        constexpr uint32_t MEM_WR_RST = (1U << 1);  ///< Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t MEM_OWNER = (1U << 3);  ///< This register marks the ownership of CHANNEL%s's ram block. 1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
        constexpr uint32_t RX_FILTER_EN = (1U << 4);  ///< This is the receive filter's enable bit for CHANNEL%s.
        constexpr uint32_t RX_FILTER_THRES = (8 << 5);  ///< Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
        constexpr uint32_t MEM_RX_WRAP_EN = (1U << 13);  ///< This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
        constexpr uint32_t AFIFO_RST = (1U << 14);  ///< Reserved
        constexpr uint32_t CONF_UPDATE = (1U << 15);  ///< synchronization bit for CHANNEL%s
    }

    /// CH%s_TX_STATUS Register bits
    namespace ch%s_tx_status_bits {
        constexpr uint32_t MEM_RADDR_EX = (9 << 0);  ///< This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
        constexpr uint32_t STATE = (3 << 9);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t APB_MEM_WADDR = (9 << 12);  ///< This register records the memory address offset when writes RAM over APB bus.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 21);  ///< This status bit will be set if the offset address out of memory size when reading via APB bus.
        constexpr uint32_t MEM_EMPTY = (1U << 22);  ///< This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
        constexpr uint32_t APB_MEM_WR_ERR = (1U << 23);  ///< This status bit will be set if the offset address out of memory size when writes via APB bus.
        constexpr uint32_t APB_MEM_RADDR = (8 << 24);  ///< This register records the memory address offset when reading RAM over APB bus.
    }

    /// CH%s_RX_STATUS Register bits
    namespace ch%s_rx_status_bits {
        constexpr uint32_t MEM_WADDR_EX = (9 << 0);  ///< This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
        constexpr uint32_t APB_MEM_RADDR = (9 << 12);  ///< This register records the memory address offset when reads RAM over APB bus.
        constexpr uint32_t STATE = (3 << 22);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_OWNER_ERR = (1U << 25);  ///< This status bit will be set when the ownership of memory block is wrong.
        constexpr uint32_t MEM_FULL = (1U << 26);  ///< This status bit will be set if the receiver receives more data than the memory size.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 27);  ///< This status bit will be set if the offset address out of memory size when reads via APB bus.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
        constexpr uint32_t CH%s_RX_END = (1U << 2);  ///< The interrupt raw bit for CHANNEL2. Triggered when reception done.
        constexpr uint32_t CH%s_TX_ERR = (1U << 4);  ///< The interrupt raw bit for CHANNEL4. Triggered when error occurs.
        constexpr uint32_t CH%s_RX_ERR = (1U << 6);  ///< The interrupt raw bit for CHANNEL6. Triggered when error occurs.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 8);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH%s_RX_THR_EVENT = (1U << 10);  ///< The interrupt raw bit for CHANNEL2. Triggered when receiver receive more data than configured value.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 12);  ///< The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The masked interrupt status bit for CH%s_TX_END_INT.
        constexpr uint32_t CH%s_RX_END = (1U << 2);  ///< The masked interrupt status bit for CH2_RX_END_INT.
        constexpr uint32_t CH%s_TX_ERR = (1U << 4);  ///< The masked interrupt status bit for CH4_ERR_INT.
        constexpr uint32_t CH%s_RX_ERR = (1U << 6);  ///< The masked interrupt status bit for CH6_ERR_INT.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 8);  ///< The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
        constexpr uint32_t CH%s_RX_THR_EVENT = (1U << 10);  ///< The masked interrupt status bit for CH2_RX_THR_EVENT_INT.
        constexpr uint32_t CH%s_X_LOOP = (1U << 12);  ///< The masked interrupt status bit for CH%s_TX_LOOP_INT.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt enable bit for CH%s_TX_END_INT.
        constexpr uint32_t CH%s_RX_END = (1U << 2);  ///< The interrupt enable bit for CH2_RX_END_INT.
        constexpr uint32_t CH%s_TX_ERR = (1U << 4);  ///< The interrupt enable bit for CH4_ERR_INT.
        constexpr uint32_t CH%s_RX_ERR = (1U << 6);  ///< The interrupt enable bit for CH6_ERR_INT.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 8);  ///< The interrupt enable bit for CH%s_TX_THR_EVENT_INT.
        constexpr uint32_t CH%s_RX_THR_EVENT = (1U << 10);  ///< The interrupt enable bit for CH2_RX_THR_EVENT_INT.
        constexpr uint32_t CH%s_X_LOOP = (1U << 12);  ///< The interrupt enable bit for CH%s_TX_LOOP_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< Set this bit to clear theCH%s_TX_END_INT interrupt.
        constexpr uint32_t CH%s_RX_END = (1U << 2);  ///< Set this bit to clear theCH2_RX_END_INT interrupt.
        constexpr uint32_t CH%s_TX_ERR = (1U << 4);  ///< Set this bit to clear theCH4_ERR_INT interrupt.
        constexpr uint32_t CH%s_RX_ERR = (1U << 6);  ///< Set this bit to clear theCH6_ERR_INT interrupt.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 8);  ///< Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH%s_RX_THR_EVENT = (1U << 10);  ///< Set this bit to clear theCH2_RX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 12);  ///< Set this bit to clear theCH%s_TX_LOOP_INT interrupt.
    }

    /// CH%sCARRIER_DUTY Register bits
    namespace ch%scarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW = (16 << 0);  ///< This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
        constexpr uint32_t CARRIER_HIGH = (16 << 16);  ///< This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
    }

    /// CH%s_RX_CARRIER_RM Register bits
    namespace ch%s_rx_carrier_rm_bits {
        constexpr uint32_t CARRIER_LOW_THRES = (16 << 0);  ///< The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
        constexpr uint32_t CARRIER_HIGH_THRES = (16 << 16);  ///< The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
    }

    /// CH%s_TX_LIM Register bits
    namespace ch%s_tx_lim_bits {
        constexpr uint32_t TX_LIM = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can send out.
        constexpr uint32_t TX_LOOP_NUM = (10 << 9);  ///< This register is used to configure the maximum loop count when tx_conti_mode is valid.
        constexpr uint32_t TX_LOOP_CNT_EN = (1U << 19);  ///< This register is the enabled bit for loop count.
        constexpr uint32_t LOOP_COUNT_RESET = (1U << 20);  ///< This register is used to reset the loop count when tx_conti_mode is valid.
        constexpr uint32_t LOOP_STOP_EN = (1U << 21);  ///< This bit is used to enable the loop send stop function after the loop counter counts to loop number for CHANNEL%s.
    }

    /// CH%s_RX_LIM Register bits
    namespace ch%s_rx_lim_bits {
        constexpr uint32_t RMT_RX_LIM = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can receive.
    }

    /// SYS_CONF Register bits
    namespace sys_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< 1'h1: access memory directly. 1'h0: access memory by FIFO.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit to enable the clock for RMT memory.
        constexpr uint32_t MEM_FORCE_PD = (1U << 2);  ///< Set this bit to power down RMT memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 3);  ///< 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 4);  ///< the integral part of the fractional divisor
        constexpr uint32_t SCLK_DIV_A = (6 << 12);  ///< the numerator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_DIV_B = (6 << 18);  ///< the denominator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_SEL = (2 << 24);  ///< choose the clock source of rmt_sclk. 1:CLK_80Mhz,2:CLK_FOSC, 3:XTAL
        constexpr uint32_t SCLK_ACTIVE = (1U << 26);  ///< rmt_sclk switch
        constexpr uint32_t CLK_EN = (1U << 31);  ///< RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
    }

    /// TX_SIM Register bits
    namespace tx_sim_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH1 = (1U << 1);  ///< Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
        constexpr uint32_t EN = (1U << 2);  ///< This register is used to enable multiple of channels to start sending data synchronously.
    }

    /// REF_CNT_RST Register bits
    namespace ref_cnt_rst_bits {
        constexpr uint32_t TX_REF_CNT_RST = (1U << 0);  ///< This register is used to reset the clock divider of CHANNEL0.
        constexpr uint32_t TX_REF_CNT_RST_CH1 = (1U << 1);  ///< This register is used to reset the clock divider of CHANNEL1.
        constexpr uint32_t RX_REF_CNT_RST_CH2 = (1U << 2);  ///< This register is used to reset the clock divider of CHANNEL2.
        constexpr uint32_t RX_REF_CNT_RST_CH3 = (1U << 3);  ///< This register is used to reset the clock divider of CHANNEL3.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t RMT_DATE = (28 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x600B2800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x08 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// SOC Peripheral
// ============================================================================

namespace soc {
    /// Base addresses
    constexpr uint32_t SOC_ETM_BASE = 0x60013000;

    /// SOC Register structure
    struct Registers {
        volatile uint32_t CH_ENA_AD0;  ///< Offset: 0x00 - channel enable register
        volatile uint32_t CH_ENA_AD0_SET;  ///< Offset: 0x04 - channel enable set register
        volatile uint32_t CH_ENA_AD0_CLR;  ///< Offset: 0x08 - channel enable clear register
        volatile uint32_t CH_ENA_AD1;  ///< Offset: 0x0C - channel enable register
        volatile uint32_t CH_ENA_AD1_SET;  ///< Offset: 0x10 - channel enable set register
        volatile uint32_t CH_ENA_AD1_CLR;  ///< Offset: 0x14 - channel enable clear register
        volatile uint32_t CH0_EVT_ID;  ///< Offset: 0x18 - channel0 event id register
        volatile uint32_t CH0_TASK_ID;  ///< Offset: 0x1C - channel0 task id register
        volatile uint32_t CH1_EVT_ID;  ///< Offset: 0x20 - channel1 event id register
        volatile uint32_t CH1_TASK_ID;  ///< Offset: 0x24 - channel1 task id register
        volatile uint32_t CH2_EVT_ID;  ///< Offset: 0x28 - channel2 event id register
        volatile uint32_t CH2_TASK_ID;  ///< Offset: 0x2C - channel2 task id register
        volatile uint32_t CH3_EVT_ID;  ///< Offset: 0x30 - channel3 event id register
        volatile uint32_t CH3_TASK_ID;  ///< Offset: 0x34 - channel3 task id register
        volatile uint32_t CH4_EVT_ID;  ///< Offset: 0x38 - channel4 event id register
        volatile uint32_t CH4_TASK_ID;  ///< Offset: 0x3C - channel4 task id register
        volatile uint32_t CH5_EVT_ID;  ///< Offset: 0x40 - channel5 event id register
        volatile uint32_t CH5_TASK_ID;  ///< Offset: 0x44 - channel5 task id register
        volatile uint32_t CH6_EVT_ID;  ///< Offset: 0x48 - channel6 event id register
        volatile uint32_t CH6_TASK_ID;  ///< Offset: 0x4C - channel6 task id register
        volatile uint32_t CH7_EVT_ID;  ///< Offset: 0x50 - channel7 event id register
        volatile uint32_t CH7_TASK_ID;  ///< Offset: 0x54 - channel7 task id register
        volatile uint32_t CH8_EVT_ID;  ///< Offset: 0x58 - channel8 event id register
        volatile uint32_t CH8_TASK_ID;  ///< Offset: 0x5C - channel8 task id register
        volatile uint32_t CH9_EVT_ID;  ///< Offset: 0x60 - channel9 event id register
        volatile uint32_t CH9_TASK_ID;  ///< Offset: 0x64 - channel9 task id register
        volatile uint32_t CH10_EVT_ID;  ///< Offset: 0x68 - channel10 event id register
        volatile uint32_t CH10_TASK_ID;  ///< Offset: 0x6C - channel10 task id register
        volatile uint32_t CH11_EVT_ID;  ///< Offset: 0x70 - channel11 event id register
        volatile uint32_t CH11_TASK_ID;  ///< Offset: 0x74 - channel11 task id register
        volatile uint32_t CH12_EVT_ID;  ///< Offset: 0x78 - channel12 event id register
        volatile uint32_t CH12_TASK_ID;  ///< Offset: 0x7C - channel12 task id register
        volatile uint32_t CH13_EVT_ID;  ///< Offset: 0x80 - channel13 event id register
        volatile uint32_t CH13_TASK_ID;  ///< Offset: 0x84 - channel13 task id register
        volatile uint32_t CH14_EVT_ID;  ///< Offset: 0x88 - channel14 event id register
        volatile uint32_t CH14_TASK_ID;  ///< Offset: 0x8C - channel14 task id register
        volatile uint32_t CH15_EVT_ID;  ///< Offset: 0x90 - channel15 event id register
        volatile uint32_t CH15_TASK_ID;  ///< Offset: 0x94 - channel15 task id register
        volatile uint32_t CH16_EVT_ID;  ///< Offset: 0x98 - channel16 event id register
        volatile uint32_t CH16_TASK_ID;  ///< Offset: 0x9C - channel16 task id register
        volatile uint32_t CH17_EVT_ID;  ///< Offset: 0xA0 - channel17 event id register
        volatile uint32_t CH17_TASK_ID;  ///< Offset: 0xA4 - channel17 task id register
        volatile uint32_t CH18_EVT_ID;  ///< Offset: 0xA8 - channel18 event id register
        volatile uint32_t CH18_TASK_ID;  ///< Offset: 0xAC - channel18 task id register
        volatile uint32_t CH19_EVT_ID;  ///< Offset: 0xB0 - channel19 event id register
        volatile uint32_t CH19_TASK_ID;  ///< Offset: 0xB4 - channel19 task id register
        volatile uint32_t CH20_EVT_ID;  ///< Offset: 0xB8 - channel20 event id register
        volatile uint32_t CH20_TASK_ID;  ///< Offset: 0xBC - channel20 task id register
        volatile uint32_t CH21_EVT_ID;  ///< Offset: 0xC0 - channel21 event id register
        volatile uint32_t CH21_TASK_ID;  ///< Offset: 0xC4 - channel21 task id register
        volatile uint32_t CH22_EVT_ID;  ///< Offset: 0xC8 - channel22 event id register
        volatile uint32_t CH22_TASK_ID;  ///< Offset: 0xCC - channel22 task id register
        volatile uint32_t CH23_EVT_ID;  ///< Offset: 0xD0 - channel23 event id register
        volatile uint32_t CH23_TASK_ID;  ///< Offset: 0xD4 - channel23 task id register
        volatile uint32_t CH24_EVT_ID;  ///< Offset: 0xD8 - channel24 event id register
        volatile uint32_t CH24_TASK_ID;  ///< Offset: 0xDC - channel24 task id register
        volatile uint32_t CH25_EVT_ID;  ///< Offset: 0xE0 - channel25 event id register
        volatile uint32_t CH25_TASK_ID;  ///< Offset: 0xE4 - channel25 task id register
        volatile uint32_t CH26_EVT_ID;  ///< Offset: 0xE8 - channel26 event id register
        volatile uint32_t CH26_TASK_ID;  ///< Offset: 0xEC - channel26 task id register
        volatile uint32_t CH27_EVT_ID;  ///< Offset: 0xF0 - channel27 event id register
        volatile uint32_t CH27_TASK_ID;  ///< Offset: 0xF4 - channel27 task id register
        volatile uint32_t CH28_EVT_ID;  ///< Offset: 0xF8 - channel28 event id register
        volatile uint32_t CH28_TASK_ID;  ///< Offset: 0xFC - channel28 task id register
        volatile uint32_t CH29_EVT_ID;  ///< Offset: 0x100 - channel29 event id register
        volatile uint32_t CH29_TASK_ID;  ///< Offset: 0x104 - channel29 task id register
        volatile uint32_t CH30_EVT_ID;  ///< Offset: 0x108 - channel30 event id register
        volatile uint32_t CH30_TASK_ID;  ///< Offset: 0x10C - channel30 task id register
        volatile uint32_t CH31_EVT_ID;  ///< Offset: 0x110 - channel31 event id register
        volatile uint32_t CH31_TASK_ID;  ///< Offset: 0x114 - channel31 task id register
        volatile uint32_t CH32_EVT_ID;  ///< Offset: 0x118 - channel32 event id register
        volatile uint32_t CH32_TASK_ID;  ///< Offset: 0x11C - channel32 task id register
        volatile uint32_t CH33_EVT_ID;  ///< Offset: 0x120 - channel33 event id register
        volatile uint32_t CH33_TASK_ID;  ///< Offset: 0x124 - channel33 task id register
        volatile uint32_t CH34_EVT_ID;  ///< Offset: 0x128 - channel34 event id register
        volatile uint32_t CH34_TASK_ID;  ///< Offset: 0x12C - channel34 task id register
        volatile uint32_t CH35_EVT_ID;  ///< Offset: 0x130 - channel35 event id register
        volatile uint32_t CH35_TASK_ID;  ///< Offset: 0x134 - channel35 task id register
        volatile uint32_t CH36_EVT_ID;  ///< Offset: 0x138 - channel36 event id register
        volatile uint32_t CH36_TASK_ID;  ///< Offset: 0x13C - channel36 task id register
        volatile uint32_t CH37_EVT_ID;  ///< Offset: 0x140 - channel37 event id register
        volatile uint32_t CH37_TASK_ID;  ///< Offset: 0x144 - channel37 task id register
        volatile uint32_t CH38_EVT_ID;  ///< Offset: 0x148 - channel38 event id register
        volatile uint32_t CH38_TASK_ID;  ///< Offset: 0x14C - channel38 task id register
        volatile uint32_t CH39_EVT_ID;  ///< Offset: 0x150 - channel39 event id register
        volatile uint32_t CH39_TASK_ID;  ///< Offset: 0x154 - channel39 task id register
        volatile uint32_t CH40_EVT_ID;  ///< Offset: 0x158 - channel40 event id register
        volatile uint32_t CH40_TASK_ID;  ///< Offset: 0x15C - channel40 task id register
        volatile uint32_t CH41_EVT_ID;  ///< Offset: 0x160 - channel41 event id register
        volatile uint32_t CH41_TASK_ID;  ///< Offset: 0x164 - channel41 task id register
        volatile uint32_t CH42_EVT_ID;  ///< Offset: 0x168 - channel42 event id register
        volatile uint32_t CH42_TASK_ID;  ///< Offset: 0x16C - channel42 task id register
        volatile uint32_t CH43_EVT_ID;  ///< Offset: 0x170 - channel43 event id register
        volatile uint32_t CH43_TASK_ID;  ///< Offset: 0x174 - channel43 task id register
        volatile uint32_t CH44_EVT_ID;  ///< Offset: 0x178 - channel44 event id register
        volatile uint32_t CH44_TASK_ID;  ///< Offset: 0x17C - channel44 task id register
        volatile uint32_t CH45_EVT_ID;  ///< Offset: 0x180 - channel45 event id register
        volatile uint32_t CH45_TASK_ID;  ///< Offset: 0x184 - channel45 task id register
        volatile uint32_t CH46_EVT_ID;  ///< Offset: 0x188 - channel46 event id register
        volatile uint32_t CH46_TASK_ID;  ///< Offset: 0x18C - channel46 task id register
        volatile uint32_t CH47_EVT_ID;  ///< Offset: 0x190 - channel47 event id register
        volatile uint32_t CH47_TASK_ID;  ///< Offset: 0x194 - channel47 task id register
        volatile uint32_t CH48_EVT_ID;  ///< Offset: 0x198 - channel48 event id register
        volatile uint32_t CH48_TASK_ID;  ///< Offset: 0x19C - channel48 task id register
        volatile uint32_t CH49_EVT_ID;  ///< Offset: 0x1A0 - channel49 event id register
        volatile uint32_t CH49_TASK_ID;  ///< Offset: 0x1A4 - channel49 task id register
        volatile uint32_t CLK_EN;  ///< Offset: 0x1A8 - etm clock enable register
        volatile uint32_t DATE;  ///< Offset: 0x1AC - etm date register
    };

    /// Peripheral instances
    inline Registers* SOC_ETM = reinterpret_cast<Registers*>(SOC_ETM_BASE);

    // Bit definitions
    /// CH_ENA_AD0 Register bits
    namespace ch_ena_ad0_bits {
        constexpr uint32_t CH_ENA0 = (1U << 0);  ///< ch0 enable
        constexpr uint32_t CH_ENA1 = (1U << 1);  ///< ch1 enable
        constexpr uint32_t CH_ENA2 = (1U << 2);  ///< ch2 enable
        constexpr uint32_t CH_ENA3 = (1U << 3);  ///< ch3 enable
        constexpr uint32_t CH_ENA4 = (1U << 4);  ///< ch4 enable
        constexpr uint32_t CH_ENA5 = (1U << 5);  ///< ch5 enable
        constexpr uint32_t CH_ENA6 = (1U << 6);  ///< ch6 enable
        constexpr uint32_t CH_ENA7 = (1U << 7);  ///< ch7 enable
        constexpr uint32_t CH_ENA8 = (1U << 8);  ///< ch8 enable
        constexpr uint32_t CH_ENA9 = (1U << 9);  ///< ch9 enable
        constexpr uint32_t CH_ENA10 = (1U << 10);  ///< ch10 enable
        constexpr uint32_t CH_ENA11 = (1U << 11);  ///< ch11 enable
        constexpr uint32_t CH_ENA12 = (1U << 12);  ///< ch12 enable
        constexpr uint32_t CH_ENA13 = (1U << 13);  ///< ch13 enable
        constexpr uint32_t CH_ENA14 = (1U << 14);  ///< ch14 enable
        constexpr uint32_t CH_ENA15 = (1U << 15);  ///< ch15 enable
        constexpr uint32_t CH_ENA16 = (1U << 16);  ///< ch16 enable
        constexpr uint32_t CH_ENA17 = (1U << 17);  ///< ch17 enable
        constexpr uint32_t CH_ENA18 = (1U << 18);  ///< ch18 enable
        constexpr uint32_t CH_ENA19 = (1U << 19);  ///< ch19 enable
        constexpr uint32_t CH_ENA20 = (1U << 20);  ///< ch20 enable
        constexpr uint32_t CH_ENA21 = (1U << 21);  ///< ch21 enable
        constexpr uint32_t CH_ENA22 = (1U << 22);  ///< ch22 enable
        constexpr uint32_t CH_ENA23 = (1U << 23);  ///< ch23 enable
        constexpr uint32_t CH_ENA24 = (1U << 24);  ///< ch24 enable
        constexpr uint32_t CH_ENA25 = (1U << 25);  ///< ch25 enable
        constexpr uint32_t CH_ENA26 = (1U << 26);  ///< ch26 enable
        constexpr uint32_t CH_ENA27 = (1U << 27);  ///< ch27 enable
        constexpr uint32_t CH_ENA28 = (1U << 28);  ///< ch28 enable
        constexpr uint32_t CH_ENA29 = (1U << 29);  ///< ch29 enable
        constexpr uint32_t CH_ENA30 = (1U << 30);  ///< ch30 enable
        constexpr uint32_t CH_ENA31 = (1U << 31);  ///< ch31 enable
    }

    /// CH_ENA_AD0_SET Register bits
    namespace ch_ena_ad0_set_bits {
        constexpr uint32_t CH_SET0 = (1U << 0);  ///< ch0 set
        constexpr uint32_t CH_SET1 = (1U << 1);  ///< ch1 set
        constexpr uint32_t CH_SET2 = (1U << 2);  ///< ch2 set
        constexpr uint32_t CH_SET3 = (1U << 3);  ///< ch3 set
        constexpr uint32_t CH_SET4 = (1U << 4);  ///< ch4 set
        constexpr uint32_t CH_SET5 = (1U << 5);  ///< ch5 set
        constexpr uint32_t CH_SET6 = (1U << 6);  ///< ch6 set
        constexpr uint32_t CH_SET7 = (1U << 7);  ///< ch7 set
        constexpr uint32_t CH_SET8 = (1U << 8);  ///< ch8 set
        constexpr uint32_t CH_SET9 = (1U << 9);  ///< ch9 set
        constexpr uint32_t CH_SET10 = (1U << 10);  ///< ch10 set
        constexpr uint32_t CH_SET11 = (1U << 11);  ///< ch11 set
        constexpr uint32_t CH_SET12 = (1U << 12);  ///< ch12 set
        constexpr uint32_t CH_SET13 = (1U << 13);  ///< ch13 set
        constexpr uint32_t CH_SET14 = (1U << 14);  ///< ch14 set
        constexpr uint32_t CH_SET15 = (1U << 15);  ///< ch15 set
        constexpr uint32_t CH_SET16 = (1U << 16);  ///< ch16 set
        constexpr uint32_t CH_SET17 = (1U << 17);  ///< ch17 set
        constexpr uint32_t CH_SET18 = (1U << 18);  ///< ch18 set
        constexpr uint32_t CH_SET19 = (1U << 19);  ///< ch19 set
        constexpr uint32_t CH_SET20 = (1U << 20);  ///< ch20 set
        constexpr uint32_t CH_SET21 = (1U << 21);  ///< ch21 set
        constexpr uint32_t CH_SET22 = (1U << 22);  ///< ch22 set
        constexpr uint32_t CH_SET23 = (1U << 23);  ///< ch23 set
        constexpr uint32_t CH_SET24 = (1U << 24);  ///< ch24 set
        constexpr uint32_t CH_SET25 = (1U << 25);  ///< ch25 set
        constexpr uint32_t CH_SET26 = (1U << 26);  ///< ch26 set
        constexpr uint32_t CH_SET27 = (1U << 27);  ///< ch27 set
        constexpr uint32_t CH_SET28 = (1U << 28);  ///< ch28 set
        constexpr uint32_t CH_SET29 = (1U << 29);  ///< ch29 set
        constexpr uint32_t CH_SET30 = (1U << 30);  ///< ch30 set
        constexpr uint32_t CH_SET31 = (1U << 31);  ///< ch31 set
    }

    /// CH_ENA_AD0_CLR Register bits
    namespace ch_ena_ad0_clr_bits {
        constexpr uint32_t CH_CLR0 = (1U << 0);  ///< ch0 clear
        constexpr uint32_t CH_CLR1 = (1U << 1);  ///< ch1 clear
        constexpr uint32_t CH_CLR2 = (1U << 2);  ///< ch2 clear
        constexpr uint32_t CH_CLR3 = (1U << 3);  ///< ch3 clear
        constexpr uint32_t CH_CLR4 = (1U << 4);  ///< ch4 clear
        constexpr uint32_t CH_CLR5 = (1U << 5);  ///< ch5 clear
        constexpr uint32_t CH_CLR6 = (1U << 6);  ///< ch6 clear
        constexpr uint32_t CH_CLR7 = (1U << 7);  ///< ch7 clear
        constexpr uint32_t CH_CLR8 = (1U << 8);  ///< ch8 clear
        constexpr uint32_t CH_CLR9 = (1U << 9);  ///< ch9 clear
        constexpr uint32_t CH_CLR10 = (1U << 10);  ///< ch10 clear
        constexpr uint32_t CH_CLR11 = (1U << 11);  ///< ch11 clear
        constexpr uint32_t CH_CLR12 = (1U << 12);  ///< ch12 clear
        constexpr uint32_t CH_CLR13 = (1U << 13);  ///< ch13 clear
        constexpr uint32_t CH_CLR14 = (1U << 14);  ///< ch14 clear
        constexpr uint32_t CH_CLR15 = (1U << 15);  ///< ch15 clear
        constexpr uint32_t CH_CLR16 = (1U << 16);  ///< ch16 clear
        constexpr uint32_t CH_CLR17 = (1U << 17);  ///< ch17 clear
        constexpr uint32_t CH_CLR18 = (1U << 18);  ///< ch18 clear
        constexpr uint32_t CH_CLR19 = (1U << 19);  ///< ch19 clear
        constexpr uint32_t CH_CLR20 = (1U << 20);  ///< ch20 clear
        constexpr uint32_t CH_CLR21 = (1U << 21);  ///< ch21 clear
        constexpr uint32_t CH_CLR22 = (1U << 22);  ///< ch22 clear
        constexpr uint32_t CH_CLR23 = (1U << 23);  ///< ch23 clear
        constexpr uint32_t CH_CLR24 = (1U << 24);  ///< ch24 clear
        constexpr uint32_t CH_CLR25 = (1U << 25);  ///< ch25 clear
        constexpr uint32_t CH_CLR26 = (1U << 26);  ///< ch26 clear
        constexpr uint32_t CH_CLR27 = (1U << 27);  ///< ch27 clear
        constexpr uint32_t CH_CLR28 = (1U << 28);  ///< ch28 clear
        constexpr uint32_t CH_CLR29 = (1U << 29);  ///< ch29 clear
        constexpr uint32_t CH_CLR30 = (1U << 30);  ///< ch30 clear
        constexpr uint32_t CH_CLR31 = (1U << 31);  ///< ch31 clear
    }

    /// CH_ENA_AD1 Register bits
    namespace ch_ena_ad1_bits {
        constexpr uint32_t CH_ENA32 = (1U << 0);  ///< ch32 enable
        constexpr uint32_t CH_ENA33 = (1U << 1);  ///< ch33 enable
        constexpr uint32_t CH_ENA34 = (1U << 2);  ///< ch34 enable
        constexpr uint32_t CH_ENA35 = (1U << 3);  ///< ch35 enable
        constexpr uint32_t CH_ENA36 = (1U << 4);  ///< ch36 enable
        constexpr uint32_t CH_ENA37 = (1U << 5);  ///< ch37 enable
        constexpr uint32_t CH_ENA38 = (1U << 6);  ///< ch38 enable
        constexpr uint32_t CH_ENA39 = (1U << 7);  ///< ch39 enable
        constexpr uint32_t CH_ENA40 = (1U << 8);  ///< ch40 enable
        constexpr uint32_t CH_ENA41 = (1U << 9);  ///< ch41 enable
        constexpr uint32_t CH_ENA42 = (1U << 10);  ///< ch42 enable
        constexpr uint32_t CH_ENA43 = (1U << 11);  ///< ch43 enable
        constexpr uint32_t CH_ENA44 = (1U << 12);  ///< ch44 enable
        constexpr uint32_t CH_ENA45 = (1U << 13);  ///< ch45 enable
        constexpr uint32_t CH_ENA46 = (1U << 14);  ///< ch46 enable
        constexpr uint32_t CH_ENA47 = (1U << 15);  ///< ch47 enable
        constexpr uint32_t CH_ENA48 = (1U << 16);  ///< ch48 enable
        constexpr uint32_t CH_ENA49 = (1U << 17);  ///< ch49 enable
    }

    /// CH_ENA_AD1_SET Register bits
    namespace ch_ena_ad1_set_bits {
        constexpr uint32_t CH_SET32 = (1U << 0);  ///< ch32 set
        constexpr uint32_t CH_SET33 = (1U << 1);  ///< ch33 set
        constexpr uint32_t CH_SET34 = (1U << 2);  ///< ch34 set
        constexpr uint32_t CH_SET35 = (1U << 3);  ///< ch35 set
        constexpr uint32_t CH_SET36 = (1U << 4);  ///< ch36 set
        constexpr uint32_t CH_SET37 = (1U << 5);  ///< ch37 set
        constexpr uint32_t CH_SET38 = (1U << 6);  ///< ch38 set
        constexpr uint32_t CH_SET39 = (1U << 7);  ///< ch39 set
        constexpr uint32_t CH_SET40 = (1U << 8);  ///< ch40 set
        constexpr uint32_t CH_SET41 = (1U << 9);  ///< ch41 set
        constexpr uint32_t CH_SET42 = (1U << 10);  ///< ch42 set
        constexpr uint32_t CH_SET43 = (1U << 11);  ///< ch43 set
        constexpr uint32_t CH_SET44 = (1U << 12);  ///< ch44 set
        constexpr uint32_t CH_SET45 = (1U << 13);  ///< ch45 set
        constexpr uint32_t CH_SET46 = (1U << 14);  ///< ch46 set
        constexpr uint32_t CH_SET47 = (1U << 15);  ///< ch47 set
        constexpr uint32_t CH_SET48 = (1U << 16);  ///< ch48 set
        constexpr uint32_t CH_SET49 = (1U << 17);  ///< ch49 set
    }

    /// CH_ENA_AD1_CLR Register bits
    namespace ch_ena_ad1_clr_bits {
        constexpr uint32_t CH_CLR32 = (1U << 0);  ///< ch32 clear
        constexpr uint32_t CH_CLR33 = (1U << 1);  ///< ch33 clear
        constexpr uint32_t CH_CLR34 = (1U << 2);  ///< ch34 clear
        constexpr uint32_t CH_CLR35 = (1U << 3);  ///< ch35 clear
        constexpr uint32_t CH_CLR36 = (1U << 4);  ///< ch36 clear
        constexpr uint32_t CH_CLR37 = (1U << 5);  ///< ch37 clear
        constexpr uint32_t CH_CLR38 = (1U << 6);  ///< ch38 clear
        constexpr uint32_t CH_CLR39 = (1U << 7);  ///< ch39 clear
        constexpr uint32_t CH_CLR40 = (1U << 8);  ///< ch40 clear
        constexpr uint32_t CH_CLR41 = (1U << 9);  ///< ch41 clear
        constexpr uint32_t CH_CLR42 = (1U << 10);  ///< ch42 clear
        constexpr uint32_t CH_CLR43 = (1U << 11);  ///< ch43 clear
        constexpr uint32_t CH_CLR44 = (1U << 12);  ///< ch44 clear
        constexpr uint32_t CH_CLR45 = (1U << 13);  ///< ch45 clear
        constexpr uint32_t CH_CLR46 = (1U << 14);  ///< ch46 clear
        constexpr uint32_t CH_CLR47 = (1U << 15);  ///< ch47 clear
        constexpr uint32_t CH_CLR48 = (1U << 16);  ///< ch48 clear
        constexpr uint32_t CH_CLR49 = (1U << 17);  ///< ch49 clear
    }

    /// CH0_EVT_ID Register bits
    namespace ch0_evt_id_bits {
        constexpr uint32_t CH0_EVT_ID = (8 << 0);  ///< ch0_evt_id
    }

    /// CH0_TASK_ID Register bits
    namespace ch0_task_id_bits {
        constexpr uint32_t CH0_TASK_ID = (8 << 0);  ///< ch0_task_id
    }

    /// CH1_EVT_ID Register bits
    namespace ch1_evt_id_bits {
        constexpr uint32_t CH1_EVT_ID = (8 << 0);  ///< ch1_evt_id
    }

    /// CH1_TASK_ID Register bits
    namespace ch1_task_id_bits {
        constexpr uint32_t CH1_TASK_ID = (8 << 0);  ///< ch1_task_id
    }

    /// CH2_EVT_ID Register bits
    namespace ch2_evt_id_bits {
        constexpr uint32_t CH2_EVT_ID = (8 << 0);  ///< ch2_evt_id
    }

    /// CH2_TASK_ID Register bits
    namespace ch2_task_id_bits {
        constexpr uint32_t CH2_TASK_ID = (8 << 0);  ///< ch2_task_id
    }

    /// CH3_EVT_ID Register bits
    namespace ch3_evt_id_bits {
        constexpr uint32_t CH3_EVT_ID = (8 << 0);  ///< ch3_evt_id
    }

    /// CH3_TASK_ID Register bits
    namespace ch3_task_id_bits {
        constexpr uint32_t CH3_TASK_ID = (8 << 0);  ///< ch3_task_id
    }

    /// CH4_EVT_ID Register bits
    namespace ch4_evt_id_bits {
        constexpr uint32_t CH4_EVT_ID = (8 << 0);  ///< ch4_evt_id
    }

    /// CH4_TASK_ID Register bits
    namespace ch4_task_id_bits {
        constexpr uint32_t CH4_TASK_ID = (8 << 0);  ///< ch4_task_id
    }

    /// CH5_EVT_ID Register bits
    namespace ch5_evt_id_bits {
        constexpr uint32_t CH5_EVT_ID = (8 << 0);  ///< ch5_evt_id
    }

    /// CH5_TASK_ID Register bits
    namespace ch5_task_id_bits {
        constexpr uint32_t CH5_TASK_ID = (8 << 0);  ///< ch5_task_id
    }

    /// CH6_EVT_ID Register bits
    namespace ch6_evt_id_bits {
        constexpr uint32_t CH6_EVT_ID = (8 << 0);  ///< ch6_evt_id
    }

    /// CH6_TASK_ID Register bits
    namespace ch6_task_id_bits {
        constexpr uint32_t CH6_TASK_ID = (8 << 0);  ///< ch6_task_id
    }

    /// CH7_EVT_ID Register bits
    namespace ch7_evt_id_bits {
        constexpr uint32_t CH7_EVT_ID = (8 << 0);  ///< ch7_evt_id
    }

    /// CH7_TASK_ID Register bits
    namespace ch7_task_id_bits {
        constexpr uint32_t CH7_TASK_ID = (8 << 0);  ///< ch7_task_id
    }

    /// CH8_EVT_ID Register bits
    namespace ch8_evt_id_bits {
        constexpr uint32_t CH8_EVT_ID = (8 << 0);  ///< ch8_evt_id
    }

    /// CH8_TASK_ID Register bits
    namespace ch8_task_id_bits {
        constexpr uint32_t CH8_TASK_ID = (8 << 0);  ///< ch8_task_id
    }

    /// CH9_EVT_ID Register bits
    namespace ch9_evt_id_bits {
        constexpr uint32_t CH9_EVT_ID = (8 << 0);  ///< ch9_evt_id
    }

    /// CH9_TASK_ID Register bits
    namespace ch9_task_id_bits {
        constexpr uint32_t CH9_TASK_ID = (8 << 0);  ///< ch9_task_id
    }

    /// CH10_EVT_ID Register bits
    namespace ch10_evt_id_bits {
        constexpr uint32_t CH10_EVT_ID = (8 << 0);  ///< ch10_evt_id
    }

    /// CH10_TASK_ID Register bits
    namespace ch10_task_id_bits {
        constexpr uint32_t CH10_TASK_ID = (8 << 0);  ///< ch10_task_id
    }

    /// CH11_EVT_ID Register bits
    namespace ch11_evt_id_bits {
        constexpr uint32_t CH11_EVT_ID = (8 << 0);  ///< ch11_evt_id
    }

    /// CH11_TASK_ID Register bits
    namespace ch11_task_id_bits {
        constexpr uint32_t CH11_TASK_ID = (8 << 0);  ///< ch11_task_id
    }

    /// CH12_EVT_ID Register bits
    namespace ch12_evt_id_bits {
        constexpr uint32_t CH12_EVT_ID = (8 << 0);  ///< ch12_evt_id
    }

    /// CH12_TASK_ID Register bits
    namespace ch12_task_id_bits {
        constexpr uint32_t CH12_TASK_ID = (8 << 0);  ///< ch12_task_id
    }

    /// CH13_EVT_ID Register bits
    namespace ch13_evt_id_bits {
        constexpr uint32_t CH13_EVT_ID = (8 << 0);  ///< ch13_evt_id
    }

    /// CH13_TASK_ID Register bits
    namespace ch13_task_id_bits {
        constexpr uint32_t CH13_TASK_ID = (8 << 0);  ///< ch13_task_id
    }

    /// CH14_EVT_ID Register bits
    namespace ch14_evt_id_bits {
        constexpr uint32_t CH14_EVT_ID = (8 << 0);  ///< ch14_evt_id
    }

    /// CH14_TASK_ID Register bits
    namespace ch14_task_id_bits {
        constexpr uint32_t CH14_TASK_ID = (8 << 0);  ///< ch14_task_id
    }

    /// CH15_EVT_ID Register bits
    namespace ch15_evt_id_bits {
        constexpr uint32_t CH15_EVT_ID = (8 << 0);  ///< ch15_evt_id
    }

    /// CH15_TASK_ID Register bits
    namespace ch15_task_id_bits {
        constexpr uint32_t CH15_TASK_ID = (8 << 0);  ///< ch15_task_id
    }

    /// CH16_EVT_ID Register bits
    namespace ch16_evt_id_bits {
        constexpr uint32_t CH16_EVT_ID = (8 << 0);  ///< ch16_evt_id
    }

    /// CH16_TASK_ID Register bits
    namespace ch16_task_id_bits {
        constexpr uint32_t CH16_TASK_ID = (8 << 0);  ///< ch16_task_id
    }

    /// CH17_EVT_ID Register bits
    namespace ch17_evt_id_bits {
        constexpr uint32_t CH17_EVT_ID = (8 << 0);  ///< ch17_evt_id
    }

    /// CH17_TASK_ID Register bits
    namespace ch17_task_id_bits {
        constexpr uint32_t CH17_TASK_ID = (8 << 0);  ///< ch17_task_id
    }

    /// CH18_EVT_ID Register bits
    namespace ch18_evt_id_bits {
        constexpr uint32_t CH18_EVT_ID = (8 << 0);  ///< ch18_evt_id
    }

    /// CH18_TASK_ID Register bits
    namespace ch18_task_id_bits {
        constexpr uint32_t CH18_TASK_ID = (8 << 0);  ///< ch18_task_id
    }

    /// CH19_EVT_ID Register bits
    namespace ch19_evt_id_bits {
        constexpr uint32_t CH19_EVT_ID = (8 << 0);  ///< ch19_evt_id
    }

    /// CH19_TASK_ID Register bits
    namespace ch19_task_id_bits {
        constexpr uint32_t CH19_TASK_ID = (8 << 0);  ///< ch19_task_id
    }

    /// CH20_EVT_ID Register bits
    namespace ch20_evt_id_bits {
        constexpr uint32_t CH20_EVT_ID = (8 << 0);  ///< ch20_evt_id
    }

    /// CH20_TASK_ID Register bits
    namespace ch20_task_id_bits {
        constexpr uint32_t CH20_TASK_ID = (8 << 0);  ///< ch20_task_id
    }

    /// CH21_EVT_ID Register bits
    namespace ch21_evt_id_bits {
        constexpr uint32_t CH21_EVT_ID = (8 << 0);  ///< ch21_evt_id
    }

    /// CH21_TASK_ID Register bits
    namespace ch21_task_id_bits {
        constexpr uint32_t CH21_TASK_ID = (8 << 0);  ///< ch21_task_id
    }

    /// CH22_EVT_ID Register bits
    namespace ch22_evt_id_bits {
        constexpr uint32_t CH22_EVT_ID = (8 << 0);  ///< ch22_evt_id
    }

    /// CH22_TASK_ID Register bits
    namespace ch22_task_id_bits {
        constexpr uint32_t CH22_TASK_ID = (8 << 0);  ///< ch22_task_id
    }

    /// CH23_EVT_ID Register bits
    namespace ch23_evt_id_bits {
        constexpr uint32_t CH23_EVT_ID = (8 << 0);  ///< ch23_evt_id
    }

    /// CH23_TASK_ID Register bits
    namespace ch23_task_id_bits {
        constexpr uint32_t CH23_TASK_ID = (8 << 0);  ///< ch23_task_id
    }

    /// CH24_EVT_ID Register bits
    namespace ch24_evt_id_bits {
        constexpr uint32_t CH24_EVT_ID = (8 << 0);  ///< ch24_evt_id
    }

    /// CH24_TASK_ID Register bits
    namespace ch24_task_id_bits {
        constexpr uint32_t CH24_TASK_ID = (8 << 0);  ///< ch24_task_id
    }

    /// CH25_EVT_ID Register bits
    namespace ch25_evt_id_bits {
        constexpr uint32_t CH25_EVT_ID = (8 << 0);  ///< ch25_evt_id
    }

    /// CH25_TASK_ID Register bits
    namespace ch25_task_id_bits {
        constexpr uint32_t CH25_TASK_ID = (8 << 0);  ///< ch25_task_id
    }

    /// CH26_EVT_ID Register bits
    namespace ch26_evt_id_bits {
        constexpr uint32_t CH26_EVT_ID = (8 << 0);  ///< ch26_evt_id
    }

    /// CH26_TASK_ID Register bits
    namespace ch26_task_id_bits {
        constexpr uint32_t CH26_TASK_ID = (8 << 0);  ///< ch26_task_id
    }

    /// CH27_EVT_ID Register bits
    namespace ch27_evt_id_bits {
        constexpr uint32_t CH27_EVT_ID = (8 << 0);  ///< ch27_evt_id
    }

    /// CH27_TASK_ID Register bits
    namespace ch27_task_id_bits {
        constexpr uint32_t CH27_TASK_ID = (8 << 0);  ///< ch27_task_id
    }

    /// CH28_EVT_ID Register bits
    namespace ch28_evt_id_bits {
        constexpr uint32_t CH28_EVT_ID = (8 << 0);  ///< ch28_evt_id
    }

    /// CH28_TASK_ID Register bits
    namespace ch28_task_id_bits {
        constexpr uint32_t CH28_TASK_ID = (8 << 0);  ///< ch28_task_id
    }

    /// CH29_EVT_ID Register bits
    namespace ch29_evt_id_bits {
        constexpr uint32_t CH29_EVT_ID = (8 << 0);  ///< ch29_evt_id
    }

    /// CH29_TASK_ID Register bits
    namespace ch29_task_id_bits {
        constexpr uint32_t CH29_TASK_ID = (8 << 0);  ///< ch29_task_id
    }

    /// CH30_EVT_ID Register bits
    namespace ch30_evt_id_bits {
        constexpr uint32_t CH30_EVT_ID = (8 << 0);  ///< ch30_evt_id
    }

    /// CH30_TASK_ID Register bits
    namespace ch30_task_id_bits {
        constexpr uint32_t CH30_TASK_ID = (8 << 0);  ///< ch30_task_id
    }

    /// CH31_EVT_ID Register bits
    namespace ch31_evt_id_bits {
        constexpr uint32_t CH31_EVT_ID = (8 << 0);  ///< ch31_evt_id
    }

    /// CH31_TASK_ID Register bits
    namespace ch31_task_id_bits {
        constexpr uint32_t CH31_TASK_ID = (8 << 0);  ///< ch31_task_id
    }

    /// CH32_EVT_ID Register bits
    namespace ch32_evt_id_bits {
        constexpr uint32_t CH32_EVT_ID = (8 << 0);  ///< ch32_evt_id
    }

    /// CH32_TASK_ID Register bits
    namespace ch32_task_id_bits {
        constexpr uint32_t CH32_TASK_ID = (8 << 0);  ///< ch32_task_id
    }

    /// CH33_EVT_ID Register bits
    namespace ch33_evt_id_bits {
        constexpr uint32_t CH33_EVT_ID = (8 << 0);  ///< ch33_evt_id
    }

    /// CH33_TASK_ID Register bits
    namespace ch33_task_id_bits {
        constexpr uint32_t CH33_TASK_ID = (8 << 0);  ///< ch33_task_id
    }

    /// CH34_EVT_ID Register bits
    namespace ch34_evt_id_bits {
        constexpr uint32_t CH34_EVT_ID = (8 << 0);  ///< ch34_evt_id
    }

    /// CH34_TASK_ID Register bits
    namespace ch34_task_id_bits {
        constexpr uint32_t CH34_TASK_ID = (8 << 0);  ///< ch34_task_id
    }

    /// CH35_EVT_ID Register bits
    namespace ch35_evt_id_bits {
        constexpr uint32_t CH35_EVT_ID = (8 << 0);  ///< ch35_evt_id
    }

    /// CH35_TASK_ID Register bits
    namespace ch35_task_id_bits {
        constexpr uint32_t CH35_TASK_ID = (8 << 0);  ///< ch35_task_id
    }

    /// CH36_EVT_ID Register bits
    namespace ch36_evt_id_bits {
        constexpr uint32_t CH36_EVT_ID = (8 << 0);  ///< ch36_evt_id
    }

    /// CH36_TASK_ID Register bits
    namespace ch36_task_id_bits {
        constexpr uint32_t CH36_TASK_ID = (8 << 0);  ///< ch36_task_id
    }

    /// CH37_EVT_ID Register bits
    namespace ch37_evt_id_bits {
        constexpr uint32_t CH37_EVT_ID = (8 << 0);  ///< ch37_evt_id
    }

    /// CH37_TASK_ID Register bits
    namespace ch37_task_id_bits {
        constexpr uint32_t CH37_TASK_ID = (8 << 0);  ///< ch37_task_id
    }

    /// CH38_EVT_ID Register bits
    namespace ch38_evt_id_bits {
        constexpr uint32_t CH38_EVT_ID = (8 << 0);  ///< ch38_evt_id
    }

    /// CH38_TASK_ID Register bits
    namespace ch38_task_id_bits {
        constexpr uint32_t CH38_TASK_ID = (8 << 0);  ///< ch38_task_id
    }

    /// CH39_EVT_ID Register bits
    namespace ch39_evt_id_bits {
        constexpr uint32_t CH39_EVT_ID = (8 << 0);  ///< ch39_evt_id
    }

    /// CH39_TASK_ID Register bits
    namespace ch39_task_id_bits {
        constexpr uint32_t CH39_TASK_ID = (8 << 0);  ///< ch39_task_id
    }

    /// CH40_EVT_ID Register bits
    namespace ch40_evt_id_bits {
        constexpr uint32_t CH40_EVT_ID = (8 << 0);  ///< ch40_evt_id
    }

    /// CH40_TASK_ID Register bits
    namespace ch40_task_id_bits {
        constexpr uint32_t CH40_TASK_ID = (8 << 0);  ///< ch40_task_id
    }

    /// CH41_EVT_ID Register bits
    namespace ch41_evt_id_bits {
        constexpr uint32_t CH41_EVT_ID = (8 << 0);  ///< ch41_evt_id
    }

    /// CH41_TASK_ID Register bits
    namespace ch41_task_id_bits {
        constexpr uint32_t CH41_TASK_ID = (8 << 0);  ///< ch41_task_id
    }

    /// CH42_EVT_ID Register bits
    namespace ch42_evt_id_bits {
        constexpr uint32_t CH42_EVT_ID = (8 << 0);  ///< ch42_evt_id
    }

    /// CH42_TASK_ID Register bits
    namespace ch42_task_id_bits {
        constexpr uint32_t CH42_TASK_ID = (8 << 0);  ///< ch42_task_id
    }

    /// CH43_EVT_ID Register bits
    namespace ch43_evt_id_bits {
        constexpr uint32_t CH43_EVT_ID = (8 << 0);  ///< ch43_evt_id
    }

    /// CH43_TASK_ID Register bits
    namespace ch43_task_id_bits {
        constexpr uint32_t CH43_TASK_ID = (8 << 0);  ///< ch43_task_id
    }

    /// CH44_EVT_ID Register bits
    namespace ch44_evt_id_bits {
        constexpr uint32_t CH44_EVT_ID = (8 << 0);  ///< ch44_evt_id
    }

    /// CH44_TASK_ID Register bits
    namespace ch44_task_id_bits {
        constexpr uint32_t CH44_TASK_ID = (8 << 0);  ///< ch44_task_id
    }

    /// CH45_EVT_ID Register bits
    namespace ch45_evt_id_bits {
        constexpr uint32_t CH45_EVT_ID = (8 << 0);  ///< ch45_evt_id
    }

    /// CH45_TASK_ID Register bits
    namespace ch45_task_id_bits {
        constexpr uint32_t CH45_TASK_ID = (8 << 0);  ///< ch45_task_id
    }

    /// CH46_EVT_ID Register bits
    namespace ch46_evt_id_bits {
        constexpr uint32_t CH46_EVT_ID = (8 << 0);  ///< ch46_evt_id
    }

    /// CH46_TASK_ID Register bits
    namespace ch46_task_id_bits {
        constexpr uint32_t CH46_TASK_ID = (8 << 0);  ///< ch46_task_id
    }

    /// CH47_EVT_ID Register bits
    namespace ch47_evt_id_bits {
        constexpr uint32_t CH47_EVT_ID = (8 << 0);  ///< ch47_evt_id
    }

    /// CH47_TASK_ID Register bits
    namespace ch47_task_id_bits {
        constexpr uint32_t CH47_TASK_ID = (8 << 0);  ///< ch47_task_id
    }

    /// CH48_EVT_ID Register bits
    namespace ch48_evt_id_bits {
        constexpr uint32_t CH48_EVT_ID = (8 << 0);  ///< ch48_evt_id
    }

    /// CH48_TASK_ID Register bits
    namespace ch48_task_id_bits {
        constexpr uint32_t CH48_TASK_ID = (8 << 0);  ///< ch48_task_id
    }

    /// CH49_EVT_ID Register bits
    namespace ch49_evt_id_bits {
        constexpr uint32_t CH49_EVT_ID = (8 << 0);  ///< ch49_evt_id
    }

    /// CH49_TASK_ID Register bits
    namespace ch49_task_id_bits {
        constexpr uint32_t CH49_TASK_ID = (8 << 0);  ///< ch49_task_id
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock enable
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< date
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x60002000;
    constexpr uint32_t SPI1_BASE = 0x60003000;
    constexpr uint32_t SPI2_BASE = 0x60081000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_MEM_CMD;  ///< Offset: 0x00 - SPI0 FSM status register
        volatile uint32_t SPI_MEM_CTRL;  ///< Offset: 0x08 - SPI0 control register.
        volatile uint32_t SPI_MEM_CTRL1;  ///< Offset: 0x0C - SPI0 control1 register.
        volatile uint32_t SPI_MEM_CTRL2;  ///< Offset: 0x10 - SPI0 control2 register.
        volatile uint32_t SPI_MEM_CLOCK;  ///< Offset: 0x14 - SPI clock division control register.
        volatile uint32_t SPI_MEM_USER;  ///< Offset: 0x18 - SPI0 user register.
        volatile uint32_t SPI_MEM_USER1;  ///< Offset: 0x1C - SPI0 user1 register.
        volatile uint32_t SPI_MEM_USER2;  ///< Offset: 0x20 - SPI0 user2 register.
        volatile uint32_t SPI_MEM_RD_STATUS;  ///< Offset: 0x2C - SPI0 read control register.
        volatile uint32_t SPI_MEM_MISC;  ///< Offset: 0x34 - SPI0 misc register
        volatile uint32_t SPI_MEM_CACHE_FCTRL;  ///< Offset: 0x3C - SPI0 bit mode control register.
        volatile uint32_t SPI_MEM_CACHE_SCTRL;  ///< Offset: 0x40 - SPI0 external RAM control register
        volatile uint32_t SPI_MEM_SRAM_CMD;  ///< Offset: 0x44 - SPI0 external RAM mode control register
        volatile uint32_t SPI_MEM_SRAM_DRD_CMD;  ///< Offset: 0x48 - SPI0 external RAM DDR read command control register
        volatile uint32_t SPI_MEM_SRAM_DWR_CMD;  ///< Offset: 0x4C - SPI0 external RAM DDR write command control register
        volatile uint32_t SPI_MEM_SRAM_CLK;  ///< Offset: 0x50 - SPI0 external RAM clock control register
        volatile uint32_t SPI_MEM_FSM;  ///< Offset: 0x54 - SPI0 FSM status register
        volatile uint32_t SPI_MEM_INT_ENA;  ///< Offset: 0xC0 - SPI0 interrupt enable register
        volatile uint32_t SPI_MEM_INT_CLR;  ///< Offset: 0xC4 - SPI0 interrupt clear register
        volatile uint32_t SPI_MEM_INT_RAW;  ///< Offset: 0xC8 - SPI0 interrupt raw register
        volatile uint32_t SPI_MEM_INT_ST;  ///< Offset: 0xCC - SPI0 interrupt status register
        volatile uint32_t SPI_MEM_DDR;  ///< Offset: 0xD4 - SPI0 flash DDR mode control register
        volatile uint32_t SPI_SMEM_DDR;  ///< Offset: 0xD8 - SPI0 external RAM DDR mode control register
        volatile uint32_t SPI_FMEM_PMS%s_ATTR;  ///< Offset: 0x100 - MSPI flash ACE section %s attribute register
        volatile uint32_t SPI_FMEM_PMS%s_ADDR;  ///< Offset: 0x110 - SPI1 flash ACE section %s start address register
        volatile uint32_t SPI_FMEM_PMS%s_SIZE;  ///< Offset: 0x120 - SPI1 flash ACE section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_ATTR;  ///< Offset: 0x130 - SPI1 flash ACE section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_ADDR;  ///< Offset: 0x140 - SPI1 external RAM ACE section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_SIZE;  ///< Offset: 0x150 - SPI1 external RAM ACE section %s start address register
        volatile uint32_t SPI_MEM_PMS_REJECT;  ///< Offset: 0x164 - SPI1 access reject register
        volatile uint32_t SPI_MEM_ECC_CTRL;  ///< Offset: 0x168 - MSPI ECC control register
        volatile uint32_t SPI_MEM_ECC_ERR_ADDR;  ///< Offset: 0x16C - MSPI ECC error address register
        volatile uint32_t SPI_MEM_AXI_ERR_ADDR;  ///< Offset: 0x170 - SPI0 AXI request error address.
        volatile uint32_t SPI_SMEM_ECC_CTRL;  ///< Offset: 0x174 - MSPI ECC control register
        volatile uint32_t SPI_MEM_TIMING_CALI;  ///< Offset: 0x180 - SPI0 flash timing calibration register
        volatile uint32_t SPI_MEM_DIN_MODE;  ///< Offset: 0x184 - MSPI flash input timing delay mode control register
        volatile uint32_t SPI_MEM_DIN_NUM;  ///< Offset: 0x188 - MSPI flash input timing delay number control register
        volatile uint32_t SPI_MEM_DOUT_MODE;  ///< Offset: 0x18C - MSPI flash output timing adjustment control register
        volatile uint32_t SPI_SMEM_TIMING_CALI;  ///< Offset: 0x190 - MSPI external RAM timing calibration register
        volatile uint32_t SPI_SMEM_DIN_MODE;  ///< Offset: 0x194 - MSPI external RAM input timing delay mode control register
        volatile uint32_t SPI_SMEM_DIN_NUM;  ///< Offset: 0x198 - MSPI external RAM input timing delay number control register
        volatile uint32_t SPI_SMEM_DOUT_MODE;  ///< Offset: 0x19C - MSPI external RAM output timing adjustment control register
        volatile uint32_t SPI_SMEM_AC;  ///< Offset: 0x1A0 - MSPI external RAM ECC and SPI CS timing control register
        volatile uint32_t SPI_MEM_CLOCK_GATE;  ///< Offset: 0x200 - SPI0 clock gate register
        volatile uint32_t SPI_MEM_XTS_PLAIN_BASE;  ///< Offset: 0x300 - The base address of the memory that stores plaintext in...
        volatile uint32_t SPI_MEM_XTS_LINESIZE;  ///< Offset: 0x340 - Manual Encryption Line-Size register
        volatile uint32_t SPI_MEM_XTS_DESTINATION;  ///< Offset: 0x344 - Manual Encryption destination register
        volatile uint32_t SPI_MEM_XTS_PHYSICAL_ADDRESS;  ///< Offset: 0x348 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_TRIGGER;  ///< Offset: 0x34C - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_RELEASE;  ///< Offset: 0x350 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_DESTROY;  ///< Offset: 0x354 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_STATE;  ///< Offset: 0x358 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_DATE;  ///< Offset: 0x35C - Manual Encryption version register
        volatile uint32_t SPI_MEM_MMU_ITEM_CONTENT;  ///< Offset: 0x37C - MSPI-MMU item content register
        volatile uint32_t SPI_MEM_MMU_ITEM_INDEX;  ///< Offset: 0x380 - MSPI-MMU item index register
        volatile uint32_t SPI_MEM_MMU_POWER_CTRL;  ///< Offset: 0x384 - MSPI MMU power control register
        volatile uint32_t SPI_MEM_DPA_CTRL;  ///< Offset: 0x388 - SPI memory cryption DPA register
        volatile uint32_t SPI_MEM_REGISTERRND_ECO_HIGH;  ///< Offset: 0x3F0 - MSPI ECO high register
        volatile uint32_t SPI_MEM_REGISTERRND_ECO_LOW;  ///< Offset: 0x3F4 - MSPI ECO low register
        volatile uint32_t SPI_MEM_DATE;  ///< Offset: 0x3FC - SPI0 version control register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// SPI_MEM_CMD Register bits
    namespace spi_mem_cmd_bits {
        constexpr uint32_t SPI_MEM_MST_ST = (4 << 0);  ///< The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:SPI0_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
        constexpr uint32_t SPI_MEM_SLV_ST = (4 << 4);  ///< The current status of SPI0 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
        constexpr uint32_t SPI_MEM_USR = (1U << 18);  ///< SPI0 USR_CMD start bit, only used when SPI_MEM_AXI_REQ_EN is cleared. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    }

    /// SPI_MEM_CTRL Register bits
    namespace spi_mem_ctrl_bits {
        constexpr uint32_t SPI_MEM_WDUMMY_DQS_ALWAYS_OUT = (1U << 0);  ///< In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_DQS is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_WDUMMY_ALWAYS_OUT = (1U << 1);  ///< In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_FDUMMY_RIN = (1U << 2);  ///< In an MSPI read data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the first half part of dummy phase. It is used to mask invalid SPI_DQS in the half part of dummy phase.
        constexpr uint32_t SPI_MEM_FDUMMY_WOUT = (1U << 3);  ///< In an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the second half part of dummy phase. It is used to pre-drive flash.
        constexpr uint32_t SPI_MEM_FDOUT_OCT = (1U << 4);  ///< Apply 8 signals during write-data phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FDIN_OCT = (1U << 5);  ///< Apply 8 signals during read-data phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FADDR_OCT = (1U << 6);  ///< Apply 8 signals during address phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FCMD_QUAD = (1U << 8);  ///< Apply 4 signals during command phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FCMD_OCT = (1U << 9);  ///< Apply 8 signals during command phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FASTRD_MODE = (1U << 13);  ///< This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT and SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_FREAD_DUAL = (1U << 14);  ///< In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low
        constexpr uint32_t SPI_MEM_D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low
        constexpr uint32_t SPI_MEM_FREAD_QUAD = (1U << 20);  ///< In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low.
        constexpr uint32_t SPI_MEM_FREAD_DIO = (1U << 23);  ///< In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_FREAD_QIO = (1U << 24);  ///< In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_DQS_IE_ALWAYS_ON = (1U << 30);  ///< When accesses to flash, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        constexpr uint32_t SPI_MEM_DATA_IE_ALWAYS_ON = (1U << 31);  ///< When accesses to flash, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
    }

    /// SPI_MEM_CTRL1 Register bits
    namespace spi_mem_ctrl1_bits {
        constexpr uint32_t SPI_MEM_CLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
        constexpr uint32_t SPI_AR_SIZE0_1_SUPPORT_EN = (1U << 21);  ///< 1: MSPI supports ARSIZE 0~3. When ARSIZE =0~2, MSPI read address is 4*n and reply the real AXI read data back. 0: When ARSIZE 0~1, MSPI reply SLV_ERR.
        constexpr uint32_t SPI_AW_SIZE0_1_SUPPORT_EN = (1U << 22);  ///< 1: MSPI supports AWSIZE 0~3. 0: When AWSIZE 0~1, MSPI reply SLV_ERR.
        constexpr uint32_t SPI_AXI_RDATA_BACK_FAST = (1U << 23);  ///< 1: Reply AXI read data to AXI bus when one AXI read beat data is available. 0: Reply AXI read data to AXI bus when all the read data is available.
        constexpr uint32_t SPI_MEM_RRESP_ECC_ERR_EN = (1U << 24);  ///< 1: RRESP is SLV_ERR when there is a ECC error in AXI read data. 0: RRESP is OKAY when there is a ECC error in AXI read data. The ECC error information is recorded in SPI_MEM_ECC_ERR_ADDR_REG.
        constexpr uint32_t SPI_MEM_AR_SPLICE_EN = (1U << 25);  ///< Set this bit to enable AXI Read Splice-transfer.
        constexpr uint32_t SPI_MEM_AW_SPLICE_EN = (1U << 26);  ///< Set this bit to enable AXI Write Splice-transfer.
        constexpr uint32_t SPI_MEM_RAM0_EN = (1U << 27);  ///< When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 1, only EXT_RAM0 will be accessed. When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 0, only EXT_RAM1 will be accessed. When SPI_MEM_DUAL_RAM_EN is 1, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        constexpr uint32_t SPI_MEM_DUAL_RAM_EN = (1U << 28);  ///< Set this bit to enable DUAL-RAM mode, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        constexpr uint32_t SPI_MEM_FAST_WRITE_EN = (1U << 29);  ///< Set this bit to write data faster, do not wait write data has been stored in tx_bus_fifo_l2. It will wait 4*T_clk_ctrl to insure the write data has been stored in tx_bus_fifo_l2.
        constexpr uint32_t SPI_MEM_RXFIFO_RST = (1U << 30);  ///< The synchronous reset signal for SPI0 RX AFIFO and all the AES_MSPI SYNC FIFO to receive signals from AXI. Set this bit to reset these FIFO.
        constexpr uint32_t SPI_MEM_TXFIFO_RST = (1U << 31);  ///< The synchronous reset signal for SPI0 TX AFIFO and all the AES_MSPI SYNC FIFO to send signals to AXI. Set this bit to reset these FIFO.
    }

    /// SPI_MEM_CTRL2 Register bits
    namespace spi_mem_ctrl2_bits {
        constexpr uint32_t SPI_MEM_CS_SETUP_TIME = (5 << 0);  ///< (cycles-1) of prepare phase by SPI Bus clock, this bits are combined with SPI_MEM_CS_SETUP bit.
        constexpr uint32_t SPI_MEM_CS_HOLD_TIME = (5 << 5);  ///< SPI CS signal is delayed to inactive by SPI bus clock, this bits are combined with SPI_MEM_CS_HOLD bit.
        constexpr uint32_t SPI_MEM_ECC_CS_HOLD_TIME = (3 << 10);  ///< SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI0 CS hold cycle in ECC mode when accessed flash.
        constexpr uint32_t SPI_MEM_ECC_SKIP_PAGE_CORNER = (1U << 13);  ///< 1: SPI0 and SPI1 skip page corner when accesses flash. 0: Not skip page corner when accesses flash.
        constexpr uint32_t SPI_MEM_ECC_16TO18_BYTE_EN = (1U << 14);  ///< Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
        constexpr uint32_t SPI_MEM_SPLIT_TRANS_EN = (1U << 24);  ///< Set this bit to enable SPI0 split one AXI read flash transfer into two SPI transfers when one transfer will cross flash or EXT_RAM page corner, valid no matter whether there is an ECC region or not.
        constexpr uint32_t SPI_MEM_CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SPI_MEM_SYNC_RESET = (1U << 31);  ///< The spi0_mst_st and spi0_slv_st will be reset.
    }

    /// SPI_MEM_CLOCK Register bits
    namespace spi_mem_clock_bits {
        constexpr uint32_t SPI_MEM_CLKCNT_L = (8 << 0);  ///< In the master mode it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t SPI_MEM_CLKCNT_H = (8 << 8);  ///< In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t SPI_MEM_CLKCNT_N = (8 << 16);  ///< In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t SPI_MEM_CLK_EQU_SYSCLK = (1U << 31);  ///< 1: 1-division mode, the frequency of SPI bus clock equals to that of MSPI module clock.
    }

    /// SPI_MEM_USER Register bits
    namespace spi_mem_user_bits {
        constexpr uint32_t SPI_MEM_CS_HOLD = (1U << 6);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_CS_SETUP = (1U << 7);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_CK_OUT_EDGE = (1U << 9);  ///< The bit combined with SPI_MEM_CK_IDLE_EDGE bit to control SPI clock mode 0~3.
        constexpr uint32_t SPI_MEM_USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable.
        constexpr uint32_t SPI_MEM_USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation.
    }

    /// SPI_MEM_USER1 Register bits
    namespace spi_mem_user1_bits {
        constexpr uint32_t SPI_MEM_USR_DUMMY_CYCLELEN = (6 << 0);  ///< The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        constexpr uint32_t SPI_MEM_USR_DBYTELEN = (3 << 6);  ///< SPI0 USR_CMD read or write data byte length -1
        constexpr uint32_t SPI_MEM_USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of address phase. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_USER2 Register bits
    namespace spi_mem_user2_bits {
        constexpr uint32_t SPI_MEM_USR_COMMAND_VALUE = (16 << 0);  ///< The value of command.
        constexpr uint32_t SPI_MEM_USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1)
    }

    /// SPI_MEM_RD_STATUS Register bits
    namespace spi_mem_rd_status_bits {
        constexpr uint32_t SPI_MEM_WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode bit.
    }

    /// SPI_MEM_MISC Register bits
    namespace spi_mem_misc_bits {
        constexpr uint32_t SPI_MEM_FSUB_PIN = (1U << 7);  ///< For SPI0, flash is connected to SUBPINs.
        constexpr uint32_t SPI_MEM_SSUB_PIN = (1U << 8);  ///< For SPI0, sram is connected to SUBPINs.
        constexpr uint32_t SPI_MEM_CK_IDLE_EDGE = (1U << 9);  ///< 1: SPI_CLK line is high when idle 0: spi clk line is low when idle
        constexpr uint32_t SPI_MEM_CS_KEEP_ACTIVE = (1U << 10);  ///< SPI_CS line keep low when the bit is set.
    }

    /// SPI_MEM_CACHE_FCTRL Register bits
    namespace spi_mem_cache_fctrl_bits {
        constexpr uint32_t SPI_MEM_AXI_REQ_EN = (1U << 0);  ///< For SPI0, AXI master access enable, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_CACHE_USR_ADDR_4BYTE = (1U << 1);  ///< For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_CACHE_FLASH_USR_CMD = (1U << 2);  ///< For SPI0, cache read flash for user define command, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_FDIN_DUAL = (1U << 3);  ///< For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FDOUT_DUAL = (1U << 4);  ///< For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FADDR_DUAL = (1U << 5);  ///< For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FDIN_QUAD = (1U << 6);  ///< For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_MEM_FDOUT_QUAD = (1U << 7);  ///< For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_MEM_FADDR_QUAD = (1U << 8);  ///< For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_SAME_AW_AR_ADDR_CHK_EN = (1U << 30);  ///< Set this bit to check AXI read/write the same address region.
        constexpr uint32_t SPI_CLOSE_AXI_INF_EN = (1U << 31);  ///< Set this bit to close AXI read/write transfer to MSPI, which means that only SLV_ERR will be replied to BRESP/RRESP.
    }

    /// SPI_MEM_CACHE_SCTRL Register bits
    namespace spi_mem_cache_sctrl_bits {
        constexpr uint32_t SPI_MEM_CACHE_USR_SADDR_4BYTE = (1U << 0);  ///< For SPI0, In the external RAM mode, cache read flash with 4 bytes command, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_USR_SRAM_DIO = (1U << 1);  ///< For SPI0, In the external RAM mode, spi dual I/O mode enable, 1: enable, 0:disable
        constexpr uint32_t SPI_MEM_USR_SRAM_QIO = (1U << 2);  ///< For SPI0, In the external RAM mode, spi quad I/O mode enable, 1: enable, 0:disable
        constexpr uint32_t SPI_MEM_USR_WR_SRAM_DUMMY = (1U << 3);  ///< For SPI0, In the external RAM mode, it is the enable bit of dummy phase for write operations.
        constexpr uint32_t SPI_MEM_USR_RD_SRAM_DUMMY = (1U << 4);  ///< For SPI0, In the external RAM mode, it is the enable bit of dummy phase for read operations.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RCMD = (1U << 5);  ///< For SPI0, In the external RAM mode cache read external RAM for user define command.
        constexpr uint32_t SPI_MEM_SRAM_RDUMMY_CYCLELEN = (6 << 6);  ///< For SPI0, In the external RAM mode, it is the length in bits of read dummy phase. The register value shall be (bit_num-1).
        constexpr uint32_t SPI_MEM_SRAM_ADDR_BITLEN = (6 << 14);  ///< For SPI0, In the external RAM mode, it is the length in bits of address phase. The register value shall be (bit_num-1).
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WCMD = (1U << 20);  ///< For SPI0, In the external RAM mode cache write sram for user define command
        constexpr uint32_t SPI_MEM_SRAM_OCT = (1U << 21);  ///< reserved
        constexpr uint32_t SPI_MEM_SRAM_WDUMMY_CYCLELEN = (6 << 22);  ///< For SPI0, In the external RAM mode, it is the length in bits of write dummy phase. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_CMD Register bits
    namespace spi_mem_sram_cmd_bits {
        constexpr uint32_t SPI_MEM_SCLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is always on.
        constexpr uint32_t SPI_MEM_SWB_MODE = (8 << 2);  ///< Mode bits in the external RAM fast read mode it is combined with spi_mem_fastrd_mode bit.
        constexpr uint32_t SPI_MEM_SDIN_DUAL = (1U << 10);  ///< For SPI0 external RAM , din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SDOUT_DUAL = (1U << 11);  ///< For SPI0 external RAM , dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SADDR_DUAL = (1U << 12);  ///< For SPI0 external RAM , address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SDIN_QUAD = (1U << 14);  ///< For SPI0 external RAM , din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SDOUT_QUAD = (1U << 15);  ///< For SPI0 external RAM , dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SADDR_QUAD = (1U << 16);  ///< For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SCMD_QUAD = (1U << 17);  ///< For SPI0 external RAM , cmd phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SDIN_OCT = (1U << 18);  ///< For SPI0 external RAM , din phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SDOUT_OCT = (1U << 19);  ///< For SPI0 external RAM , dout phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SADDR_OCT = (1U << 20);  ///< For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SCMD_OCT = (1U << 21);  ///< For SPI0 external RAM , cmd phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SDUMMY_RIN = (1U << 22);  ///< In the dummy phase of a MSPI read data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_SDUMMY_WOUT = (1U << 23);  ///< In the dummy phase of a MSPI write data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        constexpr uint32_t SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT = (1U << 24);  ///< In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_DQS is output by the MSPI controller.
        constexpr uint32_t SPI_SMEM_WDUMMY_ALWAYS_OUT = (1U << 25);  ///< In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_IO[7:0] is output by the MSPI controller.
        constexpr uint32_t SPI_SMEM_DQS_IE_ALWAYS_ON = (1U << 30);  ///< When accesses to external RAM, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        constexpr uint32_t SPI_SMEM_DATA_IE_ALWAYS_ON = (1U << 31);  ///< When accesses to external RAM, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
    }

    /// SPI_MEM_SRAM_DRD_CMD Register bits
    namespace spi_mem_sram_drd_cmd_bits {
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE = (16 << 0);  ///< For SPI0,When cache mode is enable it is the read command value of command phase for sram.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN = (4 << 28);  ///< For SPI0,When cache mode is enable it is the length in bits of command phase for sram. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_DWR_CMD Register bits
    namespace spi_mem_sram_dwr_cmd_bits {
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE = (16 << 0);  ///< For SPI0,When cache mode is enable it is the write command value of command phase for sram.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN = (4 << 28);  ///< For SPI0,When cache mode is enable it is the in bits of command phase for sram. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_CLK Register bits
    namespace spi_mem_sram_clk_bits {
        constexpr uint32_t SPI_MEM_SCLKCNT_L = (8 << 0);  ///< For SPI0 external RAM interface, it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t SPI_MEM_SCLKCNT_H = (8 << 8);  ///< For SPI0 external RAM interface, it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t SPI_MEM_SCLKCNT_N = (8 << 16);  ///< For SPI0 external RAM interface, it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t SPI_MEM_SCLK_EQU_SYSCLK = (1U << 31);  ///< For SPI0 external RAM interface, 1: spi_mem_clk is eqaul to system 0: spi_mem_clk is divided from system clock.
    }

    /// SPI_MEM_FSM Register bits
    namespace spi_mem_fsm_bits {
        constexpr uint32_t SPI_MEM_LOCK_DELAY_TIME = (5 << 7);  ///< The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
    }

    /// SPI_MEM_INT_ENA Register bits
    namespace spi_mem_int_ena_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_ENA = (1U << 3);  ///< The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_ENA = (1U << 4);  ///< The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_ENA = (1U << 5);  ///< The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_ENA = (1U << 6);  ///< The enable bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_ENA = (1U << 7);  ///< The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA = (1U << 8);  ///< The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT__ENA = (1U << 9);  ///< The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
    }

    /// SPI_MEM_INT_CLR Register bits
    namespace spi_mem_int_clr_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_CLR = (1U << 3);  ///< The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_CLR = (1U << 4);  ///< The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_CLR = (1U << 5);  ///< The clear bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_CLR = (1U << 6);  ///< The clear bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_CLR = (1U << 7);  ///< The clear bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR = (1U << 8);  ///< The clear bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_CLR = (1U << 9);  ///< The clear bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
    }

    /// SPI_MEM_INT_RAW Register bits
    namespace spi_mem_int_raw_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_RAW = (1U << 3);  ///< The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi0_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_RAW = (1U << 4);  ///< The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi0_mst_st is changed from non idle state to idle state. 0: Others.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_RAW = (1U << 5);  ///< The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When SPI_FMEM_ECC_ERR_INT_EN is set and SPI_SMEM_ECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN is cleared and SPI_SMEM_ECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are cleared, this bit will not be triggered.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_RAW = (1U << 6);  ///< The raw bit for SPI_MEM_PMS_REJECT_INT interrupt. 1: Triggered when SPI1 access is rejected. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_RAW = (1U << 7);  ///< The raw bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt. 1: Triggered when AXI read address is invalid by compared to MMU configuration. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW = (1U << 8);  ///< The raw bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt. 1: Triggered when AXI write flash request is received. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_RAW = (1U << 9);  ///< The raw bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt. 1: Triggered when AXI write address is invalid by compared to MMU configuration. 0: Others.
    }

    /// SPI_MEM_INT_ST Register bits
    namespace spi_mem_int_st_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_ST = (1U << 3);  ///< The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_ST = (1U << 4);  ///< The status bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_ST = (1U << 5);  ///< The status bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_ST = (1U << 6);  ///< The status bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_ST = (1U << 7);  ///< The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_ST = (1U << 8);  ///< The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_ST = (1U << 9);  ///< The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
    }

    /// SPI_MEM_DDR Register bits
    namespace spi_mem_ddr_bits {
        constexpr uint32_t SPI_FMEM_DDR_EN = (1U << 0);  ///< 1: in DDR mode, 0 in SDR mode
        constexpr uint32_t SPI_FMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_RDAT_SWP = (1U << 2);  ///< Set the bit to reorder rx data of the word in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_WDAT_SWP = (1U << 3);  ///< Set the bit to reorder tx data of the word in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in command phase when DDR mode.
        constexpr uint32_t SPI_FMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the panda device.
        constexpr uint32_t SPI_FMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI clock.
        constexpr uint32_t SPI_FMEM_DDR_DQS_LOOP = (1U << 21);  ///< 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_FMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_FMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to flash. .
        constexpr uint32_t SPI_FMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_FMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// SPI_SMEM_DDR Register bits
    namespace spi_smem_ddr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< 1: in DDR mode, 0 in SDR mode
        constexpr uint32_t SPI_SMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in spi DDR mode.
        constexpr uint32_t RDAT_SWP = (1U << 2);  ///< Set the bit to reorder rx data of the word in spi DDR mode.
        constexpr uint32_t WDAT_SWP = (1U << 3);  ///< Set the bit to reorder tx data of the word in spi DDR mode.
        constexpr uint32_t CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in command phase when DDR mode.
        constexpr uint32_t SPI_SMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the DDR psram.
        constexpr uint32_t SPI_SMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI clock.
        constexpr uint32_t DQS_LOOP = (1U << 21);  ///< 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_SMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_SMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to external RAM. .
        constexpr uint32_t SPI_SMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_SMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// SPI_FMEM_PMS%s_ATTR Register bits
    namespace spi_fmem_pms%s_attr_bits {
        constexpr uint32_t SPI_FMEM_PMS_RD_ATTR = (1U << 0);  ///< 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
        constexpr uint32_t SPI_FMEM_PMS_WR_ATTR = (1U << 1);  ///< 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
        constexpr uint32_t SPI_FMEM_PMS_ECC = (1U << 2);  ///< SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
    }

    /// SPI_FMEM_PMS%s_ADDR Register bits
    namespace spi_fmem_pms%s_addr_bits {
        constexpr uint32_t S = (26 << 0);  ///< SPI1 flash ACE section %s start address value
    }

    /// SPI_FMEM_PMS%s_SIZE Register bits
    namespace spi_fmem_pms%s_size_bits {
        constexpr uint32_t SPI_FMEM_PMS_SIZE = (14 << 0);  ///< SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
    }

    /// SPI_SMEM_PMS%s_ATTR Register bits
    namespace spi_smem_pms%s_attr_bits {
        constexpr uint32_t SPI_SMEM_PMS_RD_ATTR = (1U << 0);  ///< 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
        constexpr uint32_t SPI_SMEM_PMS_WR_ATTR = (1U << 1);  ///< 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
        constexpr uint32_t SPI_SMEM_PMS_ECC = (1U << 2);  ///< SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
    }

    /// SPI_SMEM_PMS%s_ADDR Register bits
    namespace spi_smem_pms%s_addr_bits {
        constexpr uint32_t S = (26 << 0);  ///< SPI1 external RAM ACE section %s start address value
    }

    /// SPI_SMEM_PMS%s_SIZE Register bits
    namespace spi_smem_pms%s_size_bits {
        constexpr uint32_t SPI_SMEM_PMS_SIZE = (14 << 0);  ///< SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
    }

    /// SPI_MEM_PMS_REJECT Register bits
    namespace spi_mem_pms_reject_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (26 << 0);  ///< This bits show the first SPI1 access error address. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PM_EN = (1U << 26);  ///< Set this bit to enable SPI0/1 transfer permission control function.
        constexpr uint32_t SPI_MEM_PMS_LD = (1U << 28);  ///< 1: SPI1 write access error. 0: No write access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_ST = (1U << 29);  ///< 1: SPI1 read access error. 0: No read access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_MULTI_HIT = (1U << 30);  ///< 1: SPI1 access is rejected because of address miss. 0: No address miss error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_IVD = (1U << 31);  ///< 1: SPI1 access is rejected because of address multi-hit. 0: No address multi-hit error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
    }

    /// SPI_MEM_ECC_CTRL Register bits
    namespace spi_mem_ecc_ctrl_bits {
        constexpr uint32_t SPI_FMEM_ECC_ERR_INT_NUM = (6 << 11);  ///< Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_FMEM_ECC_ERR_INT_EN = (1U << 17);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
        constexpr uint32_t SPI_FMEM_PAGE_SIZE = (2 << 18);  ///< Set the page size of the flash accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        constexpr uint32_t SPI_FMEM_ECC_ADDR_EN = (1U << 20);  ///< Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of flash. If there is no ECC region in flash, this bit should be 0. Otherwise, this bit should be 1.
        constexpr uint32_t SPI_MEM_USR_ECC_ADDR_EN = (1U << 21);  ///< Set this bit to enable ECC address convert in SPI0/1 USR_CMD transfer.
        constexpr uint32_t SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN = (1U << 24);  ///< 1: The error information in SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR is updated when there is an ECC error. 0: SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR record the first ECC error information.
        constexpr uint32_t SPI_MEM_ECC_ERR_BITS = (7 << 25);  ///< Records the first ECC error bit number in the 16 bytes(From 0~127, corresponding to byte 0 bit 0 to byte 15 bit 7)
    }

    /// SPI_MEM_ECC_ERR_ADDR Register bits
    namespace spi_mem_ecc_err_addr_bits {
        constexpr uint32_t SPI_MEM_ECC_ERR_ADDR = (26 << 0);  ///< This bits show the first MSPI ECC error address. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_ECC_ERR_CNT = (6 << 26);  ///< This bits show the error times of MSPI ECC read. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
    }

    /// SPI_MEM_AXI_ERR_ADDR Register bits
    namespace spi_mem_axi_err_addr_bits {
        constexpr uint32_t SPI_MEM_AXI_ERR_ADDR = (26 << 0);  ///< This bits show the first AXI write/read invalid error or AXI write flash error address. It is cleared by when SPI_MEM_AXI_WADDR_ERR_INT_CLR, SPI_MEM_AXI_WR_FLASH_ERR_IN_CLR or SPI_MEM_AXI_RADDR_ERR_IN_CLR bit is set.
        constexpr uint32_t SPI_MEM_ALL_FIFO_EMPTY = (1U << 26);  ///< The empty status of all AFIFO and SYNC_FIFO in MSPI module. 1: All AXI transfers and SPI0 transfers are done. 0: Others.
        constexpr uint32_t SPI_RDATA_AFIFO_REMPTY = (1U << 27);  ///< 1: RDATA_AFIFO is empty. 0: At least one AXI read transfer is pending.
        constexpr uint32_t SPI_RADDR_AFIFO_REMPTY = (1U << 28);  ///< 1: AXI_RADDR_CTL_AFIFO is empty. 0: At least one AXI read transfer is pending.
        constexpr uint32_t SPI_WDATA_AFIFO_REMPTY = (1U << 29);  ///< 1: WDATA_AFIFO is empty. 0: At least one AXI write transfer is pending.
        constexpr uint32_t SPI_WBLEN_AFIFO_REMPTY = (1U << 30);  ///< 1: WBLEN_AFIFO is empty. 0: At least one AXI write transfer is pending.
        constexpr uint32_t SPI_ALL_AXI_TRANS_AFIFO_EMPTY = (1U << 31);  ///< This bit is set when WADDR_AFIFO, WBLEN_AFIFO, WDATA_AFIFO, AXI_RADDR_CTL_AFIFO and RDATA_AFIFO are empty and spi0_mst_st is IDLE.
    }

    /// SPI_SMEM_ECC_CTRL Register bits
    namespace spi_smem_ecc_ctrl_bits {
        constexpr uint32_t SPI_SMEM_ECC_ERR_INT_EN = (1U << 17);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_PAGE_SIZE = (2 << 18);  ///< Set the page size of the external RAM accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        constexpr uint32_t SPI_SMEM_ECC_ADDR_EN = (1U << 20);  ///< Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of external RAM. If there is no ECC region in external RAM, this bit should be 0. Otherwise, this bit should be 1.
    }

    /// SPI_MEM_TIMING_CALI Register bits
    namespace spi_mem_timing_cali_bits {
        constexpr uint32_t SPI_MEM_TIMING_CLK_ENA = (1U << 0);  ///< The bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t SPI_MEM_TIMING_CALI = (1U << 1);  ///< The bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t SPI_MEM_EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< add extra dummy spi clock cycle length for spi clock calibration.
        constexpr uint32_t SPI_MEM_DLL_TIMING_CALI = (1U << 5);  ///< Set this bit to enable DLL for timing calibration in DDR mode when accessed to flash.
        constexpr uint32_t UPDATE = (1U << 6);  ///< Set this bit to update delay mode, delay num and extra dummy in MSPI.
    }

    /// SPI_MEM_DIN_MODE Register bits
    namespace spi_mem_din_mode_bits {
        constexpr uint32_t SPI_MEM_DIN0_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN1_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN2_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN3_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN4_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN5_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN6_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN7_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DINS_MODE = (3 << 24);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
    }

    /// SPI_MEM_DIN_NUM Register bits
    namespace spi_mem_din_num_bits {
        constexpr uint32_t SPI_MEM_DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN4_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN5_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN6_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN7_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DINS_NUM = (2 << 16);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// SPI_MEM_DOUT_MODE Register bits
    namespace spi_mem_dout_mode_bits {
        constexpr uint32_t SPI_MEM_DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT4_MODE = (1U << 4);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT5_MODE = (1U << 5);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT6_MODE = (1U << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT7_MODE = (1U << 7);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUTS_MODE = (1U << 8);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
    }

    /// SPI_SMEM_TIMING_CALI Register bits
    namespace spi_smem_timing_cali_bits {
        constexpr uint32_t SPI_SMEM_TIMING_CLK_ENA = (1U << 0);  ///< For sram, the bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t SPI_SMEM_TIMING_CALI = (1U << 1);  ///< For sram, the bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t SPI_SMEM_EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< For sram, add extra dummy spi clock cycle length for spi clock calibration.
        constexpr uint32_t SPI_SMEM_DLL_TIMING_CALI = (1U << 5);  ///< Set this bit to enable DLL for timing calibration in DDR mode when accessed to EXT_RAM.
    }

    /// SPI_SMEM_DIN_MODE Register bits
    namespace spi_smem_din_mode_bits {
        constexpr uint32_t SPI_SMEM_DIN0_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN1_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN2_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN3_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN4_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN5_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN6_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN7_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DINS_MODE = (3 << 24);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// SPI_SMEM_DIN_NUM Register bits
    namespace spi_smem_din_num_bits {
        constexpr uint32_t SPI_SMEM_DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN4_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN5_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN6_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN7_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DINS_NUM = (2 << 16);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// SPI_SMEM_DOUT_MODE Register bits
    namespace spi_smem_dout_mode_bits {
        constexpr uint32_t SPI_SMEM_DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT4_MODE = (1U << 4);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT5_MODE = (1U << 5);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT6_MODE = (1U << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT7_MODE = (1U << 7);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUTS_MODE = (1U << 8);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
    }

    /// SPI_SMEM_AC Register bits
    namespace spi_smem_ac_bits {
        constexpr uint32_t SPI_SMEM_CS_SETUP = (1U << 0);  ///< For SPI0 and SPI1, spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t SPI_SMEM_CS_HOLD = (1U << 1);  ///< For SPI0 and SPI1, spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t SPI_SMEM_CS_SETUP_TIME = (5 << 2);  ///< For spi0, (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
        constexpr uint32_t SPI_SMEM_CS_HOLD_TIME = (5 << 7);  ///< For SPI0 and SPI1, spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
        constexpr uint32_t SPI_SMEM_ECC_CS_HOLD_TIME = (3 << 12);  ///< SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the SPI0 and SPI1 CS hold cycles in ECC mode when accessed external RAM.
        constexpr uint32_t SPI_SMEM_ECC_SKIP_PAGE_CORNER = (1U << 15);  ///< 1: SPI0 skips page corner when accesses external RAM. 0: Not skip page corner when accesses external RAM.
        constexpr uint32_t SPI_SMEM_ECC_16TO18_BYTE_EN = (1U << 16);  ///< Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses external RAM.
        constexpr uint32_t SPI_SMEM_CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SPI_SMEM_SPLIT_TRANS_EN = (1U << 31);  ///< Set this bit to enable SPI0 split one AXI accesses EXT_RAM transfer into two SPI transfers when one transfer will cross flash/EXT_RAM page corner, valid no matter whether there is an ECC region or not.
    }

    /// SPI_MEM_CLOCK_GATE Register bits
    namespace spi_mem_clock_gate_bits {
        constexpr uint32_t SPI_CLK_EN = (1U << 0);  ///< Register clock gate enable signal. 1: Enable. 0: Disable.
    }

    /// SPI_MEM_XTS_PLAIN_BASE Register bits
    namespace spi_mem_xts_plain_base_bits {
        constexpr uint32_t SPI_XTS_PLAIN = (32 << 0);  ///< This field is only used to generate include file in c case. This field is useless. Please do not use this field.
    }

    /// SPI_MEM_XTS_LINESIZE Register bits
    namespace spi_mem_xts_linesize_bits {
        constexpr uint32_t SPI_XTS_LINESIZE = (2 << 0);  ///< This bits stores the line-size parameter which will be used in manual encryption calculation. It decides how many bytes will be encrypted one time. 0: 16-bytes, 1: 32-bytes, 2: 64-bytes, 3:reserved.
    }

    /// SPI_MEM_XTS_DESTINATION Register bits
    namespace spi_mem_xts_destination_bits {
        constexpr uint32_t SPI_XTS_DESTINATION = (1U << 0);  ///< This bit stores the destination parameter which will be used in manual encryption calculation. 0: flash(default), 1: psram(reserved). Only default value can be used.
    }

    /// SPI_MEM_XTS_PHYSICAL_ADDRESS Register bits
    namespace spi_mem_xts_physical_address_bits {
        constexpr uint32_t SPI_XTS_PHYSICAL_ADDRESS = (26 << 0);  ///< This bits stores the physical-address parameter which will be used in manual encryption calculation. This value should aligned with byte number decided by line-size parameter.
    }

    /// SPI_MEM_XTS_TRIGGER Register bits
    namespace spi_mem_xts_trigger_bits {
        constexpr uint32_t SPI_XTS_TRIGGER = (1U << 0);  ///< Set this bit to trigger the process of manual encryption calculation. This action should only be asserted when manual encryption status is 0. After this action, manual encryption status becomes 1. After calculation is done, manual encryption status becomes 2.
    }

    /// SPI_MEM_XTS_RELEASE Register bits
    namespace spi_mem_xts_release_bits {
        constexpr uint32_t SPI_XTS_RELEASE = (1U << 0);  ///< Set this bit to release encrypted result to mspi. This action should only be asserted when manual encryption status is 2. After this action, manual encryption status will become 3.
    }

    /// SPI_MEM_XTS_DESTROY Register bits
    namespace spi_mem_xts_destroy_bits {
        constexpr uint32_t SPI_XTS_DESTROY = (1U << 0);  ///< Set this bit to destroy encrypted result. This action should be asserted only when manual encryption status is 3. After this action, manual encryption status will become 0.
    }

    /// SPI_MEM_XTS_STATE Register bits
    namespace spi_mem_xts_state_bits {
        constexpr uint32_t SPI_XTS_STATE = (2 << 0);  ///< This bits stores the status of manual encryption. 0: idle, 1: busy of encryption calculation, 2: encryption calculation is done but the encrypted result is invisible to mspi, 3: the encrypted result is visible to mspi.
    }

    /// SPI_MEM_XTS_DATE Register bits
    namespace spi_mem_xts_date_bits {
        constexpr uint32_t SPI_XTS_DATE = (30 << 0);  ///< This bits stores the last modified-time of manual encryption feature.
    }

    /// SPI_MEM_MMU_ITEM_CONTENT Register bits
    namespace spi_mem_mmu_item_content_bits {
        constexpr uint32_t SPI_MMU_ITEM_CONTENT = (32 << 0);  ///< MSPI-MMU item content
    }

    /// SPI_MEM_MMU_ITEM_INDEX Register bits
    namespace spi_mem_mmu_item_index_bits {
        constexpr uint32_t SPI_MMU_ITEM_INDEX = (32 << 0);  ///< MSPI-MMU item index
    }

    /// SPI_MEM_MMU_POWER_CTRL Register bits
    namespace spi_mem_mmu_power_ctrl_bits {
        constexpr uint32_t SPI_MMU_MEM_FORCE_ON = (1U << 0);  ///< Set this bit to enable mmu-memory clock force on
        constexpr uint32_t SPI_MMU_MEM_FORCE_PD = (1U << 1);  ///< Set this bit to force mmu-memory powerdown
        constexpr uint32_t SPI_MMU_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force mmu-memory powerup, in this case, the power should also be controlled by rtc.
        constexpr uint32_t SPI_MMU_PAGE_SIZE = (2 << 3);  ///< 0: Max page size , 1: Max page size/2 , 2: Max page size/4, 3: Max page size/8
        constexpr uint32_t SPI_MEM_AUX_CTRL = (14 << 16);  ///< MMU PSRAM aux control register
        constexpr uint32_t SPI_MEM_RDN_ENA = (1U << 30);  ///< ECO register enable bit
        constexpr uint32_t SPI_MEM_RDN_RESULT = (1U << 31);  ///< MSPI module clock domain and AXI clock domain ECO register result register
    }

    /// SPI_MEM_DPA_CTRL Register bits
    namespace spi_mem_dpa_ctrl_bits {
        constexpr uint32_t SPI_CRYPT_SECURITY_LEVEL = (3 << 0);  ///< Set the security level of spi mem cryption. 0: Shut off cryption DPA funtion. 1-7: The bigger the number is, the more secure the cryption is. (Note that the performance of cryption will decrease together with this number increasing)
        constexpr uint32_t SPI_CRYPT_CALC_D_DPA_EN = (1U << 3);  ///< Only available when SPI_CRYPT_SECURITY_LEVEL is not 0. 1: Enable DPA in the calculation that using key 1 or key 2. 0: Enable DPA only in the calculation that using key 1.
        constexpr uint32_t SPI_CRYPT_DPA_SELECT_REGISTER = (1U << 4);  ///< 1: MSPI XTS DPA clock gate is controlled by SPI_CRYPT_CALC_D_DPA_EN and SPI_CRYPT_SECURITY_LEVEL. 0: Controlled by efuse bits.
    }

    /// SPI_MEM_REGISTERRND_ECO_HIGH Register bits
    namespace spi_mem_registerrnd_eco_high_bits {
        constexpr uint32_t SPI_MEM_REGISTERRND_ECO_HIGH = (32 << 0);  ///< ECO high register
    }

    /// SPI_MEM_REGISTERRND_ECO_LOW Register bits
    namespace spi_mem_registerrnd_eco_low_bits {
        constexpr uint32_t SPI_MEM_REGISTERRND_ECO_LOW = (32 << 0);  ///< ECO low register
    }

    /// SPI_MEM_DATE Register bits
    namespace spi_mem_date_bits {
        constexpr uint32_t SPI_MEM_DATE = (28 << 0);  ///< SPI0 register version.
    }

}

// ============================================================================
// TEE Peripheral
// ============================================================================

namespace tee {
    /// Base addresses
    constexpr uint32_t TEE_BASE = 0x60098000;

    /// TEE Register structure
    struct Registers {
        volatile uint32_t M0_MODE_CTRL;  ///< Offset: 0x00 - Tee mode control register
        volatile uint32_t M1_MODE_CTRL;  ///< Offset: 0x04 - Tee mode control register
        volatile uint32_t M2_MODE_CTRL;  ///< Offset: 0x08 - Tee mode control register
        volatile uint32_t M3_MODE_CTRL;  ///< Offset: 0x0C - Tee mode control register
        volatile uint32_t M4_MODE_CTRL;  ///< Offset: 0x10 - Tee mode control register
        volatile uint32_t M5_MODE_CTRL;  ///< Offset: 0x14 - Tee mode control register
        volatile uint32_t M6_MODE_CTRL;  ///< Offset: 0x18 - Tee mode control register
        volatile uint32_t M7_MODE_CTRL;  ///< Offset: 0x1C - Tee mode control register
        volatile uint32_t M8_MODE_CTRL;  ///< Offset: 0x20 - Tee mode control register
        volatile uint32_t M9_MODE_CTRL;  ///< Offset: 0x24 - Tee mode control register
        volatile uint32_t M10_MODE_CTRL;  ///< Offset: 0x28 - Tee mode control register
        volatile uint32_t M11_MODE_CTRL;  ///< Offset: 0x2C - Tee mode control register
        volatile uint32_t M12_MODE_CTRL;  ///< Offset: 0x30 - Tee mode control register
        volatile uint32_t M13_MODE_CTRL;  ///< Offset: 0x34 - Tee mode control register
        volatile uint32_t M14_MODE_CTRL;  ///< Offset: 0x38 - Tee mode control register
        volatile uint32_t M15_MODE_CTRL;  ///< Offset: 0x3C - Tee mode control register
        volatile uint32_t M16_MODE_CTRL;  ///< Offset: 0x40 - Tee mode control register
        volatile uint32_t M17_MODE_CTRL;  ///< Offset: 0x44 - Tee mode control register
        volatile uint32_t M18_MODE_CTRL;  ///< Offset: 0x48 - Tee mode control register
        volatile uint32_t M19_MODE_CTRL;  ///< Offset: 0x4C - Tee mode control register
        volatile uint32_t M20_MODE_CTRL;  ///< Offset: 0x50 - Tee mode control register
        volatile uint32_t M21_MODE_CTRL;  ///< Offset: 0x54 - Tee mode control register
        volatile uint32_t M22_MODE_CTRL;  ///< Offset: 0x58 - Tee mode control register
        volatile uint32_t M23_MODE_CTRL;  ///< Offset: 0x5C - Tee mode control register
        volatile uint32_t M24_MODE_CTRL;  ///< Offset: 0x60 - Tee mode control register
        volatile uint32_t M25_MODE_CTRL;  ///< Offset: 0x64 - Tee mode control register
        volatile uint32_t M26_MODE_CTRL;  ///< Offset: 0x68 - Tee mode control register
        volatile uint32_t M27_MODE_CTRL;  ///< Offset: 0x6C - Tee mode control register
        volatile uint32_t M28_MODE_CTRL;  ///< Offset: 0x70 - Tee mode control register
        volatile uint32_t M29_MODE_CTRL;  ///< Offset: 0x74 - Tee mode control register
        volatile uint32_t M30_MODE_CTRL;  ///< Offset: 0x78 - Tee mode control register
        volatile uint32_t M31_MODE_CTRL;  ///< Offset: 0x7C - Tee mode control register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x80 - Clock gating register
        volatile uint32_t DATE;  ///< Offset: 0xFFC - Version register
    };

    /// Peripheral instances
    inline Registers* TEE = reinterpret_cast<Registers*>(TEE_BASE);

    // Bit definitions
    /// M0_MODE_CTRL Register bits
    namespace m0_mode_ctrl_bits {
        constexpr uint32_t M0_MODE = (2 << 0);  ///< M0 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M1_MODE_CTRL Register bits
    namespace m1_mode_ctrl_bits {
        constexpr uint32_t M1_MODE = (2 << 0);  ///< M1 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M2_MODE_CTRL Register bits
    namespace m2_mode_ctrl_bits {
        constexpr uint32_t M2_MODE = (2 << 0);  ///< M2 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M3_MODE_CTRL Register bits
    namespace m3_mode_ctrl_bits {
        constexpr uint32_t M3_MODE = (2 << 0);  ///< M3 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M4_MODE_CTRL Register bits
    namespace m4_mode_ctrl_bits {
        constexpr uint32_t M4_MODE = (2 << 0);  ///< M4 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M5_MODE_CTRL Register bits
    namespace m5_mode_ctrl_bits {
        constexpr uint32_t M5_MODE = (2 << 0);  ///< M5 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M6_MODE_CTRL Register bits
    namespace m6_mode_ctrl_bits {
        constexpr uint32_t M6_MODE = (2 << 0);  ///< M6 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M7_MODE_CTRL Register bits
    namespace m7_mode_ctrl_bits {
        constexpr uint32_t M7_MODE = (2 << 0);  ///< M7 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M8_MODE_CTRL Register bits
    namespace m8_mode_ctrl_bits {
        constexpr uint32_t M8_MODE = (2 << 0);  ///< M8 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M9_MODE_CTRL Register bits
    namespace m9_mode_ctrl_bits {
        constexpr uint32_t M9_MODE = (2 << 0);  ///< M9 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M10_MODE_CTRL Register bits
    namespace m10_mode_ctrl_bits {
        constexpr uint32_t M10_MODE = (2 << 0);  ///< M10 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M11_MODE_CTRL Register bits
    namespace m11_mode_ctrl_bits {
        constexpr uint32_t M11_MODE = (2 << 0);  ///< M11 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M12_MODE_CTRL Register bits
    namespace m12_mode_ctrl_bits {
        constexpr uint32_t M12_MODE = (2 << 0);  ///< M12 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M13_MODE_CTRL Register bits
    namespace m13_mode_ctrl_bits {
        constexpr uint32_t M13_MODE = (2 << 0);  ///< M13 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M14_MODE_CTRL Register bits
    namespace m14_mode_ctrl_bits {
        constexpr uint32_t M14_MODE = (2 << 0);  ///< M14 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M15_MODE_CTRL Register bits
    namespace m15_mode_ctrl_bits {
        constexpr uint32_t M15_MODE = (2 << 0);  ///< M15 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M16_MODE_CTRL Register bits
    namespace m16_mode_ctrl_bits {
        constexpr uint32_t M16_MODE = (2 << 0);  ///< M16 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M17_MODE_CTRL Register bits
    namespace m17_mode_ctrl_bits {
        constexpr uint32_t M17_MODE = (2 << 0);  ///< M17 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M18_MODE_CTRL Register bits
    namespace m18_mode_ctrl_bits {
        constexpr uint32_t M18_MODE = (2 << 0);  ///< M18 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M19_MODE_CTRL Register bits
    namespace m19_mode_ctrl_bits {
        constexpr uint32_t M19_MODE = (2 << 0);  ///< M19 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M20_MODE_CTRL Register bits
    namespace m20_mode_ctrl_bits {
        constexpr uint32_t M20_MODE = (2 << 0);  ///< M20 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M21_MODE_CTRL Register bits
    namespace m21_mode_ctrl_bits {
        constexpr uint32_t M21_MODE = (2 << 0);  ///< M21 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M22_MODE_CTRL Register bits
    namespace m22_mode_ctrl_bits {
        constexpr uint32_t M22_MODE = (2 << 0);  ///< M22 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M23_MODE_CTRL Register bits
    namespace m23_mode_ctrl_bits {
        constexpr uint32_t M23_MODE = (2 << 0);  ///< M23 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M24_MODE_CTRL Register bits
    namespace m24_mode_ctrl_bits {
        constexpr uint32_t M24_MODE = (2 << 0);  ///< M24 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M25_MODE_CTRL Register bits
    namespace m25_mode_ctrl_bits {
        constexpr uint32_t M25_MODE = (2 << 0);  ///< M25 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M26_MODE_CTRL Register bits
    namespace m26_mode_ctrl_bits {
        constexpr uint32_t M26_MODE = (2 << 0);  ///< M26 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M27_MODE_CTRL Register bits
    namespace m27_mode_ctrl_bits {
        constexpr uint32_t M27_MODE = (2 << 0);  ///< M27 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M28_MODE_CTRL Register bits
    namespace m28_mode_ctrl_bits {
        constexpr uint32_t M28_MODE = (2 << 0);  ///< M28 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M29_MODE_CTRL Register bits
    namespace m29_mode_ctrl_bits {
        constexpr uint32_t M29_MODE = (2 << 0);  ///< M29 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M30_MODE_CTRL Register bits
    namespace m30_mode_ctrl_bits {
        constexpr uint32_t M30_MODE = (2 << 0);  ///< M30 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// M31_MODE_CTRL Register bits
    namespace m31_mode_ctrl_bits {
        constexpr uint32_t M31_MODE = (2 << 0);  ///< M31 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< reg_clk_en
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< reg_tee_date
    }

}

// ============================================================================
// TRACE Peripheral
// ============================================================================

namespace trace {
    /// Base addresses
    constexpr uint32_t TRACE_BASE = 0x600C0000;

    /// TRACE Register structure
    struct Registers {
        volatile uint32_t MEM_START_ADDR;  ///< Offset: 0x00 - mem start addr
        volatile uint32_t MEM_END_ADDR;  ///< Offset: 0x04 - mem end addr
        volatile uint32_t MEM_CURRENT_ADDR;  ///< Offset: 0x08 - mem current addr
        volatile uint32_t MEM_ADDR_UPDATE;  ///< Offset: 0x0C - mem addr update
        volatile uint32_t FIFO_STATUS;  ///< Offset: 0x10 - fifo status register
        volatile uint32_t INTR_ENA;  ///< Offset: 0x14 - interrupt enable register
        volatile uint32_t INTR_RAW;  ///< Offset: 0x18 - interrupt status register
        volatile uint32_t INTR_CLR;  ///< Offset: 0x1C - interrupt clear register
        volatile uint32_t TRIGGER;  ///< Offset: 0x20 - trigger register
        volatile uint32_t RESYNC_PROLONGED;  ///< Offset: 0x24 - resync configuration register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x28 - Clock gate control register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* TRACE = reinterpret_cast<Registers*>(TRACE_BASE);

    // Bit definitions
    /// MEM_START_ADDR Register bits
    namespace mem_start_addr_bits {
        constexpr uint32_t MEM_STAET_ADDR = (32 << 0);  ///< The start address of trace memory
    }

    /// MEM_END_ADDR Register bits
    namespace mem_end_addr_bits {
        constexpr uint32_t MEM_END_ADDR = (32 << 0);  ///< The end address of trace memory
    }

    /// MEM_CURRENT_ADDR Register bits
    namespace mem_current_addr_bits {
        constexpr uint32_t MEM_CURRENT_ADDR = (32 << 0);  ///< current_mem_addr,indicate that next writing addr
    }

    /// MEM_ADDR_UPDATE Register bits
    namespace mem_addr_update_bits {
        constexpr uint32_t MEM_CURRENT_ADDR_UPDATE = (1U << 0);  ///< when set this reg, the current_mem_addr will update to start_addr
    }

    /// FIFO_STATUS Register bits
    namespace fifo_status_bits {
        constexpr uint32_t FIFO_EMPTY = (1U << 0);  ///< 1 indicate that fifo is empty
        constexpr uint32_t WORK_STATUS = (1U << 1);  ///< mem_full interrupt status
    }

    /// INTR_ENA Register bits
    namespace intr_ena_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_ENA = (1U << 0);  ///< Set 1 enable fifo_overflow interrupt
        constexpr uint32_t MEM_FULL_INTR_ENA = (1U << 1);  ///< Set 1 enable mem_full interrupt
    }

    /// INTR_RAW Register bits
    namespace intr_raw_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_RAW = (1U << 0);  ///< fifo_overflow interrupt status
        constexpr uint32_t MEM_FULL_INTR_RAW = (1U << 1);  ///< mem_full interrupt status
    }

    /// INTR_CLR Register bits
    namespace intr_clr_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_CLR = (1U << 0);  ///< Set 1 clr fifo overflow interrupt
        constexpr uint32_t MEM_FULL_INTR_CLR = (1U << 1);  ///< Set 1 clr mem full interrupt
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t ON = (1U << 0);  ///< [0] set 1 start trace.
        constexpr uint32_t OFF = (1U << 1);  ///< set 1 stop trace.
        constexpr uint32_t MEM_LOOP = (1U << 2);  ///< if this reg is 1, trace will loop wrtie trace_mem. If is 0, when mem_current_addr at mem_end_addr, it will stop at the mem_end_addr
        constexpr uint32_t RESTART_ENA = (1U << 3);  ///< enable encoder auto-restart, when lost package, the encoder will end, if enable auto-restart, when fifo empty, encoder will restart and send a sync package.
    }

    /// RESYNC_PROLONGED Register bits
    namespace resync_prolonged_bits {
        constexpr uint32_t RESYNC_PROLONGED = (24 << 0);  ///< count number, when count to this value, send a sync package
        constexpr uint32_t RESYNC_MODE = (1U << 24);  ///< resyc mode sel: 0: default, cycle count 1: package num count
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< The bit is used to enable clock gate when access all registers in this module.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version control register. Note that this default value stored is the latest date when the hardware logic was updated.
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x6000C000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - TWAI mode register.
        volatile uint32_t CMD;  ///< Offset: 0x04 - TWAI command register.
        volatile uint32_t STATUS;  ///< Offset: 0x08 - TWAI status register.
        volatile uint32_t INTERRUPT;  ///< Offset: 0x0C - Interrupt signals' register.
        volatile uint32_t INTERRUPT_ENABLE;  ///< Offset: 0x10 - Interrupt enable register.
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bit timing configuration register 0.
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bit timing configuration register 1.
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - TWAI arbiter lost capture register.
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - TWAI error info capture register.
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - TWAI error threshold configuration register.
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Rx error counter register.
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Tx error counter register.
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0.
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1.
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2.
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3.
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4.
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5.
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6.
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7.
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8.
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9.
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10.
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11.
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12.
        volatile uint32_t RX_MESSAGE_COUNTER;  ///< Offset: 0x74 - Received message counter register.
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock divider register.
        volatile uint32_t SW_STANDBY_CFG;  ///< Offset: 0x80 - Software configure standby pin directly.
        volatile uint32_t HW_CFG;  ///< Offset: 0x84 - Hardware configure standby pin.
        volatile uint32_t HW_STANDBY_CNT;  ///< Offset: 0x88 - Configure standby counter.
        volatile uint32_t IDLE_INTR_CNT;  ///< Offset: 0x8C - Configure idle interrupt counter.
        volatile uint32_t ECO_CFG;  ///< Offset: 0x90 - ECO configuration register.
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< 1: reset, detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode. 0: normal, on the '1-to-0' transition of the reset mode bit, the TWAI controller returns to the operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: listen only, in this mode the TWAI controller would give no acknowledge to the TWAI-bus, even if a message is received successfully. The error counters are stopped at the current value. 0: normal.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: self test, in this mode a full node test is possible without any other active node on the bus using the self reception request command. The TWAI controller will perform a successful transmission, even if there is no acknowledge received. 0: normal, an acknowledge is required for successful transmission.
        constexpr uint32_t ACCEPTANCE_FILTER_MODE = (1U << 3);  ///< 1:single, the single acceptance filter option is enabled (one filter with the length of 32 bit is active). 0:dual, the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active).
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQUEST = (1U << 0);  ///< 1: present, a message shall be transmitted. 0: absent
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< 1: present, if not already in progress, a pending transmission request is cancelled. 0: absent
        constexpr uint32_t RELEASE_BUFFER = (1U << 2);  ///< 1: released, the receive buffer, representing the message memory space in the RXFIFO is released. 0: no action
        constexpr uint32_t CLEAR_DATA_OVERRUN = (1U << 3);  ///< 1: clear, the data overrun status bit is cleared. 0: no action.
        constexpr uint32_t SELF_RX_REQUEST = (1U << 4);  ///< 1: present, a message shall be transmitted and received simultaneously. 0: absent.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RECEIVE_BUFFER = (1U << 0);  ///< 1: full, one or more complete messages are available in the RXFIFO. 0: empty, no message is available
        constexpr uint32_t OVERRUN = (1U << 1);  ///< 1: overrun, a message was lost because there was not enough space for that message in the RXFIFO. 0: absent, no data overrun has occurred since the last clear data overrun command was given
        constexpr uint32_t TRANSMIT_BUFFER = (1U << 2);  ///< 1: released, the CPU may write a message into the transmit buffer. 0: locked, the CPU cannot access the transmit buffer, a message is either waiting for transmission or is in the process of being transmitted
        constexpr uint32_t TRANSMISSION_COMPLETE = (1U << 3);  ///< 1: complete, last requested transmission has been successfully completed. 0: incomplete, previously requested transmission is not yet completed
        constexpr uint32_t RECEIVE = (1U << 4);  ///< 1: receive, the TWAI controller is receiving a message. 0: idle
        constexpr uint32_t TRANSMIT = (1U << 5);  ///< 1: transmit, the TWAI controller is transmitting a message. 0: idle
        constexpr uint32_t ERR = (1U << 6);  ///< 1: error, at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR). 0: ok, both error counters are below the warning limit
        constexpr uint32_t NODE_BUS_OFF = (1U << 7);  ///< 1: bus-off, the TWAI controller is not involved in bus activities. 0: bus-on, the TWAI controller is involved in bus activities
        constexpr uint32_t MISS = (1U << 8);  ///< 1: current message is destroyed because of FIFO overflow.
    }

    /// INTERRUPT Register bits
    namespace interrupt_bits {
        constexpr uint32_t RECEIVE_INT_ST = (1U << 0);  ///< 1: this bit is set while the receive FIFO is not empty and the RIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t TRANSMIT_INT_ST = (1U << 1);  ///< 1: this bit is set whenever the transmit buffer status changes from '0-to-1' (released) and the TIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t ERR_WARNING_INT_ST = (1U << 2);  ///< 1: this bit is set on every change (set and clear) of either the error status or bus status bits and the EIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t DATA_OVERRUN_INT_ST = (1U << 3);  ///< 1: this bit is set on a '0-to-1' transition of the data overrun status bit and the DOIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< 1: this bit is set whenever the TWAI controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the TWAI controller is in the error passive status and enters the error active status again and the EPIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 6);  ///< 1: this bit is set when the TWAI controller lost the arbitration and becomes a receiver and the ALIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< 1: this bit is set when the TWAI controller detects an error on the TWAI-bus and the BEIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t IDLE_INT_ST = (1U << 8);  ///< 1: this bit is set when the TWAI controller detects state of TWAI become IDLE and this interrupt enable bit is set within the interrupt enable register. 0: reset
    }

    /// INTERRUPT_ENABLE Register bits
    namespace interrupt_enable_bits {
        constexpr uint32_t EXT_RECEIVE_INT_ENA = (1U << 0);  ///< 1: enabled, when the receive buffer status is 'full' the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t EXT_TRANSMIT_INT_ENA = (1U << 1);  ///< 1: enabled, when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t EXT_ERR_WARNING_INT_ENA = (1U << 2);  ///< 1: enabled, if the error or bus status change (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
        constexpr uint32_t EXT_DATA_OVERRUN_INT_ENA = (1U << 3);  ///< 1: enabled, if the data overrun status bit is set (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< 1: enabled, if the error status of the TWAI controller changes from error active to error passive or vice versa, the respective interrupt is requested. 0: disable
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 6);  ///< 1: enabled, if the TWAI controller has lost arbitration, the respective interrupt is requested. 0: disable
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< 1: enabled, if an bus error has been detected, the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t IDLE_INT_ENA = (1U << 8);  ///< 1: enabled, if state of TWAI become IDLE, the TWAI controller requests the respective interrupt. 0: disable
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (14 << 0);  ///< The period of the TWAI system clock is programmable and determines the individual bit timing. Software has R/W permission in reset mode and RO permission in operation mode.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 14);  ///< The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEGMENT1 = (4 << 0);  ///< The number of clock cycles in TSEG1 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
        constexpr uint32_t TIME_SEGMENT2 = (3 << 4);  ///< The number of clock cycles in TSEG2 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
        constexpr uint32_t TIME_SAMPLING = (1U << 7);  ///< 1: triple, the bus is sampled three times. 0: single, the bus is sampled once. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARBITRATION_LOST_CAPTURE = (5 << 0);  ///< This register contains information about the bit position of losing arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ERR_CAPTURE_CODE_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors on the bus.
        constexpr uint32_t ERR_CAPTURE_CODE_DIRECTION = (1U << 5);  ///< 1: RX, error occurred during reception. 0: TX, error occurred during transmission.
        constexpr uint32_t ERR_CAPTURE_CODE_TYPE = (2 << 6);  ///< 00: bit error. 01: form error. 10:stuff error. 11:other type of error.
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< The threshold that trigger error warning interrupt when this interrupt is enabled. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t DATA_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 0 and when software initiate read operation, it is rx data register 0.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t DATA_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 1 and when software initiate read operation, it is rx data register 1.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t DATA_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 2 and when software initiate read operation, it is rx data register 2.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t DATA_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 3 and when software initiate read operation, it is rx data register 3.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t DATA_4 = (8 << 0);  ///< In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 4 and when software initiate read operation, it is rx data register 4.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t DATA_5 = (8 << 0);  ///< In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 5 and when software initiate read operation, it is rx data register 5.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t DATA_6 = (8 << 0);  ///< In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 6 and when software initiate read operation, it is rx data register 6.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t DATA_7 = (8 << 0);  ///< In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 7 and when software initiate read operation, it is rx data register 7.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t DATA_8 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 8 and when software initiate read operation, it is rx data register 8.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t DATA_9 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 9 and when software initiate read operation, it is rx data register 9.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t DATA_10 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 10 and when software initiate read operation, it is rx data register 10.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t DATA_11 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 11 and when software initiate read operation, it is rx data register 11.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t DATA_12 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 12 and when software initiate read operation, it is rx data register 12.
    }

    /// RX_MESSAGE_COUNTER Register bits
    namespace rx_message_counter_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to define the frequency at the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< 1: Disable the external CLKOUT pin. 0: Enable the external CLKOUT pin. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// SW_STANDBY_CFG Register bits
    namespace sw_standby_cfg_bits {
        constexpr uint32_t SW_STANDBY_EN = (1U << 0);  ///< Enable standby pin.
        constexpr uint32_t SW_STANDBY_CLR = (1U << 1);  ///< Clear standby pin.
    }

    /// HW_CFG Register bits
    namespace hw_cfg_bits {
        constexpr uint32_t HW_STANDBY_EN = (1U << 0);  ///< Enable function that hardware control standby pin.
    }

    /// HW_STANDBY_CNT Register bits
    namespace hw_standby_cnt_bits {
        constexpr uint32_t STANDBY_WAIT_CNT = (32 << 0);  ///< Configure the number of cycles before standby becomes high when TWAI_HW_STANDBY_EN is enabled.
    }

    /// IDLE_INTR_CNT Register bits
    namespace idle_intr_cnt_bits {
        constexpr uint32_t IDLE_INTR_CNT = (32 << 0);  ///< Configure the number of cycles before triggering idle interrupt.
    }

    /// ECO_CFG Register bits
    namespace eco_cfg_bits {
        constexpr uint32_t RDN_ENA = (1U << 0);  ///< Enable eco module.
        constexpr uint32_t RDN_RESULT = (1U << 1);  ///< Output of eco module.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x60000000;
    constexpr uint32_t UART1_BASE = 0x60001000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0;  ///< Offset: 0x20 - a
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t HWFC_CONF;  ///< Offset: 0x2C - Hardware flow-control configuration
        volatile uint32_t SLEEP_CONF0;  ///< Offset: 0x30 - UART sleep configure register 0
        volatile uint32_t SLEEP_CONF1;  ///< Offset: 0x34 - UART sleep configure register 1
        volatile uint32_t SLEEP_CONF2;  ///< Offset: 0x38 - UART sleep configure register 2
        volatile uint32_t SWFC_CONF0;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART memory power configuration
        volatile uint32_t TOUT_CONF;  ///< Offset: 0x64 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x68 - Tx-SRAM write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x6C - Rx-SRAM write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x70 - UART transmit and receive status.
        volatile uint32_t POSPULSE;  ///< Offset: 0x74 - Autobaud high pulse register
        volatile uint32_t NEGPULSE;  ///< Offset: 0x78 - Autobaud low pulse register
        volatile uint32_t LOWPULSE;  ///< Offset: 0x7C - Autobaud minimum low pulse duration register
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x80 - Autobaud minimum high pulse duration register
        volatile uint32_t RXD_CNT;  ///< Offset: 0x84 - Autobaud edge change count register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x88 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x8C - UART Version register
        volatile uint32_t AFIFO_STATUS;  ///< Offset: 0x90 - UART AFIFO Status
        volatile uint32_t REG_UPDATE;  ///< Offset: 0x98 - UART Registers Configuration Update register
        volatile uint32_t ID;  ///< Offset: 0x9C - UART ID register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for rs485_clash_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear the rs485_parity_err_int_raw interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear the rs485_frm_err_int_raw interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear the rs485_clash_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (8 << 0);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (8 << 16);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t TXD_BRK = (1U << 6);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 7);  ///< Set this bit to enable IrDA loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 8);  ///< This is the start enable bit for IrDA transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 9);  ///< 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 10);  ///< Set this bit to invert the level of IrDA transmitter.
        constexpr uint32_t IRDA_RX_INV = (1U << 11);  ///< Set this bit to invert the level of IrDA receiver.
        constexpr uint32_t LOOPBACK = (1U << 12);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 13);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t IRDA_EN = (1U << 14);  ///< Set this bit to enable IrDA protocol.
        constexpr uint32_t RXD_INV = (1U << 15);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t TXD_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 17);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t ERR_WR_MASK = (1U << 18);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t AUTOBAUD_EN = (1U << 19);  ///< This is the enable bit for detecting baudrate.
        constexpr uint32_t MEM_CLK_EN = (1U << 20);  ///< UART memory clock gate enable signal.
        constexpr uint32_t SW_RTS = (1U << 21);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t RXFIFO_RST = (1U << 22);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 23);  ///< Set this bit to reset the uart transmit-FIFO.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (8 << 0);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (8 << 8);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t CTS_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 17);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t RTS_INV = (1U << 18);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t SW_DTR = (1U << 20);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t CLK_EN = (1U << 21);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// HWFC_CONF Register bits
    namespace hwfc_conf_bits {
        constexpr uint32_t RX_FLOW_THRHD = (8 << 0);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 8);  ///< This is the flow enable bit for UART receiver.
    }

    /// SLEEP_CONF0 Register bits
    namespace sleep_conf0_bits {
        constexpr uint32_t WK_CHAR1 = (8 << 0);  ///< This register restores the specified wake up char1 to wake up
        constexpr uint32_t WK_CHAR2 = (8 << 8);  ///< This register restores the specified wake up char2 to wake up
        constexpr uint32_t WK_CHAR3 = (8 << 16);  ///< This register restores the specified wake up char3 to wake up
        constexpr uint32_t WK_CHAR4 = (8 << 24);  ///< This register restores the specified wake up char4 to wake up
    }

    /// SLEEP_CONF1 Register bits
    namespace sleep_conf1_bits {
        constexpr uint32_t WK_CHAR0 = (8 << 0);  ///< This register restores the specified char0 to wake up
    }

    /// SLEEP_CONF2 Register bits
    namespace sleep_conf2_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
        constexpr uint32_t RX_WAKE_UP_THRHD = (8 << 10);  ///< In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
        constexpr uint32_t WK_CHAR_NUM = (3 << 18);  ///< This register is used to select number of wake up char.
        constexpr uint32_t WK_CHAR_MASK = (5 << 21);  ///< This register is used to mask wake up char.
        constexpr uint32_t WK_MODE_SEL = (2 << 26);  ///< This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
    }

    /// SWFC_CONF0 Register bits
    namespace swfc_conf0_bits {
        constexpr uint32_t XON_CHAR = (8 << 0);  ///< This register stores the Xon flow control char.
        constexpr uint32_t XOFF_CHAR = (8 << 8);  ///< This register stores the Xoff flow control char.
        constexpr uint32_t XON_XOFF_STILL_SEND = (1U << 16);  ///< In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 17);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 18);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 19);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 20);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 21);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 22);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (8 << 0);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1 it will send a Xon char.
        constexpr uint32_t XOFF_THRESHOLD = (8 << 8);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1 it will send a Xoff char.
    }

    /// TXBRK_CONF Register bits
    namespace txbrk_conf_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose the rs485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t MEM_FORCE_PD = (1U << 25);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 26);  ///< Set this bit to force power up UART memory.
    }

    /// TOUT_CONF Register bits
    namespace tout_conf_bits {
        constexpr uint32_t RX_TOUT_EN = (1U << 0);  ///< This is the enble bit for uart receiver's timeout function.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 1);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 2);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t TX_SRAM_WADDR = (8 << 0);  ///< This register stores the offset write address in Tx-SRAM.
        constexpr uint32_t TX_SRAM_RADDR = (8 << 9);  ///< This register stores the offset read address in Tx-SRAM.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t RX_SRAM_RADDR = (8 << 0);  ///< This register stores the offset read address in RX-SRAM.
        constexpr uint32_t RX_SRAM_WADDR = (8 << 9);  ///< This register stores the offset write address in Rx-SRAM.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of rxd edge change. It is used in baud rate-detect process.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit to reset UART Tx.
        constexpr uint32_t RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit to reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// AFIFO_STATUS Register bits
    namespace afifo_status_bits {
        constexpr uint32_t TX_AFIFO_FULL = (1U << 0);  ///< Full signal of APB TX AFIFO.
        constexpr uint32_t TX_AFIFO_EMPTY = (1U << 1);  ///< Empty signal of APB TX AFIFO.
        constexpr uint32_t RX_AFIFO_FULL = (1U << 2);  ///< Full signal of APB RX AFIFO.
        constexpr uint32_t RX_AFIFO_EMPTY = (1U << 3);  ///< Empty signal of APB RX AFIFO.
    }

    /// REG_UPDATE Register bits
    namespace reg_update_bits {
        constexpr uint32_t REG_UPDATE = (1U << 0);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< This register is used to configure the uart_id.
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x60006000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - a
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - a
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - a
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - a
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - a
        volatile uint32_t CONF1;  ///< Offset: 0x14 - a
        volatile uint32_t STATE0;  ///< Offset: 0x18 - a
        volatile uint32_t STATE1;  ///< Offset: 0x1C - a
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x20 - a
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x24 - a
        volatile uint32_t ACK_NUM;  ///< Offset: 0x28 - a
        volatile uint32_t RX_HEAD;  ///< Offset: 0x2C - a
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x30 - a
        volatile uint32_t REG_Q0_WORD0;  ///< Offset: 0x34 - a
        volatile uint32_t REG_Q0_WORD1;  ///< Offset: 0x38 - a
        volatile uint32_t REG_Q1_WORD0;  ///< Offset: 0x3C - a
        volatile uint32_t REG_Q1_WORD1;  ///< Offset: 0x40 - a
        volatile uint32_t REG_Q2_WORD0;  ///< Offset: 0x44 - a
        volatile uint32_t REG_Q2_WORD1;  ///< Offset: 0x48 - a
        volatile uint32_t REG_Q3_WORD0;  ///< Offset: 0x4C - a
        volatile uint32_t REG_Q3_WORD1;  ///< Offset: 0x50 - a
        volatile uint32_t REG_Q4_WORD0;  ///< Offset: 0x54 - a
        volatile uint32_t REG_Q4_WORD1;  ///< Offset: 0x58 - a
        volatile uint32_t REG_Q5_WORD0;  ///< Offset: 0x5C - a
        volatile uint32_t REG_Q5_WORD1;  ///< Offset: 0x60 - a
        volatile uint32_t REG_Q6_WORD0;  ///< Offset: 0x64 - a
        volatile uint32_t REG_Q6_WORD1;  ///< Offset: 0x68 - a
        volatile uint32_t ESC_CONF0;  ///< Offset: 0x6C - a
        volatile uint32_t ESC_CONF1;  ///< Offset: 0x70 - a
        volatile uint32_t ESC_CONF2;  ///< Offset: 0x74 - a
        volatile uint32_t ESC_CONF3;  ///< Offset: 0x78 - a
        volatile uint32_t PKT_THRES;  ///< Offset: 0x7C - a
        volatile uint32_t DATE;  ///< Offset: 0x80 - a
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t TX_RST = (1U << 0);  ///< Write 1 then write 0 to this bit to reset decode state machine.
        constexpr uint32_t RX_RST = (1U << 1);  ///< Write 1 then write 0 to this bit to reset encode state machine.
        constexpr uint32_t UART0_CE = (1U << 2);  ///< Set this bit to link up HCI and UART0.
        constexpr uint32_t UART1_CE = (1U << 3);  ///< Set this bit to link up HCI and UART1.
        constexpr uint32_t SEPER_EN = (1U << 5);  ///< Set this bit to separate the data frame using a special char.
        constexpr uint32_t HEAD_EN = (1U << 6);  ///< Set this bit to encode the data packet with a formatting header.
        constexpr uint32_t CRC_REC_EN = (1U << 7);  ///< Set this bit to enable UHCI to receive the 16 bit CRC.
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 8);  ///< If this bit is set to 1 UHCI will end the payload receiving process when UART has been in idle state.
        constexpr uint32_t LEN_EOF_EN = (1U << 9);  ///< If this bit is set to 1 UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0 UHCI decoder receiving payload data is end when 0xc0 is received.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 10);  ///< Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
        constexpr uint32_t CLK_EN = (1U << 11);  ///< 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 12);  ///< If this bit is set to 1 UHCI will end payload receive process when NULL frame is received by UART.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_RAW = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_RAW = (1U << 5);  ///< a
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 6);  ///< This is the interrupt raw bit. Triggered when there are some errors in EOF in the
        constexpr uint32_t APP_CTRL0_INT_RAW = (1U << 7);  ///< Soft control int raw bit.
        constexpr uint32_t APP_CTRL1_INT_RAW = (1U << 8);  ///< Soft control int raw bit.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_ST = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_ST = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_ST = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_ST = (1U << 8);  ///< a
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_ENA = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_ENA = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_ENA = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_ENA = (1U << 8);  ///< a
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< a
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< a
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< a
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< a
        constexpr uint32_t SEND_S_REG_Q_INT_CLR = (1U << 4);  ///< a
        constexpr uint32_t SEND_A_REG_Q_INT_CLR = (1U << 5);  ///< a
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 6);  ///< a
        constexpr uint32_t APP_CTRL0_INT_CLR = (1U << 7);  ///< a
        constexpr uint32_t APP_CTRL1_INT_CLR = (1U << 8);  ///< a
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< a
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< a
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< a
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< a
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< a
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< a
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< a
        constexpr uint32_t SW_START = (1U << 8);  ///< a
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t RX_ERR_CAUSE = (3 << 0);  ///< a
        constexpr uint32_t DECODE_STATE = (3 << 3);  ///< a
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t ENCODE_STATE = (3 << 0);  ///< a
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< a
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< a
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< a
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< a
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< a
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< a
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< a
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< a
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< a
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< a
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< a
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< a
    }

    /// ACK_NUM Register bits
    namespace ack_num_bits {
        constexpr uint32_t ACK_NUM = (3 << 0);  ///< a
        constexpr uint32_t LOAD = (1U << 3);  ///< a
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< a
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< a
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< a
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< a
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< a
    }

    /// REG_Q0_WORD0 Register bits
    namespace reg_q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q0_WORD1 Register bits
    namespace reg_q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q1_WORD0 Register bits
    namespace reg_q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q1_WORD1 Register bits
    namespace reg_q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q2_WORD0 Register bits
    namespace reg_q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q2_WORD1 Register bits
    namespace reg_q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q3_WORD0 Register bits
    namespace reg_q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q3_WORD1 Register bits
    namespace reg_q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q4_WORD0 Register bits
    namespace reg_q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q4_WORD1 Register bits
    namespace reg_q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q5_WORD0 Register bits
    namespace reg_q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q5_WORD1 Register bits
    namespace reg_q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< a
    }

    /// REG_Q6_WORD0 Register bits
    namespace reg_q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< a
    }

    /// REG_Q6_WORD1 Register bits
    namespace reg_q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< a
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< a
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< a
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< a
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< a
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< a
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< a
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< a
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_DEVICE_BASE = 0x6000F000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP1;  ///< Offset: 0x00 - FIFO access for the CDC-ACM data IN and OUT endpoints.
        volatile uint32_t EP1_CONF;  ///< Offset: 0x04 - Configuration and control registers for the CDC-ACM FIFOs.
        volatile uint32_t INT_RAW;  ///< Offset: 0x08 - Interrupt raw status register.
        volatile uint32_t INT_ST;  ///< Offset: 0x0C - Interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt enable status register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x14 - Interrupt clear status register.
        volatile uint32_t CONF0;  ///< Offset: 0x18 - PHY hardware configuration.
        volatile uint32_t TEST;  ///< Offset: 0x1C - Registers used for debugging the PHY.
        volatile uint32_t JFIFO_ST;  ///< Offset: 0x20 - JTAG FIFO status and control registers.
        volatile uint32_t FRAM_NUM;  ///< Offset: 0x24 - Last received SOF frame index register.
        volatile uint32_t IN_EP0_ST;  ///< Offset: 0x28 - Control IN endpoint status information.
        volatile uint32_t IN_EP1_ST;  ///< Offset: 0x2C - CDC-ACM IN endpoint status information.
        volatile uint32_t IN_EP2_ST;  ///< Offset: 0x30 - CDC-ACM interrupt IN endpoint status information.
        volatile uint32_t IN_EP3_ST;  ///< Offset: 0x34 - JTAG IN endpoint status information.
        volatile uint32_t OUT_EP0_ST;  ///< Offset: 0x38 - Control OUT endpoint status information.
        volatile uint32_t OUT_EP1_ST;  ///< Offset: 0x3C - CDC-ACM OUT endpoint status information.
        volatile uint32_t OUT_EP2_ST;  ///< Offset: 0x40 - JTAG OUT endpoint status information.
        volatile uint32_t MISC_CONF;  ///< Offset: 0x44 - Clock enable control
        volatile uint32_t MEM_CONF;  ///< Offset: 0x48 - Memory power control
        volatile uint32_t CHIP_RST;  ///< Offset: 0x4C - CDC-ACM chip reset control.
        volatile uint32_t SET_LINE_CODE_W0;  ///< Offset: 0x50 - W0 of SET_LINE_CODING command.
        volatile uint32_t SET_LINE_CODE_W1;  ///< Offset: 0x54 - W1 of SET_LINE_CODING command.
        volatile uint32_t GET_LINE_CODE_W0;  ///< Offset: 0x58 - W0 of GET_LINE_CODING command.
        volatile uint32_t GET_LINE_CODE_W1;  ///< Offset: 0x5C - W1 of GET_LINE_CODING command.
        volatile uint32_t CONFIG_UPDATE;  ///< Offset: 0x60 - Configuration registers' value update
        volatile uint32_t SER_AFIFO_CONFIG;  ///< Offset: 0x64 - Serial AFIFO configure register
        volatile uint32_t BUS_RESET_ST;  ///< Offset: 0x68 - USB Bus reset status register
        volatile uint32_t DATE;  ///< Offset: 0x80 - Date register
    };

    /// Peripheral instances
    inline Registers* USB_DEVICE = reinterpret_cast<Registers*>(USB_DEVICE_BASE);

    // Bit definitions
    /// EP1 Register bits
    namespace ep1_bits {
        constexpr uint32_t RDWR_BYTE = (8 << 0);  ///< Write and read byte data to/from UART Tx/Rx FIFO through this field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes) into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many data is received, then read data from UART Rx FIFO.
    }

    /// EP1_CONF Register bits
    namespace ep1_conf_bits {
        constexpr uint32_t WR_DONE = (1U << 0);  ///< Set this bit to indicate writing byte data to UART Tx FIFO is done.
        constexpr uint32_t SERIAL_IN_EP_DATA_FREE = (1U << 1);  ///< 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is read by USB Host.
        constexpr uint32_t SERIAL_OUT_EP_DATA_AVAIL = (1U << 2);  ///< 1'b1: Indicate there is data in UART Rx FIFO.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when flush cmd is received for IN endpoint 2 of JTAG.
        constexpr uint32_t SOF_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when SOF frame is received.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when Serial Port OUT Endpoint received one packet.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_RAW = (1U << 3);  ///< The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
        constexpr uint32_t PID_ERR_INT_RAW = (1U << 4);  ///< The raw interrupt bit turns to high level when pid error is detected.
        constexpr uint32_t CRC5_ERR_INT_RAW = (1U << 5);  ///< The raw interrupt bit turns to high level when CRC5 error is detected.
        constexpr uint32_t CRC16_ERR_INT_RAW = (1U << 6);  ///< The raw interrupt bit turns to high level when CRC16 error is detected.
        constexpr uint32_t STUFF_ERR_INT_RAW = (1U << 7);  ///< The raw interrupt bit turns to high level when stuff error is detected.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_RAW = (1U << 8);  ///< The raw interrupt bit turns to high level when IN token for IN endpoint 1 is received.
        constexpr uint32_t USB_BUS_RESET_INT_RAW = (1U << 9);  ///< The raw interrupt bit turns to high level when usb bus reset is detected.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_RAW = (1U << 10);  ///< The raw interrupt bit turns to high level when OUT endpoint 1 received packet with zero palyload.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_RAW = (1U << 11);  ///< The raw interrupt bit turns to high level when OUT endpoint 2 received packet with zero palyload.
        constexpr uint32_t RTS_CHG_INT_RAW = (1U << 12);  ///< The raw interrupt bit turns to high level when level of RTS from usb serial channel is changed.
        constexpr uint32_t DTR_CHG_INT_RAW = (1U << 13);  ///< The raw interrupt bit turns to high level when level of DTR from usb serial channel is changed.
        constexpr uint32_t GET_LINE_CODE_INT_RAW = (1U << 14);  ///< The raw interrupt bit turns to high level when level of GET LINE CODING request is received.
        constexpr uint32_t SET_LINE_CODE_INT_RAW = (1U << 15);  ///< The raw interrupt bit turns to high level when level of SET LINE CODING request is received.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_ST = (1U << 3);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_ST = (1U << 4);  ///< The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_ST = (1U << 5);  ///< The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_ST = (1U << 6);  ///< The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_ST = (1U << 7);  ///< The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_ST = (1U << 8);  ///< The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_ST = (1U << 9);  ///< The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ST = (1U << 10);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ST = (1U << 11);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t RTS_CHG_INT_ST = (1U << 12);  ///< The raw interrupt status bit for the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t DTR_CHG_INT_ST = (1U << 13);  ///< The raw interrupt status bit for the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t GET_LINE_CODE_INT_ST = (1U << 14);  ///< The raw interrupt status bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t SET_LINE_CODE_INT_ST = (1U << 15);  ///< The raw interrupt status bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t RTS_CHG_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t DTR_CHG_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t GET_LINE_CODE_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t SET_LINE_CODE_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t JTAG_IN_FLUSH_INT_CLR = (1U << 0);  ///< Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t SOF_INT_CLR = (1U << 1);  ///< Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
        constexpr uint32_t SERIAL_OUT_RECV_PKT_INT_CLR = (1U << 2);  ///< Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t SERIAL_IN_EMPTY_INT_CLR = (1U << 3);  ///< Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t PID_ERR_INT_CLR = (1U << 4);  ///< Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t CRC5_ERR_INT_CLR = (1U << 5);  ///< Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t CRC16_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t STUFF_ERR_INT_CLR = (1U << 7);  ///< Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t IN_TOKEN_REC_IN_EP1_INT_CLR = (1U << 8);  ///< Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
        constexpr uint32_t USB_BUS_RESET_INT_CLR = (1U << 9);  ///< Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t OUT_EP1_ZERO_PAYLOAD_INT_CLR = (1U << 10);  ///< Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t OUT_EP2_ZERO_PAYLOAD_INT_CLR = (1U << 11);  ///< Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t RTS_CHG_INT_CLR = (1U << 12);  ///< Set this bit to clear the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t DTR_CHG_INT_CLR = (1U << 13);  ///< Set this bit to clear the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t GET_LINE_CODE_INT_CLR = (1U << 14);  ///< Set this bit to clear the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t SET_LINE_CODE_INT_CLR = (1U << 15);  ///< Set this bit to clear the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PHY_SEL = (1U << 0);  ///< Select internal/external PHY
        constexpr uint32_t EXCHG_PINS_OVERRIDE = (1U << 1);  ///< Enable software control USB D+ D- exchange
        constexpr uint32_t EXCHG_PINS = (1U << 2);  ///< USB D+ D- exchange
        constexpr uint32_t VREFH = (2 << 3);  ///< Control single-end input high threshold,1.76V to 2V, step 80mV
        constexpr uint32_t VREFL = (2 << 5);  ///< Control single-end input low threshold,0.8V to 1.04V, step 80mV
        constexpr uint32_t VREF_OVERRIDE = (1U << 7);  ///< Enable software control input threshold
        constexpr uint32_t PAD_PULL_OVERRIDE = (1U << 8);  ///< Enable software control USB D+ D- pullup pulldown
        constexpr uint32_t DP_PULLUP = (1U << 9);  ///< Control USB D+ pull up.
        constexpr uint32_t DP_PULLDOWN = (1U << 10);  ///< Control USB D+ pull down.
        constexpr uint32_t DM_PULLUP = (1U << 11);  ///< Control USB D- pull up.
        constexpr uint32_t DM_PULLDOWN = (1U << 12);  ///< Control USB D- pull down.
        constexpr uint32_t PULLUP_VALUE = (1U << 13);  ///< Control pull up value.
        constexpr uint32_t USB_PAD_ENABLE = (1U << 14);  ///< Enable USB pad function.
        constexpr uint32_t USB_JTAG_BRIDGE_EN = (1U << 15);  ///< Set this bit usb_jtag, the connection between usb_jtag and internal JTAG is disconnected, and MTMS, MTDI, MTCK are output through GPIO Matrix, MTDO is input through GPIO Matrix.
    }

    /// TEST Register bits
    namespace test_bits {
        constexpr uint32_t TEST_ENABLE = (1U << 0);  ///< Enable test of the USB pad
        constexpr uint32_t TEST_USB_OE = (1U << 1);  ///< USB pad oen in test
        constexpr uint32_t TEST_TX_DP = (1U << 2);  ///< USB D+ tx value in test
        constexpr uint32_t TEST_TX_DM = (1U << 3);  ///< USB D- tx value in test
        constexpr uint32_t TEST_RX_RCV = (1U << 4);  ///< USB RCV value in test
        constexpr uint32_t TEST_RX_DP = (1U << 5);  ///< USB D+ rx value in test
        constexpr uint32_t TEST_RX_DM = (1U << 6);  ///< USB D- rx value in test
    }

    /// JFIFO_ST Register bits
    namespace jfifo_st_bits {
        constexpr uint32_t IN_FIFO_CNT = (2 << 0);  ///< JTAT in fifo counter.
        constexpr uint32_t IN_FIFO_EMPTY = (1U << 2);  ///< 1: JTAG in fifo is empty.
        constexpr uint32_t IN_FIFO_FULL = (1U << 3);  ///< 1: JTAG in fifo is full.
        constexpr uint32_t OUT_FIFO_CNT = (2 << 4);  ///< JTAT out fifo counter.
        constexpr uint32_t OUT_FIFO_EMPTY = (1U << 6);  ///< 1: JTAG out fifo is empty.
        constexpr uint32_t OUT_FIFO_FULL = (1U << 7);  ///< 1: JTAG out fifo is full.
        constexpr uint32_t IN_FIFO_RESET = (1U << 8);  ///< Write 1 to reset JTAG in fifo.
        constexpr uint32_t OUT_FIFO_RESET = (1U << 9);  ///< Write 1 to reset JTAG out fifo.
    }

    /// FRAM_NUM Register bits
    namespace fram_num_bits {
        constexpr uint32_t SOF_FRAME_INDEX = (11 << 0);  ///< Frame index of received SOF frame.
    }

    /// IN_EP0_ST Register bits
    namespace in_ep0_st_bits {
        constexpr uint32_t IN_EP0_STATE = (2 << 0);  ///< State of IN Endpoint 0.
        constexpr uint32_t IN_EP0_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 0.
        constexpr uint32_t IN_EP0_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 0.
    }

    /// IN_EP1_ST Register bits
    namespace in_ep1_st_bits {
        constexpr uint32_t IN_EP1_STATE = (2 << 0);  ///< State of IN Endpoint 1.
        constexpr uint32_t IN_EP1_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 1.
        constexpr uint32_t IN_EP1_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 1.
    }

    /// IN_EP2_ST Register bits
    namespace in_ep2_st_bits {
        constexpr uint32_t IN_EP2_STATE = (2 << 0);  ///< State of IN Endpoint 2.
        constexpr uint32_t IN_EP2_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 2.
        constexpr uint32_t IN_EP2_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 2.
    }

    /// IN_EP3_ST Register bits
    namespace in_ep3_st_bits {
        constexpr uint32_t IN_EP3_STATE = (2 << 0);  ///< State of IN Endpoint 3.
        constexpr uint32_t IN_EP3_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 3.
        constexpr uint32_t IN_EP3_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 3.
    }

    /// OUT_EP0_ST Register bits
    namespace out_ep0_st_bits {
        constexpr uint32_t OUT_EP0_STATE = (2 << 0);  ///< State of OUT Endpoint 0.
        constexpr uint32_t OUT_EP0_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
        constexpr uint32_t OUT_EP0_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 0.
    }

    /// OUT_EP1_ST Register bits
    namespace out_ep1_st_bits {
        constexpr uint32_t OUT_EP1_STATE = (2 << 0);  ///< State of OUT Endpoint 1.
        constexpr uint32_t OUT_EP1_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
        constexpr uint32_t OUT_EP1_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 1.
        constexpr uint32_t OUT_EP1_REC_DATA_CNT = (7 << 16);  ///< Data count in OUT endpoint 1 when one packet is received.
    }

    /// OUT_EP2_ST Register bits
    namespace out_ep2_st_bits {
        constexpr uint32_t OUT_EP2_STATE = (2 << 0);  ///< State of OUT Endpoint 2.
        constexpr uint32_t OUT_EP2_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
        constexpr uint32_t OUT_EP2_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 2.
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t USB_MEM_PD = (1U << 0);  ///< 1: power down usb memory.
        constexpr uint32_t USB_MEM_CLK_EN = (1U << 1);  ///< 1: Force clock on for usb memory.
    }

    /// CHIP_RST Register bits
    namespace chip_rst_bits {
        constexpr uint32_t RTS = (1U << 0);  ///< 1: Chip reset is detected from usb serial channel. Software write 1 to clear it.
        constexpr uint32_t DTR = (1U << 1);  ///< 1: Chip reset is detected from usb jtag channel. Software write 1 to clear it.
        constexpr uint32_t USB_UART_CHIP_RST_DIS = (1U << 2);  ///< Set this bit to disable chip reset from usb serial channel to reset chip.
    }

    /// SET_LINE_CODE_W0 Register bits
    namespace set_line_code_w0_bits {
        constexpr uint32_t DW_DTE_RATE = (32 << 0);  ///< The value of dwDTERate set by host through SET_LINE_CODING command.
    }

    /// SET_LINE_CODE_W1 Register bits
    namespace set_line_code_w1_bits {
        constexpr uint32_t BCHAR_FORMAT = (8 << 0);  ///< The value of bCharFormat set by host through SET_LINE_CODING command.
        constexpr uint32_t BPARITY_TYPE = (8 << 8);  ///< The value of bParityTpye set by host through SET_LINE_CODING command.
        constexpr uint32_t BDATA_BITS = (8 << 16);  ///< The value of bDataBits set by host through SET_LINE_CODING command.
    }

    /// GET_LINE_CODE_W0 Register bits
    namespace get_line_code_w0_bits {
        constexpr uint32_t GET_DW_DTE_RATE = (32 << 0);  ///< The value of dwDTERate set by software which is requested by GET_LINE_CODING command.
    }

    /// GET_LINE_CODE_W1 Register bits
    namespace get_line_code_w1_bits {
        constexpr uint32_t GET_BDATA_BITS = (8 << 0);  ///< The value of bCharFormat set by software which is requested by GET_LINE_CODING command.
        constexpr uint32_t GET_BPARITY_TYPE = (8 << 8);  ///< The value of bParityTpye set by software which is requested by GET_LINE_CODING command.
        constexpr uint32_t GET_BCHAR_FORMAT = (8 << 16);  ///< The value of bDataBits set by software which is requested by GET_LINE_CODING command.
    }

    /// CONFIG_UPDATE Register bits
    namespace config_update_bits {
        constexpr uint32_t CONFIG_UPDATE = (1U << 0);  ///< Write 1 to this register would update the value of configure registers from APB clock domain to 48MHz clock domain.
    }

    /// SER_AFIFO_CONFIG Register bits
    namespace ser_afifo_config_bits {
        constexpr uint32_t SERIAL_IN_AFIFO_RESET_WR = (1U << 0);  ///< Write 1 to reset CDC_ACM IN async FIFO write clock domain.
        constexpr uint32_t SERIAL_IN_AFIFO_RESET_RD = (1U << 1);  ///< Write 1 to reset CDC_ACM IN async FIFO read clock domain.
        constexpr uint32_t SERIAL_OUT_AFIFO_RESET_WR = (1U << 2);  ///< Write 1 to reset CDC_ACM OUT async FIFO write clock domain.
        constexpr uint32_t SERIAL_OUT_AFIFO_RESET_RD = (1U << 3);  ///< Write 1 to reset CDC_ACM OUT async FIFO read clock domain.
        constexpr uint32_t SERIAL_OUT_AFIFO_REMPTY = (1U << 4);  ///< CDC_ACM OUTOUT async FIFO empty signal in read clock domain.
        constexpr uint32_t SERIAL_IN_AFIFO_WFULL = (1U << 5);  ///< CDC_ACM OUT IN async FIFO empty signal in write clock domain.
    }

    /// BUS_RESET_ST Register bits
    namespace bus_reset_st_bits {
        constexpr uint32_t USB_BUS_RESET_ST = (1U << 0);  ///< USB bus reset status. 0: USB-Serial-JTAG is in usb bus reset status. 1: USB bus reset is released.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

}


} // namespace alloy::generated::esp32-h2

#endif // ALLOY_GENERATED_ESP32-H2_PERIPHERALS_HPP