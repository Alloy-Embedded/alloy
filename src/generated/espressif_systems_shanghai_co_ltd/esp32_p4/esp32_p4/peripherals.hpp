/// Auto-generated code for ESP32-P4
/// Generated by Alloy Code Generator
/// Source: espressif_esp32p4.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:07
#ifndef ALLOY_GENERATED_ESP32-P4_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-P4_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-p4 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 4;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 4;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 4;
    constexpr bool has_assist = true;
    constexpr uint32_t num_assist_instances = 1;
    constexpr bool has_radio = true;
    constexpr uint32_t num_radio_instances = 1;
    constexpr bool has_cache = true;
    constexpr uint32_t num_cache_instances = 1;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 2;
    constexpr bool has_mipi = true;
    constexpr uint32_t num_mipi_instances = 4;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_ecc = true;
    constexpr uint32_t num_ecc_instances = 1;
    constexpr bool has_ecdsa = true;
    constexpr uint32_t num_ecdsa_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;
    constexpr bool has_h264 = true;
    constexpr uint32_t num_h264_instances = 1;
    constexpr bool has_hp = true;
    constexpr uint32_t num_hp_instances = 2;
    constexpr bool has_lp = true;
    constexpr uint32_t num_lp_instances = 9;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 4;
    constexpr bool has_i3c = true;
    constexpr uint32_t num_i3c_instances = 3;
    constexpr bool has_axi = true;
    constexpr uint32_t num_axi_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_isp = true;
    constexpr uint32_t num_isp_instances = 1;
    constexpr bool has_jpeg = true;
    constexpr uint32_t num_jpeg_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_parl = true;
    constexpr uint32_t num_parl_instances = 1;
    constexpr bool has_pau = true;
    constexpr uint32_t num_pau_instances = 1;
    constexpr bool has_pcnt = true;
    constexpr uint32_t num_pcnt_instances = 1;
    constexpr bool has_pmu = true;
    constexpr uint32_t num_pmu_instances = 1;
    constexpr bool has_ppa = true;
    constexpr uint32_t num_ppa_instances = 1;
    constexpr bool has_pvt = true;
    constexpr uint32_t num_pvt_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 4;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_sdhost = true;
    constexpr uint32_t num_sdhost_instances = 1;
    constexpr bool has_soc = true;
    constexpr uint32_t num_soc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_trace0 = true;
    constexpr uint32_t num_trace0_instances = 1;
    constexpr bool has_trace1 = true;
    constexpr uint32_t num_trace1_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 3;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct assist_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct radio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mipi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ecdsa_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct h264_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct lp_tag> {
        static constexpr uint32_t value = 9;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct i3c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct axi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct isp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct jpeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct parl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcnt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ppa_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pvt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhost_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct soc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct trace0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trace1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lp_uart = true;
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x500DE000;
    constexpr uint32_t LP_ADC_BASE = 0x50127000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Register
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - Register
        volatile uint32_t FILTER_CTRL1;  ///< Offset: 0x08 - Register
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - Register
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - Register
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - Register
        volatile uint32_t SAR1_PATT_TAB1;  ///< Offset: 0x18 - Register
        volatile uint32_t SAR1_PATT_TAB2;  ///< Offset: 0x1C - Register
        volatile uint32_t SAR1_PATT_TAB3;  ///< Offset: 0x20 - Register
        volatile uint32_t SAR1_PATT_TAB4;  ///< Offset: 0x24 - Register
        volatile uint32_t SAR2_PATT_TAB1;  ///< Offset: 0x28 - Register
        volatile uint32_t SAR2_PATT_TAB2;  ///< Offset: 0x2C - Register
        volatile uint32_t SAR2_PATT_TAB3;  ///< Offset: 0x30 - Register
        volatile uint32_t SAR2_PATT_TAB4;  ///< Offset: 0x34 - Register
        volatile uint32_t ARB_CTRL;  ///< Offset: 0x38 - Register
        volatile uint32_t FILTER_CTRL0;  ///< Offset: 0x3C - Register
        volatile uint32_t SAR1_DATA_STATUS;  ///< Offset: 0x40 - Register
        volatile uint32_t THRES0_CTRL;  ///< Offset: 0x44 - Register
        volatile uint32_t THRES1_CTRL;  ///< Offset: 0x48 - Register
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x4C - Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x50 - Register
        volatile uint32_t INT_RAW;  ///< Offset: 0x54 - Register
        volatile uint32_t INT_ST;  ///< Offset: 0x58 - Register
        volatile uint32_t INT_CLR;  ///< Offset: 0x5C - Register
        volatile uint32_t DMA_CONF;  ///< Offset: 0x60 - Register
        volatile uint32_t SAR2_DATA_STATUS;  ///< Offset: 0x64 - Register
        volatile uint32_t CALI;  ///< Offset: 0x68 - Register
        volatile uint32_t RND_ECO_LOW;  ///< Offset: 0x6C - Register
        volatile uint32_t RND_ECO_HIGH;  ///< Offset: 0x70 - Register
        volatile uint32_t RND_ECO_CS;  ///< Offset: 0x74 - Register
        volatile uint32_t CTRL_DATE;  ///< Offset: 0x3FC - Register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);
    inline Registers* LP_ADC = reinterpret_cast<Registers*>(LP_ADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t START_FORCE = (1U << 0);  ///< need_des
        constexpr uint32_t START = (1U << 1);  ///< need_des
        constexpr uint32_t WORK_MODE = (2 << 2);  ///< 0: single mode, 1: double mode, 2: alternate mode
        constexpr uint32_t SAR_SEL = (1U << 4);  ///< 0: SAR1, 1: SAR2, only work for single SAR mode
        constexpr uint32_t SAR_CLK_GATED = (1U << 5);  ///< need_des
        constexpr uint32_t SAR_CLK_DIV = (8 << 6);  ///< SAR clock divider
        constexpr uint32_t SAR1_PATT_LEN = (4 << 14);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SAR2_PATT_LEN = (4 << 18);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SAR1_PATT_P_CLEAR = (1U << 22);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SAR2_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC2 CTRL
        constexpr uint32_t DATA_SAR_SEL = (1U << 24);  ///< 1: sar_sel will be coded by the MSB of the 16-bit output data, in this case the resolution should not be larger than 11 bits.
        constexpr uint32_t DATA_TO_I2S = (1U << 25);  ///< 1: I2S input data is from SAR ADC (for DMA), 0: I2S input data is from GPIO matrix
        constexpr uint32_t XPD_SAR1_FORCE = (2 << 26);  ///< force option to xpd sar1 blocks
        constexpr uint32_t XPD_SAR2_FORCE = (2 << 28);  ///< force option to xpd sar2 blocks
        constexpr uint32_t WAIT_ARB_CYCLE = (2 << 30);  ///< wait arbit signal stable after sar_done
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t MEAS_NUM_LIMIT = (1U << 0);  ///< need_des
        constexpr uint32_t MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not
        constexpr uint32_t SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not
        constexpr uint32_t TIMER_SEL = (1U << 11);  ///< 1: select saradc timer 0: i2s_ws trigger
        constexpr uint32_t TIMER_TARGET = (12 << 12);  ///< to set saradc timer target
        constexpr uint32_t TIMER_EN = (1U << 24);  ///< to enable saradc timer trigger
    }

    /// FILTER_CTRL1 Register bits
    namespace filter_ctrl1_bits {
        constexpr uint32_t FILTER_FACTOR1 = (3 << 26);  ///< need_des
        constexpr uint32_t FILTER_FACTOR0 = (3 << 29);  ///< need_des
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t XPD_WAIT = (8 << 0);  ///< need_des
        constexpr uint32_t RSTB_WAIT = (8 << 8);  ///< need_des
        constexpr uint32_t STANDBY_WAIT = (8 << 16);  ///< need_des
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SAR1_STATUS = (32 << 0);  ///< SAR1_STATUS
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SAR2_STATUS = (32 << 0);  ///< SAR2_STATUS
    }

    /// SAR1_PATT_TAB1 Register bits
    namespace sar1_patt_tab1_bits {
        constexpr uint32_t SAR1_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB2 Register bits
    namespace sar1_patt_tab2_bits {
        constexpr uint32_t SAR1_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB3 Register bits
    namespace sar1_patt_tab3_bits {
        constexpr uint32_t SAR1_PATT_TAB3 = (24 << 0);  ///< Item 8 ~ 11 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB4 Register bits
    namespace sar1_patt_tab4_bits {
        constexpr uint32_t SAR1_PATT_TAB4 = (24 << 0);  ///< Item 12 ~ 15 for pattern table 1 (each item one byte)
    }

    /// SAR2_PATT_TAB1 Register bits
    namespace sar2_patt_tab1_bits {
        constexpr uint32_t SAR2_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB2 Register bits
    namespace sar2_patt_tab2_bits {
        constexpr uint32_t SAR2_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB3 Register bits
    namespace sar2_patt_tab3_bits {
        constexpr uint32_t SAR2_PATT_TAB3 = (24 << 0);  ///< Item 8 ~ 11 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB4 Register bits
    namespace sar2_patt_tab4_bits {
        constexpr uint32_t SAR2_PATT_TAB4 = (24 << 0);  ///< Item 12 ~ 15 for pattern table 2 (each item one byte)
    }

    /// ARB_CTRL Register bits
    namespace arb_ctrl_bits {
        constexpr uint32_t ARB_APB_FORCE = (1U << 2);  ///< adc2 arbiter force to enableapb controller
        constexpr uint32_t ARB_RTC_FORCE = (1U << 3);  ///< adc2 arbiter force to enable rtc controller
        constexpr uint32_t ARB_WIFI_FORCE = (1U << 4);  ///< adc2 arbiter force to enable wifi controller
        constexpr uint32_t ARB_GRANT_FORCE = (1U << 5);  ///< adc2 arbiter force grant
        constexpr uint32_t ARB_APB_PRIORITY = (2 << 6);  ///< Set adc2 arbiterapb priority
        constexpr uint32_t ARB_RTC_PRIORITY = (2 << 8);  ///< Set adc2 arbiter rtc priority
        constexpr uint32_t ARB_WIFI_PRIORITY = (2 << 10);  ///< Set adc2 arbiter wifi priority
        constexpr uint32_t ARB_FIX_PRIORITY = (1U << 12);  ///< adc2 arbiter uses fixed priority
    }

    /// FILTER_CTRL0 Register bits
    namespace filter_ctrl0_bits {
        constexpr uint32_t FILTER_CHANNEL1 = (5 << 14);  ///< need_des
        constexpr uint32_t FILTER_CHANNEL0 = (5 << 19);  ///< apb_adc1_filter_factor
        constexpr uint32_t FILTER_RESET = (1U << 31);  ///< enable apb_adc1_filter
    }

    /// SAR1_DATA_STATUS Register bits
    namespace sar1_data_status_bits {
        constexpr uint32_t APB_SARADC1_DATA = (17 << 0);  ///< need_des
    }

    /// THRES0_CTRL Register bits
    namespace thres0_ctrl_bits {
        constexpr uint32_t THRES0_CHANNEL = (5 << 0);  ///< need_des
        constexpr uint32_t THRES0_HIGH = (13 << 5);  ///< saradc1's thres0 monitor thres
        constexpr uint32_t THRES0_LOW = (13 << 18);  ///< saradc1's thres0 monitor thres
    }

    /// THRES1_CTRL Register bits
    namespace thres1_ctrl_bits {
        constexpr uint32_t THRES1_CHANNEL = (5 << 0);  ///< need_des
        constexpr uint32_t THRES1_HIGH = (13 << 5);  ///< saradc1's thres0 monitor thres
        constexpr uint32_t THRES1_LOW = (13 << 18);  ///< saradc1's thres0 monitor thres
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t THRES_ALL_EN = (1U << 27);  ///< need_des
        constexpr uint32_t THRES3_EN = (1U << 28);  ///< need_des
        constexpr uint32_t THRES2_EN = (1U << 29);  ///< need_des
        constexpr uint32_t THRES1_EN = (1U << 30);  ///< need_des
        constexpr uint32_t THRES0_EN = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t THRES1_LOW_INT_ENA = (1U << 26);  ///< need_des
        constexpr uint32_t THRES0_LOW_INT_ENA = (1U << 27);  ///< need_des
        constexpr uint32_t THRES1_HIGH_INT_ENA = (1U << 28);  ///< need_des
        constexpr uint32_t THRES0_HIGH_INT_ENA = (1U << 29);  ///< need_des
        constexpr uint32_t SAR2_DONE_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SAR1_DONE_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t THRES1_LOW_INT_RAW = (1U << 26);  ///< need_des
        constexpr uint32_t THRES0_LOW_INT_RAW = (1U << 27);  ///< need_des
        constexpr uint32_t THRES1_HIGH_INT_RAW = (1U << 28);  ///< need_des
        constexpr uint32_t THRES0_HIGH_INT_RAW = (1U << 29);  ///< need_des
        constexpr uint32_t SAR2_DONE_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SAR1_DONE_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t THRES1_LOW_INT_ST = (1U << 26);  ///< need_des
        constexpr uint32_t THRES0_LOW_INT_ST = (1U << 27);  ///< need_des
        constexpr uint32_t THRES1_HIGH_INT_ST = (1U << 28);  ///< need_des
        constexpr uint32_t THRES0_HIGH_INT_ST = (1U << 29);  ///< need_des
        constexpr uint32_t APB_SARADC2_DONE_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t APB_SARADC1_DONE_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t THRES1_LOW_INT_CLR = (1U << 26);  ///< need_des
        constexpr uint32_t THRES0_LOW_INT_CLR = (1U << 27);  ///< need_des
        constexpr uint32_t THRES1_HIGH_INT_CLR = (1U << 28);  ///< need_des
        constexpr uint32_t THRES0_HIGH_INT_CLR = (1U << 29);  ///< need_des
        constexpr uint32_t APB_SARADC2_DONE_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t APB_SARADC1_DONE_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< the dma_in_suc_eof gen when sample cnt = spi_eof_num
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< reset_apb_adc_state
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< enable apb_adc use spi_dma
    }

    /// SAR2_DATA_STATUS Register bits
    namespace sar2_data_status_bits {
        constexpr uint32_t APB_SARADC2_DATA = (17 << 0);  ///< need_des
    }

    /// CALI Register bits
    namespace cali_bits {
        constexpr uint32_t CFG = (17 << 0);  ///< need_des
    }

    /// RND_ECO_LOW Register bits
    namespace rnd_eco_low_bits {
        constexpr uint32_t RND_ECO_LOW = (32 << 0);  ///< rnd eco low
    }

    /// RND_ECO_HIGH Register bits
    namespace rnd_eco_high_bits {
        constexpr uint32_t RND_ECO_HIGH = (32 << 0);  ///< rnd eco high
    }

    /// RND_ECO_CS Register bits
    namespace rnd_eco_cs_bits {
        constexpr uint32_t RND_ECO_EN = (1U << 0);  ///< need_des
        constexpr uint32_t RND_ECO_RESULT = (1U << 1);  ///< need_des
    }

    /// CTRL_DATE Register bits
    namespace ctrl_date_bits {
        constexpr uint32_t CTRL_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x50090000;
    constexpr uint32_t HMAC_BASE = 0x50095000;
    constexpr uint32_t RSA_BASE = 0x50092000;
    constexpr uint32_t SHA_BASE = 0x50091000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t KEY_0;  ///< Offset: 0x00 - Key material key_0 configure register
        volatile uint32_t KEY_1;  ///< Offset: 0x04 - Key material key_1 configure register
        volatile uint32_t KEY_2;  ///< Offset: 0x08 - Key material key_2 configure register
        volatile uint32_t KEY_3;  ///< Offset: 0x0C - Key material key_3 configure register
        volatile uint32_t KEY_4;  ///< Offset: 0x10 - Key material key_4 configure register
        volatile uint32_t KEY_5;  ///< Offset: 0x14 - Key material key_5 configure register
        volatile uint32_t KEY_6;  ///< Offset: 0x18 - Key material key_6 configure register
        volatile uint32_t KEY_7;  ///< Offset: 0x1C - Key material key_7 configure register
        volatile uint32_t TEXT_IN_0;  ///< Offset: 0x20 - source text material text_in_0 configure register
        volatile uint32_t TEXT_IN_1;  ///< Offset: 0x24 - source text material text_in_1 configure register
        volatile uint32_t TEXT_IN_2;  ///< Offset: 0x28 - source text material text_in_2 configure register
        volatile uint32_t TEXT_IN_3;  ///< Offset: 0x2C - source text material text_in_3 configure register
        volatile uint32_t TEXT_OUT_0;  ///< Offset: 0x30 - result text material text_out_0 configure register
        volatile uint32_t TEXT_OUT_1;  ///< Offset: 0x34 - result text material text_out_1 configure register
        volatile uint32_t TEXT_OUT_2;  ///< Offset: 0x38 - result text material text_out_2 configure register
        volatile uint32_t TEXT_OUT_3;  ///< Offset: 0x3C - result text material text_out_3 configure register
        volatile uint32_t MODE;  ///< Offset: 0x40 - AES Mode register
        volatile uint32_t ENDIAN;  ///< Offset: 0x44 - AES Endian configure register
        volatile uint32_t TRIGGER;  ///< Offset: 0x48 - AES trigger register
        volatile uint32_t STATE;  ///< Offset: 0x4C - AES state register
        volatile uint32_t IV_MEM[%s];  ///< Offset: 0x50 - The memory that stores initialization vector
        volatile uint32_t H_MEM[%s];  ///< Offset: 0x60 - The memory that stores GCM hash subkey
        volatile uint32_t J0_MEM[%s];  ///< Offset: 0x70 - The memory that stores J0
        volatile uint32_t T0_MEM[%s];  ///< Offset: 0x80 - The memory that stores T0
        volatile uint32_t DMA_ENABLE;  ///< Offset: 0x90 - DMA-AES working mode register
        volatile uint32_t BLOCK_MODE;  ///< Offset: 0x94 - AES cipher block mode register
        volatile uint32_t BLOCK_NUM;  ///< Offset: 0x98 - AES block number register
        volatile uint32_t INC_SEL;  ///< Offset: 0x9C - Standard incrementing function configure register
        volatile uint32_t AAD_BLOCK_NUM;  ///< Offset: 0xA0 - Additional Authential Data block number register
        volatile uint32_t REMAINDER_BIT_NUM;  ///< Offset: 0xA4 - AES remainder bit number register
        volatile uint32_t CONTINUE;  ///< Offset: 0xA8 - AES continue register
        volatile uint32_t INT_CLEAR;  ///< Offset: 0xAC - AES Interrupt clear register
        volatile uint32_t INT_ENA;  ///< Offset: 0xB0 - AES Interrupt enable register
        volatile uint32_t DATE;  ///< Offset: 0xB4 - AES version control register
        volatile uint32_t DMA_EXIT;  ///< Offset: 0xB8 - AES-DMA exit config
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* HMAC = reinterpret_cast<Registers*>(HMAC_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);

    // Bit definitions
    /// KEY_0 Register bits
    namespace key_0_bits {
        constexpr uint32_t KEY_0 = (32 << 0);  ///< This bits stores key_0 that is a part of key material.
    }

    /// KEY_1 Register bits
    namespace key_1_bits {
        constexpr uint32_t KEY_1 = (32 << 0);  ///< This bits stores key_1 that is a part of key material.
    }

    /// KEY_2 Register bits
    namespace key_2_bits {
        constexpr uint32_t KEY_2 = (32 << 0);  ///< This bits stores key_2 that is a part of key material.
    }

    /// KEY_3 Register bits
    namespace key_3_bits {
        constexpr uint32_t KEY_3 = (32 << 0);  ///< This bits stores key_3 that is a part of key material.
    }

    /// KEY_4 Register bits
    namespace key_4_bits {
        constexpr uint32_t KEY_4 = (32 << 0);  ///< This bits stores key_4 that is a part of key material.
    }

    /// KEY_5 Register bits
    namespace key_5_bits {
        constexpr uint32_t KEY_5 = (32 << 0);  ///< This bits stores key_5 that is a part of key material.
    }

    /// KEY_6 Register bits
    namespace key_6_bits {
        constexpr uint32_t KEY_6 = (32 << 0);  ///< This bits stores key_6 that is a part of key material.
    }

    /// KEY_7 Register bits
    namespace key_7_bits {
        constexpr uint32_t KEY_7 = (32 << 0);  ///< This bits stores key_7 that is a part of key material.
    }

    /// TEXT_IN_0 Register bits
    namespace text_in_0_bits {
        constexpr uint32_t TEXT_IN_0 = (32 << 0);  ///< This bits stores text_in_0 that is a part of source text material.
    }

    /// TEXT_IN_1 Register bits
    namespace text_in_1_bits {
        constexpr uint32_t TEXT_IN_1 = (32 << 0);  ///< This bits stores text_in_1 that is a part of source text material.
    }

    /// TEXT_IN_2 Register bits
    namespace text_in_2_bits {
        constexpr uint32_t TEXT_IN_2 = (32 << 0);  ///< This bits stores text_in_2 that is a part of source text material.
    }

    /// TEXT_IN_3 Register bits
    namespace text_in_3_bits {
        constexpr uint32_t TEXT_IN_3 = (32 << 0);  ///< This bits stores text_in_3 that is a part of source text material.
    }

    /// TEXT_OUT_0 Register bits
    namespace text_out_0_bits {
        constexpr uint32_t TEXT_OUT_0 = (32 << 0);  ///< This bits stores text_out_0 that is a part of result text material.
    }

    /// TEXT_OUT_1 Register bits
    namespace text_out_1_bits {
        constexpr uint32_t TEXT_OUT_1 = (32 << 0);  ///< This bits stores text_out_1 that is a part of result text material.
    }

    /// TEXT_OUT_2 Register bits
    namespace text_out_2_bits {
        constexpr uint32_t TEXT_OUT_2 = (32 << 0);  ///< This bits stores text_out_2 that is a part of result text material.
    }

    /// TEXT_OUT_3 Register bits
    namespace text_out_3_bits {
        constexpr uint32_t TEXT_OUT_3 = (32 << 0);  ///< This bits stores text_out_3 that is a part of result text material.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< This bits decides which one operation mode will be used. 3'd0: AES-EN-128, 3'd1: AES-EN-192, 3'd2: AES-EN-256, 3'd4: AES-DE-128, 3'd5: AES-DE-192, 3'd6: AES-DE-256.
    }

    /// ENDIAN Register bits
    namespace endian_bits {
        constexpr uint32_t ENDIAN = (6 << 0);  ///< endian. [1:0] key endian, [3:2] text_in endian or in_stream endian, [5:4] text_out endian or out_stream endian
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< Set this bit to start AES calculation.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< Those bits shows AES status. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
    }

    /// DMA_ENABLE Register bits
    namespace dma_enable_bits {
        constexpr uint32_t DMA_ENABLE = (1U << 0);  ///< 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
    }

    /// BLOCK_MODE Register bits
    namespace block_mode_bits {
        constexpr uint32_t BLOCK_MODE = (3 << 0);  ///< Those bits decides which block mode will be used. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: GCM, 0x7: reserved.
    }

    /// BLOCK_NUM Register bits
    namespace block_num_bits {
        constexpr uint32_t BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of Plaintext/ciphertext block.
    }

    /// INC_SEL Register bits
    namespace inc_sel_bits {
        constexpr uint32_t INC_SEL = (1U << 0);  ///< This bit decides the standard incrementing function. 0: INC32. 1: INC128.
    }

    /// AAD_BLOCK_NUM Register bits
    namespace aad_block_num_bits {
        constexpr uint32_t AAD_BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of AAD block.
    }

    /// REMAINDER_BIT_NUM Register bits
    namespace remainder_bit_num_bits {
        constexpr uint32_t REMAINDER_BIT_NUM = (7 << 0);  ///< Those bits stores the number of remainder bit.
    }

    /// CONTINUE Register bits
    namespace continue_bits {
        constexpr uint32_t CONTINUE = (1U << 0);  ///< Set this bit to continue GCM operation.
    }

    /// INT_CLEAR Register bits
    namespace int_clear_bits {
        constexpr uint32_t INT_CLEAR = (1U << 0);  ///< Set this bit to clear the AES interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t INT_ENA = (1U << 0);  ///< Set this bit to enable interrupt that occurs when DMA-AES calculation is done.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< This bits stores the version information of AES.
    }

    /// DMA_EXIT Register bits
    namespace dma_exit_bits {
        constexpr uint32_t DMA_EXIT = (1U << 0);  ///< Set this register to leave calculation done stage. Recommend to use it after software finishes reading DMA's output buffer.
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t AHB_DMA_BASE = 0x50085000;
    constexpr uint32_t AXI_DMA_BASE = 0x5008A000;
    constexpr uint32_t DMA_BASE = 0x50081000;
    constexpr uint32_t H264_DMA_BASE = 0x500A7000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t IN_INT_RAW_CH%s;  ///< Offset: 0x00 - Raw status interrupt of channel 0
        volatile uint32_t IN_INT_ST_CH%s;  ///< Offset: 0x04 - Masked interrupt of channel 0
        volatile uint32_t IN_INT_ENA_CH%s;  ///< Offset: 0x08 - Interrupt enable bits of channel 0
        volatile uint32_t IN_INT_CLR_CH%s;  ///< Offset: 0x0C - Interrupt clear bits of channel 0
        volatile uint32_t OUT_INT_RAW_CH%s;  ///< Offset: 0x30 - Raw status interrupt of channel 0
        volatile uint32_t OUT_INT_ST_CH%s;  ///< Offset: 0x34 - Masked interrupt of channel 0
        volatile uint32_t OUT_INT_ENA_CH%s;  ///< Offset: 0x38 - Interrupt enable bits of channel 0
        volatile uint32_t OUT_INT_CLR_CH%s;  ///< Offset: 0x3C - Interrupt clear bits of channel 0
        volatile uint32_t AHB_TEST;  ///< Offset: 0x60 - reserved
        volatile uint32_t MISC_CONF;  ///< Offset: 0x64 - MISC register
        volatile uint32_t DATE;  ///< Offset: 0x68 - Version control register
        volatile uint32_t IN_CONF0_CH%s;  ///< Offset: 0x70 - Configure 0 register of Rx channel 0
        volatile uint32_t IN_CONF1_CH%s;  ///< Offset: 0x74 - Configure 1 register of Rx channel 0
        volatile uint32_t INFIFO_STATUS_CH%s;  ///< Offset: 0x78 - Receive FIFO status of Rx channel 0
        volatile uint32_t IN_POP_CH%s;  ///< Offset: 0x7C - Pop control register of Rx channel 0
        volatile uint32_t IN_LINK_CH%s;  ///< Offset: 0x80 - Link descriptor configure and control register of Rx channel 0
        volatile uint32_t IN_STATE_CH%s;  ///< Offset: 0x84 - Receive status of Rx channel 0
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH%s;  ///< Offset: 0x88 - Inlink descriptor address when EOF occurs of Rx channel 0
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH%s;  ///< Offset: 0x8C - Inlink descriptor address when errors occur of Rx channel 0
        volatile uint32_t IN_DSCR_CH%s;  ///< Offset: 0x90 - Current inlink descriptor address of Rx channel 0
        volatile uint32_t IN_DSCR_BF0_CH%s;  ///< Offset: 0x94 - The last inlink descriptor address of Rx channel 0
        volatile uint32_t IN_DSCR_BF1_CH%s;  ///< Offset: 0x98 - The second-to-last inlink descriptor address of Rx channel 0
        volatile uint32_t IN_PRI_CH%s;  ///< Offset: 0x9C - Priority register of Rx channel 0
        volatile uint32_t IN_PERI_SEL_CH%s;  ///< Offset: 0xA0 - Peripheral selection of Rx channel 0
        volatile uint32_t OUT_CONF0_CH0;  ///< Offset: 0xD0 - Configure 0 register of Tx channel 0
        volatile uint32_t OUT_CONF1_CH%s;  ///< Offset: 0xD4 - Configure 1 register of Tx channel 0
        volatile uint32_t OUTFIFO_STATUS_CH%s;  ///< Offset: 0xD8 - Transmit FIFO status of Tx channel 0
        volatile uint32_t OUT_PUSH_CH%s;  ///< Offset: 0xDC - Push control register of Rx channel 0
        volatile uint32_t OUT_LINK_CH%s;  ///< Offset: 0xE0 - Link descriptor configure and control register of Tx channel 0
        volatile uint32_t OUT_STATE_CH%s;  ///< Offset: 0xE4 - Transmit status of Tx channel 0
        volatile uint32_t OUT_EOF_DES_ADDR_CH%s;  ///< Offset: 0xE8 - Outlink descriptor address when EOF occurs of Tx channel 0
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH%s;  ///< Offset: 0xEC - The last outlink descriptor address when EOF occurs of...
        volatile uint32_t OUT_DSCR_CH%s;  ///< Offset: 0xF0 - Current inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_DSCR_BF0_CH%s;  ///< Offset: 0xF4 - The last inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_DSCR_BF1_CH%s;  ///< Offset: 0xF8 - The second-to-last inlink descriptor address of Tx channel 0
        volatile uint32_t OUT_PRI_CH%s;  ///< Offset: 0xFC - Priority register of Tx channel 0.
        volatile uint32_t OUT_PERI_SEL_CH%s;  ///< Offset: 0x100 - Peripheral selection of Tx channel 0
        volatile uint32_t OUT_CONF0_CH%s;  ///< Offset: 0x190 - Configure 0 register of Tx channel 1
        volatile uint32_t OUT_CRC_INIT_DATA_CH%s;  ///< Offset: 0x2BC - This register is used to config ch0 crc initial data(max 32 bit)
        volatile uint32_t TX_CRC_WIDTH_CH%s;  ///< Offset: 0x2C0 - This register is used to confiig tx ch0 crc result...
        volatile uint32_t OUT_CRC_CLEAR_CH%s;  ///< Offset: 0x2C4 - This register is used to clear ch0 crc result
        volatile uint32_t OUT_CRC_FINAL_RESULT_CH%s;  ///< Offset: 0x2C8 - This register is used to store ch0 crc result
        volatile uint32_t TX_CRC_EN_WR_DATA_CH%s;  ///< Offset: 0x2CC - This resister is used to config ch0 crc en for every bit
        volatile uint32_t TX_CRC_EN_ADDR_CH%s;  ///< Offset: 0x2D0 - This register is used to config ch0 crc en addr
        volatile uint32_t TX_CRC_DATA_EN_WR_DATA_CH%s;  ///< Offset: 0x2D4 - This register is used to config crc data_8bit en
        volatile uint32_t TX_CRC_DATA_EN_ADDR_CH%s;  ///< Offset: 0x2D8 - This register is used to config addr of crc data_8bit en
        volatile uint32_t TX_CH_ARB_WEIGH_CH%s;  ///< Offset: 0x2DC - This register is used to config ch0 arbiter weigh
        volatile uint32_t TX_ARB_WEIGH_OPT_DIR_CH%s;  ///< Offset: 0x2E0 - This register is used to config off or on weigh optimization
        volatile uint32_t IN_CRC_INIT_DATA_CH%s;  ///< Offset: 0x334 - This register is used to config ch0 crc initial data(max 32 bit)
        volatile uint32_t RX_CRC_WIDTH_CH%s;  ///< Offset: 0x338 - This register is used to confiig rx ch0 crc result...
        volatile uint32_t IN_CRC_CLEAR_CH%s;  ///< Offset: 0x33C - This register is used to clear ch0 crc result
        volatile uint32_t IN_CRC_FINAL_RESULT_CH%s;  ///< Offset: 0x340 - This register is used to store ch0 crc result
        volatile uint32_t RX_CRC_EN_WR_DATA_CH%s;  ///< Offset: 0x344 - This resister is used to config ch0 crc en for every bit
        volatile uint32_t RX_CRC_EN_ADDR_CH%s;  ///< Offset: 0x348 - This register is used to config ch0 crc en addr
        volatile uint32_t RX_CRC_DATA_EN_WR_DATA_CH%s;  ///< Offset: 0x34C - This register is used to config crc data_8bit en
        volatile uint32_t RX_CRC_DATA_EN_ADDR_CH%s;  ///< Offset: 0x350 - This register is used to config addr of crc data_8bit en
        volatile uint32_t RX_CH_ARB_WEIGH_CH%s;  ///< Offset: 0x354 - This register is used to config ch0 arbiter weigh
        volatile uint32_t RX_ARB_WEIGH_OPT_DIR_CH%s;  ///< Offset: 0x358 - This register is used to config off or on weigh optimization
        volatile uint32_t IN_LINK_ADDR_CH%s;  ///< Offset: 0x3AC - Link descriptor configure of Rx channel 0
        volatile uint32_t OUT_LINK_ADDR_CH%s;  ///< Offset: 0x3B8 - Link descriptor configure of Tx channel 0
        volatile uint32_t INTR_MEM_START_ADDR;  ///< Offset: 0x3C4 - The start address of accessible address space.
        volatile uint32_t INTR_MEM_END_ADDR;  ///< Offset: 0x3C8 - The end address of accessible address space. The access...
        volatile uint32_t ARB_TIMEOUT_TX;  ///< Offset: 0x3CC - This retister is used to config arbiter time slice for tx dir
        volatile uint32_t ARB_TIMEOUT_RX;  ///< Offset: 0x3D0 - This retister is used to config arbiter time slice for rx dir
        volatile uint32_t WEIGHT_EN_TX;  ///< Offset: 0x3D4 - This register is used to config arbiter weigh function...
        volatile uint32_t WEIGHT_EN_RX;  ///< Offset: 0x3D8 - This register is used to config arbiter weigh function...
    };

    /// Peripheral instances
    inline Registers* AHB_DMA = reinterpret_cast<Registers*>(AHB_DMA_BASE);
    inline Registers* AXI_DMA = reinterpret_cast<Registers*>(AXI_DMA_BASE);
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* H264_DMA = reinterpret_cast<Registers*>(H264_DMA_BASE);

    // Bit definitions
    /// IN_INT_RAW_CH%s Register bits
    namespace in_int_raw_ch%s_bits {
        constexpr uint32_t IN_DONE_CH_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
        constexpr uint32_t IN_SUC_EOF_CH_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
        constexpr uint32_t IN_ERR_EOF_CH_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
        constexpr uint32_t IN_DSCR_ERR_CH_INT_RAW = (1U << 3);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
        constexpr uint32_t IN_DSCR_EMPTY_CH_INT_RAW = (1U << 4);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
        constexpr uint32_t INFIFO_OVF_CH_INT_RAW = (1U << 5);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF_CH_INT_RAW = (1U << 6);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
    }

    /// IN_INT_ST_CH%s Register bits
    namespace in_int_st_ch%s_bits {
        constexpr uint32_t IN_DONE_CH_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_CH_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_CH_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_CH_INT_ST = (1U << 3);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_CH_INT_ST = (1U << 4);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_CH_INT_ST = (1U << 5);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_CH_INT_ST = (1U << 6);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// IN_INT_ENA_CH%s Register bits
    namespace in_int_ena_ch%s_bits {
        constexpr uint32_t IN_DONE_CH_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_CH_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_CH_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_CH_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_CH_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_CH_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_CH_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// IN_INT_CLR_CH%s Register bits
    namespace in_int_clr_ch%s_bits {
        constexpr uint32_t IN_DONE_CH_INT_CLR = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_CH_INT_CLR = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_CH_INT_CLR = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_CH_INT_CLR = (1U << 3);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_CH_INT_CLR = (1U << 4);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_CH_INT_CLR = (1U << 5);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_CH_INT_CLR = (1U << 6);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_RAW_CH%s Register bits
    namespace out_int_raw_ch%s_bits {
        constexpr uint32_t OUT_DONE_CH_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
        constexpr uint32_t OUT_EOF_CH_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
        constexpr uint32_t OUT_DSCR_ERR_CH_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
        constexpr uint32_t OUT_TOTAL_EOF_CH_INT_RAW = (1U << 3);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
        constexpr uint32_t OUTFIFO_OVF_CH_INT_RAW = (1U << 4);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF_CH_INT_RAW = (1U << 5);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
    }

    /// OUT_INT_ST_CH%s Register bits
    namespace out_int_st_ch%s_bits {
        constexpr uint32_t OUT_DONE_CH_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF_CH_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_CH_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_CH_INT_ST = (1U << 3);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_CH_INT_ST = (1U << 4);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_CH_INT_ST = (1U << 5);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_ENA_CH%s Register bits
    namespace out_int_ena_ch%s_bits {
        constexpr uint32_t OUT_DONE_CH_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF_CH_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_CH_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_CH_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_CH_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_CH_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// OUT_INT_CLR_CH%s Register bits
    namespace out_int_clr_ch%s_bits {
        constexpr uint32_t OUT_DONE_CH_INT_CLR = (1U << 0);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF_CH_INT_CLR = (1U << 1);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_CH_INT_CLR = (1U << 2);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_CH_INT_CLR = (1U << 3);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_CH_INT_CLR = (1U << 4);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_CH_INT_CLR = (1U << 5);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< reserved
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< reserved
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t AHBM_RST_INTER = (1U << 0);  ///< Set this bit then clear this bit to reset the internal ahb FSM.
        constexpr uint32_t ARB_PRI_DIS = (1U << 2);  ///< Set this bit to disable priority arbitration function.
        constexpr uint32_t CLK_EN = (1U << 3);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

    /// IN_CONF0_CH%s Register bits
    namespace in_conf0_ch%s_bits {
        constexpr uint32_t IN_RST_CH = (1U << 0);  ///< This bit is used to reset AHB_DMA channel 0 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST_CH = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN_CH = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN_CH = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN_CH = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via AHB_DMA.
        constexpr uint32_t IN_ETM_EN_CH = (1U << 5);  ///< Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
    }

    /// IN_CONF1_CH%s Register bits
    namespace in_conf1_ch%s_bits {
        constexpr uint32_t IN_CHECK_OWNER_CH = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// INFIFO_STATUS_CH%s Register bits
    namespace infifo_status_ch%s_bits {
        constexpr uint32_t INFIFO_FULL_CH = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY_CH = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_CNT_CH = (6 << 2);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
        constexpr uint32_t IN_REMAIN_UNDER_1B_CH = (1U << 23);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B_CH = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B_CH = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B_CH = (1U << 26);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY_CH = (1U << 27);  ///< reserved
    }

    /// IN_POP_CH%s Register bits
    namespace in_pop_ch%s_bits {
        constexpr uint32_t INFIFO_RDATA_CH = (12 << 0);  ///< This register stores the data popping from AHB_DMA FIFO.
        constexpr uint32_t INFIFO_POP_CH = (1U << 12);  ///< Set this bit to pop data from AHB_DMA FIFO.
    }

    /// IN_LINK_CH%s Register bits
    namespace in_link_ch%s_bits {
        constexpr uint32_t INLINK_AUTO_RET_CH = (1U << 0);  ///< Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP_CH = (1U << 1);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START_CH = (1U << 2);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART_CH = (1U << 3);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK_CH = (1U << 4);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH%s Register bits
    namespace in_state_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_ADDR_CH = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE_CH = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE_CH = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH%s Register bits
    namespace in_suc_eof_des_addr_ch%s_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR_CH = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH%s Register bits
    namespace in_err_eof_des_addr_ch%s_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR_CH = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH%s Register bits
    namespace in_dscr_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_CH = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH%s Register bits
    namespace in_dscr_bf0_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_BF0_CH = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH%s Register bits
    namespace in_dscr_bf1_ch%s_bits {
        constexpr uint32_t INLINK_DSCR_BF1_CH = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_PRI_CH%s Register bits
    namespace in_pri_ch%s_bits {
        constexpr uint32_t RX_PRI_CH = (4 << 0);  ///< The priority of Rx channel 0. The larger of the value the higher of the priority.
    }

    /// IN_PERI_SEL_CH%s Register bits
    namespace in_peri_sel_ch%s_bits {
        constexpr uint32_t PERI_IN_SEL_CH = (6 << 0);  ///< This register is used to select peripheral for Rx channel 0. I3C. 1: Dummy. 2: UHCI0. 3: I2S0. 4: I2S1. 5: I2S2. 6: Dummy. 7: Dummy. 8: ADC_DAC. 9: Dummy. 10: RMT,11~15: Dummy
    }

    /// OUT_CONF0_CH0 Register bits
    namespace out_conf0_ch0_bits {
        constexpr uint32_t OUT_RST_CH0 = (1U << 0);  ///< This bit is used to reset AHB_DMA channel 0 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST_CH0 = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK_CH0 = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE_CH0 = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 0 is generated when data need to transmit has been popped from FIFO in AHB_DMA
        constexpr uint32_t OUTDSCR_BURST_EN_CH0 = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN_CH0 = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 transmitting data when accessing internal SRAM.
        constexpr uint32_t OUT_ETM_EN_CH0 = (1U << 6);  ///< Set this bit to 1 to enable etm control mode, dma Tx channel 0 is triggered by etm task.
    }

    /// OUT_CONF1_CH%s Register bits
    namespace out_conf1_ch%s_bits {
        constexpr uint32_t OUT_CHECK_OWNER_CH = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
    }

    /// OUTFIFO_STATUS_CH%s Register bits
    namespace outfifo_status_ch%s_bits {
        constexpr uint32_t OUTFIFO_FULL_CH = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY_CH = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT_CH = (6 << 2);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUT_REMAIN_UNDER_1B_CH = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B_CH = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B_CH = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B_CH = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH%s Register bits
    namespace out_push_ch%s_bits {
        constexpr uint32_t OUTFIFO_WDATA_CH = (9 << 0);  ///< This register stores the data that need to be pushed into AHB_DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH_CH = (1U << 9);  ///< Set this bit to push data into AHB_DMA FIFO.
    }

    /// OUT_LINK_CH%s Register bits
    namespace out_link_ch%s_bits {
        constexpr uint32_t OUTLINK_STOP_CH = (1U << 0);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START_CH = (1U << 1);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART_CH = (1U << 2);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK_CH = (1U << 3);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH%s Register bits
    namespace out_state_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR_CH = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE_CH = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE_CH = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH%s Register bits
    namespace out_eof_des_addr_ch%s_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR_CH = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH%s Register bits
    namespace out_eof_bfr_des_addr_ch%s_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR_CH = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH%s Register bits
    namespace out_dscr_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_CH = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH%s Register bits
    namespace out_dscr_bf0_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0_CH = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH%s Register bits
    namespace out_dscr_bf1_ch%s_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1_CH = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_PRI_CH%s Register bits
    namespace out_pri_ch%s_bits {
        constexpr uint32_t TX_PRI_CH = (4 << 0);  ///< The priority of Tx channel 0. The larger of the value the higher of the priority.
    }

    /// OUT_PERI_SEL_CH%s Register bits
    namespace out_peri_sel_ch%s_bits {
        constexpr uint32_t PERI_OUT_SEL_CH = (6 << 0);  ///< This register is used to select peripheral for Tx channel 0. I3C. 1: Dummy. 2: UHCI0. 3: I2S0. 4: I2S1. 5: I2S2. 6: Dummy. 7: Dummy. 8: ADC_DAC. 9: Dummy. 10: RMT,11~15: Dummy
    }

    /// OUT_CONF0_CH%s Register bits
    namespace out_conf0_ch%s_bits {
        constexpr uint32_t OUT_RST_CH = (1U << 0);  ///< This bit is used to reset AHB_DMA channel 1 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST_CH = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK_CH = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE_CH = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in AHB_DMA
        constexpr uint32_t OUTDSCR_BURST_EN_CH = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN_CH = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
        constexpr uint32_t OUT_ETM_EN_CH = (1U << 6);  ///< Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
    }

    /// OUT_CRC_INIT_DATA_CH%s Register bits
    namespace out_crc_init_data_ch%s_bits {
        constexpr uint32_t OUT_CRC_INIT_DATA_CH = (32 << 0);  ///< This register is used to config ch0 of tx crc initial value
    }

    /// TX_CRC_WIDTH_CH%s Register bits
    namespace tx_crc_width_ch%s_bits {
        constexpr uint32_t TX_CRC_WIDTH_CH = (2 << 0);  ///< reserved
        constexpr uint32_t TX_CRC_LAUTCH_FLGA_CH = (1U << 2);  ///< reserved
    }

    /// OUT_CRC_CLEAR_CH%s Register bits
    namespace out_crc_clear_ch%s_bits {
        constexpr uint32_t OUT_CRC_CLEAR_CH = (1U << 0);  ///< This register is used to clear ch0 of tx crc result
    }

    /// OUT_CRC_FINAL_RESULT_CH%s Register bits
    namespace out_crc_final_result_ch%s_bits {
        constexpr uint32_t OUT_CRC_FINAL_RESULT_CH = (32 << 0);  ///< This register is used to store result ch0 of tx
    }

    /// TX_CRC_EN_WR_DATA_CH%s Register bits
    namespace tx_crc_en_wr_data_ch%s_bits {
        constexpr uint32_t TX_CRC_EN_WR_DATA_CH = (32 << 0);  ///< This register is used to enable tx ch0 crc 32bit on/off
    }

    /// TX_CRC_EN_ADDR_CH%s Register bits
    namespace tx_crc_en_addr_ch%s_bits {
        constexpr uint32_t TX_CRC_EN_ADDR_CH = (32 << 0);  ///< reserved
    }

    /// TX_CRC_DATA_EN_WR_DATA_CH%s Register bits
    namespace tx_crc_data_en_wr_data_ch%s_bits {
        constexpr uint32_t TX_CRC_DATA_EN_WR_DATA_CH = (8 << 0);  ///< reserved
    }

    /// TX_CRC_DATA_EN_ADDR_CH%s Register bits
    namespace tx_crc_data_en_addr_ch%s_bits {
        constexpr uint32_t TX_CRC_DATA_EN_ADDR_CH = (32 << 0);  ///< reserved
    }

    /// TX_CH_ARB_WEIGH_CH%s Register bits
    namespace tx_ch_arb_weigh_ch%s_bits {
        constexpr uint32_t TX_CH_ARB_WEIGH_CH = (4 << 0);  ///< reserved
    }

    /// TX_ARB_WEIGH_OPT_DIR_CH%s Register bits
    namespace tx_arb_weigh_opt_dir_ch%s_bits {
        constexpr uint32_t TX_ARB_WEIGH_OPT_DIR_CH = (1U << 0);  ///< reserved
    }

    /// IN_CRC_INIT_DATA_CH%s Register bits
    namespace in_crc_init_data_ch%s_bits {
        constexpr uint32_t IN_CRC_INIT_DATA_CH = (32 << 0);  ///< This register is used to config ch0 of rx crc initial value
    }

    /// RX_CRC_WIDTH_CH%s Register bits
    namespace rx_crc_width_ch%s_bits {
        constexpr uint32_t RX_CRC_WIDTH_CH = (2 << 0);  ///< reserved
        constexpr uint32_t RX_CRC_LAUTCH_FLGA_CH = (1U << 2);  ///< reserved
    }

    /// IN_CRC_CLEAR_CH%s Register bits
    namespace in_crc_clear_ch%s_bits {
        constexpr uint32_t IN_CRC_CLEAR_CH = (1U << 0);  ///< This register is used to clear ch0 of rx crc result
    }

    /// IN_CRC_FINAL_RESULT_CH%s Register bits
    namespace in_crc_final_result_ch%s_bits {
        constexpr uint32_t IN_CRC_FINAL_RESULT_CH = (32 << 0);  ///< This register is used to store result ch0 of rx
    }

    /// RX_CRC_EN_WR_DATA_CH%s Register bits
    namespace rx_crc_en_wr_data_ch%s_bits {
        constexpr uint32_t RX_CRC_EN_WR_DATA_CH = (32 << 0);  ///< This register is used to enable rx ch0 crc 32bit on/off
    }

    /// RX_CRC_EN_ADDR_CH%s Register bits
    namespace rx_crc_en_addr_ch%s_bits {
        constexpr uint32_t RX_CRC_EN_ADDR_CH = (32 << 0);  ///< reserved
    }

    /// RX_CRC_DATA_EN_WR_DATA_CH%s Register bits
    namespace rx_crc_data_en_wr_data_ch%s_bits {
        constexpr uint32_t RX_CRC_DATA_EN_WR_DATA_CH = (8 << 0);  ///< reserved
    }

    /// RX_CRC_DATA_EN_ADDR_CH%s Register bits
    namespace rx_crc_data_en_addr_ch%s_bits {
        constexpr uint32_t RX_CRC_DATA_EN_ADDR_CH = (32 << 0);  ///< reserved
    }

    /// RX_CH_ARB_WEIGH_CH%s Register bits
    namespace rx_ch_arb_weigh_ch%s_bits {
        constexpr uint32_t RX_CH_ARB_WEIGH_CH = (4 << 0);  ///< reserved
    }

    /// RX_ARB_WEIGH_OPT_DIR_CH%s Register bits
    namespace rx_arb_weigh_opt_dir_ch%s_bits {
        constexpr uint32_t RX_ARB_WEIGH_OPT_DIR_CH = (1U << 0);  ///< reserved
    }

    /// IN_LINK_ADDR_CH%s Register bits
    namespace in_link_addr_ch%s_bits {
        constexpr uint32_t INLINK_ADDR_CH = (32 << 0);  ///< This register stores the 32 least significant bits of the first inlink descriptor's address.
    }

    /// OUT_LINK_ADDR_CH%s Register bits
    namespace out_link_addr_ch%s_bits {
        constexpr uint32_t OUTLINK_ADDR_CH = (32 << 0);  ///< This register stores the 32 least significant bits of the first outlink descriptor's address.
    }

    /// INTR_MEM_START_ADDR Register bits
    namespace intr_mem_start_addr_bits {
        constexpr uint32_t ACCESS_INTR_MEM_START_ADDR = (32 << 0);  ///< The start address of accessible address space.
    }

    /// INTR_MEM_END_ADDR Register bits
    namespace intr_mem_end_addr_bits {
        constexpr uint32_t ACCESS_INTR_MEM_END_ADDR = (32 << 0);  ///< The end address of accessible address space. The access address beyond this range would lead to descriptor error.
    }

    /// ARB_TIMEOUT_TX Register bits
    namespace arb_timeout_tx_bits {
        constexpr uint32_t ARB_TIMEOUT_TX = (16 << 0);  ///< This register is used to config arbiter time out value
    }

    /// ARB_TIMEOUT_RX Register bits
    namespace arb_timeout_rx_bits {
        constexpr uint32_t ARB_TIMEOUT_RX = (16 << 0);  ///< This register is used to config arbiter time out value
    }

    /// WEIGHT_EN_TX Register bits
    namespace weight_en_tx_bits {
        constexpr uint32_t WEIGHT_EN_TX = (1U << 0);  ///< This register is used to config arbiter weight function off/on
    }

    /// WEIGHT_EN_RX Register bits
    namespace weight_en_rx_bits {
        constexpr uint32_t WEIGHT_EN_RX = (1U << 0);  ///< This register is used to config arbiter weight function off/on
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LP_I2C_ANA_MST_BASE = 0x50124000;
    constexpr uint32_t I2C0_BASE = 0x500C4000;
    constexpr uint32_t I2C1_BASE = 0x500C5000;
    constexpr uint32_t LP_I2C0_BASE = 0x50122000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t I2C0_CTRL;  ///< Offset: 0x00 - need des
        volatile uint32_t I2C1_CTRL;  ///< Offset: 0x04 - need des
        volatile uint32_t I2C0_CONF;  ///< Offset: 0x08 - need des
        volatile uint32_t I2C1_CONF;  ///< Offset: 0x0C - need des
        volatile uint32_t I2C_BURST_CONF;  ///< Offset: 0x10 - need des
        volatile uint32_t I2C_BURST_STATUS;  ///< Offset: 0x14 - need des
        volatile uint32_t ANA_CONF0;  ///< Offset: 0x18 - need des
        volatile uint32_t ANA_CONF1;  ///< Offset: 0x1C - need des
        volatile uint32_t ANA_CONF2;  ///< Offset: 0x20 - need des
        volatile uint32_t I2C0_CTRL1;  ///< Offset: 0x24 - need des
        volatile uint32_t I2C1_CTRL1;  ///< Offset: 0x28 - need des
        volatile uint32_t HW_I2C_CTRL;  ///< Offset: 0x2C - need des
        volatile uint32_t NOUSE;  ///< Offset: 0x30 - need des
        volatile uint32_t CLK160M;  ///< Offset: 0x34 - need des
        volatile uint32_t DATE;  ///< Offset: 0x38 - need des
    };

    /// Peripheral instances
    inline Registers* LP_I2C_ANA_MST = reinterpret_cast<Registers*>(LP_I2C_ANA_MST_BASE);
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* LP_I2C0 = reinterpret_cast<Registers*>(LP_I2C0_BASE);

    // Bit definitions
    /// I2C0_CTRL Register bits
    namespace i2c0_ctrl_bits {
        constexpr uint32_t I2C0_CTRL = (25 << 0);  ///< need des
        constexpr uint32_t I2C0_BUSY = (1U << 25);  ///< need des
    }

    /// I2C1_CTRL Register bits
    namespace i2c1_ctrl_bits {
        constexpr uint32_t I2C1_CTRL = (25 << 0);  ///< need des
        constexpr uint32_t I2C1_BUSY = (1U << 25);  ///< need des
    }

    /// I2C0_CONF Register bits
    namespace i2c0_conf_bits {
        constexpr uint32_t I2C0_CONF = (24 << 0);  ///< need des
        constexpr uint32_t I2C0_STATUS = (8 << 24);  ///< need des
    }

    /// I2C1_CONF Register bits
    namespace i2c1_conf_bits {
        constexpr uint32_t I2C1_CONF = (24 << 0);  ///< need des
        constexpr uint32_t I2C1_STATUS = (8 << 24);  ///< need des
    }

    /// I2C_BURST_CONF Register bits
    namespace i2c_burst_conf_bits {
        constexpr uint32_t I2C_MST_BURST_CTRL = (32 << 0);  ///< need des
    }

    /// I2C_BURST_STATUS Register bits
    namespace i2c_burst_status_bits {
        constexpr uint32_t I2C_MST_BURST_DONE = (1U << 0);  ///< need des
        constexpr uint32_t I2C_MST0_BURST_ERR_FLAG = (1U << 1);  ///< need des
        constexpr uint32_t I2C_MST1_BURST_ERR_FLAG = (1U << 2);  ///< need des
        constexpr uint32_t I2C_MST_BURST_TIMEOUT_CNT = (12 << 20);  ///< need des
    }

    /// ANA_CONF0 Register bits
    namespace ana_conf0_bits {
        constexpr uint32_t ANA_CONF0 = (24 << 0);  ///< need des
        constexpr uint32_t ANA_STATUS0 = (8 << 24);  ///< need des
    }

    /// ANA_CONF1 Register bits
    namespace ana_conf1_bits {
        constexpr uint32_t ANA_CONF1 = (24 << 0);  ///< need des
        constexpr uint32_t ANA_STATUS1 = (8 << 24);  ///< need des
    }

    /// ANA_CONF2 Register bits
    namespace ana_conf2_bits {
        constexpr uint32_t ANA_CONF2 = (24 << 0);  ///< need des
        constexpr uint32_t ANA_STATUS2 = (8 << 24);  ///< need des
    }

    /// I2C0_CTRL1 Register bits
    namespace i2c0_ctrl1_bits {
        constexpr uint32_t I2C0_SCL_PULSE_DUR = (6 << 0);  ///< need des
        constexpr uint32_t I2C0_SDA_SIDE_GUARD = (5 << 6);  ///< need des
    }

    /// I2C1_CTRL1 Register bits
    namespace i2c1_ctrl1_bits {
        constexpr uint32_t I2C1_SCL_PULSE_DUR = (6 << 0);  ///< need des
        constexpr uint32_t I2C1_SDA_SIDE_GUARD = (5 << 6);  ///< need des
    }

    /// HW_I2C_CTRL Register bits
    namespace hw_i2c_ctrl_bits {
        constexpr uint32_t HW_I2C_SCL_PULSE_DUR = (6 << 0);  ///< need des
        constexpr uint32_t HW_I2C_SDA_SIDE_GUARD = (5 << 6);  ///< need des
        constexpr uint32_t ARBITER_DIS = (1U << 11);  ///< need des
    }

    /// NOUSE Register bits
    namespace nouse_bits {
        constexpr uint32_t I2C_MST_NOUSE = (32 << 0);  ///< need des
    }

    /// CLK160M Register bits
    namespace clk160m_bits {
        constexpr uint32_t CLK_I2C_MST_SEL_160M = (1U << 0);  ///< need des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< need des
        constexpr uint32_t I2C_MST_CLK_EN = (1U << 28);  ///< need des
    }

}

// ============================================================================
// ASSIST Peripheral
// ============================================================================

namespace assist {
    /// Base addresses
    constexpr uint32_t ASSIST_DEBUG_BASE = 0x3FF06000;

    /// ASSIST Register structure
    struct Registers {
        volatile uint32_t CORE_0_INTR_ENA;  ///< Offset: 0x00 - core0 monitor enable configuration register
        volatile uint32_t CORE_0_INTR_RAW;  ///< Offset: 0x04 - core0 monitor interrupt status register
        volatile uint32_t CORE_0_INTR_RLS;  ///< Offset: 0x08 - core0 monitor interrupt enable register
        volatile uint32_t CORE_0_INTR_CLR;  ///< Offset: 0x0C - core0 monitor interrupt clr register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MIN;  ///< Offset: 0x10 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MAX;  ///< Offset: 0x14 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MIN;  ///< Offset: 0x18 - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MAX;  ///< Offset: 0x1C - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MIN;  ///< Offset: 0x20 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MAX;  ///< Offset: 0x24 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MIN;  ///< Offset: 0x28 - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MAX;  ///< Offset: 0x2C - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PC;  ///< Offset: 0x30 - core0 area pc status register
        volatile uint32_t CORE_0_AREA_SP;  ///< Offset: 0x34 - core0 area sp status register
        volatile uint32_t CORE_0_SP_MIN;  ///< Offset: 0x38 - stack min value
        volatile uint32_t CORE_0_SP_MAX;  ///< Offset: 0x3C - stack max value
        volatile uint32_t CORE_0_SP_PC;  ///< Offset: 0x40 - stack monitor pc status register
        volatile uint32_t CORE_0_RCD_EN;  ///< Offset: 0x44 - record enable configuration register
        volatile uint32_t CORE_0_RCD_PDEBUGPC;  ///< Offset: 0x48 - record status regsiter
        volatile uint32_t CORE_0_RCD_PDEBUGSP;  ///< Offset: 0x4C - record status regsiter
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x50 - exception monitor status register0
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x54 - exception monitor status register1
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x58 - exception monitor status register2
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x5C - exception monitor status register3
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0x60 - exception monitor status register4
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0x64 - exception monitor status register5
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_4;  ///< Offset: 0x68 - exception monitor status register6
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_5;  ///< Offset: 0x6C - exception monitor status register7
        volatile uint32_t CORE_0_LASTPC_BEFORE_EXCEPTION;  ///< Offset: 0x70 - cpu status register
        volatile uint32_t CORE_0_DEBUG_MODE;  ///< Offset: 0x74 - cpu status register
        volatile uint32_t CORE_1_INTR_ENA;  ///< Offset: 0x80 - core1 monitor enable configuration register
        volatile uint32_t CORE_1_INTR_RAW;  ///< Offset: 0x84 - core1 monitor interrupt status register
        volatile uint32_t CORE_1_INTR_RLS;  ///< Offset: 0x88 - core1 monitor interrupt enable register
        volatile uint32_t CORE_1_INTR_CLR;  ///< Offset: 0x8C - core1 monitor interrupt clr register
        volatile uint32_t CORE_1_AREA_DRAM0_0_MIN;  ///< Offset: 0x90 - core1 dram0 region0 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_0_MAX;  ///< Offset: 0x94 - core1 dram0 region0 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_1_MIN;  ///< Offset: 0x98 - core1 dram0 region1 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_1_MAX;  ///< Offset: 0x9C - core1 dram0 region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_0_MIN;  ///< Offset: 0xA0 - core1 PIF region0 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_0_MAX;  ///< Offset: 0xA4 - core1 PIF region0 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_1_MIN;  ///< Offset: 0xA8 - core1 PIF region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_1_MAX;  ///< Offset: 0xAC - core1 PIF region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PC;  ///< Offset: 0xB0 - core1 area pc status register
        volatile uint32_t CORE_1_AREA_SP;  ///< Offset: 0xB4 - core1 area sp status register
        volatile uint32_t CORE_1_SP_MIN;  ///< Offset: 0xB8 - stack min value
        volatile uint32_t CORE_1_SP_MAX;  ///< Offset: 0xBC - stack max value
        volatile uint32_t CORE_1_SP_PC;  ///< Offset: 0xC0 - stack monitor pc status register
        volatile uint32_t CORE_1_RCD_EN;  ///< Offset: 0xC4 - record enable configuration register
        volatile uint32_t CORE_1_RCD_PDEBUGPC;  ///< Offset: 0xC8 - record status regsiter
        volatile uint32_t CORE_1_RCD_PDEBUGSP;  ///< Offset: 0xCC - record status regsiter
        volatile uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0xD0 - exception monitor status register0
        volatile uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0xD4 - exception monitor status register1
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0xD8 - exception monitor status register2
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0xDC - exception monitor status register3
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0xE0 - exception monitor status register4
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0xE4 - exception monitor status register5
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_4;  ///< Offset: 0xE8 - exception monitor status register6
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_5;  ///< Offset: 0xEC - exception monitor status register7
        volatile uint32_t CORE_1_LASTPC_BEFORE_EXCEPTION;  ///< Offset: 0xF0 - cpu status register
        volatile uint32_t CORE_1_DEBUG_MODE;  ///< Offset: 0xF4 - cpu status register
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x100 - exception monitor status register6
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x104 - exception monitor status register7
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x108 - clock register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - version register
    };

    /// Peripheral instances
    inline Registers* ASSIST_DEBUG = reinterpret_cast<Registers*>(ASSIST_DEBUG_BASE);

    // Bit definitions
    /// CORE_0_INTR_ENA Register bits
    namespace core_0_intr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< Core0 dram0 area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< Core0 dram0 area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< Core0 dram0 area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< Core0 dram0 area1 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_ENA = (1U << 4);  ///< Core0 PIF area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_ENA = (1U << 5);  ///< Core0 PIF area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_ENA = (1U << 6);  ///< Core0 PIF area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_ENA = (1U << 7);  ///< Core0 PIF area1 write monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_ENA = (1U << 8);  ///< Core0 stackpoint underflow monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_ENA = (1U << 9);  ///< Core0 stackpoint overflow monitor enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< IBUS busy monitor enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< DBUS busy monitor enbale
    }

    /// CORE_0_INTR_RAW Register bits
    namespace core_0_intr_raw_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_RAW = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_RAW = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_RAW = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_RAW = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RAW = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RAW = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt status
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< IBUS busy monitor interrupt status
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< DBUS busy monitor initerrupt status
    }

    /// CORE_0_INTR_RLS Register bits
    namespace core_0_intr_rls_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_RLS = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_RLS = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_RLS = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_RLS = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_RLS = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_RLS = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_RLS = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_RLS = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RLS = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RLS = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RLS = (1U << 10);  ///< IBUS busy monitor interrupt enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RLS = (1U << 11);  ///< DBUS busy monitor interrupt enbale
    }

    /// CORE_0_INTR_CLR Register bits
    namespace core_0_intr_clr_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_CLR = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_CLR = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_CLR = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_CLR = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MIN_CLR = (1U << 8);  ///< Core0 stackpoint underflow monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MAX_CLR = (1U << 9);  ///< Core0 stackpoint overflow monitor interrupt clr
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< IBUS busy monitor interrupt clr
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< DBUS busy monitor interrupt clr
    }

    /// CORE_0_AREA_DRAM0_0_MIN Register bits
    namespace core_0_area_dram0_0_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MIN = (32 << 0);  ///< Core0 dram0 region0 start addr
    }

    /// CORE_0_AREA_DRAM0_0_MAX Register bits
    namespace core_0_area_dram0_0_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MAX = (32 << 0);  ///< Core0 dram0 region0 end addr
    }

    /// CORE_0_AREA_DRAM0_1_MIN Register bits
    namespace core_0_area_dram0_1_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MIN = (32 << 0);  ///< Core0 dram0 region1 start addr
    }

    /// CORE_0_AREA_DRAM0_1_MAX Register bits
    namespace core_0_area_dram0_1_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MAX = (32 << 0);  ///< Core0 dram0 region1 end addr
    }

    /// CORE_0_AREA_PIF_0_MIN Register bits
    namespace core_0_area_pif_0_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MIN = (32 << 0);  ///< Core0 PIF region0 start addr
    }

    /// CORE_0_AREA_PIF_0_MAX Register bits
    namespace core_0_area_pif_0_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MAX = (32 << 0);  ///< Core0 PIF region0 end addr
    }

    /// CORE_0_AREA_PIF_1_MIN Register bits
    namespace core_0_area_pif_1_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MIN = (32 << 0);  ///< Core0 PIF region1 start addr
    }

    /// CORE_0_AREA_PIF_1_MAX Register bits
    namespace core_0_area_pif_1_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MAX = (32 << 0);  ///< Core0 PIF region1 end addr
    }

    /// CORE_0_AREA_PC Register bits
    namespace core_0_area_pc_bits {
        constexpr uint32_t CORE_0_AREA_PC = (32 << 0);  ///< the stackpointer when first touch region monitor interrupt
    }

    /// CORE_0_AREA_SP Register bits
    namespace core_0_area_sp_bits {
        constexpr uint32_t CORE_0_AREA_SP = (32 << 0);  ///< the PC when first touch region monitor interrupt
    }

    /// CORE_0_SP_MIN Register bits
    namespace core_0_sp_min_bits {
        constexpr uint32_t CORE_0_SP_MIN = (32 << 0);  ///< core0 sp region configuration regsiter
    }

    /// CORE_0_SP_MAX Register bits
    namespace core_0_sp_max_bits {
        constexpr uint32_t CORE_0_SP_MAX = (32 << 0);  ///< core0 sp pc status register
    }

    /// CORE_0_SP_PC Register bits
    namespace core_0_sp_pc_bits {
        constexpr uint32_t CORE_0_SP_PC = (32 << 0);  ///< This regsiter stores the PC when trigger stack monitor.
    }

    /// CORE_0_RCD_EN Register bits
    namespace core_0_rcd_en_bits {
        constexpr uint32_t CORE_0_RCD_RECORDEN = (1U << 0);  ///< Set 1 to enable record PC
        constexpr uint32_t CORE_0_RCD_PDEBUGEN = (1U << 1);  ///< Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
    }

    /// CORE_0_RCD_PDEBUGPC Register bits
    namespace core_0_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGPC = (32 << 0);  ///< recorded PC
    }

    /// CORE_0_RCD_PDEBUGSP Register bits
    namespace core_0_rcd_pdebugsp_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGSP = (32 << 0);  ///< recorded sp
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_0
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_0
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_iram0_recording_addr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_0_iram0_recording_wr_1
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< reg_core_0_iram0_recording_loadstore_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_0 = (1U << 0);  ///< reg_core_0_dram0_recording_wr_0
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_0 = (16 << 1);  ///< reg_core_0_dram0_recording_byteen_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_0_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_0
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_0_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_1 = (1U << 0);  ///< reg_core_0_dram0_recording_wr_1
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_1 = (16 << 1);  ///< reg_core_0_dram0_recording_byteen_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_4 Register bits
    namespace core_0_dram0_exception_monitor_4_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_0_dram0_recording_addr_1
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_5 Register bits
    namespace core_0_dram0_exception_monitor_5_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< reg_core_0_dram0_recording_pc_1
    }

    /// CORE_0_LASTPC_BEFORE_EXCEPTION Register bits
    namespace core_0_lastpc_before_exception_bits {
        constexpr uint32_t CORE_0_LASTPC_BEFORE_EXC = (32 << 0);  ///< cpu's lastpc before exception
    }

    /// CORE_0_DEBUG_MODE Register bits
    namespace core_0_debug_mode_bits {
        constexpr uint32_t CORE_0_DEBUG_MODE = (1U << 0);  ///< cpu debug mode status, 1 means cpu enter debug mode.
        constexpr uint32_t CORE_0_DEBUG_MODULE_ACTIVE = (1U << 1);  ///< cpu debug_module active status
    }

    /// CORE_1_INTR_ENA Register bits
    namespace core_1_intr_ena_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< Core1 dram0 area0 read monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< Core1 dram0 area0 write monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< Core1 dram0 area1 read monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< Core1 dram0 area1 write monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_ENA = (1U << 4);  ///< Core1 PIF area0 read monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_ENA = (1U << 5);  ///< Core1 PIF area0 write monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_ENA = (1U << 6);  ///< Core1 PIF area1 read monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_ENA = (1U << 7);  ///< Core1 PIF area1 write monitor enable
        constexpr uint32_t CORE_1_SP_SPILL_MIN_ENA = (1U << 8);  ///< Core1 stackpoint underflow monitor enable
        constexpr uint32_t CORE_1_SP_SPILL_MAX_ENA = (1U << 9);  ///< Core1 stackpoint overflow monitor enable
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< IBUS busy monitor enable
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< DBUS busy monitor enbale
    }

    /// CORE_1_INTR_RAW Register bits
    namespace core_1_intr_raw_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_RAW = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_RAW = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_RAW = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_RAW = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt status
        constexpr uint32_t CORE_1_SP_SPILL_MIN_RAW = (1U << 8);  ///< Core1 stackpoint underflow monitor interrupt status
        constexpr uint32_t CORE_1_SP_SPILL_MAX_RAW = (1U << 9);  ///< Core1 stackpoint overflow monitor interrupt status
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< IBUS busy monitor interrupt status
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< DBUS busy monitor initerrupt status
    }

    /// CORE_1_INTR_RLS Register bits
    namespace core_1_intr_rls_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_RLS = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_RLS = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_RLS = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_RLS = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_RLS = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_RLS = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_RLS = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_RLS = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt enable
        constexpr uint32_t CORE_1_SP_SPILL_MIN_RLS = (1U << 8);  ///< Core1 stackpoint underflow monitor interrupt enable
        constexpr uint32_t CORE_1_SP_SPILL_MAX_RLS = (1U << 9);  ///< Core1 stackpoint overflow monitor interrupt enable
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_RLS = (1U << 10);  ///< IBUS busy monitor interrupt enable
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_RLS = (1U << 11);  ///< DBUS busy monitor interrupt enbale
    }

    /// CORE_1_INTR_CLR Register bits
    namespace core_1_intr_clr_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_CLR = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_CLR = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_CLR = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_CLR = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt clr
        constexpr uint32_t CORE_1_SP_SPILL_MIN_CLR = (1U << 8);  ///< Core1 stackpoint underflow monitor interrupt clr
        constexpr uint32_t CORE_1_SP_SPILL_MAX_CLR = (1U << 9);  ///< Core1 stackpoint overflow monitor interrupt clr
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< IBUS busy monitor interrupt clr
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< DBUS busy monitor interrupt clr
    }

    /// CORE_1_AREA_DRAM0_0_MIN Register bits
    namespace core_1_area_dram0_0_min_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_MIN = (32 << 0);  ///< Core1 dram0 region0 start addr
    }

    /// CORE_1_AREA_DRAM0_0_MAX Register bits
    namespace core_1_area_dram0_0_max_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_MAX = (32 << 0);  ///< Core1 dram0 region0 end addr
    }

    /// CORE_1_AREA_DRAM0_1_MIN Register bits
    namespace core_1_area_dram0_1_min_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_1_MIN = (32 << 0);  ///< Core1 dram0 region1 start addr
    }

    /// CORE_1_AREA_DRAM0_1_MAX Register bits
    namespace core_1_area_dram0_1_max_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_1_MAX = (32 << 0);  ///< Core1 dram0 region1 end addr
    }

    /// CORE_1_AREA_PIF_0_MIN Register bits
    namespace core_1_area_pif_0_min_bits {
        constexpr uint32_t CORE_1_AREA_PIF_0_MIN = (32 << 0);  ///< Core1 PIF region0 start addr
    }

    /// CORE_1_AREA_PIF_0_MAX Register bits
    namespace core_1_area_pif_0_max_bits {
        constexpr uint32_t CORE_1_AREA_PIF_0_MAX = (32 << 0);  ///< Core1 PIF region0 end addr
    }

    /// CORE_1_AREA_PIF_1_MIN Register bits
    namespace core_1_area_pif_1_min_bits {
        constexpr uint32_t CORE_1_AREA_PIF_1_MIN = (32 << 0);  ///< Core1 PIF region1 start addr
    }

    /// CORE_1_AREA_PIF_1_MAX Register bits
    namespace core_1_area_pif_1_max_bits {
        constexpr uint32_t CORE_1_AREA_PIF_1_MAX = (32 << 0);  ///< Core1 PIF region1 end addr
    }

    /// CORE_1_AREA_PC Register bits
    namespace core_1_area_pc_bits {
        constexpr uint32_t CORE_1_AREA_PC = (32 << 0);  ///< the stackpointer when first touch region monitor interrupt
    }

    /// CORE_1_AREA_SP Register bits
    namespace core_1_area_sp_bits {
        constexpr uint32_t CORE_1_AREA_SP = (32 << 0);  ///< the PC when first touch region monitor interrupt
    }

    /// CORE_1_SP_MIN Register bits
    namespace core_1_sp_min_bits {
        constexpr uint32_t CORE_1_SP_MIN = (32 << 0);  ///< core1 sp region configuration regsiter
    }

    /// CORE_1_SP_MAX Register bits
    namespace core_1_sp_max_bits {
        constexpr uint32_t CORE_1_SP_MAX = (32 << 0);  ///< core1 sp pc status register
    }

    /// CORE_1_SP_PC Register bits
    namespace core_1_sp_pc_bits {
        constexpr uint32_t CORE_1_SP_PC = (32 << 0);  ///< This regsiter stores the PC when trigger stack monitor.
    }

    /// CORE_1_RCD_EN Register bits
    namespace core_1_rcd_en_bits {
        constexpr uint32_t CORE_1_RCD_RECORDEN = (1U << 0);  ///< Set 1 to enable record PC
        constexpr uint32_t CORE_1_RCD_PDEBUGEN = (1U << 1);  ///< Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
    }

    /// CORE_1_RCD_PDEBUGPC Register bits
    namespace core_1_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGPC = (32 << 0);  ///< recorded PC
    }

    /// CORE_1_RCD_PDEBUGSP Register bits
    namespace core_1_rcd_pdebugsp_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGSP = (32 << 0);  ///< recorded sp
    }

    /// CORE_1_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_1_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_1_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_1_iram0_recording_addr_0
        constexpr uint32_t CORE_1_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< reg_core_1_iram0_recording_wr_0
        constexpr uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< reg_core_1_iram0_recording_loadstore_0
    }

    /// CORE_1_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_1_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_1_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_1_iram0_recording_addr_1
        constexpr uint32_t CORE_1_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< reg_core_1_iram0_recording_wr_1
        constexpr uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< reg_core_1_iram0_recording_loadstore_1
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_1_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_WR_0 = (1U << 0);  ///< reg_core_1_dram0_recording_wr_0
        constexpr uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_0 = (16 << 1);  ///< reg_core_1_dram0_recording_byteen_0
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_1_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< reg_core_1_dram0_recording_addr_0
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_1_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< reg_core_1_dram0_recording_pc_0
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_1_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_WR_1 = (1U << 0);  ///< reg_core_1_dram0_recording_wr_1
        constexpr uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_1 = (16 << 1);  ///< reg_core_1_dram0_recording_byteen_1
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_4 Register bits
    namespace core_1_dram0_exception_monitor_4_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< reg_core_1_dram0_recording_addr_1
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_5 Register bits
    namespace core_1_dram0_exception_monitor_5_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< reg_core_1_dram0_recording_pc_1
    }

    /// CORE_1_LASTPC_BEFORE_EXCEPTION Register bits
    namespace core_1_lastpc_before_exception_bits {
        constexpr uint32_t CORE_1_LASTPC_BEFORE_EXC = (32 << 0);  ///< cpu's lastpc before exception
    }

    /// CORE_1_DEBUG_MODE Register bits
    namespace core_1_debug_mode_bits {
        constexpr uint32_t CORE_1_DEBUG_MODE = (1U << 0);  ///< cpu debug mode status, 1 means cpu enter debug mode.
        constexpr uint32_t CORE_1_DEBUG_MODULE_ACTIVE = (1U << 1);  ///< cpu debug_module active status
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_x_iram0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_0
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_x_iram0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 = (20 << 0);  ///< reg_core_x_iram0_dram0_limit_cycle_1
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Set 1 force on the clock gate
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t ASSIST_DEBUG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// RADIO Peripheral
// ============================================================================

namespace radio {
    /// Base addresses
    constexpr uint32_t BITSCRAMBLER_BASE = 0x500A3000;

    /// RADIO Register structure
    struct Registers {
        volatile uint32_t TX_INST_CFG0;  ///< Offset: 0x00 - Control and configuration registers
        volatile uint32_t TX_INST_CFG1;  ///< Offset: 0x04 - Control and configuration registers
        volatile uint32_t RX_INST_CFG0;  ///< Offset: 0x08 - Control and configuration registers
        volatile uint32_t RX_INST_CFG1;  ///< Offset: 0x0C - Control and configuration registers
        volatile uint32_t TX_LUT_CFG0;  ///< Offset: 0x10 - Control and configuration registers
        volatile uint32_t TX_LUT_CFG1;  ///< Offset: 0x14 - Control and configuration registers
        volatile uint32_t RX_LUT_CFG0;  ///< Offset: 0x18 - Control and configuration registers
        volatile uint32_t RX_LUT_CFG1;  ///< Offset: 0x1C - Control and configuration registers
        volatile uint32_t TX_TAILING_BITS;  ///< Offset: 0x20 - Control and configuration registers
        volatile uint32_t RX_TAILING_BITS;  ///< Offset: 0x24 - Control and configuration registers
        volatile uint32_t TX_CTRL;  ///< Offset: 0x28 - Control and configuration registers
        volatile uint32_t RX_CTRL;  ///< Offset: 0x2C - Control and configuration registers
        volatile uint32_t TX_STATE;  ///< Offset: 0x30 - Status registers
        volatile uint32_t RX_STATE;  ///< Offset: 0x34 - Status registers
        volatile uint32_t SYS;  ///< Offset: 0xF8 - Control and configuration registers
        volatile uint32_t VERSION;  ///< Offset: 0xFC - Control and configuration registers
    };

    /// Peripheral instances
    inline Registers* BITSCRAMBLER = reinterpret_cast<Registers*>(BITSCRAMBLER_BASE);

    // Bit definitions
    /// TX_INST_CFG0 Register bits
    namespace tx_inst_cfg0_bits {
        constexpr uint32_t TX_INST_IDX = (3 << 0);  ///< write this bits to specify the one of 8 instruction
        constexpr uint32_t TX_INST_POS = (4 << 3);  ///< write this bits to specify the bit position of 257 bit instruction which in units of 32 bits
    }

    /// TX_INST_CFG1 Register bits
    namespace tx_inst_cfg1_bits {
        constexpr uint32_t TX_INST = (32 << 0);  ///< write this bits to update instruction which specified by BITSCRAMBLER_TX_INST_CFG0_REG, Read this bits to get instruction which specified by BITSCRAMBLER_TX_INST_CFG0_REG
    }

    /// RX_INST_CFG0 Register bits
    namespace rx_inst_cfg0_bits {
        constexpr uint32_t RX_INST_IDX = (3 << 0);  ///< write this bits to specify the one of 8 instruction
        constexpr uint32_t RX_INST_POS = (4 << 3);  ///< write this bits to specify the bit position of 257 bit instruction which in units of 32 bits
    }

    /// RX_INST_CFG1 Register bits
    namespace rx_inst_cfg1_bits {
        constexpr uint32_t RX_INST = (32 << 0);  ///< write this bits to update instruction which specified by BITSCRAMBLER_RX_INST_CFG0_REG, Read this bits to get instruction which specified by BITSCRAMBLER_RX_INST_CFG0_REG
    }

    /// TX_LUT_CFG0 Register bits
    namespace tx_lut_cfg0_bits {
        constexpr uint32_t TX_LUT_IDX = (11 << 0);  ///< write this bits to specify the bytes position of LUT RAM based on reg_bitscrambler_tx_lut_mode
        constexpr uint32_t TX_LUT_MODE = (2 << 11);  ///< write this bits to specify the bytes mode of LUT RAM, 0: 1 byte,1: 2bytes, 2: 4 bytes
    }

    /// TX_LUT_CFG1 Register bits
    namespace tx_lut_cfg1_bits {
        constexpr uint32_t TX_LUT = (32 << 0);  ///< write this bits to update LUT which specified by BITSCRAMBLER_TX_LUT_CFG0_REG, Read this bits to get LUT which specified by BITSCRAMBLER_TX_LUT_CFG0_REG
    }

    /// RX_LUT_CFG0 Register bits
    namespace rx_lut_cfg0_bits {
        constexpr uint32_t RX_LUT_IDX = (11 << 0);  ///< write this bits to specify the bytes position of LUT RAM based on reg_bitscrambler_rx_lut_mode
        constexpr uint32_t RX_LUT_MODE = (2 << 11);  ///< write this bits to specify the bytes mode of LUT RAM, 0: 1 byte,1: 2bytes, 2: 4 bytes
    }

    /// RX_LUT_CFG1 Register bits
    namespace rx_lut_cfg1_bits {
        constexpr uint32_t RX_LUT = (32 << 0);  ///< write this bits to update LUT which specified by BITSCRAMBLER_RX_LUT_CFG0_REG, Read this bits to get LUT which specified by BITSCRAMBLER_RX_LUT_CFG0_REG
    }

    /// TX_TAILING_BITS Register bits
    namespace tx_tailing_bits_bits {
        constexpr uint32_t TX_TAILING_BITS = (16 << 0);  ///< write this bits to specify the extra data bit length after getting EOF
    }

    /// RX_TAILING_BITS Register bits
    namespace rx_tailing_bits_bits {
        constexpr uint32_t RX_TAILING_BITS = (16 << 0);  ///< write this bits to specify the extra data bit length after getting EOF
    }

    /// TX_CTRL Register bits
    namespace tx_ctrl_bits {
        constexpr uint32_t TX_ENA = (1U << 0);  ///< write this bit to enable the bitscrambler tx
        constexpr uint32_t TX_PAUSE = (1U << 1);  ///< write this bit to pause the bitscrambler tx core
        constexpr uint32_t TX_HALT = (1U << 2);  ///< write this bit to halt the bitscrambler tx core
        constexpr uint32_t TX_EOF_MODE = (1U << 3);  ///< write this bit to ser the bitscrambler tx core EOF signal generating mode which is combined with reg_bitscrambler_tx_tailing_bits, 0: counter by read dma fifo, 0 counter by write peripheral buffer
        constexpr uint32_t TX_COND_MODE = (1U << 4);  ///< write this bit to specify the LOOP instruction condition mode of bitscrambler tx core, 0: use the little than operator to get the condition, 1: use not equal operator to get the condition
        constexpr uint32_t TX_FETCH_MODE = (1U << 5);  ///< write this bit to set the bitscrambler tx core fetch instruction mode, 0: prefetch by reset, 1: fetch by instrutions
        constexpr uint32_t TX_HALT_MODE = (1U << 6);  ///< write this bit to set the bitscrambler tx core halt mode when tx_halt is set, 0: wait write data back done, , 1: ignore write data back
        constexpr uint32_t TX_RD_DUMMY = (1U << 7);  ///< write this bit to set the bitscrambler tx core read data mode when EOF received.0: wait read data, 1: ignore read data
        constexpr uint32_t TX_FIFO_RST = (1U << 8);  ///< write this bit to reset the bitscrambler tx fifo
    }

    /// RX_CTRL Register bits
    namespace rx_ctrl_bits {
        constexpr uint32_t RX_ENA = (1U << 0);  ///< write this bit to enable the bitscrambler rx
        constexpr uint32_t RX_PAUSE = (1U << 1);  ///< write this bit to pause the bitscrambler rx core
        constexpr uint32_t RX_HALT = (1U << 2);  ///< write this bit to halt the bitscrambler rx core
        constexpr uint32_t RX_EOF_MODE = (1U << 3);  ///< write this bit to ser the bitscrambler rx core EOF signal generating mode which is combined with reg_bitscrambler_rx_tailing_bits, 0: counter by read peripheral buffer, 0 counter by write dma fifo
        constexpr uint32_t RX_COND_MODE = (1U << 4);  ///< write this bit to specify the LOOP instruction condition mode of bitscrambler rx core, 0: use the little than operator to get the condition, 1: use not equal operator to get the condition
        constexpr uint32_t RX_FETCH_MODE = (1U << 5);  ///< write this bit to set the bitscrambler rx core fetch instruction mode, 0: prefetch by reset, 1: fetch by instrutions
        constexpr uint32_t RX_HALT_MODE = (1U << 6);  ///< write this bit to set the bitscrambler rx core halt mode when rx_halt is set, 0: wait write data back done, , 1: ignore write data back
        constexpr uint32_t RX_RD_DUMMY = (1U << 7);  ///< write this bit to set the bitscrambler rx core read data mode when EOF received.0: wait read data, 1: ignore read data
        constexpr uint32_t RX_FIFO_RST = (1U << 8);  ///< write this bit to reset the bitscrambler rx fifo
    }

    /// TX_STATE Register bits
    namespace tx_state_bits {
        constexpr uint32_t TX_IN_IDLE = (1U << 0);  ///< represents the bitscrambler tx core in halt mode
        constexpr uint32_t TX_IN_RUN = (1U << 1);  ///< represents the bitscrambler tx core in run mode
        constexpr uint32_t TX_IN_WAIT = (1U << 2);  ///< represents the bitscrambler tx core in wait mode to wait write back done
        constexpr uint32_t TX_IN_PAUSE = (1U << 3);  ///< represents the bitscrambler tx core in pause mode
        constexpr uint32_t TX_FIFO_EMPTY = (1U << 4);  ///< represents the bitscrambler tx fifo in empty state
        constexpr uint32_t TX_EOF_GET_CNT = (14 << 16);  ///< represents the bytes numbers of bitscrambler tx core when get EOF
        constexpr uint32_t TX_EOF_OVERLOAD = (1U << 30);  ///< represents the some EOFs will be lost for bitscrambler tx core
        constexpr uint32_t TX_EOF_TRACE_CLR = (1U << 31);  ///< write this bit to clear reg_bitscrambler_tx_eof_overload and reg_bitscrambler_tx_eof_get_cnt registers
    }

    /// RX_STATE Register bits
    namespace rx_state_bits {
        constexpr uint32_t RX_IN_IDLE = (1U << 0);  ///< represents the bitscrambler rx core in halt mode
        constexpr uint32_t RX_IN_RUN = (1U << 1);  ///< represents the bitscrambler rx core in run mode
        constexpr uint32_t RX_IN_WAIT = (1U << 2);  ///< represents the bitscrambler rx core in wait mode to wait write back done
        constexpr uint32_t RX_IN_PAUSE = (1U << 3);  ///< represents the bitscrambler rx core in pause mode
        constexpr uint32_t RX_FIFO_FULL = (1U << 4);  ///< represents the bitscrambler rx fifo in full state
        constexpr uint32_t RX_EOF_GET_CNT = (14 << 16);  ///< represents the bytes numbers of bitscrambler rx core when get EOF
        constexpr uint32_t RX_EOF_OVERLOAD = (1U << 30);  ///< represents the some EOFs will be lost for bitscrambler rx core
        constexpr uint32_t RX_EOF_TRACE_CLR = (1U << 31);  ///< write this bit to clear reg_bitscrambler_rx_eof_overload and reg_bitscrambler_rx_eof_get_cnt registers
    }

    /// SYS Register bits
    namespace sys_bits {
        constexpr uint32_t LOOP_MODE = (1U << 0);  ///< write this bit to set the bitscrambler tx loop back to DMA rx
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Reserved
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t BITSCRAMBLER_VER = (28 << 0);  ///< Reserved
    }

}

// ============================================================================
// CACHE Peripheral
// ============================================================================

namespace cache {
    /// Base addresses
    constexpr uint32_t CACHE_BASE = 0x3FF10000;

    /// CACHE Register structure
    struct Registers {
        volatile uint32_t L1_ICACHE_CTRL;  ///< Offset: 0x00 - L1 instruction Cache(L1-ICache) control register
        volatile uint32_t L1_DCACHE_CTRL;  ///< Offset: 0x04 - L1 data Cache(L1-DCache) control register
        volatile uint32_t L1_BYPASS_CACHE_CONF;  ///< Offset: 0x08 - Bypass Cache configure register
        volatile uint32_t L1_CACHE_ATOMIC_CONF;  ///< Offset: 0x0C - L1 Cache atomic feature configure register
        volatile uint32_t L1_ICACHE_CACHESIZE_CONF;  ///< Offset: 0x10 - L1 instruction Cache CacheSize mode configure register
        volatile uint32_t L1_ICACHE_BLOCKSIZE_CONF;  ///< Offset: 0x14 - L1 instruction Cache BlockSize mode configure register
        volatile uint32_t L1_DCACHE_CACHESIZE_CONF;  ///< Offset: 0x18 - L1 data Cache CacheSize mode configure register
        volatile uint32_t L1_DCACHE_BLOCKSIZE_CONF;  ///< Offset: 0x1C - L1 data Cache BlockSize mode configure register
        volatile uint32_t L1_CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0x20 - Cache wrap around control register
        volatile uint32_t L1_CACHE_TAG_MEM_POWER_CTRL;  ///< Offset: 0x24 - Cache tag memory power control register
        volatile uint32_t L1_CACHE_DATA_MEM_POWER_CTRL;  ///< Offset: 0x28 - Cache data memory power control register
        volatile uint32_t L1_CACHE_FREEZE_CTRL;  ///< Offset: 0x2C - Cache Freeze control register
        volatile uint32_t L1_CACHE_DATA_MEM_ACS_CONF;  ///< Offset: 0x30 - Cache data memory access configure register
        volatile uint32_t L1_CACHE_TAG_MEM_ACS_CONF;  ///< Offset: 0x34 - Cache tag memory access configure register
        volatile uint32_t L1_ICACHE0_PRELOCK_CONF;  ///< Offset: 0x38 - L1 instruction Cache 0 prelock configure register
        volatile uint32_t L1_ICACHE0_PRELOCK_SCT0_ADDR;  ///< Offset: 0x3C - L1 instruction Cache 0 prelock section0 address...
        volatile uint32_t L1_ICACHE0_PRELOCK_SCT1_ADDR;  ///< Offset: 0x40 - L1 instruction Cache 0 prelock section1 address...
        volatile uint32_t L1_ICACHE0_PRELOCK_SCT_SIZE;  ///< Offset: 0x44 - L1 instruction Cache 0 prelock section size configure register
        volatile uint32_t L1_ICACHE1_PRELOCK_CONF;  ///< Offset: 0x48 - L1 instruction Cache 1 prelock configure register
        volatile uint32_t L1_ICACHE1_PRELOCK_SCT0_ADDR;  ///< Offset: 0x4C - L1 instruction Cache 1 prelock section0 address...
        volatile uint32_t L1_ICACHE1_PRELOCK_SCT1_ADDR;  ///< Offset: 0x50 - L1 instruction Cache 1 prelock section1 address...
        volatile uint32_t L1_ICACHE1_PRELOCK_SCT_SIZE;  ///< Offset: 0x54 - L1 instruction Cache 1 prelock section size configure register
        volatile uint32_t L1_ICACHE2_PRELOCK_CONF;  ///< Offset: 0x58 - L1 instruction Cache 2 prelock configure register
        volatile uint32_t L1_ICACHE2_PRELOCK_SCT0_ADDR;  ///< Offset: 0x5C - L1 instruction Cache 2 prelock section0 address...
        volatile uint32_t L1_ICACHE2_PRELOCK_SCT1_ADDR;  ///< Offset: 0x60 - L1 instruction Cache 2 prelock section1 address...
        volatile uint32_t L1_ICACHE2_PRELOCK_SCT_SIZE;  ///< Offset: 0x64 - L1 instruction Cache 2 prelock section size configure register
        volatile uint32_t L1_ICACHE3_PRELOCK_CONF;  ///< Offset: 0x68 - L1 instruction Cache 3 prelock configure register
        volatile uint32_t L1_ICACHE3_PRELOCK_SCT0_ADDR;  ///< Offset: 0x6C - L1 instruction Cache 3 prelock section0 address...
        volatile uint32_t L1_ICACHE3_PRELOCK_SCT1_ADDR;  ///< Offset: 0x70 - L1 instruction Cache 3 prelock section1 address...
        volatile uint32_t L1_ICACHE3_PRELOCK_SCT_SIZE;  ///< Offset: 0x74 - L1 instruction Cache 3 prelock section size configure register
        volatile uint32_t L1_DCACHE_PRELOCK_CONF;  ///< Offset: 0x78 - L1 data Cache prelock configure register
        volatile uint32_t L1_DCACHE_PRELOCK_SCT0_ADDR;  ///< Offset: 0x7C - L1 data Cache prelock section0 address configure register
        volatile uint32_t L1_DCACHE_PRELOCK_SCT1_ADDR;  ///< Offset: 0x80 - L1 data Cache prelock section1 address configure register
        volatile uint32_t L1_DCACHE_PRELOCK_SCT_SIZE;  ///< Offset: 0x84 - L1 data Cache prelock section size configure register
        volatile uint32_t LOCK_CTRL;  ///< Offset: 0x88 - Lock-class (manual lock) operation control register
        volatile uint32_t LOCK_MAP;  ///< Offset: 0x8C - Lock (manual lock) map configure register
        volatile uint32_t LOCK_ADDR;  ///< Offset: 0x90 - Lock (manual lock) address configure register
        volatile uint32_t LOCK_SIZE;  ///< Offset: 0x94 - Lock (manual lock) size configure register
        volatile uint32_t SYNC_CTRL;  ///< Offset: 0x98 - Sync-class operation control register
        volatile uint32_t SYNC_MAP;  ///< Offset: 0x9C - Sync map configure register
        volatile uint32_t SYNC_ADDR;  ///< Offset: 0xA0 - Sync address configure register
        volatile uint32_t SYNC_SIZE;  ///< Offset: 0xA4 - Sync size configure register
        volatile uint32_t L1_ICACHE0_PRELOAD_CTRL;  ///< Offset: 0xA8 - L1 instruction Cache 0 preload-operation control register
        volatile uint32_t L1_ICACHE0_PRELOAD_ADDR;  ///< Offset: 0xAC - L1 instruction Cache 0 preload address configure register
        volatile uint32_t L1_ICACHE0_PRELOAD_SIZE;  ///< Offset: 0xB0 - L1 instruction Cache 0 preload size configure register
        volatile uint32_t L1_ICACHE1_PRELOAD_CTRL;  ///< Offset: 0xB4 - L1 instruction Cache 1 preload-operation control register
        volatile uint32_t L1_ICACHE1_PRELOAD_ADDR;  ///< Offset: 0xB8 - L1 instruction Cache 1 preload address configure register
        volatile uint32_t L1_ICACHE1_PRELOAD_SIZE;  ///< Offset: 0xBC - L1 instruction Cache 1 preload size configure register
        volatile uint32_t L1_ICACHE2_PRELOAD_CTRL;  ///< Offset: 0xC0 - L1 instruction Cache 2 preload-operation control register
        volatile uint32_t L1_ICACHE2_PRELOAD_ADDR;  ///< Offset: 0xC4 - L1 instruction Cache 2 preload address configure register
        volatile uint32_t L1_ICACHE2_PRELOAD_SIZE;  ///< Offset: 0xC8 - L1 instruction Cache 2 preload size configure register
        volatile uint32_t L1_ICACHE3_PRELOAD_CTRL;  ///< Offset: 0xCC - L1 instruction Cache 3 preload-operation control register
        volatile uint32_t L1_ICACHE3_PRELOAD_ADDR;  ///< Offset: 0xD0 - L1 instruction Cache 3 preload address configure register
        volatile uint32_t L1_ICACHE3_PRELOAD_SIZE;  ///< Offset: 0xD4 - L1 instruction Cache 3 preload size configure register
        volatile uint32_t L1_DCACHE_PRELOAD_CTRL;  ///< Offset: 0xD8 - L1 data Cache preload-operation control register
        volatile uint32_t L1_DCACHE_PRELOAD_ADDR;  ///< Offset: 0xDC - L1 data Cache preload address configure register
        volatile uint32_t L1_DCACHE_PRELOAD_SIZE;  ///< Offset: 0xE0 - L1 data Cache preload size configure register
        volatile uint32_t L1_ICACHE0_AUTOLOAD_CTRL;  ///< Offset: 0xE4 - L1 instruction Cache 0 autoload-operation control register
        volatile uint32_t L1_ICACHE0_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0xE8 - L1 instruction Cache 0 autoload section 0 address...
        volatile uint32_t L1_ICACHE0_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0xEC - L1 instruction Cache 0 autoload section 0 size configure register
        volatile uint32_t L1_ICACHE0_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0xF0 - L1 instruction Cache 0 autoload section 1 address...
        volatile uint32_t L1_ICACHE0_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0xF4 - L1 instruction Cache 0 autoload section 1 size configure register
        volatile uint32_t L1_ICACHE1_AUTOLOAD_CTRL;  ///< Offset: 0xF8 - L1 instruction Cache 1 autoload-operation control register
        volatile uint32_t L1_ICACHE1_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0xFC - L1 instruction Cache 1 autoload section 0 address...
        volatile uint32_t L1_ICACHE1_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x100 - L1 instruction Cache 1 autoload section 0 size configure register
        volatile uint32_t L1_ICACHE1_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x104 - L1 instruction Cache 1 autoload section 1 address...
        volatile uint32_t L1_ICACHE1_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x108 - L1 instruction Cache 1 autoload section 1 size configure register
        volatile uint32_t L1_ICACHE2_AUTOLOAD_CTRL;  ///< Offset: 0x10C - L1 instruction Cache 2 autoload-operation control register
        volatile uint32_t L1_ICACHE2_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x110 - L1 instruction Cache 2 autoload section 0 address...
        volatile uint32_t L1_ICACHE2_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x114 - L1 instruction Cache 2 autoload section 0 size configure register
        volatile uint32_t L1_ICACHE2_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x118 - L1 instruction Cache 2 autoload section 1 address...
        volatile uint32_t L1_ICACHE2_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x11C - L1 instruction Cache 2 autoload section 1 size configure register
        volatile uint32_t L1_ICACHE3_AUTOLOAD_CTRL;  ///< Offset: 0x120 - L1 instruction Cache 3 autoload-operation control register
        volatile uint32_t L1_ICACHE3_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x124 - L1 instruction Cache 3 autoload section 0 address...
        volatile uint32_t L1_ICACHE3_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x128 - L1 instruction Cache 3 autoload section 0 size configure register
        volatile uint32_t L1_ICACHE3_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x12C - L1 instruction Cache 3 autoload section 1 address...
        volatile uint32_t L1_ICACHE3_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x130 - L1 instruction Cache 3 autoload section 1 size configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_CTRL;  ///< Offset: 0x134 - L1 data Cache autoload-operation control register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x138 - L1 data Cache autoload section 0 address configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x13C - L1 data Cache autoload section 0 size configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x140 - L1 data Cache autoload section 1 address configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x144 - L1 data Cache autoload section 1 size configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT2_ADDR;  ///< Offset: 0x148 - L1 data Cache autoload section 2 address configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT2_SIZE;  ///< Offset: 0x14C - L1 data Cache autoload section 2 size configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT3_ADDR;  ///< Offset: 0x150 - L1 data Cache autoload section 1 address configure register
        volatile uint32_t L1_DCACHE_AUTOLOAD_SCT3_SIZE;  ///< Offset: 0x154 - L1 data Cache autoload section 1 size configure register
        volatile uint32_t L1_CACHE_ACS_CNT_INT_ENA;  ///< Offset: 0x158 - Cache Access Counter Interrupt enable register
        volatile uint32_t L1_CACHE_ACS_CNT_INT_CLR;  ///< Offset: 0x15C - Cache Access Counter Interrupt clear register
        volatile uint32_t L1_CACHE_ACS_CNT_INT_RAW;  ///< Offset: 0x160 - Cache Access Counter Interrupt raw register
        volatile uint32_t L1_CACHE_ACS_CNT_INT_ST;  ///< Offset: 0x164 - Cache Access Counter Interrupt status register
        volatile uint32_t L1_CACHE_ACS_FAIL_CTRL;  ///< Offset: 0x168 - Cache Access Fail Configuration register
        volatile uint32_t L1_CACHE_ACS_FAIL_INT_ENA;  ///< Offset: 0x16C - Cache Access Fail Interrupt enable register
        volatile uint32_t L1_CACHE_ACS_FAIL_INT_CLR;  ///< Offset: 0x170 - L1-Cache Access Fail Interrupt clear register
        volatile uint32_t L1_CACHE_ACS_FAIL_INT_RAW;  ///< Offset: 0x174 - Cache Access Fail Interrupt raw register
        volatile uint32_t L1_CACHE_ACS_FAIL_INT_ST;  ///< Offset: 0x178 - Cache Access Fail Interrupt status register
        volatile uint32_t L1_CACHE_ACS_CNT_CTRL;  ///< Offset: 0x17C - Cache Access Counter enable and clear register
        volatile uint32_t L1_IBUS0_ACS_HIT_CNT;  ///< Offset: 0x180 - L1-ICache bus0 Hit-Access Counter register
        volatile uint32_t L1_IBUS0_ACS_MISS_CNT;  ///< Offset: 0x184 - L1-ICache bus0 Miss-Access Counter register
        volatile uint32_t L1_IBUS0_ACS_CONFLICT_CNT;  ///< Offset: 0x188 - L1-ICache bus0 Conflict-Access Counter register
        volatile uint32_t L1_IBUS0_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x18C - L1-ICache bus0 Next-Level-Access Counter register
        volatile uint32_t L1_IBUS1_ACS_HIT_CNT;  ///< Offset: 0x190 - L1-ICache bus1 Hit-Access Counter register
        volatile uint32_t L1_IBUS1_ACS_MISS_CNT;  ///< Offset: 0x194 - L1-ICache bus1 Miss-Access Counter register
        volatile uint32_t L1_IBUS1_ACS_CONFLICT_CNT;  ///< Offset: 0x198 - L1-ICache bus1 Conflict-Access Counter register
        volatile uint32_t L1_IBUS1_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x19C - L1-ICache bus1 Next-Level-Access Counter register
        volatile uint32_t L1_IBUS2_ACS_HIT_CNT;  ///< Offset: 0x1A0 - L1-ICache bus2 Hit-Access Counter register
        volatile uint32_t L1_IBUS2_ACS_MISS_CNT;  ///< Offset: 0x1A4 - L1-ICache bus2 Miss-Access Counter register
        volatile uint32_t L1_IBUS2_ACS_CONFLICT_CNT;  ///< Offset: 0x1A8 - L1-ICache bus2 Conflict-Access Counter register
        volatile uint32_t L1_IBUS2_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x1AC - L1-ICache bus2 Next-Level-Access Counter register
        volatile uint32_t L1_IBUS3_ACS_HIT_CNT;  ///< Offset: 0x1B0 - L1-ICache bus3 Hit-Access Counter register
        volatile uint32_t L1_IBUS3_ACS_MISS_CNT;  ///< Offset: 0x1B4 - L1-ICache bus3 Miss-Access Counter register
        volatile uint32_t L1_IBUS3_ACS_CONFLICT_CNT;  ///< Offset: 0x1B8 - L1-ICache bus3 Conflict-Access Counter register
        volatile uint32_t L1_IBUS3_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x1BC - L1-ICache bus3 Next-Level-Access Counter register
        volatile uint32_t L1_DBUS0_ACS_HIT_CNT;  ///< Offset: 0x1C0 - L1-DCache bus0 Hit-Access Counter register
        volatile uint32_t L1_DBUS0_ACS_MISS_CNT;  ///< Offset: 0x1C4 - L1-DCache bus0 Miss-Access Counter register
        volatile uint32_t L1_DBUS0_ACS_CONFLICT_CNT;  ///< Offset: 0x1C8 - L1-DCache bus0 Conflict-Access Counter register
        volatile uint32_t L1_DBUS0_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x1CC - L1-DCache bus0 Next-Level-Access Counter register
        volatile uint32_t L1_DBUS0_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x1D0 - L1-DCache bus0 WB-Access Counter register
        volatile uint32_t L1_DBUS1_ACS_HIT_CNT;  ///< Offset: 0x1D4 - L1-DCache bus1 Hit-Access Counter register
        volatile uint32_t L1_DBUS1_ACS_MISS_CNT;  ///< Offset: 0x1D8 - L1-DCache bus1 Miss-Access Counter register
        volatile uint32_t L1_DBUS1_ACS_CONFLICT_CNT;  ///< Offset: 0x1DC - L1-DCache bus1 Conflict-Access Counter register
        volatile uint32_t L1_DBUS1_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x1E0 - L1-DCache bus1 Next-Level-Access Counter register
        volatile uint32_t L1_DBUS1_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x1E4 - L1-DCache bus1 WB-Access Counter register
        volatile uint32_t L1_DBUS2_ACS_HIT_CNT;  ///< Offset: 0x1E8 - L1-DCache bus2 Hit-Access Counter register
        volatile uint32_t L1_DBUS2_ACS_MISS_CNT;  ///< Offset: 0x1EC - L1-DCache bus2 Miss-Access Counter register
        volatile uint32_t L1_DBUS2_ACS_CONFLICT_CNT;  ///< Offset: 0x1F0 - L1-DCache bus2 Conflict-Access Counter register
        volatile uint32_t L1_DBUS2_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x1F4 - L1-DCache bus2 Next-Level-Access Counter register
        volatile uint32_t L1_DBUS2_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x1F8 - L1-DCache bus2 WB-Access Counter register
        volatile uint32_t L1_DBUS3_ACS_HIT_CNT;  ///< Offset: 0x1FC - L1-DCache bus3 Hit-Access Counter register
        volatile uint32_t L1_DBUS3_ACS_MISS_CNT;  ///< Offset: 0x200 - L1-DCache bus3 Miss-Access Counter register
        volatile uint32_t L1_DBUS3_ACS_CONFLICT_CNT;  ///< Offset: 0x204 - L1-DCache bus3 Conflict-Access Counter register
        volatile uint32_t L1_DBUS3_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x208 - L1-DCache bus3 Next-Level-Access Counter register
        volatile uint32_t L1_DBUS3_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x20C - L1-DCache bus3 WB-Access Counter register
        volatile uint32_t L1_ICACHE0_ACS_FAIL_ID_ATTR;  ///< Offset: 0x210 - L1-ICache0 Access Fail ID/attribution information register
        volatile uint32_t L1_ICACHE0_ACS_FAIL_ADDR;  ///< Offset: 0x214 - L1-ICache0 Access Fail Address information register
        volatile uint32_t L1_ICACHE1_ACS_FAIL_ID_ATTR;  ///< Offset: 0x218 - L1-ICache0 Access Fail ID/attribution information register
        volatile uint32_t L1_ICACHE1_ACS_FAIL_ADDR;  ///< Offset: 0x21C - L1-ICache0 Access Fail Address information register
        volatile uint32_t L1_ICACHE2_ACS_FAIL_ID_ATTR;  ///< Offset: 0x220 - L1-ICache0 Access Fail ID/attribution information register
        volatile uint32_t L1_ICACHE2_ACS_FAIL_ADDR;  ///< Offset: 0x224 - L1-ICache0 Access Fail Address information register
        volatile uint32_t L1_ICACHE3_ACS_FAIL_ID_ATTR;  ///< Offset: 0x228 - L1-ICache0 Access Fail ID/attribution information register
        volatile uint32_t L1_ICACHE3_ACS_FAIL_ADDR;  ///< Offset: 0x22C - L1-ICache0 Access Fail Address information register
        volatile uint32_t L1_DCACHE_ACS_FAIL_ID_ATTR;  ///< Offset: 0x230 - L1-DCache Access Fail ID/attribution information register
        volatile uint32_t L1_DCACHE_ACS_FAIL_ADDR;  ///< Offset: 0x234 - L1-DCache Access Fail Address information register
        volatile uint32_t SYNC_L1_CACHE_PRELOAD_INT_ENA;  ///< Offset: 0x238 - L1-Cache Access Fail Interrupt enable register
        volatile uint32_t SYNC_L1_CACHE_PRELOAD_INT_CLR;  ///< Offset: 0x23C - Sync Preload operation Interrupt clear register
        volatile uint32_t SYNC_L1_CACHE_PRELOAD_INT_RAW;  ///< Offset: 0x240 - Sync Preload operation Interrupt raw register
        volatile uint32_t SYNC_L1_CACHE_PRELOAD_INT_ST;  ///< Offset: 0x244 - L1-Cache Access Fail Interrupt status register
        volatile uint32_t SYNC_L1_CACHE_PRELOAD_EXCEPTION;  ///< Offset: 0x248 - Cache Sync/Preload Operation exception register
        volatile uint32_t L1_CACHE_SYNC_RST_CTRL;  ///< Offset: 0x24C - Cache Sync Reset control register
        volatile uint32_t L1_CACHE_PRELOAD_RST_CTRL;  ///< Offset: 0x250 - Cache Preload Reset control register
        volatile uint32_t L1_CACHE_AUTOLOAD_BUF_CLR_CTRL;  ///< Offset: 0x254 - Cache Autoload buffer clear control register
        volatile uint32_t L1_UNALLOCATE_BUFFER_CLEAR;  ///< Offset: 0x258 - Unallocate request buffer clear registers
        volatile uint32_t L1_CACHE_OBJECT_CTRL;  ///< Offset: 0x25C - Cache Tag and Data memory Object control register
        volatile uint32_t L1_CACHE_WAY_OBJECT;  ///< Offset: 0x260 - Cache Tag and Data memory way register
        volatile uint32_t L1_CACHE_VADDR;  ///< Offset: 0x264 - Cache Vaddr register
        volatile uint32_t L1_CACHE_DEBUG_BUS;  ///< Offset: 0x268 - Cache Tag/data memory content register
        volatile uint32_t LEVEL_SPLIT0;  ///< Offset: 0x26C - USED TO SPLIT L1 CACHE AND L2 CACHE
        volatile uint32_t L2_CACHE_CTRL;  ///< Offset: 0x270 - L2 Cache(L2-Cache) control register
        volatile uint32_t L2_BYPASS_CACHE_CONF;  ///< Offset: 0x274 - Bypass Cache configure register
        volatile uint32_t L2_CACHE_CACHESIZE_CONF;  ///< Offset: 0x278 - L2 Cache CacheSize mode configure register
        volatile uint32_t L2_CACHE_BLOCKSIZE_CONF;  ///< Offset: 0x27C - L2 Cache BlockSize mode configure register
        volatile uint32_t L2_CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0x280 - Cache wrap around control register
        volatile uint32_t L2_CACHE_TAG_MEM_POWER_CTRL;  ///< Offset: 0x284 - Cache tag memory power control register
        volatile uint32_t L2_CACHE_DATA_MEM_POWER_CTRL;  ///< Offset: 0x288 - Cache data memory power control register
        volatile uint32_t L2_CACHE_FREEZE_CTRL;  ///< Offset: 0x28C - Cache Freeze control register
        volatile uint32_t L2_CACHE_DATA_MEM_ACS_CONF;  ///< Offset: 0x290 - Cache data memory access configure register
        volatile uint32_t L2_CACHE_TAG_MEM_ACS_CONF;  ///< Offset: 0x294 - Cache tag memory access configure register
        volatile uint32_t L2_CACHE_PRELOCK_CONF;  ///< Offset: 0x298 - L2 Cache prelock configure register
        volatile uint32_t L2_CACHE_PRELOCK_SCT0_ADDR;  ///< Offset: 0x29C - L2 Cache prelock section0 address configure register
        volatile uint32_t L2_CACHE_PRELOCK_SCT1_ADDR;  ///< Offset: 0x2A0 - L2 Cache prelock section1 address configure register
        volatile uint32_t L2_CACHE_PRELOCK_SCT_SIZE;  ///< Offset: 0x2A4 - L2 Cache prelock section size configure register
        volatile uint32_t L2_CACHE_PRELOAD_CTRL;  ///< Offset: 0x2A8 - L2 Cache preload-operation control register
        volatile uint32_t L2_CACHE_PRELOAD_ADDR;  ///< Offset: 0x2AC - L2 Cache preload address configure register
        volatile uint32_t L2_CACHE_PRELOAD_SIZE;  ///< Offset: 0x2B0 - L2 Cache preload size configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_CTRL;  ///< Offset: 0x2B4 - L2 Cache autoload-operation control register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x2B8 - L2 Cache autoload section 0 address configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x2BC - L2 Cache autoload section 0 size configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x2C0 - L2 Cache autoload section 1 address configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x2C4 - L2 Cache autoload section 1 size configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT2_ADDR;  ///< Offset: 0x2C8 - L2 Cache autoload section 2 address configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT2_SIZE;  ///< Offset: 0x2CC - L2 Cache autoload section 2 size configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT3_ADDR;  ///< Offset: 0x2D0 - L2 Cache autoload section 3 address configure register
        volatile uint32_t L2_CACHE_AUTOLOAD_SCT3_SIZE;  ///< Offset: 0x2D4 - L2 Cache autoload section 3 size configure register
        volatile uint32_t L2_CACHE_ACS_CNT_INT_ENA;  ///< Offset: 0x2D8 - Cache Access Counter Interrupt enable register
        volatile uint32_t L2_CACHE_ACS_CNT_INT_CLR;  ///< Offset: 0x2DC - Cache Access Counter Interrupt clear register
        volatile uint32_t L2_CACHE_ACS_CNT_INT_RAW;  ///< Offset: 0x2E0 - Cache Access Counter Interrupt raw register
        volatile uint32_t L2_CACHE_ACS_CNT_INT_ST;  ///< Offset: 0x2E4 - Cache Access Counter Interrupt status register
        volatile uint32_t L2_CACHE_ACS_FAIL_CTRL;  ///< Offset: 0x2E8 - Cache Access Fail Configuration register
        volatile uint32_t L2_CACHE_ACS_FAIL_INT_ENA;  ///< Offset: 0x2EC - Cache Access Fail Interrupt enable register
        volatile uint32_t L2_CACHE_ACS_FAIL_INT_CLR;  ///< Offset: 0x2F0 - L1-Cache Access Fail Interrupt clear register
        volatile uint32_t L2_CACHE_ACS_FAIL_INT_RAW;  ///< Offset: 0x2F4 - Cache Access Fail Interrupt raw register
        volatile uint32_t L2_CACHE_ACS_FAIL_INT_ST;  ///< Offset: 0x2F8 - Cache Access Fail Interrupt status register
        volatile uint32_t L2_CACHE_ACS_CNT_CTRL;  ///< Offset: 0x2FC - Cache Access Counter enable and clear register
        volatile uint32_t L2_IBUS0_ACS_HIT_CNT;  ///< Offset: 0x300 - L2-Cache bus0 Hit-Access Counter register
        volatile uint32_t L2_IBUS0_ACS_MISS_CNT;  ///< Offset: 0x304 - L2-Cache bus0 Miss-Access Counter register
        volatile uint32_t L2_IBUS0_ACS_CONFLICT_CNT;  ///< Offset: 0x308 - L2-Cache bus0 Conflict-Access Counter register
        volatile uint32_t L2_IBUS0_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x30C - L2-Cache bus0 Next-Level-Access Counter register
        volatile uint32_t L2_IBUS1_ACS_HIT_CNT;  ///< Offset: 0x310 - L2-Cache bus1 Hit-Access Counter register
        volatile uint32_t L2_IBUS1_ACS_MISS_CNT;  ///< Offset: 0x314 - L2-Cache bus1 Miss-Access Counter register
        volatile uint32_t L2_IBUS1_ACS_CONFLICT_CNT;  ///< Offset: 0x318 - L2-Cache bus1 Conflict-Access Counter register
        volatile uint32_t L2_IBUS1_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x31C - L2-Cache bus1 Next-Level-Access Counter register
        volatile uint32_t L2_IBUS2_ACS_HIT_CNT;  ///< Offset: 0x320 - L2-Cache bus2 Hit-Access Counter register
        volatile uint32_t L2_IBUS2_ACS_MISS_CNT;  ///< Offset: 0x324 - L2-Cache bus2 Miss-Access Counter register
        volatile uint32_t L2_IBUS2_ACS_CONFLICT_CNT;  ///< Offset: 0x328 - L2-Cache bus2 Conflict-Access Counter register
        volatile uint32_t L2_IBUS2_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x32C - L2-Cache bus2 Next-Level-Access Counter register
        volatile uint32_t L2_IBUS3_ACS_HIT_CNT;  ///< Offset: 0x330 - L2-Cache bus3 Hit-Access Counter register
        volatile uint32_t L2_IBUS3_ACS_MISS_CNT;  ///< Offset: 0x334 - L2-Cache bus3 Miss-Access Counter register
        volatile uint32_t L2_IBUS3_ACS_CONFLICT_CNT;  ///< Offset: 0x338 - L2-Cache bus3 Conflict-Access Counter register
        volatile uint32_t L2_IBUS3_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x33C - L2-Cache bus3 Next-Level-Access Counter register
        volatile uint32_t L2_DBUS0_ACS_HIT_CNT;  ///< Offset: 0x340 - L2-Cache bus0 Hit-Access Counter register
        volatile uint32_t L2_DBUS0_ACS_MISS_CNT;  ///< Offset: 0x344 - L2-Cache bus0 Miss-Access Counter register
        volatile uint32_t L2_DBUS0_ACS_CONFLICT_CNT;  ///< Offset: 0x348 - L2-Cache bus0 Conflict-Access Counter register
        volatile uint32_t L2_DBUS0_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x34C - L2-Cache bus0 Next-Level-Access Counter register
        volatile uint32_t L2_DBUS0_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x350 - L2-Cache bus0 WB-Access Counter register
        volatile uint32_t L2_DBUS1_ACS_HIT_CNT;  ///< Offset: 0x354 - L2-Cache bus1 Hit-Access Counter register
        volatile uint32_t L2_DBUS1_ACS_MISS_CNT;  ///< Offset: 0x358 - L2-Cache bus1 Miss-Access Counter register
        volatile uint32_t L2_DBUS1_ACS_CONFLICT_CNT;  ///< Offset: 0x35C - L2-Cache bus1 Conflict-Access Counter register
        volatile uint32_t L2_DBUS1_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x360 - L2-Cache bus1 Next-Level-Access Counter register
        volatile uint32_t L2_DBUS1_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x364 - L2-Cache bus1 WB-Access Counter register
        volatile uint32_t L2_DBUS2_ACS_HIT_CNT;  ///< Offset: 0x368 - L2-Cache bus2 Hit-Access Counter register
        volatile uint32_t L2_DBUS2_ACS_MISS_CNT;  ///< Offset: 0x36C - L2-Cache bus2 Miss-Access Counter register
        volatile uint32_t L2_DBUS2_ACS_CONFLICT_CNT;  ///< Offset: 0x370 - L2-Cache bus2 Conflict-Access Counter register
        volatile uint32_t L2_DBUS2_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x374 - L2-Cache bus2 Next-Level-Access Counter register
        volatile uint32_t L2_DBUS2_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x378 - L2-Cache bus2 WB-Access Counter register
        volatile uint32_t L2_DBUS3_ACS_HIT_CNT;  ///< Offset: 0x37C - L2-Cache bus3 Hit-Access Counter register
        volatile uint32_t L2_DBUS3_ACS_MISS_CNT;  ///< Offset: 0x380 - L2-Cache bus3 Miss-Access Counter register
        volatile uint32_t L2_DBUS3_ACS_CONFLICT_CNT;  ///< Offset: 0x384 - L2-Cache bus3 Conflict-Access Counter register
        volatile uint32_t L2_DBUS3_ACS_NXTLVL_RD_CNT;  ///< Offset: 0x388 - L2-Cache bus3 Next-Level-Access Counter register
        volatile uint32_t L2_DBUS3_ACS_NXTLVL_WR_CNT;  ///< Offset: 0x38C - L2-Cache bus3 WB-Access Counter register
        volatile uint32_t L2_CACHE_ACS_FAIL_ID_ATTR;  ///< Offset: 0x390 - L2-Cache Access Fail ID/attribution information register
        volatile uint32_t L2_CACHE_ACS_FAIL_ADDR;  ///< Offset: 0x394 - L2-Cache Access Fail Address information register
        volatile uint32_t L2_CACHE_SYNC_PRELOAD_INT_ENA;  ///< Offset: 0x398 - L1-Cache Access Fail Interrupt enable register
        volatile uint32_t L2_CACHE_SYNC_PRELOAD_INT_CLR;  ///< Offset: 0x39C - Sync Preload operation Interrupt clear register
        volatile uint32_t L2_CACHE_SYNC_PRELOAD_INT_RAW;  ///< Offset: 0x3A0 - Sync Preload operation Interrupt raw register
        volatile uint32_t L2_CACHE_SYNC_PRELOAD_INT_ST;  ///< Offset: 0x3A4 - L1-Cache Access Fail Interrupt status register
        volatile uint32_t L2_CACHE_SYNC_PRELOAD_EXCEPTION;  ///< Offset: 0x3A8 - Cache Sync/Preload Operation exception register
        volatile uint32_t L2_CACHE_SYNC_RST_CTRL;  ///< Offset: 0x3AC - Cache Sync Reset control register
        volatile uint32_t L2_CACHE_PRELOAD_RST_CTRL;  ///< Offset: 0x3B0 - Cache Preload Reset control register
        volatile uint32_t L2_CACHE_AUTOLOAD_BUF_CLR_CTRL;  ///< Offset: 0x3B4 - Cache Autoload buffer clear control register
        volatile uint32_t L2_UNALLOCATE_BUFFER_CLEAR;  ///< Offset: 0x3B8 - Unallocate request buffer clear registers
        volatile uint32_t L2_CACHE_ACCESS_ATTR_CTRL;  ///< Offset: 0x3BC - L2 cache access attribute control register
        volatile uint32_t L2_CACHE_OBJECT_CTRL;  ///< Offset: 0x3C0 - Cache Tag and Data memory Object control register
        volatile uint32_t L2_CACHE_WAY_OBJECT;  ///< Offset: 0x3C4 - Cache Tag and Data memory way register
        volatile uint32_t L2_CACHE_VADDR;  ///< Offset: 0x3C8 - Cache Vaddr register
        volatile uint32_t L2_CACHE_DEBUG_BUS;  ///< Offset: 0x3CC - Cache Tag/data memory content register
        volatile uint32_t LEVEL_SPLIT1;  ///< Offset: 0x3D0 - USED TO SPLIT L1 CACHE AND L2 CACHE
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x3D4 - Clock gate control register
        volatile uint32_t REDUNDANCY_SIG0;  ///< Offset: 0x3D8 - Cache redundancy signal 0 register
        volatile uint32_t REDUNDANCY_SIG1;  ///< Offset: 0x3DC - Cache redundancy signal 1 register
        volatile uint32_t REDUNDANCY_SIG2;  ///< Offset: 0x3E0 - Cache redundancy signal 2 register
        volatile uint32_t REDUNDANCY_SIG3;  ///< Offset: 0x3E4 - Cache redundancy signal 3 register
        volatile uint32_t REDUNDANCY_SIG4;  ///< Offset: 0x3E8 - Cache redundancy signal 0 register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* CACHE = reinterpret_cast<Registers*>(CACHE_BASE);

    // Bit definitions
    /// L1_ICACHE_CTRL Register bits
    namespace l1_icache_ctrl_bits {
        constexpr uint32_t L1_ICACHE_SHUT_IBUS0 = (1U << 0);  ///< The bit is used to disable core0 ibus access L1-ICache, 0: enable, 1: disable
        constexpr uint32_t L1_ICACHE_SHUT_IBUS1 = (1U << 1);  ///< The bit is used to disable core1 ibus access L1-ICache, 0: enable, 1: disable
        constexpr uint32_t L1_ICACHE_SHUT_IBUS2 = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE_SHUT_IBUS3 = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_ICACHE_UNDEF_OP = (8 << 8);  ///< Reserved
    }

    /// L1_DCACHE_CTRL Register bits
    namespace l1_dcache_ctrl_bits {
        constexpr uint32_t L1_DCACHE_SHUT_DBUS0 = (1U << 0);  ///< The bit is used to disable core0 dbus access L1-DCache, 0: enable, 1: disable
        constexpr uint32_t L1_DCACHE_SHUT_DBUS1 = (1U << 1);  ///< The bit is used to disable core1 dbus access L1-DCache, 0: enable, 1: disable
        constexpr uint32_t L1_DCACHE_SHUT_DBUS2 = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_DCACHE_SHUT_DBUS3 = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_SHUT_DMA = (1U << 4);  ///< The bit is used to disable DMA access L1-DCache, 0: enable, 1: disable
        constexpr uint32_t L1_DCACHE_UNDEF_OP = (8 << 8);  ///< Reserved
    }

    /// L1_BYPASS_CACHE_CONF Register bits
    namespace l1_bypass_cache_conf_bits {
        constexpr uint32_t BYPASS_L1_ICACHE0_EN = (1U << 0);  ///< The bit is used to enable bypass L1-ICache0. 0: disable bypass, 1: enable bypass.
        constexpr uint32_t BYPASS_L1_ICACHE1_EN = (1U << 1);  ///< The bit is used to enable bypass L1-ICache1. 0: disable bypass, 1: enable bypass.
        constexpr uint32_t BYPASS_L1_ICACHE2_EN = (1U << 2);  ///< Reserved
        constexpr uint32_t BYPASS_L1_ICACHE3_EN = (1U << 3);  ///< Reserved
        constexpr uint32_t BYPASS_L1_DCACHE_EN = (1U << 4);  ///< The bit is used to enable bypass L1-DCache. 0: disable bypass, 1: enable bypass.
    }

    /// L1_CACHE_ATOMIC_CONF Register bits
    namespace l1_cache_atomic_conf_bits {
        constexpr uint32_t L1_DCACHE_ATOMIC_EN = (1U << 0);  ///< The bit is used to enable atomic feature on L1-DCache when multiple cores access L1-DCache. 1: disable, 1: enable.
    }

    /// L1_ICACHE_CACHESIZE_CONF Register bits
    namespace l1_icache_cachesize_conf_bits {
        constexpr uint32_t L1_ICACHE_CACHESIZE_256 = (1U << 0);  ///< The field is used to configure cachesize of L1-ICache as 256 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_512 = (1U << 1);  ///< The field is used to configure cachesize of L1-ICache as 512 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_1K = (1U << 2);  ///< The field is used to configure cachesize of L1-ICache as 1k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_2K = (1U << 3);  ///< The field is used to configure cachesize of L1-ICache as 2k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_4K = (1U << 4);  ///< The field is used to configure cachesize of L1-ICache as 4k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_8K = (1U << 5);  ///< The field is used to configure cachesize of L1-ICache as 8k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_16K = (1U << 6);  ///< The field is used to configure cachesize of L1-ICache as 16k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_32K = (1U << 7);  ///< The field is used to configure cachesize of L1-ICache as 32k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_64K = (1U << 8);  ///< The field is used to configure cachesize of L1-ICache as 64k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_128K = (1U << 9);  ///< The field is used to configure cachesize of L1-ICache as 128k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_256K = (1U << 10);  ///< The field is used to configure cachesize of L1-ICache as 256k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_512K = (1U << 11);  ///< The field is used to configure cachesize of L1-ICache as 512k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_CACHESIZE_1024K = (1U << 12);  ///< The field is used to configure cachesize of L1-ICache as 1024k bytes. This field and all other fields within this register is onehot.
    }

    /// L1_ICACHE_BLOCKSIZE_CONF Register bits
    namespace l1_icache_blocksize_conf_bits {
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_8 = (1U << 0);  ///< The field is used to configureblocksize of L1-ICache as 8 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_16 = (1U << 1);  ///< The field is used to configureblocksize of L1-ICache as 16 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_32 = (1U << 2);  ///< The field is used to configureblocksize of L1-ICache as 32 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_64 = (1U << 3);  ///< The field is used to configureblocksize of L1-ICache as 64 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_128 = (1U << 4);  ///< The field is used to configureblocksize of L1-ICache as 128 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_ICACHE_BLOCKSIZE_256 = (1U << 5);  ///< The field is used to configureblocksize of L1-ICache as 256 bytes. This field and all other fields within this register is onehot.
    }

    /// L1_DCACHE_CACHESIZE_CONF Register bits
    namespace l1_dcache_cachesize_conf_bits {
        constexpr uint32_t L1_DCACHE_CACHESIZE_256 = (1U << 0);  ///< The field is used to configure cachesize of L1-DCache as 256 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_512 = (1U << 1);  ///< The field is used to configure cachesize of L1-DCache as 512 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_1K = (1U << 2);  ///< The field is used to configure cachesize of L1-DCache as 1k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_2K = (1U << 3);  ///< The field is used to configure cachesize of L1-DCache as 2k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_4K = (1U << 4);  ///< The field is used to configure cachesize of L1-DCache as 4k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_8K = (1U << 5);  ///< The field is used to configure cachesize of L1-DCache as 8k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_16K = (1U << 6);  ///< The field is used to configure cachesize of L1-DCache as 16k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_32K = (1U << 7);  ///< The field is used to configure cachesize of L1-DCache as 32k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_64K = (1U << 8);  ///< The field is used to configure cachesize of L1-DCache as 64k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_128K = (1U << 9);  ///< The field is used to configure cachesize of L1-DCache as 128k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_256K = (1U << 10);  ///< The field is used to configure cachesize of L1-DCache as 256k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_512K = (1U << 11);  ///< The field is used to configure cachesize of L1-DCache as 512k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_CACHESIZE_1024K = (1U << 12);  ///< The field is used to configure cachesize of L1-DCache as 1024k bytes. This field and all other fields within this register is onehot.
    }

    /// L1_DCACHE_BLOCKSIZE_CONF Register bits
    namespace l1_dcache_blocksize_conf_bits {
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_8 = (1U << 0);  ///< The field is used to configureblocksize of L1-DCache as 8 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_16 = (1U << 1);  ///< The field is used to configureblocksize of L1-DCache as 16 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_32 = (1U << 2);  ///< The field is used to configureblocksize of L1-DCache as 32 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_64 = (1U << 3);  ///< The field is used to configureblocksize of L1-DCache as 64 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_128 = (1U << 4);  ///< The field is used to configureblocksize of L1-DCache as 128 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L1_DCACHE_BLOCKSIZE_256 = (1U << 5);  ///< The field is used to configureblocksize of L1-DCache as 256 bytes. This field and all other fields within this register is onehot.
    }

    /// L1_CACHE_WRAP_AROUND_CTRL Register bits
    namespace l1_cache_wrap_around_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_WRAP = (1U << 0);  ///< Set this bit as 1 to enable L1-ICache0 wrap around mode.
        constexpr uint32_t L1_ICACHE1_WRAP = (1U << 1);  ///< Set this bit as 1 to enable L1-ICache1 wrap around mode.
        constexpr uint32_t L1_ICACHE2_WRAP = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_WRAP = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_WRAP = (1U << 4);  ///< Set this bit as 1 to enable L1-DCache wrap around mode.
    }

    /// L1_CACHE_TAG_MEM_POWER_CTRL Register bits
    namespace l1_cache_tag_mem_power_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of L1-ICache0 tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_ICACHE0_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power L1-ICache0 tag memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_ICACHE0_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power L1-ICache0 tag memory up. 0: follow rtc_lslp, 1: power up
        constexpr uint32_t L1_ICACHE1_TAG_MEM_FORCE_ON = (1U << 4);  ///< The bit is used to close clock gating of L1-ICache1 tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_ICACHE1_TAG_MEM_FORCE_PD = (1U << 5);  ///< The bit is used to power L1-ICache1 tag memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_ICACHE1_TAG_MEM_FORCE_PU = (1U << 6);  ///< The bit is used to power L1-ICache1 tag memory up. 0: follow rtc_lslp, 1: power up
        constexpr uint32_t L1_ICACHE2_TAG_MEM_FORCE_ON = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_TAG_MEM_FORCE_PD = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_TAG_MEM_FORCE_PU = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_MEM_FORCE_ON = (1U << 12);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_MEM_FORCE_PD = (1U << 13);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_MEM_FORCE_PU = (1U << 14);  ///< Reserved
        constexpr uint32_t L1_DCACHE_TAG_MEM_FORCE_ON = (1U << 16);  ///< The bit is used to close clock gating of L1-DCache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_DCACHE_TAG_MEM_FORCE_PD = (1U << 17);  ///< The bit is used to power L1-DCache tag memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_DCACHE_TAG_MEM_FORCE_PU = (1U << 18);  ///< The bit is used to power L1-DCache tag memory up. 0: follow rtc_lslp, 1: power up
    }

    /// L1_CACHE_DATA_MEM_POWER_CTRL Register bits
    namespace l1_cache_data_mem_power_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_DATA_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of L1-ICache0 data memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_ICACHE0_DATA_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power L1-ICache0 data memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_ICACHE0_DATA_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power L1-ICache0 data memory up. 0: follow rtc_lslp, 1: power up
        constexpr uint32_t L1_ICACHE1_DATA_MEM_FORCE_ON = (1U << 4);  ///< The bit is used to close clock gating of L1-ICache1 data memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_ICACHE1_DATA_MEM_FORCE_PD = (1U << 5);  ///< The bit is used to power L1-ICache1 data memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_ICACHE1_DATA_MEM_FORCE_PU = (1U << 6);  ///< The bit is used to power L1-ICache1 data memory up. 0: follow rtc_lslp, 1: power up
        constexpr uint32_t L1_ICACHE2_DATA_MEM_FORCE_ON = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_DATA_MEM_FORCE_PD = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_DATA_MEM_FORCE_PU = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_DATA_MEM_FORCE_ON = (1U << 12);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_DATA_MEM_FORCE_PD = (1U << 13);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_DATA_MEM_FORCE_PU = (1U << 14);  ///< Reserved
        constexpr uint32_t L1_DCACHE_DATA_MEM_FORCE_ON = (1U << 16);  ///< The bit is used to close clock gating of L1-DCache data memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L1_DCACHE_DATA_MEM_FORCE_PD = (1U << 17);  ///< The bit is used to power L1-DCache data memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L1_DCACHE_DATA_MEM_FORCE_PU = (1U << 18);  ///< The bit is used to power L1-DCache data memory up. 0: follow rtc_lslp, 1: power up
    }

    /// L1_CACHE_FREEZE_CTRL Register bits
    namespace l1_cache_freeze_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_FREEZE_EN = (1U << 0);  ///< The bit is used to enable freeze operation on L1-ICache0. It can be cleared by software.
        constexpr uint32_t L1_ICACHE0_FREEZE_MODE = (1U << 1);  ///< The bit is used to configure mode of freeze operation L1-ICache0. 0: a miss-access will not stuck. 1: a miss-access will stuck.
        constexpr uint32_t L1_ICACHE0_FREEZE_DONE = (1U << 2);  ///< The bit is used to indicate whether freeze operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE1_FREEZE_EN = (1U << 4);  ///< The bit is used to enable freeze operation on L1-ICache1. It can be cleared by software.
        constexpr uint32_t L1_ICACHE1_FREEZE_MODE = (1U << 5);  ///< The bit is used to configure mode of freeze operation L1-ICache1. 0: a miss-access will not stuck. 1: a miss-access will stuck.
        constexpr uint32_t L1_ICACHE1_FREEZE_DONE = (1U << 6);  ///< The bit is used to indicate whether freeze operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE2_FREEZE_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_FREEZE_MODE = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_FREEZE_DONE = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FREEZE_EN = (1U << 12);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FREEZE_MODE = (1U << 13);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FREEZE_DONE = (1U << 14);  ///< Reserved
        constexpr uint32_t L1_DCACHE_FREEZE_EN = (1U << 16);  ///< The bit is used to enable freeze operation on L1-DCache. It can be cleared by software.
        constexpr uint32_t L1_DCACHE_FREEZE_MODE = (1U << 17);  ///< The bit is used to configure mode of freeze operation L1-DCache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
        constexpr uint32_t L1_DCACHE_FREEZE_DONE = (1U << 18);  ///< The bit is used to indicate whether freeze operation on L1-DCache is finished or not. 0: not finished. 1: finished.
    }

    /// L1_CACHE_DATA_MEM_ACS_CONF Register bits
    namespace l1_cache_data_mem_acs_conf_bits {
        constexpr uint32_t L1_ICACHE0_DATA_MEM_RD_EN = (1U << 0);  ///< The bit is used to enable config-bus read L1-ICache0 data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE0_DATA_MEM_WR_EN = (1U << 1);  ///< The bit is used to enable config-bus write L1-ICache0 data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE1_DATA_MEM_RD_EN = (1U << 4);  ///< The bit is used to enable config-bus read L1-ICache1 data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE1_DATA_MEM_WR_EN = (1U << 5);  ///< The bit is used to enable config-bus write L1-ICache1 data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE2_DATA_MEM_RD_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_DATA_MEM_WR_EN = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_DATA_MEM_RD_EN = (1U << 12);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_DATA_MEM_WR_EN = (1U << 13);  ///< Reserved
        constexpr uint32_t L1_DCACHE_DATA_MEM_RD_EN = (1U << 16);  ///< The bit is used to enable config-bus read L1-DCache data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_DCACHE_DATA_MEM_WR_EN = (1U << 17);  ///< The bit is used to enable config-bus write L1-DCache data memoryory. 0: disable, 1: enable.
    }

    /// L1_CACHE_TAG_MEM_ACS_CONF Register bits
    namespace l1_cache_tag_mem_acs_conf_bits {
        constexpr uint32_t L1_ICACHE0_TAG_MEM_RD_EN = (1U << 0);  ///< The bit is used to enable config-bus read L1-ICache0 tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE0_TAG_MEM_WR_EN = (1U << 1);  ///< The bit is used to enable config-bus write L1-ICache0 tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE1_TAG_MEM_RD_EN = (1U << 4);  ///< The bit is used to enable config-bus read L1-ICache1 tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE1_TAG_MEM_WR_EN = (1U << 5);  ///< The bit is used to enable config-bus write L1-ICache1 tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_ICACHE2_TAG_MEM_RD_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE2_TAG_MEM_WR_EN = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_MEM_RD_EN = (1U << 12);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_MEM_WR_EN = (1U << 13);  ///< Reserved
        constexpr uint32_t L1_DCACHE_TAG_MEM_RD_EN = (1U << 16);  ///< The bit is used to enable config-bus read L1-DCache tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L1_DCACHE_TAG_MEM_WR_EN = (1U << 17);  ///< The bit is used to enable config-bus write L1-DCache tag memoryory. 0: disable, 1: enable.
    }

    /// L1_ICACHE0_PRELOCK_CONF Register bits
    namespace l1_icache0_prelock_conf_bits {
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L1-ICache0.
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L1-ICache0.
        constexpr uint32_t L1_ICACHE0_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l1 icache0 prelock.
    }

    /// L1_ICACHE0_PRELOCK_SCT0_ADDR Register bits
    namespace l1_icache0_prelock_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_SIZE_REG
    }

    /// L1_ICACHE0_PRELOCK_SCT1_ADDR Register bits
    namespace l1_icache0_prelock_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_SIZE_REG
    }

    /// L1_ICACHE0_PRELOCK_SCT_SIZE Register bits
    namespace l1_icache0_prelock_sct_size_bits {
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT0_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L1_ICACHE0_PRELOCK_SCT1_SIZE = (14 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_ADDR_REG
    }

    /// L1_ICACHE1_PRELOCK_CONF Register bits
    namespace l1_icache1_prelock_conf_bits {
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L1-ICache1.
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L1-ICache1.
        constexpr uint32_t L1_ICACHE1_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l1 icache1 prelock.
    }

    /// L1_ICACHE1_PRELOCK_SCT0_ADDR Register bits
    namespace l1_icache1_prelock_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_SIZE_REG
    }

    /// L1_ICACHE1_PRELOCK_SCT1_ADDR Register bits
    namespace l1_icache1_prelock_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_SIZE_REG
    }

    /// L1_ICACHE1_PRELOCK_SCT_SIZE Register bits
    namespace l1_icache1_prelock_sct_size_bits {
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT0_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L1_ICACHE1_PRELOCK_SCT1_SIZE = (14 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_ADDR_REG
    }

    /// L1_ICACHE2_PRELOCK_CONF Register bits
    namespace l1_icache2_prelock_conf_bits {
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L1-ICache2.
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L1-ICache2.
        constexpr uint32_t L1_ICACHE2_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l1 icache2 prelock.
    }

    /// L1_ICACHE2_PRELOCK_SCT0_ADDR Register bits
    namespace l1_icache2_prelock_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_SIZE_REG
    }

    /// L1_ICACHE2_PRELOCK_SCT1_ADDR Register bits
    namespace l1_icache2_prelock_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_SIZE_REG
    }

    /// L1_ICACHE2_PRELOCK_SCT_SIZE Register bits
    namespace l1_icache2_prelock_sct_size_bits {
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT0_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L1_ICACHE2_PRELOCK_SCT1_SIZE = (14 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_ADDR_REG
    }

    /// L1_ICACHE3_PRELOCK_CONF Register bits
    namespace l1_icache3_prelock_conf_bits {
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L1-ICache3.
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L1-ICache3.
        constexpr uint32_t L1_ICACHE3_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l1 icache3 prelock.
    }

    /// L1_ICACHE3_PRELOCK_SCT0_ADDR Register bits
    namespace l1_icache3_prelock_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_SIZE_REG
    }

    /// L1_ICACHE3_PRELOCK_SCT1_ADDR Register bits
    namespace l1_icache3_prelock_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_SIZE_REG
    }

    /// L1_ICACHE3_PRELOCK_SCT_SIZE Register bits
    namespace l1_icache3_prelock_sct_size_bits {
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT0_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L1_ICACHE3_PRELOCK_SCT1_SIZE = (14 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_ADDR_REG
    }

    /// L1_DCACHE_PRELOCK_CONF Register bits
    namespace l1_dcache_prelock_conf_bits {
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L1-DCache.
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L1-DCache.
        constexpr uint32_t L1_DCACHE_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l1 dcache prelock.
    }

    /// L1_DCACHE_PRELOCK_SCT0_ADDR Register bits
    namespace l1_dcache_prelock_sct0_addr_bits {
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L1-DCache, which should be used together with L1_DCACHE_PRELOCK_SCT0_SIZE_REG
    }

    /// L1_DCACHE_PRELOCK_SCT1_ADDR Register bits
    namespace l1_dcache_prelock_sct1_addr_bits {
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L1-DCache, which should be used together with L1_DCACHE_PRELOCK_SCT1_SIZE_REG
    }

    /// L1_DCACHE_PRELOCK_SCT_SIZE Register bits
    namespace l1_dcache_prelock_sct_size_bits {
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT0_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-DCache, which should be used together with L1_DCACHE_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L1_DCACHE_PRELOCK_SCT1_SIZE = (14 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L1-DCache, which should be used together with L1_DCACHE_PRELOCK_SCT1_ADDR_REG
    }

    /// LOCK_CTRL Register bits
    namespace lock_ctrl_bits {
        constexpr uint32_t LOCK_ENA = (1U << 0);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done. Note that (1) this bit and unlock_ena bit are mutually exclusive, that is, those bits can not be set to 1 at the same time. (2) lock operation can be applied on LL1-ICache, L1-DCache and L2-Cache.
        constexpr uint32_t UNLOCK_ENA = (1U << 1);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done. Note that (1) this bit and lock_ena bit are mutually exclusive, that is, those bits can not be set to 1 at the same time. (2) unlock operation can be applied on L1-ICache, L1-DCache and L2-Cache.
        constexpr uint32_t LOCK_DONE = (1U << 2);  ///< The bit is used to indicate whether unlock/lock operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t LOCK_RGID = (4 << 3);  ///< The bit is used to set the gid of cache lock/unlock.
    }

    /// LOCK_MAP Register bits
    namespace lock_map_bits {
        constexpr uint32_t LOCK_MAP = (6 << 0);  ///< Those bits are used to indicate which caches in the two-level cache structure will apply this lock/unlock operation. [0]: L1-ICache0, [1]: L1-ICache1, [2]: L1-ICache2, [3]: L1-ICache3, [4]: L1-DCache, [5]: L2-Cache.
    }

    /// LOCK_ADDR Register bits
    namespace lock_addr_bits {
        constexpr uint32_t LOCK_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the lock/unlock operation, which should be used together with CACHE_LOCK_SIZE_REG
    }

    /// LOCK_SIZE Register bits
    namespace lock_size_bits {
        constexpr uint32_t LOCK_SIZE = (16 << 0);  ///< Those bits are used to configure the size of the lock/unlock operation, which should be used together with CACHE_LOCK_ADDR_REG
    }

    /// SYNC_CTRL Register bits
    namespace sync_ctrl_bits {
        constexpr uint32_t INVALIDATE_ENA = (1U << 0);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done. Note that this bit and the other sync-bits (clean_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
        constexpr uint32_t CLEAN_ENA = (1U << 1);  ///< The bit is used to enable clean operation. It will be cleared by hardware after clean operation done. Note that this bit and the other sync-bits (invalidate_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
        constexpr uint32_t WRITEBACK_ENA = (1U << 2);  ///< The bit is used to enable writeback operation. It will be cleared by hardware after writeback operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
        constexpr uint32_t WRITEBACK_INVALIDATE_ENA = (1U << 3);  ///< The bit is used to enable writeback-invalidate operation. It will be cleared by hardware after writeback-invalidate operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
        constexpr uint32_t SYNC_DONE = (1U << 4);  ///< The bit is used to indicate whether sync operation (invalidate, clean, writeback, writeback_invalidate) is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t SYNC_RGID = (4 << 5);  ///< The bit is used to set the gid of cache sync operation (invalidate, clean, writeback, writeback_invalidate)
    }

    /// SYNC_MAP Register bits
    namespace sync_map_bits {
        constexpr uint32_t SYNC_MAP = (6 << 0);  ///< Those bits are used to indicate which caches in the two-level cache structure will apply the sync operation. [0]: L1-ICache0, [1]: L1-ICache1, [2]: L1-ICache2, [3]: L1-ICache3, [4]: L1-DCache, [5]: L2-Cache.
    }

    /// SYNC_ADDR Register bits
    namespace sync_addr_bits {
        constexpr uint32_t SYNC_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the sync operation, which should be used together with CACHE_SYNC_SIZE_REG
    }

    /// SYNC_SIZE Register bits
    namespace sync_size_bits {
        constexpr uint32_t SYNC_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the sync operation, which should be used together with CACHE_SYNC_ADDR_REG
    }

    /// L1_ICACHE0_PRELOAD_CTRL Register bits
    namespace l1_icache0_preload_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L1-ICache0. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L1_ICACHE0_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE0_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L1_ICACHE0_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l1 icache0 preload.
    }

    /// L1_ICACHE0_PRELOAD_ADDR Register bits
    namespace l1_icache0_preload_addr_bits {
        constexpr uint32_t L1_ICACHE0_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_SIZE_REG
    }

    /// L1_ICACHE0_PRELOAD_SIZE Register bits
    namespace l1_icache0_preload_size_bits {
        constexpr uint32_t L1_ICACHE0_PRELOAD_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_ADDR_REG
    }

    /// L1_ICACHE1_PRELOAD_CTRL Register bits
    namespace l1_icache1_preload_ctrl_bits {
        constexpr uint32_t L1_ICACHE1_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L1-ICache1. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L1_ICACHE1_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE1_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L1_ICACHE1_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l1 icache1 preload.
    }

    /// L1_ICACHE1_PRELOAD_ADDR Register bits
    namespace l1_icache1_preload_addr_bits {
        constexpr uint32_t L1_ICACHE1_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_SIZE_REG
    }

    /// L1_ICACHE1_PRELOAD_SIZE Register bits
    namespace l1_icache1_preload_size_bits {
        constexpr uint32_t L1_ICACHE1_PRELOAD_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_ADDR_REG
    }

    /// L1_ICACHE2_PRELOAD_CTRL Register bits
    namespace l1_icache2_preload_ctrl_bits {
        constexpr uint32_t L1_ICACHE2_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L1-ICache2. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L1_ICACHE2_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE2_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L1_ICACHE2_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l1 icache2 preload.
    }

    /// L1_ICACHE2_PRELOAD_ADDR Register bits
    namespace l1_icache2_preload_addr_bits {
        constexpr uint32_t L1_ICACHE2_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_SIZE_REG
    }

    /// L1_ICACHE2_PRELOAD_SIZE Register bits
    namespace l1_icache2_preload_size_bits {
        constexpr uint32_t L1_ICACHE2_PRELOAD_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_ADDR_REG
    }

    /// L1_ICACHE3_PRELOAD_CTRL Register bits
    namespace l1_icache3_preload_ctrl_bits {
        constexpr uint32_t L1_ICACHE3_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L1-ICache3. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L1_ICACHE3_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE3_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L1_ICACHE3_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l1 icache3 preload.
    }

    /// L1_ICACHE3_PRELOAD_ADDR Register bits
    namespace l1_icache3_preload_addr_bits {
        constexpr uint32_t L1_ICACHE3_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_SIZE_REG
    }

    /// L1_ICACHE3_PRELOAD_SIZE Register bits
    namespace l1_icache3_preload_size_bits {
        constexpr uint32_t L1_ICACHE3_PRELOAD_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_ADDR_REG
    }

    /// L1_DCACHE_PRELOAD_CTRL Register bits
    namespace l1_dcache_preload_ctrl_bits {
        constexpr uint32_t L1_DCACHE_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L1-DCache. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L1_DCACHE_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_DCACHE_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L1_DCACHE_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l1 dcache preload.
    }

    /// L1_DCACHE_PRELOAD_ADDR Register bits
    namespace l1_dcache_preload_addr_bits {
        constexpr uint32_t L1_DCACHE_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L1-DCache, which should be used together with L1_DCACHE_PRELOAD_SIZE_REG
    }

    /// L1_DCACHE_PRELOAD_SIZE Register bits
    namespace l1_dcache_preload_size_bits {
        constexpr uint32_t L1_DCACHE_PRELOAD_SIZE = (14 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L1-DCache, which should be used together with L1_DCACHE_PRELOAD_ADDR_REG
    }

    /// L1_ICACHE0_AUTOLOAD_CTRL Register bits
    namespace l1_icache0_autoload_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L1-ICache0. 1: enable, 0: disable.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L1-ICache0. 0: ascending. 1: descending.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L1-ICache0. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L1-ICache0.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L1-ICache0.
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_RGID = (4 << 10);  ///< The bit is used to set the gid of l1 icache0 autoload.
    }

    /// L1_ICACHE0_AUTOLOAD_SCT0_ADDR Register bits
    namespace l1_icache0_autoload_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE0_AUTOLOAD_SCT0_SIZE Register bits
    namespace l1_icache0_autoload_sct0_size_bits {
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE0_AUTOLOAD_SCT1_ADDR Register bits
    namespace l1_icache0_autoload_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE0_AUTOLOAD_SCT1_SIZE Register bits
    namespace l1_icache0_autoload_sct1_size_bits {
        constexpr uint32_t L1_ICACHE0_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE1_AUTOLOAD_CTRL Register bits
    namespace l1_icache1_autoload_ctrl_bits {
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L1-ICache1. 1: enable, 0: disable.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L1-ICache1. 0: ascending. 1: descending.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L1-ICache1. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L1-ICache1.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L1-ICache1.
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_RGID = (4 << 10);  ///< The bit is used to set the gid of l1 icache1 autoload.
    }

    /// L1_ICACHE1_AUTOLOAD_SCT0_ADDR Register bits
    namespace l1_icache1_autoload_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE1_AUTOLOAD_SCT0_SIZE Register bits
    namespace l1_icache1_autoload_sct0_size_bits {
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE1_AUTOLOAD_SCT1_ADDR Register bits
    namespace l1_icache1_autoload_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE1_AUTOLOAD_SCT1_SIZE Register bits
    namespace l1_icache1_autoload_sct1_size_bits {
        constexpr uint32_t L1_ICACHE1_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE2_AUTOLOAD_CTRL Register bits
    namespace l1_icache2_autoload_ctrl_bits {
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L1-ICache2. 1: enable, 0: disable.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L1-ICache2 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L1-ICache2. 0: ascending. 1: descending.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L1-ICache2. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L1-ICache2.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L1-ICache2.
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_RGID = (4 << 10);  ///< The bit is used to set the gid of l1 icache2 autoload.
    }

    /// L1_ICACHE2_AUTOLOAD_SCT0_ADDR Register bits
    namespace l1_icache2_autoload_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE2_AUTOLOAD_SCT0_SIZE Register bits
    namespace l1_icache2_autoload_sct0_size_bits {
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE2_AUTOLOAD_SCT1_ADDR Register bits
    namespace l1_icache2_autoload_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE2_AUTOLOAD_SCT1_SIZE Register bits
    namespace l1_icache2_autoload_sct1_size_bits {
        constexpr uint32_t L1_ICACHE2_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE3_AUTOLOAD_CTRL Register bits
    namespace l1_icache3_autoload_ctrl_bits {
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L1-ICache3. 1: enable, 0: disable.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L1-ICache3 is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L1-ICache3. 0: ascending. 1: descending.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L1-ICache3. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L1-ICache3.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L1-ICache3.
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_RGID = (4 << 10);  ///< The bit is used to set the gid of l1 icache3 autoload.
    }

    /// L1_ICACHE3_AUTOLOAD_SCT0_ADDR Register bits
    namespace l1_icache3_autoload_sct0_addr_bits {
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE3_AUTOLOAD_SCT0_SIZE Register bits
    namespace l1_icache3_autoload_sct0_size_bits {
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_ICACHE3_AUTOLOAD_SCT1_ADDR Register bits
    namespace l1_icache3_autoload_sct1_addr_bits {
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_ICACHE3_AUTOLOAD_SCT1_SIZE Register bits
    namespace l1_icache3_autoload_sct1_size_bits {
        constexpr uint32_t L1_ICACHE3_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Reserved
    }

    /// L1_DCACHE_AUTOLOAD_CTRL Register bits
    namespace l1_dcache_autoload_ctrl_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L1-DCache. 1: enable, 0: disable.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L1-DCache is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L1-DCache. 0: ascending. 1: descending.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L1-DCache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L1-DCache.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L1-DCache.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT2_ENA = (1U << 10);  ///< The bit is used to enable the third section for autoload operation on L1-DCache.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT3_ENA = (1U << 11);  ///< The bit is used to enable the fourth section for autoload operation on L1-DCache.
        constexpr uint32_t L1_DCACHE_AUTOLOAD_RGID = (4 << 12);  ///< The bit is used to set the gid of l1 dcache autoload.
    }

    /// L1_DCACHE_AUTOLOAD_SCT0_ADDR Register bits
    namespace l1_dcache_autoload_sct0_addr_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT0_SIZE and L1_DCACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT0_SIZE Register bits
    namespace l1_dcache_autoload_sct0_size_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT0_ADDR and L1_DCACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT1_ADDR Register bits
    namespace l1_dcache_autoload_sct1_addr_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT1_SIZE and L1_DCACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT1_SIZE Register bits
    namespace l1_dcache_autoload_sct1_size_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the second section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT1_ADDR and L1_DCACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT2_ADDR Register bits
    namespace l1_dcache_autoload_sct2_addr_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT2_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the third section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT2_SIZE and L1_DCACHE_AUTOLOAD_SCT2_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT2_SIZE Register bits
    namespace l1_dcache_autoload_sct2_size_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT2_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the third section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT2_ADDR and L1_DCACHE_AUTOLOAD_SCT2_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT3_ADDR Register bits
    namespace l1_dcache_autoload_sct3_addr_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT3_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the fourth section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT3_SIZE and L1_DCACHE_AUTOLOAD_SCT3_ENA.
    }

    /// L1_DCACHE_AUTOLOAD_SCT3_SIZE Register bits
    namespace l1_dcache_autoload_sct3_size_bits {
        constexpr uint32_t L1_DCACHE_AUTOLOAD_SCT3_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the fourth section for autoload operation on L1-DCache. Note that it should be used together with L1_DCACHE_AUTOLOAD_SCT3_ADDR and L1_DCACHE_AUTOLOAD_SCT3_ENA.
    }

    /// L1_CACHE_ACS_CNT_INT_ENA Register bits
    namespace l1_cache_acs_cnt_int_ena_bits {
        constexpr uint32_t L1_IBUS0_OVF_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
        constexpr uint32_t L1_IBUS1_OVF_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
        constexpr uint32_t L1_IBUS2_OVF_INT_ENA = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_IBUS3_OVF_INT_ENA = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DBUS0_OVF_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
        constexpr uint32_t L1_DBUS1_OVF_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
        constexpr uint32_t L1_DBUS2_OVF_INT_ENA = (1U << 6);  ///< Reserved
        constexpr uint32_t L1_DBUS3_OVF_INT_ENA = (1U << 7);  ///< Reserved
    }

    /// L1_CACHE_ACS_CNT_INT_CLR Register bits
    namespace l1_cache_acs_cnt_int_clr_bits {
        constexpr uint32_t L1_IBUS0_OVF_INT_CLR = (1U << 0);  ///< The bit is used to clear counters overflow interrupt and counters in L1-ICache0 due to bus0 accesses L1-ICache0.
        constexpr uint32_t L1_IBUS1_OVF_INT_CLR = (1U << 1);  ///< The bit is used to clear counters overflow interrupt and counters in L1-ICache1 due to bus1 accesses L1-ICache1.
        constexpr uint32_t L1_IBUS2_OVF_INT_CLR = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_IBUS3_OVF_INT_CLR = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DBUS0_OVF_INT_CLR = (1U << 4);  ///< The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus0 accesses L1-DCache.
        constexpr uint32_t L1_DBUS1_OVF_INT_CLR = (1U << 5);  ///< The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus1 accesses L1-DCache.
        constexpr uint32_t L1_DBUS2_OVF_INT_CLR = (1U << 6);  ///< Reserved
        constexpr uint32_t L1_DBUS3_OVF_INT_CLR = (1U << 7);  ///< Reserved
    }

    /// L1_CACHE_ACS_CNT_INT_RAW Register bits
    namespace l1_cache_acs_cnt_int_raw_bits {
        constexpr uint32_t L1_IBUS0_OVF_INT_RAW = (1U << 0);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
        constexpr uint32_t L1_IBUS1_OVF_INT_RAW = (1U << 1);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
        constexpr uint32_t L1_IBUS2_OVF_INT_RAW = (1U << 2);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache2 due to bus2 accesses L1-ICache2.
        constexpr uint32_t L1_IBUS3_OVF_INT_RAW = (1U << 3);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache3 due to bus3 accesses L1-ICache3.
        constexpr uint32_t L1_DBUS0_OVF_INT_RAW = (1U << 4);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
        constexpr uint32_t L1_DBUS1_OVF_INT_RAW = (1U << 5);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
        constexpr uint32_t L1_DBUS2_OVF_INT_RAW = (1U << 6);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus2 accesses L1-DCache.
        constexpr uint32_t L1_DBUS3_OVF_INT_RAW = (1U << 7);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus3 accesses L1-DCache.
    }

    /// L1_CACHE_ACS_CNT_INT_ST Register bits
    namespace l1_cache_acs_cnt_int_st_bits {
        constexpr uint32_t L1_IBUS0_OVF_INT_ST = (1U << 0);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
        constexpr uint32_t L1_IBUS1_OVF_INT_ST = (1U << 1);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
        constexpr uint32_t L1_IBUS2_OVF_INT_ST = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_IBUS3_OVF_INT_ST = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DBUS0_OVF_INT_ST = (1U << 4);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
        constexpr uint32_t L1_DBUS1_OVF_INT_ST = (1U << 5);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
        constexpr uint32_t L1_DBUS2_OVF_INT_ST = (1U << 6);  ///< Reserved
        constexpr uint32_t L1_DBUS3_OVF_INT_ST = (1U << 7);  ///< Reserved
    }

    /// L1_CACHE_ACS_FAIL_CTRL Register bits
    namespace l1_cache_acs_fail_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_ACS_FAIL_CHECK_MODE = (1U << 0);  ///< The bit is used to configure l1 icache0 access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
        constexpr uint32_t L1_ICACHE1_ACS_FAIL_CHECK_MODE = (1U << 1);  ///< The bit is used to configure l1 icache1 access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
        constexpr uint32_t L1_ICACHE2_ACS_FAIL_CHECK_MODE = (1U << 2);  ///< The bit is used to configure l1 icache2 access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
        constexpr uint32_t L1_ICACHE3_ACS_FAIL_CHECK_MODE = (1U << 3);  ///< The bit is used to configure l1 icache3 access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
        constexpr uint32_t L1_DCACHE_ACS_FAIL_CHECK_MODE = (1U << 4);  ///< The bit is used to configure l1 dcache access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
    }

    /// L1_CACHE_ACS_FAIL_INT_ENA Register bits
    namespace l1_cache_acs_fail_int_ena_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
        constexpr uint32_t L1_ICACHE1_FAIL_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
        constexpr uint32_t L1_ICACHE2_FAIL_INT_ENA = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FAIL_INT_ENA = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_FAIL_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
    }

    /// L1_CACHE_ACS_FAIL_INT_CLR Register bits
    namespace l1_cache_acs_fail_int_clr_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
        constexpr uint32_t L1_ICACHE1_FAIL_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
        constexpr uint32_t L1_ICACHE2_FAIL_INT_CLR = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FAIL_INT_CLR = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_FAIL_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
    }

    /// L1_CACHE_ACS_FAIL_INT_RAW Register bits
    namespace l1_cache_acs_fail_int_raw_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_INT_RAW = (1U << 0);  ///< The raw bit of the interrupt of access fail that occurs in L1-ICache0.
        constexpr uint32_t L1_ICACHE1_FAIL_INT_RAW = (1U << 1);  ///< The raw bit of the interrupt of access fail that occurs in L1-ICache1.
        constexpr uint32_t L1_ICACHE2_FAIL_INT_RAW = (1U << 2);  ///< The raw bit of the interrupt of access fail that occurs in L1-ICache2.
        constexpr uint32_t L1_ICACHE3_FAIL_INT_RAW = (1U << 3);  ///< The raw bit of the interrupt of access fail that occurs in L1-ICache3.
        constexpr uint32_t L1_DCACHE_FAIL_INT_RAW = (1U << 4);  ///< The raw bit of the interrupt of access fail that occurs in L1-DCache.
    }

    /// L1_CACHE_ACS_FAIL_INT_ST Register bits
    namespace l1_cache_acs_fail_int_st_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_INT_ST = (1U << 0);  ///< The bit indicates the interrupt status of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache.
        constexpr uint32_t L1_ICACHE1_FAIL_INT_ST = (1U << 1);  ///< The bit indicates the interrupt status of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache.
        constexpr uint32_t L1_ICACHE2_FAIL_INT_ST = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_FAIL_INT_ST = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_FAIL_INT_ST = (1U << 4);  ///< The bit indicates the interrupt status of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
    }

    /// L1_CACHE_ACS_CNT_CTRL Register bits
    namespace l1_cache_acs_cnt_ctrl_bits {
        constexpr uint32_t L1_IBUS0_CNT_ENA = (1U << 0);  ///< The bit is used to enable ibus0 counter in L1-ICache0.
        constexpr uint32_t L1_IBUS1_CNT_ENA = (1U << 1);  ///< The bit is used to enable ibus1 counter in L1-ICache1.
        constexpr uint32_t L1_IBUS2_CNT_ENA = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_IBUS3_CNT_ENA = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DBUS0_CNT_ENA = (1U << 4);  ///< The bit is used to enable dbus0 counter in L1-DCache.
        constexpr uint32_t L1_DBUS1_CNT_ENA = (1U << 5);  ///< The bit is used to enable dbus1 counter in L1-DCache.
        constexpr uint32_t L1_DBUS2_CNT_ENA = (1U << 6);  ///< Reserved
        constexpr uint32_t L1_DBUS3_CNT_ENA = (1U << 7);  ///< Reserved
        constexpr uint32_t L1_IBUS0_CNT_CLR = (1U << 16);  ///< The bit is used to clear ibus0 counter in L1-ICache0.
        constexpr uint32_t L1_IBUS1_CNT_CLR = (1U << 17);  ///< The bit is used to clear ibus1 counter in L1-ICache1.
        constexpr uint32_t L1_IBUS2_CNT_CLR = (1U << 18);  ///< Reserved
        constexpr uint32_t L1_IBUS3_CNT_CLR = (1U << 19);  ///< Reserved
        constexpr uint32_t L1_DBUS0_CNT_CLR = (1U << 20);  ///< The bit is used to clear dbus0 counter in L1-DCache.
        constexpr uint32_t L1_DBUS1_CNT_CLR = (1U << 21);  ///< The bit is used to clear dbus1 counter in L1-DCache.
        constexpr uint32_t L1_DBUS2_CNT_CLR = (1U << 22);  ///< Reserved
        constexpr uint32_t L1_DBUS3_CNT_CLR = (1U << 23);  ///< Reserved
    }

    /// L1_IBUS0_ACS_HIT_CNT Register bits
    namespace l1_ibus0_acs_hit_cnt_bits {
        constexpr uint32_t L1_IBUS0_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus0 accesses L1-ICache0.
    }

    /// L1_IBUS0_ACS_MISS_CNT Register bits
    namespace l1_ibus0_acs_miss_cnt_bits {
        constexpr uint32_t L1_IBUS0_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus0 accesses L1-ICache0.
    }

    /// L1_IBUS0_ACS_CONFLICT_CNT Register bits
    namespace l1_ibus0_acs_conflict_cnt_bits {
        constexpr uint32_t L1_IBUS0_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus0 accesses L1-ICache0.
    }

    /// L1_IBUS0_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_ibus0_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_IBUS0_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-ICache accesses L2-Cache due to bus0 accessing L1-ICache0.
    }

    /// L1_IBUS1_ACS_HIT_CNT Register bits
    namespace l1_ibus1_acs_hit_cnt_bits {
        constexpr uint32_t L1_IBUS1_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus1 accesses L1-ICache1.
    }

    /// L1_IBUS1_ACS_MISS_CNT Register bits
    namespace l1_ibus1_acs_miss_cnt_bits {
        constexpr uint32_t L1_IBUS1_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus1 accesses L1-ICache1.
    }

    /// L1_IBUS1_ACS_CONFLICT_CNT Register bits
    namespace l1_ibus1_acs_conflict_cnt_bits {
        constexpr uint32_t L1_IBUS1_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus1 accesses L1-ICache1.
    }

    /// L1_IBUS1_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_ibus1_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_IBUS1_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-ICache accesses L2-Cache due to bus1 accessing L1-ICache1.
    }

    /// L1_IBUS2_ACS_HIT_CNT Register bits
    namespace l1_ibus2_acs_hit_cnt_bits {
        constexpr uint32_t L1_IBUS2_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus2 accesses L1-ICache2.
    }

    /// L1_IBUS2_ACS_MISS_CNT Register bits
    namespace l1_ibus2_acs_miss_cnt_bits {
        constexpr uint32_t L1_IBUS2_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus2 accesses L1-ICache2.
    }

    /// L1_IBUS2_ACS_CONFLICT_CNT Register bits
    namespace l1_ibus2_acs_conflict_cnt_bits {
        constexpr uint32_t L1_IBUS2_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus2 accesses L1-ICache2.
    }

    /// L1_IBUS2_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_ibus2_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_IBUS2_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-ICache accesses L2-Cache due to bus2 accessing L1-ICache2.
    }

    /// L1_IBUS3_ACS_HIT_CNT Register bits
    namespace l1_ibus3_acs_hit_cnt_bits {
        constexpr uint32_t L1_IBUS3_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus3 accesses L1-ICache3.
    }

    /// L1_IBUS3_ACS_MISS_CNT Register bits
    namespace l1_ibus3_acs_miss_cnt_bits {
        constexpr uint32_t L1_IBUS3_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus3 accesses L1-ICache3.
    }

    /// L1_IBUS3_ACS_CONFLICT_CNT Register bits
    namespace l1_ibus3_acs_conflict_cnt_bits {
        constexpr uint32_t L1_IBUS3_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus3 accesses L1-ICache3.
    }

    /// L1_IBUS3_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_ibus3_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_IBUS3_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-ICache accesses L2-Cache due to bus3 accessing L1-ICache3.
    }

    /// L1_DBUS0_ACS_HIT_CNT Register bits
    namespace l1_dbus0_acs_hit_cnt_bits {
        constexpr uint32_t L1_DBUS0_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus0 accesses L1-DCache.
    }

    /// L1_DBUS0_ACS_MISS_CNT Register bits
    namespace l1_dbus0_acs_miss_cnt_bits {
        constexpr uint32_t L1_DBUS0_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus0 accesses L1-DCache.
    }

    /// L1_DBUS0_ACS_CONFLICT_CNT Register bits
    namespace l1_dbus0_acs_conflict_cnt_bits {
        constexpr uint32_t L1_DBUS0_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus0 accesses L1-DCache.
    }

    /// L1_DBUS0_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_dbus0_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_DBUS0_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L1_DBUS0_ACS_NXTLVL_WR_CNT Register bits
    namespace l1_dbus0_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L1_DBUS0_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when bus0 accesses L1-DCache.
    }

    /// L1_DBUS1_ACS_HIT_CNT Register bits
    namespace l1_dbus1_acs_hit_cnt_bits {
        constexpr uint32_t L1_DBUS1_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus1 accesses L1-DCache.
    }

    /// L1_DBUS1_ACS_MISS_CNT Register bits
    namespace l1_dbus1_acs_miss_cnt_bits {
        constexpr uint32_t L1_DBUS1_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus1 accesses L1-DCache.
    }

    /// L1_DBUS1_ACS_CONFLICT_CNT Register bits
    namespace l1_dbus1_acs_conflict_cnt_bits {
        constexpr uint32_t L1_DBUS1_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus1 accesses L1-DCache.
    }

    /// L1_DBUS1_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_dbus1_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_DBUS1_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L1_DBUS1_ACS_NXTLVL_WR_CNT Register bits
    namespace l1_dbus1_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L1_DBUS1_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when bus1 accesses L1-DCache.
    }

    /// L1_DBUS2_ACS_HIT_CNT Register bits
    namespace l1_dbus2_acs_hit_cnt_bits {
        constexpr uint32_t L1_DBUS2_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus2 accesses L1-DCache.
    }

    /// L1_DBUS2_ACS_MISS_CNT Register bits
    namespace l1_dbus2_acs_miss_cnt_bits {
        constexpr uint32_t L1_DBUS2_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus2 accesses L1-DCache.
    }

    /// L1_DBUS2_ACS_CONFLICT_CNT Register bits
    namespace l1_dbus2_acs_conflict_cnt_bits {
        constexpr uint32_t L1_DBUS2_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus2 accesses L1-DCache.
    }

    /// L1_DBUS2_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_dbus2_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_DBUS2_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L1_DBUS2_ACS_NXTLVL_WR_CNT Register bits
    namespace l1_dbus2_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L1_DBUS2_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when bus2 accesses L1-DCache.
    }

    /// L1_DBUS3_ACS_HIT_CNT Register bits
    namespace l1_dbus3_acs_hit_cnt_bits {
        constexpr uint32_t L1_DBUS3_HIT_CNT = (32 << 0);  ///< The register records the number of hits when bus3 accesses L1-DCache.
    }

    /// L1_DBUS3_ACS_MISS_CNT Register bits
    namespace l1_dbus3_acs_miss_cnt_bits {
        constexpr uint32_t L1_DBUS3_MISS_CNT = (32 << 0);  ///< The register records the number of missing when bus3 accesses L1-DCache.
    }

    /// L1_DBUS3_ACS_CONFLICT_CNT Register bits
    namespace l1_dbus3_acs_conflict_cnt_bits {
        constexpr uint32_t L1_DBUS3_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when bus3 accesses L1-DCache.
    }

    /// L1_DBUS3_ACS_NXTLVL_RD_CNT Register bits
    namespace l1_dbus3_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L1_DBUS3_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L1_DBUS3_ACS_NXTLVL_WR_CNT Register bits
    namespace l1_dbus3_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L1_DBUS3_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when bus0 accesses L1-DCache.
    }

    /// L1_ICACHE0_ACS_FAIL_ID_ATTR Register bits
    namespace l1_icache0_acs_fail_id_attr_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when cache0 accesses L1-ICache.
        constexpr uint32_t L1_ICACHE0_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when cache0 accesses L1-ICache.
    }

    /// L1_ICACHE0_ACS_FAIL_ADDR Register bits
    namespace l1_icache0_acs_fail_addr_bits {
        constexpr uint32_t L1_ICACHE0_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when cache0 accesses L1-ICache.
    }

    /// L1_ICACHE1_ACS_FAIL_ID_ATTR Register bits
    namespace l1_icache1_acs_fail_id_attr_bits {
        constexpr uint32_t L1_ICACHE1_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when cache1 accesses L1-ICache.
        constexpr uint32_t L1_ICACHE1_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when cache1 accesses L1-ICache.
    }

    /// L1_ICACHE1_ACS_FAIL_ADDR Register bits
    namespace l1_icache1_acs_fail_addr_bits {
        constexpr uint32_t L1_ICACHE1_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when cache1 accesses L1-ICache.
    }

    /// L1_ICACHE2_ACS_FAIL_ID_ATTR Register bits
    namespace l1_icache2_acs_fail_id_attr_bits {
        constexpr uint32_t L1_ICACHE2_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when cache2 accesses L1-ICache.
        constexpr uint32_t L1_ICACHE2_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when cache2 accesses L1-ICache.
    }

    /// L1_ICACHE2_ACS_FAIL_ADDR Register bits
    namespace l1_icache2_acs_fail_addr_bits {
        constexpr uint32_t L1_ICACHE2_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when cache2 accesses L1-ICache.
    }

    /// L1_ICACHE3_ACS_FAIL_ID_ATTR Register bits
    namespace l1_icache3_acs_fail_id_attr_bits {
        constexpr uint32_t L1_ICACHE3_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when cache3 accesses L1-ICache.
        constexpr uint32_t L1_ICACHE3_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when cache3 accesses L1-ICache.
    }

    /// L1_ICACHE3_ACS_FAIL_ADDR Register bits
    namespace l1_icache3_acs_fail_addr_bits {
        constexpr uint32_t L1_ICACHE3_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when cache3 accesses L1-ICache.
    }

    /// L1_DCACHE_ACS_FAIL_ID_ATTR Register bits
    namespace l1_dcache_acs_fail_id_attr_bits {
        constexpr uint32_t L1_DCACHE_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when cache accesses L1-DCache.
        constexpr uint32_t L1_DCACHE_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when cache accesses L1-DCache.
    }

    /// L1_DCACHE_ACS_FAIL_ADDR Register bits
    namespace l1_dcache_acs_fail_addr_bits {
        constexpr uint32_t L1_DCACHE_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when cache accesses L1-DCache.
    }

    /// SYNC_L1_CACHE_PRELOAD_INT_ENA Register bits
    namespace sync_l1_cache_preload_int_ena_bits {
        constexpr uint32_t L1_ICACHE0_PLD_DONE_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt of L1-ICache0 preload-operation. If preload operation is done, interrupt occurs.
        constexpr uint32_t L1_ICACHE1_PLD_DONE_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt of L1-ICache1 preload-operation. If preload operation is done, interrupt occurs.
        constexpr uint32_t L1_ICACHE2_PLD_DONE_INT_ENA = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_DONE_INT_ENA = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_DONE_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt of L1-DCache preload-operation. If preload operation is done, interrupt occurs.
        constexpr uint32_t SYNC_DONE_INT_ENA = (1U << 6);  ///< The bit is used to enable interrupt of Cache sync-operation done.
        constexpr uint32_t L1_ICACHE0_PLD_ERR_INT_ENA = (1U << 7);  ///< The bit is used to enable interrupt of L1-ICache0 preload-operation error.
        constexpr uint32_t L1_ICACHE1_PLD_ERR_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt of L1-ICache1 preload-operation error.
        constexpr uint32_t L1_ICACHE2_PLD_ERR_INT_ENA = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_ERR_INT_ENA = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_ERR_INT_ENA = (1U << 11);  ///< The bit is used to enable interrupt of L1-DCache preload-operation error.
        constexpr uint32_t SYNC_ERR_INT_ENA = (1U << 13);  ///< The bit is used to enable interrupt of Cache sync-operation error.
    }

    /// SYNC_L1_CACHE_PRELOAD_INT_CLR Register bits
    namespace sync_l1_cache_preload_int_clr_bits {
        constexpr uint32_t L1_ICACHE0_PLD_DONE_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt that occurs only when L1-ICache0 preload-operation is done.
        constexpr uint32_t L1_ICACHE1_PLD_DONE_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt that occurs only when L1-ICache1 preload-operation is done.
        constexpr uint32_t L1_ICACHE2_PLD_DONE_INT_CLR = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_DONE_INT_CLR = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_DONE_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt that occurs only when L1-DCache preload-operation is done.
        constexpr uint32_t SYNC_DONE_INT_CLR = (1U << 6);  ///< The bit is used to clear interrupt that occurs only when Cache sync-operation is done.
        constexpr uint32_t L1_ICACHE0_PLD_ERR_INT_CLR = (1U << 7);  ///< The bit is used to clear interrupt of L1-ICache0 preload-operation error.
        constexpr uint32_t L1_ICACHE1_PLD_ERR_INT_CLR = (1U << 8);  ///< The bit is used to clear interrupt of L1-ICache1 preload-operation error.
        constexpr uint32_t L1_ICACHE2_PLD_ERR_INT_CLR = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_ERR_INT_CLR = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_ERR_INT_CLR = (1U << 11);  ///< The bit is used to clear interrupt of L1-DCache preload-operation error.
        constexpr uint32_t SYNC_ERR_INT_CLR = (1U << 13);  ///< The bit is used to clear interrupt of Cache sync-operation error.
    }

    /// SYNC_L1_CACHE_PRELOAD_INT_RAW Register bits
    namespace sync_l1_cache_preload_int_raw_bits {
        constexpr uint32_t L1_ICACHE0_PLD_DONE_INT_RAW = (1U << 0);  ///< The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation is done.
        constexpr uint32_t L1_ICACHE1_PLD_DONE_INT_RAW = (1U << 1);  ///< The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation is done.
        constexpr uint32_t L1_ICACHE2_PLD_DONE_INT_RAW = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_DONE_INT_RAW = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_DONE_INT_RAW = (1U << 4);  ///< The raw bit of the interrupt that occurs only when L1-DCache preload-operation is done.
        constexpr uint32_t SYNC_DONE_INT_RAW = (1U << 6);  ///< The raw bit of the interrupt that occurs only when Cache sync-operation is done.
        constexpr uint32_t L1_ICACHE0_PLD_ERR_INT_RAW = (1U << 7);  ///< The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation error occurs.
        constexpr uint32_t L1_ICACHE1_PLD_ERR_INT_RAW = (1U << 8);  ///< The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation error occurs.
        constexpr uint32_t L1_ICACHE2_PLD_ERR_INT_RAW = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_ERR_INT_RAW = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_ERR_INT_RAW = (1U << 11);  ///< The raw bit of the interrupt that occurs only when L1-DCache preload-operation error occurs.
        constexpr uint32_t SYNC_ERR_INT_RAW = (1U << 13);  ///< The raw bit of the interrupt that occurs only when Cache sync-operation error occurs.
    }

    /// SYNC_L1_CACHE_PRELOAD_INT_ST Register bits
    namespace sync_l1_cache_preload_int_st_bits {
        constexpr uint32_t L1_ICACHE0_PLD_DONE_INT_ST = (1U << 0);  ///< The bit indicates the status of the interrupt that occurs only when L1-ICache0 preload-operation is done.
        constexpr uint32_t L1_ICACHE1_PLD_DONE_INT_ST = (1U << 1);  ///< The bit indicates the status of the interrupt that occurs only when L1-ICache1 preload-operation is done.
        constexpr uint32_t L1_ICACHE2_PLD_DONE_INT_ST = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_DONE_INT_ST = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_DONE_INT_ST = (1U << 4);  ///< The bit indicates the status of the interrupt that occurs only when L1-DCache preload-operation is done.
        constexpr uint32_t SYNC_DONE_INT_ST = (1U << 6);  ///< The bit indicates the status of the interrupt that occurs only when Cache sync-operation is done.
        constexpr uint32_t L1_ICACHE0_PLD_ERR_INT_ST = (1U << 7);  ///< The bit indicates the status of the interrupt of L1-ICache0 preload-operation error.
        constexpr uint32_t L1_ICACHE1_PLD_ERR_INT_ST = (1U << 8);  ///< The bit indicates the status of the interrupt of L1-ICache1 preload-operation error.
        constexpr uint32_t L1_ICACHE2_PLD_ERR_INT_ST = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_ERR_INT_ST = (1U << 10);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_ERR_INT_ST = (1U << 11);  ///< The bit indicates the status of the interrupt of L1-DCache preload-operation error.
        constexpr uint32_t SYNC_ERR_INT_ST = (1U << 13);  ///< The bit indicates the status of the interrupt of Cache sync-operation error.
    }

    /// SYNC_L1_CACHE_PRELOAD_EXCEPTION Register bits
    namespace sync_l1_cache_preload_exception_bits {
        constexpr uint32_t L1_ICACHE0_PLD_ERR_CODE = (2 << 0);  ///< The value 2 is Only available which means preload size is error in L1-ICache0.
        constexpr uint32_t L1_ICACHE1_PLD_ERR_CODE = (2 << 2);  ///< The value 2 is Only available which means preload size is error in L1-ICache1.
        constexpr uint32_t L1_ICACHE2_PLD_ERR_CODE = (2 << 4);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_ERR_CODE = (2 << 6);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_ERR_CODE = (2 << 8);  ///< The value 2 is Only available which means preload size is error in L1-DCache.
        constexpr uint32_t SYNC_ERR_CODE = (2 << 12);  ///< The values 0-2 are available which means sync map, command conflict and size are error in Cache System.
    }

    /// L1_CACHE_SYNC_RST_CTRL Register bits
    namespace l1_cache_sync_rst_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_SYNC_RST = (1U << 0);  ///< set this bit to reset sync-logic inside L1-ICache0. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
        constexpr uint32_t L1_ICACHE1_SYNC_RST = (1U << 1);  ///< set this bit to reset sync-logic inside L1-ICache1. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
        constexpr uint32_t L1_ICACHE2_SYNC_RST = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_SYNC_RST = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_SYNC_RST = (1U << 4);  ///< set this bit to reset sync-logic inside L1-DCache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
    }

    /// L1_CACHE_PRELOAD_RST_CTRL Register bits
    namespace l1_cache_preload_rst_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_PLD_RST = (1U << 0);  ///< set this bit to reset preload-logic inside L1-ICache0. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
        constexpr uint32_t L1_ICACHE1_PLD_RST = (1U << 1);  ///< set this bit to reset preload-logic inside L1-ICache1. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
        constexpr uint32_t L1_ICACHE2_PLD_RST = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_PLD_RST = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_PLD_RST = (1U << 4);  ///< set this bit to reset preload-logic inside L1-DCache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
    }

    /// L1_CACHE_AUTOLOAD_BUF_CLR_CTRL Register bits
    namespace l1_cache_autoload_buf_clr_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_ALD_BUF_CLR = (1U << 0);  ///< set this bit to clear autoload-buffer inside L1-ICache0. If this bit is active, autoload will not work in L1-ICache0. This bit should not be active when autoload works in L1-ICache0.
        constexpr uint32_t L1_ICACHE1_ALD_BUF_CLR = (1U << 1);  ///< set this bit to clear autoload-buffer inside L1-ICache1. If this bit is active, autoload will not work in L1-ICache1. This bit should not be active when autoload works in L1-ICache1.
        constexpr uint32_t L1_ICACHE2_ALD_BUF_CLR = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_ALD_BUF_CLR = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_ALD_BUF_CLR = (1U << 4);  ///< set this bit to clear autoload-buffer inside L1-DCache. If this bit is active, autoload will not work in L1-DCache. This bit should not be active when autoload works in L1-DCache.
    }

    /// L1_UNALLOCATE_BUFFER_CLEAR Register bits
    namespace l1_unallocate_buffer_clear_bits {
        constexpr uint32_t L1_ICACHE0_UNALLOC_CLR = (1U << 0);  ///< The bit is used to clear the unallocate request buffer of l1 icache0 where the unallocate request is responsed but not completed.
        constexpr uint32_t L1_ICACHE1_UNALLOC_CLR = (1U << 1);  ///< The bit is used to clear the unallocate request buffer of l1 icache1 where the unallocate request is responsed but not completed.
        constexpr uint32_t L1_ICACHE2_UNALLOC_CLR = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_UNALLOC_CLR = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_UNALLOC_CLR = (1U << 4);  ///< The bit is used to clear the unallocate request buffer of l1 dcache where the unallocate request is responsed but not completed.
    }

    /// L1_CACHE_OBJECT_CTRL Register bits
    namespace l1_cache_object_ctrl_bits {
        constexpr uint32_t L1_ICACHE0_TAG_OBJECT = (1U << 0);  ///< Set this bit to set L1-ICache0 tag memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L1_ICACHE1_TAG_OBJECT = (1U << 1);  ///< Set this bit to set L1-ICache1 tag memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L1_ICACHE2_TAG_OBJECT = (1U << 2);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_TAG_OBJECT = (1U << 3);  ///< Reserved
        constexpr uint32_t L1_DCACHE_TAG_OBJECT = (1U << 4);  ///< Set this bit to set L1-DCache tag memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L1_ICACHE0_MEM_OBJECT = (1U << 6);  ///< Set this bit to set L1-ICache0 data memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L1_ICACHE1_MEM_OBJECT = (1U << 7);  ///< Set this bit to set L1-ICache1 data memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L1_ICACHE2_MEM_OBJECT = (1U << 8);  ///< Reserved
        constexpr uint32_t L1_ICACHE3_MEM_OBJECT = (1U << 9);  ///< Reserved
        constexpr uint32_t L1_DCACHE_MEM_OBJECT = (1U << 10);  ///< Set this bit to set L1-DCache data memory as object. This bit should be onehot with the others fields inside this register.
    }

    /// L1_CACHE_WAY_OBJECT Register bits
    namespace l1_cache_way_object_bits {
        constexpr uint32_t L1_CACHE_WAY_OBJECT = (3 << 0);  ///< Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
    }

    /// L1_CACHE_VADDR Register bits
    namespace l1_cache_vaddr_bits {
        constexpr uint32_t L1_CACHE_VADDR = (32 << 0);  ///< Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
    }

    /// L1_CACHE_DEBUG_BUS Register bits
    namespace l1_cache_debug_bus_bits {
        constexpr uint32_t L1_CACHE_DEBUG_BUS = (32 << 0);  ///< This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
    }

    /// LEVEL_SPLIT0 Register bits
    namespace level_split0_bits {
        constexpr uint32_t LEVEL_SPLIT0 = (32 << 0);  ///< Reserved
    }

    /// L2_CACHE_CTRL Register bits
    namespace l2_cache_ctrl_bits {
        constexpr uint32_t L2_CACHE_SHUT_DMA = (1U << 4);  ///< The bit is used to disable DMA access L2-Cache, 0: enable, 1: disable
        constexpr uint32_t L2_CACHE_UNDEF_OP = (8 << 8);  ///< Reserved
    }

    /// L2_BYPASS_CACHE_CONF Register bits
    namespace l2_bypass_cache_conf_bits {
        constexpr uint32_t BYPASS_L2_CACHE_EN = (1U << 5);  ///< The bit is used to enable bypass L2-Cache. 0: disable bypass, 1: enable bypass.
    }

    /// L2_CACHE_CACHESIZE_CONF Register bits
    namespace l2_cache_cachesize_conf_bits {
        constexpr uint32_t L2_CACHE_CACHESIZE_256 = (1U << 0);  ///< The field is used to configure cachesize of L2-Cache as 256 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_512 = (1U << 1);  ///< The field is used to configure cachesize of L2-Cache as 512 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_1K = (1U << 2);  ///< The field is used to configure cachesize of L2-Cache as 1k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_2K = (1U << 3);  ///< The field is used to configure cachesize of L2-Cache as 2k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_4K = (1U << 4);  ///< The field is used to configure cachesize of L2-Cache as 4k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_8K = (1U << 5);  ///< The field is used to configure cachesize of L2-Cache as 8k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_16K = (1U << 6);  ///< The field is used to configure cachesize of L2-Cache as 16k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_32K = (1U << 7);  ///< The field is used to configure cachesize of L2-Cache as 32k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_64K = (1U << 8);  ///< The field is used to configure cachesize of L2-Cache as 64k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_128K = (1U << 9);  ///< The field is used to configure cachesize of L2-Cache as 128k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_256K = (1U << 10);  ///< The field is used to configure cachesize of L2-Cache as 256k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_512K = (1U << 11);  ///< The field is used to configure cachesize of L2-Cache as 512k bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_CACHESIZE_1024K = (1U << 12);  ///< The field is used to configure cachesize of L2-Cache as 1024k bytes. This field and all other fields within this register is onehot.
    }

    /// L2_CACHE_BLOCKSIZE_CONF Register bits
    namespace l2_cache_blocksize_conf_bits {
        constexpr uint32_t L2_CACHE_BLOCKSIZE_8 = (1U << 0);  ///< The field is used to configureblocksize of L2-Cache as 8 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_BLOCKSIZE_16 = (1U << 1);  ///< The field is used to configureblocksize of L2-Cache as 16 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_BLOCKSIZE_32 = (1U << 2);  ///< The field is used to configureblocksize of L2-Cache as 32 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_BLOCKSIZE_64 = (1U << 3);  ///< The field is used to configureblocksize of L2-Cache as 64 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_BLOCKSIZE_128 = (1U << 4);  ///< The field is used to configureblocksize of L2-Cache as 128 bytes. This field and all other fields within this register is onehot.
        constexpr uint32_t L2_CACHE_BLOCKSIZE_256 = (1U << 5);  ///< The field is used to configureblocksize of L2-Cache as 256 bytes. This field and all other fields within this register is onehot.
    }

    /// L2_CACHE_WRAP_AROUND_CTRL Register bits
    namespace l2_cache_wrap_around_ctrl_bits {
        constexpr uint32_t L2_CACHE_WRAP = (1U << 5);  ///< Set this bit as 1 to enable L2-Cache wrap around mode.
    }

    /// L2_CACHE_TAG_MEM_POWER_CTRL Register bits
    namespace l2_cache_tag_mem_power_ctrl_bits {
        constexpr uint32_t L2_CACHE_TAG_MEM_FORCE_ON = (1U << 20);  ///< The bit is used to close clock gating of L2-Cache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L2_CACHE_TAG_MEM_FORCE_PD = (1U << 21);  ///< The bit is used to power L2-Cache tag memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L2_CACHE_TAG_MEM_FORCE_PU = (1U << 22);  ///< The bit is used to power L2-Cache tag memory up. 0: follow rtc_lslp, 1: power up
    }

    /// L2_CACHE_DATA_MEM_POWER_CTRL Register bits
    namespace l2_cache_data_mem_power_ctrl_bits {
        constexpr uint32_t L2_CACHE_DATA_MEM_FORCE_ON = (1U << 20);  ///< The bit is used to close clock gating of L2-Cache data memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t L2_CACHE_DATA_MEM_FORCE_PD = (1U << 21);  ///< The bit is used to power L2-Cache data memory down. 0: follow rtc_lslp, 1: power down
        constexpr uint32_t L2_CACHE_DATA_MEM_FORCE_PU = (1U << 22);  ///< The bit is used to power L2-Cache data memory up. 0: follow rtc_lslp, 1: power up
    }

    /// L2_CACHE_FREEZE_CTRL Register bits
    namespace l2_cache_freeze_ctrl_bits {
        constexpr uint32_t L2_CACHE_FREEZE_EN = (1U << 20);  ///< The bit is used to enable freeze operation on L2-Cache. It can be cleared by software.
        constexpr uint32_t L2_CACHE_FREEZE_MODE = (1U << 21);  ///< The bit is used to configure mode of freeze operation L2-Cache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
        constexpr uint32_t L2_CACHE_FREEZE_DONE = (1U << 22);  ///< The bit is used to indicate whether freeze operation on L2-Cache is finished or not. 0: not finished. 1: finished.
    }

    /// L2_CACHE_DATA_MEM_ACS_CONF Register bits
    namespace l2_cache_data_mem_acs_conf_bits {
        constexpr uint32_t L2_CACHE_DATA_MEM_RD_EN = (1U << 20);  ///< The bit is used to enable config-bus read L2-Cache data memoryory. 0: disable, 1: enable.
        constexpr uint32_t L2_CACHE_DATA_MEM_WR_EN = (1U << 21);  ///< The bit is used to enable config-bus write L2-Cache data memoryory. 0: disable, 1: enable.
    }

    /// L2_CACHE_TAG_MEM_ACS_CONF Register bits
    namespace l2_cache_tag_mem_acs_conf_bits {
        constexpr uint32_t L2_CACHE_TAG_MEM_RD_EN = (1U << 20);  ///< The bit is used to enable config-bus read L2-Cache tag memoryory. 0: disable, 1: enable.
        constexpr uint32_t L2_CACHE_TAG_MEM_WR_EN = (1U << 21);  ///< The bit is used to enable config-bus write L2-Cache tag memoryory. 0: disable, 1: enable.
    }

    /// L2_CACHE_PRELOCK_CONF Register bits
    namespace l2_cache_prelock_conf_bits {
        constexpr uint32_t L2_CACHE_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function on L2-Cache.
        constexpr uint32_t L2_CACHE_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function on L2-Cache.
        constexpr uint32_t L2_CACHE_PRELOCK_RGID = (4 << 2);  ///< The bit is used to set the gid of l2 cache prelock.
    }

    /// L2_CACHE_PRELOCK_SCT0_ADDR Register bits
    namespace l2_cache_prelock_sct0_addr_bits {
        constexpr uint32_t L2_CACHE_PRELOCK_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_SIZE_REG
    }

    /// L2_CACHE_PRELOCK_SCT1_ADDR Register bits
    namespace l2_cache_prelock_sct1_addr_bits {
        constexpr uint32_t L2_CACHE_PRELOCK_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_SIZE_REG
    }

    /// L2_CACHE_PRELOCK_SCT_SIZE Register bits
    namespace l2_cache_prelock_sct_size_bits {
        constexpr uint32_t L2_CACHE_PRELOCK_SCT0_SIZE = (16 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_ADDR_REG
        constexpr uint32_t L2_CACHE_PRELOCK_SCT1_SIZE = (16 << 16);  ///< Those bits are used to configure the size of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_ADDR_REG
    }

    /// L2_CACHE_PRELOAD_CTRL Register bits
    namespace l2_cache_preload_ctrl_bits {
        constexpr uint32_t L2_CACHE_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation on L2-Cache. It will be cleared by hardware automatically after preload operation is done.
        constexpr uint32_t L2_CACHE_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L2_CACHE_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
        constexpr uint32_t L2_CACHE_PRELOAD_RGID = (4 << 3);  ///< The bit is used to set the gid of l2 cache preload.
    }

    /// L2_CACHE_PRELOAD_ADDR Register bits
    namespace l2_cache_preload_addr_bits {
        constexpr uint32_t L2_CACHE_PRELOAD_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of preload on L2-Cache, which should be used together with L2_CACHE_PRELOAD_SIZE_REG
    }

    /// L2_CACHE_PRELOAD_SIZE Register bits
    namespace l2_cache_preload_size_bits {
        constexpr uint32_t L2_CACHE_PRELOAD_SIZE = (16 << 0);  ///< Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOAD_ADDR_REG
    }

    /// L2_CACHE_AUTOLOAD_CTRL Register bits
    namespace l2_cache_autoload_ctrl_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_ENA = (1U << 0);  ///< The bit is used to enable and disable autoload operation on L2-Cache. 1: enable, 0: disable.
        constexpr uint32_t L2_CACHE_AUTOLOAD_DONE = (1U << 1);  ///< The bit is used to indicate whether autoload operation on L2-Cache is finished or not. 0: not finished. 1: finished.
        constexpr uint32_t L2_CACHE_AUTOLOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of autoload operation on L2-Cache. 0: ascending. 1: descending.
        constexpr uint32_t L2_CACHE_AUTOLOAD_TRIGGER_MODE = (2 << 3);  ///< The field is used to configure trigger mode of autoload operation on L2-Cache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bit is used to enable the first section for autoload operation on L2-Cache.
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bit is used to enable the second section for autoload operation on L2-Cache.
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT2_ENA = (1U << 10);  ///< The bit is used to enable the third section for autoload operation on L2-Cache.
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT3_ENA = (1U << 11);  ///< The bit is used to enable the fourth section for autoload operation on L2-Cache.
        constexpr uint32_t L2_CACHE_AUTOLOAD_RGID = (4 << 12);  ///< The bit is used to set the gid of l2 cache autoload.
    }

    /// L2_CACHE_AUTOLOAD_SCT0_ADDR Register bits
    namespace l2_cache_autoload_sct0_addr_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_SIZE and L2_CACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT0_SIZE Register bits
    namespace l2_cache_autoload_sct0_size_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT0_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_ADDR and L2_CACHE_AUTOLOAD_SCT0_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT1_ADDR Register bits
    namespace l2_cache_autoload_sct1_addr_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_SIZE and L2_CACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT1_SIZE Register bits
    namespace l2_cache_autoload_sct1_size_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT1_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_ADDR and L2_CACHE_AUTOLOAD_SCT1_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT2_ADDR Register bits
    namespace l2_cache_autoload_sct2_addr_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT2_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_SIZE and L2_CACHE_AUTOLOAD_SCT2_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT2_SIZE Register bits
    namespace l2_cache_autoload_sct2_size_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT2_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_ADDR and L2_CACHE_AUTOLOAD_SCT2_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT3_ADDR Register bits
    namespace l2_cache_autoload_sct3_addr_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT3_ADDR = (32 << 0);  ///< Those bits are used to configure the start virtual address of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_SIZE and L2_CACHE_AUTOLOAD_SCT3_ENA.
    }

    /// L2_CACHE_AUTOLOAD_SCT3_SIZE Register bits
    namespace l2_cache_autoload_sct3_size_bits {
        constexpr uint32_t L2_CACHE_AUTOLOAD_SCT3_SIZE = (28 << 0);  ///< Those bits are used to configure the size of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_ADDR and L2_CACHE_AUTOLOAD_SCT3_ENA.
    }

    /// L2_CACHE_ACS_CNT_INT_ENA Register bits
    namespace l2_cache_acs_cnt_int_ena_bits {
        constexpr uint32_t L2_IBUS0_OVF_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_IBUS1_OVF_INT_ENA = (1U << 9);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_IBUS2_OVF_INT_ENA = (1U << 10);  ///< Reserved
        constexpr uint32_t L2_IBUS3_OVF_INT_ENA = (1U << 11);  ///< Reserved
        constexpr uint32_t L2_DBUS0_OVF_INT_ENA = (1U << 12);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_DBUS1_OVF_INT_ENA = (1U << 13);  ///< The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_DBUS2_OVF_INT_ENA = (1U << 14);  ///< Reserved
        constexpr uint32_t L2_DBUS3_OVF_INT_ENA = (1U << 15);  ///< Reserved
    }

    /// L2_CACHE_ACS_CNT_INT_CLR Register bits
    namespace l2_cache_acs_cnt_int_clr_bits {
        constexpr uint32_t L2_IBUS0_OVF_INT_CLR = (1U << 8);  ///< The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_IBUS1_OVF_INT_CLR = (1U << 9);  ///< The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_IBUS2_OVF_INT_CLR = (1U << 10);  ///< Reserved
        constexpr uint32_t L2_IBUS3_OVF_INT_CLR = (1U << 11);  ///< Reserved
        constexpr uint32_t L2_DBUS0_OVF_INT_CLR = (1U << 12);  ///< The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_DBUS1_OVF_INT_CLR = (1U << 13);  ///< The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_DBUS2_OVF_INT_CLR = (1U << 14);  ///< Reserved
        constexpr uint32_t L2_DBUS3_OVF_INT_CLR = (1U << 15);  ///< Reserved
    }

    /// L2_CACHE_ACS_CNT_INT_RAW Register bits
    namespace l2_cache_acs_cnt_int_raw_bits {
        constexpr uint32_t L2_IBUS0_OVF_INT_RAW = (1U << 8);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-ICache0.
        constexpr uint32_t L2_IBUS1_OVF_INT_RAW = (1U << 9);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-ICache1.
        constexpr uint32_t L2_IBUS2_OVF_INT_RAW = (1U << 10);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-ICache2.
        constexpr uint32_t L2_IBUS3_OVF_INT_RAW = (1U << 11);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-ICache3.
        constexpr uint32_t L2_DBUS0_OVF_INT_RAW = (1U << 12);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-DCache.
        constexpr uint32_t L2_DBUS1_OVF_INT_RAW = (1U << 13);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-DCache.
        constexpr uint32_t L2_DBUS2_OVF_INT_RAW = (1U << 14);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-DCache.
        constexpr uint32_t L2_DBUS3_OVF_INT_RAW = (1U << 15);  ///< The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-DCache.
    }

    /// L2_CACHE_ACS_CNT_INT_ST Register bits
    namespace l2_cache_acs_cnt_int_st_bits {
        constexpr uint32_t L2_IBUS0_OVF_INT_ST = (1U << 8);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_IBUS1_OVF_INT_ST = (1U << 9);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_IBUS2_OVF_INT_ST = (1U << 10);  ///< Reserved
        constexpr uint32_t L2_IBUS3_OVF_INT_ST = (1U << 11);  ///< Reserved
        constexpr uint32_t L2_DBUS0_OVF_INT_ST = (1U << 12);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
        constexpr uint32_t L2_DBUS1_OVF_INT_ST = (1U << 13);  ///< The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
        constexpr uint32_t L2_DBUS2_OVF_INT_ST = (1U << 14);  ///< Reserved
        constexpr uint32_t L2_DBUS3_OVF_INT_ST = (1U << 15);  ///< Reserved
    }

    /// L2_CACHE_ACS_FAIL_CTRL Register bits
    namespace l2_cache_acs_fail_ctrl_bits {
        constexpr uint32_t L2_CACHE_ACS_FAIL_CHECK_MODE = (1U << 0);  ///< The bit is used to configure l2 cache access fail check mode. 0: the access fail is not propagated to the request, 1: the access fail is propagated to the request
    }

    /// L2_CACHE_ACS_FAIL_INT_ENA Register bits
    namespace l2_cache_acs_fail_int_ena_bits {
        constexpr uint32_t L2_CACHE_FAIL_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
    }

    /// L2_CACHE_ACS_FAIL_INT_CLR Register bits
    namespace l2_cache_acs_fail_int_clr_bits {
        constexpr uint32_t L2_CACHE_FAIL_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
    }

    /// L2_CACHE_ACS_FAIL_INT_RAW Register bits
    namespace l2_cache_acs_fail_int_raw_bits {
        constexpr uint32_t L2_CACHE_FAIL_INT_RAW = (1U << 5);  ///< The raw bit of the interrupt of access fail that occurs in L2-Cache.
    }

    /// L2_CACHE_ACS_FAIL_INT_ST Register bits
    namespace l2_cache_acs_fail_int_st_bits {
        constexpr uint32_t L2_CACHE_FAIL_INT_ST = (1U << 5);  ///< The bit indicates the interrupt status of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
    }

    /// L2_CACHE_ACS_CNT_CTRL Register bits
    namespace l2_cache_acs_cnt_ctrl_bits {
        constexpr uint32_t L2_IBUS0_CNT_ENA = (1U << 8);  ///< The bit is used to enable ibus0 counter in L2-Cache.
        constexpr uint32_t L2_IBUS1_CNT_ENA = (1U << 9);  ///< The bit is used to enable ibus1 counter in L2-Cache.
        constexpr uint32_t L2_IBUS2_CNT_ENA = (1U << 10);  ///< Reserved
        constexpr uint32_t L2_IBUS3_CNT_ENA = (1U << 11);  ///< Reserved
        constexpr uint32_t L2_DBUS0_CNT_ENA = (1U << 12);  ///< The bit is used to enable dbus0 counter in L2-Cache.
        constexpr uint32_t L2_DBUS1_CNT_ENA = (1U << 13);  ///< The bit is used to enable dbus1 counter in L2-Cache.
        constexpr uint32_t L2_DBUS2_CNT_ENA = (1U << 14);  ///< Reserved
        constexpr uint32_t L2_DBUS3_CNT_ENA = (1U << 15);  ///< Reserved
        constexpr uint32_t L2_IBUS0_CNT_CLR = (1U << 24);  ///< The bit is used to clear ibus0 counter in L2-Cache.
        constexpr uint32_t L2_IBUS1_CNT_CLR = (1U << 25);  ///< The bit is used to clear ibus1 counter in L2-Cache.
        constexpr uint32_t L2_IBUS2_CNT_CLR = (1U << 26);  ///< Reserved
        constexpr uint32_t L2_IBUS3_CNT_CLR = (1U << 27);  ///< Reserved
        constexpr uint32_t L2_DBUS0_CNT_CLR = (1U << 28);  ///< The bit is used to clear dbus0 counter in L2-Cache.
        constexpr uint32_t L2_DBUS1_CNT_CLR = (1U << 29);  ///< The bit is used to clear dbus1 counter in L2-Cache.
        constexpr uint32_t L2_DBUS2_CNT_CLR = (1U << 30);  ///< Reserved
        constexpr uint32_t L2_DBUS3_CNT_CLR = (1U << 31);  ///< Reserved
    }

    /// L2_IBUS0_ACS_HIT_CNT Register bits
    namespace l2_ibus0_acs_hit_cnt_bits {
        constexpr uint32_t L2_IBUS0_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
    }

    /// L2_IBUS0_ACS_MISS_CNT Register bits
    namespace l2_ibus0_acs_miss_cnt_bits {
        constexpr uint32_t L2_IBUS0_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
    }

    /// L2_IBUS0_ACS_CONFLICT_CNT Register bits
    namespace l2_ibus0_acs_conflict_cnt_bits {
        constexpr uint32_t L2_IBUS0_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
    }

    /// L2_IBUS0_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_ibus0_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_IBUS0_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-ICache0 accessing L2-Cache due to bus0 accessing L1-ICache0.
    }

    /// L2_IBUS1_ACS_HIT_CNT Register bits
    namespace l2_ibus1_acs_hit_cnt_bits {
        constexpr uint32_t L2_IBUS1_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
    }

    /// L2_IBUS1_ACS_MISS_CNT Register bits
    namespace l2_ibus1_acs_miss_cnt_bits {
        constexpr uint32_t L2_IBUS1_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
    }

    /// L2_IBUS1_ACS_CONFLICT_CNT Register bits
    namespace l2_ibus1_acs_conflict_cnt_bits {
        constexpr uint32_t L2_IBUS1_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
    }

    /// L2_IBUS1_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_ibus1_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_IBUS1_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-ICache1 accessing L2-Cache due to bus1 accessing L1-ICache1.
    }

    /// L2_IBUS2_ACS_HIT_CNT Register bits
    namespace l2_ibus2_acs_hit_cnt_bits {
        constexpr uint32_t L2_IBUS2_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
    }

    /// L2_IBUS2_ACS_MISS_CNT Register bits
    namespace l2_ibus2_acs_miss_cnt_bits {
        constexpr uint32_t L2_IBUS2_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
    }

    /// L2_IBUS2_ACS_CONFLICT_CNT Register bits
    namespace l2_ibus2_acs_conflict_cnt_bits {
        constexpr uint32_t L2_IBUS2_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
    }

    /// L2_IBUS2_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_ibus2_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_IBUS2_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-ICache2 accessing L2-Cache due to bus2 accessing L1-ICache2.
    }

    /// L2_IBUS3_ACS_HIT_CNT Register bits
    namespace l2_ibus3_acs_hit_cnt_bits {
        constexpr uint32_t L2_IBUS3_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
    }

    /// L2_IBUS3_ACS_MISS_CNT Register bits
    namespace l2_ibus3_acs_miss_cnt_bits {
        constexpr uint32_t L2_IBUS3_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
    }

    /// L2_IBUS3_ACS_CONFLICT_CNT Register bits
    namespace l2_ibus3_acs_conflict_cnt_bits {
        constexpr uint32_t L2_IBUS3_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
    }

    /// L2_IBUS3_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_ibus3_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_IBUS3_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-ICache3 accessing L2-Cache due to bus3 accessing L1-ICache3.
    }

    /// L2_DBUS0_ACS_HIT_CNT Register bits
    namespace l2_dbus0_acs_hit_cnt_bits {
        constexpr uint32_t L2_DBUS0_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L2_DBUS0_ACS_MISS_CNT Register bits
    namespace l2_dbus0_acs_miss_cnt_bits {
        constexpr uint32_t L2_DBUS0_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L2_DBUS0_ACS_CONFLICT_CNT Register bits
    namespace l2_dbus0_acs_conflict_cnt_bits {
        constexpr uint32_t L2_DBUS0_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L2_DBUS0_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_dbus0_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_DBUS0_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L2_DBUS0_ACS_NXTLVL_WR_CNT Register bits
    namespace l2_dbus0_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L2_DBUS0_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
    }

    /// L2_DBUS1_ACS_HIT_CNT Register bits
    namespace l2_dbus1_acs_hit_cnt_bits {
        constexpr uint32_t L2_DBUS1_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L2_DBUS1_ACS_MISS_CNT Register bits
    namespace l2_dbus1_acs_miss_cnt_bits {
        constexpr uint32_t L2_DBUS1_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L2_DBUS1_ACS_CONFLICT_CNT Register bits
    namespace l2_dbus1_acs_conflict_cnt_bits {
        constexpr uint32_t L2_DBUS1_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L2_DBUS1_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_dbus1_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_DBUS1_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L2_DBUS1_ACS_NXTLVL_WR_CNT Register bits
    namespace l2_dbus1_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L2_DBUS1_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
    }

    /// L2_DBUS2_ACS_HIT_CNT Register bits
    namespace l2_dbus2_acs_hit_cnt_bits {
        constexpr uint32_t L2_DBUS2_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L2_DBUS2_ACS_MISS_CNT Register bits
    namespace l2_dbus2_acs_miss_cnt_bits {
        constexpr uint32_t L2_DBUS2_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L2_DBUS2_ACS_CONFLICT_CNT Register bits
    namespace l2_dbus2_acs_conflict_cnt_bits {
        constexpr uint32_t L2_DBUS2_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L2_DBUS2_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_dbus2_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_DBUS2_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L2_DBUS2_ACS_NXTLVL_WR_CNT Register bits
    namespace l2_dbus2_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L2_DBUS2_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
    }

    /// L2_DBUS3_ACS_HIT_CNT Register bits
    namespace l2_dbus3_acs_hit_cnt_bits {
        constexpr uint32_t L2_DBUS3_HIT_CNT = (32 << 0);  ///< The register records the number of hits when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L2_DBUS3_ACS_MISS_CNT Register bits
    namespace l2_dbus3_acs_miss_cnt_bits {
        constexpr uint32_t L2_DBUS3_MISS_CNT = (32 << 0);  ///< The register records the number of missing when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L2_DBUS3_ACS_CONFLICT_CNT Register bits
    namespace l2_dbus3_acs_conflict_cnt_bits {
        constexpr uint32_t L2_DBUS3_CONFLICT_CNT = (32 << 0);  ///< The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L2_DBUS3_ACS_NXTLVL_RD_CNT Register bits
    namespace l2_dbus3_acs_nxtlvl_rd_cnt_bits {
        constexpr uint32_t L2_DBUS3_NXTLVL_RD_CNT = (32 << 0);  ///< The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L2_DBUS3_ACS_NXTLVL_WR_CNT Register bits
    namespace l2_dbus3_acs_nxtlvl_wr_cnt_bits {
        constexpr uint32_t L2_DBUS3_NXTLVL_WR_CNT = (32 << 0);  ///< The register records the number of write back when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
    }

    /// L2_CACHE_ACS_FAIL_ID_ATTR Register bits
    namespace l2_cache_acs_fail_id_attr_bits {
        constexpr uint32_t L2_CACHE_FAIL_ID = (16 << 0);  ///< The register records the ID of fail-access when L1-Cache accesses L2-Cache.
        constexpr uint32_t L2_CACHE_FAIL_ATTR = (16 << 16);  ///< The register records the attribution of fail-access when L1-Cache accesses L2-Cache due to cache accessing L1-Cache.
    }

    /// L2_CACHE_ACS_FAIL_ADDR Register bits
    namespace l2_cache_acs_fail_addr_bits {
        constexpr uint32_t L2_CACHE_FAIL_ADDR = (32 << 0);  ///< The register records the address of fail-access when L1-Cache accesses L2-Cache.
    }

    /// L2_CACHE_SYNC_PRELOAD_INT_ENA Register bits
    namespace l2_cache_sync_preload_int_ena_bits {
        constexpr uint32_t L2_CACHE_PLD_DONE_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt of L2-Cache preload-operation done.
        constexpr uint32_t L2_CACHE_PLD_ERR_INT_ENA = (1U << 12);  ///< The bit is used to enable interrupt of L2-Cache preload-operation error.
    }

    /// L2_CACHE_SYNC_PRELOAD_INT_CLR Register bits
    namespace l2_cache_sync_preload_int_clr_bits {
        constexpr uint32_t L2_CACHE_PLD_DONE_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt that occurs only when L2-Cache preload-operation is done.
        constexpr uint32_t L2_CACHE_PLD_ERR_INT_CLR = (1U << 12);  ///< The bit is used to clear interrupt of L2-Cache preload-operation error.
    }

    /// L2_CACHE_SYNC_PRELOAD_INT_RAW Register bits
    namespace l2_cache_sync_preload_int_raw_bits {
        constexpr uint32_t L2_CACHE_PLD_DONE_INT_RAW = (1U << 5);  ///< The raw bit of the interrupt that occurs only when L2-Cache preload-operation is done.
        constexpr uint32_t L2_CACHE_PLD_ERR_INT_RAW = (1U << 12);  ///< The raw bit of the interrupt that occurs only when L2-Cache preload-operation error occurs.
    }

    /// L2_CACHE_SYNC_PRELOAD_INT_ST Register bits
    namespace l2_cache_sync_preload_int_st_bits {
        constexpr uint32_t L2_CACHE_PLD_DONE_INT_ST = (1U << 5);  ///< The bit indicates the status of the interrupt that occurs only when L2-Cache preload-operation is done.
        constexpr uint32_t L2_CACHE_PLD_ERR_INT_ST = (1U << 12);  ///< The bit indicates the status of the interrupt of L2-Cache preload-operation error.
    }

    /// L2_CACHE_SYNC_PRELOAD_EXCEPTION Register bits
    namespace l2_cache_sync_preload_exception_bits {
        constexpr uint32_t L2_CACHE_PLD_ERR_CODE = (2 << 10);  ///< The value 2 is Only available which means preload size is error in L2-Cache.
    }

    /// L2_CACHE_SYNC_RST_CTRL Register bits
    namespace l2_cache_sync_rst_ctrl_bits {
        constexpr uint32_t L2_CACHE_SYNC_RST = (1U << 5);  ///< set this bit to reset sync-logic inside L2-Cache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
    }

    /// L2_CACHE_PRELOAD_RST_CTRL Register bits
    namespace l2_cache_preload_rst_ctrl_bits {
        constexpr uint32_t L2_CACHE_PLD_RST = (1U << 5);  ///< set this bit to reset preload-logic inside L2-Cache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
    }

    /// L2_CACHE_AUTOLOAD_BUF_CLR_CTRL Register bits
    namespace l2_cache_autoload_buf_clr_ctrl_bits {
        constexpr uint32_t L2_CACHE_ALD_BUF_CLR = (1U << 5);  ///< set this bit to clear autoload-buffer inside L2-Cache. If this bit is active, autoload will not work in L2-Cache. This bit should not be active when autoload works in L2-Cache.
    }

    /// L2_UNALLOCATE_BUFFER_CLEAR Register bits
    namespace l2_unallocate_buffer_clear_bits {
        constexpr uint32_t L2_CACHE_UNALLOC_CLR = (1U << 5);  ///< The bit is used to clear the unallocate request buffer of l2 icache where the unallocate request is responsed but not completed.
    }

    /// L2_CACHE_ACCESS_ATTR_CTRL Register bits
    namespace l2_cache_access_attr_ctrl_bits {
        constexpr uint32_t L2_CACHE_ACCESS_FORCE_CC = (1U << 0);  ///< Set this bit to force the request to l2 cache with cacheable attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of cacheable and non-cacheable.
        constexpr uint32_t L2_CACHE_ACCESS_FORCE_WB = (1U << 1);  ///< Set this bit to force the request to l2 cache with write-back attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-back and write-through.
        constexpr uint32_t L2_CACHE_ACCESS_FORCE_WMA = (1U << 2);  ///< Set this bit to force the request to l2 cache with write-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-miss-allocate and write-miss-no-allocate.
        constexpr uint32_t L2_CACHE_ACCESS_FORCE_RMA = (1U << 3);  ///< Set this bit to force the request to l2 cache with read-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of read-miss-allocate and read-miss-no-allocate.
    }

    /// L2_CACHE_OBJECT_CTRL Register bits
    namespace l2_cache_object_ctrl_bits {
        constexpr uint32_t L2_CACHE_TAG_OBJECT = (1U << 5);  ///< Set this bit to set L2-Cache tag memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t L2_CACHE_MEM_OBJECT = (1U << 11);  ///< Set this bit to set L2-Cache data memory as object. This bit should be onehot with the others fields inside this register.
    }

    /// L2_CACHE_WAY_OBJECT Register bits
    namespace l2_cache_way_object_bits {
        constexpr uint32_t L2_CACHE_WAY_OBJECT = (3 << 0);  ///< Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
    }

    /// L2_CACHE_VADDR Register bits
    namespace l2_cache_vaddr_bits {
        constexpr uint32_t L2_CACHE_VADDR = (32 << 0);  ///< Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
    }

    /// L2_CACHE_DEBUG_BUS Register bits
    namespace l2_cache_debug_bus_bits {
        constexpr uint32_t L2_CACHE_DEBUG_BUS = (32 << 0);  ///< This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
    }

    /// LEVEL_SPLIT1 Register bits
    namespace level_split1_bits {
        constexpr uint32_t LEVEL_SPLIT1 = (32 << 0);  ///< Reserved
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< The bit is used to enable clock gate when access all registers in this module.
    }

    /// REDUNDANCY_SIG0 Register bits
    namespace redundancy_sig0_bits {
        constexpr uint32_t REDCY_SIG0 = (32 << 0);  ///< Those bits are prepared for ECO.
    }

    /// REDUNDANCY_SIG1 Register bits
    namespace redundancy_sig1_bits {
        constexpr uint32_t REDCY_SIG1 = (32 << 0);  ///< Those bits are prepared for ECO.
    }

    /// REDUNDANCY_SIG2 Register bits
    namespace redundancy_sig2_bits {
        constexpr uint32_t REDCY_SIG2 = (32 << 0);  ///< Those bits are prepared for ECO.
    }

    /// REDUNDANCY_SIG3 Register bits
    namespace redundancy_sig3_bits {
        constexpr uint32_t REDCY_SIG3 = (32 << 0);  ///< Those bits are prepared for ECO.
    }

    /// REDUNDANCY_SIG4 Register bits
    namespace redundancy_sig4_bits {
        constexpr uint32_t REDCY_SIG4 = (4 << 0);  ///< Those bits are prepared for ECO.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version control register. Note that this default value stored is the latest date when the hardware logic was updated.
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x500D6000;
    constexpr uint32_t INTERRUPT_CORE1_BASE = 0x500D6800;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t LP_RTC_INT_MAP;  ///< Offset: 0x00 - NA
        volatile uint32_t LP_WDT_INT_MAP;  ///< Offset: 0x04 - NA
        volatile uint32_t LP_TIMER_REG_0_INT_MAP;  ///< Offset: 0x08 - NA
        volatile uint32_t LP_TIMER_REG_1_INT_MAP;  ///< Offset: 0x0C - NA
        volatile uint32_t MB_HP_INT_MAP;  ///< Offset: 0x10 - NA
        volatile uint32_t MB_LP_INT_MAP;  ///< Offset: 0x14 - NA
        volatile uint32_t PMU_REG_0_INT_MAP;  ///< Offset: 0x18 - NA
        volatile uint32_t PMU_REG_1_INT_MAP;  ///< Offset: 0x1C - NA
        volatile uint32_t LP_ANAPERI_INT_MAP;  ///< Offset: 0x20 - NA
        volatile uint32_t LP_ADC_INT_MAP;  ///< Offset: 0x24 - NA
        volatile uint32_t LP_GPIO_INT_MAP;  ///< Offset: 0x28 - NA
        volatile uint32_t LP_I2C_INT_MAP;  ///< Offset: 0x2C - NA
        volatile uint32_t LP_I2S_INT_MAP;  ///< Offset: 0x30 - NA
        volatile uint32_t LP_SPI_INT_MAP;  ///< Offset: 0x34 - NA
        volatile uint32_t LP_TOUCH_INT_MAP;  ///< Offset: 0x38 - NA
        volatile uint32_t LP_TSENS_INT_MAP;  ///< Offset: 0x3C - NA
        volatile uint32_t LP_UART_INT_MAP;  ///< Offset: 0x40 - NA
        volatile uint32_t LP_EFUSE_INT_MAP;  ///< Offset: 0x44 - NA
        volatile uint32_t LP_SW_INT_MAP;  ///< Offset: 0x48 - NA
        volatile uint32_t LP_SYSREG_INT_MAP;  ///< Offset: 0x4C - NA
        volatile uint32_t LP_HUK_INT_MAP;  ///< Offset: 0x50 - NA
        volatile uint32_t SYS_ICM_INT_MAP;  ///< Offset: 0x54 - NA
        volatile uint32_t USB_DEVICE_INT_MAP;  ///< Offset: 0x58 - NA
        volatile uint32_t SDIO_HOST_INT_MAP;  ///< Offset: 0x5C - NA
        volatile uint32_t GDMA_INT_MAP;  ///< Offset: 0x60 - NA
        volatile uint32_t SPI2_INT_MAP;  ///< Offset: 0x64 - NA
        volatile uint32_t SPI3_INT_MAP;  ///< Offset: 0x68 - NA
        volatile uint32_t I2S0_INT_MAP;  ///< Offset: 0x6C - NA
        volatile uint32_t I2S1_INT_MAP;  ///< Offset: 0x70 - NA
        volatile uint32_t I2S2_INT_MAP;  ///< Offset: 0x74 - NA
        volatile uint32_t UHCI0_INT_MAP;  ///< Offset: 0x78 - NA
        volatile uint32_t UART0_INT_MAP;  ///< Offset: 0x7C - NA
        volatile uint32_t UART1_INT_MAP;  ///< Offset: 0x80 - NA
        volatile uint32_t UART2_INT_MAP;  ///< Offset: 0x84 - NA
        volatile uint32_t UART3_INT_MAP;  ///< Offset: 0x88 - NA
        volatile uint32_t UART4_INT_MAP;  ///< Offset: 0x8C - NA
        volatile uint32_t LCD_CAM_INT_MAP;  ///< Offset: 0x90 - NA
        volatile uint32_t ADC_INT_MAP;  ///< Offset: 0x94 - NA
        volatile uint32_t PWM0_INT_MAP;  ///< Offset: 0x98 - NA
        volatile uint32_t PWM1_INT_MAP;  ///< Offset: 0x9C - NA
        volatile uint32_t CAN0_INT_MAP;  ///< Offset: 0xA0 - NA
        volatile uint32_t CAN1_INT_MAP;  ///< Offset: 0xA4 - NA
        volatile uint32_t CAN2_INT_MAP;  ///< Offset: 0xA8 - NA
        volatile uint32_t RMT_INT_MAP;  ///< Offset: 0xAC - NA
        volatile uint32_t I2C0_INT_MAP;  ///< Offset: 0xB0 - NA
        volatile uint32_t I2C1_INT_MAP;  ///< Offset: 0xB4 - NA
        volatile uint32_t TIMERGRP0_T0_INT_MAP;  ///< Offset: 0xB8 - NA
        volatile uint32_t TIMERGRP0_T1_INT_MAP;  ///< Offset: 0xBC - NA
        volatile uint32_t TIMERGRP0_WDT_INT_MAP;  ///< Offset: 0xC0 - NA
        volatile uint32_t TIMERGRP1_T0_INT_MAP;  ///< Offset: 0xC4 - NA
        volatile uint32_t TIMERGRP1_T1_INT_MAP;  ///< Offset: 0xC8 - NA
        volatile uint32_t TIMERGRP1_WDT_INT_MAP;  ///< Offset: 0xCC - NA
        volatile uint32_t LEDC_INT_MAP;  ///< Offset: 0xD0 - NA
        volatile uint32_t SYSTIMER_TARGET0_INT_MAP;  ///< Offset: 0xD4 - NA
        volatile uint32_t SYSTIMER_TARGET1_INT_MAP;  ///< Offset: 0xD8 - NA
        volatile uint32_t SYSTIMER_TARGET2_INT_MAP;  ///< Offset: 0xDC - NA
        volatile uint32_t AHB_PDMA_IN_CH0_INT_MAP;  ///< Offset: 0xE0 - NA
        volatile uint32_t AHB_PDMA_IN_CH1_INT_MAP;  ///< Offset: 0xE4 - NA
        volatile uint32_t AHB_PDMA_IN_CH2_INT_MAP;  ///< Offset: 0xE8 - NA
        volatile uint32_t AHB_PDMA_OUT_CH0_INT_MAP;  ///< Offset: 0xEC - NA
        volatile uint32_t AHB_PDMA_OUT_CH1_INT_MAP;  ///< Offset: 0xF0 - NA
        volatile uint32_t AHB_PDMA_OUT_CH2_INT_MAP;  ///< Offset: 0xF4 - NA
        volatile uint32_t AXI_PDMA_IN_CH0_INT_MAP;  ///< Offset: 0xF8 - NA
        volatile uint32_t AXI_PDMA_IN_CH1_INT_MAP;  ///< Offset: 0xFC - NA
        volatile uint32_t AXI_PDMA_IN_CH2_INT_MAP;  ///< Offset: 0x100 - NA
        volatile uint32_t AXI_PDMA_OUT_CH0_INT_MAP;  ///< Offset: 0x104 - NA
        volatile uint32_t AXI_PDMA_OUT_CH1_INT_MAP;  ///< Offset: 0x108 - NA
        volatile uint32_t AXI_PDMA_OUT_CH2_INT_MAP;  ///< Offset: 0x10C - NA
        volatile uint32_t RSA_INT_MAP;  ///< Offset: 0x110 - NA
        volatile uint32_t AES_INT_MAP;  ///< Offset: 0x114 - NA
        volatile uint32_t SHA_INT_MAP;  ///< Offset: 0x118 - NA
        volatile uint32_t ECC_INT_MAP;  ///< Offset: 0x11C - NA
        volatile uint32_t ECDSA_INT_MAP;  ///< Offset: 0x120 - NA
        volatile uint32_t KM_INT_MAP;  ///< Offset: 0x124 - NA
        volatile uint32_t GPIO_INT0_MAP;  ///< Offset: 0x128 - NA
        volatile uint32_t GPIO_INT1_MAP;  ///< Offset: 0x12C - NA
        volatile uint32_t GPIO_INT2_MAP;  ///< Offset: 0x130 - NA
        volatile uint32_t GPIO_INT3_MAP;  ///< Offset: 0x134 - NA
        volatile uint32_t GPIO_PAD_COMP_INT_MAP;  ///< Offset: 0x138 - NA
        volatile uint32_t CPU_INT_FROM_CPU_0_MAP;  ///< Offset: 0x13C - NA
        volatile uint32_t CPU_INT_FROM_CPU_1_MAP;  ///< Offset: 0x140 - NA
        volatile uint32_t CPU_INT_FROM_CPU_2_MAP;  ///< Offset: 0x144 - NA
        volatile uint32_t CPU_INT_FROM_CPU_3_MAP;  ///< Offset: 0x148 - NA
        volatile uint32_t CACHE_INT_MAP;  ///< Offset: 0x14C - NA
        volatile uint32_t FLASH_MSPI_INT_MAP;  ///< Offset: 0x150 - NA
        volatile uint32_t CSI_BRIDGE_INT_MAP;  ///< Offset: 0x154 - NA
        volatile uint32_t DSI_BRIDGE_INT_MAP;  ///< Offset: 0x158 - NA
        volatile uint32_t CSI_INT_MAP;  ///< Offset: 0x15C - NA
        volatile uint32_t DSI_INT_MAP;  ///< Offset: 0x160 - NA
        volatile uint32_t GMII_PHY_INT_MAP;  ///< Offset: 0x164 - NA
        volatile uint32_t LPI_INT_MAP;  ///< Offset: 0x168 - NA
        volatile uint32_t PMT_INT_MAP;  ///< Offset: 0x16C - NA
        volatile uint32_t SBD_INT_MAP;  ///< Offset: 0x170 - NA
        volatile uint32_t USB_OTG_INT_MAP;  ///< Offset: 0x174 - NA
        volatile uint32_t USB_OTG_ENDP_MULTI_PROC_INT_MAP;  ///< Offset: 0x178 - NA
        volatile uint32_t JPEG_INT_MAP;  ///< Offset: 0x17C - NA
        volatile uint32_t PPA_INT_MAP;  ///< Offset: 0x180 - NA
        volatile uint32_t CORE0_TRACE_INT_MAP;  ///< Offset: 0x184 - NA
        volatile uint32_t CORE1_TRACE_INT_MAP;  ///< Offset: 0x188 - NA
        volatile uint32_t HP_CORE_CTRL_INT_MAP;  ///< Offset: 0x18C - NA
        volatile uint32_t ISP_INT_MAP;  ///< Offset: 0x190 - NA
        volatile uint32_t I3C_MST_INT_MAP;  ///< Offset: 0x194 - NA
        volatile uint32_t I3C_SLV_INT_MAP;  ///< Offset: 0x198 - NA
        volatile uint32_t USB_OTG11_INT_MAP;  ///< Offset: 0x19C - NA
        volatile uint32_t DMA2D_IN_CH0_INT_MAP;  ///< Offset: 0x1A0 - NA
        volatile uint32_t DMA2D_IN_CH1_INT_MAP;  ///< Offset: 0x1A4 - NA
        volatile uint32_t DMA2D_OUT_CH0_INT_MAP;  ///< Offset: 0x1A8 - NA
        volatile uint32_t DMA2D_OUT_CH1_INT_MAP;  ///< Offset: 0x1AC - NA
        volatile uint32_t DMA2D_OUT_CH2_INT_MAP;  ///< Offset: 0x1B0 - NA
        volatile uint32_t PSRAM_MSPI_INT_MAP;  ///< Offset: 0x1B4 - NA
        volatile uint32_t HP_SYSREG_INT_MAP;  ///< Offset: 0x1B8 - NA
        volatile uint32_t PCNT_INT_MAP;  ///< Offset: 0x1BC - NA
        volatile uint32_t HP_PAU_INT_MAP;  ///< Offset: 0x1C0 - NA
        volatile uint32_t HP_PARLIO_RX_INT_MAP;  ///< Offset: 0x1C4 - NA
        volatile uint32_t HP_PARLIO_TX_INT_MAP;  ///< Offset: 0x1C8 - NA
        volatile uint32_t H264_DMA2D_OUT_CH0_INT_MAP;  ///< Offset: 0x1CC - NA
        volatile uint32_t H264_DMA2D_OUT_CH1_INT_MAP;  ///< Offset: 0x1D0 - NA
        volatile uint32_t H264_DMA2D_OUT_CH2_INT_MAP;  ///< Offset: 0x1D4 - NA
        volatile uint32_t H264_DMA2D_OUT_CH3_INT_MAP;  ///< Offset: 0x1D8 - NA
        volatile uint32_t H264_DMA2D_OUT_CH4_INT_MAP;  ///< Offset: 0x1DC - NA
        volatile uint32_t H264_DMA2D_IN_CH0_INT_MAP;  ///< Offset: 0x1E0 - NA
        volatile uint32_t H264_DMA2D_IN_CH1_INT_MAP;  ///< Offset: 0x1E4 - NA
        volatile uint32_t H264_DMA2D_IN_CH2_INT_MAP;  ///< Offset: 0x1E8 - NA
        volatile uint32_t H264_DMA2D_IN_CH3_INT_MAP;  ///< Offset: 0x1EC - NA
        volatile uint32_t H264_DMA2D_IN_CH4_INT_MAP;  ///< Offset: 0x1F0 - NA
        volatile uint32_t H264_DMA2D_IN_CH5_INT_MAP;  ///< Offset: 0x1F4 - NA
        volatile uint32_t H264_REG_INT_MAP;  ///< Offset: 0x1F8 - NA
        volatile uint32_t ASSIST_DEBUG_INT_MAP;  ///< Offset: 0x1FC - NA
        volatile uint32_t INTR_STATUS_REG_0;  ///< Offset: 0x200 - NA
        volatile uint32_t INTR_STATUS_REG_1;  ///< Offset: 0x204 - NA
        volatile uint32_t INTR_STATUS_REG_2;  ///< Offset: 0x208 - NA
        volatile uint32_t INTR_STATUS_REG_3;  ///< Offset: 0x20C - NA
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x210 - NA
        volatile uint32_t INTERRUPT_REG_DATE;  ///< Offset: 0x3FC - NA
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);
    inline Registers* INTERRUPT_CORE1 = reinterpret_cast<Registers*>(INTERRUPT_CORE1_BASE);

    // Bit definitions
    /// LP_RTC_INT_MAP Register bits
    namespace lp_rtc_int_map_bits {
        constexpr uint32_t CORE0_LP_RTC_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_WDT_INT_MAP Register bits
    namespace lp_wdt_int_map_bits {
        constexpr uint32_t CORE0_LP_WDT_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_TIMER_REG_0_INT_MAP Register bits
    namespace lp_timer_reg_0_int_map_bits {
        constexpr uint32_t CORE0_LP_TIMER_REG_0_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_TIMER_REG_1_INT_MAP Register bits
    namespace lp_timer_reg_1_int_map_bits {
        constexpr uint32_t CORE0_LP_TIMER_REG_1_INT_MAP = (6 << 0);  ///< NA
    }

    /// MB_HP_INT_MAP Register bits
    namespace mb_hp_int_map_bits {
        constexpr uint32_t CORE0_MB_HP_INT_MAP = (6 << 0);  ///< NA
    }

    /// MB_LP_INT_MAP Register bits
    namespace mb_lp_int_map_bits {
        constexpr uint32_t CORE0_MB_LP_INT_MAP = (6 << 0);  ///< NA
    }

    /// PMU_REG_0_INT_MAP Register bits
    namespace pmu_reg_0_int_map_bits {
        constexpr uint32_t CORE0_PMU_REG_0_INT_MAP = (6 << 0);  ///< NA
    }

    /// PMU_REG_1_INT_MAP Register bits
    namespace pmu_reg_1_int_map_bits {
        constexpr uint32_t CORE0_PMU_REG_1_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_ANAPERI_INT_MAP Register bits
    namespace lp_anaperi_int_map_bits {
        constexpr uint32_t CORE0_LP_ANAPERI_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_ADC_INT_MAP Register bits
    namespace lp_adc_int_map_bits {
        constexpr uint32_t CORE0_LP_ADC_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_GPIO_INT_MAP Register bits
    namespace lp_gpio_int_map_bits {
        constexpr uint32_t CORE0_LP_GPIO_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_I2C_INT_MAP Register bits
    namespace lp_i2c_int_map_bits {
        constexpr uint32_t CORE0_LP_I2C_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_I2S_INT_MAP Register bits
    namespace lp_i2s_int_map_bits {
        constexpr uint32_t CORE0_LP_I2S_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_SPI_INT_MAP Register bits
    namespace lp_spi_int_map_bits {
        constexpr uint32_t CORE0_LP_SPI_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_TOUCH_INT_MAP Register bits
    namespace lp_touch_int_map_bits {
        constexpr uint32_t CORE0_LP_TOUCH_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_TSENS_INT_MAP Register bits
    namespace lp_tsens_int_map_bits {
        constexpr uint32_t CORE0_LP_TSENS_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_UART_INT_MAP Register bits
    namespace lp_uart_int_map_bits {
        constexpr uint32_t CORE0_LP_UART_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_EFUSE_INT_MAP Register bits
    namespace lp_efuse_int_map_bits {
        constexpr uint32_t CORE0_LP_EFUSE_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_SW_INT_MAP Register bits
    namespace lp_sw_int_map_bits {
        constexpr uint32_t CORE0_LP_SW_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_SYSREG_INT_MAP Register bits
    namespace lp_sysreg_int_map_bits {
        constexpr uint32_t CORE0_LP_SYSREG_INT_MAP = (6 << 0);  ///< NA
    }

    /// LP_HUK_INT_MAP Register bits
    namespace lp_huk_int_map_bits {
        constexpr uint32_t CORE0_LP_HUK_INT_MAP = (6 << 0);  ///< NA
    }

    /// SYS_ICM_INT_MAP Register bits
    namespace sys_icm_int_map_bits {
        constexpr uint32_t CORE0_SYS_ICM_INT_MAP = (6 << 0);  ///< NA
    }

    /// USB_DEVICE_INT_MAP Register bits
    namespace usb_device_int_map_bits {
        constexpr uint32_t CORE0_USB_DEVICE_INT_MAP = (6 << 0);  ///< NA
    }

    /// SDIO_HOST_INT_MAP Register bits
    namespace sdio_host_int_map_bits {
        constexpr uint32_t CORE0_SDIO_HOST_INT_MAP = (6 << 0);  ///< NA
    }

    /// GDMA_INT_MAP Register bits
    namespace gdma_int_map_bits {
        constexpr uint32_t CORE0_GDMA_INT_MAP = (6 << 0);  ///< NA
    }

    /// SPI2_INT_MAP Register bits
    namespace spi2_int_map_bits {
        constexpr uint32_t CORE0_SPI2_INT_MAP = (6 << 0);  ///< NA
    }

    /// SPI3_INT_MAP Register bits
    namespace spi3_int_map_bits {
        constexpr uint32_t CORE0_SPI3_INT_MAP = (6 << 0);  ///< NA
    }

    /// I2S0_INT_MAP Register bits
    namespace i2s0_int_map_bits {
        constexpr uint32_t CORE0_I2S0_INT_MAP = (6 << 0);  ///< NA
    }

    /// I2S1_INT_MAP Register bits
    namespace i2s1_int_map_bits {
        constexpr uint32_t CORE0_I2S1_INT_MAP = (6 << 0);  ///< NA
    }

    /// I2S2_INT_MAP Register bits
    namespace i2s2_int_map_bits {
        constexpr uint32_t CORE0_I2S2_INT_MAP = (6 << 0);  ///< NA
    }

    /// UHCI0_INT_MAP Register bits
    namespace uhci0_int_map_bits {
        constexpr uint32_t CORE0_UHCI0_INT_MAP = (6 << 0);  ///< NA
    }

    /// UART0_INT_MAP Register bits
    namespace uart0_int_map_bits {
        constexpr uint32_t CORE0_UART0_INT_MAP = (6 << 0);  ///< NA
    }

    /// UART1_INT_MAP Register bits
    namespace uart1_int_map_bits {
        constexpr uint32_t CORE0_UART1_INT_MAP = (6 << 0);  ///< NA
    }

    /// UART2_INT_MAP Register bits
    namespace uart2_int_map_bits {
        constexpr uint32_t CORE0_UART2_INT_MAP = (6 << 0);  ///< NA
    }

    /// UART3_INT_MAP Register bits
    namespace uart3_int_map_bits {
        constexpr uint32_t CORE0_UART3_INT_MAP = (6 << 0);  ///< NA
    }

    /// UART4_INT_MAP Register bits
    namespace uart4_int_map_bits {
        constexpr uint32_t CORE0_UART4_INT_MAP = (6 << 0);  ///< NA
    }

    /// LCD_CAM_INT_MAP Register bits
    namespace lcd_cam_int_map_bits {
        constexpr uint32_t CORE0_LCD_CAM_INT_MAP = (6 << 0);  ///< NA
    }

    /// ADC_INT_MAP Register bits
    namespace adc_int_map_bits {
        constexpr uint32_t CORE0_ADC_INT_MAP = (6 << 0);  ///< NA
    }

    /// PWM0_INT_MAP Register bits
    namespace pwm0_int_map_bits {
        constexpr uint32_t CORE0_PWM0_INT_MAP = (6 << 0);  ///< NA
    }

    /// PWM1_INT_MAP Register bits
    namespace pwm1_int_map_bits {
        constexpr uint32_t CORE0_PWM1_INT_MAP = (6 << 0);  ///< NA
    }

    /// CAN0_INT_MAP Register bits
    namespace can0_int_map_bits {
        constexpr uint32_t CORE0_CAN0_INT_MAP = (6 << 0);  ///< NA
    }

    /// CAN1_INT_MAP Register bits
    namespace can1_int_map_bits {
        constexpr uint32_t CORE0_CAN1_INT_MAP = (6 << 0);  ///< NA
    }

    /// CAN2_INT_MAP Register bits
    namespace can2_int_map_bits {
        constexpr uint32_t CORE0_CAN2_INT_MAP = (6 << 0);  ///< NA
    }

    /// RMT_INT_MAP Register bits
    namespace rmt_int_map_bits {
        constexpr uint32_t CORE0_RMT_INT_MAP = (6 << 0);  ///< NA
    }

    /// I2C0_INT_MAP Register bits
    namespace i2c0_int_map_bits {
        constexpr uint32_t CORE0_I2C0_INT_MAP = (6 << 0);  ///< NA
    }

    /// I2C1_INT_MAP Register bits
    namespace i2c1_int_map_bits {
        constexpr uint32_t CORE0_I2C1_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP0_T0_INT_MAP Register bits
    namespace timergrp0_t0_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP0_T0_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP0_T1_INT_MAP Register bits
    namespace timergrp0_t1_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP0_T1_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP0_WDT_INT_MAP Register bits
    namespace timergrp0_wdt_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP0_WDT_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP1_T0_INT_MAP Register bits
    namespace timergrp1_t0_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP1_T0_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP1_T1_INT_MAP Register bits
    namespace timergrp1_t1_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP1_T1_INT_MAP = (6 << 0);  ///< NA
    }

    /// TIMERGRP1_WDT_INT_MAP Register bits
    namespace timergrp1_wdt_int_map_bits {
        constexpr uint32_t CORE0_TIMERGRP1_WDT_INT_MAP = (6 << 0);  ///< NA
    }

    /// LEDC_INT_MAP Register bits
    namespace ledc_int_map_bits {
        constexpr uint32_t CORE0_LEDC_INT_MAP = (6 << 0);  ///< NA
    }

    /// SYSTIMER_TARGET0_INT_MAP Register bits
    namespace systimer_target0_int_map_bits {
        constexpr uint32_t CORE0_SYSTIMER_TARGET0_INT_MAP = (6 << 0);  ///< NA
    }

    /// SYSTIMER_TARGET1_INT_MAP Register bits
    namespace systimer_target1_int_map_bits {
        constexpr uint32_t CORE0_SYSTIMER_TARGET1_INT_MAP = (6 << 0);  ///< NA
    }

    /// SYSTIMER_TARGET2_INT_MAP Register bits
    namespace systimer_target2_int_map_bits {
        constexpr uint32_t CORE0_SYSTIMER_TARGET2_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_IN_CH0_INT_MAP Register bits
    namespace ahb_pdma_in_ch0_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_IN_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_IN_CH1_INT_MAP Register bits
    namespace ahb_pdma_in_ch1_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_IN_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_IN_CH2_INT_MAP Register bits
    namespace ahb_pdma_in_ch2_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_IN_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_OUT_CH0_INT_MAP Register bits
    namespace ahb_pdma_out_ch0_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_OUT_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_OUT_CH1_INT_MAP Register bits
    namespace ahb_pdma_out_ch1_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_OUT_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// AHB_PDMA_OUT_CH2_INT_MAP Register bits
    namespace ahb_pdma_out_ch2_int_map_bits {
        constexpr uint32_t CORE0_AHB_PDMA_OUT_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_IN_CH0_INT_MAP Register bits
    namespace axi_pdma_in_ch0_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_IN_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_IN_CH1_INT_MAP Register bits
    namespace axi_pdma_in_ch1_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_IN_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_IN_CH2_INT_MAP Register bits
    namespace axi_pdma_in_ch2_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_IN_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_OUT_CH0_INT_MAP Register bits
    namespace axi_pdma_out_ch0_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_OUT_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_OUT_CH1_INT_MAP Register bits
    namespace axi_pdma_out_ch1_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_OUT_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// AXI_PDMA_OUT_CH2_INT_MAP Register bits
    namespace axi_pdma_out_ch2_int_map_bits {
        constexpr uint32_t CORE0_AXI_PDMA_OUT_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// RSA_INT_MAP Register bits
    namespace rsa_int_map_bits {
        constexpr uint32_t CORE0_RSA_INT_MAP = (6 << 0);  ///< NA
    }

    /// AES_INT_MAP Register bits
    namespace aes_int_map_bits {
        constexpr uint32_t CORE0_AES_INT_MAP = (6 << 0);  ///< NA
    }

    /// SHA_INT_MAP Register bits
    namespace sha_int_map_bits {
        constexpr uint32_t CORE0_SHA_INT_MAP = (6 << 0);  ///< NA
    }

    /// ECC_INT_MAP Register bits
    namespace ecc_int_map_bits {
        constexpr uint32_t CORE0_ECC_INT_MAP = (6 << 0);  ///< NA
    }

    /// ECDSA_INT_MAP Register bits
    namespace ecdsa_int_map_bits {
        constexpr uint32_t CORE0_ECDSA_INT_MAP = (6 << 0);  ///< NA
    }

    /// KM_INT_MAP Register bits
    namespace km_int_map_bits {
        constexpr uint32_t CORE0_KM_INT_MAP = (6 << 0);  ///< NA
    }

    /// GPIO_INT0_MAP Register bits
    namespace gpio_int0_map_bits {
        constexpr uint32_t CORE0_GPIO_INT0_MAP = (6 << 0);  ///< NA
    }

    /// GPIO_INT1_MAP Register bits
    namespace gpio_int1_map_bits {
        constexpr uint32_t CORE0_GPIO_INT1_MAP = (6 << 0);  ///< NA
    }

    /// GPIO_INT2_MAP Register bits
    namespace gpio_int2_map_bits {
        constexpr uint32_t CORE0_GPIO_INT2_MAP = (6 << 0);  ///< NA
    }

    /// GPIO_INT3_MAP Register bits
    namespace gpio_int3_map_bits {
        constexpr uint32_t CORE0_GPIO_INT3_MAP = (6 << 0);  ///< NA
    }

    /// GPIO_PAD_COMP_INT_MAP Register bits
    namespace gpio_pad_comp_int_map_bits {
        constexpr uint32_t CORE0_GPIO_PAD_COMP_INT_MAP = (6 << 0);  ///< NA
    }

    /// CPU_INT_FROM_CPU_0_MAP Register bits
    namespace cpu_int_from_cpu_0_map_bits {
        constexpr uint32_t CORE0_CPU_INT_FROM_CPU_0_MAP = (6 << 0);  ///< NA
    }

    /// CPU_INT_FROM_CPU_1_MAP Register bits
    namespace cpu_int_from_cpu_1_map_bits {
        constexpr uint32_t CORE0_CPU_INT_FROM_CPU_1_MAP = (6 << 0);  ///< NA
    }

    /// CPU_INT_FROM_CPU_2_MAP Register bits
    namespace cpu_int_from_cpu_2_map_bits {
        constexpr uint32_t CORE0_CPU_INT_FROM_CPU_2_MAP = (6 << 0);  ///< NA
    }

    /// CPU_INT_FROM_CPU_3_MAP Register bits
    namespace cpu_int_from_cpu_3_map_bits {
        constexpr uint32_t CORE0_CPU_INT_FROM_CPU_3_MAP = (6 << 0);  ///< NA
    }

    /// CACHE_INT_MAP Register bits
    namespace cache_int_map_bits {
        constexpr uint32_t CORE0_CACHE_INT_MAP = (6 << 0);  ///< NA
    }

    /// FLASH_MSPI_INT_MAP Register bits
    namespace flash_mspi_int_map_bits {
        constexpr uint32_t CORE0_FLASH_MSPI_INT_MAP = (6 << 0);  ///< NA
    }

    /// CSI_BRIDGE_INT_MAP Register bits
    namespace csi_bridge_int_map_bits {
        constexpr uint32_t CORE0_CSI_BRIDGE_INT_MAP = (6 << 0);  ///< NA
    }

    /// DSI_BRIDGE_INT_MAP Register bits
    namespace dsi_bridge_int_map_bits {
        constexpr uint32_t CORE0_DSI_BRIDGE_INT_MAP = (6 << 0);  ///< NA
    }

    /// CSI_INT_MAP Register bits
    namespace csi_int_map_bits {
        constexpr uint32_t CORE0_CSI_INT_MAP = (6 << 0);  ///< NA
    }

    /// DSI_INT_MAP Register bits
    namespace dsi_int_map_bits {
        constexpr uint32_t CORE0_DSI_INT_MAP = (6 << 0);  ///< NA
    }

    /// GMII_PHY_INT_MAP Register bits
    namespace gmii_phy_int_map_bits {
        constexpr uint32_t CORE0_GMII_PHY_INT_MAP = (6 << 0);  ///< NA
    }

    /// LPI_INT_MAP Register bits
    namespace lpi_int_map_bits {
        constexpr uint32_t CORE0_LPI_INT_MAP = (6 << 0);  ///< NA
    }

    /// PMT_INT_MAP Register bits
    namespace pmt_int_map_bits {
        constexpr uint32_t CORE0_PMT_INT_MAP = (6 << 0);  ///< NA
    }

    /// SBD_INT_MAP Register bits
    namespace sbd_int_map_bits {
        constexpr uint32_t CORE0_SBD_INT_MAP = (6 << 0);  ///< NA
    }

    /// USB_OTG_INT_MAP Register bits
    namespace usb_otg_int_map_bits {
        constexpr uint32_t CORE0_USB_OTG_INT_MAP = (6 << 0);  ///< NA
    }

    /// USB_OTG_ENDP_MULTI_PROC_INT_MAP Register bits
    namespace usb_otg_endp_multi_proc_int_map_bits {
        constexpr uint32_t CORE0_USB_OTG_ENDP_MULTI_PROC_INT_MAP = (6 << 0);  ///< NA
    }

    /// JPEG_INT_MAP Register bits
    namespace jpeg_int_map_bits {
        constexpr uint32_t CORE0_JPEG_INT_MAP = (6 << 0);  ///< NA
    }

    /// PPA_INT_MAP Register bits
    namespace ppa_int_map_bits {
        constexpr uint32_t CORE0_PPA_INT_MAP = (6 << 0);  ///< NA
    }

    /// CORE0_TRACE_INT_MAP Register bits
    namespace core0_trace_int_map_bits {
        constexpr uint32_t CORE0_CORE0_TRACE_INT_MAP = (6 << 0);  ///< NA
    }

    /// CORE1_TRACE_INT_MAP Register bits
    namespace core1_trace_int_map_bits {
        constexpr uint32_t CORE0_CORE1_TRACE_INT_MAP = (6 << 0);  ///< NA
    }

    /// HP_CORE_CTRL_INT_MAP Register bits
    namespace hp_core_ctrl_int_map_bits {
        constexpr uint32_t CORE0_HP_CORE_CTRL_INT_MAP = (6 << 0);  ///< NA
    }

    /// ISP_INT_MAP Register bits
    namespace isp_int_map_bits {
        constexpr uint32_t CORE0_ISP_INT_MAP = (6 << 0);  ///< NA
    }

    /// I3C_MST_INT_MAP Register bits
    namespace i3c_mst_int_map_bits {
        constexpr uint32_t CORE0_I3C_MST_INT_MAP = (6 << 0);  ///< NA
    }

    /// I3C_SLV_INT_MAP Register bits
    namespace i3c_slv_int_map_bits {
        constexpr uint32_t CORE0_I3C_SLV_INT_MAP = (6 << 0);  ///< NA
    }

    /// USB_OTG11_INT_MAP Register bits
    namespace usb_otg11_int_map_bits {
        constexpr uint32_t CORE0_USB_OTG11_INT_MAP = (6 << 0);  ///< NA
    }

    /// DMA2D_IN_CH0_INT_MAP Register bits
    namespace dma2d_in_ch0_int_map_bits {
        constexpr uint32_t CORE0_DMA2D_IN_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// DMA2D_IN_CH1_INT_MAP Register bits
    namespace dma2d_in_ch1_int_map_bits {
        constexpr uint32_t CORE0_DMA2D_IN_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// DMA2D_OUT_CH0_INT_MAP Register bits
    namespace dma2d_out_ch0_int_map_bits {
        constexpr uint32_t CORE0_DMA2D_OUT_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// DMA2D_OUT_CH1_INT_MAP Register bits
    namespace dma2d_out_ch1_int_map_bits {
        constexpr uint32_t CORE0_DMA2D_OUT_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// DMA2D_OUT_CH2_INT_MAP Register bits
    namespace dma2d_out_ch2_int_map_bits {
        constexpr uint32_t CORE0_DMA2D_OUT_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// PSRAM_MSPI_INT_MAP Register bits
    namespace psram_mspi_int_map_bits {
        constexpr uint32_t CORE0_PSRAM_MSPI_INT_MAP = (6 << 0);  ///< NA
    }

    /// HP_SYSREG_INT_MAP Register bits
    namespace hp_sysreg_int_map_bits {
        constexpr uint32_t CORE0_HP_SYSREG_INT_MAP = (6 << 0);  ///< NA
    }

    /// PCNT_INT_MAP Register bits
    namespace pcnt_int_map_bits {
        constexpr uint32_t CORE0_PCNT_INT_MAP = (6 << 0);  ///< NA
    }

    /// HP_PAU_INT_MAP Register bits
    namespace hp_pau_int_map_bits {
        constexpr uint32_t CORE0_HP_PAU_INT_MAP = (6 << 0);  ///< NA
    }

    /// HP_PARLIO_RX_INT_MAP Register bits
    namespace hp_parlio_rx_int_map_bits {
        constexpr uint32_t CORE0_HP_PARLIO_RX_INT_MAP = (6 << 0);  ///< NA
    }

    /// HP_PARLIO_TX_INT_MAP Register bits
    namespace hp_parlio_tx_int_map_bits {
        constexpr uint32_t CORE0_HP_PARLIO_TX_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_OUT_CH0_INT_MAP Register bits
    namespace h264_dma2d_out_ch0_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_OUT_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_OUT_CH1_INT_MAP Register bits
    namespace h264_dma2d_out_ch1_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_OUT_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_OUT_CH2_INT_MAP Register bits
    namespace h264_dma2d_out_ch2_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_OUT_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_OUT_CH3_INT_MAP Register bits
    namespace h264_dma2d_out_ch3_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_OUT_CH3_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_OUT_CH4_INT_MAP Register bits
    namespace h264_dma2d_out_ch4_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_OUT_CH4_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH0_INT_MAP Register bits
    namespace h264_dma2d_in_ch0_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH0_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH1_INT_MAP Register bits
    namespace h264_dma2d_in_ch1_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH1_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH2_INT_MAP Register bits
    namespace h264_dma2d_in_ch2_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH2_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH3_INT_MAP Register bits
    namespace h264_dma2d_in_ch3_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH3_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH4_INT_MAP Register bits
    namespace h264_dma2d_in_ch4_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH4_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_DMA2D_IN_CH5_INT_MAP Register bits
    namespace h264_dma2d_in_ch5_int_map_bits {
        constexpr uint32_t CORE0_H264_DMA2D_IN_CH5_INT_MAP = (6 << 0);  ///< NA
    }

    /// H264_REG_INT_MAP Register bits
    namespace h264_reg_int_map_bits {
        constexpr uint32_t CORE0_H264_REG_INT_MAP = (6 << 0);  ///< NA
    }

    /// ASSIST_DEBUG_INT_MAP Register bits
    namespace assist_debug_int_map_bits {
        constexpr uint32_t CORE0_ASSIST_DEBUG_INT_MAP = (6 << 0);  ///< NA
    }

    /// INTR_STATUS_REG_0 Register bits
    namespace intr_status_reg_0_bits {
        constexpr uint32_t CORE0_INTR_STATUS_0 = (32 << 0);  ///< NA
    }

    /// INTR_STATUS_REG_1 Register bits
    namespace intr_status_reg_1_bits {
        constexpr uint32_t CORE0_INTR_STATUS_1 = (32 << 0);  ///< NA
    }

    /// INTR_STATUS_REG_2 Register bits
    namespace intr_status_reg_2_bits {
        constexpr uint32_t CORE0_INTR_STATUS_2 = (32 << 0);  ///< NA
    }

    /// INTR_STATUS_REG_3 Register bits
    namespace intr_status_reg_3_bits {
        constexpr uint32_t CORE0_INTR_STATUS_3 = (32 << 0);  ///< NA
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CORE0_REG_CLK_EN = (1U << 0);  ///< NA
    }

    /// INTERRUPT_REG_DATE Register bits
    namespace interrupt_reg_date_bits {
        constexpr uint32_t CORE0_INTERRUPT_REG_DATE = (28 << 0);  ///< NA
    }

}

// ============================================================================
// MIPI Peripheral
// ============================================================================

namespace mipi {
    /// Base addresses
    constexpr uint32_t MIPI_CSI_BRIDGE_BASE = 0x5009F800;
    constexpr uint32_t MIPI_CSI_HOST_BASE = 0x5009F000;
    constexpr uint32_t MIPI_DSI_BRIDGE_BASE = 0x500A0800;
    constexpr uint32_t MIPI_DSI_HOST_BASE = 0x500A0000;

    /// MIPI Register structure
    struct Registers {
        volatile uint32_t CLK_EN;  ///< Offset: 0x00 - csi bridge register mapping unit clock gating.
        volatile uint32_t CSI_EN;  ///< Offset: 0x04 - csi bridge enable.
        volatile uint32_t DMA_REQ_CFG;  ///< Offset: 0x08 - dma request configuration.
        volatile uint32_t BUF_FLOW_CTL;  ///< Offset: 0x0C - csi bridge buffer control.
        volatile uint32_t DATA_TYPE_CFG;  ///< Offset: 0x10 - pixel data type configuration.
        volatile uint32_t FRAME_CFG;  ///< Offset: 0x14 - frame configuration.
        volatile uint32_t ENDIAN_MODE;  ///< Offset: 0x18 - data endianness order configuration.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1C - csi bridge interrupt raw.
        volatile uint32_t INT_CLR;  ///< Offset: 0x20 - csi bridge interrupt clr.
        volatile uint32_t INT_ST;  ///< Offset: 0x24 - csi bridge interrupt st.
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - csi bridge interrupt enable.
        volatile uint32_t DMA_REQ_INTERVAL;  ///< Offset: 0x2C - DMA interval configuration.
        volatile uint32_t DMABLK_SIZE;  ///< Offset: 0x30 - DMA block size configuration.
        volatile uint32_t RDN_ECO_CS;  ///< Offset: 0x34 - N/A
        volatile uint32_t RDN_ECO_LOW;  ///< Offset: 0x38 - N/A
        volatile uint32_t RDN_ECO_HIGH;  ///< Offset: 0x3C - N/A
        volatile uint32_t HOST_CTRL;  ///< Offset: 0x40 - csi host control by csi bridge.
        volatile uint32_t MEM_CTRL;  ///< Offset: 0x44 - csi bridge buffer control.
    };

    /// Peripheral instances
    inline Registers* MIPI_CSI_BRIDGE = reinterpret_cast<Registers*>(MIPI_CSI_BRIDGE_BASE);
    inline Registers* MIPI_CSI_HOST = reinterpret_cast<Registers*>(MIPI_CSI_HOST_BASE);
    inline Registers* MIPI_DSI_BRIDGE = reinterpret_cast<Registers*>(MIPI_DSI_BRIDGE_BASE);
    inline Registers* MIPI_DSI_HOST = reinterpret_cast<Registers*>(MIPI_DSI_HOST_BASE);

    // Bit definitions
    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< 0: enable clock gating. 1: disable clock gating, clock always on.
    }

    /// CSI_EN Register bits
    namespace csi_en_bits {
        constexpr uint32_t CSI_BRIG_EN = (1U << 0);  ///< 0: disable csi bridge. 1: enable csi bridge.
    }

    /// DMA_REQ_CFG Register bits
    namespace dma_req_cfg_bits {
        constexpr uint32_t DMA_BURST_LEN = (12 << 0);  ///< DMA burst length.
        constexpr uint32_t DMA_CFG_UPD_BY_BLK = (1U << 12);  ///< 1: reg_dma_burst_len & reg_dma_burst_len will be updated by dma block finish. 0: updated by frame.
        constexpr uint32_t DMA_FORCE_RD_STATUS = (1U << 16);  ///< 1: mask dma request when reading frame info. 0: disable mask.
    }

    /// BUF_FLOW_CTL Register bits
    namespace buf_flow_ctl_bits {
        constexpr uint32_t CSI_BUF_AFULL_THRD = (14 << 0);  ///< buffer almost full threshold.
        constexpr uint32_t CSI_BUF_DEPTH = (14 << 16);  ///< buffer data count.
    }

    /// DATA_TYPE_CFG Register bits
    namespace data_type_cfg_bits {
        constexpr uint32_t DATA_TYPE_MIN = (6 << 0);  ///< the min value of data type used for pixel filter.
        constexpr uint32_t DATA_TYPE_MAX = (6 << 8);  ///< the max value of data type used for pixel filter.
    }

    /// FRAME_CFG Register bits
    namespace frame_cfg_bits {
        constexpr uint32_t VADR_NUM = (12 << 0);  ///< vadr of frame data.
        constexpr uint32_t HADR_NUM = (12 << 12);  ///< hadr of frame data.
        constexpr uint32_t HAS_HSYNC_E = (1U << 24);  ///< 0: frame data doesn't contain hsync. 1: frame data contains hsync.
        constexpr uint32_t VADR_NUM_CHECK = (1U << 25);  ///< 0: disable vadr check. 1: enable vadr check.
    }

    /// ENDIAN_MODE Register bits
    namespace endian_mode_bits {
        constexpr uint32_t BYTE_ENDIAN_ORDER = (1U << 0);  ///< endianness order in bytes. 2'h0 is normal mode and 2'h3 is useful to YUV420(Legacy) when isp is bapassed.
        constexpr uint32_t BIT_ENDIAN_ORDER = (1U << 1);  ///< N/A
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t VADR_NUM_GT_INT_RAW = (1U << 0);  ///< reg_vadr_num is greater than real interrupt raw.
        constexpr uint32_t VADR_NUM_LT_INT_RAW = (1U << 1);  ///< reg_vadr_num is less than real interrupt raw.
        constexpr uint32_t DISCARD_INT_RAW = (1U << 2);  ///< an incomplete frame of data was sent interrupt raw.
        constexpr uint32_t CSI_BUF_OVERRUN_INT_RAW = (1U << 3);  ///< buffer overrun interrupt raw.
        constexpr uint32_t CSI_ASYNC_FIFO_OVF_INT_RAW = (1U << 4);  ///< buffer overflow interrupt raw.
        constexpr uint32_t DMA_CFG_HAS_UPDATED_INT_RAW = (1U << 5);  ///< dma configuration update complete interrupt raw.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t VADR_NUM_GT_REAL_INT_CLR = (1U << 0);  ///< reg_vadr_num is greater than real interrupt clr.
        constexpr uint32_t VADR_NUM_LT_REAL_INT_CLR = (1U << 1);  ///< reg_vadr_num is less than real interrupt clr.
        constexpr uint32_t DISCARD_INT_CLR = (1U << 2);  ///< an incomplete frame of data was sent interrupt clr.
        constexpr uint32_t CSI_BUF_OVERRUN_INT_CLR = (1U << 3);  ///< buffer overrun interrupt clr.
        constexpr uint32_t CSI_ASYNC_FIFO_OVF_INT_CLR = (1U << 4);  ///< buffer overflow interrupt clr.
        constexpr uint32_t DMA_CFG_HAS_UPDATED_INT_CLR = (1U << 5);  ///< dma configuration update complete interrupt clr.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t VADR_NUM_GT_INT_ST = (1U << 0);  ///< reg_vadr_num is greater than real interrupt st.
        constexpr uint32_t VADR_NUM_LT_INT_ST = (1U << 1);  ///< reg_vadr_num is less than real interrupt st.
        constexpr uint32_t DISCARD_INT_ST = (1U << 2);  ///< an incomplete frame of data was sent interrupt st.
        constexpr uint32_t CSI_BUF_OVERRUN_INT_ST = (1U << 3);  ///< buffer overrun interrupt st.
        constexpr uint32_t CSI_ASYNC_FIFO_OVF_INT_ST = (1U << 4);  ///< buffer overflow interrupt st.
        constexpr uint32_t DMA_CFG_HAS_UPDATED_INT_ST = (1U << 5);  ///< dma configuration update complete interrupt st.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t VADR_NUM_GT_INT_ENA = (1U << 0);  ///< reg_vadr_num is greater than real interrupt enable.
        constexpr uint32_t VADR_NUM_LT_INT_ENA = (1U << 1);  ///< reg_vadr_num is less than real interrupt enable.
        constexpr uint32_t DISCARD_INT_ENA = (1U << 2);  ///< an incomplete frame of data was sent interrupt enable.
        constexpr uint32_t CSI_BUF_OVERRUN_INT_ENA = (1U << 3);  ///< buffer overrun interrupt enable.
        constexpr uint32_t CSI_ASYNC_FIFO_OVF_INT_ENA = (1U << 4);  ///< buffer overflow interrupt enable.
        constexpr uint32_t DMA_CFG_HAS_UPDATED_INT_ENA = (1U << 5);  ///< dma configuration update complete interrupt enable.
    }

    /// DMA_REQ_INTERVAL Register bits
    namespace dma_req_interval_bits {
        constexpr uint32_t DMA_REQ_INTERVAL = (16 << 0);  ///< 16'b1: 1 cycle. 16'b11: 2 cycle. ... ... 16'hFFFF: 16 cycle.
    }

    /// DMABLK_SIZE Register bits
    namespace dmablk_size_bits {
        constexpr uint32_t DMABLK_SIZE = (13 << 0);  ///< the number of reg_dma_burst_len in a block
    }

    /// RDN_ECO_CS Register bits
    namespace rdn_eco_cs_bits {
        constexpr uint32_t RDN_ECO_EN = (1U << 0);  ///< N/A
        constexpr uint32_t RDN_ECO_RESULT = (1U << 1);  ///< N/A
    }

    /// RDN_ECO_LOW Register bits
    namespace rdn_eco_low_bits {
        constexpr uint32_t RDN_ECO_LOW = (32 << 0);  ///< N/A
    }

    /// RDN_ECO_HIGH Register bits
    namespace rdn_eco_high_bits {
        constexpr uint32_t RDN_ECO_HIGH = (32 << 0);  ///< N/A
    }

    /// HOST_CTRL Register bits
    namespace host_ctrl_bits {
        constexpr uint32_t CSI_ENABLECLK = (1U << 0);  ///< enable clock lane module of csi phy.
        constexpr uint32_t CSI_CFG_CLK_EN = (1U << 1);  ///< enable cfg_clk of csi host module.
        constexpr uint32_t LOOPBK_TEST_EN = (1U << 2);  ///< for phy test by loopback dsi phy to csi phy.
    }

    /// MEM_CTRL Register bits
    namespace mem_ctrl_bits {
        constexpr uint32_t CSI_BRIDGE_MEM_CLK_FORCE_ON = (1U << 0);  ///< csi bridge memory clock gating force on.
        constexpr uint32_t CSI_MEM_AUX_CTRL = (14 << 1);  ///< N/A
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x50094000;

    /// DS Register structure
    struct Registers {
        volatile uint32_t Y_MEM[%s];  ///< Offset: 0x00 - memory that stores Y
        volatile uint32_t M_MEM[%s];  ///< Offset: 0x200 - memory that stores M
        volatile uint32_t RB_MEM[%s];  ///< Offset: 0x400 - memory that stores Rb
        volatile uint32_t BOX_MEM[%s];  ///< Offset: 0x600 - memory that stores BOX
        volatile uint32_t IV_MEM[%s];  ///< Offset: 0x630 - memory that stores IV
        volatile uint32_t X_MEM[%s];  ///< Offset: 0x800 - memory that stores X
        volatile uint32_t Z_MEM[%s];  ///< Offset: 0xA00 - memory that stores Z
        volatile uint32_t SET_START;  ///< Offset: 0xE00 - DS start control register
        volatile uint32_t SET_CONTINUE;  ///< Offset: 0xE04 - DS continue control register
        volatile uint32_t SET_FINISH;  ///< Offset: 0xE08 - DS finish control register
        volatile uint32_t QUERY_BUSY;  ///< Offset: 0xE0C - DS query busy register
        volatile uint32_t QUERY_KEY_WRONG;  ///< Offset: 0xE10 - DS query key-wrong counter register
        volatile uint32_t QUERY_CHECK;  ///< Offset: 0xE14 - DS query check result register
        volatile uint32_t DATE;  ///< Offset: 0xE20 - DS version control register
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// SET_START Register bits
    namespace set_start_bits {
        constexpr uint32_t SET_START = (1U << 0);  ///< set this bit to start DS operation.
    }

    /// SET_CONTINUE Register bits
    namespace set_continue_bits {
        constexpr uint32_t SET_CONTINUE = (1U << 0);  ///< set this bit to continue DS operation.
    }

    /// SET_FINISH Register bits
    namespace set_finish_bits {
        constexpr uint32_t SET_FINISH = (1U << 0);  ///< Set this bit to finish DS process.
    }

    /// QUERY_BUSY Register bits
    namespace query_busy_bits {
        constexpr uint32_t QUERY_BUSY = (1U << 0);  ///< digital signature state. 1'b0: idle, 1'b1: busy
    }

    /// QUERY_KEY_WRONG Register bits
    namespace query_key_wrong_bits {
        constexpr uint32_t QUERY_KEY_WRONG = (4 << 0);  ///< digital signature key wrong counter
    }

    /// QUERY_CHECK Register bits
    namespace query_check_bits {
        constexpr uint32_t MD_ERROR = (1U << 0);  ///< MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
        constexpr uint32_t PADDING_BAD = (1U << 1);  ///< padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< ds version information
    }

}

// ============================================================================
// ECC Peripheral
// ============================================================================

namespace ecc {
    /// Base addresses
    constexpr uint32_t ECC_BASE = 0x50093000;

    /// ECC Register structure
    struct Registers {
        volatile uint32_t MULT_INT_RAW;  ///< Offset: 0x0C - ECC interrupt raw register, valid in level.
        volatile uint32_t MULT_INT_ST;  ///< Offset: 0x10 - ECC interrupt status register.
        volatile uint32_t MULT_INT_ENA;  ///< Offset: 0x14 - ECC interrupt enable register.
        volatile uint32_t MULT_INT_CLR;  ///< Offset: 0x18 - ECC interrupt clear register.
        volatile uint32_t MULT_CONF;  ///< Offset: 0x1C - ECC configure register
        volatile uint32_t MULT_DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t K_MEM[%s];  ///< Offset: 0x100 - The memory that stores k.
        volatile uint32_t PX_MEM[%s];  ///< Offset: 0x120 - The memory that stores Px.
        volatile uint32_t PY_MEM[%s];  ///< Offset: 0x140 - The memory that stores Py.
    };

    /// Peripheral instances
    inline Registers* ECC = reinterpret_cast<Registers*>(ECC_BASE);

    // Bit definitions
    /// MULT_INT_RAW Register bits
    namespace mult_int_raw_bits {
        constexpr uint32_t CALC_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_ST Register bits
    namespace mult_int_st_bits {
        constexpr uint32_t CALC_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_ENA Register bits
    namespace mult_int_ena_bits {
        constexpr uint32_t CALC_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the ecc_calc_done_int interrupt
    }

    /// MULT_INT_CLR Register bits
    namespace mult_int_clr_bits {
        constexpr uint32_t CALC_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the ecc_calc_done_int interrupt
    }

    /// MULT_CONF Register bits
    namespace mult_conf_bits {
        constexpr uint32_t START = (1U << 0);  ///< Write 1 to start caculation of ECC Accelerator. This bit will be self-cleared after the caculatrion is done.
        constexpr uint32_t RESET = (1U << 1);  ///< Write 1 to reset ECC Accelerator.
        constexpr uint32_t KEY_LENGTH = (1U << 2);  ///< The key length mode bit of ECC Accelerator. 0: P-192. 1: P-256.
        constexpr uint32_t MOD_BASE = (1U << 3);  ///< The mod base of mod operation, only valid in work_mode 8-11. 0: n(order of curve). 1: p(mod base of curve)
        constexpr uint32_t WORK_MODE = (4 << 4);  ///< The work mode bits of ECC Accelerator. 0: Point Mult Mode. 1: Reserved. 2: Point verification mode. 3: Point Verif+mult mode. 4: Jacobian Point Mult Mode. 5: Point Add Mode. 6: Jacobian Point Verification Mode. 7: Point Verif + Jacobian Mult Mode. 8: mod addition. 9. mod substraction. 10: mod multiplication. 11: mod division.
        constexpr uint32_t SECURITY_MODE = (1U << 8);  ///< Reserved
        constexpr uint32_t VERIFICATION_RESULT = (1U << 29);  ///< The verification result bit of ECC Accelerator, only valid when calculation is done.
        constexpr uint32_t CLK_EN = (1U << 30);  ///< Write 1 to force on register clock gate.
        constexpr uint32_t MEM_CLOCK_GATE_FORCE_ON = (1U << 31);  ///< ECC memory clock gate force on register
    }

    /// MULT_DATE Register bits
    namespace mult_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< ECC mult version control register
    }

}

// ============================================================================
// ECDSA Peripheral
// ============================================================================

namespace ecdsa {
    /// Base addresses
    constexpr uint32_t ECDSA_BASE = 0x50096000;

    /// ECDSA Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x04 - ECDSA configure register
        volatile uint32_t CLK;  ///< Offset: 0x08 - ECDSA clock gate register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - ECDSA interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - ECDSA interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - ECDSA interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - ECDSA interrupt clear register.
        volatile uint32_t START;  ///< Offset: 0x1C - ECDSA start register
        volatile uint32_t STATE;  ///< Offset: 0x20 - ECDSA status register
        volatile uint32_t RESULT;  ///< Offset: 0x24 - ECDSA result register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t SHA_MODE;  ///< Offset: 0x200 - ECDSA control SHA register
        volatile uint32_t SHA_START;  ///< Offset: 0x210 - ECDSA control SHA register
        volatile uint32_t SHA_CONTINUE;  ///< Offset: 0x214 - ECDSA control SHA register
        volatile uint32_t SHA_BUSY;  ///< Offset: 0x218 - ECDSA status register
        volatile uint32_t MESSAGE_MEM[%s];  ///< Offset: 0x280 - The memory that stores message.
        volatile uint32_t R_MEM[%s];  ///< Offset: 0xA00 - The memory that stores r.
        volatile uint32_t S_MEM[%s];  ///< Offset: 0xA20 - The memory that stores s.
        volatile uint32_t Z_MEM[%s];  ///< Offset: 0xA40 - The memory that stores software written z.
        volatile uint32_t QAX_MEM[%s];  ///< Offset: 0xA60 - The memory that stores x coordinates of QA or software written k.
        volatile uint32_t QAY_MEM[%s];  ///< Offset: 0xA80 - The memory that stores y coordinates of QA.
    };

    /// Peripheral instances
    inline Registers* ECDSA = reinterpret_cast<Registers*>(ECDSA_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t WORK_MODE = (2 << 0);  ///< The work mode bits of ECDSA Accelerator. 0: Signature Verify Mode. 1: Signature Generate Mode. 2: Export Public Key Mode. 3: invalid.
        constexpr uint32_t ECC_CURVE = (1U << 2);  ///< The ecc curve select bit of ECDSA Accelerator. 0: P-192. 1: P-256.
        constexpr uint32_t SOFTWARE_SET_K = (1U << 3);  ///< The source of k select bit. 0: k is automatically generated by hardware. 1: k is written by software.
        constexpr uint32_t SOFTWARE_SET_Z = (1U << 4);  ///< The source of z select bit. 0: z is generated from SHA result. 1: z is written by software.
        constexpr uint32_t DETERMINISTIC_K = (1U << 5);  ///< The source of hardware generated k. 0: k is generated by TRNG. 1: k is generated by deterministic derivation algorithm.
        constexpr uint32_t DETERMINISTIC_LOOP = (16 << 6);  ///< The (loop number - 1) value in the deterministic derivation algorithm to derive k.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t GATE_FORCE_ON = (1U << 0);  ///< Write 1 to force on register clock gate.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CALC_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the ecdsa_calc_done_int interrupt
        constexpr uint32_t SHA_RELEASE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the ecdsa_sha_release_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CALC_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the ecdsa_calc_done_int interrupt
        constexpr uint32_t SHA_RELEASE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the ecdsa_sha_release_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CALC_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the ecdsa_calc_done_int interrupt
        constexpr uint32_t SHA_RELEASE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the ecdsa_sha_release_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CALC_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the ecdsa_calc_done_int interrupt
        constexpr uint32_t SHA_RELEASE_INT_CLR = (1U << 1);  ///< Set this bit to clear the ecdsa_sha_release_int interrupt
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t START = (1U << 0);  ///< Write 1 to start caculation of ECDSA Accelerator. This bit will be self-cleared after configuration.
        constexpr uint32_t LOAD_DONE = (1U << 1);  ///< Write 1 to input load done signal of ECDSA Accelerator. This bit will be self-cleared after configuration.
        constexpr uint32_t GET_DONE = (1U << 2);  ///< Write 1 to input get done signal of ECDSA Accelerator. This bit will be self-cleared after configuration.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t BUSY = (2 << 0);  ///< The status bits of ECDSA Accelerator. ECDSA is at 0: IDLE, 1: LOAD, 2: GET, 3: BUSY state.
    }

    /// RESULT Register bits
    namespace result_bits {
        constexpr uint32_t OPERATION_RESULT = (1U << 0);  ///< The operation result bit of ECDSA Accelerator, only valid when ECDSA calculation is done.
        constexpr uint32_t K_VALUE_WARNING = (1U << 1);  ///< The k value warning bit of ECDSA Accelerator, valid when k value is bigger than the curve order, then actually taken k = k mod n.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< ECDSA version control register
    }

    /// SHA_MODE Register bits
    namespace sha_mode_bits {
        constexpr uint32_t SHA_MODE = (3 << 0);  ///< The work mode bits of SHA Calculator in ECDSA Accelerator. 1: SHA-224. 2: SHA-256. Others: invalid.
    }

    /// SHA_START Register bits
    namespace sha_start_bits {
        constexpr uint32_t SHA_START = (1U << 0);  ///< Write 1 to start the first caculation of SHA Calculator in ECDSA Accelerator. This bit will be self-cleared after configuration.
    }

    /// SHA_CONTINUE Register bits
    namespace sha_continue_bits {
        constexpr uint32_t SHA_CONTINUE = (1U << 0);  ///< Write 1 to start the latter caculation of SHA Calculator in ECDSA Accelerator. This bit will be self-cleared after configuration.
    }

    /// SHA_BUSY Register bits
    namespace sha_busy_bits {
        constexpr uint32_t SHA_BUSY = (1U << 0);  ///< The busy status bit of SHA Calculator in ECDSA Accelerator. 1:SHA is in calculation. 0: SHA is idle.
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x5012D000;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA0;  ///< Offset: 0x00 - Register 0 that stores data to be programmed.
        volatile uint32_t PGM_DATA1;  ///< Offset: 0x04 - Register 1 that stores data to be programmed.
        volatile uint32_t PGM_DATA2;  ///< Offset: 0x08 - Register 2 that stores data to be programmed.
        volatile uint32_t PGM_DATA3;  ///< Offset: 0x0C - Register 3 that stores data to be programmed.
        volatile uint32_t PGM_DATA4;  ///< Offset: 0x10 - Register 4 that stores data to be programmed.
        volatile uint32_t PGM_DATA5;  ///< Offset: 0x14 - Register 5 that stores data to be programmed.
        volatile uint32_t PGM_DATA6;  ///< Offset: 0x18 - Register 6 that stores data to be programmed.
        volatile uint32_t PGM_DATA7;  ///< Offset: 0x1C - Register 7 that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE0;  ///< Offset: 0x20 - Register 0 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE1;  ///< Offset: 0x24 - Register 1 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE2;  ///< Offset: 0x28 - Register 2 that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - BLOCK0 data register 0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - BLOCK0 data register 1.
        volatile uint32_t RD_REPEAT_DATA1;  ///< Offset: 0x34 - BLOCK0 data register 2.
        volatile uint32_t RD_REPEAT_DATA2;  ///< Offset: 0x38 - BLOCK0 data register 3.
        volatile uint32_t RD_REPEAT_DATA3;  ///< Offset: 0x3C - BLOCK0 data register 4.
        volatile uint32_t RD_REPEAT_DATA4;  ///< Offset: 0x40 - BLOCK0 data register 5.
        volatile uint32_t RD_MAC_SYS_0;  ///< Offset: 0x44 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_1;  ///< Offset: 0x48 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_2;  ///< Offset: 0x4C - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_3;  ///< Offset: 0x50 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_4;  ///< Offset: 0x54 - BLOCK1 data register $n.
        volatile uint32_t RD_MAC_SYS_5;  ///< Offset: 0x58 - BLOCK1 data register $n.
        volatile uint32_t RD_SYS_PART1_DATA0;  ///< Offset: 0x5C - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA1;  ///< Offset: 0x60 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA2;  ///< Offset: 0x64 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA3;  ///< Offset: 0x68 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA4;  ///< Offset: 0x6C - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA5;  ///< Offset: 0x70 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA6;  ///< Offset: 0x74 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA7;  ///< Offset: 0x78 - Register $n of BLOCK2 (system).
        volatile uint32_t RD_USR_DATA0;  ///< Offset: 0x7C - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA1;  ///< Offset: 0x80 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA2;  ///< Offset: 0x84 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA3;  ///< Offset: 0x88 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA4;  ///< Offset: 0x8C - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA5;  ///< Offset: 0x90 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA6;  ///< Offset: 0x94 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA7;  ///< Offset: 0x98 - Register $n of BLOCK3 (user).
        volatile uint32_t RD_KEY0_DATA0;  ///< Offset: 0x9C - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA1;  ///< Offset: 0xA0 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA2;  ///< Offset: 0xA4 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA3;  ///< Offset: 0xA8 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA4;  ///< Offset: 0xAC - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA5;  ///< Offset: 0xB0 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA6;  ///< Offset: 0xB4 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA7;  ///< Offset: 0xB8 - Register $n of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY1_DATA0;  ///< Offset: 0xBC - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA1;  ///< Offset: 0xC0 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA2;  ///< Offset: 0xC4 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA3;  ///< Offset: 0xC8 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA4;  ///< Offset: 0xCC - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA5;  ///< Offset: 0xD0 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA6;  ///< Offset: 0xD4 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA7;  ///< Offset: 0xD8 - Register $n of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY2_DATA0;  ///< Offset: 0xDC - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA1;  ///< Offset: 0xE0 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA2;  ///< Offset: 0xE4 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA3;  ///< Offset: 0xE8 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA4;  ///< Offset: 0xEC - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA5;  ///< Offset: 0xF0 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA6;  ///< Offset: 0xF4 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA7;  ///< Offset: 0xF8 - Register $n of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY3_DATA0;  ///< Offset: 0xFC - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA1;  ///< Offset: 0x100 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA2;  ///< Offset: 0x104 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA3;  ///< Offset: 0x108 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA4;  ///< Offset: 0x10C - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA5;  ///< Offset: 0x110 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA6;  ///< Offset: 0x114 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA7;  ///< Offset: 0x118 - Register $n of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY4_DATA0;  ///< Offset: 0x11C - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA1;  ///< Offset: 0x120 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA2;  ///< Offset: 0x124 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA3;  ///< Offset: 0x128 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA4;  ///< Offset: 0x12C - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA5;  ///< Offset: 0x130 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA6;  ///< Offset: 0x134 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA7;  ///< Offset: 0x138 - Register $n of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY5_DATA0;  ///< Offset: 0x13C - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA1;  ///< Offset: 0x140 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA2;  ///< Offset: 0x144 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA3;  ///< Offset: 0x148 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA4;  ///< Offset: 0x14C - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA5;  ///< Offset: 0x150 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA6;  ///< Offset: 0x154 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA7;  ///< Offset: 0x158 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA0;  ///< Offset: 0x15C - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA1;  ///< Offset: 0x160 - Register $n of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA2;  ///< Offset: 0x164 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA3;  ///< Offset: 0x168 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA4;  ///< Offset: 0x16C - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA5;  ///< Offset: 0x170 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA6;  ///< Offset: 0x174 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA7;  ///< Offset: 0x178 - Register $n of BLOCK10 (system).
        volatile uint32_t RD_REPEAT_ERR0;  ///< Offset: 0x17C - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR1;  ///< Offset: 0x180 - Programming error record register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR2;  ///< Offset: 0x184 - Programming error record register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR3;  ///< Offset: 0x188 - Programming error record register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR4;  ///< Offset: 0x18C - Programming error record register 4 of BLOCK0.
        volatile uint32_t RD_RS_ERR0;  ///< Offset: 0x1C0 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t RD_RS_ERR1;  ///< Offset: 0x1C4 - Programming error record register 1 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x1C8 - eFuse clcok configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x1CC - eFuse operation mode configuraiton register
        volatile uint32_t STATUS;  ///< Offset: 0x1D0 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x1D4 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1D8 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x1DC - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x1E0 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x1E4 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x1E8 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x1EC - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x1F0 - Configurarion register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x1F4 - Configurarion register 2 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF0_RS_BYPASS;  ///< Offset: 0x1F8 - Configurarion register0 of eFuse programming time...
        volatile uint32_t DATE;  ///< Offset: 0x1FC - eFuse version register.
        volatile uint32_t APB2OTP_WR_DIS;  ///< Offset: 0x800 - eFuse apb2otp block0 data register1.
        volatile uint32_t APB2OTP_BLK0_BACKUP1_W1;  ///< Offset: 0x804 - eFuse apb2otp block0 data register2.
        volatile uint32_t APB2OTP_BLK0_BACKUP1_W2;  ///< Offset: 0x808 - eFuse apb2otp block0 data register3.
        volatile uint32_t APB2OTP_BLK0_BACKUP1_W3;  ///< Offset: 0x80C - eFuse apb2otp block0 data register4.
        volatile uint32_t APB2OTP_BLK0_BACKUP1_W4;  ///< Offset: 0x810 - eFuse apb2otp block0 data register5.
        volatile uint32_t APB2OTP_BLK0_BACKUP1_W5;  ///< Offset: 0x814 - eFuse apb2otp block0 data register6.
        volatile uint32_t APB2OTP_BLK0_BACKUP2_W1;  ///< Offset: 0x818 - eFuse apb2otp block0 data register7.
        volatile uint32_t APB2OTP_BLK0_BACKUP2_W2;  ///< Offset: 0x81C - eFuse apb2otp block0 data register8.
        volatile uint32_t APB2OTP_BLK0_BACKUP2_W3;  ///< Offset: 0x820 - eFuse apb2otp block0 data register9.
        volatile uint32_t APB2OTP_BLK0_BACKUP2_W4;  ///< Offset: 0x824 - eFuse apb2otp block0 data register10.
        volatile uint32_t APB2OTP_BLK0_BACKUP2_W5;  ///< Offset: 0x828 - eFuse apb2otp block0 data register11.
        volatile uint32_t APB2OTP_BLK0_BACKUP3_W1;  ///< Offset: 0x82C - eFuse apb2otp block0 data register12.
        volatile uint32_t APB2OTP_BLK0_BACKUP3_W2;  ///< Offset: 0x830 - eFuse apb2otp block0 data register13.
        volatile uint32_t APB2OTP_BLK0_BACKUP3_W3;  ///< Offset: 0x834 - eFuse apb2otp block0 data register14.
        volatile uint32_t APB2OTP_BLK0_BACKUP3_W4;  ///< Offset: 0x838 - eFuse apb2otp block0 data register15.
        volatile uint32_t APB2OTP_BLK0_BACKUP3_W5;  ///< Offset: 0x83C - eFuse apb2otp block0 data register16.
        volatile uint32_t APB2OTP_BLK0_BACKUP4_W1;  ///< Offset: 0x840 - eFuse apb2otp block0 data register17.
        volatile uint32_t APB2OTP_BLK0_BACKUP4_W2;  ///< Offset: 0x844 - eFuse apb2otp block0 data register18.
        volatile uint32_t APB2OTP_BLK0_BACKUP4_W3;  ///< Offset: 0x848 - eFuse apb2otp block0 data register19.
        volatile uint32_t APB2OTP_BLK0_BACKUP4_W4;  ///< Offset: 0x84C - eFuse apb2otp block0 data register20.
        volatile uint32_t APB2OTP_BLK0_BACKUP4_W5;  ///< Offset: 0x850 - eFuse apb2otp block0 data register21.
        volatile uint32_t APB2OTP_BLK1_W1;  ///< Offset: 0x854 - eFuse apb2otp block1 data register1.
        volatile uint32_t APB2OTP_BLK1_W2;  ///< Offset: 0x858 - eFuse apb2otp block1 data register2.
        volatile uint32_t APB2OTP_BLK1_W3;  ///< Offset: 0x85C - eFuse apb2otp block1 data register3.
        volatile uint32_t APB2OTP_BLK1_W4;  ///< Offset: 0x860 - eFuse apb2otp block1 data register4.
        volatile uint32_t APB2OTP_BLK1_W5;  ///< Offset: 0x864 - eFuse apb2otp block1 data register5.
        volatile uint32_t APB2OTP_BLK1_W6;  ///< Offset: 0x868 - eFuse apb2otp block1 data register6.
        volatile uint32_t APB2OTP_BLK1_W7;  ///< Offset: 0x86C - eFuse apb2otp block1 data register7.
        volatile uint32_t APB2OTP_BLK1_W8;  ///< Offset: 0x870 - eFuse apb2otp block1 data register8.
        volatile uint32_t APB2OTP_BLK1_W9;  ///< Offset: 0x874 - eFuse apb2otp block1 data register9.
        volatile uint32_t APB2OTP_BLK2_W1;  ///< Offset: 0x878 - eFuse apb2otp block2 data register1.
        volatile uint32_t APB2OTP_BLK2_W2;  ///< Offset: 0x87C - eFuse apb2otp block2 data register2.
        volatile uint32_t APB2OTP_BLK2_W3;  ///< Offset: 0x880 - eFuse apb2otp block2 data register3.
        volatile uint32_t APB2OTP_BLK2_W4;  ///< Offset: 0x884 - eFuse apb2otp block2 data register4.
        volatile uint32_t APB2OTP_BLK2_W5;  ///< Offset: 0x888 - eFuse apb2otp block2 data register5.
        volatile uint32_t APB2OTP_BLK2_W6;  ///< Offset: 0x88C - eFuse apb2otp block2 data register6.
        volatile uint32_t APB2OTP_BLK2_W7;  ///< Offset: 0x890 - eFuse apb2otp block2 data register7.
        volatile uint32_t APB2OTP_BLK2_W8;  ///< Offset: 0x894 - eFuse apb2otp block2 data register8.
        volatile uint32_t APB2OTP_BLK2_W9;  ///< Offset: 0x898 - eFuse apb2otp block2 data register9.
        volatile uint32_t APB2OTP_BLK2_W10;  ///< Offset: 0x89C - eFuse apb2otp block2 data register10.
        volatile uint32_t APB2OTP_BLK2_W11;  ///< Offset: 0x8A0 - eFuse apb2otp block2 data register11.
        volatile uint32_t APB2OTP_BLK3_W1;  ///< Offset: 0x8A4 - eFuse apb2otp block3 data register1.
        volatile uint32_t APB2OTP_BLK3_W2;  ///< Offset: 0x8A8 - eFuse apb2otp block3 data register2.
        volatile uint32_t APB2OTP_BLK3_W3;  ///< Offset: 0x8AC - eFuse apb2otp block3 data register3.
        volatile uint32_t APB2OTP_BLK3_W4;  ///< Offset: 0x8B0 - eFuse apb2otp block3 data register4.
        volatile uint32_t APB2OTP_BLK3_W5;  ///< Offset: 0x8B4 - eFuse apb2otp block3 data register5.
        volatile uint32_t APB2OTP_BLK3_W6;  ///< Offset: 0x8B8 - eFuse apb2otp block3 data register6.
        volatile uint32_t APB2OTP_BLK3_W7;  ///< Offset: 0x8BC - eFuse apb2otp block3 data register7.
        volatile uint32_t APB2OTP_BLK3_W8;  ///< Offset: 0x8C0 - eFuse apb2otp block3 data register8.
        volatile uint32_t APB2OTP_BLK3_W9;  ///< Offset: 0x8C4 - eFuse apb2otp block3 data register9.
        volatile uint32_t APB2OTP_BLK3_W10;  ///< Offset: 0x8C8 - eFuse apb2otp block3 data register10.
        volatile uint32_t APB2OTP_BLK3_W11;  ///< Offset: 0x8CC - eFuse apb2otp block3 data register11.
        volatile uint32_t APB2OTP_BLK4_W1;  ///< Offset: 0x8D0 - eFuse apb2otp block4 data register1.
        volatile uint32_t APB2OTP_BLK4_W2;  ///< Offset: 0x8D4 - eFuse apb2otp block4 data register2.
        volatile uint32_t APB2OTP_BLK4_W3;  ///< Offset: 0x8D8 - eFuse apb2otp block4 data register3.
        volatile uint32_t APB2OTP_BLK4_W4;  ///< Offset: 0x8DC - eFuse apb2otp block4 data register4.
        volatile uint32_t APB2OTP_BLK4_W5;  ///< Offset: 0x8E0 - eFuse apb2otp block4 data register5.
        volatile uint32_t APB2OTP_BLK4_W6;  ///< Offset: 0x8E4 - eFuse apb2otp block4 data register6.
        volatile uint32_t APB2OTP_BLK4_W7;  ///< Offset: 0x8E8 - eFuse apb2otp block4 data register7.
        volatile uint32_t APB2OTP_BLK4_W8;  ///< Offset: 0x8EC - eFuse apb2otp block4 data register8.
        volatile uint32_t APB2OTP_BLK4_W9;  ///< Offset: 0x8F0 - eFuse apb2otp block4 data register9.
        volatile uint32_t APB2OTP_BLK4_W10;  ///< Offset: 0x8F4 - eFuse apb2otp block4 data registe10.
        volatile uint32_t APB2OTP_BLK4_W11;  ///< Offset: 0x8F8 - eFuse apb2otp block4 data register11.
        volatile uint32_t APB2OTP_BLK5_W1;  ///< Offset: 0x8FC - eFuse apb2otp block5 data register1.
        volatile uint32_t APB2OTP_BLK5_W2;  ///< Offset: 0x900 - eFuse apb2otp block5 data register2.
        volatile uint32_t APB2OTP_BLK5_W3;  ///< Offset: 0x904 - eFuse apb2otp block5 data register3.
        volatile uint32_t APB2OTP_BLK5_W4;  ///< Offset: 0x908 - eFuse apb2otp block5 data register4.
        volatile uint32_t APB2OTP_BLK5_W5;  ///< Offset: 0x90C - eFuse apb2otp block5 data register5.
        volatile uint32_t APB2OTP_BLK5_W6;  ///< Offset: 0x910 - eFuse apb2otp block5 data register6.
        volatile uint32_t APB2OTP_BLK5_W7;  ///< Offset: 0x914 - eFuse apb2otp block5 data register7.
        volatile uint32_t APB2OTP_BLK5_W8;  ///< Offset: 0x918 - eFuse apb2otp block5 data register8.
        volatile uint32_t APB2OTP_BLK5_W9;  ///< Offset: 0x91C - eFuse apb2otp block5 data register9.
        volatile uint32_t APB2OTP_BLK5_W10;  ///< Offset: 0x920 - eFuse apb2otp block5 data register10.
        volatile uint32_t APB2OTP_BLK5_W11;  ///< Offset: 0x924 - eFuse apb2otp block5 data register11.
        volatile uint32_t APB2OTP_BLK6_W1;  ///< Offset: 0x928 - eFuse apb2otp block6 data register1.
        volatile uint32_t APB2OTP_BLK6_W2;  ///< Offset: 0x92C - eFuse apb2otp block6 data register2.
        volatile uint32_t APB2OTP_BLK6_W3;  ///< Offset: 0x930 - eFuse apb2otp block6 data register3.
        volatile uint32_t APB2OTP_BLK6_W4;  ///< Offset: 0x934 - eFuse apb2otp block6 data register4.
        volatile uint32_t APB2OTP_BLK6_W5;  ///< Offset: 0x938 - eFuse apb2otp block6 data register5.
        volatile uint32_t APB2OTP_BLK6_W6;  ///< Offset: 0x93C - eFuse apb2otp block6 data register6.
        volatile uint32_t APB2OTP_BLK6_W7;  ///< Offset: 0x940 - eFuse apb2otp block6 data register7.
        volatile uint32_t APB2OTP_BLK6_W8;  ///< Offset: 0x944 - eFuse apb2otp block6 data register8.
        volatile uint32_t APB2OTP_BLK6_W9;  ///< Offset: 0x948 - eFuse apb2otp block6 data register9.
        volatile uint32_t APB2OTP_BLK6_W10;  ///< Offset: 0x94C - eFuse apb2otp block6 data register10.
        volatile uint32_t APB2OTP_BLK6_W11;  ///< Offset: 0x950 - eFuse apb2otp block6 data register11.
        volatile uint32_t APB2OTP_BLK7_W1;  ///< Offset: 0x954 - eFuse apb2otp block7 data register1.
        volatile uint32_t APB2OTP_BLK7_W2;  ///< Offset: 0x958 - eFuse apb2otp block7 data register2.
        volatile uint32_t APB2OTP_BLK7_W3;  ///< Offset: 0x95C - eFuse apb2otp block7 data register3.
        volatile uint32_t APB2OTP_BLK7_W4;  ///< Offset: 0x960 - eFuse apb2otp block7 data register4.
        volatile uint32_t APB2OTP_BLK7_W5;  ///< Offset: 0x964 - eFuse apb2otp block7 data register5.
        volatile uint32_t APB2OTP_BLK7_W6;  ///< Offset: 0x968 - eFuse apb2otp block7 data register6.
        volatile uint32_t APB2OTP_BLK7_W7;  ///< Offset: 0x96C - eFuse apb2otp block7 data register7.
        volatile uint32_t APB2OTP_BLK7_W8;  ///< Offset: 0x970 - eFuse apb2otp block7 data register8.
        volatile uint32_t APB2OTP_BLK7_W9;  ///< Offset: 0x974 - eFuse apb2otp block7 data register9.
        volatile uint32_t APB2OTP_BLK7_W10;  ///< Offset: 0x978 - eFuse apb2otp block7 data register10.
        volatile uint32_t APB2OTP_BLK7_W11;  ///< Offset: 0x97C - eFuse apb2otp block7 data register11.
        volatile uint32_t APB2OTP_BLK8_W1;  ///< Offset: 0x980 - eFuse apb2otp block8 data register1.
        volatile uint32_t APB2OTP_BLK8_W2;  ///< Offset: 0x984 - eFuse apb2otp block8 data register2.
        volatile uint32_t APB2OTP_BLK8_W3;  ///< Offset: 0x988 - eFuse apb2otp block8 data register3.
        volatile uint32_t APB2OTP_BLK8_W4;  ///< Offset: 0x98C - eFuse apb2otp block8 data register4.
        volatile uint32_t APB2OTP_BLK8_W5;  ///< Offset: 0x990 - eFuse apb2otp block8 data register5.
        volatile uint32_t APB2OTP_BLK8_W6;  ///< Offset: 0x994 - eFuse apb2otp block8 data register6.
        volatile uint32_t APB2OTP_BLK8_W7;  ///< Offset: 0x998 - eFuse apb2otp block8 data register7.
        volatile uint32_t APB2OTP_BLK8_W8;  ///< Offset: 0x99C - eFuse apb2otp block8 data register8.
        volatile uint32_t APB2OTP_BLK8_W9;  ///< Offset: 0x9A0 - eFuse apb2otp block8 data register9.
        volatile uint32_t APB2OTP_BLK8_W10;  ///< Offset: 0x9A4 - eFuse apb2otp block8 data register10.
        volatile uint32_t APB2OTP_BLK8_W11;  ///< Offset: 0x9A8 - eFuse apb2otp block8 data register11.
        volatile uint32_t APB2OTP_BLK9_W1;  ///< Offset: 0x9AC - eFuse apb2otp block9 data register1.
        volatile uint32_t APB2OTP_BLK9_W2;  ///< Offset: 0x9B0 - eFuse apb2otp block9 data register2.
        volatile uint32_t APB2OTP_BLK9_W3;  ///< Offset: 0x9B4 - eFuse apb2otp block9 data register3.
        volatile uint32_t APB2OTP_BLK9_W4;  ///< Offset: 0x9B8 - eFuse apb2otp block9 data register4.
        volatile uint32_t APB2OTP_BLK9_W5;  ///< Offset: 0x9BC - eFuse apb2otp block9 data register5.
        volatile uint32_t APB2OTP_BLK9_W6;  ///< Offset: 0x9C0 - eFuse apb2otp block9 data register6.
        volatile uint32_t APB2OTP_BLK9_W7;  ///< Offset: 0x9C4 - eFuse apb2otp block9 data register7.
        volatile uint32_t APB2OTP_BLK9_W8;  ///< Offset: 0x9C8 - eFuse apb2otp block9 data register8.
        volatile uint32_t APB2OTP_BLK9_W9;  ///< Offset: 0x9CC - eFuse apb2otp block9 data register9.
        volatile uint32_t APB2OTP_BLK9_W10;  ///< Offset: 0x9D0 - eFuse apb2otp block9 data register10.
        volatile uint32_t APB2OTP_BLK9_W11;  ///< Offset: 0x9D4 - eFuse apb2otp block9 data register11.
        volatile uint32_t APB2OTP_BLK10_W1;  ///< Offset: 0x9D8 - eFuse apb2otp block10 data register1.
        volatile uint32_t APB2OTP_BLK10_W2;  ///< Offset: 0x9DC - eFuse apb2otp block10 data register2.
        volatile uint32_t APB2OTP_BLK10_W3;  ///< Offset: 0x9E0 - eFuse apb2otp block10 data register3.
        volatile uint32_t APB2OTP_BLK10_W4;  ///< Offset: 0x9E4 - eFuse apb2otp block10 data register4.
        volatile uint32_t APB2OTP_BLK10_W5;  ///< Offset: 0x9E8 - eFuse apb2otp block10 data register5.
        volatile uint32_t APB2OTP_BLK10_W6;  ///< Offset: 0x9EC - eFuse apb2otp block10 data register6.
        volatile uint32_t APB2OTP_BLK10_W7;  ///< Offset: 0x9F0 - eFuse apb2otp block10 data register7.
        volatile uint32_t APB2OTP_BLK10_W8;  ///< Offset: 0x9F4 - eFuse apb2otp block10 data register8.
        volatile uint32_t APB2OTP_BLK10_W9;  ///< Offset: 0x9F8 - eFuse apb2otp block10 data register9.
        volatile uint32_t APB2OTP_BLK10_W10;  ///< Offset: 0x9FC - eFuse apb2otp block10 data register10.
        volatile uint32_t APB2OTP_BLK10_W11;  ///< Offset: 0xA00 - eFuse apb2otp block10 data register11.
        volatile uint32_t APB2OTP_EN;  ///< Offset: 0xA08 - eFuse apb2otp enable configuration register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA0 Register bits
    namespace pgm_data0_bits {
        constexpr uint32_t PGM_DATA_0 = (32 << 0);  ///< Configures the 0th 32-bit data to be programmed.
    }

    /// PGM_DATA1 Register bits
    namespace pgm_data1_bits {
        constexpr uint32_t PGM_DATA_1 = (32 << 0);  ///< Configures the 1st 32-bit data to be programmed.
    }

    /// PGM_DATA2 Register bits
    namespace pgm_data2_bits {
        constexpr uint32_t PGM_DATA_2 = (32 << 0);  ///< Configures the 2nd 32-bit data to be programmed.
    }

    /// PGM_DATA3 Register bits
    namespace pgm_data3_bits {
        constexpr uint32_t PGM_DATA_3 = (32 << 0);  ///< Configures the 3rd 32-bit data to be programmed.
    }

    /// PGM_DATA4 Register bits
    namespace pgm_data4_bits {
        constexpr uint32_t PGM_DATA_4 = (32 << 0);  ///< Configures the 4th 32-bit data to be programmed.
    }

    /// PGM_DATA5 Register bits
    namespace pgm_data5_bits {
        constexpr uint32_t PGM_DATA_5 = (32 << 0);  ///< Configures the 5th 32-bit data to be programmed.
    }

    /// PGM_DATA6 Register bits
    namespace pgm_data6_bits {
        constexpr uint32_t PGM_DATA_6 = (32 << 0);  ///< Configures the 6th 32-bit data to be programmed.
    }

    /// PGM_DATA7 Register bits
    namespace pgm_data7_bits {
        constexpr uint32_t PGM_DATA_7 = (32 << 0);  ///< Configures the 7th 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE0 Register bits
    namespace pgm_check_value0_bits {
        constexpr uint32_t PGM_RS_DATA_0 = (32 << 0);  ///< Configures the 0th 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE1 Register bits
    namespace pgm_check_value1_bits {
        constexpr uint32_t PGM_RS_DATA_1 = (32 << 0);  ///< Configures the 1st 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE2 Register bits
    namespace pgm_check_value2_bits {
        constexpr uint32_t PGM_RS_DATA_2 = (32 << 0);  ///< Configures the 2nd 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (32 << 0);  ///< Represents whether programming of individual eFuse memory bit is disabled or enabled. 1: Disabled. 0 Enabled.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (7 << 0);  ///< Represents whether reading of individual eFuse block(block4~block10) is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t USB_DEVICE_EXCHG_PINS = (1U << 7);  ///< Enable usb device exchange pins of D+ and D-.
        constexpr uint32_t USB_OTG11_EXCHG_PINS = (1U << 8);  ///< Enable usb otg11 exchange pins of D+ and D-.
        constexpr uint32_t DIS_USB_JTAG = (1U << 9);  ///< Represents whether the function of usb switch to jtag is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t POWERGLITCH_EN = (1U << 10);  ///< Represents whether power glitch function is enabled. 1: enabled. 0: disabled.
        constexpr uint32_t DIS_USB_SERIAL_JTAG = (1U << 11);  ///< Represents whether USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_FORCE_DOWNLOAD = (1U << 12);  ///< Represents whether the function that forces chip into download mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t SPI_DOWNLOAD_MSPI_DIS = (1U << 13);  ///< Set this bit to disable accessing MSPI flash/MSPI ram by SYS AXI matrix during boot_mode_download.
        constexpr uint32_t DIS_TWAI = (1U << 14);  ///< Represents whether TWAI function is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t JTAG_SEL_ENABLE = (1U << 15);  ///< Represents whether the selection between usb_to_jtag and pad_to_jtag through strapping gpio15 when both EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are equal to 0 is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SOFT_DIS_JTAG = (3 << 16);  ///< Represents whether JTAG is disabled in soft way. Odd number: disabled. Even number: enabled.
        constexpr uint32_t DIS_PAD_JTAG = (1U << 19);  ///< Represents whether JTAG is disabled in the hard way(permanently). 1: disabled. 0: enabled.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 20);  ///< Represents whether flash encrypt function is disabled or enabled(except in SPI boot mode). 1: disabled. 0: enabled.
        constexpr uint32_t USB_DEVICE_DREFH = (2 << 21);  ///< USB intphy of usb device signle-end input high threshold, 1.76V to 2V. Step by 80mV
        constexpr uint32_t USB_OTG11_DREFH = (2 << 23);  ///< USB intphy of usb otg11 signle-end input high threshold, 1.76V to 2V. Step by 80mV
        constexpr uint32_t USB_PHY_SEL = (1U << 25);  ///< TBD
        constexpr uint32_t KM_HUK_GEN_STATE_LOW = (6 << 26);  ///< Set this bit to control validation of HUK generate mode. Odd of 1 is invalid, even of 1 is valid.
    }

    /// RD_REPEAT_DATA1 Register bits
    namespace rd_repeat_data1_bits {
        constexpr uint32_t KM_HUK_GEN_STATE_HIGH = (3 << 0);  ///< Set this bit to control validation of HUK generate mode. Odd of 1 is invalid, even of 1 is valid.
        constexpr uint32_t KM_RND_SWITCH_CYCLE = (2 << 3);  ///< Set bits to control key manager random number switch cycle. 0: control by register. 1: 8 km clk cycles. 2: 16 km cycles. 3: 32 km cycles.
        constexpr uint32_t KM_DEPLOY_ONLY_ONCE = (4 << 5);  ///< Set each bit to control whether corresponding key can only be deployed once. 1 is true, 0 is false. Bit0: ecdsa. Bit1: xts. Bit2: hmac. Bit3: ds.
        constexpr uint32_t FORCE_USE_KEY_MANAGER_KEY = (4 << 9);  ///< Set each bit to control whether corresponding key must come from key manager.. 1 is true, 0 is false. Bit0: ecdsa. Bit1: xts. Bit2: hmac. Bit3: ds.
        constexpr uint32_t FORCE_DISABLE_SW_INIT_KEY = (1U << 13);  ///< Set this bit to disable software written init key, and force use efuse_init_key.
        constexpr uint32_t XTS_KEY_LENGTH_256 = (1U << 14);  ///< Set this bit to configure flash encryption use xts-128 key, else use xts-256 key.
        constexpr uint32_t WDT_DELAY_SEL = (2 << 16);  ///< Represents whether RTC watchdog timeout threshold is selected at startup. 1: selected. 0: not selected.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT = (3 << 18);  ///< Represents whether SPI boot encrypt/decrypt is disabled or enabled. Odd number of 1: enabled. Even number of 1: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0 = (1U << 21);  ///< Represents whether revoking first secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1 = (1U << 22);  ///< Represents whether revoking second secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2 = (1U << 23);  ///< Represents whether revoking third secure boot key is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t KEY_PURPOSE_0 = (4 << 24);  ///< Represents the purpose of Key0.
        constexpr uint32_t KEY_PURPOSE_1 = (4 << 28);  ///< Represents the purpose of Key1.
    }

    /// RD_REPEAT_DATA2 Register bits
    namespace rd_repeat_data2_bits {
        constexpr uint32_t KEY_PURPOSE_2 = (4 << 0);  ///< Represents the purpose of Key2.
        constexpr uint32_t KEY_PURPOSE_3 = (4 << 4);  ///< Represents the purpose of Key3.
        constexpr uint32_t KEY_PURPOSE_4 = (4 << 8);  ///< Represents the purpose of Key4.
        constexpr uint32_t KEY_PURPOSE_5 = (4 << 12);  ///< Represents the purpose of Key5.
        constexpr uint32_t SEC_DPA_LEVEL = (2 << 16);  ///< Represents the spa secure level by configuring the clock random divide mode.
        constexpr uint32_t ECDSA_ENABLE_SOFT_K = (1U << 18);  ///< Represents whether hardware random number k is forced used in ESDCA. 1: force used. 0: not force used.
        constexpr uint32_t CRYPT_DPA_ENABLE = (1U << 19);  ///< Represents whether anti-dpa attack is enabled. 1:enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_EN = (1U << 20);  ///< Represents whether secure boot is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE = (1U << 21);  ///< Represents whether revoking aggressive secure boot is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t FLASH_TYPE = (1U << 23);  ///< The type of interfaced flash. 0: four data lines, 1: eight data lines.
        constexpr uint32_t FLASH_PAGE_SIZE = (2 << 24);  ///< Set flash page size.
        constexpr uint32_t FLASH_ECC_EN = (1U << 26);  ///< Set this bit to enable ecc for flash boot.
        constexpr uint32_t DIS_USB_OTG_DOWNLOAD_MODE = (1U << 27);  ///< Set this bit to disable download via USB-OTG.
        constexpr uint32_t FLASH_TPUW = (4 << 28);  ///< Represents the flash waiting time after power-up, in unit of ms. When the value less than 15, the waiting time is the programmed value. Otherwise, the waiting time is 2 times the programmed value.
    }

    /// RD_REPEAT_DATA3 Register bits
    namespace rd_repeat_data3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 0);  ///< Represents whether Download mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_DIRECT_BOOT = (1U << 1);  ///< Represents whether direct boot mode is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_ROM_PRINT = (1U << 2);  ///< Represents whether print from USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t LOCK_KM_KEY = (1U << 3);  ///< TBD
        constexpr uint32_t DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE = (1U << 4);  ///< Represents whether the USB-Serial-JTAG download function is disabled or enabled. 1: disabled. 0: enabled.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 5);  ///< Represents whether security download is enabled or disabled. 1: enabled. 0: disabled.
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 6);  ///< Represents the type of UART printing. 00: force enable printing. 01: enable printing when GPIO8 is reset at low level. 10: enable printing when GPIO8 is reset at high level. 11: force disable printing.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 8);  ///< Represents whether ROM code is forced to send a resume command during SPI boot. 1: forced. 0:not forced.
        constexpr uint32_t SECURE_VERSION = (16 << 9);  ///< Represents the version used by ESP-IDF anti-rollback feature.
        constexpr uint32_t SECURE_BOOT_DISABLE_FAST_WAKE = (1U << 25);  ///< Represents whether FAST VERIFY ON WAKE is disabled or enabled when Secure Boot is enabled. 1: disabled. 0: enabled.
        constexpr uint32_t HYS_EN_PAD = (1U << 26);  ///< Represents whether the hysteresis function of corresponding PAD is enabled. 1: enabled. 0:disabled.
        constexpr uint32_t DCDC_VSET = (5 << 27);  ///< Set the dcdc voltage default.
    }

    /// RD_REPEAT_DATA4 Register bits
    namespace rd_repeat_data4_bits {
        constexpr uint32_t _0PXA_TIEH_SEL_0 = (2 << 0);  ///< TBD
        constexpr uint32_t _0PXA_TIEH_SEL_1 = (2 << 2);  ///< TBD.
        constexpr uint32_t _0PXA_TIEH_SEL_2 = (2 << 4);  ///< TBD.
        constexpr uint32_t _0PXA_TIEH_SEL_3 = (2 << 6);  ///< TBD.
        constexpr uint32_t KM_DISABLE_DEPLOY_MODE = (4 << 8);  ///< TBD.
        constexpr uint32_t USB_DEVICE_DREFL = (2 << 12);  ///< Represents the usb device single-end input low threhold, 0.8 V to 1.04 V with step of 80 mV.
        constexpr uint32_t USB_OTG11_DREFL = (2 << 14);  ///< Represents the usb otg11 single-end input low threhold, 0.8 V to 1.04 V with step of 80 mV.
        constexpr uint32_t HP_PWR_SRC_SEL = (1U << 18);  ///< HP system power source select. 0:LDO. 1: DCDC.
        constexpr uint32_t DCDC_VSET_EN = (1U << 19);  ///< Select dcdc vset use efuse_dcdc_vset.
        constexpr uint32_t DIS_WDT = (1U << 20);  ///< Set this bit to disable watch dog.
        constexpr uint32_t DIS_SWD = (1U << 21);  ///< Set this bit to disable super-watchdog.
    }

    /// RD_MAC_SYS_0 Register bits
    namespace rd_mac_sys_0_bits {
        constexpr uint32_t MAC_0 = (32 << 0);  ///< Stores the low 32 bits of MAC address.
    }

    /// RD_MAC_SYS_1 Register bits
    namespace rd_mac_sys_1_bits {
        constexpr uint32_t MAC_1 = (16 << 0);  ///< Stores the high 16 bits of MAC address.
        constexpr uint32_t MAC_EXT = (16 << 16);  ///< Stores the extended bits of MAC address.
    }

    /// RD_MAC_SYS_2 Register bits
    namespace rd_mac_sys_2_bits {
        constexpr uint32_t MAC_RESERVED_1 = (14 << 0);  ///< Reserved.
        constexpr uint32_t MAC_RESERVED_0 = (18 << 14);  ///< Reserved.
    }

    /// RD_MAC_SYS_3 Register bits
    namespace rd_mac_sys_3_bits {
        constexpr uint32_t MAC_RESERVED_2 = (18 << 0);  ///< Reserved.
        constexpr uint32_t SYS_DATA_PART0_0 = (14 << 18);  ///< Stores the first 14 bits of the zeroth part of system data.
    }

    /// RD_MAC_SYS_4 Register bits
    namespace rd_mac_sys_4_bits {
        constexpr uint32_t SYS_DATA_PART0_1 = (32 << 0);  ///< Stores the first 32 bits of the zeroth part of system data.
    }

    /// RD_MAC_SYS_5 Register bits
    namespace rd_mac_sys_5_bits {
        constexpr uint32_t SYS_DATA_PART0_2 = (32 << 0);  ///< Stores the second 32 bits of the zeroth part of system data.
    }

    /// RD_SYS_PART1_DATA0 Register bits
    namespace rd_sys_part1_data0_bits {
        constexpr uint32_t SYS_DATA_PART1_0 = (32 << 0);  ///< Stores the zeroth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA1 Register bits
    namespace rd_sys_part1_data1_bits {
        constexpr uint32_t SYS_DATA_PART1_1 = (32 << 0);  ///< Stores the first 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA2 Register bits
    namespace rd_sys_part1_data2_bits {
        constexpr uint32_t SYS_DATA_PART1_2 = (32 << 0);  ///< Stores the second 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA3 Register bits
    namespace rd_sys_part1_data3_bits {
        constexpr uint32_t SYS_DATA_PART1_3 = (32 << 0);  ///< Stores the third 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA4 Register bits
    namespace rd_sys_part1_data4_bits {
        constexpr uint32_t SYS_DATA_PART1_4 = (32 << 0);  ///< Stores the fourth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA5 Register bits
    namespace rd_sys_part1_data5_bits {
        constexpr uint32_t SYS_DATA_PART1_5 = (32 << 0);  ///< Stores the fifth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA6 Register bits
    namespace rd_sys_part1_data6_bits {
        constexpr uint32_t SYS_DATA_PART1_6 = (32 << 0);  ///< Stores the sixth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA7 Register bits
    namespace rd_sys_part1_data7_bits {
        constexpr uint32_t SYS_DATA_PART1_7 = (32 << 0);  ///< Stores the seventh 32 bits of the first part of system data.
    }

    /// RD_USR_DATA0 Register bits
    namespace rd_usr_data0_bits {
        constexpr uint32_t USR_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA1 Register bits
    namespace rd_usr_data1_bits {
        constexpr uint32_t USR_DATA1 = (32 << 0);  ///< Stores the first 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA2 Register bits
    namespace rd_usr_data2_bits {
        constexpr uint32_t USR_DATA2 = (32 << 0);  ///< Stores the second 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA3 Register bits
    namespace rd_usr_data3_bits {
        constexpr uint32_t USR_DATA3 = (32 << 0);  ///< Stores the third 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA4 Register bits
    namespace rd_usr_data4_bits {
        constexpr uint32_t USR_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA5 Register bits
    namespace rd_usr_data5_bits {
        constexpr uint32_t USR_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA6 Register bits
    namespace rd_usr_data6_bits {
        constexpr uint32_t USR_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA7 Register bits
    namespace rd_usr_data7_bits {
        constexpr uint32_t USR_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of BLOCK3 (user).
    }

    /// RD_KEY0_DATA0 Register bits
    namespace rd_key0_data0_bits {
        constexpr uint32_t KEY0_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA1 Register bits
    namespace rd_key0_data1_bits {
        constexpr uint32_t KEY0_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY0.
    }

    /// RD_KEY0_DATA2 Register bits
    namespace rd_key0_data2_bits {
        constexpr uint32_t KEY0_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY0.
    }

    /// RD_KEY0_DATA3 Register bits
    namespace rd_key0_data3_bits {
        constexpr uint32_t KEY0_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY0.
    }

    /// RD_KEY0_DATA4 Register bits
    namespace rd_key0_data4_bits {
        constexpr uint32_t KEY0_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA5 Register bits
    namespace rd_key0_data5_bits {
        constexpr uint32_t KEY0_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA6 Register bits
    namespace rd_key0_data6_bits {
        constexpr uint32_t KEY0_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA7 Register bits
    namespace rd_key0_data7_bits {
        constexpr uint32_t KEY0_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY0.
    }

    /// RD_KEY1_DATA0 Register bits
    namespace rd_key1_data0_bits {
        constexpr uint32_t KEY1_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA1 Register bits
    namespace rd_key1_data1_bits {
        constexpr uint32_t KEY1_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY1.
    }

    /// RD_KEY1_DATA2 Register bits
    namespace rd_key1_data2_bits {
        constexpr uint32_t KEY1_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY1.
    }

    /// RD_KEY1_DATA3 Register bits
    namespace rd_key1_data3_bits {
        constexpr uint32_t KEY1_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY1.
    }

    /// RD_KEY1_DATA4 Register bits
    namespace rd_key1_data4_bits {
        constexpr uint32_t KEY1_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA5 Register bits
    namespace rd_key1_data5_bits {
        constexpr uint32_t KEY1_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA6 Register bits
    namespace rd_key1_data6_bits {
        constexpr uint32_t KEY1_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA7 Register bits
    namespace rd_key1_data7_bits {
        constexpr uint32_t KEY1_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY1.
    }

    /// RD_KEY2_DATA0 Register bits
    namespace rd_key2_data0_bits {
        constexpr uint32_t KEY2_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA1 Register bits
    namespace rd_key2_data1_bits {
        constexpr uint32_t KEY2_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY2.
    }

    /// RD_KEY2_DATA2 Register bits
    namespace rd_key2_data2_bits {
        constexpr uint32_t KEY2_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY2.
    }

    /// RD_KEY2_DATA3 Register bits
    namespace rd_key2_data3_bits {
        constexpr uint32_t KEY2_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY2.
    }

    /// RD_KEY2_DATA4 Register bits
    namespace rd_key2_data4_bits {
        constexpr uint32_t KEY2_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA5 Register bits
    namespace rd_key2_data5_bits {
        constexpr uint32_t KEY2_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA6 Register bits
    namespace rd_key2_data6_bits {
        constexpr uint32_t KEY2_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA7 Register bits
    namespace rd_key2_data7_bits {
        constexpr uint32_t KEY2_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY2.
    }

    /// RD_KEY3_DATA0 Register bits
    namespace rd_key3_data0_bits {
        constexpr uint32_t KEY3_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA1 Register bits
    namespace rd_key3_data1_bits {
        constexpr uint32_t KEY3_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY3.
    }

    /// RD_KEY3_DATA2 Register bits
    namespace rd_key3_data2_bits {
        constexpr uint32_t KEY3_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY3.
    }

    /// RD_KEY3_DATA3 Register bits
    namespace rd_key3_data3_bits {
        constexpr uint32_t KEY3_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY3.
    }

    /// RD_KEY3_DATA4 Register bits
    namespace rd_key3_data4_bits {
        constexpr uint32_t KEY3_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA5 Register bits
    namespace rd_key3_data5_bits {
        constexpr uint32_t KEY3_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA6 Register bits
    namespace rd_key3_data6_bits {
        constexpr uint32_t KEY3_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA7 Register bits
    namespace rd_key3_data7_bits {
        constexpr uint32_t KEY3_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY3.
    }

    /// RD_KEY4_DATA0 Register bits
    namespace rd_key4_data0_bits {
        constexpr uint32_t KEY4_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA1 Register bits
    namespace rd_key4_data1_bits {
        constexpr uint32_t KEY4_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY4.
    }

    /// RD_KEY4_DATA2 Register bits
    namespace rd_key4_data2_bits {
        constexpr uint32_t KEY4_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY4.
    }

    /// RD_KEY4_DATA3 Register bits
    namespace rd_key4_data3_bits {
        constexpr uint32_t KEY4_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY4.
    }

    /// RD_KEY4_DATA4 Register bits
    namespace rd_key4_data4_bits {
        constexpr uint32_t KEY4_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA5 Register bits
    namespace rd_key4_data5_bits {
        constexpr uint32_t KEY4_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA6 Register bits
    namespace rd_key4_data6_bits {
        constexpr uint32_t KEY4_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA7 Register bits
    namespace rd_key4_data7_bits {
        constexpr uint32_t KEY4_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY4.
    }

    /// RD_KEY5_DATA0 Register bits
    namespace rd_key5_data0_bits {
        constexpr uint32_t KEY5_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA1 Register bits
    namespace rd_key5_data1_bits {
        constexpr uint32_t KEY5_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY5.
    }

    /// RD_KEY5_DATA2 Register bits
    namespace rd_key5_data2_bits {
        constexpr uint32_t KEY5_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY5.
    }

    /// RD_KEY5_DATA3 Register bits
    namespace rd_key5_data3_bits {
        constexpr uint32_t KEY5_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY5.
    }

    /// RD_KEY5_DATA4 Register bits
    namespace rd_key5_data4_bits {
        constexpr uint32_t KEY5_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA5 Register bits
    namespace rd_key5_data5_bits {
        constexpr uint32_t KEY5_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA6 Register bits
    namespace rd_key5_data6_bits {
        constexpr uint32_t KEY5_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA7 Register bits
    namespace rd_key5_data7_bits {
        constexpr uint32_t KEY5_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY5.
    }

    /// RD_SYS_PART2_DATA0 Register bits
    namespace rd_sys_part2_data0_bits {
        constexpr uint32_t SYS_DATA_PART2_0 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA1 Register bits
    namespace rd_sys_part2_data1_bits {
        constexpr uint32_t SYS_DATA_PART2_1 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA2 Register bits
    namespace rd_sys_part2_data2_bits {
        constexpr uint32_t SYS_DATA_PART2_2 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA3 Register bits
    namespace rd_sys_part2_data3_bits {
        constexpr uint32_t SYS_DATA_PART2_3 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA4 Register bits
    namespace rd_sys_part2_data4_bits {
        constexpr uint32_t SYS_DATA_PART2_4 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA5 Register bits
    namespace rd_sys_part2_data5_bits {
        constexpr uint32_t SYS_DATA_PART2_5 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA6 Register bits
    namespace rd_sys_part2_data6_bits {
        constexpr uint32_t SYS_DATA_PART2_6 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA7 Register bits
    namespace rd_sys_part2_data7_bits {
        constexpr uint32_t SYS_DATA_PART2_7 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_REPEAT_ERR0 Register bits
    namespace rd_repeat_err0_bits {
        constexpr uint32_t RD_DIS_ERR = (7 << 0);  ///< Indicates a programming error of RD_DIS.
        constexpr uint32_t DIS_USB_DEVICE_EXCHG_PINS_ERR = (1U << 7);  ///< Indicates a programming error of DIS_USB_DEVICE_EXCHG_PINS.
        constexpr uint32_t DIS_USB_OTG11_EXCHG_PINS_ERR = (1U << 8);  ///< Indicates a programming error of DIS_USB_OTG11_EXCHG_PINS.
        constexpr uint32_t DIS_USB_JTAG_ERR = (1U << 9);  ///< Indicates a programming error of DIS_USB_JTAG.
        constexpr uint32_t POWERGLITCH_EN_ERR = (1U << 10);  ///< Indicates a programming error of POWERGLITCH_EN.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_ERR = (1U << 11);  ///< Indicates a programming error of DIS_USB_SERIAL_JTAG.
        constexpr uint32_t DIS_FORCE_DOWNLOAD_ERR = (1U << 12);  ///< Indicates a programming error of DIS_FORCE_DOWNLOAD.
        constexpr uint32_t SPI_DOWNLOAD_MSPI_DIS_ERR = (1U << 13);  ///< Indicates a programming error of SPI_DOWNLOAD_MSPI_DIS.
        constexpr uint32_t DIS_TWAI_ERR = (1U << 14);  ///< Indicates a programming error of DIS_TWAI.
        constexpr uint32_t JTAG_SEL_ENABLE_ERR = (1U << 15);  ///< Indicates a programming error of JTAG_SEL_ENABLE.
        constexpr uint32_t SOFT_DIS_JTAG_ERR = (3 << 16);  ///< Indicates a programming error of SOFT_DIS_JTAG.
        constexpr uint32_t DIS_PAD_JTAG_ERR = (1U << 19);  ///< Indicates a programming error of DIS_PAD_JTAG.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 20);  ///< Indicates a programming error of DIS_DOWNLOAD_MANUAL_ENCRYPT.
        constexpr uint32_t USB_DEVICE_DREFH_ERR = (2 << 21);  ///< Indicates a programming error of USB_DEVICE_DREFH.
        constexpr uint32_t USB_OTG11_DREFH_ERR = (2 << 23);  ///< Indicates a programming error of USB_OTG11_DREFH.
        constexpr uint32_t USB_PHY_SEL_ERR = (1U << 25);  ///< Indicates a programming error of USB_PHY_SEL.
        constexpr uint32_t HUK_GEN_STATE_LOW_ERR = (6 << 26);  ///< Indicates a programming error of HUK_GEN_STATE_LOW.
    }

    /// RD_REPEAT_ERR1 Register bits
    namespace rd_repeat_err1_bits {
        constexpr uint32_t KM_HUK_GEN_STATE_HIGH_ERR = (3 << 0);  ///< Indicates a programming error of HUK_GEN_STATE_HIGH.
        constexpr uint32_t KM_RND_SWITCH_CYCLE_ERR = (2 << 3);  ///< Indicates a programming error of KM_RND_SWITCH_CYCLE.
        constexpr uint32_t KM_DEPLOY_ONLY_ONCE_ERR = (4 << 5);  ///< Indicates a programming error of KM_DEPLOY_ONLY_ONCE.
        constexpr uint32_t FORCE_USE_KEY_MANAGER_KEY_ERR = (4 << 9);  ///< Indicates a programming error of FORCE_USE_KEY_MANAGER_KEY.
        constexpr uint32_t FORCE_DISABLE_SW_INIT_KEY_ERR = (1U << 13);  ///< Indicates a programming error of FORCE_DISABLE_SW_INIT_KEY.
        constexpr uint32_t XTS_KEY_LENGTH_256_ERR = (1U << 14);  ///< Indicates a programming error of XTS_KEY_LENGTH_256.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 16);  ///< Indicates a programming error of WDT_DELAY_SEL.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT_ERR = (3 << 18);  ///< Indicates a programming error of SPI_BOOT_CRYPT_CNT.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0_ERR = (1U << 21);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE0.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1_ERR = (1U << 22);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE1.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2_ERR = (1U << 23);  ///< Indicates a programming error of SECURE_BOOT_KEY_REVOKE2.
        constexpr uint32_t KEY_PURPOSE_0_ERR = (4 << 24);  ///< Indicates a programming error of KEY_PURPOSE_0.
        constexpr uint32_t KEY_PURPOSE_1_ERR = (4 << 28);  ///< Indicates a programming error of KEY_PURPOSE_1.
    }

    /// RD_REPEAT_ERR2 Register bits
    namespace rd_repeat_err2_bits {
        constexpr uint32_t KEY_PURPOSE_2_ERR = (4 << 0);  ///< Indicates a programming error of KEY_PURPOSE_2.
        constexpr uint32_t KEY_PURPOSE_3_ERR = (4 << 4);  ///< Indicates a programming error of KEY_PURPOSE_3.
        constexpr uint32_t KEY_PURPOSE_4_ERR = (4 << 8);  ///< Indicates a programming error of KEY_PURPOSE_4.
        constexpr uint32_t KEY_PURPOSE_5_ERR = (4 << 12);  ///< Indicates a programming error of KEY_PURPOSE_5.
        constexpr uint32_t SEC_DPA_LEVEL_ERR = (2 << 16);  ///< Indicates a programming error of SEC_DPA_LEVEL.
        constexpr uint32_t ECDSA_ENABLE_SOFT_K_ERR = (1U << 18);  ///< Indicates a programming error of ECDSA_FORCE_USE_HARDWARE_K.
        constexpr uint32_t CRYPT_DPA_ENABLE_ERR = (1U << 19);  ///< Indicates a programming error of CRYPT_DPA_ENABLE.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 20);  ///< Indicates a programming error of SECURE_BOOT_EN.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = (1U << 21);  ///< Indicates a programming error of SECURE_BOOT_AGGRESSIVE_REVOKE.
        constexpr uint32_t FLASH_TYPE_ERR = (1U << 23);  ///< Indicates a programming error of FLASH_TYPE.
        constexpr uint32_t FLASH_PAGE_SIZE_ERR = (2 << 24);  ///< Indicates a programming error of FLASH_PAGE_SIZE.
        constexpr uint32_t FLASH_ECC_EN_ERR = (1U << 26);  ///< Indicates a programming error of FLASH_ECC_EN.
        constexpr uint32_t DIS_USB_OTG_DOWNLOAD_MODE_ERR = (1U << 27);  ///< Indicates a programming error of DIS_USB_OTG_DOWNLOAD_MODE.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 28);  ///< Indicates a programming error of FLASH_TPUW.
    }

    /// RD_REPEAT_ERR3 Register bits
    namespace rd_repeat_err3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 0);  ///< Indicates a programming error of DIS_DOWNLOAD_MODE.
        constexpr uint32_t DIS_DIRECT_BOOT_ERR = (1U << 1);  ///< Indicates a programming error of DIS_DIRECT_BOOT.
        constexpr uint32_t DIS_USB_SERIAL_JTAG_ROM_PRINT_ERR = (1U << 2);  ///< Indicates a programming error of DIS_USB_SERIAL_JTAG_ROM_PRINT_ERR.
        constexpr uint32_t LOCK_KM_KEY_ERR = (1U << 3);  ///< TBD
        constexpr uint32_t DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR = (1U << 4);  ///< Indicates a programming error of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 5);  ///< Indicates a programming error of ENABLE_SECURITY_DOWNLOAD.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 6);  ///< Indicates a programming error of UART_PRINT_CONTROL.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 8);  ///< Indicates a programming error of FORCE_SEND_RESUME.
        constexpr uint32_t SECURE_VERSION_ERR = (16 << 9);  ///< Indicates a programming error of SECURE VERSION.
        constexpr uint32_t SECURE_BOOT_DISABLE_FAST_WAKE_ERR = (1U << 25);  ///< Indicates a programming error of SECURE_BOOT_DISABLE_FAST_WAKE.
        constexpr uint32_t HYS_EN_PAD_ERR = (1U << 26);  ///< Indicates a programming error of HYS_EN_PAD.
        constexpr uint32_t DCDC_VSET_ERR = (5 << 27);  ///< Indicates a programming error of DCDC_VSET.
    }

    /// RD_REPEAT_ERR4 Register bits
    namespace rd_repeat_err4_bits {
        constexpr uint32_t _0PXA_TIEH_SEL_0_ERR = (2 << 0);  ///< Indicates a programming error of 0PXA_TIEH_SEL_0.
        constexpr uint32_t _0PXA_TIEH_SEL_1_ERR = (2 << 2);  ///< Indicates a programming error of 0PXA_TIEH_SEL_1.
        constexpr uint32_t _0PXA_TIEH_SEL_2_ERR = (2 << 4);  ///< Indicates a programming error of 0PXA_TIEH_SEL_2.
        constexpr uint32_t _0PXA_TIEH_SEL_3_ERR = (2 << 6);  ///< Indicates a programming error of 0PXA_TIEH_SEL_3.
        constexpr uint32_t KM_DISABLE_DEPLOY_MODE_ERR = (4 << 8);  ///< TBD.
        constexpr uint32_t USB_DEVICE_DREFL_ERR = (2 << 12);  ///< Indicates a programming error of USB_DEVICE_DREFL.
        constexpr uint32_t USB_OTG11_DREFL_ERR = (2 << 14);  ///< Indicates a programming error of USB_OTG11_DREFL.
        constexpr uint32_t HP_PWR_SRC_SEL_ERR = (1U << 18);  ///< Indicates a programming error of HP_PWR_SRC_SEL.
        constexpr uint32_t DCDC_VSET_EN_ERR = (1U << 19);  ///< Indicates a programming error of DCDC_VSET_EN.
        constexpr uint32_t DIS_WDT_ERR = (1U << 20);  ///< Indicates a programming error of DIS_WDT.
        constexpr uint32_t DIS_SWD_ERR = (1U << 21);  ///< Indicates a programming error of DIS_SWD.
    }

    /// RD_RS_ERR0 Register bits
    namespace rd_rs_err0_bits {
        constexpr uint32_t MAC_SYS_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t MAC_SYS_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART1_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART1_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t USR_DATA_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t USR_DATA_FAIL = (1U << 11);  ///< 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t KEY0_ERR_NUM = (3 << 12);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY0_FAIL = (1U << 15);  ///< 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY1_ERR_NUM = (3 << 16);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY1_FAIL = (1U << 19);  ///< 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY2_ERR_NUM = (3 << 20);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY2_FAIL = (1U << 23);  ///< 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY3_ERR_NUM = (3 << 24);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY3_FAIL = (1U << 27);  ///< 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY4_ERR_NUM = (3 << 28);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY4_FAIL = (1U << 31);  ///< 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
    }

    /// RD_RS_ERR1 Register bits
    namespace rd_rs_err1_bits {
        constexpr uint32_t KEY5_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY5_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of key5 is reliable 1: Means that programming key5 failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t MEM_FORCE_PD = (1U << 0);  ///< Set this bit to force eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit and force to activate clock signal of eFuse SRAM.
        constexpr uint32_t MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< Set this bit to force enable eFuse register configuration clock signal.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: programming operation command 0x5AA5: read operation command.
        constexpr uint32_t CFG_ECDSA_BLK = (4 << 16);  ///< Configures which block to use for ECDSA key output.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t BLK0_VALID_BIT_CNT = (10 << 10);  ///< Indicates the number of block valid bit.
        constexpr uint32_t CUR_ECDSA_BLK = (4 << 20);  ///< Indicates which block is used for ECDSA key output.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (4 << 2);  ///< The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t THR_A = (8 << 0);  ///< Configures the read hold time.
        constexpr uint32_t TRD = (8 << 8);  ///< Configures the read time.
        constexpr uint32_t TSUR_A = (8 << 16);  ///< Configures the read setup time.
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the waiting time of reading eFuse memory.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t TSUP_A = (8 << 0);  ///< Configures the programming setup time.
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
        constexpr uint32_t THP_A = (8 << 24);  ///< Configures the programming hold time.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
        constexpr uint32_t TPGM = (16 << 16);  ///< Configures the active programming time.
    }

    /// WR_TIM_CONF0_RS_BYPASS Register bits
    namespace wr_tim_conf0_rs_bypass_bits {
        constexpr uint32_t BYPASS_RS_CORRECTION = (1U << 0);  ///< Set this bit to bypass reed solomon correction step.
        constexpr uint32_t BYPASS_RS_BLK_NUM = (11 << 1);  ///< Configures block number of programming twice operation.
        constexpr uint32_t UPDATE = (1U << 12);  ///< Set this bit to update multi-bit register signals.
        constexpr uint32_t TPGM_INACTIVE = (8 << 13);  ///< Configures the inactive programming time.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores eFuse version.
    }

    /// APB2OTP_WR_DIS Register bits
    namespace apb2otp_wr_dis_bits {
        constexpr uint32_t APB2OTP_BLOCK0_WR_DIS = (32 << 0);  ///< Otp block0 write disable data.
    }

    /// APB2OTP_BLK0_BACKUP1_W1 Register bits
    namespace apb2otp_blk0_backup1_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP1_W1 = (32 << 0);  ///< Otp block0 backup1 word1 data.
    }

    /// APB2OTP_BLK0_BACKUP1_W2 Register bits
    namespace apb2otp_blk0_backup1_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP1_W2 = (32 << 0);  ///< Otp block0 backup1 word2 data.
    }

    /// APB2OTP_BLK0_BACKUP1_W3 Register bits
    namespace apb2otp_blk0_backup1_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP1_W3 = (32 << 0);  ///< Otp block0 backup1 word3 data.
    }

    /// APB2OTP_BLK0_BACKUP1_W4 Register bits
    namespace apb2otp_blk0_backup1_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP1_W4 = (32 << 0);  ///< Otp block0 backup1 word4 data.
    }

    /// APB2OTP_BLK0_BACKUP1_W5 Register bits
    namespace apb2otp_blk0_backup1_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP1_W5 = (32 << 0);  ///< Otp block0 backup1 word5 data.
    }

    /// APB2OTP_BLK0_BACKUP2_W1 Register bits
    namespace apb2otp_blk0_backup2_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP2_W1 = (32 << 0);  ///< Otp block0 backup2 word1 data.
    }

    /// APB2OTP_BLK0_BACKUP2_W2 Register bits
    namespace apb2otp_blk0_backup2_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP2_W2 = (32 << 0);  ///< Otp block0 backup2 word2 data.
    }

    /// APB2OTP_BLK0_BACKUP2_W3 Register bits
    namespace apb2otp_blk0_backup2_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP2_W3 = (32 << 0);  ///< Otp block0 backup2 word3 data.
    }

    /// APB2OTP_BLK0_BACKUP2_W4 Register bits
    namespace apb2otp_blk0_backup2_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP2_W4 = (32 << 0);  ///< Otp block0 backup2 word4 data.
    }

    /// APB2OTP_BLK0_BACKUP2_W5 Register bits
    namespace apb2otp_blk0_backup2_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP2_W5 = (32 << 0);  ///< Otp block0 backup2 word5 data.
    }

    /// APB2OTP_BLK0_BACKUP3_W1 Register bits
    namespace apb2otp_blk0_backup3_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP3_W1 = (32 << 0);  ///< Otp block0 backup3 word1 data.
    }

    /// APB2OTP_BLK0_BACKUP3_W2 Register bits
    namespace apb2otp_blk0_backup3_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP3_W2 = (32 << 0);  ///< Otp block0 backup3 word2 data.
    }

    /// APB2OTP_BLK0_BACKUP3_W3 Register bits
    namespace apb2otp_blk0_backup3_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP3_W3 = (32 << 0);  ///< Otp block0 backup3 word3 data.
    }

    /// APB2OTP_BLK0_BACKUP3_W4 Register bits
    namespace apb2otp_blk0_backup3_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP3_W4 = (32 << 0);  ///< Otp block0 backup3 word4 data.
    }

    /// APB2OTP_BLK0_BACKUP3_W5 Register bits
    namespace apb2otp_blk0_backup3_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP3_W5 = (32 << 0);  ///< Otp block0 backup3 word5 data.
    }

    /// APB2OTP_BLK0_BACKUP4_W1 Register bits
    namespace apb2otp_blk0_backup4_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP4_W1 = (32 << 0);  ///< Otp block0 backup4 word1 data.
    }

    /// APB2OTP_BLK0_BACKUP4_W2 Register bits
    namespace apb2otp_blk0_backup4_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP4_W2 = (32 << 0);  ///< Otp block0 backup4 word2 data.
    }

    /// APB2OTP_BLK0_BACKUP4_W3 Register bits
    namespace apb2otp_blk0_backup4_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP4_W3 = (32 << 0);  ///< Otp block0 backup4 word3 data.
    }

    /// APB2OTP_BLK0_BACKUP4_W4 Register bits
    namespace apb2otp_blk0_backup4_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP4_W4 = (32 << 0);  ///< Otp block0 backup4 word4 data.
    }

    /// APB2OTP_BLK0_BACKUP4_W5 Register bits
    namespace apb2otp_blk0_backup4_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK0_BACKUP4_W5 = (32 << 0);  ///< Otp block0 backup4 word5 data.
    }

    /// APB2OTP_BLK1_W1 Register bits
    namespace apb2otp_blk1_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W1 = (32 << 0);  ///< Otp block1 word1 data.
    }

    /// APB2OTP_BLK1_W2 Register bits
    namespace apb2otp_blk1_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W2 = (32 << 0);  ///< Otp block1 word2 data.
    }

    /// APB2OTP_BLK1_W3 Register bits
    namespace apb2otp_blk1_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W3 = (32 << 0);  ///< Otp block1 word3 data.
    }

    /// APB2OTP_BLK1_W4 Register bits
    namespace apb2otp_blk1_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W4 = (32 << 0);  ///< Otp block1 word4 data.
    }

    /// APB2OTP_BLK1_W5 Register bits
    namespace apb2otp_blk1_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W5 = (32 << 0);  ///< Otp block1 word5 data.
    }

    /// APB2OTP_BLK1_W6 Register bits
    namespace apb2otp_blk1_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W6 = (32 << 0);  ///< Otp block1 word6 data.
    }

    /// APB2OTP_BLK1_W7 Register bits
    namespace apb2otp_blk1_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W7 = (32 << 0);  ///< Otp block1 word7 data.
    }

    /// APB2OTP_BLK1_W8 Register bits
    namespace apb2otp_blk1_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W8 = (32 << 0);  ///< Otp block1 word8 data.
    }

    /// APB2OTP_BLK1_W9 Register bits
    namespace apb2otp_blk1_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK1_W9 = (32 << 0);  ///< Otp block1 word9 data.
    }

    /// APB2OTP_BLK2_W1 Register bits
    namespace apb2otp_blk2_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W1 = (32 << 0);  ///< Otp block2 word1 data.
    }

    /// APB2OTP_BLK2_W2 Register bits
    namespace apb2otp_blk2_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W2 = (32 << 0);  ///< Otp block2 word2 data.
    }

    /// APB2OTP_BLK2_W3 Register bits
    namespace apb2otp_blk2_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W3 = (32 << 0);  ///< Otp block2 word3 data.
    }

    /// APB2OTP_BLK2_W4 Register bits
    namespace apb2otp_blk2_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W4 = (32 << 0);  ///< Otp block2 word4 data.
    }

    /// APB2OTP_BLK2_W5 Register bits
    namespace apb2otp_blk2_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W5 = (32 << 0);  ///< Otp block2 word5 data.
    }

    /// APB2OTP_BLK2_W6 Register bits
    namespace apb2otp_blk2_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W6 = (32 << 0);  ///< Otp block2 word6 data.
    }

    /// APB2OTP_BLK2_W7 Register bits
    namespace apb2otp_blk2_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W7 = (32 << 0);  ///< Otp block2 word7 data.
    }

    /// APB2OTP_BLK2_W8 Register bits
    namespace apb2otp_blk2_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W8 = (32 << 0);  ///< Otp block2 word8 data.
    }

    /// APB2OTP_BLK2_W9 Register bits
    namespace apb2otp_blk2_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W9 = (32 << 0);  ///< Otp block2 word9 data.
    }

    /// APB2OTP_BLK2_W10 Register bits
    namespace apb2otp_blk2_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W10 = (32 << 0);  ///< Otp block2 word10 data.
    }

    /// APB2OTP_BLK2_W11 Register bits
    namespace apb2otp_blk2_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK2_W11 = (32 << 0);  ///< Otp block2 word11 data.
    }

    /// APB2OTP_BLK3_W1 Register bits
    namespace apb2otp_blk3_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W1 = (32 << 0);  ///< Otp block3 word1 data.
    }

    /// APB2OTP_BLK3_W2 Register bits
    namespace apb2otp_blk3_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W2 = (32 << 0);  ///< Otp block3 word2 data.
    }

    /// APB2OTP_BLK3_W3 Register bits
    namespace apb2otp_blk3_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W3 = (32 << 0);  ///< Otp block3 word3 data.
    }

    /// APB2OTP_BLK3_W4 Register bits
    namespace apb2otp_blk3_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W4 = (32 << 0);  ///< Otp block3 word4 data.
    }

    /// APB2OTP_BLK3_W5 Register bits
    namespace apb2otp_blk3_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W5 = (32 << 0);  ///< Otp block3 word5 data.
    }

    /// APB2OTP_BLK3_W6 Register bits
    namespace apb2otp_blk3_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W6 = (32 << 0);  ///< Otp block3 word6 data.
    }

    /// APB2OTP_BLK3_W7 Register bits
    namespace apb2otp_blk3_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W7 = (32 << 0);  ///< Otp block3 word7 data.
    }

    /// APB2OTP_BLK3_W8 Register bits
    namespace apb2otp_blk3_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W8 = (32 << 0);  ///< Otp block3 word8 data.
    }

    /// APB2OTP_BLK3_W9 Register bits
    namespace apb2otp_blk3_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W9 = (32 << 0);  ///< Otp block3 word9 data.
    }

    /// APB2OTP_BLK3_W10 Register bits
    namespace apb2otp_blk3_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W10 = (32 << 0);  ///< Otp block3 word10 data.
    }

    /// APB2OTP_BLK3_W11 Register bits
    namespace apb2otp_blk3_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK3_W11 = (32 << 0);  ///< Otp block3 word11 data.
    }

    /// APB2OTP_BLK4_W1 Register bits
    namespace apb2otp_blk4_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W1 = (32 << 0);  ///< Otp block4 word1 data.
    }

    /// APB2OTP_BLK4_W2 Register bits
    namespace apb2otp_blk4_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W2 = (32 << 0);  ///< Otp block4 word2 data.
    }

    /// APB2OTP_BLK4_W3 Register bits
    namespace apb2otp_blk4_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W3 = (32 << 0);  ///< Otp block4 word3 data.
    }

    /// APB2OTP_BLK4_W4 Register bits
    namespace apb2otp_blk4_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W4 = (32 << 0);  ///< Otp block4 word4 data.
    }

    /// APB2OTP_BLK4_W5 Register bits
    namespace apb2otp_blk4_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W5 = (32 << 0);  ///< Otp block4 word5 data.
    }

    /// APB2OTP_BLK4_W6 Register bits
    namespace apb2otp_blk4_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W6 = (32 << 0);  ///< Otp block4 word6 data.
    }

    /// APB2OTP_BLK4_W7 Register bits
    namespace apb2otp_blk4_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W7 = (32 << 0);  ///< Otp block4 word7 data.
    }

    /// APB2OTP_BLK4_W8 Register bits
    namespace apb2otp_blk4_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W8 = (32 << 0);  ///< Otp block4 word8 data.
    }

    /// APB2OTP_BLK4_W9 Register bits
    namespace apb2otp_blk4_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W9 = (32 << 0);  ///< Otp block4 word9 data.
    }

    /// APB2OTP_BLK4_W10 Register bits
    namespace apb2otp_blk4_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W10 = (32 << 0);  ///< Otp block4 word10 data.
    }

    /// APB2OTP_BLK4_W11 Register bits
    namespace apb2otp_blk4_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK4_W11 = (32 << 0);  ///< Otp block4 word11 data.
    }

    /// APB2OTP_BLK5_W1 Register bits
    namespace apb2otp_blk5_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W1 = (32 << 0);  ///< Otp block5 word1 data.
    }

    /// APB2OTP_BLK5_W2 Register bits
    namespace apb2otp_blk5_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W2 = (32 << 0);  ///< Otp block5 word2 data.
    }

    /// APB2OTP_BLK5_W3 Register bits
    namespace apb2otp_blk5_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W3 = (32 << 0);  ///< Otp block5 word3 data.
    }

    /// APB2OTP_BLK5_W4 Register bits
    namespace apb2otp_blk5_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W4 = (32 << 0);  ///< Otp block5 word4 data.
    }

    /// APB2OTP_BLK5_W5 Register bits
    namespace apb2otp_blk5_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W5 = (32 << 0);  ///< Otp block5 word5 data.
    }

    /// APB2OTP_BLK5_W6 Register bits
    namespace apb2otp_blk5_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W6 = (32 << 0);  ///< Otp block5 word6 data.
    }

    /// APB2OTP_BLK5_W7 Register bits
    namespace apb2otp_blk5_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W7 = (32 << 0);  ///< Otp block5 word7 data.
    }

    /// APB2OTP_BLK5_W8 Register bits
    namespace apb2otp_blk5_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W8 = (32 << 0);  ///< Otp block5 word8 data.
    }

    /// APB2OTP_BLK5_W9 Register bits
    namespace apb2otp_blk5_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W9 = (32 << 0);  ///< Otp block5 word9 data.
    }

    /// APB2OTP_BLK5_W10 Register bits
    namespace apb2otp_blk5_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W10 = (32 << 0);  ///< Otp block5 word10 data.
    }

    /// APB2OTP_BLK5_W11 Register bits
    namespace apb2otp_blk5_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK5_W11 = (32 << 0);  ///< Otp block5 word11 data.
    }

    /// APB2OTP_BLK6_W1 Register bits
    namespace apb2otp_blk6_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W1 = (32 << 0);  ///< Otp block6 word1 data.
    }

    /// APB2OTP_BLK6_W2 Register bits
    namespace apb2otp_blk6_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W2 = (32 << 0);  ///< Otp block6 word2 data.
    }

    /// APB2OTP_BLK6_W3 Register bits
    namespace apb2otp_blk6_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W3 = (32 << 0);  ///< Otp block6 word3 data.
    }

    /// APB2OTP_BLK6_W4 Register bits
    namespace apb2otp_blk6_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W4 = (32 << 0);  ///< Otp block6 word4 data.
    }

    /// APB2OTP_BLK6_W5 Register bits
    namespace apb2otp_blk6_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W5 = (32 << 0);  ///< Otp block6 word5 data.
    }

    /// APB2OTP_BLK6_W6 Register bits
    namespace apb2otp_blk6_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W6 = (32 << 0);  ///< Otp block6 word6 data.
    }

    /// APB2OTP_BLK6_W7 Register bits
    namespace apb2otp_blk6_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W7 = (32 << 0);  ///< Otp block6 word7 data.
    }

    /// APB2OTP_BLK6_W8 Register bits
    namespace apb2otp_blk6_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W8 = (32 << 0);  ///< Otp block6 word8 data.
    }

    /// APB2OTP_BLK6_W9 Register bits
    namespace apb2otp_blk6_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W9 = (32 << 0);  ///< Otp block6 word9 data.
    }

    /// APB2OTP_BLK6_W10 Register bits
    namespace apb2otp_blk6_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W10 = (32 << 0);  ///< Otp block6 word10 data.
    }

    /// APB2OTP_BLK6_W11 Register bits
    namespace apb2otp_blk6_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK6_W11 = (32 << 0);  ///< Otp block6 word11 data.
    }

    /// APB2OTP_BLK7_W1 Register bits
    namespace apb2otp_blk7_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W1 = (32 << 0);  ///< Otp block7 word1 data.
    }

    /// APB2OTP_BLK7_W2 Register bits
    namespace apb2otp_blk7_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W2 = (32 << 0);  ///< Otp block7 word2 data.
    }

    /// APB2OTP_BLK7_W3 Register bits
    namespace apb2otp_blk7_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W3 = (32 << 0);  ///< Otp block7 word3 data.
    }

    /// APB2OTP_BLK7_W4 Register bits
    namespace apb2otp_blk7_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W4 = (32 << 0);  ///< Otp block7 word4 data.
    }

    /// APB2OTP_BLK7_W5 Register bits
    namespace apb2otp_blk7_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W5 = (32 << 0);  ///< Otp block7 word5 data.
    }

    /// APB2OTP_BLK7_W6 Register bits
    namespace apb2otp_blk7_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W6 = (32 << 0);  ///< Otp block7 word6 data.
    }

    /// APB2OTP_BLK7_W7 Register bits
    namespace apb2otp_blk7_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W7 = (32 << 0);  ///< Otp block7 word7 data.
    }

    /// APB2OTP_BLK7_W8 Register bits
    namespace apb2otp_blk7_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W8 = (32 << 0);  ///< Otp block7 word8 data.
    }

    /// APB2OTP_BLK7_W9 Register bits
    namespace apb2otp_blk7_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W9 = (32 << 0);  ///< Otp block7 word9 data.
    }

    /// APB2OTP_BLK7_W10 Register bits
    namespace apb2otp_blk7_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W10 = (32 << 0);  ///< Otp block7 word10 data.
    }

    /// APB2OTP_BLK7_W11 Register bits
    namespace apb2otp_blk7_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK7_W11 = (32 << 0);  ///< Otp block7 word11 data.
    }

    /// APB2OTP_BLK8_W1 Register bits
    namespace apb2otp_blk8_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W1 = (32 << 0);  ///< Otp block8 word1 data.
    }

    /// APB2OTP_BLK8_W2 Register bits
    namespace apb2otp_blk8_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W2 = (32 << 0);  ///< Otp block8 word2 data.
    }

    /// APB2OTP_BLK8_W3 Register bits
    namespace apb2otp_blk8_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W3 = (32 << 0);  ///< Otp block8 word3 data.
    }

    /// APB2OTP_BLK8_W4 Register bits
    namespace apb2otp_blk8_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W4 = (32 << 0);  ///< Otp block8 word4 data.
    }

    /// APB2OTP_BLK8_W5 Register bits
    namespace apb2otp_blk8_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W5 = (32 << 0);  ///< Otp block8 word5 data.
    }

    /// APB2OTP_BLK8_W6 Register bits
    namespace apb2otp_blk8_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W6 = (32 << 0);  ///< Otp block8 word6 data.
    }

    /// APB2OTP_BLK8_W7 Register bits
    namespace apb2otp_blk8_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W7 = (32 << 0);  ///< Otp block8 word7 data.
    }

    /// APB2OTP_BLK8_W8 Register bits
    namespace apb2otp_blk8_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W8 = (32 << 0);  ///< Otp block8 word8 data.
    }

    /// APB2OTP_BLK8_W9 Register bits
    namespace apb2otp_blk8_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W9 = (32 << 0);  ///< Otp block8 word9 data.
    }

    /// APB2OTP_BLK8_W10 Register bits
    namespace apb2otp_blk8_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W10 = (32 << 0);  ///< Otp block8 word10 data.
    }

    /// APB2OTP_BLK8_W11 Register bits
    namespace apb2otp_blk8_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK8_W11 = (32 << 0);  ///< Otp block8 word11 data.
    }

    /// APB2OTP_BLK9_W1 Register bits
    namespace apb2otp_blk9_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W1 = (32 << 0);  ///< Otp block9 word1 data.
    }

    /// APB2OTP_BLK9_W2 Register bits
    namespace apb2otp_blk9_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W2 = (32 << 0);  ///< Otp block9 word2 data.
    }

    /// APB2OTP_BLK9_W3 Register bits
    namespace apb2otp_blk9_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W3 = (32 << 0);  ///< Otp block9 word3 data.
    }

    /// APB2OTP_BLK9_W4 Register bits
    namespace apb2otp_blk9_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W4 = (32 << 0);  ///< Otp block9 word4 data.
    }

    /// APB2OTP_BLK9_W5 Register bits
    namespace apb2otp_blk9_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W5 = (32 << 0);  ///< Otp block9 word5 data.
    }

    /// APB2OTP_BLK9_W6 Register bits
    namespace apb2otp_blk9_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W6 = (32 << 0);  ///< Otp block9 word6 data.
    }

    /// APB2OTP_BLK9_W7 Register bits
    namespace apb2otp_blk9_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W7 = (32 << 0);  ///< Otp block9 word7 data.
    }

    /// APB2OTP_BLK9_W8 Register bits
    namespace apb2otp_blk9_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W8 = (32 << 0);  ///< Otp block9 word8 data.
    }

    /// APB2OTP_BLK9_W9 Register bits
    namespace apb2otp_blk9_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W9 = (32 << 0);  ///< Otp block9 word9 data.
    }

    /// APB2OTP_BLK9_W10 Register bits
    namespace apb2otp_blk9_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W10 = (32 << 0);  ///< Otp block9 word10 data.
    }

    /// APB2OTP_BLK9_W11 Register bits
    namespace apb2otp_blk9_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK9_W11 = (32 << 0);  ///< Otp block9 word11 data.
    }

    /// APB2OTP_BLK10_W1 Register bits
    namespace apb2otp_blk10_w1_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W1 = (32 << 0);  ///< Otp block10 word1 data.
    }

    /// APB2OTP_BLK10_W2 Register bits
    namespace apb2otp_blk10_w2_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W2 = (32 << 0);  ///< Otp block10 word2 data.
    }

    /// APB2OTP_BLK10_W3 Register bits
    namespace apb2otp_blk10_w3_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W3 = (32 << 0);  ///< Otp block10 word3 data.
    }

    /// APB2OTP_BLK10_W4 Register bits
    namespace apb2otp_blk10_w4_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W4 = (32 << 0);  ///< Otp block10 word4 data.
    }

    /// APB2OTP_BLK10_W5 Register bits
    namespace apb2otp_blk10_w5_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W5 = (32 << 0);  ///< Otp block10 word5 data.
    }

    /// APB2OTP_BLK10_W6 Register bits
    namespace apb2otp_blk10_w6_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W6 = (32 << 0);  ///< Otp block10 word6 data.
    }

    /// APB2OTP_BLK10_W7 Register bits
    namespace apb2otp_blk10_w7_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W7 = (32 << 0);  ///< Otp block10 word7 data.
    }

    /// APB2OTP_BLK10_W8 Register bits
    namespace apb2otp_blk10_w8_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W8 = (32 << 0);  ///< Otp block10 word8 data.
    }

    /// APB2OTP_BLK10_W9 Register bits
    namespace apb2otp_blk10_w9_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W9 = (32 << 0);  ///< Otp block10 word9 data.
    }

    /// APB2OTP_BLK10_W10 Register bits
    namespace apb2otp_blk10_w10_bits {
        constexpr uint32_t APB2OTP_BLOCK19_W10 = (32 << 0);  ///< Otp block10 word10 data.
    }

    /// APB2OTP_BLK10_W11 Register bits
    namespace apb2otp_blk10_w11_bits {
        constexpr uint32_t APB2OTP_BLOCK10_W11 = (32 << 0);  ///< Otp block10 word11 data.
    }

    /// APB2OTP_EN Register bits
    namespace apb2otp_en_bits {
        constexpr uint32_t APB2OTP_APB2OTP_EN = (1U << 0);  ///< Apb2otp mode enable signal.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x500E0000;
    constexpr uint32_t GPIO_SD_BASE = 0x500E0F00;
    constexpr uint32_t LP_GPIO_BASE = 0x5012A000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t BT_SELECT;  ///< Offset: 0x00 - GPIO bit select register
        volatile uint32_t OUT;  ///< Offset: 0x04 - GPIO output register for GPIO0-31
        volatile uint32_t OUT_W1TS;  ///< Offset: 0x08 - GPIO output set register for GPIO0-31
        volatile uint32_t OUT_W1TC;  ///< Offset: 0x0C - GPIO output clear register for GPIO0-31
        volatile uint32_t OUT1;  ///< Offset: 0x10 - GPIO output register for GPIO32-56
        volatile uint32_t OUT1_W1TS;  ///< Offset: 0x14 - GPIO output set register for GPIO32-56
        volatile uint32_t OUT1_W1TC;  ///< Offset: 0x18 - GPIO output clear register for GPIO32-56
        volatile uint32_t ENABLE;  ///< Offset: 0x20 - GPIO output enable register for GPIO0-31
        volatile uint32_t ENABLE_W1TS;  ///< Offset: 0x24 - GPIO output enable set register for GPIO0-31
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x28 - GPIO output enable clear register for GPIO0-31
        volatile uint32_t ENABLE1;  ///< Offset: 0x2C - GPIO output enable register for GPIO32-56
        volatile uint32_t ENABLE1_W1TS;  ///< Offset: 0x30 - GPIO output enable set register for GPIO32-56
        volatile uint32_t ENABLE1_W1TC;  ///< Offset: 0x34 - GPIO output enable clear register for GPIO32-56
        volatile uint32_t STRAP;  ///< Offset: 0x38 - pad strapping register
        volatile uint32_t IN;  ///< Offset: 0x3C - GPIO input register for GPIO0-31
        volatile uint32_t IN1;  ///< Offset: 0x40 - GPIO input register for GPIO32-56
        volatile uint32_t STATUS;  ///< Offset: 0x44 - GPIO interrupt status register for GPIO0-31
        volatile uint32_t STATUS_W1TS;  ///< Offset: 0x48 - GPIO interrupt status set register for GPIO0-31
        volatile uint32_t STATUS_W1TC;  ///< Offset: 0x4C - GPIO interrupt status clear register for GPIO0-31
        volatile uint32_t STATUS1;  ///< Offset: 0x50 - GPIO interrupt status register for GPIO32-56
        volatile uint32_t STATUS1_W1TS;  ///< Offset: 0x54 - GPIO interrupt status set register for GPIO32-56
        volatile uint32_t STATUS1_W1TC;  ///< Offset: 0x58 - GPIO interrupt status clear register for GPIO32-56
        volatile uint32_t INTR_0;  ///< Offset: 0x5C - GPIO interrupt 0 status register for GPIO0-31
        volatile uint32_t INTR1_0;  ///< Offset: 0x60 - GPIO interrupt 0 status register for GPIO32-56
        volatile uint32_t INTR_1;  ///< Offset: 0x64 - GPIO interrupt 1 status register for GPIO0-31
        volatile uint32_t INTR1_1;  ///< Offset: 0x68 - GPIO interrupt 1 status register for GPIO32-56
        volatile uint32_t STATUS_NEXT;  ///< Offset: 0x6C - GPIO interrupt source register for GPIO0-31
        volatile uint32_t STATUS_NEXT1;  ///< Offset: 0x70 - GPIO interrupt source register for GPIO32-56
        volatile uint32_t PIN%s;  ///< Offset: 0x74 - GPIO pin configuration register
        volatile uint32_t FUNC%s_OUT_SEL_CFG;  ///< Offset: 0x558 - GPIO output function select register
        volatile uint32_t INTR_2;  ///< Offset: 0x63C - GPIO interrupt 2 status register for GPIO0-31
        volatile uint32_t INTR1_2;  ///< Offset: 0x640 - GPIO interrupt 2 status register for GPIO32-56
        volatile uint32_t INTR_3;  ///< Offset: 0x644 - GPIO interrupt 3 status register for GPIO0-31
        volatile uint32_t INTR1_3;  ///< Offset: 0x648 - GPIO interrupt 3 status register for GPIO32-56
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x64C - GPIO clock gate register
        volatile uint32_t INT_RAW;  ///< Offset: 0x700 - analog comparator interrupt raw
        volatile uint32_t INT_ST;  ///< Offset: 0x704 - analog comparator interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x708 - analog comparator interrupt enable
        volatile uint32_t INT_CLR;  ///< Offset: 0x70C - analog comparator interrupt clear
        volatile uint32_t ZERO_DET0_FILTER_CNT;  ///< Offset: 0x710 - GPIO analog comparator zero detect filter count
        volatile uint32_t ZERO_DET1_FILTER_CNT;  ///< Offset: 0x714 - GPIO analog comparator zero detect filter count
        volatile uint32_t SEND_SEQ;  ///< Offset: 0x718 - High speed sdio pad bist send sequence
        volatile uint32_t RECIVE_SEQ;  ///< Offset: 0x71C - High speed sdio pad bist recive sequence
        volatile uint32_t BISTIN_SEL;  ///< Offset: 0x720 - High speed sdio pad bist in pad sel
        volatile uint32_t BIST_CTRL;  ///< Offset: 0x724 - High speed sdio pad bist control
        volatile uint32_t DATE;  ///< Offset: 0x7FC - GPIO version register
        volatile uint32_t FUNC%s_IN_SEL_CFG;  ///< Offset: 0x15C - GPIO input function configuration register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);
    inline Registers* LP_GPIO = reinterpret_cast<Registers*>(LP_GPIO_BASE);

    // Bit definitions
    /// BT_SELECT Register bits
    namespace bt_select_bits {
        constexpr uint32_t BT_SEL = (32 << 0);  ///< GPIO bit select register
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t DATA_ORIG = (32 << 0);  ///< GPIO output register for GPIO0-31
    }

    /// OUT_W1TS Register bits
    namespace out_w1ts_bits {
        constexpr uint32_t OUT_W1TS = (32 << 0);  ///< GPIO output set register for GPIO0-31
    }

    /// OUT_W1TC Register bits
    namespace out_w1tc_bits {
        constexpr uint32_t OUT_W1TC = (32 << 0);  ///< GPIO output clear register for GPIO0-31
    }

    /// OUT1 Register bits
    namespace out1_bits {
        constexpr uint32_t DATA_ORIG = (25 << 0);  ///< GPIO output register for GPIO32-56
    }

    /// OUT1_W1TS Register bits
    namespace out1_w1ts_bits {
        constexpr uint32_t OUT1_W1TS = (25 << 0);  ///< GPIO output set register for GPIO32-56
    }

    /// OUT1_W1TC Register bits
    namespace out1_w1tc_bits {
        constexpr uint32_t OUT1_W1TC = (25 << 0);  ///< GPIO output clear register for GPIO32-56
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< GPIO output enable register for GPIO0-31
    }

    /// ENABLE_W1TS Register bits
    namespace enable_w1ts_bits {
        constexpr uint32_t ENABLE_W1TS = (32 << 0);  ///< GPIO output enable set register for GPIO0-31
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (32 << 0);  ///< GPIO output enable clear register for GPIO0-31
    }

    /// ENABLE1 Register bits
    namespace enable1_bits {
        constexpr uint32_t DATA = (25 << 0);  ///< GPIO output enable register for GPIO32-56
    }

    /// ENABLE1_W1TS Register bits
    namespace enable1_w1ts_bits {
        constexpr uint32_t ENABLE1_W1TS = (25 << 0);  ///< GPIO output enable set register for GPIO32-56
    }

    /// ENABLE1_W1TC Register bits
    namespace enable1_w1tc_bits {
        constexpr uint32_t ENABLE1_W1TC = (25 << 0);  ///< GPIO output enable clear register for GPIO32-56
    }

    /// STRAP Register bits
    namespace strap_bits {
        constexpr uint32_t STRAPPING = (16 << 0);  ///< pad strapping register
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t DATA_NEXT = (32 << 0);  ///< GPIO input register for GPIO0-31
    }

    /// IN1 Register bits
    namespace in1_bits {
        constexpr uint32_t DATA_NEXT = (25 << 0);  ///< GPIO input register for GPIO32-56
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INTERRUPT = (32 << 0);  ///< GPIO interrupt status register for GPIO0-31
    }

    /// STATUS_W1TS Register bits
    namespace status_w1ts_bits {
        constexpr uint32_t STATUS_W1TS = (32 << 0);  ///< GPIO interrupt status set register for GPIO0-31
    }

    /// STATUS_W1TC Register bits
    namespace status_w1tc_bits {
        constexpr uint32_t STATUS_W1TC = (32 << 0);  ///< GPIO interrupt status clear register for GPIO0-31
    }

    /// STATUS1 Register bits
    namespace status1_bits {
        constexpr uint32_t INTERRUPT = (25 << 0);  ///< GPIO interrupt status register for GPIO32-56
    }

    /// STATUS1_W1TS Register bits
    namespace status1_w1ts_bits {
        constexpr uint32_t STATUS1_W1TS = (25 << 0);  ///< GPIO interrupt status set register for GPIO32-56
    }

    /// STATUS1_W1TC Register bits
    namespace status1_w1tc_bits {
        constexpr uint32_t STATUS1_W1TC = (25 << 0);  ///< GPIO interrupt status clear register for GPIO32-56
    }

    /// INTR_0 Register bits
    namespace intr_0_bits {
        constexpr uint32_t INT_0 = (32 << 0);  ///< GPIO interrupt 0 status register for GPIO0-31
    }

    /// INTR1_0 Register bits
    namespace intr1_0_bits {
        constexpr uint32_t INT1_0 = (25 << 0);  ///< GPIO interrupt 0 status register for GPIO32-56
    }

    /// INTR_1 Register bits
    namespace intr_1_bits {
        constexpr uint32_t INT_1 = (32 << 0);  ///< GPIO interrupt 1 status register for GPIO0-31
    }

    /// INTR1_1 Register bits
    namespace intr1_1_bits {
        constexpr uint32_t INT1_1 = (25 << 0);  ///< GPIO interrupt 1 status register for GPIO32-56
    }

    /// STATUS_NEXT Register bits
    namespace status_next_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT = (32 << 0);  ///< GPIO interrupt source register for GPIO0-31
    }

    /// STATUS_NEXT1 Register bits
    namespace status_next1_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT1 = (25 << 0);  ///< GPIO interrupt source register for GPIO32-56
    }

    /// PIN%s Register bits
    namespace pin%s_bits {
        constexpr uint32_t SYNC2_BYPASS = (2 << 0);  ///< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< set this bit to select pad driver. 1:open-drain. 0:normal.
        constexpr uint32_t SYNC1_BYPASS = (2 << 3);  ///< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t INT_TYPE = (3 << 7);  ///< set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
        constexpr uint32_t WAKEUP_ENABLE = (1U << 10);  ///< set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
        constexpr uint32_t CONFIG = (2 << 11);  ///< reserved
        constexpr uint32_t INT_ENA = (5 << 13);  ///< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
    }

    /// FUNC%s_OUT_SEL_CFG Register bits
    namespace func%s_out_sel_cfg_bits {
        constexpr uint32_t OUT_SEL = (9 << 0);  ///< The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-255: output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals GPIO_OUT_REG[n].
        constexpr uint32_t INV_SEL = (1U << 9);  ///< set this bit to invert output signal.1:invert.0:not invert.
        constexpr uint32_t OEN_SEL = (1U << 10);  ///< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
        constexpr uint32_t OEN_INV_SEL = (1U << 11);  ///< set this bit to invert output enable signal.1:invert.0:not invert.
    }

    /// INTR_2 Register bits
    namespace intr_2_bits {
        constexpr uint32_t INT_2 = (32 << 0);  ///< GPIO interrupt 2 status register for GPIO0-31
    }

    /// INTR1_2 Register bits
    namespace intr1_2_bits {
        constexpr uint32_t INT1_2 = (25 << 0);  ///< GPIO interrupt 2 status register for GPIO32-56
    }

    /// INTR_3 Register bits
    namespace intr_3_bits {
        constexpr uint32_t INT_3 = (32 << 0);  ///< GPIO interrupt 3 status register for GPIO0-31
    }

    /// INTR1_3 Register bits
    namespace intr1_3_bits {
        constexpr uint32_t INT1_3 = (25 << 0);  ///< GPIO interrupt 3 status register for GPIO32-56
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable GPIO clock gate
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t COMP0_NEG_INT_RAW = (1U << 0);  ///< analog comparator pos edge interrupt raw
        constexpr uint32_t COMP0_POS_INT_RAW = (1U << 1);  ///< analog comparator neg edge interrupt raw
        constexpr uint32_t COMP0_ALL_INT_RAW = (1U << 2);  ///< analog comparator neg or pos edge interrupt raw
        constexpr uint32_t COMP1_NEG_INT_RAW = (1U << 3);  ///< analog comparator pos edge interrupt raw
        constexpr uint32_t COMP1_POS_INT_RAW = (1U << 4);  ///< analog comparator neg edge interrupt raw
        constexpr uint32_t COMP1_ALL_INT_RAW = (1U << 5);  ///< analog comparator neg or pos edge interrupt raw
        constexpr uint32_t BISTOK_INT_RAW = (1U << 6);  ///< pad bistok interrupt raw
        constexpr uint32_t BISTFAIL_INT_RAW = (1U << 7);  ///< pad bistfail interrupt raw
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t COMP0_NEG_INT_ST = (1U << 0);  ///< analog comparator pos edge interrupt status
        constexpr uint32_t COMP0_POS_INT_ST = (1U << 1);  ///< analog comparator neg edge interrupt status
        constexpr uint32_t COMP0_ALL_INT_ST = (1U << 2);  ///< analog comparator neg or pos edge interrupt status
        constexpr uint32_t COMP1_NEG_INT_ST = (1U << 3);  ///< analog comparator pos edge interrupt status
        constexpr uint32_t COMP1_POS_INT_ST = (1U << 4);  ///< analog comparator neg edge interrupt status
        constexpr uint32_t COMP1_ALL_INT_ST = (1U << 5);  ///< analog comparator neg or pos edge interrupt status
        constexpr uint32_t BISTOK_INT_ST = (1U << 6);  ///< pad bistok interrupt status
        constexpr uint32_t BISTFAIL_INT_ST = (1U << 7);  ///< pad bistfail interrupt status
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t COMP0_NEG_INT_ENA = (1U << 0);  ///< analog comparator pos edge interrupt enable
        constexpr uint32_t COMP0_POS_INT_ENA = (1U << 1);  ///< analog comparator neg edge interrupt enable
        constexpr uint32_t COMP0_ALL_INT_ENA = (1U << 2);  ///< analog comparator neg or pos edge interrupt enable
        constexpr uint32_t COMP1_NEG_INT_ENA = (1U << 3);  ///< analog comparator pos edge interrupt enable
        constexpr uint32_t COMP1_POS_INT_ENA = (1U << 4);  ///< analog comparator neg edge interrupt enable
        constexpr uint32_t COMP1_ALL_INT_ENA = (1U << 5);  ///< analog comparator neg or pos edge interrupt enable
        constexpr uint32_t BISTOK_INT_ENA = (1U << 6);  ///< pad bistok interrupt enable
        constexpr uint32_t BISTFAIL_INT_ENA = (1U << 7);  ///< pad bistfail interrupt enable
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t COMP0_NEG_INT_CLR = (1U << 0);  ///< analog comparator pos edge interrupt clear
        constexpr uint32_t COMP0_POS_INT_CLR = (1U << 1);  ///< analog comparator neg edge interrupt clear
        constexpr uint32_t COMP0_ALL_INT_CLR = (1U << 2);  ///< analog comparator neg or pos edge interrupt clear
        constexpr uint32_t COMP1_NEG_INT_CLR = (1U << 3);  ///< analog comparator pos edge interrupt clear
        constexpr uint32_t COMP1_POS_INT_CLR = (1U << 4);  ///< analog comparator neg edge interrupt clear
        constexpr uint32_t COMP1_ALL_INT_CLR = (1U << 5);  ///< analog comparator neg or pos edge interrupt clear
        constexpr uint32_t BISTOK_INT_CLR = (1U << 6);  ///< pad bistok interrupt enable
        constexpr uint32_t BISTFAIL_INT_CLR = (1U << 7);  ///< pad bistfail interrupt enable
    }

    /// ZERO_DET0_FILTER_CNT Register bits
    namespace zero_det0_filter_cnt_bits {
        constexpr uint32_t ZERO_DET0_FILTER_CNT = (32 << 0);  ///< GPIO analog comparator zero detect filter count
    }

    /// ZERO_DET1_FILTER_CNT Register bits
    namespace zero_det1_filter_cnt_bits {
        constexpr uint32_t ZERO_DET1_FILTER_CNT = (32 << 0);  ///< GPIO analog comparator zero detect filter count
    }

    /// SEND_SEQ Register bits
    namespace send_seq_bits {
        constexpr uint32_t SEND_SEQ = (32 << 0);  ///< High speed sdio pad bist send sequence
    }

    /// RECIVE_SEQ Register bits
    namespace recive_seq_bits {
        constexpr uint32_t RECIVE_SEQ = (32 << 0);  ///< High speed sdio pad bist recive sequence
    }

    /// BISTIN_SEL Register bits
    namespace bistin_sel_bits {
        constexpr uint32_t BISTIN_SEL = (4 << 0);  ///< High speed sdio pad bist in pad sel 0:pad39, 1: pad40...
    }

    /// BIST_CTRL Register bits
    namespace bist_ctrl_bits {
        constexpr uint32_t BIST_PAD_OE = (1U << 0);  ///< High speed sdio pad bist out pad oe
        constexpr uint32_t BIST_START = (1U << 1);  ///< High speed sdio pad bist start
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

    /// FUNC%s_IN_SEL_CFG Register bits
    namespace func%s_in_sel_cfg_bits {
        constexpr uint32_t IN_SEL = (6 << 0);  ///< set this value: s=0-56: connect GPIO[s] to this port. s=0x3F: set this port always high level. s=0x3E: set this port always low level.
        constexpr uint32_t IN_INV_SEL = (1U << 6);  ///< set this bit to invert input signal. 1:invert. 0:not invert.
        constexpr uint32_t SEL = (1U << 7);  ///< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
    }

}

// ============================================================================
// H264 Peripheral
// ============================================================================

namespace h264 {
    /// Base addresses
    constexpr uint32_t H264_BASE = 0x50084000;

    /// H264 Register structure
    struct Registers {
        volatile uint32_t SYS_CTRL;  ///< Offset: 0x00 - H264 system level control register.
        volatile uint32_t GOP_CONF;  ///< Offset: 0x04 - GOP related configuration register.
        volatile uint32_t A_SYS_MB_RES;  ///< Offset: 0x08 - Video A horizontal and vertical MB resolution register.
        volatile uint32_t A_SYS_CONF;  ///< Offset: 0x0C - Video A system level configuration register.
        volatile uint32_t A_DECI_SCORE;  ///< Offset: 0x10 - Video A luma and chroma MB decimate score Register.
        volatile uint32_t A_DECI_SCORE_OFFSET;  ///< Offset: 0x14 - Video A luma and chroma MB decimate score offset Register.
        volatile uint32_t A_RC_CONF0;  ///< Offset: 0x18 - Video A rate control configuration register0.
        volatile uint32_t A_RC_CONF1;  ///< Offset: 0x1C - Video A rate control configuration register1.
        volatile uint32_t A_DB_BYPASS;  ///< Offset: 0x20 - Video A Deblocking bypass register
        volatile uint32_t A_ROI_REGION0;  ///< Offset: 0x24 - Video A H264 ROI region0 range configure register.
        volatile uint32_t A_ROI_REGION1;  ///< Offset: 0x28 - Video A H264 ROI region1 range configure register.
        volatile uint32_t A_ROI_REGION2;  ///< Offset: 0x2C - Video A H264 ROI region2 range configure register.
        volatile uint32_t A_ROI_REGION3;  ///< Offset: 0x30 - Video A H264 ROI region3 range configure register.
        volatile uint32_t A_ROI_REGION4;  ///< Offset: 0x34 - Video A H264 ROI region4 range configure register.
        volatile uint32_t A_ROI_REGION5;  ///< Offset: 0x38 - Video A H264 ROI region5 range configure register.
        volatile uint32_t A_ROI_REGION6;  ///< Offset: 0x3C - Video A H264 ROI region6 range configure register.
        volatile uint32_t A_ROI_REGION7;  ///< Offset: 0x40 - Video A H264 ROI region7 range configure register.
        volatile uint32_t A_ROI_REGION0_3_QP;  ///< Offset: 0x44 - Video A H264 ROI region0, region1,region2,region3 QP register.
        volatile uint32_t A_ROI_REGION4_7_QP;  ///< Offset: 0x48 - Video A H264 ROI region4, region5,region6,region7 QP register.
        volatile uint32_t A_NO_ROI_REGION_QP_OFFSET;  ///< Offset: 0x4C - Video A H264 no roi region QP register.
        volatile uint32_t A_ROI_CONFIG;  ///< Offset: 0x50 - Video A H264 ROI configure register.
        volatile uint32_t B_SYS_MB_RES;  ///< Offset: 0x54 - Video B horizontal and vertical MB resolution register.
        volatile uint32_t B_SYS_CONF;  ///< Offset: 0x58 - Video B system level configuration register.
        volatile uint32_t B_DECI_SCORE;  ///< Offset: 0x5C - Video B luma and chroma MB decimate score Register.
        volatile uint32_t B_DECI_SCORE_OFFSET;  ///< Offset: 0x60 - Video B luma and chroma MB decimate score offset Register.
        volatile uint32_t B_RC_CONF0;  ///< Offset: 0x64 - Video B rate control configuration register0.
        volatile uint32_t B_RC_CONF1;  ///< Offset: 0x68 - Video B rate control configuration register1.
        volatile uint32_t B_DB_BYPASS;  ///< Offset: 0x6C - Video B Deblocking bypass register
        volatile uint32_t B_ROI_REGION0;  ///< Offset: 0x70 - Video B H264 ROI region0 range configure register.
        volatile uint32_t B_ROI_REGION1;  ///< Offset: 0x74 - Video B H264 ROI region1 range configure register.
        volatile uint32_t B_ROI_REGION2;  ///< Offset: 0x78 - Video B H264 ROI region2 range configure register.
        volatile uint32_t B_ROI_REGION3;  ///< Offset: 0x7C - Video B H264 ROI region3 range configure register.
        volatile uint32_t B_ROI_REGION4;  ///< Offset: 0x80 - Video B H264 ROI region4 range configure register.
        volatile uint32_t B_ROI_REGION5;  ///< Offset: 0x84 - Video B H264 ROI region5 range configure register.
        volatile uint32_t B_ROI_REGION6;  ///< Offset: 0x88 - Video B H264 ROI region6 range configure register.
        volatile uint32_t B_ROI_REGION7;  ///< Offset: 0x8C - Video B H264 ROI region7 range configure register.
        volatile uint32_t B_ROI_REGION0_3_QP;  ///< Offset: 0x90 - Video B H264 ROI region0, region1,region2,region3 QP register.
        volatile uint32_t B_ROI_REGION4_7_QP;  ///< Offset: 0x94 - Video B H264 ROI region4, region5,region6,region7 QP register.
        volatile uint32_t B_NO_ROI_REGION_QP_OFFSET;  ///< Offset: 0x98 - Video B H264 no roi region QP register.
        volatile uint32_t B_ROI_CONFIG;  ///< Offset: 0x9C - Video B H264 ROI configure register.
        volatile uint32_t RC_STATUS0;  ///< Offset: 0xA0 - Rate control status register0.
        volatile uint32_t RC_STATUS1;  ///< Offset: 0xA4 - Rate control status register1.
        volatile uint32_t RC_STATUS2;  ///< Offset: 0xA8 - Rate control status register2.
        volatile uint32_t SLICE_HEADER_REMAIN;  ///< Offset: 0xAC - Frame Slice Header remain bit register.
        volatile uint32_t SLICE_HEADER_BYTE_LENGTH;  ///< Offset: 0xB0 - Frame Slice Header byte length register.
        volatile uint32_t BS_THRESHOLD;  ///< Offset: 0xB4 - Bitstream buffer overflow threshold register
        volatile uint32_t SLICE_HEADER_BYTE0;  ///< Offset: 0xB8 - Frame Slice Header byte low 32 bit register.
        volatile uint32_t SLICE_HEADER_BYTE1;  ///< Offset: 0xBC - Frame Slice Header byte high 32 bit register.
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Interrupt masked status register
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear register
        volatile uint32_t CONF;  ///< Offset: 0xD0 - General configuration register.
        volatile uint32_t MV_MERGE_CONFIG;  ///< Offset: 0xD4 - Mv merge configuration register.
        volatile uint32_t DEBUG_DMA_SEL;  ///< Offset: 0xD8 - Debug H264 DMA select register
        volatile uint32_t SYS_STATUS;  ///< Offset: 0xDC - System status register.
        volatile uint32_t FRAME_CODE_LENGTH;  ///< Offset: 0xE0 - Frame code byte length register.
        volatile uint32_t DEBUG_INFO0;  ///< Offset: 0xE4 - Debug information register0.
        volatile uint32_t DEBUG_INFO1;  ///< Offset: 0xE8 - Debug information register1.
        volatile uint32_t DEBUG_INFO2;  ///< Offset: 0xEC - Debug information register2.
        volatile uint32_t DATE;  ///< Offset: 0xF0 - Version control register
    };

    /// Peripheral instances
    inline Registers* H264 = reinterpret_cast<Registers*>(H264_BASE);

    // Bit definitions
    /// SYS_CTRL Register bits
    namespace sys_ctrl_bits {
        constexpr uint32_t FRAME_START = (1U << 0);  ///< Configures whether or not to start encoding one frame.\\0: Invalid. No effect\\1: Start encoding one frame
        constexpr uint32_t DMA_MOVE_START = (1U << 1);  ///< Configures whether or not to start moving reference data from external mem.\\0: Invalid. No effect\\1: H264 start moving two MB lines of reference frame from external mem to internal mem
        constexpr uint32_t FRAME_MODE = (1U << 2);  ///< Configures H264 running mode. When field H264_DUAL_STREAM_MODE is set to 1, this field must be set to 1 too.\\0: GOP mode. Before every GOP first frame start, need reconfig reference frame DMA\\1: Frame mode. Before every frame start, need reconfig reference frame DMA
        constexpr uint32_t SYS_RST_PULSE = (1U << 3);  ///< Configures whether or not to reset H264 ip.\\0: Invalid. No effect\\1: Reset H264 ip
    }

    /// GOP_CONF Register bits
    namespace gop_conf_bits {
        constexpr uint32_t DUAL_STREAM_MODE = (1U << 0);  ///< Configures whether or not to enable dual stream mode. When this field is set to 1, H264_FRAME_MODE field must be set to 1 too.\\0: Normal mode\\1: Dual stream mode
        constexpr uint32_t GOP_NUM = (8 << 1);  ///< Configures the frame number of one GOP.\\0: The frame number of one GOP is infinite\\Others: Actual frame number of one GOP
    }

    /// A_SYS_MB_RES Register bits
    namespace a_sys_mb_res_bits {
        constexpr uint32_t A_SYS_TOTAL_MB_Y = (7 << 0);  ///< Configures video A vertical MB resolution.
        constexpr uint32_t A_SYS_TOTAL_MB_X = (7 << 7);  ///< Configures video A horizontal MB resolution.
    }

    /// A_SYS_CONF Register bits
    namespace a_sys_conf_bits {
        constexpr uint32_t A_DB_TMP_READY_TRIGGER_MB_NUM = (7 << 0);  ///< Configures when to trigger video A H264_DB_TMP_READY_INT. When the (MB number of written db temp+1) is greater than this filed in first MB line, trigger H264_DB_TMP_READY_INT. Min is 3.
        constexpr uint32_t A_REC_READY_TRIGGER_MB_LINES = (7 << 7);  ///< Configures when to trigger video A H264_REC_READY_INT. When the MB line number of generated reconstruct pixel is greater than this filed, trigger H264_REC_READY_INT. Min is 4.
        constexpr uint32_t A_INTRA_COST_CMP_OFFSET = (16 << 14);  ///< Configures video A intra cost offset when I MB compared with P MB.
    }

    /// A_DECI_SCORE Register bits
    namespace a_deci_score_bits {
        constexpr uint32_t A_C_DECI_SCORE = (10 << 0);  ///< Configures video A chroma MB decimate score. When chroma score is smaller than it, chroma decimate will be enable.
        constexpr uint32_t A_L_DECI_SCORE = (10 << 10);  ///< Configures video A luma MB decimate score. When luma score is smaller than it, luma decimate will be enable.
    }

    /// A_DECI_SCORE_OFFSET Register bits
    namespace a_deci_score_offset_bits {
        constexpr uint32_t A_I16X16_DECI_SCORE_OFFSET = (6 << 0);  ///< Configures video A i16x16 MB decimate score offset. This offset will be added to i16x16 MB score.
        constexpr uint32_t A_I_CHROMA_DECI_SCORE_OFFSET = (6 << 6);  ///< Configures video A I chroma MB decimate score offset. This offset will be added to I chroma MB score.
        constexpr uint32_t A_P16X16_DECI_SCORE_OFFSET = (6 << 12);  ///< Configures video A p16x16 MB decimate score offset. This offset will be added to p16x16 MB score.
        constexpr uint32_t A_P_CHROMA_DECI_SCORE_OFFSET = (6 << 18);  ///< Configures video A p chroma MB decimate score offset. This offset will be added to p chroma MB score.
    }

    /// A_RC_CONF0 Register bits
    namespace a_rc_conf0_bits {
        constexpr uint32_t A_QP = (6 << 0);  ///< Configures video A frame level initial luma QP value.
        constexpr uint32_t A_RATE_CTRL_U = (16 << 6);  ///< Configures video A parameter U value. U = int((float) u << 8).
        constexpr uint32_t A_MB_RATE_CTRL_EN = (1U << 22);  ///< Configures video A whether or not to open macro block rate ctrl.\\1:Open the macro block rate ctrl\\1:Close the macro block rate ctrl.
    }

    /// A_RC_CONF1 Register bits
    namespace a_rc_conf1_bits {
        constexpr uint32_t A_CHROMA_DC_QP_DELTA = (3 << 0);  ///< Configures video A chroma DC QP offset based on Chroma QP. Chroma DC QP = Chroma QP(after map) + reg_chroma_dc_qp_delta.
        constexpr uint32_t A_CHROMA_QP_DELTA = (4 << 3);  ///< Configures video A chroma QP offset based on luma QP. Chroma QP(before map) = Luma QP + reg_chroma_qp_delta.
        constexpr uint32_t A_QP_MIN = (6 << 7);  ///< Configures video A allowed luma QP min value.
        constexpr uint32_t A_QP_MAX = (6 << 13);  ///< Configures video A allowed luma QP max value.
        constexpr uint32_t A_MAD_FRAME_PRED = (12 << 19);  ///< Configures vdieo A frame level predicted MB MAD value.
    }

    /// A_DB_BYPASS Register bits
    namespace a_db_bypass_bits {
        constexpr uint32_t A_BYPASS_DB_FILTER = (1U << 0);  ///< Configures whether or not to bypass video A deblcoking filter. \\0: Open the deblock filter\\1: Close the deblock filter
    }

    /// A_ROI_REGION0 Register bits
    namespace a_roi_region0_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 0 in Video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 0 in Video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 0 in Video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 0 in Video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 0 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION1 Register bits
    namespace a_roi_region1_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 1 in Video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 1 in Video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 1 in Video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 1 in Video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 1 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION2 Register bits
    namespace a_roi_region2_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 2 in Video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 2 in Video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 2 in Video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 2 in Video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 2 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION3 Register bits
    namespace a_roi_region3_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 3 in Video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 3 in Video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 3 in video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 3 in video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 3 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION4 Register bits
    namespace a_roi_region4_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 4 in Video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 4 in Video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 4 in video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 4 in video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 4 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION5 Register bits
    namespace a_roi_region5_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontial start macroblocks of region 5 video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 5 video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 5 video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 5 in video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 5 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION6 Register bits
    namespace a_roi_region6_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontial start macroblocks of region 6 video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 6 in video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 6 in video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 6 in video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 6 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION7 Register bits
    namespace a_roi_region7_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 7 in video A.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 7 in video A.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 7 in video A.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 7 in video A.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video A ROI of region 7 .\\0:Close ROI\\1:Open ROI.
    }

    /// A_ROI_REGION0_3_QP Register bits
    namespace a_roi_region0_3_qp_bits {
        constexpr uint32_t A_ROI_REGION0_QP = (7 << 0);  ///< Configure H264 ROI region0 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION1_QP = (7 << 7);  ///< Configure H264 ROI region1 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION2_QP = (7 << 14);  ///< Configure H264 ROI region2 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION3_QP = (7 << 21);  ///< Configure H264 ROI region3 qp in video A,fixed qp or delta qp.
    }

    /// A_ROI_REGION4_7_QP Register bits
    namespace a_roi_region4_7_qp_bits {
        constexpr uint32_t A_ROI_REGION4_QP = (7 << 0);  ///< Configure H264 ROI region4 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION5_QP = (7 << 7);  ///< Configure H264 ROI region5 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION6_QP = (7 << 14);  ///< Configure H264 ROI region6 qp in video A,fixed qp or delta qp.
        constexpr uint32_t A_ROI_REGION7_QP = (7 << 21);  ///< Configure H264 ROI region7 qp in video A,fixed qp or delta qp.
    }

    /// A_NO_ROI_REGION_QP_OFFSET Register bits
    namespace a_no_roi_region_qp_offset_bits {
        constexpr uint32_t A_NO_ROI_REGION_QP = (7 << 0);  ///< Configure H264 no region qp in video A, delta qp.
    }

    /// A_ROI_CONFIG Register bits
    namespace a_roi_config_bits {
        constexpr uint32_t A_ROI_EN = (1U << 0);  ///< Configure whether or not to enable ROI in video A.\\0:not enable ROI\\1:enable ROI.
        constexpr uint32_t A_ROI_MODE = (1U << 1);  ///< Configure the mode of ROI in video A.\\0:fixed qp\\1:delta qp.
    }

    /// B_SYS_MB_RES Register bits
    namespace b_sys_mb_res_bits {
        constexpr uint32_t B_SYS_TOTAL_MB_Y = (7 << 0);  ///< Configures video B vertical MB resolution.
        constexpr uint32_t B_SYS_TOTAL_MB_X = (7 << 7);  ///< Configures video B horizontal MB resolution.
    }

    /// B_SYS_CONF Register bits
    namespace b_sys_conf_bits {
        constexpr uint32_t B_DB_TMP_READY_TRIGGER_MB_NUM = (7 << 0);  ///< Configures when to trigger video B H264_DB_TMP_READY_INT. When the (MB number of written db temp+1) is greater than this filed in first MB line, trigger H264_DB_TMP_READY_INT. Min is 3.
        constexpr uint32_t B_REC_READY_TRIGGER_MB_LINES = (7 << 7);  ///< Configures when to trigger video B H264_REC_READY_INT. When the MB line number of generated reconstruct pixel is greater than this filed, trigger H264_REC_READY_INT. Min is 4.
        constexpr uint32_t B_INTRA_COST_CMP_OFFSET = (16 << 14);  ///< Configures video B intra cost offset when I MB compared with P MB.
    }

    /// B_DECI_SCORE Register bits
    namespace b_deci_score_bits {
        constexpr uint32_t B_C_DECI_SCORE = (10 << 0);  ///< Configures video B chroma MB decimate score. When chroma score is smaller than it, chroma decimate will be enable.
        constexpr uint32_t B_L_DECI_SCORE = (10 << 10);  ///< Configures video B luma MB decimate score. When luma score is smaller than it, luma decimate will be enable.
    }

    /// B_DECI_SCORE_OFFSET Register bits
    namespace b_deci_score_offset_bits {
        constexpr uint32_t B_I16X16_DECI_SCORE_OFFSET = (6 << 0);  ///< Configures video B i16x16 MB decimate score offset. This offset will be added to i16x16 MB score.
        constexpr uint32_t B_I_CHROMA_DECI_SCORE_OFFSET = (6 << 6);  ///< Configures video B I chroma MB decimate score offset. This offset will be added to I chroma MB score.
        constexpr uint32_t B_P16X16_DECI_SCORE_OFFSET = (6 << 12);  ///< Configures video B p16x16 MB decimate score offset. This offset will be added to p16x16 MB score.
        constexpr uint32_t B_P_CHROMA_DECI_SCORE_OFFSET = (6 << 18);  ///< Configures video B p chroma MB decimate score offset. This offset will be added to p chroma MB score.
    }

    /// B_RC_CONF0 Register bits
    namespace b_rc_conf0_bits {
        constexpr uint32_t B_QP = (6 << 0);  ///< Configures video B frame level initial luma QP value.
        constexpr uint32_t B_RATE_CTRL_U = (16 << 6);  ///< Configures video B parameter U value. U = int((float) u << 8).
        constexpr uint32_t B_MB_RATE_CTRL_EN = (1U << 22);  ///< Configures video A whether or not to open macro block rate ctrl.\\1:Open the macro block rate ctrl\\1:Close the macro block rate ctrl.
    }

    /// B_RC_CONF1 Register bits
    namespace b_rc_conf1_bits {
        constexpr uint32_t B_CHROMA_DC_QP_DELTA = (3 << 0);  ///< Configures video B chroma DC QP offset based on Chroma QP. Chroma DC QP = Chroma QP(after map) + reg_chroma_dc_qp_delta.
        constexpr uint32_t B_CHROMA_QP_DELTA = (4 << 3);  ///< Configures video B chroma QP offset based on luma QP. Chroma QP(before map) = Luma QP + reg_chroma_qp_delta.
        constexpr uint32_t B_QP_MIN = (6 << 7);  ///< Configures video B allowed luma QP min value.
        constexpr uint32_t B_QP_MAX = (6 << 13);  ///< Configures video B allowed luma QP max value.
        constexpr uint32_t B_MAD_FRAME_PRED = (12 << 19);  ///< Configures vdieo B frame level predicted MB MAD value.
    }

    /// B_DB_BYPASS Register bits
    namespace b_db_bypass_bits {
        constexpr uint32_t B_BYPASS_DB_FILTER = (1U << 0);  ///< Configures whether or not to bypass video B deblcoking filter. \\0: Open the deblock filter\\1: Close the deblock filter
    }

    /// B_ROI_REGION0 Register bits
    namespace b_roi_region0_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 0 in Video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 0 in Video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 0 in Video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 0 in Video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 0 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION1 Register bits
    namespace b_roi_region1_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 1 in Video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 1 in Video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 1 in Video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 1 in Video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 1 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION2 Register bits
    namespace b_roi_region2_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 2 in Video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 2 in Video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 2 in Video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 2 in Video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 2 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION3 Register bits
    namespace b_roi_region3_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 3 in Video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 3 in Video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 3 in video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 3 in video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 3 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION4 Register bits
    namespace b_roi_region4_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 4 in Video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 4 in Video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 4 in video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 4 in video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 4 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION5 Register bits
    namespace b_roi_region5_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontial start macroblocks of region 5 video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 5 video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 5 video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 5 in video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 5 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION6 Register bits
    namespace b_roi_region6_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontial start macroblocks of region 6 video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 6 in video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 6 in video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 6 in video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 6 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION7 Register bits
    namespace b_roi_region7_bits {
        constexpr uint32_t X = (7 << 0);  ///< Configures the horizontal start macroblocks of region 7 in video B.
        constexpr uint32_t Y = (7 << 7);  ///< Configures the vertical start macroblocks of region 7 in video B.
        constexpr uint32_t X_LEN = (7 << 14);  ///< Configures the number of macroblocks in horizontal direction of the region 7 in video B.
        constexpr uint32_t Y_LEN = (7 << 21);  ///< Configures the number of macroblocks in vertical direction of the region 7 in video B.
        constexpr uint32_t EN = (1U << 28);  ///< Configures whether or not to open Video B ROI of region 7 .\\0:Close ROI\\1:Open ROI.
    }

    /// B_ROI_REGION0_3_QP Register bits
    namespace b_roi_region0_3_qp_bits {
        constexpr uint32_t B_ROI_REGION0_QP = (7 << 0);  ///< Configure H264 ROI region0 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION1_QP = (7 << 7);  ///< Configure H264 ROI region1 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION2_QP = (7 << 14);  ///< Configure H264 ROI region2 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION3_QP = (7 << 21);  ///< Configure H264 ROI region3 qp in video B,fixed qp or delta qp.
    }

    /// B_ROI_REGION4_7_QP Register bits
    namespace b_roi_region4_7_qp_bits {
        constexpr uint32_t B_ROI_REGION4_QP = (7 << 0);  ///< Configure H264 ROI region4 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION5_QP = (7 << 7);  ///< Configure H264 ROI region5 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION6_QP = (7 << 14);  ///< Configure H264 ROI region6 qp in video B,fixed qp or delta qp.
        constexpr uint32_t B_ROI_REGION7_QP = (7 << 21);  ///< Configure H264 ROI region7 qp in video B,fixed qp or delta qp.
    }

    /// B_NO_ROI_REGION_QP_OFFSET Register bits
    namespace b_no_roi_region_qp_offset_bits {
        constexpr uint32_t B_NO_ROI_REGION_QP = (7 << 0);  ///< Configure H264 no region qp in video B, delta qp.
    }

    /// B_ROI_CONFIG Register bits
    namespace b_roi_config_bits {
        constexpr uint32_t B_ROI_EN = (1U << 0);  ///< Configure whether or not to enable ROI in video B.\\0:not enable ROI\\1:enable ROI.
        constexpr uint32_t B_ROI_MODE = (1U << 1);  ///< Configure the mode of ROI in video B.\\0:fixed qp\\1:delta qp.
    }

    /// RC_STATUS0 Register bits
    namespace rc_status0_bits {
        constexpr uint32_t FRAME_MAD_SUM = (21 << 0);  ///< Represents all MB actual MAD sum value of one frame.
    }

    /// RC_STATUS1 Register bits
    namespace rc_status1_bits {
        constexpr uint32_t FRAME_ENC_BITS = (27 << 0);  ///< Represents all MB actual encoding bits sum value of one frame.
    }

    /// RC_STATUS2 Register bits
    namespace rc_status2_bits {
        constexpr uint32_t FRAME_QP_SUM = (19 << 0);  ///< Represents all MB actual luma QP sum value of one frame.
    }

    /// SLICE_HEADER_REMAIN Register bits
    namespace slice_header_remain_bits {
        constexpr uint32_t SLICE_REMAIN_BITLENGTH = (3 << 0);  ///< Configures Slice Header remain bit number
        constexpr uint32_t SLICE_REMAIN_BIT = (8 << 3);  ///< Configures Slice Header remain bit
    }

    /// SLICE_HEADER_BYTE_LENGTH Register bits
    namespace slice_header_byte_length_bits {
        constexpr uint32_t SLICE_BYTE_LENGTH = (4 << 0);  ///< Configures Slice Header byte number
    }

    /// BS_THRESHOLD Register bits
    namespace bs_threshold_bits {
        constexpr uint32_t BS_BUFFER_THRESHOLD = (7 << 0);  ///< Configures bitstream buffer overflow threshold. This value should be bigger than the encode bytes of one 4x4 submb.
    }

    /// SLICE_HEADER_BYTE0 Register bits
    namespace slice_header_byte0_bits {
        constexpr uint32_t SLICE_BYTE_LSB = (32 << 0);  ///< Configures Slice Header low 32 bit
    }

    /// SLICE_HEADER_BYTE1 Register bits
    namespace slice_header_byte1_bits {
        constexpr uint32_t SLICE_BYTE_MSB = (32 << 0);  ///< Configures Slice Header high 32 bit
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t DB_TMP_READY_INT_RAW = (1U << 0);  ///< Raw status bit: The raw interrupt status of H264_DB_TMP_READY_INT. Triggered when H264 written enough db tmp pixel.
        constexpr uint32_t REC_READY_INT_RAW = (1U << 1);  ///< Raw status bit: The raw interrupt status of H264_REC_READY_INT. Triggered when H264 encoding enough reconstruct pixel.
        constexpr uint32_t FRAME_DONE_INT_RAW = (1U << 2);  ///< Raw status bit: The raw interrupt status of H264_FRAME_DONE_INT. Triggered when H264 encoding one frame done.
        constexpr uint32_t DMA_MOVE_2MB_LINE_DONE_INT_RAW = (1U << 3);  ///< Raw status bit: The raw interrupt status of H264_DMA_MOVE_2MB_LINE_DONE_INT. Triggered when H264 move two MB lines of reference frame from external mem to internal mem done.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t DB_TMP_READY_INT_ST = (1U << 0);  ///< The masked interrupt status of H264_DB_TMP_READY_INT. Valid only when the H264_DB_TMP_READY_INT_ENA is set to 1.
        constexpr uint32_t REC_READY_INT_ST = (1U << 1);  ///< The masked interrupt status of H264_REC_READY_INT. Valid only when the H264_REC_READY_INT_ENA is set to 1.
        constexpr uint32_t FRAME_DONE_INT_ST = (1U << 2);  ///< The masked interrupt status of H264_FRAME_DONE_INT. Valid only when the H264_FRAME_DONE_INT_ENA is set to 1.
        constexpr uint32_t DMA_MOVE_2MB_LINE_DONE_INT_ST = (1U << 3);  ///< Masked status bit: The masked interrupt status of H264_DMA_MOVE_2MB_LINE_DONE_INT. Valid only when the H264_DMA_MOVE_2MB_LINE_DONE_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t DB_TMP_READY_INT_ENA = (1U << 0);  ///< Write 1 to enable H264_DB_TMP_READY_INT.
        constexpr uint32_t REC_READY_INT_ENA = (1U << 1);  ///< Write 1 to enable H264_REC_READY_INT.
        constexpr uint32_t FRAME_DONE_INT_ENA = (1U << 2);  ///< Write 1 to enable H264_FRAME_DONE_INT.
        constexpr uint32_t DMA_MOVE_2MB_LINE_DONE_INT_ENA = (1U << 3);  ///< Enable bit: Write 1 to enable H264_DMA_MOVE_2MB_LINE_DONE_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t DB_TMP_READY_INT_CLR = (1U << 0);  ///< Write 1 to clear H264_DB_TMP_READY_INT.
        constexpr uint32_t REC_READY_INT_CLR = (1U << 1);  ///< Write 1 to clear H264_REC_READY_INT.
        constexpr uint32_t FRAME_DONE_INT_CLR = (1U << 2);  ///< Write 1 to clear H264_FRAME_DONE_INT.
        constexpr uint32_t DMA_MOVE_2MB_LINE_DONE_INT_CLR = (1U << 3);  ///< Clear bit: Write 1 to clear H264_DMA_MOVE_2MB_LINE_DONE_INT.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Configures whether or not to open register clock gate.\\0: Open the clock gate only when application writes registers\\1: Force open the clock gate for register
        constexpr uint32_t REC_RAM_CLK_EN2 = (1U << 1);  ///< Configures whether or not to open the clock gate for rec ram2.\\0: Open the clock gate only when application writes or reads rec ram2\\1: Force open the clock gate for rec ram2
        constexpr uint32_t REC_RAM_CLK_EN1 = (1U << 2);  ///< Configures whether or not to open the clock gate for rec ram1.\\0: Open the clock gate only when application writes or reads rec ram1\\1: Force open the clock gate for rec ram1
        constexpr uint32_t QUANT_RAM_CLK_EN2 = (1U << 3);  ///< Configures whether or not to open the clock gate for quant ram2.\\0: Open the clock gate only when application writes or reads quant ram2\\1: Force open the clock gate for quant ram2
        constexpr uint32_t QUANT_RAM_CLK_EN1 = (1U << 4);  ///< Configures whether or not to open the clock gate for quant ram1.\\0: Open the clock gate only when application writes or reads quant ram1\\1: Force open the clock gate for quant ram1
        constexpr uint32_t PRE_RAM_CLK_EN = (1U << 5);  ///< Configures whether or not to open the clock gate for pre ram.\\0: Open the clock gate only when application writes or reads pre ram\\1: Force open the clock gate for pre ram
        constexpr uint32_t MVD_RAM_CLK_EN = (1U << 6);  ///< Configures whether or not to open the clock gate for mvd ram.\\0: Open the clock gate only when application writes or reads mvd ram\\1: Force open the clock gate for mvd ram
        constexpr uint32_t MC_RAM_CLK_EN = (1U << 7);  ///< Configures whether or not to open the clock gate for mc ram.\\0: Open the clock gate only when application writes or reads mc ram\\1: Force open the clock gate for mc ram
        constexpr uint32_t REF_RAM_CLK_EN = (1U << 8);  ///< Configures whether or not to open the clock gate for ref ram.\\0: Open the clock gate only when application writes or reads ref ram\\1: Force open the clock gate for ref ram
        constexpr uint32_t I4X4_REF_RAM_CLK_EN = (1U << 9);  ///< Configures whether or not to open the clock gate for i4x4_mode ram.\\0: Open the clock gate only when application writes or reads i4x4_mode ram\\1: Force open the clock gate for i4x4_mode ram
        constexpr uint32_t IME_RAM_CLK_EN = (1U << 10);  ///< Configures whether or not to open the clock gate for ime ram.\\0: Open the clock gate only when application writes or reads ime ram\\1: Force open the clock gate for ime ram
        constexpr uint32_t FME_RAM_CLK_EN = (1U << 11);  ///< Configures whether or not to open the clock gate for fme ram.\\0: Open the clock gate only when application writes or readsfme ram\\1: Force open the clock gate for fme ram
        constexpr uint32_t FETCH_RAM_CLK_EN = (1U << 12);  ///< Configures whether or not to open the clock gate for fetch ram.\\0: Open the clock gate only when application writes or reads fetch ram\\1: Force open the clock gate for fetch ram
        constexpr uint32_t DB_RAM_CLK_EN = (1U << 13);  ///< Configures whether or not to open the clock gate for db ram.\\0: Open the clock gate only when application writes or reads db ram\\1: Force open the clock gate for db ram
        constexpr uint32_t CUR_MB_RAM_CLK_EN = (1U << 14);  ///< Configures whether or not to open the clock gate for cur_mb ram.\\0: Open the clock gate only when application writes or reads cur_mb ram\\1: Force open the clock gate for cur_mb ram
        constexpr uint32_t CAVLC_RAM_CLK_EN = (1U << 15);  ///< Configures whether or not to open the clock gate for cavlc ram.\\0: Open the clock gate only when application writes or reads cavlc ram\\1: Force open the clock gate for cavlc ram
        constexpr uint32_t IME_CLK_EN = (1U << 16);  ///< Configures whether or not to open the clock gate for ime.\\0: Open the clock gate only when ime work\\1: Force open the clock gate for ime
        constexpr uint32_t FME_CLK_EN = (1U << 17);  ///< Configures whether or not to open the clock gate for fme.\\0: Open the clock gate only when fme work\\1: Force open the clock gate for fme
        constexpr uint32_t MC_CLK_EN = (1U << 18);  ///< Configures whether or not to open the clock gate for mc.\\0: Open the clock gate only when mc work\\1: Force open the clock gate for mc
        constexpr uint32_t INTERPOLATOR_CLK_EN = (1U << 19);  ///< Configures whether or not to open the clock gate for interpolator.\\0: Open the clock gate only when interpolator work\\1: Force open the clock gate for interpolator
        constexpr uint32_t DB_CLK_EN = (1U << 20);  ///< Configures whether or not to open the clock gate for deblocking filter.\\0: Open the clock gate only when deblocking filter work\\1: Force open the clock gate for deblocking filter
        constexpr uint32_t CLAVLC_CLK_EN = (1U << 21);  ///< Configures whether or not to open the clock gate for cavlc.\\0: Open the clock gate only when cavlc work\\1: Force open the clock gate for cavlc
        constexpr uint32_t INTRA_CLK_EN = (1U << 22);  ///< Configures whether or not to open the clock gate for intra.\\0: Open the clock gate only when intra work\\1: Force open the clock gate for intra
        constexpr uint32_t DECI_CLK_EN = (1U << 23);  ///< Configures whether or not to open the clock gate for decimate.\\0: Open the clock gate only when decimate work\\1: Force open the clock gate for decimate
        constexpr uint32_t BS_CLK_EN = (1U << 24);  ///< Configures whether or not to open the clock gate for bs buffer.\\0: Open the clock gate only when bs buffer work\\1: Force open the clock gate for bs buffer
        constexpr uint32_t MV_MERGE_CLK_EN = (1U << 25);  ///< Configures whether or not to open the clock gate for mv merge.\\0: Open the clock gate only when mv merge work\\1: Force open the clock gate for mv merge
    }

    /// MV_MERGE_CONFIG Register bits
    namespace mv_merge_config_bits {
        constexpr uint32_t MV_MERGE_TYPE = (2 << 0);  ///< Configure mv merge type.\\0: merge p16x16 mv\\1: merge min mv\\2: merge max mv\\3: not valid.
        constexpr uint32_t INT_MV_OUT_EN = (1U << 2);  ///< Configure mv merge output integer part not zero mv or all part not zero mv.\\0: output all part not zero mv\\1: output integer part not zero mv.
        constexpr uint32_t A_MV_MERGE_EN = (1U << 3);  ///< Configure whether or not to enable video A mv merge.\\0: disable\\1: enable.
        constexpr uint32_t B_MV_MERGE_EN = (1U << 4);  ///< Configure whether or not to enable video B mv merge.\\0: disable\\1: enable.
        constexpr uint32_t MB_VALID_NUM = (13 << 5);  ///< Represents the valid mb number of mv merge output.
    }

    /// DEBUG_DMA_SEL Register bits
    namespace debug_dma_sel_bits {
        constexpr uint32_t DBG_DMA_SEL = (8 << 0);  ///< Every bit represents a dma in h264
    }

    /// SYS_STATUS Register bits
    namespace sys_status_bits {
        constexpr uint32_t FRAME_NUM = (9 << 0);  ///< Represents current frame number.
        constexpr uint32_t DUAL_STREAM_SEL = (1U << 9);  ///< Represents which register group is used for cur frame.\\0: Register group A is used\\1: Register group B is used.
        constexpr uint32_t INTRA_FLAG = (1U << 10);  ///< Represents the type of current encoding frame.\\0: P frame\\1: I frame.
    }

    /// FRAME_CODE_LENGTH Register bits
    namespace frame_code_length_bits {
        constexpr uint32_t FRAME_CODE_LENGTH = (24 << 0);  ///< Represents current frame code byte length.
    }

    /// DEBUG_INFO0 Register bits
    namespace debug_info0_bits {
        constexpr uint32_t TOP_CTRL_INTER_DEBUG_STATE = (4 << 0);  ///< Represents top_ctrl_inter module FSM info.
        constexpr uint32_t TOP_CTRL_INTRA_DEBUG_STATE = (3 << 4);  ///< Represents top_ctrl_intra module FSM info.
        constexpr uint32_t P_I_CMP_DEBUG_STATE = (3 << 7);  ///< Represents p_i_cmp module FSM info.
        constexpr uint32_t MVD_DEBUG_STATE = (3 << 10);  ///< Represents mvd module FSM info.
        constexpr uint32_t MC_CHROMA_IP_DEBUG_STATE = (1U << 13);  ///< Represents mc_chroma_ip module FSM info.
        constexpr uint32_t INTRA_16X16_CHROMA_CTRL_DEBUG_STATE = (4 << 14);  ///< Represents intra_16x16_chroma_ctrl module FSM info.
        constexpr uint32_t INTRA_4X4_CTRL_DEBUG_STATE = (4 << 18);  ///< Represents intra_4x4_ctrl module FSM info.
        constexpr uint32_t INTRA_TOP_CTRL_DEBUG_STATE = (3 << 22);  ///< Represents intra_top_ctrl module FSM info.
        constexpr uint32_t IME_CTRL_DEBUG_STATE = (3 << 25);  ///< Represents ime_ctrl module FSM info.
    }

    /// DEBUG_INFO1 Register bits
    namespace debug_info1_bits {
        constexpr uint32_t FME_CTRL_DEBUG_STATE = (3 << 0);  ///< Represents fme_ctrl module FSM info.
        constexpr uint32_t DECI_CALC_DEBUG_STATE = (2 << 3);  ///< Represents deci_calc module's FSM info. DEV use only.
        constexpr uint32_t DB_DEBUG_STATE = (3 << 5);  ///< Represents db module FSM info.
        constexpr uint32_t CAVLC_ENC_DEBUG_STATE = (4 << 8);  ///< Represents cavlc module enc FSM info.
        constexpr uint32_t CAVLC_SCAN_DEBUG_STATE = (4 << 12);  ///< Represents cavlc module scan FSM info.
        constexpr uint32_t CAVLC_CTRL_DEBUG_STATE = (2 << 16);  ///< Represents cavlc module ctrl FSM info.
        constexpr uint32_t BS_BUFFER_DEBUG_STATE = (1U << 18);  ///< Represents bs buffer overflow info.
    }

    /// DEBUG_INFO2 Register bits
    namespace debug_info2_bits {
        constexpr uint32_t P_RC_DONE_DEBUG_FLAG = (1U << 0);  ///< Represents p rate ctrl done status.\\0: not done\\1: done.
        constexpr uint32_t P_P_I_CMP_DONE_DEBUG_FLAG = (1U << 1);  ///< Represents p p_i_cmp done status.\\0: not done\\1: done.
        constexpr uint32_t P_MV_MERGE_DONE_DEBUG_FLAG = (1U << 2);  ///< Represents p mv merge done status.\\0: not done\\1: done.
        constexpr uint32_t P_MOVE_ORI_DONE_DEBUG_FLAG = (1U << 3);  ///< Represents p move origin done status.\\0: not done\\1: done.
        constexpr uint32_t P_MC_DONE_DEBUG_FLAG = (1U << 4);  ///< Represents p mc done status.\\0: not done\\1: done.
        constexpr uint32_t P_IME_DONE_DEBUG_FLAG = (1U << 5);  ///< Represents p ime done status.\\0: not done\\1: done.
        constexpr uint32_t P_GET_ORI_DONE_DEBUG_FLAG = (1U << 6);  ///< Represents p get origin done status.\\0: not done\\1: done.
        constexpr uint32_t P_FME_DONE_DEBUG_FLAG = (1U << 7);  ///< Represents p fme done status.\\0: not done\\1: done.
        constexpr uint32_t P_FETCH_DONE_DEBUG_FLAG = (1U << 8);  ///< Represents p fetch done status.\\0: not done\\1: done.
        constexpr uint32_t P_DB_DONE_DEBUG_FLAG = (1U << 9);  ///< Represents p deblocking done status.\\0: not done\\1: done.
        constexpr uint32_t P_BS_BUF_DONE_DEBUG_FLAG = (1U << 10);  ///< Represents p bitstream buffer done status.\\0: not done\\1: done.
        constexpr uint32_t REF_MOVE_2MB_LINE_DONE_DEBUG_FLAG = (1U << 11);  ///< Represents dma move 2 ref mb line done status.\\0: not done\\1: done.
        constexpr uint32_t I_P_I_CMP_DONE_DEBUG_FLAG = (1U << 12);  ///< Represents I p_i_cmp done status.\\0: not done\\1: done.
        constexpr uint32_t I_MOVE_ORI_DONE_DEBUG_FLAG = (1U << 13);  ///< Represents I move origin done status.\\0: not done\\1: done.
        constexpr uint32_t I_GET_ORI_DONE_DEBUG_FLAG = (1U << 14);  ///< Represents I get origin done status.\\0: not done\\1: done.
        constexpr uint32_t I_EC_DONE_DEBUG_FLAG = (1U << 15);  ///< Represents I encoder done status.\\0: not done\\1: done.
        constexpr uint32_t I_DB_DONE_DEBUG_FLAG = (1U << 16);  ///< Represents I deblocking done status.\\0: not done\\1: done.
        constexpr uint32_t I_BS_BUF_DONE_DEBUG_FLAG = (1U << 17);  ///< Represents I bitstream buffer done status.\\0: not done\\1: done.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LEDC_DATE = (28 << 0);  ///< Configures the version.
    }

}

// ============================================================================
// HP Peripheral
// ============================================================================

namespace hp {
    /// Base addresses
    constexpr uint32_t HP_SYS_BASE = 0x500E5000;
    constexpr uint32_t HP_SYS_CLKRST_BASE = 0x500E6000;

    /// HP Register structure
    struct Registers {
        volatile uint32_t VER_DATE;  ///< Offset: 0x00 - NA
        volatile uint32_t CLK_EN;  ///< Offset: 0x04 - NA
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x10 - NA
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x14 - NA
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x18 - NA
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x1C - NA
        volatile uint32_t CACHE_CLK_CONFIG;  ///< Offset: 0x20 - NA
        volatile uint32_t CACHE_RESET_CONFIG;  ///< Offset: 0x24 - NA
        volatile uint32_t DMA_ADDR_CTRL;  ///< Offset: 0x2C - NA
        volatile uint32_t TCM_RAM_WRR_CONFIG;  ///< Offset: 0x34 - NA
        volatile uint32_t TCM_SW_PARITY_BWE_MASK;  ///< Offset: 0x38 - NA
        volatile uint32_t TCM_RAM_PWR_CTRL0;  ///< Offset: 0x3C - NA
        volatile uint32_t L2_ROM_PWR_CTRL0;  ///< Offset: 0x40 - NA
        volatile uint32_t PROBEA_CTRL;  ///< Offset: 0x50 - NA
        volatile uint32_t PROBEB_CTRL;  ///< Offset: 0x54 - NA
        volatile uint32_t PROBE_OUT;  ///< Offset: 0x5C - NA
        volatile uint32_t L2_MEM_RAM_PWR_CTRL0;  ///< Offset: 0x60 - NA
        volatile uint32_t CPU_CORESTALLED_ST;  ///< Offset: 0x64 - NA
        volatile uint32_t CRYPTO_CTRL;  ///< Offset: 0x70 - NA
        volatile uint32_t GPIO_O_HOLD_CTRL0;  ///< Offset: 0x74 - NA
        volatile uint32_t GPIO_O_HOLD_CTRL1;  ///< Offset: 0x78 - NA
        volatile uint32_t RDN_ECO_CS;  ///< Offset: 0x7C - NA
        volatile uint32_t CACHE_APB_POSTW_EN;  ///< Offset: 0x80 - NA
        volatile uint32_t L2_MEM_SUBSIZE;  ///< Offset: 0x84 - NA
        volatile uint32_t L2_MEM_INT_RAW;  ///< Offset: 0x9C - NA
        volatile uint32_t L2_MEM_INT_ST;  ///< Offset: 0xA0 - NA
        volatile uint32_t L2_MEM_INT_ENA;  ///< Offset: 0xA4 - NA
        volatile uint32_t L2_MEM_INT_CLR;  ///< Offset: 0xA8 - NA
        volatile uint32_t L2_MEM_L2_RAM_ECC;  ///< Offset: 0xAC - NA
        volatile uint32_t L2_MEM_INT_RECORD0;  ///< Offset: 0xB0 - NA
        volatile uint32_t L2_MEM_INT_RECORD1;  ///< Offset: 0xB4 - NA
        volatile uint32_t L2_MEM_L2_CACHE_ECC;  ///< Offset: 0xC4 - NA
        volatile uint32_t L1CACHE_BUS0_ID;  ///< Offset: 0xC8 - NA
        volatile uint32_t L1CACHE_BUS1_ID;  ///< Offset: 0xCC - NA
        volatile uint32_t L2_MEM_RDN_ECO_CS;  ///< Offset: 0xD8 - NA
        volatile uint32_t L2_MEM_RDN_ECO_LOW;  ///< Offset: 0xDC - NA
        volatile uint32_t L2_MEM_RDN_ECO_HIGH;  ///< Offset: 0xE0 - NA
        volatile uint32_t TCM_RDN_ECO_CS;  ///< Offset: 0xE4 - NA
        volatile uint32_t TCM_RDN_ECO_LOW;  ///< Offset: 0xE8 - NA
        volatile uint32_t TCM_RDN_ECO_HIGH;  ///< Offset: 0xEC - NA
        volatile uint32_t GPIO_DED_HOLD_CTRL;  ///< Offset: 0xF0 - NA
        volatile uint32_t L2_MEM_SW_ECC_BWE_MASK;  ///< Offset: 0xF4 - NA
        volatile uint32_t USB20OTG_MEM_CTRL;  ///< Offset: 0xF8 - NA
        volatile uint32_t TCM_INT_RAW;  ///< Offset: 0xFC - need_des
        volatile uint32_t TCM_INT_ST;  ///< Offset: 0x100 - need_des
        volatile uint32_t TCM_INT_ENA;  ///< Offset: 0x104 - need_des
        volatile uint32_t TCM_INT_CLR;  ///< Offset: 0x108 - need_des
        volatile uint32_t TCM_PARITY_INT_RECORD;  ///< Offset: 0x10C - need_des
        volatile uint32_t L1_CACHE_PWR_CTRL;  ///< Offset: 0x110 - NA
        volatile uint32_t L2_CACHE_PWR_CTRL;  ///< Offset: 0x114 - NA
        volatile uint32_t CPU_WAITI_CONF;  ///< Offset: 0x118 - CPU_WAITI configuration register
        volatile uint32_t CORE_DEBUG_RUNSTALL_CONF;  ///< Offset: 0x11C - Core Debug runstall configure register
        volatile uint32_t CORE_AHB_TIMEOUT;  ///< Offset: 0x120 - need_des
        volatile uint32_t CORE_IBUS_TIMEOUT;  ///< Offset: 0x124 - need_des
        volatile uint32_t CORE_DBUS_TIMEOUT;  ///< Offset: 0x128 - need_des
        volatile uint32_t ICM_CPU_H2X_CFG;  ///< Offset: 0x138 - need_des
        volatile uint32_t PERI1_APB_POSTW_EN;  ///< Offset: 0x13C - NA
        volatile uint32_t BITSCRAMBLER_PERI_SEL;  ///< Offset: 0x140 - Bitscrambler Peri Sel
        volatile uint32_t APB_SYNC_POSTW_EN;  ///< Offset: 0x144 - N/A
        volatile uint32_t GDMA_CTRL;  ///< Offset: 0x148 - N/A
        volatile uint32_t GMAC_CTRL0;  ///< Offset: 0x14C - N/A
        volatile uint32_t GMAC_CTRL1;  ///< Offset: 0x150 - N/A
        volatile uint32_t GMAC_CTRL2;  ///< Offset: 0x154 - N/A
        volatile uint32_t VPU_CTRL;  ///< Offset: 0x158 - N/A
        volatile uint32_t USBOTG20_CTRL;  ///< Offset: 0x15C - N/A
        volatile uint32_t TCM_ERR_RESP_CTRL;  ///< Offset: 0x160 - need_des
        volatile uint32_t L2_MEM_REFRESH;  ///< Offset: 0x164 - NA
        volatile uint32_t TCM_INIT;  ///< Offset: 0x168 - NA
        volatile uint32_t TCM_PARITY_CHECK_CTRL;  ///< Offset: 0x16C - need_des
        volatile uint32_t DESIGN_FOR_VERIFICATION0;  ///< Offset: 0x170 - need_des
        volatile uint32_t DESIGN_FOR_VERIFICATION1;  ///< Offset: 0x174 - need_des
        volatile uint32_t PSRAM_FLASH_ADDR_INTERCHANGE;  ///< Offset: 0x180 - need_des
        volatile uint32_t AHB2AXI_BRESP_ERR_INT_RAW;  ///< Offset: 0x188 - NA
        volatile uint32_t AHB2AXI_BRESP_ERR_INT_ST;  ///< Offset: 0x18C - need_des
        volatile uint32_t AHB2AXI_BRESP_ERR_INT_ENA;  ///< Offset: 0x190 - need_des
        volatile uint32_t AHB2AXI_BRESP_ERR_INT_CLR;  ///< Offset: 0x194 - need_des
        volatile uint32_t L2_MEM_ERR_RESP_CTRL;  ///< Offset: 0x198 - need_des
        volatile uint32_t L2_MEM_AHB_BUFFER_CTRL;  ///< Offset: 0x19C - need_des
        volatile uint32_t CORE_DMACTIVE_LPCORE;  ///< Offset: 0x1A0 - need_des
        volatile uint32_t CORE_ERR_RESP_DIS;  ///< Offset: 0x1A4 - need_des
        volatile uint32_t CORE_TIMEOUT_INT_RAW;  ///< Offset: 0x1A8 - Hp core bus timeout interrupt raw register
        volatile uint32_t CORE_TIMEOUT_INT_ST;  ///< Offset: 0x1AC - masked interrupt register
        volatile uint32_t CORE_TIMEOUT_INT_ENA;  ///< Offset: 0x1B0 - masked interrupt register
        volatile uint32_t CORE_TIMEOUT_INT_CLR;  ///< Offset: 0x1B4 - interrupt clear register
        volatile uint32_t GPIO_O_HYS_CTRL0;  ///< Offset: 0x1C0 - NA
        volatile uint32_t GPIO_O_HYS_CTRL1;  ///< Offset: 0x1C4 - NA
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x1D0 - rsa pd ctrl register
        volatile uint32_t ECC_PD_CTRL;  ///< Offset: 0x1D4 - ecc pd ctrl register
        volatile uint32_t RNG_CFG;  ///< Offset: 0x1D8 - rng cfg register
        volatile uint32_t UART_PD_CTRL;  ///< Offset: 0x1DC - ecc pd ctrl register
        volatile uint32_t PERI_MEM_CLK_FORCE_ON;  ///< Offset: 0x1E0 - hp peri mem clk force on regpster
    };

    /// Peripheral instances
    inline Registers* HP_SYS = reinterpret_cast<Registers*>(HP_SYS_BASE);
    inline Registers* HP_SYS_CLKRST = reinterpret_cast<Registers*>(HP_SYS_CLKRST_BASE);

    // Bit definitions
    /// VER_DATE Register bits
    namespace ver_date_bits {
        constexpr uint32_t REG_VER_DATE = (32 << 0);  ///< NA
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< NA
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< set 1 will triger a interrupt
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< set 1 will triger a interrupt
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< set 1 will triger a interrupt
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< set 1 will triger a interrupt
    }

    /// CACHE_CLK_CONFIG Register bits
    namespace cache_clk_config_bits {
        constexpr uint32_t REG_L2_CACHE_CLK_ON = (1U << 0);  ///< l2 cahce clk enable
        constexpr uint32_t REG_L1_D_CACHE_CLK_ON = (1U << 1);  ///< l1 dcahce clk enable
        constexpr uint32_t REG_L1_I1_CACHE_CLK_ON = (1U << 4);  ///< l1 icahce1 clk enable
        constexpr uint32_t REG_L1_I0_CACHE_CLK_ON = (1U << 5);  ///< l1 icahce0 clk enable
    }

    /// CACHE_RESET_CONFIG Register bits
    namespace cache_reset_config_bits {
        constexpr uint32_t REG_L1_D_CACHE_RESET = (1U << 1);  ///< set 1 to reset l1 dcahce
        constexpr uint32_t REG_L1_I1_CACHE_RESET = (1U << 4);  ///< set 1 to reset l1 icahce1
        constexpr uint32_t REG_L1_I0_CACHE_RESET = (1U << 5);  ///< set 1 to reset l1 icahce0
    }

    /// DMA_ADDR_CTRL Register bits
    namespace dma_addr_ctrl_bits {
        constexpr uint32_t REG_SYS_DMA_ADDR_SEL = (1U << 0);  ///< 0 means dma access extmem use 8xxx_xxxx else use 4xxx_xxxx
    }

    /// TCM_RAM_WRR_CONFIG Register bits
    namespace tcm_ram_wrr_config_bits {
        constexpr uint32_t REG_TCM_RAM_IBUS0_WT = (3 << 0);  ///< weight value of ibus0
        constexpr uint32_t REG_TCM_RAM_IBUS1_WT = (3 << 3);  ///< weight value of ibus1
        constexpr uint32_t REG_TCM_RAM_IBUS2_WT = (3 << 6);  ///< weight value of ibus2
        constexpr uint32_t REG_TCM_RAM_IBUS3_WT = (3 << 9);  ///< weight value of ibus3
        constexpr uint32_t REG_TCM_RAM_DBUS0_WT = (3 << 12);  ///< weight value of dbus0
        constexpr uint32_t REG_TCM_RAM_DBUS1_WT = (3 << 15);  ///< weight value of dbus1
        constexpr uint32_t REG_TCM_RAM_DBUS2_WT = (3 << 18);  ///< weight value of dbus2
        constexpr uint32_t REG_TCM_RAM_DBUS3_WT = (3 << 21);  ///< weight value of dbus3
        constexpr uint32_t REG_TCM_RAM_DMA_WT = (3 << 24);  ///< weight value of dma
        constexpr uint32_t REG_TCM_RAM_WRR_HIGH = (1U << 31);  ///< enable weighted round robin arbitration
    }

    /// TCM_SW_PARITY_BWE_MASK Register bits
    namespace tcm_sw_parity_bwe_mask_bits {
        constexpr uint32_t REG_TCM_SW_PARITY_BWE_MASK_CTRL = (1U << 0);  ///< Set 1 to mask tcm bwe parity code bit
    }

    /// TCM_RAM_PWR_CTRL0 Register bits
    namespace tcm_ram_pwr_ctrl0_bits {
        constexpr uint32_t REG_HP_TCM_CLK_FORCE_ON = (1U << 0);  ///< hp_tcm clk gatig force on
    }

    /// L2_ROM_PWR_CTRL0 Register bits
    namespace l2_rom_pwr_ctrl0_bits {
        constexpr uint32_t REG_L2_ROM_CLK_FORCE_ON = (1U << 0);  ///< l2_rom clk gating force on
    }

    /// PROBEA_CTRL Register bits
    namespace probea_ctrl_bits {
        constexpr uint32_t REG_PROBE_A_MOD_SEL = (16 << 0);  ///< Tihs field is used to selec probe_group from probe_group0 to probe_group15 for module's probe_out[31:0] in a mode
        constexpr uint32_t REG_PROBE_A_TOP_SEL = (8 << 16);  ///< Tihs field is used to selec module's probe_out[31:0] as probe out in a mode
        constexpr uint32_t REG_PROBE_L_SEL = (2 << 24);  ///< Tihs field is used to selec probe_out[31:16]
        constexpr uint32_t REG_PROBE_H_SEL = (2 << 26);  ///< Tihs field is used to selec probe_out[31:16]
        constexpr uint32_t REG_PROBE_GLOBAL_EN = (1U << 28);  ///< Set this bit to enable global debug probe in hp system.
    }

    /// PROBEB_CTRL Register bits
    namespace probeb_ctrl_bits {
        constexpr uint32_t REG_PROBE_B_MOD_SEL = (16 << 0);  ///< Tihs field is used to selec probe_group from probe_group0 to probe_group15 for module's probe_out[31:0] in b mode.
        constexpr uint32_t REG_PROBE_B_TOP_SEL = (8 << 16);  ///< Tihs field is used to select module's probe_out[31:0] as probe_out in b mode
        constexpr uint32_t REG_PROBE_B_EN = (1U << 24);  ///< Set this bit to enable b mode for debug probe. 1: b mode, 0: a mode.
    }

    /// PROBE_OUT Register bits
    namespace probe_out_bits {
        constexpr uint32_t REG_PROBE_TOP_OUT = (32 << 0);  ///< NA
    }

    /// L2_MEM_RAM_PWR_CTRL0 Register bits
    namespace l2_mem_ram_pwr_ctrl0_bits {
        constexpr uint32_t REG_L2_MEM_CLK_FORCE_ON = (1U << 0);  ///< l2ram clk_gating force on
    }

    /// CPU_CORESTALLED_ST Register bits
    namespace cpu_corestalled_st_bits {
        constexpr uint32_t REG_CORE0_CORESTALLED_ST = (1U << 0);  ///< hp core0 corestalled status
        constexpr uint32_t REG_CORE1_CORESTALLED_ST = (1U << 1);  ///< hp core1 corestalled status
    }

    /// CRYPTO_CTRL Register bits
    namespace crypto_ctrl_bits {
        constexpr uint32_t REG_ENABLE_SPI_MANUAL_ENCRYPT = (1U << 0);  ///< NA
        constexpr uint32_t REG_ENABLE_DOWNLOAD_DB_ENCRYPT = (1U << 1);  ///< NA
        constexpr uint32_t REG_ENABLE_DOWNLOAD_G0CB_DECRYPT = (1U << 2);  ///< NA
        constexpr uint32_t REG_ENABLE_DOWNLOAD_MANUAL_ENCRYPT = (1U << 3);  ///< NA
    }

    /// GPIO_O_HOLD_CTRL0 Register bits
    namespace gpio_o_hold_ctrl0_bits {
        constexpr uint32_t REG_GPIO_0_HOLD_LOW = (32 << 0);  ///< hold control for gpio47~16
    }

    /// GPIO_O_HOLD_CTRL1 Register bits
    namespace gpio_o_hold_ctrl1_bits {
        constexpr uint32_t REG_GPIO_0_HOLD_HIGH = (9 << 0);  ///< hold control for gpio56~48
    }

    /// RDN_ECO_CS Register bits
    namespace rdn_eco_cs_bits {
        constexpr uint32_t REG_HP_SYS_RDN_ECO_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_HP_SYS_RDN_ECO_RESULT = (1U << 1);  ///< NA
    }

    /// CACHE_APB_POSTW_EN Register bits
    namespace cache_apb_postw_en_bits {
        constexpr uint32_t REG_CACHE_APB_POSTW_EN = (1U << 0);  ///< cache apb register interface post write enable, 1 will speed up write, but will take some time to update value to register
    }

    /// L2_MEM_SUBSIZE Register bits
    namespace l2_mem_subsize_bits {
        constexpr uint32_t REG_L2_MEM_SUB_BLKSIZE = (2 << 0);  ///< l2mem sub block size 00=>32 01=>64 10=>128 11=>256
    }

    /// L2_MEM_INT_RAW Register bits
    namespace l2_mem_int_raw_bits {
        constexpr uint32_t REG_L2_MEM_ECC_ERR_INT_RAW = (1U << 0);  ///< intr triggered when two bit error detected and corrected from ecc
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_RAW = (1U << 1);  ///< intr triggered when access addr exceeds 0xff9ffff at bypass mode or exceeds 0xff80000 at l2cache 128kb mode or exceeds 0xff60000 at l2cache 256kb mode
        constexpr uint32_t REG_L2_MEM_ERR_RESP_INT_RAW = (1U << 2);  ///< intr triggered when err response occurs
    }

    /// L2_MEM_INT_ST Register bits
    namespace l2_mem_int_st_bits {
        constexpr uint32_t REG_L2_MEM_ECC_ERR_INT_ST = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_ST = (1U << 1);  ///< NA
        constexpr uint32_t REG_L2_MEM_ERR_RESP_INT_ST = (1U << 2);  ///< NA
    }

    /// L2_MEM_INT_ENA Register bits
    namespace l2_mem_int_ena_bits {
        constexpr uint32_t REG_L2_MEM_ECC_ERR_INT_ENA = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_ENA = (1U << 1);  ///< NA
        constexpr uint32_t REG_L2_MEM_ERR_RESP_INT_ENA = (1U << 2);  ///< NA
    }

    /// L2_MEM_INT_CLR Register bits
    namespace l2_mem_int_clr_bits {
        constexpr uint32_t REG_L2_MEM_ECC_ERR_INT_CLR = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_CLR = (1U << 1);  ///< NA
        constexpr uint32_t REG_L2_MEM_ERR_RESP_INT_CLR = (1U << 2);  ///< NA
    }

    /// L2_MEM_L2_RAM_ECC Register bits
    namespace l2_mem_l2_ram_ecc_bits {
        constexpr uint32_t REG_L2_RAM_UNIT0_ECC_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_RAM_UNIT1_ECC_EN = (1U << 1);  ///< NA
        constexpr uint32_t REG_L2_RAM_UNIT2_ECC_EN = (1U << 2);  ///< NA
        constexpr uint32_t REG_L2_RAM_UNIT3_ECC_EN = (1U << 3);  ///< NA
        constexpr uint32_t REG_L2_RAM_UNIT4_ECC_EN = (1U << 4);  ///< NA
        constexpr uint32_t REG_L2_RAM_UNIT5_ECC_EN = (1U << 5);  ///< NA
    }

    /// L2_MEM_INT_RECORD0 Register bits
    namespace l2_mem_int_record0_bits {
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_ADDR = (21 << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_WE = (1U << 21);  ///< NA
        constexpr uint32_t REG_L2_MEM_EXCEED_ADDR_INT_MASTER = (3 << 22);  ///< NA
    }

    /// L2_MEM_INT_RECORD1 Register bits
    namespace l2_mem_int_record1_bits {
        constexpr uint32_t REG_L2_MEM_ECC_ERR_INT_ADDR = (15 << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_ECC_ONE_BIT_ERR = (1U << 15);  ///< NA
        constexpr uint32_t REG_L2_MEM_ECC_TWO_BIT_ERR = (1U << 16);  ///< NA
        constexpr uint32_t REG_L2_MEM_ECC_ERR_BIT = (9 << 17);  ///< NA
        constexpr uint32_t REG_L2_CACHE_ERR_BANK = (1U << 26);  ///< NA
    }

    /// L2_MEM_L2_CACHE_ECC Register bits
    namespace l2_mem_l2_cache_ecc_bits {
        constexpr uint32_t REG_L2_CACHE_ECC_EN = (1U << 0);  ///< NA
    }

    /// L1CACHE_BUS0_ID Register bits
    namespace l1cache_bus0_id_bits {
        constexpr uint32_t REG_L1_CACHE_BUS0_ID = (4 << 0);  ///< NA
    }

    /// L1CACHE_BUS1_ID Register bits
    namespace l1cache_bus1_id_bits {
        constexpr uint32_t REG_L1_CACHE_BUS1_ID = (4 << 0);  ///< NA
    }

    /// L2_MEM_RDN_ECO_CS Register bits
    namespace l2_mem_rdn_eco_cs_bits {
        constexpr uint32_t REG_L2_MEM_RDN_ECO_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_RDN_ECO_RESULT = (1U << 1);  ///< NA
    }

    /// L2_MEM_RDN_ECO_LOW Register bits
    namespace l2_mem_rdn_eco_low_bits {
        constexpr uint32_t REG_L2_MEM_RDN_ECO_LOW = (32 << 0);  ///< NA
    }

    /// L2_MEM_RDN_ECO_HIGH Register bits
    namespace l2_mem_rdn_eco_high_bits {
        constexpr uint32_t REG_L2_MEM_RDN_ECO_HIGH = (32 << 0);  ///< NA
    }

    /// TCM_RDN_ECO_CS Register bits
    namespace tcm_rdn_eco_cs_bits {
        constexpr uint32_t REG_HP_TCM_RDN_ECO_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_HP_TCM_RDN_ECO_RESULT = (1U << 1);  ///< NA
    }

    /// TCM_RDN_ECO_LOW Register bits
    namespace tcm_rdn_eco_low_bits {
        constexpr uint32_t REG_HP_TCM_RDN_ECO_LOW = (32 << 0);  ///< NA
    }

    /// TCM_RDN_ECO_HIGH Register bits
    namespace tcm_rdn_eco_high_bits {
        constexpr uint32_t REG_HP_TCM_RDN_ECO_HIGH = (32 << 0);  ///< NA
    }

    /// GPIO_DED_HOLD_CTRL Register bits
    namespace gpio_ded_hold_ctrl_bits {
        constexpr uint32_t REG_GPIO_DED_HOLD = (26 << 0);  ///< hold control for gpio63~56
    }

    /// L2_MEM_SW_ECC_BWE_MASK Register bits
    namespace l2_mem_sw_ecc_bwe_mask_bits {
        constexpr uint32_t REG_L2_MEM_SW_ECC_BWE_MASK_CTRL = (1U << 0);  ///< Set 1 to mask bwe hamming code bit
    }

    /// USB20OTG_MEM_CTRL Register bits
    namespace usb20otg_mem_ctrl_bits {
        constexpr uint32_t REG_USB20_MEM_CLK_FORCE_ON = (1U << 0);  ///< NA
    }

    /// TCM_INT_RAW Register bits
    namespace tcm_int_raw_bits {
        constexpr uint32_t TCM_PARITY_ERR_INT_RAW = (1U << 31);  ///< need_des
    }

    /// TCM_INT_ST Register bits
    namespace tcm_int_st_bits {
        constexpr uint32_t TCM_PARITY_ERR_INT_ST = (1U << 31);  ///< need_des
    }

    /// TCM_INT_ENA Register bits
    namespace tcm_int_ena_bits {
        constexpr uint32_t TCM_PARITY_ERR_INT_ENA = (1U << 31);  ///< need_des
    }

    /// TCM_INT_CLR Register bits
    namespace tcm_int_clr_bits {
        constexpr uint32_t TCM_PARITY_ERR_INT_CLR = (1U << 31);  ///< need_des
    }

    /// TCM_PARITY_INT_RECORD Register bits
    namespace tcm_parity_int_record_bits {
        constexpr uint32_t TCM_PARITY_ERR_INT_ADDR = (13 << 0);  ///< hp tcm_parity_err_addr
    }

    /// L1_CACHE_PWR_CTRL Register bits
    namespace l1_cache_pwr_ctrl_bits {
        constexpr uint32_t REG_L1_CACHE_MEM_FO = (6 << 0);  ///< need_des
    }

    /// L2_CACHE_PWR_CTRL Register bits
    namespace l2_cache_pwr_ctrl_bits {
        constexpr uint32_t REG_L2_CACHE_MEM_FO = (2 << 0);  ///< need_des
    }

    /// CPU_WAITI_CONF Register bits
    namespace cpu_waiti_conf_bits {
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 0);  ///< Set 1 to force cpu_waiti_clk enable.
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 1);  ///< This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
    }

    /// CORE_DEBUG_RUNSTALL_CONF Register bits
    namespace core_debug_runstall_conf_bits {
        constexpr uint32_t CORE_DEBUG_RUNSTALL_ENABLE = (1U << 0);  ///< Set this field to 1 to enable debug runstall feature between HP-core and LP-core.
    }

    /// CORE_AHB_TIMEOUT Register bits
    namespace core_ahb_timeout_bits {
        constexpr uint32_t EN = (1U << 0);  ///< set this field to 1 to enable hp core0&1 ahb timeout handle
        constexpr uint32_t THRES = (16 << 1);  ///< This field used to set hp core0&1 ahb bus timeout threshold
    }

    /// CORE_IBUS_TIMEOUT Register bits
    namespace core_ibus_timeout_bits {
        constexpr uint32_t EN = (1U << 0);  ///< set this field to 1 to enable hp core0&1 ibus timeout handle
        constexpr uint32_t THRES = (16 << 1);  ///< This field used to set hp core0&1 ibus timeout threshold
    }

    /// CORE_DBUS_TIMEOUT Register bits
    namespace core_dbus_timeout_bits {
        constexpr uint32_t EN = (1U << 0);  ///< set this field to 1 to enable hp core0&1 dbus timeout handle
        constexpr uint32_t THRES = (16 << 1);  ///< This field used to set hp core0&1 dbus timeout threshold
    }

    /// ICM_CPU_H2X_CFG Register bits
    namespace icm_cpu_h2x_cfg_bits {
        constexpr uint32_t CPU_ICM_H2X_POST_WR_EN = (1U << 0);  ///< need_des
        constexpr uint32_t CPU_ICM_H2X_CUT_THROUGH_EN = (1U << 1);  ///< need_des
        constexpr uint32_t CPU_ICM_H2X_BRIDGE_BUSY = (1U << 2);  ///< need_des
    }

    /// PERI1_APB_POSTW_EN Register bits
    namespace peri1_apb_postw_en_bits {
        constexpr uint32_t PERI1_APB_POSTW_EN = (1U << 0);  ///< hp_peri1 apb register interface post write enable, 1 will speed up write, but will take some time to update value to register
    }

    /// BITSCRAMBLER_PERI_SEL Register bits
    namespace bitscrambler_peri_sel_bits {
        constexpr uint32_t BITSCRAMBLER_PERI_RX_SEL = (4 << 0);  ///< Set this field to sel peri with DMA RX interface to connec with bitscrambler: 4'h0 : lcd_cam, 4'h1: gpspi2, 4'h2: gpspi3, 4'h3: parl_io, 4'h4: aes, 4'h5: sha, 4'h6: adc, 4'h7: i2s0, 4'h8: i2s1, 4'h9: i2s2, 4'ha: i3c_mst, 4'hb: uhci0, 4'hc: RMT, else : none
        constexpr uint32_t BITSCRAMBLER_PERI_TX_SEL = (4 << 4);  ///< Set this field to sel peri with DMA TX interface to connec with bitscrambler: 4'h0 : lcd_cam, 4'h1: gpspi2, 4'h2: gpspi3, 4'h3: parl_io, 4'h4: aes, 4'h5: sha, 4'h6: adc, 4'h7: i2s0, 4'h8: i2s1, 4'h9: i2s2, 4'ha: i3c_mst, 4'hb: uhci0, 4'hc: RMT, else : none
    }

    /// APB_SYNC_POSTW_EN Register bits
    namespace apb_sync_postw_en_bits {
        constexpr uint32_t GMAC_APB_POSTW_EN = (1U << 0);  ///< N/A
        constexpr uint32_t DSI_HOST_APB_POSTW_EN = (1U << 1);  ///< N/A
        constexpr uint32_t CSI_HOST_APB_SYNC_POSTW_EN = (1U << 2);  ///< N/A
        constexpr uint32_t CSI_HOST_APB_ASYNC_POSTW_EN = (1U << 3);  ///< N/A
    }

    /// GDMA_CTRL Register bits
    namespace gdma_ctrl_bits {
        constexpr uint32_t DEBUG_CH_NUM = (2 << 0);  ///< N/A
    }

    /// GMAC_CTRL0 Register bits
    namespace gmac_ctrl0_bits {
        constexpr uint32_t PTP_PPS = (1U << 0);  ///< N/A
        constexpr uint32_t SBD_FLOWCTRL = (1U << 1);  ///< N/A
        constexpr uint32_t PHY_INTF_SEL = (3 << 2);  ///< N/A
        constexpr uint32_t GMAC_MEM_CLK_FORCE_ON = (1U << 5);  ///< N/A
        constexpr uint32_t GMAC_RST_CLK_TX_N = (1U << 6);  ///< N/A
        constexpr uint32_t GMAC_RST_CLK_RX_N = (1U << 7);  ///< N/A
    }

    /// GMAC_CTRL1 Register bits
    namespace gmac_ctrl1_bits {
        constexpr uint32_t PTP_TIMESTAMP_L = (32 << 0);  ///< N/A
    }

    /// GMAC_CTRL2 Register bits
    namespace gmac_ctrl2_bits {
        constexpr uint32_t PTP_TIMESTAMP_H = (32 << 0);  ///< N/A
    }

    /// VPU_CTRL Register bits
    namespace vpu_ctrl_bits {
        constexpr uint32_t PPA_LSLP_MEM_PD = (1U << 0);  ///< N/A
        constexpr uint32_t JPEG_SDSLP_MEM_PD = (1U << 1);  ///< N/A
        constexpr uint32_t JPEG_LSLP_MEM_PD = (1U << 2);  ///< N/A
        constexpr uint32_t JPEG_DSLP_MEM_PD = (1U << 3);  ///< N/A
        constexpr uint32_t DMA2D_LSLP_MEM_PD = (1U << 4);  ///< N/A
    }

    /// USBOTG20_CTRL Register bits
    namespace usbotg20_ctrl_bits {
        constexpr uint32_t OTG_PHY_TEST_DONE = (1U << 0);  ///< N/A
        constexpr uint32_t USB_MEM_AUX_CTRL = (14 << 1);  ///< N/A
        constexpr uint32_t PHY_SUSPENDM = (1U << 15);  ///< N/A
        constexpr uint32_t PHY_SUSPEND_FORCE_EN = (1U << 16);  ///< N/A
        constexpr uint32_t PHY_RSTN = (1U << 17);  ///< N/A
        constexpr uint32_t PHY_RESET_FORCE_EN = (1U << 18);  ///< N/A
        constexpr uint32_t PHY_PLL_FORCE_EN = (1U << 19);  ///< N/A
        constexpr uint32_t PHY_PLL_EN = (1U << 20);  ///< N/A
        constexpr uint32_t OTG_SUSPENDM = (1U << 21);  ///< N/A
        constexpr uint32_t OTG_PHY_TXBITSTUFF_EN = (1U << 22);  ///< N/A
        constexpr uint32_t OTG_PHY_REFCLK_MODE = (1U << 23);  ///< N/A
        constexpr uint32_t OTG_PHY_BISTEN = (1U << 24);  ///< N/A
    }

    /// TCM_ERR_RESP_CTRL Register bits
    namespace tcm_err_resp_ctrl_bits {
        constexpr uint32_t TCM_ERR_RESP_EN = (1U << 0);  ///< Set 1 to turn on tcm error response
    }

    /// L2_MEM_REFRESH Register bits
    namespace l2_mem_refresh_bits {
        constexpr uint32_t REG_L2_MEM_UNIT0_REFERSH_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT1_REFERSH_EN = (1U << 1);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT2_REFERSH_EN = (1U << 2);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT3_REFERSH_EN = (1U << 3);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT4_REFERSH_EN = (1U << 4);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT5_REFERSH_EN = (1U << 5);  ///< NA
        constexpr uint32_t REG_L2_MEM_REFERSH_CNT_RESET = (1U << 6);  ///< Set 1 to reset l2mem_refresh_cnt
        constexpr uint32_t REG_L2_MEM_UNIT0_REFRESH_DONE = (1U << 7);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT1_REFRESH_DONE = (1U << 8);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT2_REFRESH_DONE = (1U << 9);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT3_REFRESH_DONE = (1U << 10);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT4_REFRESH_DONE = (1U << 11);  ///< NA
        constexpr uint32_t REG_L2_MEM_UNIT5_REFRESH_DONE = (1U << 12);  ///< NA
    }

    /// TCM_INIT Register bits
    namespace tcm_init_bits {
        constexpr uint32_t REG_TCM_INIT_EN = (1U << 0);  ///< NA
        constexpr uint32_t REG_TCM_INIT_CNT_RESET = (1U << 1);  ///< Set 1 to reset tcm init cnt
        constexpr uint32_t REG_TCM_INIT_DONE = (1U << 2);  ///< NA
    }

    /// TCM_PARITY_CHECK_CTRL Register bits
    namespace tcm_parity_check_ctrl_bits {
        constexpr uint32_t TCM_PARITY_CHECK_EN = (1U << 0);  ///< Set 1 to turn on tcm parity check
    }

    /// DESIGN_FOR_VERIFICATION0 Register bits
    namespace design_for_verification0_bits {
        constexpr uint32_t DFV0 = (32 << 0);  ///< register for DV
    }

    /// DESIGN_FOR_VERIFICATION1 Register bits
    namespace design_for_verification1_bits {
        constexpr uint32_t DFV1 = (32 << 0);  ///< register for DV
    }

    /// PSRAM_FLASH_ADDR_INTERCHANGE Register bits
    namespace psram_flash_addr_interchange_bits {
        constexpr uint32_t CPU = (1U << 0);  ///< Set 1 to enable addr interchange between psram and flash in axi matrix when hp cpu access through cache
        constexpr uint32_t DMA = (1U << 1);  ///< Set 1 to enable addr interchange between psram and flash in axi matrix when dma device access, lp core access and hp core access through ahb
    }

    /// AHB2AXI_BRESP_ERR_INT_RAW Register bits
    namespace ahb2axi_bresp_err_int_raw_bits {
        constexpr uint32_t CPU_ICM_H2X_BRESP_ERR_INT_RAW = (1U << 0);  ///< the raw interrupt status of bresp error, triggered when if bresp err occurs in post write mode in ahb2axi.
    }

    /// AHB2AXI_BRESP_ERR_INT_ST Register bits
    namespace ahb2axi_bresp_err_int_st_bits {
        constexpr uint32_t CPU_ICM_H2X_BRESP_ERR_INT_ST = (1U << 31);  ///< the masked interrupt status of cpu_icm_h2x_bresp_err
    }

    /// AHB2AXI_BRESP_ERR_INT_ENA Register bits
    namespace ahb2axi_bresp_err_int_ena_bits {
        constexpr uint32_t CPU_ICM_H2X_BRESP_ERR_INT_ENA = (1U << 31);  ///< Write 1 to enable cpu_icm_h2x_bresp_err int
    }

    /// AHB2AXI_BRESP_ERR_INT_CLR Register bits
    namespace ahb2axi_bresp_err_int_clr_bits {
        constexpr uint32_t CPU_ICM_H2X_BRESP_ERR_INT_CLR = (1U << 31);  ///< Write 1 to clear cpu_icm_h2x_bresp_err int
    }

    /// L2_MEM_ERR_RESP_CTRL Register bits
    namespace l2_mem_err_resp_ctrl_bits {
        constexpr uint32_t L2_MEM_ERR_RESP_EN = (1U << 0);  ///< Set 1 to turn on l2mem error response
    }

    /// L2_MEM_AHB_BUFFER_CTRL Register bits
    namespace l2_mem_ahb_buffer_ctrl_bits {
        constexpr uint32_t L2_MEM_AHB_WRBUFFER_EN = (1U << 0);  ///< Set 1 to turn on l2mem ahb wr buffer
        constexpr uint32_t L2_MEM_AHB_RDBUFFER_EN = (1U << 1);  ///< Set 1 to turn on l2mem ahb rd buffer
    }

    /// CORE_DMACTIVE_LPCORE Register bits
    namespace core_dmactive_lpcore_bits {
        constexpr uint32_t CORE_DMACTIVE_LPCORE = (1U << 0);  ///< hp core dmactive_lpcore value
    }

    /// CORE_ERR_RESP_DIS Register bits
    namespace core_err_resp_dis_bits {
        constexpr uint32_t CORE_ERR_RESP_DIS = (3 << 0);  ///< Set bit0 to disable ibus err resp. Set bit1 to disable dbus err resp. Set bit 2 to disable ahb err resp.
    }

    /// CORE_TIMEOUT_INT_RAW Register bits
    namespace core_timeout_int_raw_bits {
        constexpr uint32_t CORE0_AHB_TIMEOUT_INT_RAW = (1U << 0);  ///< the raw interrupt status of hp core0 ahb timeout
        constexpr uint32_t CORE1_AHB_TIMEOUT_INT_RAW = (1U << 1);  ///< the raw interrupt status of hp core1 ahb timeout
        constexpr uint32_t CORE0_IBUS_TIMEOUT_INT_RAW = (1U << 2);  ///< the raw interrupt status of hp core0 ibus timeout
        constexpr uint32_t CORE1_IBUS_TIMEOUT_INT_RAW = (1U << 3);  ///< the raw interrupt status of hp core1 ibus timeout
        constexpr uint32_t CORE0_DBUS_TIMEOUT_INT_RAW = (1U << 4);  ///< the raw interrupt status of hp core0 dbus timeout
        constexpr uint32_t CORE1_DBUS_TIMEOUT_INT_RAW = (1U << 5);  ///< the raw interrupt status of hp core1 dbus timeout
    }

    /// CORE_TIMEOUT_INT_ST Register bits
    namespace core_timeout_int_st_bits {
        constexpr uint32_t CORE0_AHB_TIMEOUT_INT_ST = (1U << 0);  ///< the masked interrupt status of hp core0 ahb timeout
        constexpr uint32_t CORE1_AHB_TIMEOUT_INT_ST = (1U << 1);  ///< the masked interrupt status of hp core1 ahb timeout
        constexpr uint32_t CORE0_IBUS_TIMEOUT_INT_ST = (1U << 2);  ///< the masked interrupt status of hp core0 ibus timeout
        constexpr uint32_t CORE1_IBUS_TIMEOUT_INT_ST = (1U << 3);  ///< the masked interrupt status of hp core1 ibus timeout
        constexpr uint32_t CORE0_DBUS_TIMEOUT_INT_ST = (1U << 4);  ///< the masked interrupt status of hp core0 dbus timeout
        constexpr uint32_t CORE1_DBUS_TIMEOUT_INT_ST = (1U << 5);  ///< the masked interrupt status of hp core1 dbus timeout
    }

    /// CORE_TIMEOUT_INT_ENA Register bits
    namespace core_timeout_int_ena_bits {
        constexpr uint32_t CORE0_AHB_TIMEOUT_INT_ENA = (1U << 0);  ///< Write 1 to enable hp_core0_ahb_timeout int
        constexpr uint32_t CORE1_AHB_TIMEOUT_INT_ENA = (1U << 1);  ///< Write 1 to enable hp_core1_ahb_timeout int
        constexpr uint32_t CORE0_IBUS_TIMEOUT_INT_ENA = (1U << 2);  ///< Write 1 to enable hp_core0_ibus_timeout int
        constexpr uint32_t CORE1_IBUS_TIMEOUT_INT_ENA = (1U << 3);  ///< Write 1 to enable hp_core1_ibus_timeout int
        constexpr uint32_t CORE0_DBUS_TIMEOUT_INT_ENA = (1U << 4);  ///< Write 1 to enable hp_core0_dbus_timeout int
        constexpr uint32_t CORE1_DBUS_TIMEOUT_INT_ENA = (1U << 5);  ///< Write 1 to enable hp_core1_dbus_timeout int
    }

    /// CORE_TIMEOUT_INT_CLR Register bits
    namespace core_timeout_int_clr_bits {
        constexpr uint32_t CORE0_AHB_TIMEOUT_INT_CLR = (1U << 0);  ///< Write 1 to clear hp_core0_ahb_timeout int
        constexpr uint32_t CORE1_AHB_TIMEOUT_INT_CLR = (1U << 1);  ///< Write 1 to clear hp_core1_ahb_timeout int
        constexpr uint32_t CORE0_IBUS_TIMEOUT_INT_CLR = (1U << 2);  ///< Write 1 to clear hp_core0_ibus_timeout int
        constexpr uint32_t CORE1_IBUS_TIMEOUT_INT_CLR = (1U << 3);  ///< Write 1 to clear hp_core1_ibus_timeout int
        constexpr uint32_t CORE0_DBUS_TIMEOUT_INT_CLR = (1U << 4);  ///< Write 1 to clear hp_core0_dbus_timeout int
        constexpr uint32_t CORE1_DBUS_TIMEOUT_INT_CLR = (1U << 5);  ///< Write 1 to clear hp_core1_dbus_timeout int
    }

    /// GPIO_O_HYS_CTRL0 Register bits
    namespace gpio_o_hys_ctrl0_bits {
        constexpr uint32_t REG_GPIO_0_HYS_LOW = (32 << 0);  ///< hys control for gpio47~16
    }

    /// GPIO_O_HYS_CTRL1 Register bits
    namespace gpio_o_hys_ctrl1_bits {
        constexpr uint32_t REG_GPIO_0_HYS_HIGH = (9 << 0);  ///< hys control for gpio56~48
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to power down rsa internal memory.
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up rsa internal memory
        constexpr uint32_t RSA_MEM_PD = (1U << 2);  ///< Set this bit to force power down rsa internal memory.
    }

    /// ECC_PD_CTRL Register bits
    namespace ecc_pd_ctrl_bits {
        constexpr uint32_t ECC_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to power down ecc internal memory.
        constexpr uint32_t ECC_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up ecc internal memory
        constexpr uint32_t ECC_MEM_PD = (1U << 2);  ///< Set this bit to force power down ecc internal memory.
    }

    /// RNG_CFG Register bits
    namespace rng_cfg_bits {
        constexpr uint32_t RNG_SAMPLE_ENABLE = (1U << 0);  ///< enable rng sample chain
        constexpr uint32_t RNG_CHAIN_CLK_DIV_NUM = (8 << 16);  ///< chain clk div num to pad for debug
        constexpr uint32_t RNG_SAMPLE_CNT = (8 << 24);  ///< debug rng sample cnt
    }

    /// UART_PD_CTRL Register bits
    namespace uart_pd_ctrl_bits {
        constexpr uint32_t UART_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to power down hp uart internal memory.
        constexpr uint32_t UART_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up hp uart internal memory
    }

    /// PERI_MEM_CLK_FORCE_ON Register bits
    namespace peri_mem_clk_force_on_bits {
        constexpr uint32_t RMT_MEM_CLK_FORCE_ON = (1U << 0);  ///< Set this bit to force on mem clk in rmt
        constexpr uint32_t BITSCRAMBLER_TX_MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit to force on tx mem clk in bitscrambler
        constexpr uint32_t BITSCRAMBLER_RX_MEM_CLK_FORCE_ON = (1U << 2);  ///< Set this bit to force on rx mem clk in bitscrambler
        constexpr uint32_t GDMA_MEM_CLK_FORCE_ON = (1U << 3);  ///< Set this bit to force on mem clk in gdma
    }

}

// ============================================================================
// LP Peripheral
// ============================================================================

namespace lp {
    /// Base addresses
    constexpr uint32_t LP_HUK_BASE = 0x50114000;
    constexpr uint32_t LP_INTR_BASE = 0x5012C000;
    constexpr uint32_t LP_PERI_BASE = 0x50120000;
    constexpr uint32_t LP_SYS_BASE = 0x50110000;
    constexpr uint32_t LP_ANA_PERI_BASE = 0x50113000;
    constexpr uint32_t LP_AON_CLKRST_BASE = 0x50111000;
    constexpr uint32_t LP_IO_MUX_BASE = 0x5012B000;
    constexpr uint32_t LP_TOUCH_BASE = 0x50128000;
    constexpr uint32_t LP_TSENS_BASE = 0x5012F000;

    /// LP Register structure
    struct Registers {
        volatile uint32_t CLK;  ///< Offset: 0x04 - HUK Generator clock gate control register
        volatile uint32_t INT_RAW;  ///< Offset: 0x08 - HUK Generator interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x0C - HUK Generator interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - HUK Generator interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x14 - HUK Generator interrupt clear register.
        volatile uint32_t CONF;  ///< Offset: 0x20 - HUK Generator configuration register
        volatile uint32_t START;  ///< Offset: 0x24 - HUK Generator control register
        volatile uint32_t STATE;  ///< Offset: 0x28 - HUK Generator state register
        volatile uint32_t STATUS;  ///< Offset: 0x34 - HUK Generator HUK status register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t INFO_MEM[%s];  ///< Offset: 0x100 - The memory that stores HUK info.
    };

    /// Peripheral instances
    inline Registers* LP_HUK = reinterpret_cast<Registers*>(LP_HUK_BASE);
    inline Registers* LP_INTR = reinterpret_cast<Registers*>(LP_INTR_BASE);
    inline Registers* LP_PERI = reinterpret_cast<Registers*>(LP_PERI_BASE);
    inline Registers* LP_SYS = reinterpret_cast<Registers*>(LP_SYS_BASE);
    inline Registers* LP_ANA_PERI = reinterpret_cast<Registers*>(LP_ANA_PERI_BASE);
    inline Registers* LP_AON_CLKRST = reinterpret_cast<Registers*>(LP_AON_CLKRST_BASE);
    inline Registers* LP_IO_MUX = reinterpret_cast<Registers*>(LP_IO_MUX_BASE);
    inline Registers* LP_TOUCH = reinterpret_cast<Registers*>(LP_TOUCH_BASE);
    inline Registers* LP_TSENS = reinterpret_cast<Registers*>(LP_TSENS_BASE);

    // Bit definitions
    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Write 1 to force on register clock gate.
        constexpr uint32_t MEM_CG_FORCE_ON = (1U << 1);  ///< Write 1 to force on memory clock gate.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t PREP_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the huk_prep_done_int interrupt
        constexpr uint32_t PROC_DONE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the huk_proc_done_int interrupt
        constexpr uint32_t POST_DONE_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the huk_post_done_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t PREP_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the huk_prep_done_int interrupt
        constexpr uint32_t PROC_DONE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the huk_proc_done_int interrupt
        constexpr uint32_t POST_DONE_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the huk_post_done_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t PREP_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the huk_prep_done_int interrupt
        constexpr uint32_t PROC_DONE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the huk_proc_done_int interrupt
        constexpr uint32_t POST_DONE_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the huk_post_done_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t PREP_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the huk_prep_done_int interrupt
        constexpr uint32_t PROC_DONE_INT_CLR = (1U << 1);  ///< Set this bit to clear the huk_proc_done_int interrupt
        constexpr uint32_t POST_DONE_INT_CLR = (1U << 2);  ///< Set this bit to clear the huk_post_done_int interrupt
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< Set this field to choose the huk process. 1: process huk generate mode. 0: process huk recovery mode.
    }

    /// START Register bits
    namespace start_bits {
        constexpr uint32_t START = (1U << 0);  ///< Write 1 to continue HUK Generator operation at LOAD/GAIN state.
        constexpr uint32_t CONTINUE = (1U << 1);  ///< Write 1 to start HUK Generator at IDLE state.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< The state of HUK Generator. 0: IDLE. 1: LOAD. 2: GAIN. 3: BUSY.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATUS = (2 << 0);  ///< The HUK generation status. 0: HUK is not generated. 1: HUK is generated and valid. 2: HUK is generated but invalid. 3: reserved.
        constexpr uint32_t RISK_LEVEL = (3 << 2);  ///< The risk level of HUK. 0-6: the higher the risk level is, the more error bits there are in the PUF SRAM. 7: Error Level, HUK is invalid.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< HUK Generator version control register.
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x500C6000;
    constexpr uint32_t I2S1_BASE = 0x500C7000;
    constexpr uint32_t I2S2_BASE = 0x500C8000;
    constexpr uint32_t LP_I2S0_BASE = 0x50125000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - I2S interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - I2S interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - I2S interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - I2S interrupt clear register.
        volatile uint32_t RX_CONF;  ///< Offset: 0x20 - I2S RX configure register
        volatile uint32_t TX_CONF;  ///< Offset: 0x24 - I2S TX configure register
        volatile uint32_t RX_CONF1;  ///< Offset: 0x28 - I2S RX configure register 1
        volatile uint32_t TX_CONF1;  ///< Offset: 0x2C - I2S TX configure register 1
        volatile uint32_t TX_PCM2PDM_CONF;  ///< Offset: 0x40 - I2S TX PCM2PDM configuration register
        volatile uint32_t TX_PCM2PDM_CONF1;  ///< Offset: 0x44 - I2S TX PCM2PDM configuration register
        volatile uint32_t RX_PDM2PCM_CONF;  ///< Offset: 0x48 - I2S RX configure register
        volatile uint32_t RX_TDM_CTRL;  ///< Offset: 0x50 - I2S TX TDM mode control register
        volatile uint32_t TX_TDM_CTRL;  ///< Offset: 0x54 - I2S TX TDM mode control register
        volatile uint32_t RX_TIMING;  ///< Offset: 0x58 - I2S RX timing control register
        volatile uint32_t TX_TIMING;  ///< Offset: 0x5C - I2S TX timing control register
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x60 - I2S HUNG configure register.
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x64 - I2S RX data number control register.
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x68 - I2S signal data register
        volatile uint32_t STATE;  ///< Offset: 0x6C - I2S TX status register
        volatile uint32_t ETM_CONF;  ///< Offset: 0x70 - I2S ETM configure register
        volatile uint32_t FIFO_CNT;  ///< Offset: 0x74 - I2S sync counter register
        volatile uint32_t BCK_CNT;  ///< Offset: 0x78 - I2S sync counter register
        volatile uint32_t CLK_GATE;  ///< Offset: 0x7C - Clock gate register
        volatile uint32_t DATE;  ///< Offset: 0x80 - Version control register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);
    inline Registers* I2S2 = reinterpret_cast<Registers*>(I2S2_BASE);
    inline Registers* LP_I2S0 = reinterpret_cast<Registers*>(LP_I2S0_BASE);

    // Bit definitions
    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the i2s_tx_hung_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 1);  ///< Set this bit to clear the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear the i2s_tx_hung_int interrupt
    }

    /// RX_CONF Register bits
    namespace rx_conf_bits {
        constexpr uint32_t RX_RESET = (1U << 0);  ///< Set this bit to reset receiver
        constexpr uint32_t RX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Rx AFIFO
        constexpr uint32_t RX_START = (1U << 2);  ///< Set this bit to start receiving data
        constexpr uint32_t RX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave receiver mode
        constexpr uint32_t RX_STOP_MODE = (2 << 4);  ///< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
        constexpr uint32_t RX_MONO = (1U << 6);  ///< Set this bit to enable receiver in mono mode
        constexpr uint32_t RX_BIG_ENDIAN = (1U << 7);  ///< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t RX_UPDATE = (1U << 8);  ///< Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t RX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
        constexpr uint32_t RX_PCM_CONF = (2 << 10);  ///< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t RX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for received data.
        constexpr uint32_t RX_MSB_SHIFT = (1U << 13);  ///< Set this bit to enable receiver in Phillips standard mode
        constexpr uint32_t RX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
        constexpr uint32_t RX_24_FILL_EN = (1U << 16);  ///< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
        constexpr uint32_t RX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when receiving left channel data, and WS is 1in right channel. 1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
        constexpr uint32_t RX_BIT_ORDER = (1U << 18);  ///< I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
        constexpr uint32_t RX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Rx mode . 0: Disable.
        constexpr uint32_t RX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Rx mode . 0: Disable.
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 21);  ///< Bit clock configuration bits in receiver mode.
    }

    /// TX_CONF Register bits
    namespace tx_conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< Set this bit to reset transmitter
        constexpr uint32_t TX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Tx AFIFO
        constexpr uint32_t TX_START = (1U << 2);  ///< Set this bit to start transmitting data
        constexpr uint32_t TX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave transmitter mode
        constexpr uint32_t TX_STOP_EN = (1U << 4);  ///< Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
        constexpr uint32_t TX_CHAN_EQUAL = (1U << 5);  ///< 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
        constexpr uint32_t TX_MONO = (1U << 6);  ///< Set this bit to enable transmitter in mono mode
        constexpr uint32_t TX_BIG_ENDIAN = (1U << 7);  ///< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t TX_UPDATE = (1U << 8);  ///< Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t TX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
        constexpr uint32_t TX_PCM_CONF = (2 << 10);  ///< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t TX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for transmitted data.
        constexpr uint32_t TX_MSB_SHIFT = (1U << 13);  ///< Set this bit to enable transmitter in Phillips standard mode
        constexpr uint32_t TX_BCK_NO_DLY = (1U << 14);  ///< 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
        constexpr uint32_t TX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
        constexpr uint32_t TX_24_FILL_EN = (1U << 16);  ///< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
        constexpr uint32_t TX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when sending left channel data, and WS is 1in right channel. 1: WS should be 1 when sending left channel data, and WS is 0in right channel.
        constexpr uint32_t TX_BIT_ORDER = (1U << 18);  ///< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
        constexpr uint32_t TX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Tx mode . 0: Disable.
        constexpr uint32_t TX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Tx mode . 0: Disable.
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 21);  ///< Bit clock configuration bits in transmitter mode.
        constexpr uint32_t TX_CHAN_MOD = (3 << 27);  ///< I2S transmitter channel mode configuration bits.
        constexpr uint32_t SIG_LOOPBACK = (1U << 30);  ///< Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
    }

    /// RX_CONF1 Register bits
    namespace rx_conf1_bits {
        constexpr uint32_t RX_TDM_WS_WIDTH = (9 << 0);  ///< The width of rx_ws_out at idle level in TDM mode is (I2S_RX_TDM_WS_WIDTH[8:0] +1) * T_bck
        constexpr uint32_t RX_BITS_MOD = (5 << 14);  ///< Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t RX_HALF_SAMPLE_BITS = (8 << 19);  ///< I2S Rx half sample bits -1.
        constexpr uint32_t RX_TDM_CHAN_BITS = (5 << 27);  ///< The Rx bit number for each channel minus 1in TDM mode.
    }

    /// TX_CONF1 Register bits
    namespace tx_conf1_bits {
        constexpr uint32_t TX_TDM_WS_WIDTH = (9 << 0);  ///< The width of tx_ws_out at idle level in TDM mode is (I2S_TX_TDM_WS_WIDTH[8:0] +1) * T_bck
        constexpr uint32_t TX_BITS_MOD = (5 << 14);  ///< Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t TX_HALF_SAMPLE_BITS = (8 << 19);  ///< I2S Tx half sample bits -1.
        constexpr uint32_t TX_TDM_CHAN_BITS = (5 << 27);  ///< The Tx bit number for each channel minus 1in TDM mode.
    }

    /// TX_PCM2PDM_CONF Register bits
    namespace tx_pcm2pdm_conf_bits {
        constexpr uint32_t TX_PDM_HP_BYPASS = (1U << 0);  ///< I2S TX PDM bypass hp filter or not. The option has been removed.
        constexpr uint32_t TX_PDM_SINC_OSR2 = (4 << 1);  ///< I2S TX PDM OSR2 value
        constexpr uint32_t TX_PDM_PRESCALE = (8 << 5);  ///< I2S TX PDM prescale for sigmadelta
        constexpr uint32_t TX_PDM_HP_IN_SHIFT = (2 << 13);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_LP_IN_SHIFT = (2 << 15);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SINC_IN_SHIFT = (2 << 17);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_IN_SHIFT = (2 << 19);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER2 = (1U << 21);  ///< I2S TX PDM sigmadelta dither2 value
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER = (1U << 22);  ///< I2S TX PDM sigmadelta dither value
        constexpr uint32_t TX_PDM_DAC_2OUT_EN = (1U << 23);  ///< I2S TX PDM dac mode enable
        constexpr uint32_t TX_PDM_DAC_MODE_EN = (1U << 24);  ///< I2S TX PDM dac 2channel enable
        constexpr uint32_t PCM2PDM_CONV_EN = (1U << 25);  ///< I2S TX PDM Converter enable
    }

    /// TX_PCM2PDM_CONF1 Register bits
    namespace tx_pcm2pdm_conf1_bits {
        constexpr uint32_t TX_PDM_FP = (10 << 0);  ///< I2S TX PDM Fp
        constexpr uint32_t TX_PDM_FS = (10 << 10);  ///< I2S TX PDM Fs
        constexpr uint32_t TX_IIR_HP_MULT12_5 = (3 << 20);  ///< The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
        constexpr uint32_t TX_IIR_HP_MULT12_0 = (3 << 23);  ///< The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
    }

    /// RX_PDM2PCM_CONF Register bits
    namespace rx_pdm2pcm_conf_bits {
        constexpr uint32_t RX_PDM2PCM_EN = (1U << 19);  ///< 1: Enable PDM2PCM RX mode. 0: DIsable.
        constexpr uint32_t RX_PDM_SINC_DSR_16_EN = (1U << 20);  ///< Configure the down sampling rate of PDM RX filter group1 module. 1: The down sampling rate is 128. 0: down sampling rate is 64.
        constexpr uint32_t RX_PDM2PCM_AMPLIFY_NUM = (4 << 21);  ///< Configure PDM RX amplify number.
        constexpr uint32_t RX_PDM_HP_BYPASS = (1U << 25);  ///< I2S PDM RX bypass hp filter or not.
        constexpr uint32_t RX_IIR_HP_MULT12_5 = (3 << 26);  ///< The fourth parameter of PDM RX IIR_HP filter stage 2 is (504 + LP_I2S_RX_IIR_HP_MULT12_5[2:0])
        constexpr uint32_t RX_IIR_HP_MULT12_0 = (3 << 29);  ///< The fourth parameter of PDM RX IIR_HP filter stage 1 is (504 + LP_I2S_RX_IIR_HP_MULT12_0[2:0])
    }

    /// RX_TDM_CTRL Register bits
    namespace rx_tdm_ctrl_bits {
        constexpr uint32_t RX_TDM_PDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data input of I2S RX TDM channel 10. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data input of I2S RX TDM channel 11. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data input of I2S RX TDM channel 12. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data input of I2S RX TDM channel 13. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data input of I2S RX TDM channel 14. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data input of I2S RX TDM channel 15. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
    }

    /// TX_TDM_CTRL Register bits
    namespace tx_tdm_ctrl_bits {
        constexpr uint32_t TX_TDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data output of I2S TX TDM channel 0. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data output of I2S TX TDM channel 1. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data output of I2S TX TDM channel 2. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data output of I2S TX TDM channel 3. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data output of I2S TX TDM channel 4. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data output of I2S TX TDM channel 5. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data output of I2S TX TDM channel 6. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data output of I2S TX TDM channel 7. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data output of I2S TX TDM channel 8. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data output of I2S TX TDM channel 9. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data output of I2S TX TDM channel 10. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data output of I2S TX TDM channel 11. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data output of I2S TX TDM channel 12. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data output of I2S TX TDM channel 13. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data output of I2S TX TDM channel 14. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data output of I2S TX TDM channel 15. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
        constexpr uint32_t TX_TDM_SKIP_MSK_EN = (1U << 20);  ///< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1) channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
    }

    /// RX_TIMING Register bits
    namespace rx_timing_bits {
        constexpr uint32_t RX_SD_IN_DM = (2 << 0);  ///< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD1_IN_DM = (2 << 4);  ///< The delay mode of I2S Rx SD1 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD2_IN_DM = (2 << 8);  ///< The delay mode of I2S Rx SD2 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD3_IN_DM = (2 << 12);  ///< The delay mode of I2S Rx SD3 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// TX_TIMING Register bits
    namespace tx_timing_bits {
        constexpr uint32_t TX_SD_OUT_DM = (2 << 0);  ///< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_SD1_OUT_DM = (2 << 4);  ///< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for FIFO timeout
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (12 << 0);  ///< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SINGLE_DATA = (32 << 0);  ///< The configured constant channel data to be sent out.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< 1: i2s_tx is idle state. 0: i2s_tx is working.
    }

    /// ETM_CONF Register bits
    namespace etm_conf_bits {
        constexpr uint32_t ETM_TX_SEND_WORD_NUM = (10 << 0);  ///< I2S ETM send x words event. When sending word number of reg_etm_tx_send_word_num[9:0], i2s will trigger an etm event.
        constexpr uint32_t ETM_RX_RECEIVE_WORD_NUM = (10 << 10);  ///< I2S ETM receive x words event. When receiving word number of reg_etm_rx_receive_word_num[9:0], i2s will trigger an etm event.
    }

    /// FIFO_CNT Register bits
    namespace fifo_cnt_bits {
        constexpr uint32_t TX_FIFO_CNT = (31 << 0);  ///< tx fifo counter value.
        constexpr uint32_t TX_FIFO_CNT_RST = (1U << 31);  ///< Set this bit to reset tx fifo counter.
    }

    /// BCK_CNT Register bits
    namespace bck_cnt_bits {
        constexpr uint32_t TX_BCK_CNT = (31 << 0);  ///< tx bck counter value.
        constexpr uint32_t TX_BCK_CNT_RST = (1U << 31);  ///< Set this bit to reset tx bck counter.
    }

    /// CLK_GATE Register bits
    namespace clk_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable clock gate
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< I2S version control register
    }

}

// ============================================================================
// I3C Peripheral
// ============================================================================

namespace i3c {
    /// Base addresses
    constexpr uint32_t I3C_MST_BASE = 0x500DA000;
    constexpr uint32_t I3C_MST_MEM_BASE = 0x500DA000;
    constexpr uint32_t I3C_SLV_BASE = 0x500DB000;

    /// I3C Register structure
    struct Registers {
        volatile uint32_t DEVICE_CTRL;  ///< Offset: 0x00 - DEVICE_CTRL register controls the transfer properties...
        volatile uint32_t BUFFER_THLD_CTRL;  ///< Offset: 0x1C - In-Band Interrupt Status Threshold Value . Every In Band...
        volatile uint32_t DATA_BUFFER_THLD_CTRL;  ///< Offset: 0x20 - NA
        volatile uint32_t IBI_NOTIFY_CTRL;  ///< Offset: 0x24 - NA
        volatile uint32_t IBI_SIR_REQ_PAYLOAD;  ///< Offset: 0x28 - NA
        volatile uint32_t IBI_SIR_REQ_REJECT;  ///< Offset: 0x2C - NA
        volatile uint32_t INT_CLR;  ///< Offset: 0x30 - NA
        volatile uint32_t INT_RAW;  ///< Offset: 0x34 - NA
        volatile uint32_t INT_ST;  ///< Offset: 0x38 - NA
        volatile uint32_t INT_ST_ENA;  ///< Offset: 0x3C - The Interrupt status will be updated in INTR_STATUS...
        volatile uint32_t RESET_CTRL;  ///< Offset: 0x44 - NA
        volatile uint32_t BUFFER_STATUS_LEVEL;  ///< Offset: 0x48 - BUFFER_STATUS_LEVEL reflects the status level of Buffers...
        volatile uint32_t DATA_BUFFER_STATUS_LEVEL;  ///< Offset: 0x4C - DATA_BUFFER_STATUS_LEVEL reflects the status level of...
        volatile uint32_t PRESENT_STATE0;  ///< Offset: 0x50 - NA
        volatile uint32_t PRESENT_STATE1;  ///< Offset: 0x54 - NA
        volatile uint32_t DEVICE_TABLE;  ///< Offset: 0x58 - Pointer for Device Address Table
        volatile uint32_t TIME_OUT_VALUE;  ///< Offset: 0x5C - NA
        volatile uint32_t SCL_I3C_MST_OD_TIME;  ///< Offset: 0x60 - NA
        volatile uint32_t SCL_I3C_MST_PP_TIME;  ///< Offset: 0x64 - NA
        volatile uint32_t SCL_I2C_FM_TIME;  ///< Offset: 0x68 - NA
        volatile uint32_t SCL_I2C_FMP_TIME;  ///< Offset: 0x6C - NA
        volatile uint32_t SCL_EXT_LOW_TIME;  ///< Offset: 0x70 - NA
        volatile uint32_t SDA_SAMPLE_TIME;  ///< Offset: 0x74 - NA
        volatile uint32_t SDA_HOLD_TIME;  ///< Offset: 0x78 - NA
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x7C - NA
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x80 - NA
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x84 - NA
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x88 - NA
        volatile uint32_t BUS_FREE_TIME;  ///< Offset: 0x90 - NA
        volatile uint32_t SCL_TERMN_T_EXT_LOW_TIME;  ///< Offset: 0x94 - NA
        volatile uint32_t VER_ID;  ///< Offset: 0xA0 - NA
        volatile uint32_t VER_TYPE;  ///< Offset: 0xA4 - NA
        volatile uint32_t FPGA_DEBUG_PROBE;  ///< Offset: 0xAC - NA
        volatile uint32_t RND_ECO_CS;  ///< Offset: 0xB0 - NA
        volatile uint32_t RND_ECO_LOW;  ///< Offset: 0xB4 - NA
        volatile uint32_t RND_ECO_HIGH;  ///< Offset: 0xB8 - NA
    };

    /// Peripheral instances
    inline Registers* I3C_MST = reinterpret_cast<Registers*>(I3C_MST_BASE);
    inline Registers* I3C_MST_MEM = reinterpret_cast<Registers*>(I3C_MST_MEM_BASE);
    inline Registers* I3C_SLV = reinterpret_cast<Registers*>(I3C_SLV_BASE);

    // Bit definitions
    /// DEVICE_CTRL Register bits
    namespace device_ctrl_bits {
        constexpr uint32_t REG_BA_INCLUDE = (1U << 1);  ///< This bit is used to include I3C broadcast address(0x7E) for private transfer.(If I3C broadcast address is not include for the private transfer, In-Band Interrupts driven from Slaves may not win address arbitration. Hence IBIs will get delayed)
        constexpr uint32_t REG_TRANS_START = (1U << 2);  ///< Transfer Start
        constexpr uint32_t REG_CLK_EN = (1U << 3);  ///< NA
        constexpr uint32_t REG_IBI_RSTART_TRANS_EN = (1U << 4);  ///< NA
        constexpr uint32_t REG_AUTO_DIS_IBI_EN = (1U << 5);  ///< NA
        constexpr uint32_t REG_DMA_RX_EN = (1U << 6);  ///< NA
        constexpr uint32_t REG_DMA_TX_EN = (1U << 7);  ///< NA
        constexpr uint32_t REG_MULTI_SLV_SINGLE_CCC_EN = (1U << 8);  ///< 0: rx high bit first, 1: rx low bit first
        constexpr uint32_t REG_RX_BIT_ORDER = (1U << 9);  ///< 0: rx low byte fist, 1: rx high byte first
        constexpr uint32_t REG_RX_BYTE_ORDER = (1U << 10);  ///< NA
        constexpr uint32_t REG_SCL_PULLUP_FORCE_EN = (1U << 11);  ///< This bit is used to force scl_pullup_en
        constexpr uint32_t REG_SCL_OE_FORCE_EN = (1U << 12);  ///< This bit is used to force scl_oe
        constexpr uint32_t REG_SDA_PP_RD_PULLUP_EN = (1U << 13);  ///< NA
        constexpr uint32_t REG_SDA_RD_TBIT_HLVL_PULLUP_EN = (1U << 14);  ///< NA
        constexpr uint32_t REG_SDA_PP_WR_PULLUP_EN = (1U << 15);  ///< NA
        constexpr uint32_t REG_DATA_BYTE_CNT_UNLATCH = (1U << 16);  ///< 1: read current real-time updated value 0: read latch data byte cnt value
        constexpr uint32_t REG_MEM_CLK_FORCE_ON = (1U << 17);  ///< 1: dev characteristic and address table memory clk date force on . 0 : clock gating by rd/wr.
    }

    /// BUFFER_THLD_CTRL Register bits
    namespace buffer_thld_ctrl_bits {
        constexpr uint32_t REG_CMD_BUF_EMPTY_THLD = (4 << 0);  ///< Command Buffer Empty Threshold Value is used to control the number of empty locations(or greater) in the Command Buffer that trigger CMD_BUFFER_READY_STAT interrupt.
        constexpr uint32_t REG_RESP_BUF_THLD = (3 << 6);  ///< Response Buffer Threshold Value is used to control the number of entries in the Response Buffer that trigger the RESP_READY_STAT_INTR.
        constexpr uint32_t REG_IBI_DATA_BUF_THLD = (3 << 12);  ///< In-Band Interrupt Data Threshold Value . Every In Band Interrupt received by I3C controller generates an IBI status. This field controls the number of IBI data entries in the IBI buffer that trigger the IBI_DATA_THLD_STAT interrupt.
        constexpr uint32_t REG_IBI_STATUS_BUF_THLD = (3 << 18);  ///< NA
    }

    /// DATA_BUFFER_THLD_CTRL Register bits
    namespace data_buffer_thld_ctrl_bits {
        constexpr uint32_t REG_TX_DATA_BUF_THLD = (3 << 0);  ///< Transmit Buffer Threshold Value. This field controls the number of empty locations in the Transmit FIFO that trigger the TX_THLD_STAT interrupt. Supports values: 000:2 001:4 010:8 011:16 100:31, else:31
        constexpr uint32_t REG_RX_DATA_BUF_THLD = (3 << 3);  ///< Receive Buffer Threshold Value. This field controls the number of empty locations in the Receive FIFO that trigger the RX_THLD_STAT interrupt. Supports: 000:2 001:4 010:8 011:16 100:31, else:31
    }

    /// IBI_NOTIFY_CTRL Register bits
    namespace ibi_notify_ctrl_bits {
        constexpr uint32_t REG_NOTIFY_SIR_REJECTED = (1U << 2);  ///< Notify Rejected Slave Interrupt Request Control. This bit is used to suppress reporting to the application about Slave Interrupt Request. 0:Suppress passing the IBI Status to the IBI FIFO(hence not notifying the application) when a SIR request is NACKed and auto-disabled base on the IBI_SIR_REQ_REJECT register. 1: Writes IBI Status to the IBI FIFO(hence notifying the application) when SIR request is NACKed and auto-disabled based on the IBI_SIR_REQ_REJECT registerl.
    }

    /// IBI_SIR_REQ_PAYLOAD Register bits
    namespace ibi_sir_req_payload_bits {
        constexpr uint32_t REG_SIR_REQ_PAYLOAD = (32 << 0);  ///< NA
    }

    /// IBI_SIR_REQ_REJECT Register bits
    namespace ibi_sir_req_reject_bits {
        constexpr uint32_t REG_SIR_REQ_REJECT = (32 << 0);  ///< The application of controller can decide whether to send ACK or NACK for Slave request received from any I3C device. A device specific response control bit is provided to select the response option, Master will ACK/NACK the Master Request based on programming of control bit, corresponding to the interrupting device. 0:ACK the SIR Request 1:NACK and send direct auto disable CCC
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TX_DATA_BUF_THLD_INT_CLR = (1U << 0);  ///< NA
        constexpr uint32_t RX_DATA_BUF_THLD_INT_CLR = (1U << 1);  ///< NA
        constexpr uint32_t IBI_STATUS_THLD_INT_CLR = (1U << 2);  ///< NA
        constexpr uint32_t CMD_BUF_EMPTY_THLD_INT_CLR = (1U << 3);  ///< NA
        constexpr uint32_t RESP_READY_INT_CLR = (1U << 4);  ///< NA
        constexpr uint32_t NXT_CMD_REQ_ERR_INT_CLR = (1U << 5);  ///< NA
        constexpr uint32_t TRANSFER_ERR_INT_CLR = (1U << 6);  ///< NA
        constexpr uint32_t TRANSFER_COMPLETE_INT_CLR = (1U << 7);  ///< NA
        constexpr uint32_t COMMAND_DONE_INT_CLR = (1U << 8);  ///< NA
        constexpr uint32_t DETECT_START_INT_CLR = (1U << 9);  ///< NA
        constexpr uint32_t RESP_BUF_OVF_INT_CLR = (1U << 10);  ///< NA
        constexpr uint32_t IBI_DATA_BUF_OVF_INT_CLR = (1U << 11);  ///< NA
        constexpr uint32_t IBI_STATUS_BUF_OVF_INT_CLR = (1U << 12);  ///< NA
        constexpr uint32_t IBI_HANDLE_DONE_INT_CLR = (1U << 13);  ///< NA
        constexpr uint32_t IBI_DETECT_INT_CLR = (1U << 14);  ///< NA
        constexpr uint32_t CMD_CCC_MISMATCH_INT_CLR = (1U << 15);  ///< NA
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TX_DATA_BUF_THLD_INT_RAW = (1U << 0);  ///< NA
        constexpr uint32_t RX_DATA_BUF_THLD_INT_RAW = (1U << 1);  ///< NA
        constexpr uint32_t IBI_STATUS_THLD_INT_RAW = (1U << 2);  ///< NA
        constexpr uint32_t CMD_BUF_EMPTY_THLD_INT_RAW = (1U << 3);  ///< NA
        constexpr uint32_t RESP_READY_INT_RAW = (1U << 4);  ///< NA
        constexpr uint32_t NXT_CMD_REQ_ERR_INT_RAW = (1U << 5);  ///< NA
        constexpr uint32_t TRANSFER_ERR_INT_RAW = (1U << 6);  ///< NA
        constexpr uint32_t TRANSFER_COMPLETE_INT_RAW = (1U << 7);  ///< NA
        constexpr uint32_t COMMAND_DONE_INT_RAW = (1U << 8);  ///< NA
        constexpr uint32_t DETECT_START_INT_RAW = (1U << 9);  ///< NA
        constexpr uint32_t RESP_BUF_OVF_INT_RAW = (1U << 10);  ///< NA
        constexpr uint32_t IBI_DATA_BUF_OVF_INT_RAW = (1U << 11);  ///< NA
        constexpr uint32_t IBI_STATUS_BUF_OVF_INT_RAW = (1U << 12);  ///< NA
        constexpr uint32_t IBI_HANDLE_DONE_INT_RAW = (1U << 13);  ///< NA
        constexpr uint32_t IBI_DETECT_INT_RAW = (1U << 14);  ///< NA
        constexpr uint32_t CMD_CCC_MISMATCH_INT_RAW = (1U << 15);  ///< NA
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TX_DATA_BUF_THLD_INT_ST = (1U << 0);  ///< This interrupt is generated when number of empty locations in transmit buffer is greater than or equal to threshold value specified by TX_EMPTY_BUS_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of empty locations in transmit buffer is less than threshold value.
        constexpr uint32_t RX_DATA_BUF_THLD_INT_ST = (1U << 1);  ///< This interrupt is generated when number of entries in receive buffer is greater than or equal to threshold value specified by RX_BUF_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in receive buffer is less than threshold value.
        constexpr uint32_t IBI_STATUS_THLD_INT_ST = (1U << 2);  ///< Only used in master mode. This interrupt is generated when number of entries in IBI buffer is greater than or equal to threshold value specified by IBI_BUF_THLD field in BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in IBI buffer is less than threshold value.
        constexpr uint32_t CMD_BUF_EMPTY_THLD_INT_ST = (1U << 3);  ///< This interrupt is generated when number of empty locations in command buffer is greater than or equal to threshold value specified by CMD_EMPTY_BUF_THLD field in BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of empty locations in command buffer is less than threshold value.
        constexpr uint32_t RESP_READY_INT_ST = (1U << 4);  ///< This interrupt is generated when number of entries in response buffer is greater than or equal to threshold value specified by RESP_BUF_THLD field in BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in response buffer is less than threshold value.
        constexpr uint32_t NXT_CMD_REQ_ERR_INT_ST = (1U << 5);  ///< This interrupt is generated if toc is 0(master will restart next command), but command buf is empty.
        constexpr uint32_t TRANSFER_ERR_INT_ST = (1U << 6);  ///< This interrupt is generated if any error occurs during transfer. The error type will be specified in the response packet associated with the command (in ERR_STATUS field of RESPONSE_BUFFER_PORT register). This bit can be cleared by writing 1'h1.
        constexpr uint32_t TRANSFER_COMPLETE_INT_ST = (1U << 7);  ///< NA
        constexpr uint32_t COMMAND_DONE_INT_ST = (1U << 8);  ///< NA
        constexpr uint32_t DETECT_START_INT_ST = (1U << 9);  ///< NA
        constexpr uint32_t RESP_BUF_OVF_INT_ST = (1U << 10);  ///< NA
        constexpr uint32_t IBI_DATA_BUF_OVF_INT_ST = (1U << 11);  ///< NA
        constexpr uint32_t IBI_STATUS_BUF_OVF_INT_ST = (1U << 12);  ///< NA
        constexpr uint32_t IBI_HANDLE_DONE_INT_ST = (1U << 13);  ///< NA
        constexpr uint32_t IBI_DETECT_INT_ST = (1U << 14);  ///< NA
        constexpr uint32_t CMD_CCC_MISMATCH_INT_ST = (1U << 15);  ///< NA
    }

    /// INT_ST_ENA Register bits
    namespace int_st_ena_bits {
        constexpr uint32_t TX_DATA_BUF_THLD_INT_ENA = (1U << 0);  ///< Transmit Buffer threshold status enable.
        constexpr uint32_t RX_DATA_BUF_THLD_INT_ENA = (1U << 1);  ///< Receive Buffer threshold status enable.
        constexpr uint32_t IBI_STATUS_THLD_INT_ENA = (1U << 2);  ///< Only used in master mode. IBI Buffer threshold status enable.
        constexpr uint32_t CMD_BUF_EMPTY_THLD_INT_ENA = (1U << 3);  ///< Command buffer ready status enable.
        constexpr uint32_t RESP_READY_INT_ENA = (1U << 4);  ///< Response buffer ready status enable.
        constexpr uint32_t NXT_CMD_REQ_ERR_INT_ENA = (1U << 5);  ///< next command request error status enable
        constexpr uint32_t TRANSFER_ERR_INT_ENA = (1U << 6);  ///< Transfer error status enable
        constexpr uint32_t TRANSFER_COMPLETE_INT_ENA = (1U << 7);  ///< NA
        constexpr uint32_t COMMAND_DONE_INT_ENA = (1U << 8);  ///< NA
        constexpr uint32_t DETECT_START_INT_ENA = (1U << 9);  ///< NA
        constexpr uint32_t RESP_BUF_OVF_INT_ENA = (1U << 10);  ///< NA
        constexpr uint32_t IBI_DATA_BUF_OVF_INT_ENA = (1U << 11);  ///< NA
        constexpr uint32_t IBI_STATUS_BUF_OVF_INT_ENA = (1U << 12);  ///< NA
        constexpr uint32_t IBI_HANDLE_DONE_INT_ENA = (1U << 13);  ///< NA
        constexpr uint32_t IBI_DETECT_INT_ENA = (1U << 14);  ///< NA
        constexpr uint32_t CMD_CCC_MISMATCH_INT_ENA = (1U << 15);  ///< NA
    }

    /// RESET_CTRL Register bits
    namespace reset_ctrl_bits {
        constexpr uint32_t REG_CORE_SOFT_RST = (1U << 0);  ///< NA
        constexpr uint32_t REG_CMD_BUF_RST = (1U << 1);  ///< NA
        constexpr uint32_t REG_RESP_BUF_RST = (1U << 2);  ///< NA
        constexpr uint32_t REG_TX_DATA_BUF_BUF_RST = (1U << 3);  ///< NA
        constexpr uint32_t REG_RX_DATA_BUF_RST = (1U << 4);  ///< NA
        constexpr uint32_t REG_IBI_DATA_BUF_RST = (1U << 5);  ///< NA
        constexpr uint32_t REG_IBI_STATUS_BUF_RST = (1U << 6);  ///< NA
    }

    /// BUFFER_STATUS_LEVEL Register bits
    namespace buffer_status_level_bits {
        constexpr uint32_t CMD_BUF_EMPTY_CNT = (5 << 0);  ///< Command Buffer Empty Locations contains the number of empty locations in the command buffer.
        constexpr uint32_t RESP_BUF_CNT = (4 << 8);  ///< Response Buffer Level Value contains the number of valid data entries in the response buffer.
        constexpr uint32_t IBI_DATA_BUF_CNT = (4 << 16);  ///< IBI Buffer Level Value contains the number of valid entries in the IBI Buffer. This is field is used in master mode.
        constexpr uint32_t IBI_STATUS_BUF_CNT = (4 << 24);  ///< IBI Buffer Status Count contains the number of IBI status entries in the IBI Buffer. This field is used in master mode.
    }

    /// DATA_BUFFER_STATUS_LEVEL Register bits
    namespace data_buffer_status_level_bits {
        constexpr uint32_t TX_DATA_BUF_EMPTY_CNT = (6 << 0);  ///< Transmit Buffer Empty Level Value contains the number of empty locations in the transmit Buffer.
        constexpr uint32_t RX_DATA_BUF_CNT = (6 << 16);  ///< Receive Buffer Level value contains the number of valid data entries in the receive buffer.
    }

    /// PRESENT_STATE0 Register bits
    namespace present_state0_bits {
        constexpr uint32_t SDA_LVL = (1U << 0);  ///< This bit is used to check the SCL line level to recover from error and for debugging. This bit reflects the value of synchronized scl_in_a.
        constexpr uint32_t SCL_LVL = (1U << 1);  ///< This bit is used to check the SDA line level to recover from error and for debugging. This bit reflects the value of synchronized sda_in_a.
        constexpr uint32_t BUS_BUSY = (1U << 2);  ///< NA
        constexpr uint32_t BUS_FREE = (1U << 3);  ///< NA
        constexpr uint32_t CMD_TID = (4 << 9);  ///< NA
        constexpr uint32_t SCL_GEN_FSM_STATE = (3 << 13);  ///< NA
        constexpr uint32_t IBI_EV_HANDLE_FSM_STATE = (3 << 16);  ///< NA
        constexpr uint32_t I2C_MODE_FSM_STATE = (3 << 19);  ///< NA
        constexpr uint32_t SDR_MODE_FSM_STATE = (4 << 22);  ///< NA
        constexpr uint32_t DAA_MODE_FSM_STATE = (3 << 26);  ///< Reflects whether the Master Controller is in IDLE or not. This bit will be set when all the buffer(Command, Response, IBI, Transmit, Receive) are empty along with the Master State machine is in idle state. 0X0: not in idle 0x1: in idle
        constexpr uint32_t MAIN_FSM_STATE = (3 << 29);  ///< NA
    }

    /// PRESENT_STATE1 Register bits
    namespace present_state1_bits {
        constexpr uint32_t DATA_BYTE_CNT = (16 << 0);  ///< Present transfer data byte cnt: tx data byte cnt if write rx data byte cnt if read ibi data byte cnt if IBI handle.
    }

    /// DEVICE_TABLE Register bits
    namespace device_table_bits {
        constexpr uint32_t REG_DCT_DAA_INIT_INDEX = (4 << 0);  ///< Reserved
        constexpr uint32_t REG_DAT_DAA_INIT_INDEX = (4 << 4);  ///< NA
        constexpr uint32_t PRESENT_DCT_INDEX = (4 << 8);  ///< NA
        constexpr uint32_t PRESENT_DAT_INDEX = (4 << 12);  ///< NA
    }

    /// TIME_OUT_VALUE Register bits
    namespace time_out_value_bits {
        constexpr uint32_t REG_RESP_BUF_TO_VALUE = (5 << 0);  ///< NA
        constexpr uint32_t REG_RESP_BUF_TO_EN = (1U << 5);  ///< NA
        constexpr uint32_t REG_IBI_DATA_BUF_TO_VALUE = (5 << 6);  ///< NA
        constexpr uint32_t REG_IBI_DATA_BUF_TO_EN = (1U << 11);  ///< NA
        constexpr uint32_t REG_IBI_STATUS_BUF_TO_VALUE = (5 << 12);  ///< NA
        constexpr uint32_t REG_IBI_STATUS_BUF_TO_EN = (1U << 17);  ///< NA
        constexpr uint32_t REG_RX_DATA_BUF_TO_VALUE = (5 << 18);  ///< NA
        constexpr uint32_t REG_RX_DATA_BUF_TO_EN = (1U << 23);  ///< NA
    }

    /// SCL_I3C_MST_OD_TIME Register bits
    namespace scl_i3c_mst_od_time_bits {
        constexpr uint32_t REG_I3C_MST_OD_LOW_PERIOD = (16 << 0);  ///< SCL Open-Drain low count for I3C transfers targeted to I3C devices.
        constexpr uint32_t REG_I3C_MST_OD_HIGH_PERIOD = (16 << 16);  ///< SCL Open-Drain High count for I3C transfers targeted to I3C devices.
    }

    /// SCL_I3C_MST_PP_TIME Register bits
    namespace scl_i3c_mst_pp_time_bits {
        constexpr uint32_t REG_I3C_MST_PP_LOW_PERIOD = (8 << 0);  ///< NA
        constexpr uint32_t REG_I3C_MST_PP_HIGH_PERIOD = (8 << 16);  ///< NA
    }

    /// SCL_I2C_FM_TIME Register bits
    namespace scl_i2c_fm_time_bits {
        constexpr uint32_t REG_I2C_FM_LOW_PERIOD = (16 << 0);  ///< NA
        constexpr uint32_t REG_I2C_FM_HIGH_PERIOD = (16 << 16);  ///< The SCL open-drain low count timing for I2C Fast Mode transfers.
    }

    /// SCL_I2C_FMP_TIME Register bits
    namespace scl_i2c_fmp_time_bits {
        constexpr uint32_t REG_I2C_FMP_LOW_PERIOD = (16 << 0);  ///< NA
        constexpr uint32_t REG_I2C_FMP_HIGH_PERIOD = (8 << 16);  ///< NA
    }

    /// SCL_EXT_LOW_TIME Register bits
    namespace scl_ext_low_time_bits {
        constexpr uint32_t REG_I3C_MST_EXT_LOW_PERIOD1 = (8 << 0);  ///< NA
        constexpr uint32_t REG_I3C_MST_EXT_LOW_PERIOD2 = (8 << 8);  ///< NA
        constexpr uint32_t REG_I3C_MST_EXT_LOW_PERIOD3 = (8 << 16);  ///< NA
        constexpr uint32_t REG_I3C_MST_EXT_LOW_PERIOD4 = (8 << 24);  ///< NA
    }

    /// SDA_SAMPLE_TIME Register bits
    namespace sda_sample_time_bits {
        constexpr uint32_t REG_SDA_OD_SAMPLE_TIME = (9 << 0);  ///< It is used to adjust sda sample point when scl high under open drain speed
        constexpr uint32_t REG_SDA_PP_SAMPLE_TIME = (5 << 9);  ///< It is used to adjust sda sample point when scl high under push pull speed
    }

    /// SDA_HOLD_TIME Register bits
    namespace sda_hold_time_bits {
        constexpr uint32_t REG_SDA_OD_TX_HOLD_TIME = (9 << 0);  ///< It is used to adjust sda drive point after scl neg under open drain speed
        constexpr uint32_t REG_SDA_PP_TX_HOLD_TIME = (5 << 9);  ///< It is used to adjust sda dirve point after scl neg under push pull speed
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t REG_SCL_START_HOLD_TIME = (9 << 0);  ///< I2C_SCL_START_HOLD_TIME
        constexpr uint32_t REG_START_DET_HOLD_TIME = (2 << 9);  ///< NA
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t REG_SCL_RSTART_SETUP_TIME = (9 << 0);  ///< I2C_SCL_RSTART_SETUP_TIME
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t REG_SCL_STOP_HOLD_TIME = (9 << 0);  ///< I2C_SCL_STOP_HOLD_TIME
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t REG_SCL_STOP_SETUP_TIME = (9 << 0);  ///< I2C_SCL_STOP_SETUP_TIME
    }

    /// BUS_FREE_TIME Register bits
    namespace bus_free_time_bits {
        constexpr uint32_t REG_BUS_FREE_TIME = (16 << 0);  ///< I3C Bus Free Count Value. This field is used only in Master mode. In pure Bus System, this field represents tCAS. In Mixed Bus System, this field is expected to be programmed to tLOW of I2C Timing.
    }

    /// SCL_TERMN_T_EXT_LOW_TIME Register bits
    namespace scl_termn_t_ext_low_time_bits {
        constexpr uint32_t REG_I3C_MST_TERMN_T_EXT_LOW_TIME = (8 << 0);  ///< NA
    }

    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t REG_I3C_MST_VER_ID = (32 << 0);  ///< This field indicates the controller current release number that is read by an application.
    }

    /// VER_TYPE Register bits
    namespace ver_type_bits {
        constexpr uint32_t REG_I3C_MST_VER_TYPE = (32 << 0);  ///< This field indicates the controller current release type that is read by an application.
    }

    /// FPGA_DEBUG_PROBE Register bits
    namespace fpga_debug_probe_bits {
        constexpr uint32_t REG_I3C_MST_FPGA_DEBUG_PROBE = (32 << 0);  ///< For Debug Probe Test on FPGA
    }

    /// RND_ECO_CS Register bits
    namespace rnd_eco_cs_bits {
        constexpr uint32_t REG_RND_ECO_EN = (1U << 0);  ///< NA
        constexpr uint32_t RND_ECO_RESULT = (1U << 1);  ///< NA
    }

    /// RND_ECO_LOW Register bits
    namespace rnd_eco_low_bits {
        constexpr uint32_t REG_RND_ECO_LOW = (32 << 0);  ///< NA
    }

    /// RND_ECO_HIGH Register bits
    namespace rnd_eco_high_bits {
        constexpr uint32_t REG_RND_ECO_HIGH = (32 << 0);  ///< NA
    }

}

// ============================================================================
// AXI Peripheral
// ============================================================================

namespace axi {
    /// Base addresses
    constexpr uint32_t AXI_ICM_BASE = 0x500A4000;

    /// AXI Register structure
    struct Registers {
        volatile uint32_t VERID_FILEDS;  ///< Offset: 0x00 - NA
        volatile uint32_t HW_CFG;  ///< Offset: 0x04 - NA
        volatile uint32_t CMD;  ///< Offset: 0x08 - NA
        volatile uint32_t DATA;  ///< Offset: 0x0C - NA
    };

    /// Peripheral instances
    inline Registers* AXI_ICM = reinterpret_cast<Registers*>(AXI_ICM_BASE);

    // Bit definitions
    /// VERID_FILEDS Register bits
    namespace verid_fileds_bits {
        constexpr uint32_t ICM_REG_VERID = (32 << 0);  ///< NA
    }

    /// HW_CFG Register bits
    namespace hw_cfg_bits {
        constexpr uint32_t ICM_REG_AXI_HWCFG_QOS_SUPPORT = (1U << 0);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_APB3_SUPPORT = (1U << 1);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_AXI4_SUPPORT = (1U << 2);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_LOCK_EN = (1U << 3);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_TRUST_ZONE_EN = (1U << 4);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_DECODER_TYPE = (1U << 5);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_REMAP_EN = (1U << 6);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_BI_DIR_CMD_EN = (1U << 7);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_LOW_POWER_INF_EN = (1U << 8);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_AXI_NUM_MASTERS = (5 << 12);  ///< NA
        constexpr uint32_t ICM_REG_AXI_HWCFG_AXI_NUM_SLAVES = (5 << 20);  ///< NA
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t ICM_REG_AXI_CMD = (3 << 0);  ///< NA
        constexpr uint32_t ICM_REG_RD_WR_CHAN = (1U << 7);  ///< NA
        constexpr uint32_t ICM_REG_AXI_MASTER_PORT = (4 << 8);  ///< NA
        constexpr uint32_t ICM_REG_AXI_ERR_BIT = (1U << 28);  ///< NA
        constexpr uint32_t ICM_REG_AXI_SOFT_RESET_BIT = (1U << 29);  ///< NA
        constexpr uint32_t ICM_REG_AXI_RD_WR_CMD = (1U << 30);  ///< NA
        constexpr uint32_t ICM_REG_AXI_CMD_EN = (1U << 31);  ///< NA
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t ICM_REG_DATA = (32 << 0);  ///< NA
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x500E1000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t DATE;  ///< Offset: 0x104 - iomux version
        volatile uint32_t GPIO%s;  ///< Offset: 0x04 - IO_MUX Control Register
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< csv date
    }

    /// GPIO%s Register bits
    namespace gpio%s_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Configures whether or not to enable the output of GPIOn in sleep mode. 0: Disable 1: Enable
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Configures whether or not to enter sleep mode for GPIOn. 0: Not enter 1: Enter
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Configure whether or not to enable pull-down resistor of GPIOn during sleep mode. 0: Disable 1: Enable
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Configures whether or not to enable pull-up resistor of GPIOn during sleep mode. 0: Disable 1: Enable
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Configures whether or not to enable the input of GPIOn during sleep mode. 0: Disable 1: Enable
        constexpr uint32_t MCU_DRV = (2 << 5);  ///< Configures the drive strength of GPIOn during sleep mode. 0: ~5 mA 1: ~10 mA 2: ~20 mA 3: ~40 mA
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Configures whether or not to enable pull-down resistor of GPIOn. 0: Disable 1: Enable
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Configures whether or not enable pull-up resistor of GPIOn. 0: Disable 1: Enable
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Configures whether or not to enable input of GPIOn. 0: Disable 1: Enable
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Configures the drive strength of GPIOn. 0: ~5 mA 1: ~10 mA 2: ~20 mA 3: ~40 mA
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Configures to select IO MUX function for this pin. 0: Select Function 0 1: Select Function 1 ......
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Configures whether or not to enable filter for pin input signals. 0: Disable 1: Enable
    }

}

// ============================================================================
// ISP Peripheral
// ============================================================================

namespace isp {
    /// Base addresses
    constexpr uint32_t ISP_BASE = 0x500A1000;

    /// ISP Register structure
    struct Registers {
        volatile uint32_t VER_DATE;  ///< Offset: 0x00 - version control register
        volatile uint32_t CLK_EN;  ///< Offset: 0x04 - isp clk control register
        volatile uint32_t CNTL;  ///< Offset: 0x08 - isp module enable control register
        volatile uint32_t HSYNC_CNT;  ///< Offset: 0x0C - header hsync interval control register
        volatile uint32_t FRAME_CFG;  ///< Offset: 0x10 - frame control parameter register
        volatile uint32_t CCM_COEF0;  ///< Offset: 0x14 - ccm coef register 0
        volatile uint32_t CCM_COEF1;  ///< Offset: 0x18 - ccm coef register 1
        volatile uint32_t CCM_COEF3;  ///< Offset: 0x1C - ccm coef register 3
        volatile uint32_t CCM_COEF4;  ///< Offset: 0x20 - ccm coef register 4
        volatile uint32_t CCM_COEF5;  ///< Offset: 0x24 - ccm coef register 5
        volatile uint32_t BF_MATRIX_CTRL;  ///< Offset: 0x28 - bf pix2matrix ctrl
        volatile uint32_t BF_SIGMA;  ///< Offset: 0x2C - bf denoising level control register
        volatile uint32_t BF_GAU0;  ///< Offset: 0x30 - bf gau template register 0
        volatile uint32_t BF_GAU1;  ///< Offset: 0x34 - bf gau template register 1
        volatile uint32_t DPC_CTRL;  ///< Offset: 0x38 - DPC mode control register
        volatile uint32_t DPC_CONF;  ///< Offset: 0x3C - DPC parameter config register
        volatile uint32_t DPC_MATRIX_CTRL;  ///< Offset: 0x40 - dpc pix2matrix ctrl
        volatile uint32_t DPC_DEADPIX_CNT;  ///< Offset: 0x44 - DPC dead-pix number register
        volatile uint32_t LUT_CMD;  ///< Offset: 0x48 - LUT command register
        volatile uint32_t LUT_WDATA;  ///< Offset: 0x4C - LUT write data register
        volatile uint32_t LUT_RDATA;  ///< Offset: 0x50 - LUT read data register
        volatile uint32_t LSC_TABLESIZE;  ///< Offset: 0x54 - LSC point in x-direction
        volatile uint32_t DEMOSAIC_MATRIX_CTRL;  ///< Offset: 0x58 - demosaic pix2matrix ctrl
        volatile uint32_t DEMOSAIC_GRAD_RATIO;  ///< Offset: 0x5C - demosaic gradient select ratio
        volatile uint32_t MEDIAN_MATRIX_CTRL;  ///< Offset: 0x60 - median pix2matrix ctrl
        volatile uint32_t INT_RAW;  ///< Offset: 0x64 - raw interrupt register
        volatile uint32_t INT_ST;  ///< Offset: 0x68 - masked interrupt register
        volatile uint32_t INT_ENA;  ///< Offset: 0x6C - interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0x70 - interrupt clear register
        volatile uint32_t GAMMA_CTRL;  ///< Offset: 0x74 - gamma control register
        volatile uint32_t GAMMA_RY1;  ///< Offset: 0x78 - point of Y-axis of r channel gamma curve register 1
        volatile uint32_t GAMMA_RY2;  ///< Offset: 0x7C - point of Y-axis of r channel gamma curve register 2
        volatile uint32_t GAMMA_RY3;  ///< Offset: 0x80 - point of Y-axis of r channel gamma curve register 3
        volatile uint32_t GAMMA_RY4;  ///< Offset: 0x84 - point of Y-axis of r channel gamma curve register 4
        volatile uint32_t GAMMA_GY1;  ///< Offset: 0x88 - point of Y-axis of g channel gamma curve register 1
        volatile uint32_t GAMMA_GY2;  ///< Offset: 0x8C - point of Y-axis of g channel gamma curve register 2
        volatile uint32_t GAMMA_GY3;  ///< Offset: 0x90 - point of Y-axis of g channel gamma curve register 3
        volatile uint32_t GAMMA_GY4;  ///< Offset: 0x94 - point of Y-axis of g channel gamma curve register 4
        volatile uint32_t GAMMA_BY1;  ///< Offset: 0x98 - point of Y-axis of b channel gamma curve register 1
        volatile uint32_t GAMMA_BY2;  ///< Offset: 0x9C - point of Y-axis of b channel gamma curve register 2
        volatile uint32_t GAMMA_BY3;  ///< Offset: 0xA0 - point of Y-axis of b channel gamma curve register 3
        volatile uint32_t GAMMA_BY4;  ///< Offset: 0xA4 - point of Y-axis of b channel gamma curve register 4
        volatile uint32_t GAMMA_RX1;  ///< Offset: 0xA8 - point of X-axis of r channel gamma curve register 1
        volatile uint32_t GAMMA_RX2;  ///< Offset: 0xAC - point of X-axis of r channel gamma curve register 2
        volatile uint32_t GAMMA_GX1;  ///< Offset: 0xB0 - point of X-axis of g channel gamma curve register 1
        volatile uint32_t GAMMA_GX2;  ///< Offset: 0xB4 - point of X-axis of g channel gamma curve register 2
        volatile uint32_t GAMMA_BX1;  ///< Offset: 0xB8 - point of X-axis of b channel gamma curve register 1
        volatile uint32_t GAMMA_BX2;  ///< Offset: 0xBC - point of X-axis of b channel gamma curve register 2
        volatile uint32_t AE_CTRL;  ///< Offset: 0xC0 - ae control register
        volatile uint32_t AE_MONITOR;  ///< Offset: 0xC4 - ae monitor control register
        volatile uint32_t AE_BX;  ///< Offset: 0xC8 - ae window register in x-direction
        volatile uint32_t AE_BY;  ///< Offset: 0xCC - ae window register in y-direction
        volatile uint32_t AE_WINPIXNUM;  ///< Offset: 0xD0 - ae sub-window pix num register
        volatile uint32_t AE_WIN_RECIPROCAL;  ///< Offset: 0xD4 - reciprocal of ae sub-window pixel number
        volatile uint32_t AE_BLOCK_MEAN_0;  ///< Offset: 0xD8 - ae statistic result register 0
        volatile uint32_t AE_BLOCK_MEAN_1;  ///< Offset: 0xDC - ae statistic result register 1
        volatile uint32_t AE_BLOCK_MEAN_2;  ///< Offset: 0xE0 - ae statistic result register 2
        volatile uint32_t AE_BLOCK_MEAN_3;  ///< Offset: 0xE4 - ae statistic result register 3
        volatile uint32_t AE_BLOCK_MEAN_4;  ///< Offset: 0xE8 - ae statistic result register 4
        volatile uint32_t AE_BLOCK_MEAN_5;  ///< Offset: 0xEC - ae statistic result register 5
        volatile uint32_t AE_BLOCK_MEAN_6;  ///< Offset: 0xF0 - ae statistic result register 6
        volatile uint32_t SHARP_CTRL0;  ///< Offset: 0xF4 - sharp control register 0
        volatile uint32_t SHARP_FILTER0;  ///< Offset: 0xF8 - sharp usm config register 0
        volatile uint32_t SHARP_FILTER1;  ///< Offset: 0xFC - sharp usm config register 1
        volatile uint32_t SHARP_FILTER2;  ///< Offset: 0x100 - sharp usm config register 2
        volatile uint32_t SHARP_MATRIX_CTRL;  ///< Offset: 0x104 - sharp pix2matrix ctrl
        volatile uint32_t SHARP_CTRL1;  ///< Offset: 0x108 - sharp control register 1
        volatile uint32_t DMA_CNTL;  ///< Offset: 0x10C - isp dma source trans control register
        volatile uint32_t DMA_RAW_DATA;  ///< Offset: 0x110 - isp dma source total raw number set register
        volatile uint32_t CAM_CNTL;  ///< Offset: 0x114 - isp cam source control register
        volatile uint32_t CAM_CONF;  ///< Offset: 0x118 - isp cam source config register
        volatile uint32_t AF_CTRL0;  ///< Offset: 0x11C - af control register 0
        volatile uint32_t AF_CTRL1;  ///< Offset: 0x120 - af control register 1
        volatile uint32_t AF_GEN_TH_CTRL;  ///< Offset: 0x124 - af gen threshold control register
        volatile uint32_t AF_ENV_USER_TH_SUM;  ///< Offset: 0x128 - af monitor user sum threshold register
        volatile uint32_t AF_ENV_USER_TH_LUM;  ///< Offset: 0x12C - af monitor user lum threshold register
        volatile uint32_t AF_THRESHOLD;  ///< Offset: 0x130 - af threshold register
        volatile uint32_t AF_HSCALE_A;  ///< Offset: 0x134 - h-scale of af window a register
        volatile uint32_t AF_VSCALE_A;  ///< Offset: 0x138 - v-scale of af window a register
        volatile uint32_t AF_HSCALE_B;  ///< Offset: 0x13C - h-scale of af window b register
        volatile uint32_t AF_VSCALE_B;  ///< Offset: 0x140 - v-scale of af window b register
        volatile uint32_t AF_HSCALE_C;  ///< Offset: 0x144 - v-scale of af window c register
        volatile uint32_t AF_VSCALE_C;  ///< Offset: 0x148 - v-scale of af window c register
        volatile uint32_t AF_SUM_A;  ///< Offset: 0x14C - result of sum of af window a
        volatile uint32_t AF_SUM_B;  ///< Offset: 0x150 - result of sum of af window b
        volatile uint32_t AF_SUM_C;  ///< Offset: 0x154 - result of sum of af window c
        volatile uint32_t AF_LUM_A;  ///< Offset: 0x158 - result of lum of af window a
        volatile uint32_t AF_LUM_B;  ///< Offset: 0x15C - result of lum of af window b
        volatile uint32_t AF_LUM_C;  ///< Offset: 0x160 - result of lum of af window c
        volatile uint32_t AWB_MODE;  ///< Offset: 0x164 - awb mode control register
        volatile uint32_t AWB_HSCALE;  ///< Offset: 0x168 - h-scale of awb window
        volatile uint32_t AWB_VSCALE;  ///< Offset: 0x16C - v-scale of awb window
        volatile uint32_t AWB_TH_LUM;  ///< Offset: 0x170 - awb lum threshold register
        volatile uint32_t AWB_TH_RG;  ///< Offset: 0x174 - awb r/g threshold register
        volatile uint32_t AWB_TH_BG;  ///< Offset: 0x178 - awb b/g threshold register
        volatile uint32_t AWB0_WHITE_CNT;  ///< Offset: 0x17C - result of awb white point number
        volatile uint32_t AWB0_ACC_R;  ///< Offset: 0x180 - result of accumulate of r channel of all white points
        volatile uint32_t AWB0_ACC_G;  ///< Offset: 0x184 - result of accumulate of g channel of all white points
        volatile uint32_t AWB0_ACC_B;  ///< Offset: 0x188 - result of accumulate of b channel of all white points
        volatile uint32_t COLOR_CTRL;  ///< Offset: 0x18C - color control register
        volatile uint32_t BLC_VALUE;  ///< Offset: 0x190 - blc black level register
        volatile uint32_t BLC_CTRL0;  ///< Offset: 0x194 - blc stretch control register
        volatile uint32_t BLC_CTRL1;  ///< Offset: 0x198 - blc window control register
        volatile uint32_t BLC_CTRL2;  ///< Offset: 0x19C - blc black threshold control register
        volatile uint32_t BLC_MEAN;  ///< Offset: 0x1A0 - results of the average of black window
        volatile uint32_t HIST_MODE;  ///< Offset: 0x1A4 - histogram mode control register
        volatile uint32_t HIST_COEFF;  ///< Offset: 0x1A8 - histogram rgb to gray coefficients register
        volatile uint32_t HIST_OFFS;  ///< Offset: 0x1AC - histogram window offsets register
        volatile uint32_t HIST_SIZE;  ///< Offset: 0x1B0 - histogram sub-window size register
        volatile uint32_t HIST_SEG0;  ///< Offset: 0x1B4 - histogram bin control register 0
        volatile uint32_t HIST_SEG1;  ///< Offset: 0x1B8 - histogram bin control register 1
        volatile uint32_t HIST_SEG2;  ///< Offset: 0x1BC - histogram bin control register 2
        volatile uint32_t HIST_SEG3;  ///< Offset: 0x1C0 - histogram bin control register 3
        volatile uint32_t HIST_WEIGHT0;  ///< Offset: 0x1C4 - histogram sub-window weight register 0
        volatile uint32_t HIST_WEIGHT1;  ///< Offset: 0x1C8 - histogram sub-window weight register 1
        volatile uint32_t HIST_WEIGHT2;  ///< Offset: 0x1CC - histogram sub-window weight register 2
        volatile uint32_t HIST_WEIGHT3;  ///< Offset: 0x1D0 - histogram sub-window weight register 3
        volatile uint32_t HIST_WEIGHT4;  ///< Offset: 0x1D4 - histogram sub-window weight register 4
        volatile uint32_t HIST_WEIGHT5;  ///< Offset: 0x1D8 - histogram sub-window weight register 5
        volatile uint32_t HIST_WEIGHT6;  ///< Offset: 0x1DC - histogram sub-window weight register 6
        volatile uint32_t HIST_BIN0;  ///< Offset: 0x1E0 - result of histogram bin 0
        volatile uint32_t HIST_BIN1;  ///< Offset: 0x1E4 - result of histogram bin 1
        volatile uint32_t HIST_BIN2;  ///< Offset: 0x1E8 - result of histogram bin 2
        volatile uint32_t HIST_BIN3;  ///< Offset: 0x1EC - result of histogram bin 3
        volatile uint32_t HIST_BIN4;  ///< Offset: 0x1F0 - result of histogram bin 4
        volatile uint32_t HIST_BIN5;  ///< Offset: 0x1F4 - result of histogram bin 5
        volatile uint32_t HIST_BIN6;  ///< Offset: 0x1F8 - result of histogram bin 6
        volatile uint32_t HIST_BIN7;  ///< Offset: 0x1FC - result of histogram bin 7
        volatile uint32_t HIST_BIN8;  ///< Offset: 0x200 - result of histogram bin 8
        volatile uint32_t HIST_BIN9;  ///< Offset: 0x204 - result of histogram bin 9
        volatile uint32_t HIST_BIN10;  ///< Offset: 0x208 - result of histogram bin 10
        volatile uint32_t HIST_BIN11;  ///< Offset: 0x20C - result of histogram bin 11
        volatile uint32_t HIST_BIN12;  ///< Offset: 0x210 - result of histogram bin 12
        volatile uint32_t HIST_BIN13;  ///< Offset: 0x214 - result of histogram bin 13
        volatile uint32_t HIST_BIN14;  ///< Offset: 0x218 - result of histogram bin 14
        volatile uint32_t HIST_BIN15;  ///< Offset: 0x21C - result of histogram bin 15
        volatile uint32_t MEM_AUX_CTRL_0;  ///< Offset: 0x220 - mem aux control register 0
        volatile uint32_t MEM_AUX_CTRL_1;  ///< Offset: 0x224 - mem aux control register 1
        volatile uint32_t MEM_AUX_CTRL_2;  ///< Offset: 0x228 - mem aux control register 2
        volatile uint32_t MEM_AUX_CTRL_3;  ///< Offset: 0x22C - mem aux control register 3
        volatile uint32_t MEM_AUX_CTRL_4;  ///< Offset: 0x230 - mem aux control register 4
        volatile uint32_t YUV_FORMAT;  ///< Offset: 0x234 - yuv format control register
        volatile uint32_t RDN_ECO_CS;  ///< Offset: 0x238 - rdn eco cs register
        volatile uint32_t RDN_ECO_LOW;  ///< Offset: 0x23C - rdn eco all low register
        volatile uint32_t RDN_ECO_HIGH;  ///< Offset: 0x240 - rdn eco all high register
    };

    /// Peripheral instances
    inline Registers* ISP = reinterpret_cast<Registers*>(ISP_BASE);

    // Bit definitions
    /// VER_DATE Register bits
    namespace ver_date_bits {
        constexpr uint32_t VER_DATA = (32 << 0);  ///< csv version
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< this bit configures the clk force on of isp reg. 0: disable, 1: enable
        constexpr uint32_t CLK_BLC_FORCE_ON = (1U << 1);  ///< this bit configures the clk force on of blc. 0: disable, 1: enable
        constexpr uint32_t CLK_DPC_FORCE_ON = (1U << 2);  ///< this bit configures the clk force on of dpc. 0: disable, 1: enable
        constexpr uint32_t CLK_BF_FORCE_ON = (1U << 3);  ///< this bit configures the clk force on of bf. 0: disable, 1: enable
        constexpr uint32_t CLK_LSC_FORCE_ON = (1U << 4);  ///< this bit configures the clk force on of lsc. 0: disable, 1: enable
        constexpr uint32_t CLK_DEMOSAIC_FORCE_ON = (1U << 5);  ///< this bit configures the clk force on of demosaic. 0: disable, 1: enable
        constexpr uint32_t CLK_MEDIAN_FORCE_ON = (1U << 6);  ///< this bit configures the clk force on of median. 0: disable, 1: enable
        constexpr uint32_t CLK_CCM_FORCE_ON = (1U << 7);  ///< this bit configures the clk force on of ccm. 0: disable, 1: enable
        constexpr uint32_t CLK_GAMMA_FORCE_ON = (1U << 8);  ///< this bit configures the clk force on of gamma. 0: disable, 1: enable
        constexpr uint32_t CLK_RGB2YUV_FORCE_ON = (1U << 9);  ///< this bit configures the clk force on of rgb2yuv. 0: disable, 1: enable
        constexpr uint32_t CLK_SHARP_FORCE_ON = (1U << 10);  ///< this bit configures the clk force on of sharp. 0: disable, 1: enable
        constexpr uint32_t CLK_COLOR_FORCE_ON = (1U << 11);  ///< this bit configures the clk force on of color. 0: disable, 1: enable
        constexpr uint32_t CLK_YUV2RGB_FORCE_ON = (1U << 12);  ///< this bit configures the clk force on of yuv2rgb. 0: disable, 1: enable
        constexpr uint32_t CLK_AE_FORCE_ON = (1U << 13);  ///< this bit configures the clk force on of ae. 0: disable, 1: enable
        constexpr uint32_t CLK_AF_FORCE_ON = (1U << 14);  ///< this bit configures the clk force on of af. 0: disable, 1: enable
        constexpr uint32_t CLK_AWB_FORCE_ON = (1U << 15);  ///< this bit configures the clk force on of awb. 0: disable, 1: enable
        constexpr uint32_t CLK_HIST_FORCE_ON = (1U << 16);  ///< this bit configures the clk force on of hist. 0: disable, 1: enable
        constexpr uint32_t CLK_MIPI_IDI_FORCE_ON = (1U << 17);  ///< this bit configures the clk force on of mipi idi input. 0: disable, 1: enable
        constexpr uint32_t ISP_MEM_CLK_FORCE_ON = (1U << 18);  ///< this bit configures the clk force on of all isp memory. 0: disable, 1: enable
    }

    /// CNTL Register bits
    namespace cntl_bits {
        constexpr uint32_t MIPI_DATA_EN = (1U << 0);  ///< this bit configures mipi input data enable. 0: disable, 1: enable
        constexpr uint32_t ISP_EN = (1U << 1);  ///< this bit configures isp global enable. 0: disable, 1: enable
        constexpr uint32_t BLC_EN = (1U << 2);  ///< this bit configures blc enable. 0: disable, 1: enable
        constexpr uint32_t DPC_EN = (1U << 3);  ///< this bit configures dpc enable. 0: disable, 1: enable
        constexpr uint32_t BF_EN = (1U << 4);  ///< this bit configures bf enable. 0: disable, 1: enable
        constexpr uint32_t LSC_EN = (1U << 5);  ///< this bit configures lsc enable. 0: disable, 1: enable
        constexpr uint32_t DEMOSAIC_EN = (1U << 6);  ///< this bit configures demosaic enable. 0: disable, 1: enable
        constexpr uint32_t MEDIAN_EN = (1U << 7);  ///< this bit configures median enable. 0: disable, 1: enable
        constexpr uint32_t CCM_EN = (1U << 8);  ///< this bit configures ccm enable. 0: disable, 1: enable
        constexpr uint32_t GAMMA_EN = (1U << 9);  ///< this bit configures gamma enable. 0: disable, 1: enable
        constexpr uint32_t RGB2YUV_EN = (1U << 10);  ///< this bit configures rgb2yuv enable. 0: disable, 1: enable
        constexpr uint32_t SHARP_EN = (1U << 11);  ///< this bit configures sharp enable. 0: disable, 1: enable
        constexpr uint32_t COLOR_EN = (1U << 12);  ///< this bit configures color enable. 0: disable, 1: enable
        constexpr uint32_t YUV2RGB_EN = (1U << 13);  ///< this bit configures yuv2rgb enable. 0: disable, 1: enable
        constexpr uint32_t AE_EN = (1U << 14);  ///< this bit configures ae enable. 0: disable, 1: enable
        constexpr uint32_t AF_EN = (1U << 15);  ///< this bit configures af enable. 0: disable, 1: enable
        constexpr uint32_t AWB_EN = (1U << 16);  ///< this bit configures awb enable. 0: disable, 1: enable
        constexpr uint32_t HIST_EN = (1U << 17);  ///< this bit configures hist enable. 0: disable, 1: enable
        constexpr uint32_t BYTE_ENDIAN_ORDER = (1U << 24);  ///< select input idi data byte_endian_order when isp is bypass, 0: csi_data[31:0], 1: {[7:0], [15:8], [23:16], [31:24]}
        constexpr uint32_t ISP_DATA_TYPE = (2 << 25);  ///< this field configures input data type, 0:RAW8 1:RAW10 2:RAW12
        constexpr uint32_t ISP_IN_SRC = (2 << 27);  ///< this field configures input data source, 0:CSI HOST 1:CAM 2:DMA
        constexpr uint32_t ISP_OUT_TYPE = (3 << 29);  ///< this field configures pixel output type, 0: RAW8 1: YUV422 2: RGB888 3: YUV420 4: RGB565
    }

    /// HSYNC_CNT Register bits
    namespace hsync_cnt_bits {
        constexpr uint32_t HSYNC_CNT = (8 << 0);  ///< this field configures the number of clock before hsync and after vsync and line_end when decodes pix data from idi to isp
    }

    /// FRAME_CFG Register bits
    namespace frame_cfg_bits {
        constexpr uint32_t VADR_NUM = (12 << 0);  ///< this field configures input image size in y-direction, image row number - 1
        constexpr uint32_t HADR_NUM = (12 << 12);  ///< this field configures input image size in x-direction, image line number - 1
        constexpr uint32_t BAYER_MODE = (2 << 27);  ///< this field configures the bayer mode of input pixel. 00 : BG/GR 01 : GB/RG 10 : GR/BG 11 : RG/GB
        constexpr uint32_t HSYNC_START_EXIST = (1U << 29);  ///< this bit configures the line end packet exist or not. 0: not exist, 1: exist
        constexpr uint32_t HSYNC_END_EXIST = (1U << 30);  ///< this bit configures the line start packet exist or not. 0: not exist, 1: exist
    }

    /// CCM_COEF0 Register bits
    namespace ccm_coef0_bits {
        constexpr uint32_t CCM_RR = (13 << 0);  ///< this field configures the color correction matrix coefficient
        constexpr uint32_t CCM_RG = (13 << 13);  ///< this field configures the color correction matrix coefficient
    }

    /// CCM_COEF1 Register bits
    namespace ccm_coef1_bits {
        constexpr uint32_t CCM_RB = (13 << 0);  ///< this field configures the color correction matrix coefficient
        constexpr uint32_t CCM_GR = (13 << 13);  ///< this field configures the color correction matrix coefficient
    }

    /// CCM_COEF3 Register bits
    namespace ccm_coef3_bits {
        constexpr uint32_t CCM_GG = (13 << 0);  ///< this field configures the color correction matrix coefficient
        constexpr uint32_t CCM_GB = (13 << 13);  ///< this field configures the color correction matrix coefficient
    }

    /// CCM_COEF4 Register bits
    namespace ccm_coef4_bits {
        constexpr uint32_t CCM_BR = (13 << 0);  ///< this field configures the color correction matrix coefficient
        constexpr uint32_t CCM_BG = (13 << 13);  ///< this field configures the color correction matrix coefficient
    }

    /// CCM_COEF5 Register bits
    namespace ccm_coef5_bits {
        constexpr uint32_t CCM_BB = (13 << 0);  ///< this field configures the color correction matrix coefficient
    }

    /// BF_MATRIX_CTRL Register bits
    namespace bf_matrix_ctrl_bits {
        constexpr uint32_t BF_TAIL_PIXEN_PULSE_TL = (8 << 0);  ///< matrix tail pixen low level threshold, should not to large to prevent expanding to next frame, only reg_bf_tail_pixen_pulse_th!=0 and reg_bf_tail_pixen_pulse_tl!=0 and reg_bf_tail_pixen_pulse_th < reg_bf_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t BF_TAIL_PIXEN_PULSE_TH = (8 << 8);  ///< matrix tail pixen high level threshold, must < hnum-1, only reg_bf_tail_pixen_pulse_th!=0 and reg_bf_tail_pixen_pulse_tl!=0 and reg_bf_tail_pixen_pulse_th < reg_bf_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t BF_PADDING_DATA = (8 << 16);  ///< this field configures bf matrix padding data
        constexpr uint32_t BF_PADDING_MODE = (1U << 24);  ///< this bit configures the padding mode of bf matrix. 0: use pixel in image to do padding 1: use reg_padding_data to do padding
    }

    /// BF_SIGMA Register bits
    namespace bf_sigma_bits {
        constexpr uint32_t SIGMA = (6 << 0);  ///< this field configures the bayer denoising level, valid data from 2 to 20
    }

    /// BF_GAU0 Register bits
    namespace bf_gau0_bits {
        constexpr uint32_t GAU_TEMPLATE21 = (4 << 0);  ///< this field configures index 21 of gausian template
        constexpr uint32_t GAU_TEMPLATE20 = (4 << 4);  ///< this field configures index 20 of gausian template
        constexpr uint32_t GAU_TEMPLATE12 = (4 << 8);  ///< this field configures index 12 of gausian template
        constexpr uint32_t GAU_TEMPLATE11 = (4 << 12);  ///< this field configures index 11 of gausian template
        constexpr uint32_t GAU_TEMPLATE10 = (4 << 16);  ///< this field configures index 10 of gausian template
        constexpr uint32_t GAU_TEMPLATE02 = (4 << 20);  ///< this field configures index 02 of gausian template
        constexpr uint32_t GAU_TEMPLATE01 = (4 << 24);  ///< this field configures index 01 of gausian template
        constexpr uint32_t GAU_TEMPLATE00 = (4 << 28);  ///< this field configures index 00 of gausian template
    }

    /// BF_GAU1 Register bits
    namespace bf_gau1_bits {
        constexpr uint32_t GAU_TEMPLATE22 = (4 << 0);  ///< this field configures index 22 of gausian template
    }

    /// DPC_CTRL Register bits
    namespace dpc_ctrl_bits {
        constexpr uint32_t DPC_CHECK_EN = (1U << 0);  ///< this bit configures the check mode enable. 0: disable, 1: enable
        constexpr uint32_t STA_EN = (1U << 1);  ///< this bit configures the sta dpc enable. 0: disable, 1: enable
        constexpr uint32_t DYN_EN = (1U << 2);  ///< this bit configures the dyn dpc enable. 0: disable, 1: enable
        constexpr uint32_t DPC_BLACK_EN = (1U << 3);  ///< this bit configures input image type select when in check mode, 0: white img, 1: black img
        constexpr uint32_t DPC_METHOD_SEL = (1U << 4);  ///< this bit configures dyn dpc method select. 0: simple method, 1: hard method
        constexpr uint32_t DPC_CHECK_OD_EN = (1U << 5);  ///< this bit configures output pixel data when in check mode or not. 0: no data output, 1: data output
    }

    /// DPC_CONF Register bits
    namespace dpc_conf_bits {
        constexpr uint32_t DPC_THRESHOLD_L = (8 << 0);  ///< this bit configures the threshold to detect black img in check mode, or the low threshold(use 8 bit 0~255) in dyn method 0, or the low threshold factor (use 5 bit 10000-> 16/16, 00001->1/16, 0/16~16/16) in dyn method 1
        constexpr uint32_t DPC_THRESHOLD_H = (8 << 8);  ///< this bit configures the threshold to detect white img in check mode, or the high threshold(use 8 bit 0~255) in dyn method 0, or the high threshold factor (use 5 bit 10000-> 16/16, 00001->1/16, 0/16~16/16) in dyn method 1
        constexpr uint32_t DPC_FACTOR_DARK = (6 << 16);  ///< this field configures the dynamic correction method 1 dark factor
        constexpr uint32_t DPC_FACTOR_BRIG = (6 << 22);  ///< this field configures the dynamic correction method 1 bright factor
    }

    /// DPC_MATRIX_CTRL Register bits
    namespace dpc_matrix_ctrl_bits {
        constexpr uint32_t DPC_TAIL_PIXEN_PULSE_TL = (8 << 0);  ///< matrix tail pixen low level threshold, should not to large to prevent expanding to next frame, only reg_dpc_tail_pixen_pulse_th!=0 and reg_dpc_tail_pixen_pulse_tl!=0 and reg_dpc_tail_pixen_pulse_th < reg_dpc_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t DPC_TAIL_PIXEN_PULSE_TH = (8 << 8);  ///< matrix tail pixen high level threshold, must < hnum-1, only reg_dpc_tail_pixen_pulse_th!=0 and reg_dpc_tail_pixen_pulse_tl!=0 and reg_dpc_tail_pixen_pulse_th < reg_dpc_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t DPC_PADDING_DATA = (8 << 16);  ///< this field configures dpc matrix padding data
        constexpr uint32_t DPC_PADDING_MODE = (1U << 24);  ///< this bit configures the padding mode of dpc matrix. 0: use pixel in image to do padding 1: use reg_padding_data to do padding
    }

    /// DPC_DEADPIX_CNT Register bits
    namespace dpc_deadpix_cnt_bits {
        constexpr uint32_t DPC_DEADPIX_CNT = (10 << 0);  ///< this field represents the dead pixel count
    }

    /// LUT_CMD Register bits
    namespace lut_cmd_bits {
        constexpr uint32_t LUT_ADDR = (12 << 0);  ///< this field configures the lut access addr, when select lsc lut, [11:10]:00 sel gb_b lut, 01 sel r_gr lut
        constexpr uint32_t LUT_NUM = (4 << 12);  ///< this field configures the lut selection. 0000:LSC LUT 0001:DPC LUT
        constexpr uint32_t LUT_CMD = (1U << 16);  ///< this bit configures the access event of lut. 0:rd 1: wr
    }

    /// LUT_WDATA Register bits
    namespace lut_wdata_bits {
        constexpr uint32_t LUT_WDATA = (32 << 0);  ///< this field configures the write data of lut. please initial ISP_LUT_WDATA before write ISP_LUT_CMD register
    }

    /// LUT_RDATA Register bits
    namespace lut_rdata_bits {
        constexpr uint32_t LUT_RDATA = (32 << 0);  ///< this field represents the read data of lut. read ISP_LUT_RDATA after write ISP_LUT_CMD register
    }

    /// LSC_TABLESIZE Register bits
    namespace lsc_tablesize_bits {
        constexpr uint32_t LSC_XTABLESIZE = (5 << 0);  ///< this field configures lsc table size in x-direction
    }

    /// DEMOSAIC_MATRIX_CTRL Register bits
    namespace demosaic_matrix_ctrl_bits {
        constexpr uint32_t DEMOSAIC_TAIL_PIXEN_PULSE_TL = (8 << 0);  ///< matrix tail pixen low level threshold, should not to large to prevent expanding to next frame, only reg_demosaic_tail_pixen_pulse_th!=0 and reg_demosaic_tail_pixen_pulse_tl!=0 and reg_demosaic_tail_pixen_pulse_th < reg_demosaic_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t DEMOSAIC_TAIL_PIXEN_PULSE_TH = (8 << 8);  ///< matrix tail pixen high level threshold, must < hnum-1, only reg_demosaic_tail_pixen_pulse_th!=0 and reg_demosaic_tail_pixen_pulse_tl!=0 and reg_demosaic_tail_pixen_pulse_th < reg_demosaic_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t DEMOSAIC_PADDING_DATA = (8 << 16);  ///< this field configures demosaic matrix padding data
        constexpr uint32_t DEMOSAIC_PADDING_MODE = (1U << 24);  ///< this bit configures the padding mode of demosaic matrix. 0: use pixel in image to do padding 1: use reg_padding_data to do padding
    }

    /// DEMOSAIC_GRAD_RATIO Register bits
    namespace demosaic_grad_ratio_bits {
        constexpr uint32_t DEMOSAIC_GRAD_RATIO = (6 << 0);  ///< this field configures demosaic gradient select ratio
    }

    /// MEDIAN_MATRIX_CTRL Register bits
    namespace median_matrix_ctrl_bits {
        constexpr uint32_t MEDIAN_PADDING_DATA = (8 << 0);  ///< this field configures median matrix padding data
        constexpr uint32_t MEDIAN_PADDING_MODE = (1U << 8);  ///< this bit configures the padding mode of median matrix. 0: use pixel in image to do padding 1: use reg_padding_data to do padding
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t ISP_DATA_TYPE_ERR_INT_RAW = (1U << 0);  ///< the raw interrupt status of input data type error. isp only support RGB bayer data type, other type will report type_err_int
        constexpr uint32_t ISP_ASYNC_FIFO_OVF_INT_RAW = (1U << 1);  ///< the raw interrupt status of isp input fifo overflow
        constexpr uint32_t ISP_BUF_FULL_INT_RAW = (1U << 2);  ///< the raw interrupt status of isp input buffer full
        constexpr uint32_t ISP_HVNUM_SETTING_ERR_INT_RAW = (1U << 3);  ///< the raw interrupt status of hnum and vnum setting format error
        constexpr uint32_t ISP_DATA_TYPE_SETTING_ERR_INT_RAW = (1U << 4);  ///< the raw interrupt status of setting invalid reg_data_type
        constexpr uint32_t ISP_MIPI_HNUM_UNMATCH_INT_RAW = (1U << 5);  ///< the raw interrupt status of hnum setting unmatch with mipi input
        constexpr uint32_t DPC_CHECK_DONE_INT_RAW = (1U << 6);  ///< the raw interrupt status of dpc check done
        constexpr uint32_t GAMMA_XCOORD_ERR_INT_RAW = (1U << 7);  ///< the raw interrupt status of gamma setting error. it report the sum of the lengths represented by reg_gamma_x00~x0F isn't equal to 256
        constexpr uint32_t AE_MONITOR_INT_RAW = (1U << 8);  ///< the raw interrupt status of ae monitor
        constexpr uint32_t AE_FRAME_DONE_INT_RAW = (1U << 9);  ///< the raw interrupt status of ae.
        constexpr uint32_t AF_FDONE_INT_RAW = (1U << 10);  ///< the raw interrupt status of af statistic. when auto_update enable, each frame done will send one int pulse when manual_update, each time when write 1 to reg_manual_update will send a int pulse when next frame done
        constexpr uint32_t AF_ENV_INT_RAW = (1U << 11);  ///< the raw interrupt status of af monitor. send a int pulse when env_det function enabled and environment changes detected
        constexpr uint32_t AWB_FDONE_INT_RAW = (1U << 12);  ///< the raw interrupt status of awb. send a int pulse when statistic of one awb frame done
        constexpr uint32_t HIST_FDONE_INT_RAW = (1U << 13);  ///< the raw interrupt status of histogram. send a int pulse when statistic of one frame histogram done
        constexpr uint32_t FRAME_INT_RAW = (1U << 14);  ///< the raw interrupt status of isp frame end
        constexpr uint32_t BLC_FRAME_INT_RAW = (1U << 15);  ///< the raw interrupt status of blc frame done
        constexpr uint32_t LSC_FRAME_INT_RAW = (1U << 16);  ///< the raw interrupt status of lsc frame done
        constexpr uint32_t DPC_FRAME_INT_RAW = (1U << 17);  ///< the raw interrupt status of dpc frame done
        constexpr uint32_t BF_FRAME_INT_RAW = (1U << 18);  ///< the raw interrupt status of bf frame done
        constexpr uint32_t DEMOSAIC_FRAME_INT_RAW = (1U << 19);  ///< the raw interrupt status of demosaic frame done
        constexpr uint32_t MEDIAN_FRAME_INT_RAW = (1U << 20);  ///< the raw interrupt status of median frame done
        constexpr uint32_t CCM_FRAME_INT_RAW = (1U << 21);  ///< the raw interrupt status of ccm frame done
        constexpr uint32_t GAMMA_FRAME_INT_RAW = (1U << 22);  ///< the raw interrupt status of gamma frame done
        constexpr uint32_t RGB2YUV_FRAME_INT_RAW = (1U << 23);  ///< the raw interrupt status of rgb2yuv frame done
        constexpr uint32_t SHARP_FRAME_INT_RAW = (1U << 24);  ///< the raw interrupt status of sharp frame done
        constexpr uint32_t COLOR_FRAME_INT_RAW = (1U << 25);  ///< the raw interrupt status of color frame done
        constexpr uint32_t YUV2RGB_FRAME_INT_RAW = (1U << 26);  ///< the raw interrupt status of yuv2rgb frame done
        constexpr uint32_t TAIL_IDI_FRAME_INT_RAW = (1U << 27);  ///< the raw interrupt status of isp_tail idi frame_end
        constexpr uint32_t HEADER_IDI_FRAME_INT_RAW = (1U << 28);  ///< the raw interrupt status of real input frame end of isp_input
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t ISP_DATA_TYPE_ERR_INT_ST = (1U << 0);  ///< the masked interrupt status of input data type error
        constexpr uint32_t ISP_ASYNC_FIFO_OVF_INT_ST = (1U << 1);  ///< the masked interrupt status of isp input fifo overflow
        constexpr uint32_t ISP_BUF_FULL_INT_ST = (1U << 2);  ///< the masked interrupt status of isp input buffer full
        constexpr uint32_t ISP_HVNUM_SETTING_ERR_INT_ST = (1U << 3);  ///< the masked interrupt status of hnum and vnum setting format error
        constexpr uint32_t ISP_DATA_TYPE_SETTING_ERR_INT_ST = (1U << 4);  ///< the masked interrupt status of setting invalid reg_data_type
        constexpr uint32_t ISP_MIPI_HNUM_UNMATCH_INT_ST = (1U << 5);  ///< the masked interrupt status of hnum setting unmatch with mipi input
        constexpr uint32_t DPC_CHECK_DONE_INT_ST = (1U << 6);  ///< the masked interrupt status of dpc check done
        constexpr uint32_t GAMMA_XCOORD_ERR_INT_ST = (1U << 7);  ///< the masked interrupt status of gamma setting error
        constexpr uint32_t AE_MONITOR_INT_ST = (1U << 8);  ///< the masked interrupt status of ae monitor
        constexpr uint32_t AE_FRAME_DONE_INT_ST = (1U << 9);  ///< the masked interrupt status of ae
        constexpr uint32_t AF_FDONE_INT_ST = (1U << 10);  ///< the masked interrupt status of af statistic
        constexpr uint32_t AF_ENV_INT_ST = (1U << 11);  ///< the masked interrupt status of af monitor
        constexpr uint32_t AWB_FDONE_INT_ST = (1U << 12);  ///< the masked interrupt status of awb
        constexpr uint32_t HIST_FDONE_INT_ST = (1U << 13);  ///< the masked interrupt status of histogram
        constexpr uint32_t FRAME_INT_ST = (1U << 14);  ///< the masked interrupt status of isp frame end
        constexpr uint32_t BLC_FRAME_INT_ST = (1U << 15);  ///< the masked interrupt status of blc frame done
        constexpr uint32_t LSC_FRAME_INT_ST = (1U << 16);  ///< the masked interrupt status of lsc frame done
        constexpr uint32_t DPC_FRAME_INT_ST = (1U << 17);  ///< the masked interrupt status of dpc frame done
        constexpr uint32_t BF_FRAME_INT_ST = (1U << 18);  ///< the masked interrupt status of bf frame done
        constexpr uint32_t DEMOSAIC_FRAME_INT_ST = (1U << 19);  ///< the masked interrupt status of demosaic frame done
        constexpr uint32_t MEDIAN_FRAME_INT_ST = (1U << 20);  ///< the masked interrupt status of median frame done
        constexpr uint32_t CCM_FRAME_INT_ST = (1U << 21);  ///< the masked interrupt status of ccm frame done
        constexpr uint32_t GAMMA_FRAME_INT_ST = (1U << 22);  ///< the masked interrupt status of gamma frame done
        constexpr uint32_t RGB2YUV_FRAME_INT_ST = (1U << 23);  ///< the masked interrupt status of rgb2yuv frame done
        constexpr uint32_t SHARP_FRAME_INT_ST = (1U << 24);  ///< the masked interrupt status of sharp frame done
        constexpr uint32_t COLOR_FRAME_INT_ST = (1U << 25);  ///< the masked interrupt status of color frame done
        constexpr uint32_t YUV2RGB_FRAME_INT_ST = (1U << 26);  ///< the masked interrupt status of yuv2rgb frame done
        constexpr uint32_t TAIL_IDI_FRAME_INT_ST = (1U << 27);  ///< the masked interrupt status of isp_tail idi frame_end
        constexpr uint32_t HEADER_IDI_FRAME_INT_ST = (1U << 28);  ///< the masked interrupt status of real input frame end of isp_input
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t ISP_DATA_TYPE_ERR_INT_ENA = (1U << 0);  ///< write 1 to enable input data type error
        constexpr uint32_t ISP_ASYNC_FIFO_OVF_INT_ENA = (1U << 1);  ///< write 1 to enable isp input fifo overflow
        constexpr uint32_t ISP_BUF_FULL_INT_ENA = (1U << 2);  ///< write 1 to enable isp input buffer full
        constexpr uint32_t ISP_HVNUM_SETTING_ERR_INT_ENA = (1U << 3);  ///< write 1 to enable hnum and vnum setting format error
        constexpr uint32_t ISP_DATA_TYPE_SETTING_ERR_INT_ENA = (1U << 4);  ///< write 1 to enable setting invalid reg_data_type
        constexpr uint32_t ISP_MIPI_HNUM_UNMATCH_INT_ENA = (1U << 5);  ///< write 1 to enable hnum setting unmatch with mipi input
        constexpr uint32_t DPC_CHECK_DONE_INT_ENA = (1U << 6);  ///< write 1 to enable dpc check done
        constexpr uint32_t GAMMA_XCOORD_ERR_INT_ENA = (1U << 7);  ///< write 1 to enable gamma setting error
        constexpr uint32_t AE_MONITOR_INT_ENA = (1U << 8);  ///< write 1 to enable ae monitor
        constexpr uint32_t AE_FRAME_DONE_INT_ENA = (1U << 9);  ///< write 1 to enable ae
        constexpr uint32_t AF_FDONE_INT_ENA = (1U << 10);  ///< write 1 to enable af statistic
        constexpr uint32_t AF_ENV_INT_ENA = (1U << 11);  ///< write 1 to enable af monitor
        constexpr uint32_t AWB_FDONE_INT_ENA = (1U << 12);  ///< write 1 to enable awb
        constexpr uint32_t HIST_FDONE_INT_ENA = (1U << 13);  ///< write 1 to enable histogram
        constexpr uint32_t FRAME_INT_ENA = (1U << 14);  ///< write 1 to enable isp frame end
        constexpr uint32_t BLC_FRAME_INT_ENA = (1U << 15);  ///< write 1 to enable blc frame done
        constexpr uint32_t LSC_FRAME_INT_ENA = (1U << 16);  ///< write 1 to enable lsc frame done
        constexpr uint32_t DPC_FRAME_INT_ENA = (1U << 17);  ///< write 1 to enable dpc frame done
        constexpr uint32_t BF_FRAME_INT_ENA = (1U << 18);  ///< write 1 to enable bf frame done
        constexpr uint32_t DEMOSAIC_FRAME_INT_ENA = (1U << 19);  ///< write 1 to enable demosaic frame done
        constexpr uint32_t MEDIAN_FRAME_INT_ENA = (1U << 20);  ///< write 1 to enable median frame done
        constexpr uint32_t CCM_FRAME_INT_ENA = (1U << 21);  ///< write 1 to enable ccm frame done
        constexpr uint32_t GAMMA_FRAME_INT_ENA = (1U << 22);  ///< write 1 to enable gamma frame done
        constexpr uint32_t RGB2YUV_FRAME_INT_ENA = (1U << 23);  ///< write 1 to enable rgb2yuv frame done
        constexpr uint32_t SHARP_FRAME_INT_ENA = (1U << 24);  ///< write 1 to enable sharp frame done
        constexpr uint32_t COLOR_FRAME_INT_ENA = (1U << 25);  ///< write 1 to enable color frame done
        constexpr uint32_t YUV2RGB_FRAME_INT_ENA = (1U << 26);  ///< write 1 to enable yuv2rgb frame done
        constexpr uint32_t TAIL_IDI_FRAME_INT_ENA = (1U << 27);  ///< write 1 to enable isp_tail idi frame_end
        constexpr uint32_t HEADER_IDI_FRAME_INT_ENA = (1U << 28);  ///< write 1 to enable real input frame end of isp_input
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t ISP_DATA_TYPE_ERR_INT_CLR = (1U << 0);  ///< write 1 to clear input data type error
        constexpr uint32_t ISP_ASYNC_FIFO_OVF_INT_CLR = (1U << 1);  ///< write 1 to clear isp input fifo overflow
        constexpr uint32_t ISP_BUF_FULL_INT_CLR = (1U << 2);  ///< write 1 to clear isp input buffer full
        constexpr uint32_t ISP_HVNUM_SETTING_ERR_INT_CLR = (1U << 3);  ///< write 1 to clear hnum and vnum setting format error
        constexpr uint32_t ISP_DATA_TYPE_SETTING_ERR_INT_CLR = (1U << 4);  ///< write 1 to clear setting invalid reg_data_type
        constexpr uint32_t ISP_MIPI_HNUM_UNMATCH_INT_CLR = (1U << 5);  ///< write 1 to clear hnum setting unmatch with mipi input
        constexpr uint32_t DPC_CHECK_DONE_INT_CLR = (1U << 6);  ///< write 1 to clear dpc check done
        constexpr uint32_t GAMMA_XCOORD_ERR_INT_CLR = (1U << 7);  ///< write 1 to clear gamma setting error
        constexpr uint32_t AE_MONITOR_INT_CLR = (1U << 8);  ///< write 1 to clear ae monitor
        constexpr uint32_t AE_FRAME_DONE_INT_CLR = (1U << 9);  ///< write 1 to clear ae
        constexpr uint32_t AF_FDONE_INT_CLR = (1U << 10);  ///< write 1 to clear af statistic
        constexpr uint32_t AF_ENV_INT_CLR = (1U << 11);  ///< write 1 to clear af monitor
        constexpr uint32_t AWB_FDONE_INT_CLR = (1U << 12);  ///< write 1 to clear awb
        constexpr uint32_t HIST_FDONE_INT_CLR = (1U << 13);  ///< write 1 to clear histogram
        constexpr uint32_t FRAME_INT_CLR = (1U << 14);  ///< write 1 to clear isp frame end
        constexpr uint32_t BLC_FRAME_INT_CLR = (1U << 15);  ///< write 1 to clear blc frame done
        constexpr uint32_t LSC_FRAME_INT_CLR = (1U << 16);  ///< write 1 to clear lsc frame done
        constexpr uint32_t DPC_FRAME_INT_CLR = (1U << 17);  ///< write 1 to clear dpc frame done
        constexpr uint32_t BF_FRAME_INT_CLR = (1U << 18);  ///< write 1 to clear bf frame done
        constexpr uint32_t DEMOSAIC_FRAME_INT_CLR = (1U << 19);  ///< write 1 to clear demosaic frame done
        constexpr uint32_t MEDIAN_FRAME_INT_CLR = (1U << 20);  ///< write 1 to clear median frame done
        constexpr uint32_t CCM_FRAME_INT_CLR = (1U << 21);  ///< write 1 to clear ccm frame done
        constexpr uint32_t GAMMA_FRAME_INT_CLR = (1U << 22);  ///< write 1 to clear gamma frame done
        constexpr uint32_t RGB2YUV_FRAME_INT_CLR = (1U << 23);  ///< write 1 to clear rgb2yuv frame done
        constexpr uint32_t SHARP_FRAME_INT_CLR = (1U << 24);  ///< write 1 to clear sharp frame done
        constexpr uint32_t COLOR_FRAME_INT_CLR = (1U << 25);  ///< write 1 to clear color frame done
        constexpr uint32_t YUV2RGB_FRAME_INT_CLR = (1U << 26);  ///< write 1 to clear yuv2rgb frame done
        constexpr uint32_t TAIL_IDI_FRAME_INT_CLR = (1U << 27);  ///< write 1 to clear isp_tail idi frame_end
        constexpr uint32_t HEADER_IDI_FRAME_INT_CLR = (1U << 28);  ///< write 1 to clear real input frame end of isp_input
    }

    /// GAMMA_CTRL Register bits
    namespace gamma_ctrl_bits {
        constexpr uint32_t GAMMA_UPDATE = (1U << 0);  ///< Indicates that gamma register configuration is complete
        constexpr uint32_t GAMMA_B_LAST_CORRECT = (1U << 1);  ///< this bit configures enable of last b segment correcction. 0: disable, 1: enable
        constexpr uint32_t GAMMA_G_LAST_CORRECT = (1U << 2);  ///< this bit configures enable of last g segment correcction. 0: disable, 1: enable
        constexpr uint32_t GAMMA_R_LAST_CORRECT = (1U << 3);  ///< this bit configures enable of last r segment correcction. 0: disable, 1: enable
    }

    /// GAMMA_RY1 Register bits
    namespace gamma_ry1_bits {
        constexpr uint32_t GAMMA_R_Y03 = (8 << 0);  ///< this field configures the point 3 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y02 = (8 << 8);  ///< this field configures the point 2 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y01 = (8 << 16);  ///< this field configures the point 1 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y00 = (8 << 24);  ///< this field configures the point 0 of Y-axis of r channel gamma curve
    }

    /// GAMMA_RY2 Register bits
    namespace gamma_ry2_bits {
        constexpr uint32_t GAMMA_R_Y07 = (8 << 0);  ///< this field configures the point 7 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y06 = (8 << 8);  ///< this field configures the point 6 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y05 = (8 << 16);  ///< this field configures the point 5 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y04 = (8 << 24);  ///< this field configures the point 4 of Y-axis of r channel gamma curve
    }

    /// GAMMA_RY3 Register bits
    namespace gamma_ry3_bits {
        constexpr uint32_t GAMMA_R_Y0B = (8 << 0);  ///< this field configures the point 11 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y0A = (8 << 8);  ///< this field configures the point 10 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y09 = (8 << 16);  ///< this field configures the point 9 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y08 = (8 << 24);  ///< this field configures the point 8 of Y-axis of r channel gamma curve
    }

    /// GAMMA_RY4 Register bits
    namespace gamma_ry4_bits {
        constexpr uint32_t GAMMA_R_Y0F = (8 << 0);  ///< this field configures the point 15 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y0E = (8 << 8);  ///< this field configures the point 14 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y0D = (8 << 16);  ///< this field configures the point 13 of Y-axis of r channel gamma curve
        constexpr uint32_t GAMMA_R_Y0C = (8 << 24);  ///< this field configures the point 12 of Y-axis of r channel gamma curve
    }

    /// GAMMA_GY1 Register bits
    namespace gamma_gy1_bits {
        constexpr uint32_t GAMMA_G_Y03 = (8 << 0);  ///< this field configures the point 3 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y02 = (8 << 8);  ///< this field configures the point 2 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y01 = (8 << 16);  ///< this field configures the point 1 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y00 = (8 << 24);  ///< this field configures the point 0 of Y-axis of g channel gamma curve
    }

    /// GAMMA_GY2 Register bits
    namespace gamma_gy2_bits {
        constexpr uint32_t GAMMA_G_Y07 = (8 << 0);  ///< this field configures the point 7 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y06 = (8 << 8);  ///< this field configures the point 6 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y05 = (8 << 16);  ///< this field configures the point 5 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y04 = (8 << 24);  ///< this field configures the point 4 of Y-axis of g channel gamma curve
    }

    /// GAMMA_GY3 Register bits
    namespace gamma_gy3_bits {
        constexpr uint32_t GAMMA_G_Y0B = (8 << 0);  ///< this field configures the point 11 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y0A = (8 << 8);  ///< this field configures the point 10 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y09 = (8 << 16);  ///< this field configures the point 9 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y08 = (8 << 24);  ///< this field configures the point 8 of Y-axis of g channel gamma curve
    }

    /// GAMMA_GY4 Register bits
    namespace gamma_gy4_bits {
        constexpr uint32_t GAMMA_G_Y0F = (8 << 0);  ///< this field configures the point 15 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y0E = (8 << 8);  ///< this field configures the point 14 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y0D = (8 << 16);  ///< this field configures the point 13 of Y-axis of g channel gamma curve
        constexpr uint32_t GAMMA_G_Y0C = (8 << 24);  ///< this field configures the point 12 of Y-axis of g channel gamma curve
    }

    /// GAMMA_BY1 Register bits
    namespace gamma_by1_bits {
        constexpr uint32_t GAMMA_B_Y03 = (8 << 0);  ///< this field configures the point 3 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y02 = (8 << 8);  ///< this field configures the point 2 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y01 = (8 << 16);  ///< this field configures the point 1 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y00 = (8 << 24);  ///< this field configures the point 0 of Y-axis of b channel gamma curve
    }

    /// GAMMA_BY2 Register bits
    namespace gamma_by2_bits {
        constexpr uint32_t GAMMA_B_Y07 = (8 << 0);  ///< this field configures the point 7 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y06 = (8 << 8);  ///< this field configures the point 6 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y05 = (8 << 16);  ///< this field configures the point 5 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y04 = (8 << 24);  ///< this field configures the point 4 of Y-axis of b channel gamma curve
    }

    /// GAMMA_BY3 Register bits
    namespace gamma_by3_bits {
        constexpr uint32_t GAMMA_B_Y0B = (8 << 0);  ///< this field configures the point 11 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y0A = (8 << 8);  ///< this field configures the point 10 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y09 = (8 << 16);  ///< this field configures the point 9 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y08 = (8 << 24);  ///< this field configures the point 8 of Y-axis of b channel gamma curve
    }

    /// GAMMA_BY4 Register bits
    namespace gamma_by4_bits {
        constexpr uint32_t GAMMA_B_Y0F = (8 << 0);  ///< this field configures the point 15 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y0E = (8 << 8);  ///< this field configures the point 14 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y0D = (8 << 16);  ///< this field configures the point 13 of Y-axis of b channel gamma curve
        constexpr uint32_t GAMMA_B_Y0C = (8 << 24);  ///< this field configures the point 12 of Y-axis of b channel gamma curve
    }

    /// GAMMA_RX1 Register bits
    namespace gamma_rx1_bits {
        constexpr uint32_t GAMMA_R_X07 = (3 << 0);  ///< this field configures the point 7 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X06 = (3 << 3);  ///< this field configures the point 6 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X05 = (3 << 6);  ///< this field configures the point 5 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X04 = (3 << 9);  ///< this field configures the point 4 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X03 = (3 << 12);  ///< this field configures the point 3 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X02 = (3 << 15);  ///< this field configures the point 2 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X01 = (3 << 18);  ///< this field configures the point 1 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X00 = (3 << 21);  ///< this field configures the point 0 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
    }

    /// GAMMA_RX2 Register bits
    namespace gamma_rx2_bits {
        constexpr uint32_t GAMMA_R_X0F = (3 << 0);  ///< this field configures the point 15 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X0E = (3 << 3);  ///< this field configures the point 14 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X0D = (3 << 6);  ///< this field configures the point 13 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X0C = (3 << 9);  ///< this field configures the point 12 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X0B = (3 << 12);  ///< this field configures the point 11 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X0A = (3 << 15);  ///< this field configures the point 10 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X09 = (3 << 18);  ///< this field configures the point 9 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_R_X08 = (3 << 21);  ///< this field configures the point 8 of X-axis of r channel gamma curve, it represents the power of the distance from the previous point
    }

    /// GAMMA_GX1 Register bits
    namespace gamma_gx1_bits {
        constexpr uint32_t GAMMA_G_X07 = (3 << 0);  ///< this field configures the point 7 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X06 = (3 << 3);  ///< this field configures the point 6 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X05 = (3 << 6);  ///< this field configures the point 5 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X04 = (3 << 9);  ///< this field configures the point 4 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X03 = (3 << 12);  ///< this field configures the point 3 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X02 = (3 << 15);  ///< this field configures the point 2 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X01 = (3 << 18);  ///< this field configures the point 1 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X00 = (3 << 21);  ///< this field configures the point 0 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
    }

    /// GAMMA_GX2 Register bits
    namespace gamma_gx2_bits {
        constexpr uint32_t GAMMA_G_X0F = (3 << 0);  ///< this field configures the point 15 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X0E = (3 << 3);  ///< this field configures the point 14 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X0D = (3 << 6);  ///< this field configures the point 13 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X0C = (3 << 9);  ///< this field configures the point 12 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X0B = (3 << 12);  ///< this field configures the point 11 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X0A = (3 << 15);  ///< this field configures the point 10 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X09 = (3 << 18);  ///< this field configures the point 9 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_G_X08 = (3 << 21);  ///< this field configures the point 8 of X-axis of g channel gamma curve, it represents the power of the distance from the previous point
    }

    /// GAMMA_BX1 Register bits
    namespace gamma_bx1_bits {
        constexpr uint32_t GAMMA_B_X07 = (3 << 0);  ///< this field configures the point 7 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X06 = (3 << 3);  ///< this field configures the point 6 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X05 = (3 << 6);  ///< this field configures the point 5 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X04 = (3 << 9);  ///< this field configures the point 4 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X03 = (3 << 12);  ///< this field configures the point 3 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X02 = (3 << 15);  ///< this field configures the point 2 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X01 = (3 << 18);  ///< this field configures the point 1 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X00 = (3 << 21);  ///< this field configures the point 0 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
    }

    /// GAMMA_BX2 Register bits
    namespace gamma_bx2_bits {
        constexpr uint32_t GAMMA_B_X0F = (3 << 0);  ///< this field configures the point 15 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X0E = (3 << 3);  ///< this field configures the point 14 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X0D = (3 << 6);  ///< this field configures the point 13 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X0C = (3 << 9);  ///< this field configures the point 12 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X0B = (3 << 12);  ///< this field configures the point 11 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X0A = (3 << 15);  ///< this field configures the point 10 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X09 = (3 << 18);  ///< this field configures the point 9 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
        constexpr uint32_t GAMMA_B_X08 = (3 << 21);  ///< this field configures the point 8 of X-axis of b channel gamma curve, it represents the power of the distance from the previous point
    }

    /// AE_CTRL Register bits
    namespace ae_ctrl_bits {
        constexpr uint32_t AE_UPDATE = (1U << 0);  ///< write 1 to this bit triggers one statistic event
        constexpr uint32_t AE_SELECT = (1U << 1);  ///< this field configures ae input data source, 0: data from median, 1: data from gama
    }

    /// AE_MONITOR Register bits
    namespace ae_monitor_bits {
        constexpr uint32_t TL = (8 << 0);  ///< this field configures the lower lum threshold of ae monitor
        constexpr uint32_t TH = (8 << 8);  ///< this field configures the higher lum threshold of ae monitor
        constexpr uint32_t PERIOD = (6 << 16);  ///< this field cnfigures ae monitor frame period
    }

    /// AE_BX Register bits
    namespace ae_bx_bits {
        constexpr uint32_t AE_X_BSIZE = (11 << 0);  ///< this field configures every block x size
        constexpr uint32_t AE_X_START = (11 << 11);  ///< this field configures first block start x address
    }

    /// AE_BY Register bits
    namespace ae_by_bits {
        constexpr uint32_t AE_Y_BSIZE = (11 << 0);  ///< this field configures every block y size
        constexpr uint32_t AE_Y_START = (11 << 11);  ///< this field configures first block start y address
    }

    /// AE_WINPIXNUM Register bits
    namespace ae_winpixnum_bits {
        constexpr uint32_t AE_SUBWIN_PIXNUM = (17 << 0);  ///< this field configures the pixel number of each sub win
    }

    /// AE_WIN_RECIPROCAL Register bits
    namespace ae_win_reciprocal_bits {
        constexpr uint32_t AE_SUBWIN_RECIP = (20 << 0);  ///< this field configures the reciprocal of each subwin_pixnum, 20bit fraction
    }

    /// AE_BLOCK_MEAN_0 Register bits
    namespace ae_block_mean_0_bits {
        constexpr uint32_t AE_B03_MEAN = (8 << 0);  ///< this field configures block03 Y mean data
        constexpr uint32_t AE_B02_MEAN = (8 << 8);  ///< this field configures block02 Y mean data
        constexpr uint32_t AE_B01_MEAN = (8 << 16);  ///< this field configures block01 Y mean data
        constexpr uint32_t AE_B00_MEAN = (8 << 24);  ///< this field configures block00 Y mean data
    }

    /// AE_BLOCK_MEAN_1 Register bits
    namespace ae_block_mean_1_bits {
        constexpr uint32_t AE_B12_MEAN = (8 << 0);  ///< this field configures block12 Y mean data
        constexpr uint32_t AE_B11_MEAN = (8 << 8);  ///< this field configures block11 Y mean data
        constexpr uint32_t AE_B10_MEAN = (8 << 16);  ///< this field configures block10 Y mean data
        constexpr uint32_t AE_B04_MEAN = (8 << 24);  ///< this field configures block04 Y mean data
    }

    /// AE_BLOCK_MEAN_2 Register bits
    namespace ae_block_mean_2_bits {
        constexpr uint32_t AE_B21_MEAN = (8 << 0);  ///< this field configures block21 Y mean data
        constexpr uint32_t AE_B20_MEAN = (8 << 8);  ///< this field configures block20 Y mean data
        constexpr uint32_t AE_B14_MEAN = (8 << 16);  ///< this field configures block14 Y mean data
        constexpr uint32_t AE_B13_MEAN = (8 << 24);  ///< this field configures block13 Y mean data
    }

    /// AE_BLOCK_MEAN_3 Register bits
    namespace ae_block_mean_3_bits {
        constexpr uint32_t AE_B30_MEAN = (8 << 0);  ///< this field configures block30 Y mean data
        constexpr uint32_t AE_B24_MEAN = (8 << 8);  ///< this field configures block24 Y mean data
        constexpr uint32_t AE_B23_MEAN = (8 << 16);  ///< this field configures block23 Y mean data
        constexpr uint32_t AE_B22_MEAN = (8 << 24);  ///< this field configures block22 Y mean data
    }

    /// AE_BLOCK_MEAN_4 Register bits
    namespace ae_block_mean_4_bits {
        constexpr uint32_t AE_B34_MEAN = (8 << 0);  ///< this field configures block34 Y mean data
        constexpr uint32_t AE_B33_MEAN = (8 << 8);  ///< this field configures block33 Y mean data
        constexpr uint32_t AE_B32_MEAN = (8 << 16);  ///< this field configures block32 Y mean data
        constexpr uint32_t AE_B31_MEAN = (8 << 24);  ///< this field configures block31 Y mean data
    }

    /// AE_BLOCK_MEAN_5 Register bits
    namespace ae_block_mean_5_bits {
        constexpr uint32_t AE_B43_MEAN = (8 << 0);  ///< this field configures block43 Y mean data
        constexpr uint32_t AE_B42_MEAN = (8 << 8);  ///< this field configures block42 Y mean data
        constexpr uint32_t AE_B41_MEAN = (8 << 16);  ///< this field configures block41 Y mean data
        constexpr uint32_t AE_B40_MEAN = (8 << 24);  ///< this field configures block40 Y mean data
    }

    /// AE_BLOCK_MEAN_6 Register bits
    namespace ae_block_mean_6_bits {
        constexpr uint32_t AE_B44_MEAN = (8 << 24);  ///< this field configures block44 Y mean data
    }

    /// SHARP_CTRL0 Register bits
    namespace sharp_ctrl0_bits {
        constexpr uint32_t SHARP_THRESHOLD_LOW = (8 << 0);  ///< this field configures sharpen threshold for detail
        constexpr uint32_t SHARP_THRESHOLD_HIGH = (8 << 8);  ///< this field configures sharpen threshold for edge
        constexpr uint32_t SHARP_AMOUNT_LOW = (8 << 16);  ///< this field configures sharpen amount for detail
        constexpr uint32_t SHARP_AMOUNT_HIGH = (8 << 24);  ///< this field configures sharpen amount for edge
    }

    /// SHARP_FILTER0 Register bits
    namespace sharp_filter0_bits {
        constexpr uint32_t SHARP_FILTER_COE00 = (5 << 0);  ///< this field configures unsharp masking(usm) filter coefficient
        constexpr uint32_t SHARP_FILTER_COE01 = (5 << 5);  ///< this field configures usm filter coefficient
        constexpr uint32_t SHARP_FILTER_COE02 = (5 << 10);  ///< this field configures usm filter coefficient
    }

    /// SHARP_FILTER1 Register bits
    namespace sharp_filter1_bits {
        constexpr uint32_t SHARP_FILTER_COE10 = (5 << 0);  ///< this field configures usm filter coefficient
        constexpr uint32_t SHARP_FILTER_COE11 = (5 << 5);  ///< this field configures usm filter coefficient
        constexpr uint32_t SHARP_FILTER_COE12 = (5 << 10);  ///< this field configures usm filter coefficient
    }

    /// SHARP_FILTER2 Register bits
    namespace sharp_filter2_bits {
        constexpr uint32_t SHARP_FILTER_COE20 = (5 << 0);  ///< this field configures usm filter coefficient
        constexpr uint32_t SHARP_FILTER_COE21 = (5 << 5);  ///< this field configures usm filter coefficient
        constexpr uint32_t SHARP_FILTER_COE22 = (5 << 10);  ///< this field configures usm filter coefficient
    }

    /// SHARP_MATRIX_CTRL Register bits
    namespace sharp_matrix_ctrl_bits {
        constexpr uint32_t SHARP_TAIL_PIXEN_PULSE_TL = (8 << 0);  ///< matrix tail pixen low level threshold, should not to large to prevent expanding to next frame, only reg_demosaic_tail_pixen_pulse_th!=0 and reg_demosaic_tail_pixen_pulse_tl!=0 and reg_demosaic_tail_pixen_pulse_th < reg_demosaic_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t SHARP_TAIL_PIXEN_PULSE_TH = (8 << 8);  ///< matrix tail pixen high level threshold, must < hnum-1, only reg_sharp_tail_pixen_pulse_th!=0 and reg_sharp_tail_pixen_pulse_tl!=0 and reg_sharp_tail_pixen_pulse_th < reg_sharp_tail_pixen_pulse_tl will enable tail pulse function
        constexpr uint32_t SHARP_PADDING_DATA = (8 << 16);  ///< this field configures sharp padding data
        constexpr uint32_t SHARP_PADDING_MODE = (1U << 24);  ///< this field configures sharp padding mode
    }

    /// SHARP_CTRL1 Register bits
    namespace sharp_ctrl1_bits {
        constexpr uint32_t SHARP_GRADIENT_MAX = (8 << 0);  ///< this field configures sharp max gradient, refresh at the end of each frame end
    }

    /// DMA_CNTL Register bits
    namespace dma_cntl_bits {
        constexpr uint32_t DMA_EN = (1U << 0);  ///< write 1 to triger dma to get 1 frame
        constexpr uint32_t DMA_UPDATE = (1U << 1);  ///< write 1 to update reg_dma_burst_len & reg_dma_data_type
        constexpr uint32_t DMA_DATA_TYPE = (6 << 2);  ///< this field configures the idi data type for image data
        constexpr uint32_t DMA_BURST_LEN = (12 << 8);  ///< this field configures dma burst len when data source is dma. set according to dma_msize, it is the number of 64bits in a dma transfer
        constexpr uint32_t DMA_INTERVAL = (12 << 20);  ///< this field configures dma req interval, 12'b1: 1 cycle, 12'b11 2 cycle ...
    }

    /// DMA_RAW_DATA Register bits
    namespace dma_raw_data_bits {
        constexpr uint32_t DMA_RAW_NUM_TOTAL = (22 << 0);  ///< this field configures the the number of 64bits in a frame
        constexpr uint32_t DMA_RAW_NUM_TOTAL_SET = (1U << 31);  ///< write 1 to update reg_dma_raw_num_total
    }

    /// CAM_CNTL Register bits
    namespace cam_cntl_bits {
        constexpr uint32_t CAM_EN = (1U << 0);  ///< write 1 to start recive camera data, write 0 to disable
        constexpr uint32_t CAM_UPDATE = (1U << 1);  ///< write 1 to update ISP_CAM_CONF
        constexpr uint32_t CAM_RESET = (1U << 2);  ///< this bit configures cam clk domain reset, 1: reset cam input logic, 0: release reset
        constexpr uint32_t CAM_CLK_INV = (1U << 3);  ///< this bit configures the invertion of cam clk from pad. 0: not invert cam clk, 1: invert cam clk
    }

    /// CAM_CONF Register bits
    namespace cam_conf_bits {
        constexpr uint32_t CAM_DATA_ORDER = (1U << 0);  ///< this field configures data order of cam port, 0: cam_data_in, 1:{cam_data_in[7:0], cam_data_in[15:8]}
        constexpr uint32_t CAM_2BYTE_MODE = (1U << 1);  ///< this field configures enable of cam 2 byte mode(input 2 bytes each clock). 0: disable, 1: enable
        constexpr uint32_t CAM_DATA_TYPE = (6 << 2);  ///< this field configures idi data type for image data, 0x2a: RAW8, 0x2b: RAW10, 0x2c: RAW12
        constexpr uint32_t CAM_DE_INV = (1U << 8);  ///< this bit configures cam data enable invert. 0: not invert, 1: invert
        constexpr uint32_t CAM_HSYNC_INV = (1U << 9);  ///< this bit configures cam hsync invert. 0: not invert, 1: invert
        constexpr uint32_t CAM_VSYNC_INV = (1U << 10);  ///< this bit configures cam vsync invert. 0: not invert, 1: invert
        constexpr uint32_t CAM_VSYNC_FILTER_THRES = (3 << 11);  ///< this bit configures the number of clock of vsync filter length
        constexpr uint32_t CAM_VSYNC_FILTER_EN = (1U << 14);  ///< this bit configures vsync filter en
    }

    /// AF_CTRL0 Register bits
    namespace af_ctrl0_bits {
        constexpr uint32_t AF_AUTO_UPDATE = (1U << 0);  ///< this bit configures auto_update enable. when set to 1, will update sum and lum each frame
        constexpr uint32_t AF_MANUAL_UPDATE = (1U << 4);  ///< write 1 to this bit will update the sum and lum once
        constexpr uint32_t AF_ENV_THRESHOLD = (4 << 8);  ///< this field configures env threshold. when both sum and lum changes larger than this value, consider environment changes and need to trigger a new autofocus. 4Bit fractional
        constexpr uint32_t AF_ENV_PERIOD = (8 << 16);  ///< this field configures environment changes detection period (frame). When set to 0, disable this function
    }

    /// AF_CTRL1 Register bits
    namespace af_ctrl1_bits {
        constexpr uint32_t AF_THPIXNUM = (22 << 0);  ///< this field configures pixnum used when calculating the autofocus threshold. Set to 0 to disable threshold calculation
    }

    /// AF_GEN_TH_CTRL Register bits
    namespace af_gen_th_ctrl_bits {
        constexpr uint32_t AF_GEN_THRESHOLD_MIN = (16 << 0);  ///< this field configures min threshold when use auto_threshold
        constexpr uint32_t AF_GEN_THRESHOLD_MAX = (16 << 16);  ///< this field configures max threshold when use auto_threshold
    }

    /// AF_ENV_USER_TH_SUM Register bits
    namespace af_env_user_th_sum_bits {
        constexpr uint32_t AF_ENV_USER_THRESHOLD_SUM = (32 << 0);  ///< this field configures user setup env detect sum threshold
    }

    /// AF_ENV_USER_TH_LUM Register bits
    namespace af_env_user_th_lum_bits {
        constexpr uint32_t AF_ENV_USER_THRESHOLD_LUM = (30 << 0);  ///< this field configures user setup env detect lum threshold
    }

    /// AF_THRESHOLD Register bits
    namespace af_threshold_bits {
        constexpr uint32_t AF_THRESHOLD = (16 << 0);  ///< this field configures user threshold. When set to non-zero, autofocus will use this threshold
        constexpr uint32_t AF_GEN_THRESHOLD = (16 << 16);  ///< this field represents the last calculated threshold
    }

    /// AF_HSCALE_A Register bits
    namespace af_hscale_a_bits {
        constexpr uint32_t AF_RPOINT_A = (12 << 0);  ///< this field configures left coordinate of focus window a, must >= 2
        constexpr uint32_t AF_LPOINT_A = (12 << 16);  ///< this field configures top coordinate of focus window a, must >= 2
    }

    /// AF_VSCALE_A Register bits
    namespace af_vscale_a_bits {
        constexpr uint32_t AF_BPOINT_A = (12 << 0);  ///< this field configures right coordinate of focus window a, must <= hnum-2
        constexpr uint32_t AF_TPOINT_A = (12 << 16);  ///< this field configures bottom coordinate of focus window a, must <= hnum-2
    }

    /// AF_HSCALE_B Register bits
    namespace af_hscale_b_bits {
        constexpr uint32_t AF_RPOINT_B = (12 << 0);  ///< this field configures left coordinate of focus window b, must >= 2
        constexpr uint32_t AF_LPOINT_B = (12 << 16);  ///< this field configures top coordinate of focus window b, must >= 2
    }

    /// AF_VSCALE_B Register bits
    namespace af_vscale_b_bits {
        constexpr uint32_t AF_BPOINT_B = (12 << 0);  ///< this field configures right coordinate of focus window b, must <= hnum-2
        constexpr uint32_t AF_TPOINT_B = (12 << 16);  ///< this field configures bottom coordinate of focus window b, must <= hnum-2
    }

    /// AF_HSCALE_C Register bits
    namespace af_hscale_c_bits {
        constexpr uint32_t AF_RPOINT_C = (12 << 0);  ///< this field configures left coordinate of focus window c, must >= 2
        constexpr uint32_t AF_LPOINT_C = (12 << 16);  ///< this field configures top coordinate of focus window c, must >= 2
    }

    /// AF_VSCALE_C Register bits
    namespace af_vscale_c_bits {
        constexpr uint32_t AF_BPOINT_C = (12 << 0);  ///< this field configures right coordinate of focus window c, must <= hnum-2
        constexpr uint32_t AF_TPOINT_C = (12 << 16);  ///< this field configures bottom coordinate of focus window c, must <= hnum-2
    }

    /// AF_SUM_A Register bits
    namespace af_sum_a_bits {
        constexpr uint32_t AF_SUMA = (30 << 0);  ///< this field represents the result of accumulation of pix grad of focus window a
    }

    /// AF_SUM_B Register bits
    namespace af_sum_b_bits {
        constexpr uint32_t AF_SUMB = (30 << 0);  ///< this field represents the result of accumulation of pix grad of focus window b
    }

    /// AF_SUM_C Register bits
    namespace af_sum_c_bits {
        constexpr uint32_t AF_SUMC = (30 << 0);  ///< this field represents the result of accumulation of pix grad of focus window c
    }

    /// AF_LUM_A Register bits
    namespace af_lum_a_bits {
        constexpr uint32_t AF_LUMA = (28 << 0);  ///< this field represents the result of accumulation of pix light of focus window a
    }

    /// AF_LUM_B Register bits
    namespace af_lum_b_bits {
        constexpr uint32_t AF_LUMB = (28 << 0);  ///< this field represents the result of accumulation of pix light of focus window b
    }

    /// AF_LUM_C Register bits
    namespace af_lum_c_bits {
        constexpr uint32_t AF_LUMC = (28 << 0);  ///< this field represents the result of accumulation of pix light of focus window c
    }

    /// AWB_MODE Register bits
    namespace awb_mode_bits {
        constexpr uint32_t AWB_MODE = (2 << 0);  ///< this field configures awb algo sel. 00: none sellected. 01: sel algo0. 10: sel algo1. 11: sel both algo0 and algo1
        constexpr uint32_t AWB_SAMPLE = (1U << 4);  ///< this bit configures awb sample location, 0:before ccm, 1:after ccm
    }

    /// AWB_HSCALE Register bits
    namespace awb_hscale_bits {
        constexpr uint32_t AWB_RPOINT = (12 << 0);  ///< this field configures awb window right coordinate
        constexpr uint32_t AWB_LPOINT = (12 << 16);  ///< this field configures awb window left coordinate
    }

    /// AWB_VSCALE Register bits
    namespace awb_vscale_bits {
        constexpr uint32_t AWB_BPOINT = (12 << 0);  ///< this field configures awb window bottom coordinate
        constexpr uint32_t AWB_TPOINT = (12 << 16);  ///< this field configures awb window top coordinate
    }

    /// AWB_TH_LUM Register bits
    namespace awb_th_lum_bits {
        constexpr uint32_t AWB_MIN_LUM = (10 << 0);  ///< this field configures lower threshold of r+g+b
        constexpr uint32_t AWB_MAX_LUM = (10 << 16);  ///< this field configures upper threshold of r+g+b
    }

    /// AWB_TH_RG Register bits
    namespace awb_th_rg_bits {
        constexpr uint32_t AWB_MIN_RG = (10 << 0);  ///< this field configures lower threshold of r/g, 2bit integer and 8bit fraction
        constexpr uint32_t AWB_MAX_RG = (10 << 16);  ///< this field configures upper threshold of r/g, 2bit integer and 8bit fraction
    }

    /// AWB_TH_BG Register bits
    namespace awb_th_bg_bits {
        constexpr uint32_t AWB_MIN_BG = (10 << 0);  ///< this field configures lower threshold of b/g, 2bit integer and 8bit fraction
        constexpr uint32_t AWB_MAX_BG = (10 << 16);  ///< this field configures upper threshold of b/g, 2bit integer and 8bit fraction
    }

    /// AWB0_WHITE_CNT Register bits
    namespace awb0_white_cnt_bits {
        constexpr uint32_t AWB0_WHITE_CNT = (24 << 0);  ///< this field configures number of white point detected of algo0
    }

    /// AWB0_ACC_R Register bits
    namespace awb0_acc_r_bits {
        constexpr uint32_t AWB0_ACC_R = (32 << 0);  ///< this field represents accumulate of channel r of all white point of algo0
    }

    /// AWB0_ACC_G Register bits
    namespace awb0_acc_g_bits {
        constexpr uint32_t AWB0_ACC_G = (32 << 0);  ///< this field represents accumulate of channel g of all white point of algo0
    }

    /// AWB0_ACC_B Register bits
    namespace awb0_acc_b_bits {
        constexpr uint32_t AWB0_ACC_B = (32 << 0);  ///< this field represents accumulate of channel b of all white point of algo0
    }

    /// COLOR_CTRL Register bits
    namespace color_ctrl_bits {
        constexpr uint32_t COLOR_SATURATION = (8 << 0);  ///< this field configures the color saturation value
        constexpr uint32_t COLOR_HUE = (8 << 8);  ///< this field configures the color hue angle
        constexpr uint32_t COLOR_CONTRAST = (8 << 16);  ///< this field configures the color contrast value
        constexpr uint32_t COLOR_BRIGHTNESS = (8 << 24);  ///< this field configures the color brightness value, signed 2's complement
    }

    /// BLC_VALUE Register bits
    namespace blc_value_bits {
        constexpr uint32_t BLC_R3_VALUE = (8 << 0);  ///< this field configures the black level of bottom right channel of bayer img
        constexpr uint32_t BLC_R2_VALUE = (8 << 8);  ///< this field configures the black level of bottom left channel of bayer img
        constexpr uint32_t BLC_R1_VALUE = (8 << 16);  ///< this field configures the black level of top right channel of bayer img
        constexpr uint32_t BLC_R0_VALUE = (8 << 24);  ///< this field configures the black level of top left channel of bayer img
    }

    /// BLC_CTRL0 Register bits
    namespace blc_ctrl0_bits {
        constexpr uint32_t BLC_R3_STRETCH = (1U << 0);  ///< this bit configures the stretch feature of bottom right channel. 0: stretch disable, 1: stretch enable
        constexpr uint32_t BLC_R2_STRETCH = (1U << 1);  ///< this bit configures the stretch feature of bottom left channel. 0: stretch disable, 1: stretch enable
        constexpr uint32_t BLC_R1_STRETCH = (1U << 2);  ///< this bit configures the stretch feature of top right channel. 0: stretch disable, 1: stretch enable
        constexpr uint32_t BLC_R0_STRETCH = (1U << 3);  ///< this bit configures the stretch feature of top left channel. 0: stretch disable, 1: stretch enable
    }

    /// BLC_CTRL1 Register bits
    namespace blc_ctrl1_bits {
        constexpr uint32_t BLC_WINDOW_TOP = (11 << 0);  ///< this field configures blc average calculation window top
        constexpr uint32_t BLC_WINDOW_LEFT = (11 << 11);  ///< this field configures blc average calculation window left
        constexpr uint32_t BLC_WINDOW_VNUM = (4 << 22);  ///< this field configures blc average calculation window vnum
        constexpr uint32_t BLC_WINDOW_HNUM = (4 << 26);  ///< this field configures blc average calculation window hnum
        constexpr uint32_t BLC_FILTER_EN = (1U << 30);  ///< this bit configures enable blc average input filter. 0: disable, 1: enable
    }

    /// BLC_CTRL2 Register bits
    namespace blc_ctrl2_bits {
        constexpr uint32_t BLC_R3_TH = (8 << 0);  ///< this field configures black threshold when get blc average of bottom right channel
        constexpr uint32_t BLC_R2_TH = (8 << 8);  ///< this field configures black threshold when get blc average of bottom left channel
        constexpr uint32_t BLC_R1_TH = (8 << 16);  ///< this field configures black threshold when get blc average of top right channel
        constexpr uint32_t BLC_R0_TH = (8 << 24);  ///< this field configures black threshold when get blc average of top left channel
    }

    /// BLC_MEAN Register bits
    namespace blc_mean_bits {
        constexpr uint32_t BLC_R3_MEAN = (8 << 0);  ///< this field represents the average black value of bottom right channel
        constexpr uint32_t BLC_R2_MEAN = (8 << 8);  ///< this field represents the average black value of bottom left channel
        constexpr uint32_t BLC_R1_MEAN = (8 << 16);  ///< this field represents the average black value of top right channel
        constexpr uint32_t BLC_R0_MEAN = (8 << 24);  ///< this field represents the average black value of top left channel
    }

    /// HIST_MODE Register bits
    namespace hist_mode_bits {
        constexpr uint32_t HIST_MODE = (3 << 0);  ///< this field configures statistic mode. 0: RAW_B, 1: RAW_GB, 2: RAW_GR 3: RAW_R, 4: RGB, 5:YUV_Y, 6:YUV_U, 7:YUV_V
    }

    /// HIST_COEFF Register bits
    namespace hist_coeff_bits {
        constexpr uint32_t B = (8 << 0);  ///< this field configures coefficient of B when set hist_mode to RGB, sum of coeff_r and coeff_g and coeff_b should be 256
        constexpr uint32_t G = (8 << 8);  ///< this field configures coefficient of G when set hist_mode to RGB, sum of coeff_r and coeff_g and coeff_b should be 256
        constexpr uint32_t R = (8 << 16);  ///< this field configures coefficient of R when set hist_mode to RGB, sum of coeff_r and coeff_g and coeff_b should be 256
    }

    /// HIST_OFFS Register bits
    namespace hist_offs_bits {
        constexpr uint32_t HIST_Y_OFFS = (12 << 0);  ///< this field configures y coordinate of first window
        constexpr uint32_t HIST_X_OFFS = (12 << 16);  ///< this field configures x coordinate of first window
    }

    /// HIST_SIZE Register bits
    namespace hist_size_bits {
        constexpr uint32_t HIST_Y_SIZE = (9 << 0);  ///< this field configures y direction size of subwindow
        constexpr uint32_t HIST_X_SIZE = (9 << 16);  ///< this field configures x direction size of subwindow
    }

    /// HIST_SEG0 Register bits
    namespace hist_seg0_bits {
        constexpr uint32_t HIST_SEG_3_4 = (8 << 0);  ///< this field configures threshold of histogram bin 3 and bin 4
        constexpr uint32_t HIST_SEG_2_3 = (8 << 8);  ///< this field configures threshold of histogram bin 2 and bin 3
        constexpr uint32_t HIST_SEG_1_2 = (8 << 16);  ///< this field configures threshold of histogram bin 1 and bin 2
        constexpr uint32_t HIST_SEG_0_1 = (8 << 24);  ///< this field configures threshold of histogram bin 0 and bin 1
    }

    /// HIST_SEG1 Register bits
    namespace hist_seg1_bits {
        constexpr uint32_t HIST_SEG_7_8 = (8 << 0);  ///< this field configures threshold of histogram bin 7 and bin 8
        constexpr uint32_t HIST_SEG_6_7 = (8 << 8);  ///< this field configures threshold of histogram bin 6 and bin 7
        constexpr uint32_t HIST_SEG_5_6 = (8 << 16);  ///< this field configures threshold of histogram bin 5 and bin 6
        constexpr uint32_t HIST_SEG_4_5 = (8 << 24);  ///< this field configures threshold of histogram bin 4 and bin 5
    }

    /// HIST_SEG2 Register bits
    namespace hist_seg2_bits {
        constexpr uint32_t HIST_SEG_11_12 = (8 << 0);  ///< this field configures threshold of histogram bin 11 and bin 12
        constexpr uint32_t HIST_SEG_10_11 = (8 << 8);  ///< this field configures threshold of histogram bin 10 and bin 11
        constexpr uint32_t HIST_SEG_9_10 = (8 << 16);  ///< this field configures threshold of histogram bin 9 and bin 10
        constexpr uint32_t HIST_SEG_8_9 = (8 << 24);  ///< this field configures threshold of histogram bin 8 and bin 9
    }

    /// HIST_SEG3 Register bits
    namespace hist_seg3_bits {
        constexpr uint32_t HIST_SEG_14_15 = (8 << 0);  ///< this field configures threshold of histogram bin 14 and bin 15
        constexpr uint32_t HIST_SEG_13_14 = (8 << 8);  ///< this field configures threshold of histogram bin 13 and bin 14
        constexpr uint32_t HIST_SEG_12_13 = (8 << 16);  ///< this field configures threshold of histogram bin 12 and bin 13
    }

    /// HIST_WEIGHT0 Register bits
    namespace hist_weight0_bits {
        constexpr uint32_t HIST_WEIGHT_03 = (8 << 0);  ///< this field configures weight of subwindow 03
        constexpr uint32_t HIST_WEIGHT_02 = (8 << 8);  ///< this field configures weight of subwindow 02
        constexpr uint32_t HIST_WEIGHT_01 = (8 << 16);  ///< this field configures weight of subwindow 01
        constexpr uint32_t HIST_WEIGHT_00 = (8 << 24);  ///< this field configures weight of subwindow 00 and sum of all weight should be 256
    }

    /// HIST_WEIGHT1 Register bits
    namespace hist_weight1_bits {
        constexpr uint32_t HIST_WEIGHT_12 = (8 << 0);  ///< this field configures weight of subwindow 12
        constexpr uint32_t HIST_WEIGHT_11 = (8 << 8);  ///< this field configures weight of subwindow 11
        constexpr uint32_t HIST_WEIGHT_10 = (8 << 16);  ///< this field configures weight of subwindow 10
        constexpr uint32_t HIST_WEIGHT_04 = (8 << 24);  ///< this field configures weight of subwindow 04
    }

    /// HIST_WEIGHT2 Register bits
    namespace hist_weight2_bits {
        constexpr uint32_t HIST_WEIGHT_21 = (8 << 0);  ///< this field configures weight of subwindow 21
        constexpr uint32_t HIST_WEIGHT_20 = (8 << 8);  ///< this field configures weight of subwindow 20
        constexpr uint32_t HIST_WEIGHT_14 = (8 << 16);  ///< this field configures weight of subwindow 04
        constexpr uint32_t HIST_WEIGHT_13 = (8 << 24);  ///< this field configures weight of subwindow 13
    }

    /// HIST_WEIGHT3 Register bits
    namespace hist_weight3_bits {
        constexpr uint32_t HIST_WEIGHT_30 = (8 << 0);  ///< this field configures weight of subwindow 30
        constexpr uint32_t HIST_WEIGHT_24 = (8 << 8);  ///< this field configures weight of subwindow 24
        constexpr uint32_t HIST_WEIGHT_23 = (8 << 16);  ///< this field configures weight of subwindow 23
        constexpr uint32_t HIST_WEIGHT_22 = (8 << 24);  ///< this field configures weight of subwindow 22
    }

    /// HIST_WEIGHT4 Register bits
    namespace hist_weight4_bits {
        constexpr uint32_t HIST_WEIGHT_34 = (8 << 0);  ///< this field configures weight of subwindow 34
        constexpr uint32_t HIST_WEIGHT_33 = (8 << 8);  ///< this field configures weight of subwindow 33
        constexpr uint32_t HIST_WEIGHT_32 = (8 << 16);  ///< this field configures weight of subwindow 32
        constexpr uint32_t HIST_WEIGHT_31 = (8 << 24);  ///< this field configures weight of subwindow 31
    }

    /// HIST_WEIGHT5 Register bits
    namespace hist_weight5_bits {
        constexpr uint32_t HIST_WEIGHT_43 = (8 << 0);  ///< this field configures weight of subwindow 43
        constexpr uint32_t HIST_WEIGHT_42 = (8 << 8);  ///< this field configures weight of subwindow 42
        constexpr uint32_t HIST_WEIGHT_41 = (8 << 16);  ///< this field configures weight of subwindow 41
        constexpr uint32_t HIST_WEIGHT_40 = (8 << 24);  ///< this field configures weight of subwindow 40
    }

    /// HIST_WEIGHT6 Register bits
    namespace hist_weight6_bits {
        constexpr uint32_t HIST_WEIGHT_44 = (8 << 0);  ///< this field configures weight of subwindow 44
    }

    /// HIST_BIN0 Register bits
    namespace hist_bin0_bits {
        constexpr uint32_t HIST_BIN_0 = (17 << 0);  ///< this field represents result of histogram bin 0
    }

    /// HIST_BIN1 Register bits
    namespace hist_bin1_bits {
        constexpr uint32_t HIST_BIN_1 = (17 << 0);  ///< this field represents result of histogram bin 1
    }

    /// HIST_BIN2 Register bits
    namespace hist_bin2_bits {
        constexpr uint32_t HIST_BIN_2 = (17 << 0);  ///< this field represents result of histogram bin 2
    }

    /// HIST_BIN3 Register bits
    namespace hist_bin3_bits {
        constexpr uint32_t HIST_BIN_3 = (17 << 0);  ///< this field represents result of histogram bin 3
    }

    /// HIST_BIN4 Register bits
    namespace hist_bin4_bits {
        constexpr uint32_t HIST_BIN_4 = (17 << 0);  ///< this field represents result of histogram bin 4
    }

    /// HIST_BIN5 Register bits
    namespace hist_bin5_bits {
        constexpr uint32_t HIST_BIN_5 = (17 << 0);  ///< this field represents result of histogram bin 5
    }

    /// HIST_BIN6 Register bits
    namespace hist_bin6_bits {
        constexpr uint32_t HIST_BIN_6 = (17 << 0);  ///< this field represents result of histogram bin 6
    }

    /// HIST_BIN7 Register bits
    namespace hist_bin7_bits {
        constexpr uint32_t HIST_BIN_7 = (17 << 0);  ///< this field represents result of histogram bin 7
    }

    /// HIST_BIN8 Register bits
    namespace hist_bin8_bits {
        constexpr uint32_t HIST_BIN_8 = (17 << 0);  ///< this field represents result of histogram bin 8
    }

    /// HIST_BIN9 Register bits
    namespace hist_bin9_bits {
        constexpr uint32_t HIST_BIN_9 = (17 << 0);  ///< this field represents result of histogram bin 9
    }

    /// HIST_BIN10 Register bits
    namespace hist_bin10_bits {
        constexpr uint32_t HIST_BIN_10 = (17 << 0);  ///< this field represents result of histogram bin 10
    }

    /// HIST_BIN11 Register bits
    namespace hist_bin11_bits {
        constexpr uint32_t HIST_BIN_11 = (17 << 0);  ///< this field represents result of histogram bin 11
    }

    /// HIST_BIN12 Register bits
    namespace hist_bin12_bits {
        constexpr uint32_t HIST_BIN_12 = (17 << 0);  ///< this field represents result of histogram bin 12
    }

    /// HIST_BIN13 Register bits
    namespace hist_bin13_bits {
        constexpr uint32_t HIST_BIN_13 = (17 << 0);  ///< this field represents result of histogram bin 13
    }

    /// HIST_BIN14 Register bits
    namespace hist_bin14_bits {
        constexpr uint32_t HIST_BIN_14 = (17 << 0);  ///< this field represents result of histogram bin 14
    }

    /// HIST_BIN15 Register bits
    namespace hist_bin15_bits {
        constexpr uint32_t HIST_BIN_15 = (17 << 0);  ///< this field represents result of histogram bin 15
    }

    /// MEM_AUX_CTRL_0 Register bits
    namespace mem_aux_ctrl_0_bits {
        constexpr uint32_t HEADER_MEM_AUX_CTRL = (14 << 0);  ///< this field configures the mem_aux of isp input buffer memory
        constexpr uint32_t DPC_LUT_MEM_AUX_CTRL = (14 << 16);  ///< this field represents this field configures the mem_aux of dpc lut memory
    }

    /// MEM_AUX_CTRL_1 Register bits
    namespace mem_aux_ctrl_1_bits {
        constexpr uint32_t LSC_LUT_R_GR_MEM_AUX_CTRL = (14 << 0);  ///< this field configures the mem_aux of lsc r gr lut memory
        constexpr uint32_t LSC_LUT_GB_B_MEM_AUX_CTRL = (14 << 16);  ///< this field configures the mem_aux of lsc gb b lut memory
    }

    /// MEM_AUX_CTRL_2 Register bits
    namespace mem_aux_ctrl_2_bits {
        constexpr uint32_t BF_MATRIX_MEM_AUX_CTRL = (14 << 0);  ///< this field configures the mem_aux of bf line buffer memory
        constexpr uint32_t DPC_MATRIX_MEM_AUX_CTRL = (14 << 16);  ///< this field configures the mem_aux of dpc line buffer memory
    }

    /// MEM_AUX_CTRL_3 Register bits
    namespace mem_aux_ctrl_3_bits {
        constexpr uint32_t SHARP_MATRIX_Y_MEM_AUX_CTRL = (14 << 0);  ///< this field configures the mem_aux of sharp y line buffer memory
        constexpr uint32_t DEMOSAIC_MATRIX_MEM_AUX_CTRL = (14 << 16);  ///< this field configures the mem_aux of demosaic line buffer memory
    }

    /// MEM_AUX_CTRL_4 Register bits
    namespace mem_aux_ctrl_4_bits {
        constexpr uint32_t SHARP_MATRIX_UV_MEM_AUX_CTRL = (14 << 0);  ///< this field configures the mem_aux of sharp uv line buffer memory
    }

    /// YUV_FORMAT Register bits
    namespace yuv_format_bits {
        constexpr uint32_t YUV_MODE = (1U << 0);  ///< this bit configures the yuv mode. 0: ITU-R BT.601, 1: ITU-R BT.709
        constexpr uint32_t YUV_RANGE = (1U << 1);  ///< this bit configures the yuv range. 0: full range, 1: limit range
    }

    /// RDN_ECO_CS Register bits
    namespace rdn_eco_cs_bits {
        constexpr uint32_t RDN_ECO_EN = (1U << 0);  ///< rdn_eco_en
        constexpr uint32_t RDN_ECO_RESULT = (1U << 1);  ///< rdn_eco_result
    }

    /// RDN_ECO_LOW Register bits
    namespace rdn_eco_low_bits {
        constexpr uint32_t RDN_ECO_LOW = (32 << 0);  ///< rdn_eco_low
    }

    /// RDN_ECO_HIGH Register bits
    namespace rdn_eco_high_bits {
        constexpr uint32_t RDN_ECO_HIGH = (32 << 0);  ///< rdn_eco_high
    }

}

// ============================================================================
// JPEG Peripheral
// ============================================================================

namespace jpeg {
    /// Base addresses
    constexpr uint32_t JPEG_BASE = 0x50086000;

    /// JPEG Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - Control and configuration registers
        volatile uint32_t DQT_INFO;  ///< Offset: 0x04 - Control and configuration registers
        volatile uint32_t PIC_SIZE;  ///< Offset: 0x08 - Control and configuration registers
        volatile uint32_t T0QNR;  ///< Offset: 0x10 - Control and configuration registers
        volatile uint32_t T1QNR;  ///< Offset: 0x14 - Control and configuration registers
        volatile uint32_t T2QNR;  ///< Offset: 0x18 - Control and configuration registers
        volatile uint32_t T3QNR;  ///< Offset: 0x1C - Control and configuration registers
        volatile uint32_t DECODE_CONF;  ///< Offset: 0x20 - Control and configuration registers
        volatile uint32_t C0;  ///< Offset: 0x24 - Control and configuration registers
        volatile uint32_t C1;  ///< Offset: 0x28 - Control and configuration registers
        volatile uint32_t C2;  ///< Offset: 0x2C - Control and configuration registers
        volatile uint32_t C3;  ///< Offset: 0x30 - Control and configuration registers
        volatile uint32_t DHT_INFO;  ///< Offset: 0x34 - Control and configuration registers
        volatile uint32_t INT_RAW;  ///< Offset: 0x38 - Interrupt raw registers
        volatile uint32_t INT_ENA;  ///< Offset: 0x3C - Interrupt enable registers
        volatile uint32_t INT_ST;  ///< Offset: 0x40 - Interrupt status registers
        volatile uint32_t INT_CLR;  ///< Offset: 0x44 - Interrupt clear registers
        volatile uint32_t STATUS0;  ///< Offset: 0x48 - Trace and Debug registers
        volatile uint32_t STATUS2;  ///< Offset: 0x4C - Trace and Debug registers
        volatile uint32_t STATUS3;  ///< Offset: 0x50 - Trace and Debug registers
        volatile uint32_t STATUS4;  ///< Offset: 0x54 - Trace and Debug registers
        volatile uint32_t DHT_TOTLEN_DC0;  ///< Offset: 0x58 - Trace and Debug registers
        volatile uint32_t DHT_VAl_DC0;  ///< Offset: 0x5C - Trace and Debug registers
        volatile uint32_t DHT_TOTLEN_AC0;  ///< Offset: 0x60 - Trace and Debug registers
        volatile uint32_t DHT_VAl_AC0;  ///< Offset: 0x64 - Trace and Debug registers
        volatile uint32_t DHT_TOTLEN_DC1;  ///< Offset: 0x68 - Trace and Debug registers
        volatile uint32_t DHT_VAl_DC1;  ///< Offset: 0x6C - Trace and Debug registers
        volatile uint32_t DHT_TOTLEN_AC1;  ///< Offset: 0x70 - Trace and Debug registers
        volatile uint32_t DHT_VAl_AC1;  ///< Offset: 0x74 - Trace and Debug registers
        volatile uint32_t DHT_CODEMIN_DC0;  ///< Offset: 0x78 - Trace and Debug registers
        volatile uint32_t DHT_CODEMIN_AC0;  ///< Offset: 0x7C - Trace and Debug registers
        volatile uint32_t DHT_CODEMIN_DC1;  ///< Offset: 0x80 - Trace and Debug registers
        volatile uint32_t DHT_CODEMIN_AC1;  ///< Offset: 0x84 - Trace and Debug registers
        volatile uint32_t DECODER_STATUS0;  ///< Offset: 0x88 - Trace and Debug registers
        volatile uint32_t DECODER_STATUS1;  ///< Offset: 0x8C - Trace and Debug registers
        volatile uint32_t DECODER_STATUS2;  ///< Offset: 0x90 - Trace and Debug registers
        volatile uint32_t DECODER_STATUS3;  ///< Offset: 0x94 - Trace and Debug registers
        volatile uint32_t DECODER_STATUS4;  ///< Offset: 0x98 - Trace and Debug registers
        volatile uint32_t DECODER_STATUS5;  ///< Offset: 0x9C - Trace and Debug registers
        volatile uint32_t STATUS5;  ///< Offset: 0xA0 - Trace and Debug registers
        volatile uint32_t ECO_LOW;  ///< Offset: 0xA4 - Trace and Debug registers
        volatile uint32_t ECO_HIGH;  ///< Offset: 0xA8 - Trace and Debug registers
        volatile uint32_t SYS;  ///< Offset: 0xF8 - Trace and Debug registers
        volatile uint32_t VERSION;  ///< Offset: 0xFC - Trace and Debug registers
    };

    /// Peripheral instances
    inline Registers* JPEG = reinterpret_cast<Registers*>(JPEG_BASE);

    // Bit definitions
    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t FSM_RST = (1U << 0);  ///< fsm reset
        constexpr uint32_t JPEG_START = (1U << 1);  ///< start to compress a new pic(in dma reg mode)
        constexpr uint32_t QNR_PRESITION = (1U << 2);  ///< 0:8bit qnr,1:12bit qnr(TBD)
        constexpr uint32_t FF_CHECK_EN = (1U << 3);  ///< enable whether to add "00" after "ff"
        constexpr uint32_t SAMPLE_SEL = (2 << 4);  ///< 0:yuv444,1:yuv422, 2:yuv420
        constexpr uint32_t DMA_LINKLIST_MODE = (1U << 6);  ///< 1:use linklist to configure dma
        constexpr uint32_t DEBUG_DIRECT_OUT_EN = (1U << 7);  ///< 0:normal mode,1:debug mode for direct output from input
        constexpr uint32_t GRAY_SEL = (1U << 8);  ///< 0:use non-fifo way to access qnr ram,1:use fifo way to access qnr ram
        constexpr uint32_t LQNR_TBL_SEL = (2 << 9);  ///< choose luminance quntization table id(TBD)
        constexpr uint32_t CQNR_TBL_SEL = (2 << 11);  ///< choose chrominance quntization table id (TBD)
        constexpr uint32_t COLOR_SPACE = (2 << 13);  ///< configure picture's color space:0-rb888,1-yuv422,2-rgb565, 3-gray
        constexpr uint32_t DHT_FIFO_EN = (1U << 15);  ///< 0:use non-fifo way to write dht len_total/codemin/value table,1:use fifo way to write dht len_total/codemin/value table. Reading dht len_total/codemin/value table only has nonfifo way
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 16);  ///< force memory's clock enabled
        constexpr uint32_t JFIF_VER = (6 << 17);  ///< decode pause period to trigger decode_timeout int, the timeout periods =2 power (reg_decode_timeout_thres) -1
        constexpr uint32_t DECODE_TIMEOUT_TASK_SEL = (1U << 23);  ///< 0: software use reset to abort decode process ,1: decoder abort decode process by itself
        constexpr uint32_t SOFT_RST = (1U << 24);  ///< when set to 1, soft reset JPEG module except jpeg_reg module
        constexpr uint32_t FIFO_RST = (1U << 25);  ///< fifo reset
        constexpr uint32_t PIXEL_REV = (1U << 26);  ///< reverse the source color pixel
        constexpr uint32_t TAILER_EN = (1U << 27);  ///< set this bit to add EOI of "0xffd9" at the end of bitstream
        constexpr uint32_t PAUSE_EN = (1U << 28);  ///< set this bit to pause jpeg encoding
        constexpr uint32_t MEM_FORCE_PD = (1U << 29);  ///< 0: no operation,1:force jpeg memory to power down
        constexpr uint32_t MEM_FORCE_PU = (1U << 30);  ///< 0: no operation,1:force jpeg memory to power up
        constexpr uint32_t MODE = (1U << 31);  ///< 0:encoder mode, 1: decoder mode
    }

    /// DQT_INFO Register bits
    namespace dqt_info_bits {
        constexpr uint32_t T0_DQT_INFO = (8 << 0);  ///< Configure dqt table0's quantization coefficient precision in bit[7:4], configure dqt table0's table id in bit[3:0]
        constexpr uint32_t T1_DQT_INFO = (8 << 8);  ///< Configure dqt table1's quantization coefficient precision in bit[7:4], configure dqt table1's table id in bit[3:0]
        constexpr uint32_t T2_DQT_INFO = (8 << 16);  ///< Configure dqt table2's quantization coefficient precision in bit[7:4], configure dqt table2's table id in bit[3:0]
        constexpr uint32_t T3_DQT_INFO = (8 << 24);  ///< Configure dqt table3's quantization coefficient precision in bit[7:4], configure dqt table3's table id in bit[3:0]
    }

    /// PIC_SIZE Register bits
    namespace pic_size_bits {
        constexpr uint32_t VA = (16 << 0);  ///< configure picture's height. when encode, the max configurable bits is 14, when decode, the max configurable bits is 16
        constexpr uint32_t HA = (16 << 16);  ///< configure picture's width. when encode, the max configurable bits is 14, when decode, the max configurable bits is 16
    }

    /// T0QNR Register bits
    namespace t0qnr_bits {
        constexpr uint32_t T0_QNR_VAL = (32 << 0);  ///< write this reg to configure 64 quantization coefficient in t0 table
    }

    /// T1QNR Register bits
    namespace t1qnr_bits {
        constexpr uint32_t CHROMINANCE_QNR_VAL = (32 << 0);  ///< write this reg to configure 64 quantization coefficient in t1 table
    }

    /// T2QNR Register bits
    namespace t2qnr_bits {
        constexpr uint32_t T2_QNR_VAL = (32 << 0);  ///< write this reg to configure 64 quantization coefficient in t2 table
    }

    /// T3QNR Register bits
    namespace t3qnr_bits {
        constexpr uint32_t T3_QNR_VAL = (32 << 0);  ///< write this reg to configure 64 quantization coefficient in t3 table
    }

    /// DECODE_CONF Register bits
    namespace decode_conf_bits {
        constexpr uint32_t RESTART_INTERVAL = (16 << 0);  ///< configure restart interval in DRI marker when decode
        constexpr uint32_t COMPONENT_NUM = (8 << 16);  ///< configure number of components in frame when decode
        constexpr uint32_t SW_DHT_EN = (1U << 24);  ///< software decode dht table enable
        constexpr uint32_t SOS_CHECK_BYTE_NUM = (2 << 25);  ///< Configure the byte number to check next sos marker in the multi-scan picture after one scan is decoded down. The real check number is reg_sos_check_byte_num+1
        constexpr uint32_t RST_CHECK_BYTE_NUM = (2 << 27);  ///< Configure the byte number to check next rst marker after one rst interval is decoded down. The real check number is reg_rst_check_byte_num+1
        constexpr uint32_t MULTI_SCAN_ERR_CHECK = (1U << 29);  ///< reserved for decoder
        constexpr uint32_t DEZIGZAG_READY_CTL = (1U << 30);  ///< reserved for decoder
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DQT_TBL_SEL = (8 << 0);  ///< choose c0 quntization table id (TBD)
        constexpr uint32_t Y_FACTOR = (4 << 8);  ///< vertical sampling factor of c0
        constexpr uint32_t X_FACTOR = (4 << 12);  ///< horizontal sampling factor of c0
        constexpr uint32_t ID = (8 << 16);  ///< the identifier of c0
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DQT_TBL_SEL = (8 << 0);  ///< choose c1 quntization table id (TBD)
        constexpr uint32_t Y_FACTOR = (4 << 8);  ///< vertical sampling factor of c1
        constexpr uint32_t X_FACTOR = (4 << 12);  ///< horizontal sampling factor of c1
        constexpr uint32_t ID = (8 << 16);  ///< the identifier of c1
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DQT_TBL_SEL = (8 << 0);  ///< choose c2 quntization table id (TBD)
        constexpr uint32_t Y_FACTOR = (4 << 8);  ///< vertical sampling factor of c2
        constexpr uint32_t X_FACTOR = (4 << 12);  ///< horizontal sampling factor of c2
        constexpr uint32_t ID = (8 << 16);  ///< the identifier of c2
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t DQT_TBL_SEL = (8 << 0);  ///< choose c3 quntization table id (TBD)
        constexpr uint32_t Y_FACTOR = (4 << 8);  ///< vertical sampling factor of c3
        constexpr uint32_t X_FACTOR = (4 << 12);  ///< horizontal sampling factor of c3
        constexpr uint32_t ID = (8 << 16);  ///< the identifier of c3
    }

    /// DHT_INFO Register bits
    namespace dht_info_bits {
        constexpr uint32_t DC0_DHT_ID = (4 << 0);  ///< configure dht dc table 0 id
        constexpr uint32_t DC1_DHT_ID = (4 << 4);  ///< configure dht dc table 1 id
        constexpr uint32_t AC0_DHT_ID = (4 << 8);  ///< configure dht ac table 0 id
        constexpr uint32_t AC1_DHT_ID = (4 << 12);  ///< configure dht ac table 1 id
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t DONE_INT_RAW = (1U << 0);  ///< This raw interrupt bit turns to high level when JPEG finishes encoding a picture..
        constexpr uint32_t RLE_PARALLEL_ERR_INT_RAW = (1U << 1);  ///< The raw interrupt bit to sign that rle parallel error when decoding.
        constexpr uint32_t CID_ERR_INT_RAW = (1U << 2);  ///< The raw interrupt bit to sign that scan id check with component fails when decoding.
        constexpr uint32_t C_DHT_DC_ID_ERR_INT_RAW = (1U << 3);  ///< The raw interrupt bit to sign that scan component's dc dht id check with dc dht table's id fails when decoding.
        constexpr uint32_t C_DHT_AC_ID_ERR_INT_RAW = (1U << 4);  ///< The raw interrupt bit to sign that scan component's ac dht id check with ac dht table's id fails when decoding.
        constexpr uint32_t C_DQT_ID_ERR_INT_RAW = (1U << 5);  ///< The raw interrupt bit to sign that scan component's dqt id check with dqt table's id fails when decoding.
        constexpr uint32_t RST_UXP_ERR_INT_RAW = (1U << 6);  ///< The raw interrupt bit to sign that RST header marker is detected but restart interval is 0 when decoding.
        constexpr uint32_t RST_CHECK_NONE_ERR_INT_RAW = (1U << 7);  ///< The raw interrupt bit to sign that RST header marker is not detected but restart interval is not 0 when decoding.
        constexpr uint32_t RST_CHECK_POS_ERR_INT_RAW = (1U << 8);  ///< The raw interrupt bit to sign that RST header marker position mismatches with restart interval when decoding.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 9);  ///< The raw interrupt bit turns to high level when the last pixel of one square has been transmitted for Tx channel.
        constexpr uint32_t SR_COLOR_MODE_ERR_INT_RAW = (1U << 10);  ///< The raw interrupt bit to sign that the selected source color mode is not supported.
        constexpr uint32_t DCT_DONE_INT_RAW = (1U << 11);  ///< The raw interrupt bit to sign that one dct calculation is finished.
        constexpr uint32_t BS_LAST_BLOCK_EOF_INT_RAW = (1U << 12);  ///< The raw interrupt bit to sign that the coding process for last block is finished.
        constexpr uint32_t SCAN_CHECK_NONE_ERR_INT_RAW = (1U << 13);  ///< The raw interrupt bit to sign that SOS header marker is not detected but there are still components left to be decoded.
        constexpr uint32_t SCAN_CHECK_POS_ERR_INT_RAW = (1U << 14);  ///< The raw interrupt bit to sign that SOS header marker position wrong when decoding.
        constexpr uint32_t UXP_DET_INT_RAW = (1U << 15);  ///< The raw interrupt bit to sign that unsupported header marker is detected when decoding.
        constexpr uint32_t EN_FRAME_EOF_ERR_INT_RAW = (1U << 16);  ///< The raw interrupt bit to sign that received pixel blocks are smaller than expected when encoding.
        constexpr uint32_t EN_FRAME_EOF_LACK_INT_RAW = (1U << 17);  ///< The raw interrupt bit to sign that the frame eof sign bit from dma input is missing when encoding. But the number of pixel blocks is enough.
        constexpr uint32_t DE_FRAME_EOF_ERR_INT_RAW = (1U << 18);  ///< The raw interrupt bit to sign that decoded blocks are smaller than expected when decoding.
        constexpr uint32_t DE_FRAME_EOF_LACK_INT_RAW = (1U << 19);  ///< The raw interrupt bit to sign that the either frame eof from dma input or eoi marker is missing when encoding. But the number of decoded blocks is enough.
        constexpr uint32_t SOS_UNMATCH_ERR_INT_RAW = (1U << 20);  ///< The raw interrupt bit to sign that the component number of a scan is 0 or does not match the sos marker's length when decoding.
        constexpr uint32_t MARKER_ERR_FST_SCAN_INT_RAW = (1U << 21);  ///< The raw interrupt bit to sign that the first scan has header marker error when decoding.
        constexpr uint32_t MARKER_ERR_OTHER_SCAN_INT_RAW = (1U << 22);  ///< The raw interrupt bit to sign that the following scans but not the first scan have header marker error when decoding.
        constexpr uint32_t UNDET_INT_RAW = (1U << 23);  ///< The raw interrupt bit to sign that JPEG format is not detected at the eof data of a packet when decoding.
        constexpr uint32_t DECODE_TIMEOUT_INT_RAW = (1U << 24);  ///< The raw interrupt bit to sign that decode pause time is longer than the setting decode timeout time when decoding.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t DONE_INT_ENA = (1U << 0);  ///< This enable interrupt bit turns to high level when JPEG finishes encoding a picture..
        constexpr uint32_t RLE_PARALLEL_ERR_INT_ENA = (1U << 1);  ///< The enable interrupt bit to sign that rle parallel error when decoding.
        constexpr uint32_t CID_ERR_INT_ENA = (1U << 2);  ///< The enable interrupt bit to sign that scan id check with component fails when decoding.
        constexpr uint32_t C_DHT_DC_ID_ERR_INT_ENA = (1U << 3);  ///< The enable interrupt bit to sign that scan component's dc dht id check with dc dht table's id fails when decoding.
        constexpr uint32_t C_DHT_AC_ID_ERR_INT_ENA = (1U << 4);  ///< The enable interrupt bit to sign that scan component's ac dht id check with ac dht table's id fails when decoding.
        constexpr uint32_t C_DQT_ID_ERR_INT_ENA = (1U << 5);  ///< The enable interrupt bit to sign that scan component's dqt id check with dqt table's id fails when decoding.
        constexpr uint32_t RST_UXP_ERR_INT_ENA = (1U << 6);  ///< The enable interrupt bit to sign that RST header marker is detected but restart interval is 0 when decoding.
        constexpr uint32_t RST_CHECK_NONE_ERR_INT_ENA = (1U << 7);  ///< The enable interrupt bit to sign that RST header marker is not detected but restart interval is not 0 when decoding.
        constexpr uint32_t RST_CHECK_POS_ERR_INT_ENA = (1U << 8);  ///< The enable interrupt bit to sign that RST header marker position mismatches with restart interval when decoding.
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 9);  ///< The enable interrupt bit turns to high level when the last pixel of one square has been transmitted for Tx channel.
        constexpr uint32_t SR_COLOR_MODE_ERR_INT_ENA = (1U << 10);  ///< The enable interrupt bit to sign that the selected source color mode is not supported.
        constexpr uint32_t DCT_DONE_INT_ENA = (1U << 11);  ///< The enable interrupt bit to sign that one dct calculation is finished.
        constexpr uint32_t BS_LAST_BLOCK_EOF_INT_ENA = (1U << 12);  ///< The enable interrupt bit to sign that the coding process for last block is finished.
        constexpr uint32_t SCAN_CHECK_NONE_ERR_INT_ENA = (1U << 13);  ///< The enable interrupt bit to sign that SOS header marker is not detected but there are still components left to be decoded.
        constexpr uint32_t SCAN_CHECK_POS_ERR_INT_ENA = (1U << 14);  ///< The enable interrupt bit to sign that SOS header marker position wrong when decoding.
        constexpr uint32_t UXP_DET_INT_ENA = (1U << 15);  ///< The enable interrupt bit to sign that unsupported header marker is detected when decoding.
        constexpr uint32_t EN_FRAME_EOF_ERR_INT_ENA = (1U << 16);  ///< The enable interrupt bit to sign that received pixel blocks are smaller than expected when encoding.
        constexpr uint32_t EN_FRAME_EOF_LACK_INT_ENA = (1U << 17);  ///< The enable interrupt bit to sign that the frame eof sign bit from dma input is missing when encoding. But the number of pixel blocks is enough.
        constexpr uint32_t DE_FRAME_EOF_ERR_INT_ENA = (1U << 18);  ///< The enable interrupt bit to sign that decoded blocks are smaller than expected when decoding.
        constexpr uint32_t DE_FRAME_EOF_LACK_INT_ENA = (1U << 19);  ///< The enable interrupt bit to sign that the either frame eof from dma input or eoi marker is missing when encoding. But the number of decoded blocks is enough.
        constexpr uint32_t SOS_UNMATCH_ERR_INT_ENA = (1U << 20);  ///< The enable interrupt bit to sign that the component number of a scan is 0 or does not match the sos marker's length when decoding.
        constexpr uint32_t MARKER_ERR_FST_SCAN_INT_ENA = (1U << 21);  ///< The enable interrupt bit to sign that the first scan has header marker error when decoding.
        constexpr uint32_t MARKER_ERR_OTHER_SCAN_INT_ENA = (1U << 22);  ///< The enable interrupt bit to sign that the following scans but not the first scan have header marker error when decoding.
        constexpr uint32_t UNDET_INT_ENA = (1U << 23);  ///< The enable interrupt bit to sign that JPEG format is not detected at the eof data of a packet when decoding.
        constexpr uint32_t DECODE_TIMEOUT_INT_ENA = (1U << 24);  ///< The enable interrupt bit to sign that decode pause time is longer than the setting decode timeout time when decoding.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t DONE_INT_ST = (1U << 0);  ///< This status interrupt bit turns to high level when JPEG finishes encoding a picture..
        constexpr uint32_t RLE_PARALLEL_ERR_INT_ST = (1U << 1);  ///< The status interrupt bit to sign that rle parallel error when decoding.
        constexpr uint32_t CID_ERR_INT_ST = (1U << 2);  ///< The status interrupt bit to sign that scan id check with component fails when decoding.
        constexpr uint32_t C_DHT_DC_ID_ERR_INT_ST = (1U << 3);  ///< The status interrupt bit to sign that scan component's dc dht id check with dc dht table's id fails when decoding.
        constexpr uint32_t C_DHT_AC_ID_ERR_INT_ST = (1U << 4);  ///< The status interrupt bit to sign that scan component's ac dht id check with ac dht table's id fails when decoding.
        constexpr uint32_t C_DQT_ID_ERR_INT_ST = (1U << 5);  ///< The status interrupt bit to sign that scan component's dqt id check with dqt table's id fails when decoding.
        constexpr uint32_t RST_UXP_ERR_INT_ST = (1U << 6);  ///< The status interrupt bit to sign that RST header marker is detected but restart interval is 0 when decoding.
        constexpr uint32_t RST_CHECK_NONE_ERR_INT_ST = (1U << 7);  ///< The status interrupt bit to sign that RST header marker is not detected but restart interval is not 0 when decoding.
        constexpr uint32_t RST_CHECK_POS_ERR_INT_ST = (1U << 8);  ///< The status interrupt bit to sign that RST header marker position mismatches with restart interval when decoding.
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 9);  ///< The status interrupt bit turns to high level when the last pixel of one square has been transmitted for Tx channel.
        constexpr uint32_t SR_COLOR_MODE_ERR_INT_ST = (1U << 10);  ///< The status interrupt bit to sign that the selected source color mode is not supported.
        constexpr uint32_t DCT_DONE_INT_ST = (1U << 11);  ///< The status interrupt bit to sign that one dct calculation is finished.
        constexpr uint32_t BS_LAST_BLOCK_EOF_INT_ST = (1U << 12);  ///< The status interrupt bit to sign that the coding process for last block is finished.
        constexpr uint32_t SCAN_CHECK_NONE_ERR_INT_ST = (1U << 13);  ///< The status interrupt bit to sign that SOS header marker is not detected but there are still components left to be decoded.
        constexpr uint32_t SCAN_CHECK_POS_ERR_INT_ST = (1U << 14);  ///< The status interrupt bit to sign that SOS header marker position wrong when decoding.
        constexpr uint32_t UXP_DET_INT_ST = (1U << 15);  ///< The status interrupt bit to sign that unsupported header marker is detected when decoding.
        constexpr uint32_t EN_FRAME_EOF_ERR_INT_ST = (1U << 16);  ///< The status interrupt bit to sign that received pixel blocks are smaller than expected when encoding.
        constexpr uint32_t EN_FRAME_EOF_LACK_INT_ST = (1U << 17);  ///< The status interrupt bit to sign that the frame eof sign bit from dma input is missing when encoding. But the number of pixel blocks is enough.
        constexpr uint32_t DE_FRAME_EOF_ERR_INT_ST = (1U << 18);  ///< The status interrupt bit to sign that decoded blocks are smaller than expected when decoding.
        constexpr uint32_t DE_FRAME_EOF_LACK_INT_ST = (1U << 19);  ///< The status interrupt bit to sign that the either frame eof from dma input or eoi marker is missing when encoding. But the number of decoded blocks is enough.
        constexpr uint32_t SOS_UNMATCH_ERR_INT_ST = (1U << 20);  ///< The status interrupt bit to sign that the component number of a scan is 0 or does not match the sos marker's length when decoding.
        constexpr uint32_t MARKER_ERR_FST_SCAN_INT_ST = (1U << 21);  ///< The status interrupt bit to sign that the first scan has header marker error when decoding.
        constexpr uint32_t MARKER_ERR_OTHER_SCAN_INT_ST = (1U << 22);  ///< The status interrupt bit to sign that the following scans but not the first scan have header marker error when decoding.
        constexpr uint32_t UNDET_INT_ST = (1U << 23);  ///< The status interrupt bit to sign that JPEG format is not detected at the eof data of a packet when decoding.
        constexpr uint32_t DECODE_TIMEOUT_INT_ST = (1U << 24);  ///< The status interrupt bit to sign that decode pause time is longer than the setting decode timeout time when decoding.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t DONE_INT_CLR = (1U << 0);  ///< This clear interrupt bit turns to high level when JPEG finishes encoding a picture..
        constexpr uint32_t RLE_PARALLEL_ERR_INT_CLR = (1U << 1);  ///< The clear interrupt bit to sign that rle parallel error when decoding.
        constexpr uint32_t CID_ERR_INT_CLR = (1U << 2);  ///< The clear interrupt bit to sign that scan id check with component fails when decoding.
        constexpr uint32_t C_DHT_DC_ID_ERR_INT_CLR = (1U << 3);  ///< The clear interrupt bit to sign that scan component's dc dht id check with dc dht table's id fails when decoding.
        constexpr uint32_t C_DHT_AC_ID_ERR_INT_CLR = (1U << 4);  ///< The clear interrupt bit to sign that scan component's ac dht id check with ac dht table's id fails when decoding.
        constexpr uint32_t C_DQT_ID_ERR_INT_CLR = (1U << 5);  ///< The clear interrupt bit to sign that scan component's dqt id check with dqt table's id fails when decoding.
        constexpr uint32_t RST_UXP_ERR_INT_CLR = (1U << 6);  ///< The clear interrupt bit to sign that RST header marker is detected but restart interval is 0 when decoding.
        constexpr uint32_t RST_CHECK_NONE_ERR_INT_CLR = (1U << 7);  ///< The clear interrupt bit to sign that RST header marker is not detected but restart interval is not 0 when decoding.
        constexpr uint32_t RST_CHECK_POS_ERR_INT_CLR = (1U << 8);  ///< The clear interrupt bit to sign that RST header marker position mismatches with restart interval when decoding.
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 9);  ///< The clear interrupt bit turns to high level when the last pixel of one square has been transmitted for Tx channel.
        constexpr uint32_t SR_COLOR_MODE_ERR_INT_CLR = (1U << 10);  ///< The clear interrupt bit to sign that the selected source color mode is not supported.
        constexpr uint32_t DCT_DONE_INT_CLR = (1U << 11);  ///< The clear interrupt bit to sign that one dct calculation is finished.
        constexpr uint32_t BS_LAST_BLOCK_EOF_INT_CLR = (1U << 12);  ///< The clear interrupt bit to sign that the coding process for last block is finished.
        constexpr uint32_t SCAN_CHECK_NONE_ERR_INT_CLR = (1U << 13);  ///< The clear interrupt bit to sign that SOS header marker is not detected but there are still components left to be decoded.
        constexpr uint32_t SCAN_CHECK_POS_ERR_INT_CLR = (1U << 14);  ///< The clear interrupt bit to sign that SOS header marker position wrong when decoding.
        constexpr uint32_t UXP_DET_INT_CLR = (1U << 15);  ///< The clear interrupt bit to sign that unsupported header marker is detected when decoding.
        constexpr uint32_t EN_FRAME_EOF_ERR_INT_CLR = (1U << 16);  ///< The clear interrupt bit to sign that received pixel blocks are smaller than expected when encoding.
        constexpr uint32_t EN_FRAME_EOF_LACK_INT_CLR = (1U << 17);  ///< The clear interrupt bit to sign that the frame eof sign bit from dma input is missing when encoding. But the number of pixel blocks is enough.
        constexpr uint32_t DE_FRAME_EOF_ERR_INT_CLR = (1U << 18);  ///< The clear interrupt bit to sign that decoded blocks are smaller than expected when decoding.
        constexpr uint32_t DE_FRAME_EOF_LACK_INT_CLR = (1U << 19);  ///< The clear interrupt bit to sign that the either frame eof from dma input or eoi marker is missing when encoding. But the number of decoded blocks is enough.
        constexpr uint32_t SOS_UNMATCH_ERR_INT_CLR = (1U << 20);  ///< The clear interrupt bit to sign that the component number of a scan is 0 or does not match the sos marker's length when decoding.
        constexpr uint32_t MARKER_ERR_FST_SCAN_INT_CLR = (1U << 21);  ///< The clear interrupt bit to sign that the first scan has header marker error when decoding.
        constexpr uint32_t MARKER_ERR_OTHER_SCAN_INT_CLR = (1U << 22);  ///< The clear interrupt bit to sign that the following scans but not the first scan have header marker error when decoding.
        constexpr uint32_t UNDET_INT_CLR = (1U << 23);  ///< The clear interrupt bit to sign that JPEG format is not detected at the eof data of a packet when decoding.
        constexpr uint32_t DECODE_TIMEOUT_INT_CLR = (1U << 24);  ///< The clear interrupt bit to sign that decode pause time is longer than the setting decode timeout time when decoding.
    }

    /// STATUS0 Register bits
    namespace status0_bits {
        constexpr uint32_t BITSTREAM_EOF_VLD_CNT = (6 << 11);  ///< the valid bit count for last bitstream
        constexpr uint32_t DCTOUT_ZZSCAN_ADDR = (6 << 17);  ///< the zig-zag read addr from dctout_ram
        constexpr uint32_t QNRVAL_ZZSCAN_ADDR = (6 << 23);  ///< the zig-zag read addr from qnrval_ram
        constexpr uint32_t REG_STATE_YUV = (3 << 29);  ///< the state of jpeg fsm
    }

    /// STATUS2 Register bits
    namespace status2_bits {
        constexpr uint32_t SOURCE_PIXEL = (24 << 0);  ///< source pixels fetched from dma
        constexpr uint32_t LAST_BLOCK = (1U << 24);  ///< indicate the encoding process for the last mcu of the picture
        constexpr uint32_t LAST_MCU = (1U << 25);  ///< indicate the encoding process for the last block of the picture
        constexpr uint32_t LAST_DC = (1U << 26);  ///< indicate the encoding process is at the header of the last block of the picture
        constexpr uint32_t PACKFIFO_READY = (1U << 27);  ///< the jpeg pack_fifo ready signal, high active
    }

    /// STATUS3 Register bits
    namespace status3_bits {
        constexpr uint32_t YO = (9 << 0);  ///< component y transferred from rgb input
        constexpr uint32_t Y_READY = (1U << 9);  ///< component y valid signal, high active
        constexpr uint32_t CBO = (9 << 10);  ///< component cb transferred from rgb input
        constexpr uint32_t CB_READY = (1U << 19);  ///< component cb valid signal, high active
        constexpr uint32_t CRO = (9 << 20);  ///< component cr transferred from rgb input
        constexpr uint32_t CR_READY = (1U << 29);  ///< component cr valid signal, high active
    }

    /// STATUS4 Register bits
    namespace status4_bits {
        constexpr uint32_t HFM_BITSTREAM = (32 << 0);  ///< the hufman bitstream during encoding process
    }

    /// DHT_TOTLEN_DC0 Register bits
    namespace dht_totlen_dc0_bits {
        constexpr uint32_t DHT_TOTLEN_DC0 = (32 << 0);  ///< write the numbers of 1~n codeword length sum from 1~16 of dc0 table
    }

    /// DHT_VAl_DC0 Register bits
    namespace dht_val_dc0_bits {
        constexpr uint32_t DHT_VAL_DC0 = (32 << 0);  ///< write codeword corresponding huffman values of dc0 table
    }

    /// DHT_TOTLEN_AC0 Register bits
    namespace dht_totlen_ac0_bits {
        constexpr uint32_t DHT_TOTLEN_AC0 = (32 << 0);  ///< write the numbers of 1~n codeword length sum from 1~16 of ac0 table
    }

    /// DHT_VAl_AC0 Register bits
    namespace dht_val_ac0_bits {
        constexpr uint32_t DHT_VAL_AC0 = (32 << 0);  ///< write codeword corresponding huffman values of ac0 table
    }

    /// DHT_TOTLEN_DC1 Register bits
    namespace dht_totlen_dc1_bits {
        constexpr uint32_t DHT_TOTLEN_DC1 = (32 << 0);  ///< write the numbers of 1~n codeword length sum from 1~16 of dc1 table
    }

    /// DHT_VAl_DC1 Register bits
    namespace dht_val_dc1_bits {
        constexpr uint32_t DHT_VAL_DC1 = (32 << 0);  ///< write codeword corresponding huffman values of dc1 table
    }

    /// DHT_TOTLEN_AC1 Register bits
    namespace dht_totlen_ac1_bits {
        constexpr uint32_t DHT_TOTLEN_AC1 = (32 << 0);  ///< write the numbers of 1~n codeword length sum from 1~16 of ac1 table
    }

    /// DHT_VAl_AC1 Register bits
    namespace dht_val_ac1_bits {
        constexpr uint32_t DHT_VAL_AC1 = (32 << 0);  ///< write codeword corresponding huffman values of ac1 table
    }

    /// DHT_CODEMIN_DC0 Register bits
    namespace dht_codemin_dc0_bits {
        constexpr uint32_t DHT_CODEMIN_DC0 = (32 << 0);  ///< write the minimum codeword of code length from 1~16 of dc0 table. The codeword is left shifted to the MSB position of a 16bit word
    }

    /// DHT_CODEMIN_AC0 Register bits
    namespace dht_codemin_ac0_bits {
        constexpr uint32_t DHT_CODEMIN_AC0 = (32 << 0);  ///< write the minimum codeword of code length from 1~16 of ac0 table. The codeword is left shifted to the MSB position of a 16bit word
    }

    /// DHT_CODEMIN_DC1 Register bits
    namespace dht_codemin_dc1_bits {
        constexpr uint32_t DHT_CODEMIN_DC1 = (32 << 0);  ///< write the minimum codeword of code length from 1~16 of dc1 table. The codeword is left shifted to the MSB position of a 16bit word
    }

    /// DHT_CODEMIN_AC1 Register bits
    namespace dht_codemin_ac1_bits {
        constexpr uint32_t DHT_CODEMIN_AC1 = (32 << 0);  ///< write the minimum codeword of code length from 1~16 of ac1 table. The codeword is left shifted to the MSB position of a 16bit word
    }

    /// DECODER_STATUS0 Register bits
    namespace decoder_status0_bits {
        constexpr uint32_t DECODE_BYTE_CNT = (26 << 0);  ///< Reserved
        constexpr uint32_t HEADER_DEC_ST = (4 << 26);  ///< Reserved
        constexpr uint32_t DECODE_SAMPLE_SEL = (2 << 30);  ///< Reserved
    }

    /// DECODER_STATUS1 Register bits
    namespace decoder_status1_bits {
        constexpr uint32_t ENCODE_DATA = (16 << 0);  ///< Reserved
        constexpr uint32_t COUNT_Q = (7 << 16);  ///< Reserved
        constexpr uint32_t MCU_FSM_READY = (1U << 23);  ///< Reserved
        constexpr uint32_t DECODE_DATA = (8 << 24);  ///< Reserved
    }

    /// DECODER_STATUS2 Register bits
    namespace decoder_status2_bits {
        constexpr uint32_t COMP_BLOCK_NUM = (26 << 0);  ///< Reserved
        constexpr uint32_t SCAN_NUM = (3 << 26);  ///< Reserved
        constexpr uint32_t RST_CHECK_WAIT = (1U << 29);  ///< Reserved
        constexpr uint32_t SCAN_CHECK_WAIT = (1U << 30);  ///< Reserved
        constexpr uint32_t MCU_IN_PROC = (1U << 31);  ///< Reserved
    }

    /// DECODER_STATUS3 Register bits
    namespace decoder_status3_bits {
        constexpr uint32_t LOOKUP_DATA = (32 << 0);  ///< Reserved
    }

    /// DECODER_STATUS4 Register bits
    namespace decoder_status4_bits {
        constexpr uint32_t BLOCK_EOF_CNT = (26 << 0);  ///< Reserved
        constexpr uint32_t DEZIGZAG_READY = (1U << 26);  ///< Reserved
        constexpr uint32_t DE_FRAME_EOF_CHECK = (1U << 27);  ///< Reserved
        constexpr uint32_t DE_DMA2D_IN_PUSH = (1U << 28);  ///< Reserved
    }

    /// DECODER_STATUS5 Register bits
    namespace decoder_status5_bits {
        constexpr uint32_t IDCT_HFM_DATA = (16 << 0);  ///< Reserved
        constexpr uint32_t NS0 = (3 << 16);  ///< Reserved
        constexpr uint32_t NS1 = (3 << 19);  ///< Reserved
        constexpr uint32_t NS2 = (3 << 22);  ///< Reserved
        constexpr uint32_t NS3 = (3 << 25);  ///< Reserved
        constexpr uint32_t DATA_LAST_O = (1U << 28);  ///< Reserved
        constexpr uint32_t RDN_RESULT = (1U << 29);  ///< redundant registers for jpeg
        constexpr uint32_t RDN_ENA = (1U << 30);  ///< redundant control registers for jpeg
    }

    /// STATUS5 Register bits
    namespace status5_bits {
        constexpr uint32_t PIC_BLOCK_NUM = (24 << 0);  ///< Reserved
    }

    /// ECO_LOW Register bits
    namespace eco_low_bits {
        constexpr uint32_t RDN_ECO_LOW = (32 << 0);  ///< redundant registers for jpeg
    }

    /// ECO_HIGH Register bits
    namespace eco_high_bits {
        constexpr uint32_t RDN_ECO_HIGH = (32 << 0);  ///< redundant registers for jpeg
    }

    /// SYS Register bits
    namespace sys_bits {
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Reserved
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t JPEG_VER = (28 << 0);  ///< Reserved
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_CAM_BASE = 0x500DC000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t LCD_CLOCK;  ///< Offset: 0x00 - LCD clock config register.
        volatile uint32_t CAM_CTRL;  ///< Offset: 0x04 - CAM config register.
        volatile uint32_t CAM_CTRL1;  ///< Offset: 0x08 - CAM config register.
        volatile uint32_t CAM_RGB_YUV;  ///< Offset: 0x0C - CAM YUV/RGB converter configuration register.
        volatile uint32_t LCD_RGB_YUV;  ///< Offset: 0x10 - LCD YUV/RGB converter configuration register.
        volatile uint32_t LCD_USER;  ///< Offset: 0x14 - LCD config register.
        volatile uint32_t LCD_MISC;  ///< Offset: 0x18 - LCD config register.
        volatile uint32_t LCD_CTRL;  ///< Offset: 0x1C - LCD config register.
        volatile uint32_t LCD_CTRL1;  ///< Offset: 0x20 - LCD config register.
        volatile uint32_t LCD_CTRL2;  ///< Offset: 0x24 - LCD config register.
        volatile uint32_t LCD_FIRST_CMD_VAL;  ///< Offset: 0x28 - LCD config register.
        volatile uint32_t LCD_LATTER_CMD_VAL;  ///< Offset: 0x2C - LCD config register.
        volatile uint32_t LCD_DLY_MODE_CFG1;  ///< Offset: 0x30 - LCD config register.
        volatile uint32_t LCD_DLY_MODE_CFG2;  ///< Offset: 0x38 - LCD config register.
        volatile uint32_t LC_DMA_INT_ENA;  ///< Offset: 0x64 - LCDCAM interrupt enable register.
        volatile uint32_t LC_DMA_INT_RAW;  ///< Offset: 0x68 - LCDCAM interrupt raw register, valid in level.
        volatile uint32_t LC_DMA_INT_ST;  ///< Offset: 0x6C - LCDCAM interrupt status register.
        volatile uint32_t LC_DMA_INT_CLR;  ///< Offset: 0x70 - LCDCAM interrupt clear register.
        volatile uint32_t LC_REG_DATE;  ///< Offset: 0xFC - Version register
    };

    /// Peripheral instances
    inline Registers* LCD_CAM = reinterpret_cast<Registers*>(LCD_CAM_BASE);

    // Bit definitions
    /// LCD_CLOCK Register bits
    namespace lcd_clock_bits {
        constexpr uint32_t LCD_CLKCNT_N = (6 << 0);  ///< f_LCD_PCLK = f_LCD_CLK / (reg_clkcnt_N + 1) when reg_clk_equ_sysclk is 0.
        constexpr uint32_t LCD_CLK_EQU_SYSCLK = (1U << 6);  ///< 1: f_LCD_PCLK = f_LCD_CLK. 0: f_LCD_PCLK = f_LCD_CLK / (reg_clkcnt_N + 1).
        constexpr uint32_t LCD_CK_IDLE_EDGE = (1U << 7);  ///< 1: LCD_PCLK line is high when idle 0: LCD_PCLK line is low when idle.
        constexpr uint32_t LCD_CK_OUT_EDGE = (1U << 8);  ///< 1: LCD_PCLK line is high in the first half data cycle. 0: LCD_PCLK line is low in the second half data cycle.
        constexpr uint32_t LCD_CLKM_DIV_NUM = (8 << 9);  ///< Integral LCD clock divider value
        constexpr uint32_t LCD_CLKM_DIV_B = (6 << 17);  ///< Fractional clock divider numerator value
        constexpr uint32_t LCD_CLKM_DIV_A = (6 << 23);  ///< Fractional clock divider denominator value
        constexpr uint32_t LCD_CLK_SEL = (2 << 29);  ///< Select LCD module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: no clock.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Set this bit to enable clk gate
    }

    /// CAM_CTRL Register bits
    namespace cam_ctrl_bits {
        constexpr uint32_t CAM_STOP_EN = (1U << 0);  ///< Camera stop enable signal, 1: camera stops when DMA Rx FIFO is full. 0: Not stop.
        constexpr uint32_t CAM_VSYNC_FILTER_THRES = (3 << 1);  ///< Filter threshold value for CAM_VSYNC signal.
        constexpr uint32_t CAM_UPDATE = (1U << 4);  ///< 1: Update Camera registers, will be cleared by hardware. 0 : Not care.
        constexpr uint32_t CAM_BYTE_ORDER = (1U << 5);  ///< 1: Change data bit order, change CAM_DATA_in[7:0] to CAM_DATA_in[0:7] in one byte mode, and bits[15:0] to bits[0:15] in two byte mode. 0: Not change.
        constexpr uint32_t CAM_BIT_ORDER = (1U << 6);  ///< 1: invert data byte order, only valid in 2 byte mode. 0: Not change.
        constexpr uint32_t CAM_LINE_INT_EN = (1U << 7);  ///< 1: Enable to generate CAM_HS_INT. 0: Disable.
        constexpr uint32_t CAM_VS_EOF_EN = (1U << 8);  ///< 1: CAM_VSYNC to generate in_suc_eof. 0: in_suc_eof is controlled by reg_cam_rec_data_cyclelen.
        constexpr uint32_t CAM_CLKM_DIV_NUM = (8 << 9);  ///< Integral Camera clock divider value
        constexpr uint32_t CAM_CLKM_DIV_B = (6 << 17);  ///< Fractional clock divider numerator value
        constexpr uint32_t CAM_CLKM_DIV_A = (6 << 23);  ///< Fractional clock divider denominator value
        constexpr uint32_t CAM_CLK_SEL = (2 << 29);  ///< Select Camera module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: no clock.
    }

    /// CAM_CTRL1 Register bits
    namespace cam_ctrl1_bits {
        constexpr uint32_t CAM_REC_DATA_BYTELEN = (16 << 0);  ///< Camera receive data byte length minus 1 to set DMA in_suc_eof_int.
        constexpr uint32_t CAM_LINE_INT_NUM = (6 << 16);  ///< The line number minus 1 to generate cam_hs_int.
        constexpr uint32_t CAM_CLK_INV = (1U << 22);  ///< 1: Invert the input signal CAM_PCLK. 0: Not invert.
        constexpr uint32_t CAM_VSYNC_FILTER_EN = (1U << 23);  ///< 1: Enable CAM_VSYNC filter function. 0: bypass.
        constexpr uint32_t CAM_2BYTE_EN = (1U << 24);  ///< 1: The bit number of input data is 9~16. 0: The bit number of input data is 0~8.
        constexpr uint32_t CAM_DE_INV = (1U << 25);  ///< CAM_DE invert enable signal, valid in high level.
        constexpr uint32_t CAM_HSYNC_INV = (1U << 26);  ///< CAM_HSYNC invert enable signal, valid in high level.
        constexpr uint32_t CAM_VSYNC_INV = (1U << 27);  ///< CAM_VSYNC invert enable signal, valid in high level.
        constexpr uint32_t CAM_VH_DE_MODE_EN = (1U << 28);  ///< 1: Input control signals are CAM_DE CAM_HSYNC and CAM_VSYNC. 0: Input control signals are CAM_DE and CAM_VSYNC.
        constexpr uint32_t CAM_START = (1U << 29);  ///< Camera module start signal.
        constexpr uint32_t CAM_RESET = (1U << 30);  ///< Camera module reset signal.
        constexpr uint32_t CAM_AFIFO_RESET = (1U << 31);  ///< Camera AFIFO reset signal.
    }

    /// CAM_RGB_YUV Register bits
    namespace cam_rgb_yuv_bits {
        constexpr uint32_t CAM_CONV_8BITS_DATA_INV = (1U << 21);  ///< 1:invert every two 8bits input data. 2. disabled.
        constexpr uint32_t CAM_CONV_YUV2YUV_MODE = (2 << 22);  ///< 0: to yuv422. 1: to yuv420. 2: to yuv411. 3: disabled. To enable yuv2yuv mode, trans_mode must be set to 1.
        constexpr uint32_t CAM_CONV_YUV_MODE = (2 << 24);  ///< 0: yuv422. 1: yuv420. 2: yuv411. When in yuv2yuv mode, yuv_mode decides the yuv mode of Data_in
        constexpr uint32_t CAM_CONV_PROTOCOL_MODE = (1U << 26);  ///< 0:BT601. 1:BT709.
        constexpr uint32_t CAM_CONV_DATA_OUT_MODE = (1U << 27);  ///< LIMIT or FULL mode of Data out. 0: limit. 1: full
        constexpr uint32_t CAM_CONV_DATA_IN_MODE = (1U << 28);  ///< LIMIT or FULL mode of Data in. 0: limit. 1: full
        constexpr uint32_t CAM_CONV_MODE_8BITS_ON = (1U << 29);  ///< 0: 16bits mode. 1: 8bits mode.
        constexpr uint32_t CAM_CONV_TRANS_MODE = (1U << 30);  ///< 0: YUV to RGB. 1: RGB to YUV.
        constexpr uint32_t CAM_CONV_ENABLE = (1U << 31);  ///< 0: Bypass converter. 1: Enable converter.
    }

    /// LCD_RGB_YUV Register bits
    namespace lcd_rgb_yuv_bits {
        constexpr uint32_t LCD_CONV_8BITS_DATA_INV = (1U << 20);  ///< 1:invert every two 8bits input data. 2. disabled.
        constexpr uint32_t LCD_CONV_TXTORX = (1U << 21);  ///< 0: txtorx mode off. 1: txtorx mode on.
        constexpr uint32_t LCD_CONV_YUV2YUV_MODE = (2 << 22);  ///< 0: to yuv422. 1: to yuv420. 2: to yuv411. 3: disabled. To enable yuv2yuv mode, trans_mode must be set to 1.
        constexpr uint32_t LCD_CONV_YUV_MODE = (2 << 24);  ///< 0: yuv422. 1: yuv420. 2: yuv411. When in yuv2yuv mode, yuv_mode decides the yuv mode of Data_in
        constexpr uint32_t LCD_CONV_PROTOCOL_MODE = (1U << 26);  ///< 0:BT601. 1:BT709.
        constexpr uint32_t LCD_CONV_DATA_OUT_MODE = (1U << 27);  ///< LIMIT or FULL mode of Data out. 0: limit. 1: full
        constexpr uint32_t LCD_CONV_DATA_IN_MODE = (1U << 28);  ///< LIMIT or FULL mode of Data in. 0: limit. 1: full
        constexpr uint32_t LCD_CONV_MODE_8BITS_ON = (1U << 29);  ///< 0: 16bits mode. 1: 8bits mode.
        constexpr uint32_t LCD_CONV_TRANS_MODE = (1U << 30);  ///< 0: YUV to RGB. 1: RGB to YUV.
        constexpr uint32_t LCD_CONV_ENABLE = (1U << 31);  ///< 0: Bypass converter. 1: Enable converter.
    }

    /// LCD_USER Register bits
    namespace lcd_user_bits {
        constexpr uint32_t LCD_DOUT_CYCLELEN = (13 << 0);  ///< The output data cycles minus 1 of LCD module.
        constexpr uint32_t LCD_ALWAYS_OUT_EN = (1U << 13);  ///< LCD always output when LCD is in LCD_DOUT state, unless reg_lcd_start is cleared or reg_lcd_reset is set.
        constexpr uint32_t LCD_DOUT_BYTE_SWIZZLE_MODE = (3 << 14);  ///< 0: ABAB->BABA. 1: ABC->ACB. 2: ABC->BAC. 3: ABC->BCA. 4:ABC->CAB. 5:ABC->CBA
        constexpr uint32_t LCD_DOUT_BYTE_SWIZZLE_ENABLE = (1U << 17);  ///< 1: enable byte swizzle 0: disable
        constexpr uint32_t LCD_DOUT_BIT_ORDER = (1U << 18);  ///< 1: change bit order in every byte. 0: Not change.
        constexpr uint32_t LCD_BYTE_MODE = (2 << 19);  ///< 2: 24bit mode. 1: 16bit mode. 0: 8bit mode
        constexpr uint32_t LCD_UPDATE = (1U << 21);  ///< 1: Update LCD registers, will be cleared by hardware. 0 : Not care.
        constexpr uint32_t LCD_BIT_ORDER = (1U << 22);  ///< 1: Change data bit order, change LCD_DATA_out[7:0] to LCD_DATA_out[0:7] in one byte mode, and bits[15:0] to bits[0:15] in two byte mode. 0: Not change.
        constexpr uint32_t LCD_BYTE_ORDER = (1U << 23);  ///< 1: invert data byte order, only valid in 2 byte mode. 0: Not change.
        constexpr uint32_t LCD_DOUT = (1U << 24);  ///< 1: Be able to send data out in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_DUMMY = (1U << 25);  ///< 1: Enable DUMMY phase in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_CMD = (1U << 26);  ///< 1: Be able to send command in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_START = (1U << 27);  ///< LCD start sending data enable signal, valid in high level.
        constexpr uint32_t LCD_RESET = (1U << 28);  ///< The value of command.
        constexpr uint32_t LCD_DUMMY_CYCLELEN = (2 << 29);  ///< The dummy cycle length minus 1.
        constexpr uint32_t LCD_CMD_2_CYCLE_EN = (1U << 31);  ///< The cycle length of command phase. 1: 2 cycles. 0: 1 cycle.
    }

    /// LCD_MISC Register bits
    namespace lcd_misc_bits {
        constexpr uint32_t LCD_WIRE_MODE = (2 << 4);  ///< The wire width of LCD output. 0: 8bit. 1: 16bit 2: 24bit
        constexpr uint32_t LCD_VFK_CYCLELEN = (6 << 6);  ///< The setup cycle length minus 1 in LCD non-RGB mode.
        constexpr uint32_t LCD_VBK_CYCLELEN = (13 << 12);  ///< The vertical back blank region cycle length minus 1 in LCD RGB mode, or the hold time cycle length in LCD non-RGB mode.
        constexpr uint32_t LCD_NEXT_FRAME_EN = (1U << 25);  ///< 1: Send the next frame data when the current frame is sent out. 0: LCD stops when the current frame is sent out.
        constexpr uint32_t LCD_BK_EN = (1U << 26);  ///< 1: Enable blank region when LCD sends data out. 0: No blank region.
        constexpr uint32_t LCD_AFIFO_RESET = (1U << 27);  ///< LCD AFIFO reset signal.
        constexpr uint32_t LCD_CD_DATA_SET = (1U << 28);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_DOUT state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_DUMMY_SET = (1U << 29);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_DUMMY state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_CMD_SET = (1U << 30);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_CMD state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_IDLE_EDGE = (1U << 31);  ///< The default value of LCD_CD.
    }

    /// LCD_CTRL Register bits
    namespace lcd_ctrl_bits {
        constexpr uint32_t LCD_HB_FRONT = (11 << 0);  ///< It is the horizontal blank front porch of a frame.
        constexpr uint32_t LCD_VA_HEIGHT = (10 << 11);  ///< It is the vertical active height of a frame.
        constexpr uint32_t LCD_VT_HEIGHT = (10 << 21);  ///< It is the vertical total height of a frame.
        constexpr uint32_t LCD_RGB_MODE_EN = (1U << 31);  ///< 1: Enable LCD RGB mode. 0: Disable LCD RGB mode.
    }

    /// LCD_CTRL1 Register bits
    namespace lcd_ctrl1_bits {
        constexpr uint32_t LCD_VB_FRONT = (8 << 0);  ///< It is the vertical blank front porch of a frame.
        constexpr uint32_t LCD_HA_WIDTH = (12 << 8);  ///< It is the horizontal active width of a frame.
        constexpr uint32_t LCD_HT_WIDTH = (12 << 20);  ///< It is the horizontal total width of a frame.
    }

    /// LCD_CTRL2 Register bits
    namespace lcd_ctrl2_bits {
        constexpr uint32_t LCD_VSYNC_WIDTH = (7 << 0);  ///< It is the position of LCD_VSYNC active pulse in a line.
        constexpr uint32_t LCD_VSYNC_IDLE_POL = (1U << 7);  ///< It is the idle value of LCD_VSYNC.
        constexpr uint32_t LCD_DE_IDLE_POL = (1U << 8);  ///< It is the idle value of LCD_DE.
        constexpr uint32_t LCD_HS_BLANK_EN = (1U << 9);  ///< 1: The pulse of LCD_HSYNC is out in vertical blanking lines RGB mode. 0: LCD_HSYNC pulse is valid only in active region lines in RGB mode.
        constexpr uint32_t LCD_HSYNC_WIDTH = (7 << 16);  ///< It is the position of LCD_HSYNC active pulse in a line.
        constexpr uint32_t LCD_HSYNC_IDLE_POL = (1U << 23);  ///< It is the idle value of LCD_HSYNC.
        constexpr uint32_t LCD_HSYNC_POSITION = (8 << 24);  ///< It is the position of LCD_HSYNC active pulse in a line.
    }

    /// LCD_FIRST_CMD_VAL Register bits
    namespace lcd_first_cmd_val_bits {
        constexpr uint32_t LCD_FIRST_CMD_VALUE = (32 << 0);  ///< The LCD write command value of first cmd cycle.
    }

    /// LCD_LATTER_CMD_VAL Register bits
    namespace lcd_latter_cmd_val_bits {
        constexpr uint32_t LCD_LATTER_CMD_VALUE = (32 << 0);  ///< The LCD write command value of latter cmd cycle.
    }

    /// LCD_DLY_MODE_CFG1 Register bits
    namespace lcd_dly_mode_cfg1_bits {
        constexpr uint32_t DOUT16_MODE = (2 << 0);  ///< The output data bit 0 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT17_MODE = (2 << 2);  ///< The output data bit 2 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT18_MODE = (2 << 4);  ///< The output data bit 4 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT19_MODE = (2 << 6);  ///< The output data bit 6 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT20_MODE = (2 << 8);  ///< The output data bit 8 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT21_MODE = (2 << 10);  ///< The output data bit 10 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT22_MODE = (2 << 12);  ///< The output data bit 12 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT23_MODE = (2 << 14);  ///< The output data bit 14 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_CD_MODE = (2 << 16);  ///< The output LCD_CD is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_DE_MODE = (2 << 18);  ///< The output LCD_DE is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_HSYNC_MODE = (2 << 20);  ///< The output LCD_HSYNC is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_VSYNC_MODE = (2 << 22);  ///< The output LCD_VSYNC is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
    }

    /// LCD_DLY_MODE_CFG2 Register bits
    namespace lcd_dly_mode_cfg2_bits {
        constexpr uint32_t DOUT0_MODE = (2 << 0);  ///< The output data bit 0 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT1_MODE = (2 << 2);  ///< The output data bit 2 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT2_MODE = (2 << 4);  ///< The output data bit 4 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT3_MODE = (2 << 6);  ///< The output data bit 6 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT4_MODE = (2 << 8);  ///< The output data bit 8 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT5_MODE = (2 << 10);  ///< The output data bit 10 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT6_MODE = (2 << 12);  ///< The output data bit 12 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT7_MODE = (2 << 14);  ///< The output data bit 14 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT8_MODE = (2 << 16);  ///< The output data bit 16 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT9_MODE = (2 << 18);  ///< The output data bit 18 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT10_MODE = (2 << 20);  ///< The output data bit 20 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT11_MODE = (2 << 22);  ///< The output data bit 22 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT12_MODE = (2 << 24);  ///< The output data bit 24 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT13_MODE = (2 << 26);  ///< The output data bit 26 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT14_MODE = (2 << 28);  ///< The output data bit 28 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT15_MODE = (2 << 30);  ///< The output data bit 30 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
    }

    /// LC_DMA_INT_ENA Register bits
    namespace lc_dma_int_ena_bits {
        constexpr uint32_t LCD_VSYNC_INT_ENA = (1U << 0);  ///< The enable bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_ENA = (1U << 1);  ///< The enable bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_ENA = (1U << 2);  ///< The enable bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_ENA = (1U << 3);  ///< The enable bit for Camera line interrupt.
    }

    /// LC_DMA_INT_RAW Register bits
    namespace lc_dma_int_raw_bits {
        constexpr uint32_t LCD_VSYNC_INT_RAW = (1U << 0);  ///< The raw bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_RAW = (1U << 1);  ///< The raw bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_RAW = (1U << 2);  ///< The raw bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_RAW = (1U << 3);  ///< The raw bit for Camera line interrupt.
    }

    /// LC_DMA_INT_ST Register bits
    namespace lc_dma_int_st_bits {
        constexpr uint32_t LCD_VSYNC_INT_ST = (1U << 0);  ///< The status bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_ST = (1U << 1);  ///< The status bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_ST = (1U << 2);  ///< The status bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_ST = (1U << 3);  ///< The status bit for Camera transfer end interrupt.
    }

    /// LC_DMA_INT_CLR Register bits
    namespace lc_dma_int_clr_bits {
        constexpr uint32_t LCD_VSYNC_INT_CLR = (1U << 0);  ///< The clear bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_CLR = (1U << 1);  ///< The clear bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_CLR = (1U << 2);  ///< The clear bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_CLR = (1U << 3);  ///< The clear bit for Camera line interrupt.
    }

    /// LC_REG_DATE Register bits
    namespace lc_reg_date_bits {
        constexpr uint32_t LC_DATE = (28 << 0);  ///< LCD_CAM version control register
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x500D3000;
    constexpr uint32_t MCPWM0_BASE = 0x500C0000;
    constexpr uint32_t MCPWM1_BASE = 0x500C1000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for channel %s
        volatile uint32_t CH%s_HPOINT;  ///< Offset: 0x04 - High point register for channel %s
        volatile uint32_t CH%s_DUTY;  ///< Offset: 0x08 - Initial duty cycle register for channel %s
        volatile uint32_t CH%s_CONF1;  ///< Offset: 0x0C - Configuration register 1 for channel %s
        volatile uint32_t CH%s_DUTY_R;  ///< Offset: 0x10 - Current duty cycle register for channel %s
        volatile uint32_t TIMER%s_CONF;  ///< Offset: 0xA0 - Timer %s configuration register
        volatile uint32_t TIMER%s_VALUE;  ///< Offset: 0xA4 - Timer %s current counter value register
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Interrupt masked status register
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear register
        volatile uint32_t CH%s_GAMMA_CONF;  ///< Offset: 0x100 - Ledc ch%s gamma config register.
        volatile uint32_t EVT_TASK_EN0;  ///< Offset: 0x120 - Ledc event task enable bit register0.
        volatile uint32_t EVT_TASK_EN1;  ///< Offset: 0x124 - Ledc event task enable bit register1.
        volatile uint32_t EVT_TASK_EN2;  ///< Offset: 0x128 - Ledc event task enable bit register2.
        volatile uint32_t TIMER%s_CMP;  ///< Offset: 0x140 - Ledc timer%s compare value register.
        volatile uint32_t TIMER%s_CNT_CAP;  ///< Offset: 0x150 - Ledc timer%s captured count value register.
        volatile uint32_t CONF;  ///< Offset: 0x170 - LEDC global configuration register
        volatile uint32_t DATE;  ///< Offset: 0x174 - Version control register
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);
    inline Registers* MCPWM0 = reinterpret_cast<Registers*>(MCPWM0_BASE);
    inline Registers* MCPWM1 = reinterpret_cast<Registers*>(MCPWM1_BASE);

    // Bit definitions
    /// CH%s_CONF0 Register bits
    namespace ch%s_conf0_bits {
        constexpr uint32_t TIMER_SEL_CH = (2 << 0);  ///< Configures which timer is channel %s selected.\\0: Select timer0\\1: Select timer1\\2: Select timer2\\3: Select timer3
        constexpr uint32_t SIG_OUT_EN_CH = (1U << 2);  ///< Configures whether or not to enable signal output on channel %s.\\0: Signal output disable\\1: Signal output enable
        constexpr uint32_t IDLE_LV_CH = (1U << 3);  ///< Configures the output value when channel %s is inactive. Valid only when LEDC_SIG_OUT_EN_CH%s is 0.\\0: Output level is low\\1: Output level is high
        constexpr uint32_t PARA_UP_CH = (1U << 4);  ///< Configures whether or not to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.\\0: Invalid. No effect\\1: Update
        constexpr uint32_t OVF_NUM_CH = (10 << 5);  ///< Configures the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
        constexpr uint32_t OVF_CNT_EN_CH = (1U << 15);  ///< Configures whether or not to enable the ovf_cnt of channel %s.\\0: Disable\\1: Enable
        constexpr uint32_t OVF_CNT_RESET_CH = (1U << 16);  ///< Configures whether or not to reset the ovf_cnt of channel %s.\\0: Invalid. No effect\\1: Reset the ovf_cnt
    }

    /// CH%s_HPOINT Register bits
    namespace ch%s_hpoint_bits {
        constexpr uint32_t HPOINT_CH = (20 << 0);  ///< Configures high point of signal output on channel %s. The output value changes to high when the selected timers has reached the value specified by this register.
    }

    /// CH%s_DUTY Register bits
    namespace ch%s_duty_bits {
        constexpr uint32_t DUTY_CH = (25 << 0);  ///< Configures the duty of signal output on channel %s.
    }

    /// CH%s_CONF1 Register bits
    namespace ch%s_conf1_bits {
        constexpr uint32_t DUTY_START_CH = (1U << 31);  ///< Configures whether the duty cycle fading configurations take effect.\\0: Not take effect\\1: Take effect
    }

    /// CH%s_DUTY_R Register bits
    namespace ch%s_duty_r_bits {
        constexpr uint32_t DUTY_CH_R = (25 << 0);  ///< Represents the current duty of output signal on channel %s.
    }

    /// TIMER%s_CONF Register bits
    namespace timer%s_conf_bits {
        constexpr uint32_t TIMER_DUTY_RES = (5 << 0);  ///< Configures the range of the counter in timer %s.
        constexpr uint32_t CLK_DIV_TIMER = (18 << 5);  ///< Configures the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
        constexpr uint32_t TIMER_PAUSE = (1U << 23);  ///< Configures whether or not to pause the counter in timer %s.\\0: Normal\\1: Pause
        constexpr uint32_t TIMER_RST = (1U << 24);  ///< Configures whether or not to reset timer %s. The counter will show 0 after reset.\\0: Not reset\\1: Reset
        constexpr uint32_t TICK_SEL_TIMER = (1U << 25);  ///< Configures which clock is timer %s selected. Unused.
        constexpr uint32_t TIMER_PARA_UP = (1U << 26);  ///< Configures whether or not to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.\\0: Invalid. No effect\\1: Update
    }

    /// TIMER%s_VALUE Register bits
    namespace timer%s_value_bits {
        constexpr uint32_t TIMER_CNT = (20 << 0);  ///< Represents the current counter value of timer %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TIMER0_OVF_INT_RAW = (1U << 0);  ///< Raw status bit: The raw interrupt status of LEDC_TIMER0_OVF_INT. Triggered when the timer0 has reached its maximum counter value.
        constexpr uint32_t TIMER1_OVF_INT_RAW = (1U << 1);  ///< Raw status bit: The raw interrupt status of LEDC_TIMER1_OVF_INT. Triggered when the timer1 has reached its maximum counter value.
        constexpr uint32_t TIMER2_OVF_INT_RAW = (1U << 2);  ///< Raw status bit: The raw interrupt status of LEDC_TIMER2_OVF_INT. Triggered when the timer2 has reached its maximum counter value.
        constexpr uint32_t TIMER3_OVF_INT_RAW = (1U << 3);  ///< Raw status bit: The raw interrupt status of LEDC_TIMER3_OVF_INT. Triggered when the timer3 has reached its maximum counter value.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_RAW = (1U << 4);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH0_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_RAW = (1U << 5);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH1_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_RAW = (1U << 6);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH2_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_RAW = (1U << 7);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH3_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_RAW = (1U << 8);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH4_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_RAW = (1U << 9);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH5_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_RAW = (1U << 10);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH6_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_RAW = (1U << 11);  ///< Raw status bit: The raw interrupt status of LEDC_DUTY_CHNG_END_CH7_INT. Triggered when the fading of duty has finished.
        constexpr uint32_t OVF_CNT_CH0_INT_RAW = (1U << 12);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH0_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
        constexpr uint32_t OVF_CNT_CH1_INT_RAW = (1U << 13);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH1_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
        constexpr uint32_t OVF_CNT_CH2_INT_RAW = (1U << 14);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH2_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
        constexpr uint32_t OVF_CNT_CH3_INT_RAW = (1U << 15);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH3_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
        constexpr uint32_t OVF_CNT_CH4_INT_RAW = (1U << 16);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH4_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
        constexpr uint32_t OVF_CNT_CH5_INT_RAW = (1U << 17);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH5_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
        constexpr uint32_t OVF_CNT_CH6_INT_RAW = (1U << 18);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH6_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH6.
        constexpr uint32_t OVF_CNT_CH7_INT_RAW = (1U << 19);  ///< Raw status bit: The raw interrupt status of LEDC_OVF_CNT_CH7_INT. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH7.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TIMER0_OVF_INT_ST = (1U << 0);  ///< Masked status bit: The masked interrupt status of LEDC_TIMER0_OVF_INT. Valid only when LEDC_TIMER0_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER1_OVF_INT_ST = (1U << 1);  ///< Masked status bit: The masked interrupt status of LEDC_TIMER1_OVF_INT. Valid only when LEDC_TIMER1_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER2_OVF_INT_ST = (1U << 2);  ///< Masked status bit: The masked interrupt status of LEDC_TIMER2_OVF_INT. Valid only when LEDC_TIMER2_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER3_OVF_INT_ST = (1U << 3);  ///< Masked status bit: The masked interrupt status of LEDC_TIMER3_OVF_INT. Valid only when LEDC_TIMER3_OVF_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ST = (1U << 4);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH0_INT. Valid only when LEDC_DUTY_CHNG_END_CH0_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ST = (1U << 5);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH1_INT. Valid only when LEDC_DUTY_CHNG_END_CH1_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ST = (1U << 6);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH2_INT. Valid only when LEDC_DUTY_CHNG_END_CH2_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ST = (1U << 7);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH3_INT. Valid only when LEDC_DUTY_CHNG_END_CH3_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ST = (1U << 8);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH4_INT. Valid only when LEDC_DUTY_CHNG_END_CH4_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ST = (1U << 9);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH5_INT. Valid only when LEDC_DUTY_CHNG_END_CH5_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ST = (1U << 10);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH6_INT. Valid only when LEDC_DUTY_CHNG_END_CH6_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ST = (1U << 11);  ///< Masked status bit: The masked interrupt status of LEDC_DUTY_CHNG_END_CH7_INT. Valid only when LEDC_DUTY_CHNG_END_CH7_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH0_INT_ST = (1U << 12);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH0_INT. Valid only when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH1_INT_ST = (1U << 13);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH1_INT. Valid only when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH2_INT_ST = (1U << 14);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH2_INT. Valid only when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH3_INT_ST = (1U << 15);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH3_INT. Valid only when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH4_INT_ST = (1U << 16);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH4_INT. Valid only when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH5_INT_ST = (1U << 17);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH5_INT. Valid only when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH6_INT_ST = (1U << 18);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH6_INT. Valid only when LEDC_OVF_CNT_CH6_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH7_INT_ST = (1U << 19);  ///< Masked status bit: The masked interrupt status of LEDC_OVF_CNT_CH7_INT. Valid only when LEDC_OVF_CNT_CH7_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TIMER0_OVF_INT_ENA = (1U << 0);  ///< Enable bit: Write 1 to enable LEDC_TIMER0_OVF_INT.
        constexpr uint32_t TIMER1_OVF_INT_ENA = (1U << 1);  ///< Enable bit: Write 1 to enable LEDC_TIMER1_OVF_INT.
        constexpr uint32_t TIMER2_OVF_INT_ENA = (1U << 2);  ///< Enable bit: Write 1 to enable LEDC_TIMER2_OVF_INT.
        constexpr uint32_t TIMER3_OVF_INT_ENA = (1U << 3);  ///< Enable bit: Write 1 to enable LEDC_TIMER3_OVF_INT.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ENA = (1U << 4);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH0_INT.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ENA = (1U << 5);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH1_INT.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ENA = (1U << 6);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH2_INT.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ENA = (1U << 7);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH3_INT.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ENA = (1U << 8);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH4_INT.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ENA = (1U << 9);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH5_INT.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ENA = (1U << 10);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH6_INT.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ENA = (1U << 11);  ///< Enable bit: Write 1 to enable LEDC_DUTY_CHNG_END_CH7_INT.
        constexpr uint32_t OVF_CNT_CH0_INT_ENA = (1U << 12);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH0_INT.
        constexpr uint32_t OVF_CNT_CH1_INT_ENA = (1U << 13);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH1_INT.
        constexpr uint32_t OVF_CNT_CH2_INT_ENA = (1U << 14);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH2_INT.
        constexpr uint32_t OVF_CNT_CH3_INT_ENA = (1U << 15);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH3_INT.
        constexpr uint32_t OVF_CNT_CH4_INT_ENA = (1U << 16);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH4_INT.
        constexpr uint32_t OVF_CNT_CH5_INT_ENA = (1U << 17);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH5_INT.
        constexpr uint32_t OVF_CNT_CH6_INT_ENA = (1U << 18);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH6_INT.
        constexpr uint32_t OVF_CNT_CH7_INT_ENA = (1U << 19);  ///< Enable bit: Write 1 to enable LEDC_OVF_CNT_CH7_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TIMER0_OVF_INT_CLR = (1U << 0);  ///< Clear bit: Write 1 to clear LEDC_TIMER0_OVF_INT.
        constexpr uint32_t TIMER1_OVF_INT_CLR = (1U << 1);  ///< Clear bit: Write 1 to clear LEDC_TIMER1_OVF_INT.
        constexpr uint32_t TIMER2_OVF_INT_CLR = (1U << 2);  ///< Clear bit: Write 1 to clear LEDC_TIMER2_OVF_INT.
        constexpr uint32_t TIMER3_OVF_INT_CLR = (1U << 3);  ///< Clear bit: Write 1 to clear LEDC_TIMER3_OVF_INT.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_CLR = (1U << 4);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH0_INT.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_CLR = (1U << 5);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH1_INT.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_CLR = (1U << 6);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH2_INT.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_CLR = (1U << 7);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH3_INT.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_CLR = (1U << 8);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH4_INT.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_CLR = (1U << 9);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH5_INT.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_CLR = (1U << 10);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH6_INT.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_CLR = (1U << 11);  ///< Clear bit: Write 1 to clear LEDC_DUTY_CHNG_END_CH7_INT.
        constexpr uint32_t OVF_CNT_CH0_INT_CLR = (1U << 12);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH0_INT.
        constexpr uint32_t OVF_CNT_CH1_INT_CLR = (1U << 13);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH1_INT.
        constexpr uint32_t OVF_CNT_CH2_INT_CLR = (1U << 14);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH2_INT.
        constexpr uint32_t OVF_CNT_CH3_INT_CLR = (1U << 15);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH3_INT.
        constexpr uint32_t OVF_CNT_CH4_INT_CLR = (1U << 16);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH4_INT.
        constexpr uint32_t OVF_CNT_CH5_INT_CLR = (1U << 17);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH5_INT.
        constexpr uint32_t OVF_CNT_CH6_INT_CLR = (1U << 18);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH6_INT.
        constexpr uint32_t OVF_CNT_CH7_INT_CLR = (1U << 19);  ///< Clear bit: Write 1 to clear LEDC_OVF_CNT_CH7_INT.
    }

    /// CH%s_GAMMA_CONF Register bits
    namespace ch%s_gamma_conf_bits {
        constexpr uint32_t CH_GAMMA_ENTRY_NUM = (5 << 0);  ///< Configures the number of duty cycle fading rages for LEDC ch%s.
        constexpr uint32_t CH_GAMMA_PAUSE = (1U << 5);  ///< Configures whether or not to pause duty cycle fading of LEDC ch%s.\\0: Invalid. No effect\\1: Pause
        constexpr uint32_t CH_GAMMA_RESUME = (1U << 6);  ///< Configures whether or nor to resume duty cycle fading of LEDC ch%s.\\0: Invalid. No effect\\1: Resume
    }

    /// EVT_TASK_EN0 Register bits
    namespace evt_task_en0_bits {
        constexpr uint32_t EVT_DUTY_CHNG_END_CH0_EN = (1U << 0);  ///< Configures whether or not to enable the ledc_ch0_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH1_EN = (1U << 1);  ///< Configures whether or not to enable the ledc_ch1_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH2_EN = (1U << 2);  ///< Configures whether or not to enable the ledc_ch2_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH3_EN = (1U << 3);  ///< Configures whether or not to enable the ledc_ch3_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH4_EN = (1U << 4);  ///< Configures whether or not to enable the ledc_ch4_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH5_EN = (1U << 5);  ///< Configures whether or not to enable the ledc_ch5_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH6_EN = (1U << 6);  ///< Configures whether or not to enable the ledc_ch6_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_DUTY_CHNG_END_CH7_EN = (1U << 7);  ///< Configures whether or not to enable the ledc_ch7_duty_chng_end event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH0_EN = (1U << 8);  ///< Configures whether or not to enable the ledc_ch0_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH1_EN = (1U << 9);  ///< Configures whether or not to enable the ledc_ch1_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH2_EN = (1U << 10);  ///< Configures whether or not to enable the ledc_ch2_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH3_EN = (1U << 11);  ///< Configures whether or not to enable the ledc_ch3_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH4_EN = (1U << 12);  ///< Configures whether or not to enable the ledc_ch4_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH5_EN = (1U << 13);  ///< Configures whether or not to enable the ledc_ch5_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH6_EN = (1U << 14);  ///< Configures whether or not to enable the ledc_ch6_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_OVF_CNT_PLS_CH7_EN = (1U << 15);  ///< Configures whether or not to enable the ledc_ch7_ovf_cnt_pls event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME_OVF_TIMER0_EN = (1U << 16);  ///< Configures whether or not to enable the ledc_timer0_ovf event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME_OVF_TIMER1_EN = (1U << 17);  ///< Configures whether or not to enable the ledc_timer1_ovf event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME_OVF_TIMER2_EN = (1U << 18);  ///< Configures whether or not to enable the ledc_timer2_ovf event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME_OVF_TIMER3_EN = (1U << 19);  ///< Configures whether or not to enable the ledc_timer3_ovf event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME0_CMP_EN = (1U << 20);  ///< Configures whether or not to enable the ledc_timer0_cmp event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME1_CMP_EN = (1U << 21);  ///< Configures whether or not to enable the ledc_timer1_cmp event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME2_CMP_EN = (1U << 22);  ///< Configures whether or not to enable the ledc_timer2_cmp event.\\0: Disable\\1: Enable
        constexpr uint32_t EVT_TIME3_CMP_EN = (1U << 23);  ///< Configures whether or not to enable the ledc_timer3_cmp event.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH0_EN = (1U << 24);  ///< Configures whether or not to enable the ledc_ch0_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH1_EN = (1U << 25);  ///< Configures whether or not to enable the ledc_ch1_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH2_EN = (1U << 26);  ///< Configures whether or not to enable the ledc_ch2_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH3_EN = (1U << 27);  ///< Configures whether or not to enable the ledc_ch3_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH4_EN = (1U << 28);  ///< Configures whether or not to enable the ledc_ch4_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH5_EN = (1U << 29);  ///< Configures whether or not to enable the ledc_ch5_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH6_EN = (1U << 30);  ///< Configures whether or not to enable the ledc_ch6_duty_scale_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_DUTY_SCALE_UPDATE_CH7_EN = (1U << 31);  ///< Configures whether or not to enable the ledc_ch7_duty_scale_update task.\\0: Disable\\1: Enable
    }

    /// EVT_TASK_EN1 Register bits
    namespace evt_task_en1_bits {
        constexpr uint32_t TASK_TIMER0_RES_UPDATE_EN = (1U << 0);  ///< Configures whether or not to enable ledc_timer0_res_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER1_RES_UPDATE_EN = (1U << 1);  ///< Configures whether or not to enable ledc_timer1_res_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER2_RES_UPDATE_EN = (1U << 2);  ///< Configures whether or not to enable ledc_timer2_res_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER3_RES_UPDATE_EN = (1U << 3);  ///< Configures whether or not to enable ledc_timer3_res_update task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER0_CAP_EN = (1U << 4);  ///< Configures whether or not to enable ledc_timer0_cap task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER1_CAP_EN = (1U << 5);  ///< Configures whether or not to enable ledc_timer1_cap task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER2_CAP_EN = (1U << 6);  ///< Configures whether or not to enable ledc_timer2_cap task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER3_CAP_EN = (1U << 7);  ///< Configures whether or not to enable ledc_timer3_cap task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH0_EN = (1U << 8);  ///< Configures whether or not to enable ledc_ch0_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH1_EN = (1U << 9);  ///< Configures whether or not to enable ledc_ch1_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH2_EN = (1U << 10);  ///< Configures whether or not to enable ledc_ch2_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH3_EN = (1U << 11);  ///< Configures whether or not to enable ledc_ch3_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH4_EN = (1U << 12);  ///< Configures whether or not to enable ledc_ch4_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH5_EN = (1U << 13);  ///< Configures whether or not to enable ledc_ch5_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH6_EN = (1U << 14);  ///< Configures whether or not to enable ledc_ch6_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_SIG_OUT_DIS_CH7_EN = (1U << 15);  ///< Configures whether or not to enable ledc_ch7_sig_out_dis task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH0_EN = (1U << 16);  ///< Configures whether or not to enable ledc_ch0_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH1_EN = (1U << 17);  ///< Configures whether or not to enable ledc_ch1_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH2_EN = (1U << 18);  ///< Configures whether or not to enable ledc_ch2_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH3_EN = (1U << 19);  ///< Configures whether or not to enable ledc_ch3_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH4_EN = (1U << 20);  ///< Configures whether or not to enable ledc_ch4_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH5_EN = (1U << 21);  ///< Configures whether or not to enable ledc_ch5_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH6_EN = (1U << 22);  ///< Configures whether or not to enable ledc_ch6_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_OVF_CNT_RST_CH7_EN = (1U << 23);  ///< Configures whether or not to enable ledc_ch7_ovf_cnt_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER0_RST_EN = (1U << 24);  ///< Configures whether or not to enable ledc_timer0_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER1_RST_EN = (1U << 25);  ///< Configures whether or not to enable ledc_timer1_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER2_RST_EN = (1U << 26);  ///< Configures whether or not to enable ledc_timer2_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER3_RST_EN = (1U << 27);  ///< Configures whether or not to enable ledc_timer3_rst task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER0_PAUSE_RESUME_EN = (1U << 28);  ///< Configures whether or not to enable ledc_timer0_pause_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER1_PAUSE_RESUME_EN = (1U << 29);  ///< Configures whether or not to enable ledc_timer1_pause_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER2_PAUSE_RESUME_EN = (1U << 30);  ///< Configures whether or not to enable ledc_timer2_pause_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_TIMER3_PAUSE_RESUME_EN = (1U << 31);  ///< Configures whether or not to enable ledc_timer3_pause_resume task.\\0: Disable\\1: Enable
    }

    /// EVT_TASK_EN2 Register bits
    namespace evt_task_en2_bits {
        constexpr uint32_t TASK_GAMMA_RESTART_CH0_EN = (1U << 0);  ///< Configures whether or not to enable ledc_ch0_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH1_EN = (1U << 1);  ///< Configures whether or not to enable ledc_ch1_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH2_EN = (1U << 2);  ///< Configures whether or not to enable ledc_ch2_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH3_EN = (1U << 3);  ///< Configures whether or not to enable ledc_ch3_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH4_EN = (1U << 4);  ///< Configures whether or not to enable ledc_ch4_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH5_EN = (1U << 5);  ///< Configures whether or not to enable ledc_ch5_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH6_EN = (1U << 6);  ///< Configures whether or not to enable ledc_ch6_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESTART_CH7_EN = (1U << 7);  ///< Configures whether or not to enable ledc_ch7_gamma_restart task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH0_EN = (1U << 8);  ///< Configures whether or not to enable ledc_ch0_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH1_EN = (1U << 9);  ///< Configures whether or not to enable ledc_ch1_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH2_EN = (1U << 10);  ///< Configures whether or not to enable ledc_ch2_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH3_EN = (1U << 11);  ///< Configures whether or not to enable ledc_ch3_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH4_EN = (1U << 12);  ///< Configures whether or not to enable ledc_ch4_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH5_EN = (1U << 13);  ///< Configures whether or not to enable ledc_ch5_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH6_EN = (1U << 14);  ///< Configures whether or not to enable ledc_ch6_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_PAUSE_CH7_EN = (1U << 15);  ///< Configures whether or not to enable ledc_ch7_gamma_pause task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH0_EN = (1U << 16);  ///< Configures whether or not to enable ledc_ch0_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH1_EN = (1U << 17);  ///< Configures whether or not to enable ledc_ch1_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH2_EN = (1U << 18);  ///< Configures whether or not to enable ledc_ch2_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH3_EN = (1U << 19);  ///< Configures whether or not to enable ledc_ch3_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH4_EN = (1U << 20);  ///< Configures whether or not to enable ledc_ch4_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH5_EN = (1U << 21);  ///< Configures whether or not to enable ledc_ch5_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH6_EN = (1U << 22);  ///< Configures whether or not to enable ledc_ch6_gamma_resume task.\\0: Disable\\1: Enable
        constexpr uint32_t TASK_GAMMA_RESUME_CH7_EN = (1U << 23);  ///< Configures whether or not to enable ledc_ch7_gamma_resume task.\\0: Disable\\1: Enable
    }

    /// TIMER%s_CMP Register bits
    namespace timer%s_cmp_bits {
        constexpr uint32_t TIMER_CMP = (20 << 0);  ///< Configures the comparison value for LEDC timer%s.
    }

    /// TIMER%s_CNT_CAP Register bits
    namespace timer%s_cnt_cap_bits {
        constexpr uint32_t TIMER_CNT_CAP = (20 << 0);  ///< Represents the captured LEDC timer%s count value.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< Configures the clock source for the four timers.\\0: APB_CLK\\1: RC_FAST_CLK\\2: XTAL_CLK\\3: Invalid. No clock
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH0 = (1U << 2);  ///< Configures whether or not to open LEDC ch0 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch0 gamma ram\\1: Force open the clock gate for LEDC ch0 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH1 = (1U << 3);  ///< Configures whether or not to open LEDC ch1 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch1 gamma ram\\1: Force open the clock gate for LEDC ch1 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH2 = (1U << 4);  ///< Configures whether or not to open LEDC ch2 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch2 gamma ram\\1: Force open the clock gate for LEDC ch2 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH3 = (1U << 5);  ///< Configures whether or not to open LEDC ch3 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch3 gamma ram\\1: Force open the clock gate for LEDC ch3 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH4 = (1U << 6);  ///< Configures whether or not to open LEDC ch4 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch4 gamma ram\\1: Force open the clock gate for LEDC ch4 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH5 = (1U << 7);  ///< Configures whether or not to open LEDC ch5 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch5 gamma ram\\1: Force open the clock gate for LEDC ch5 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH6 = (1U << 8);  ///< Configures whether or not to open LEDC ch6 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch6 gamma ram\\1: Force open the clock gate for LEDC ch6 gamma ram
        constexpr uint32_t GAMMA_RAM_CLK_EN_CH7 = (1U << 9);  ///< Configures whether or not to open LEDC ch7 gamma ram clock gate.\\0: Open the clock gate only when application writes or reads LEDC ch7 gamma ram\\1: Force open the clock gate for LEDC ch7 gamma ram
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Configures whether or not to open register clock gate.\\0: Open the clock gate only when application writes registers\\1: Force open the clock gate for register
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LEDC_DATE = (28 << 0);  ///< Configures the version.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LP_UART_BASE = 0x50121000;
    constexpr uint32_t UART0_BASE = 0x500CA000;
    constexpr uint32_t UART1_BASE = 0x500CB000;
    constexpr uint32_t UART2_BASE = 0x500CC000;
    constexpr uint32_t UART3_BASE = 0x500CD000;
    constexpr uint32_t UART4_BASE = 0x500CE000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV_SYNC;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0_SYNC;  ///< Offset: 0x20 - Configuration register 0
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t HWFC_CONF_SYNC;  ///< Offset: 0x2C - Hardware flow-control configuration
        volatile uint32_t SLEEP_CONF0;  ///< Offset: 0x30 - UART sleep configure register 0
        volatile uint32_t SLEEP_CONF1;  ///< Offset: 0x34 - UART sleep configure register 1
        volatile uint32_t SLEEP_CONF2;  ///< Offset: 0x38 - UART sleep configure register 2
        volatile uint32_t SWFC_CONF0_SYNC;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF_SYNC;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF_SYNC;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF_SYNC;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT_SYNC;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT_SYNC;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT_SYNC;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR_SYNC;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART memory power configuration
        volatile uint32_t TOUT_CONF_SYNC;  ///< Offset: 0x64 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x68 - Tx-SRAM write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x6C - Rx-SRAM write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x70 - UART transmit and receive status.
        volatile uint32_t CLK_CONF;  ///< Offset: 0x88 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x8C - UART Version register
        volatile uint32_t AFIFO_STATUS;  ///< Offset: 0x90 - UART AFIFO Status
        volatile uint32_t REG_UPDATE;  ///< Offset: 0x98 - UART Registers Configuration Update register
        volatile uint32_t ID;  ///< Offset: 0x9C - UART ID register
    };

    /// Peripheral instances
    inline Registers* LP_UART = reinterpret_cast<Registers*>(LP_UART_BASE);
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV_SYNC Register bits
    namespace clkdiv_sync_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t CLKDIV_FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (5 << 3);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (5 << 19);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0_SYNC Register bits
    namespace conf0_sync_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t TXD_BRK = (1U << 6);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t LOOPBACK = (1U << 12);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 13);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t RXD_INV = (1U << 15);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t TXD_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 17);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t ERR_WR_MASK = (1U << 18);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t MEM_CLK_EN = (1U << 20);  ///< UART memory clock gate enable signal.
        constexpr uint32_t SW_RTS = (1U << 21);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t RXFIFO_RST = (1U << 22);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 23);  ///< Set this bit to reset the uart transmit-FIFO.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (5 << 3);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (5 << 11);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t CTS_INV = (1U << 16);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 17);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t RTS_INV = (1U << 18);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t SW_DTR = (1U << 20);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t CLK_EN = (1U << 21);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// HWFC_CONF_SYNC Register bits
    namespace hwfc_conf_sync_bits {
        constexpr uint32_t RX_FLOW_THRHD = (5 << 3);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 8);  ///< This is the flow enable bit for UART receiver.
    }

    /// SLEEP_CONF0 Register bits
    namespace sleep_conf0_bits {
        constexpr uint32_t WK_CHAR1 = (8 << 0);  ///< This register restores the specified wake up char1 to wake up
        constexpr uint32_t WK_CHAR2 = (8 << 8);  ///< This register restores the specified wake up char2 to wake up
        constexpr uint32_t WK_CHAR3 = (8 << 16);  ///< This register restores the specified wake up char3 to wake up
        constexpr uint32_t WK_CHAR4 = (8 << 24);  ///< This register restores the specified wake up char4 to wake up
    }

    /// SLEEP_CONF1 Register bits
    namespace sleep_conf1_bits {
        constexpr uint32_t WK_CHAR0 = (8 << 0);  ///< This register restores the specified char0 to wake up
    }

    /// SLEEP_CONF2 Register bits
    namespace sleep_conf2_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
        constexpr uint32_t RX_WAKE_UP_THRHD = (5 << 13);  ///< In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
        constexpr uint32_t WK_CHAR_NUM = (3 << 18);  ///< This register is used to select number of wake up char.
        constexpr uint32_t WK_CHAR_MASK = (5 << 21);  ///< This register is used to mask wake up char.
        constexpr uint32_t WK_MODE_SEL = (2 << 26);  ///< This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
    }

    /// SWFC_CONF0_SYNC Register bits
    namespace swfc_conf0_sync_bits {
        constexpr uint32_t XON_CHAR = (8 << 0);  ///< This register stores the Xon flow control char.
        constexpr uint32_t XOFF_CHAR = (8 << 8);  ///< This register stores the Xoff flow control char.
        constexpr uint32_t XON_XOFF_STILL_SEND = (1U << 16);  ///< In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 17);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 18);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 19);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 20);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 21);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 22);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (5 << 3);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1 it will send a Xon char.
        constexpr uint32_t XOFF_THRESHOLD = (5 << 11);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1 it will send a Xoff char.
    }

    /// TXBRK_CONF_SYNC Register bits
    namespace txbrk_conf_sync_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF_SYNC Register bits
    namespace idle_conf_sync_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF_SYNC Register bits
    namespace rs485_conf_sync_bits {
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
    }

    /// AT_CMD_PRECNT_SYNC Register bits
    namespace at_cmd_precnt_sync_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT_SYNC Register bits
    namespace at_cmd_postcnt_sync_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT_SYNC Register bits
    namespace at_cmd_gaptout_sync_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR_SYNC Register bits
    namespace at_cmd_char_sync_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t MEM_FORCE_PD = (1U << 25);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 26);  ///< Set this bit to force power up UART memory.
    }

    /// TOUT_CONF_SYNC Register bits
    namespace tout_conf_sync_bits {
        constexpr uint32_t RX_TOUT_EN = (1U << 0);  ///< This is the enble bit for uart receiver's timeout function.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 1);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 2);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t TX_SRAM_WADDR = (5 << 3);  ///< This register stores the offset write address in Tx-SRAM.
        constexpr uint32_t TX_SRAM_RADDR = (5 << 12);  ///< This register stores the offset read address in Tx-SRAM.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t RX_SRAM_RADDR = (5 << 3);  ///< This register stores the offset read address in RX-SRAM.
        constexpr uint32_t RX_SRAM_WADDR = (5 << 12);  ///< This register stores the offset write address in Rx-SRAM.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t RX_SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit to reset UART Tx.
        constexpr uint32_t RX_RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit to reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// AFIFO_STATUS Register bits
    namespace afifo_status_bits {
        constexpr uint32_t TX_AFIFO_FULL = (1U << 0);  ///< Full signal of APB TX AFIFO.
        constexpr uint32_t TX_AFIFO_EMPTY = (1U << 1);  ///< Empty signal of APB TX AFIFO.
        constexpr uint32_t RX_AFIFO_FULL = (1U << 2);  ///< Full signal of APB RX AFIFO.
        constexpr uint32_t RX_AFIFO_EMPTY = (1U << 3);  ///< Empty signal of APB RX AFIFO.
    }

    /// REG_UPDATE Register bits
    namespace reg_update_bits {
        constexpr uint32_t REG_UPDATE = (1U << 0);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< This register is used to configure the uart_id.
    }

}

// ============================================================================
// PARL Peripheral
// ============================================================================

namespace parl {
    /// Base addresses
    constexpr uint32_t PARL_IO_BASE = 0x500CF000;

    /// PARL Register structure
    struct Registers {
        volatile uint32_t RX_MODE_CFG;  ///< Offset: 0x00 - Parallel RX Sampling mode configuration register.
        volatile uint32_t RX_DATA_CFG;  ///< Offset: 0x04 - Parallel RX data configuration register.
        volatile uint32_t RX_GENRL_CFG;  ///< Offset: 0x08 - Parallel RX general configuration register.
        volatile uint32_t RX_START_CFG;  ///< Offset: 0x0C - Parallel RX Start configuration register.
        volatile uint32_t TX_DATA_CFG;  ///< Offset: 0x10 - Parallel TX data configuration register.
        volatile uint32_t TX_START_CFG;  ///< Offset: 0x14 - Parallel TX Start configuration register.
        volatile uint32_t TX_GENRL_CFG;  ///< Offset: 0x18 - Parallel TX general configuration register.
        volatile uint32_t FIFO_CFG;  ///< Offset: 0x1C - Parallel IO FIFO configuration register.
        volatile uint32_t REG_UPDATE;  ///< Offset: 0x20 - Parallel IO FIFO configuration register.
        volatile uint32_t ST;  ///< Offset: 0x24 - Parallel IO module status register0.
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Parallel IO interrupt enable singal configuration register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x2C - Parallel IO interrupt raw singal status register.
        volatile uint32_t INT_ST;  ///< Offset: 0x30 - Parallel IO interrupt singal status register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x34 - Parallel IO interrupt clear singal configuration register.
        volatile uint32_t RX_ST0;  ///< Offset: 0x38 - Parallel IO RX status register0
        volatile uint32_t RX_ST1;  ///< Offset: 0x3C - Parallel IO RX status register1
        volatile uint32_t TX_ST0;  ///< Offset: 0x40 - Parallel IO TX status register0
        volatile uint32_t RX_CLK_CFG;  ///< Offset: 0x44 - Parallel IO RX clk configuration register
        volatile uint32_t TX_CLK_CFG;  ///< Offset: 0x48 - Parallel IO TX clk configuration register
        volatile uint32_t CLK;  ///< Offset: 0x120 - Parallel IO clk configuration register
        volatile uint32_t VERSION;  ///< Offset: 0x3FC - Version register.
    };

    /// Peripheral instances
    inline Registers* PARL_IO = reinterpret_cast<Registers*>(PARL_IO_BASE);

    // Bit definitions
    /// RX_MODE_CFG Register bits
    namespace rx_mode_cfg_bits {
        constexpr uint32_t RX_EXT_EN_SEL = (4 << 21);  ///< Configures rx external enable signal selection from IO PAD.
        constexpr uint32_t RX_SW_EN = (1U << 25);  ///< Set this bit to enable data sampling by software.
        constexpr uint32_t RX_EXT_EN_INV = (1U << 26);  ///< Set this bit to invert the external enable signal.
        constexpr uint32_t RX_PULSE_SUBMODE_SEL = (3 << 27);  ///< Configures the rxd pulse sampling submode. 4'd0: positive pulse start(data bit included) && positive pulse end(data bit included) 4'd1: positive pulse start(data bit included) && positive pulse end (data bit excluded) 4'd2: positive pulse start(data bit excluded) && positive pulse end (data bit included) 4'd3: positive pulse start(data bit excluded) && positive pulse end (data bit excluded) 4'd4: positive pulse start(data bit included) && length end 4'd5: positive pulse start(data bit excluded) && length end
        constexpr uint32_t RX_SMP_MODE_SEL = (2 << 30);  ///< Configures the rxd sampling mode. 2'b00: external level enable mode 2'b01: external pulse enable mode 2'b10: internal software enable mode
    }

    /// RX_DATA_CFG Register bits
    namespace rx_data_cfg_bits {
        constexpr uint32_t RX_BITLEN = (19 << 9);  ///< Configures expected byte number of received data.
        constexpr uint32_t RX_DATA_ORDER_INV = (1U << 28);  ///< Set this bit to invert bit order of one byte sent from RX_FIFO to DMA.
        constexpr uint32_t RX_BUS_WID_SEL = (3 << 29);  ///< Configures the rxd bus width. 3'd0: bus width is 1. 3'd1: bus width is 2. 3'd2: bus width is 4. 3'd3: bus width is 8.
    }

    /// RX_GENRL_CFG Register bits
    namespace rx_genrl_cfg_bits {
        constexpr uint32_t RX_GATING_EN = (1U << 12);  ///< Set this bit to enable the clock gating of output rx clock.
        constexpr uint32_t RX_TIMEOUT_THRES = (16 << 13);  ///< Configures threshold of timeout counter.
        constexpr uint32_t RX_TIMEOUT_EN = (1U << 29);  ///< Set this bit to enable timeout function to generate error eof.
        constexpr uint32_t RX_EOF_GEN_SEL = (1U << 30);  ///< Configures the DMA eof generated mechanism. 1'b0: eof generated by data bit length. 1'b1: eof generated by external enable signal.
    }

    /// RX_START_CFG Register bits
    namespace rx_start_cfg_bits {
        constexpr uint32_t RX_START = (1U << 31);  ///< Set this bit to start rx data sampling.
    }

    /// TX_DATA_CFG Register bits
    namespace tx_data_cfg_bits {
        constexpr uint32_t TX_BITLEN = (19 << 9);  ///< Configures expected byte number of sent data.
        constexpr uint32_t TX_DATA_ORDER_INV = (1U << 28);  ///< Set this bit to invert bit order of one byte sent from TX_FIFO to IO data.
        constexpr uint32_t TX_BUS_WID_SEL = (3 << 29);  ///< Configures the txd bus width. 3'd0: bus width is 1. 3'd1: bus width is 2. 3'd2: bus width is 4. 3'd3: bus width is 8.
    }

    /// TX_START_CFG Register bits
    namespace tx_start_cfg_bits {
        constexpr uint32_t TX_START = (1U << 31);  ///< Set this bit to start tx data transmit.
    }

    /// TX_GENRL_CFG Register bits
    namespace tx_genrl_cfg_bits {
        constexpr uint32_t TX_EOF_GEN_SEL = (1U << 13);  ///< Configures the tx eof generated mechanism. 1'b0: eof generated by data bit length. 1'b1: eof generated by DMA eof.
        constexpr uint32_t TX_IDLE_VALUE = (16 << 14);  ///< Configures bus value of transmitter in IDLE state.
        constexpr uint32_t TX_GATING_EN = (1U << 30);  ///< Set this bit to enable the clock gating of output tx clock.
        constexpr uint32_t TX_VALID_OUTPUT_EN = (1U << 31);  ///< Set this bit to enable the output of tx data valid signal.
    }

    /// FIFO_CFG Register bits
    namespace fifo_cfg_bits {
        constexpr uint32_t TX_FIFO_SRST = (1U << 30);  ///< Set this bit to reset async fifo in tx module.
        constexpr uint32_t RX_FIFO_SRST = (1U << 31);  ///< Set this bit to reset async fifo in rx module.
    }

    /// REG_UPDATE Register bits
    namespace reg_update_bits {
        constexpr uint32_t RX_REG_UPDATE = (1U << 31);  ///< Set this bit to update rx register configuration.
    }

    /// ST Register bits
    namespace st_bits {
        constexpr uint32_t TX_READY = (1U << 31);  ///< Represents the status that tx is ready to transmit.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_ENA = (1U << 0);  ///< Set this bit to enable TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_ENA = (1U << 1);  ///< Set this bit to enable RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_ENA = (1U << 2);  ///< Set this bit to enable TX_EOF_INT.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_RAW = (1U << 0);  ///< The raw interrupt status of TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_RAW = (1U << 1);  ///< The raw interrupt status of RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_RAW = (1U << 2);  ///< The raw interrupt status of TX_EOF_INT.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_ST = (1U << 0);  ///< The masked interrupt status of TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_ST = (1U << 1);  ///< The masked interrupt status of RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_ST = (1U << 2);  ///< The masked interrupt status of TX_EOF_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TX_FIFO_REMPTY_INT_CLR = (1U << 0);  ///< Set this bit to clear TX_FIFO_REMPTY_INT.
        constexpr uint32_t RX_FIFO_WOVF_INT_CLR = (1U << 1);  ///< Set this bit to clear RX_FIFO_WOVF_INT.
        constexpr uint32_t TX_EOF_INT_CLR = (1U << 2);  ///< Set this bit to clear TX_EOF_INT.
    }

    /// RX_ST0 Register bits
    namespace rx_st0_bits {
        constexpr uint32_t RX_CNT = (5 << 8);  ///< Indicates the cycle number of reading Rx FIFO.
        constexpr uint32_t RX_FIFO_WR_BIT_CNT = (19 << 13);  ///< Indicates the current written bit number into Rx FIFO.
    }

    /// RX_ST1 Register bits
    namespace rx_st1_bits {
        constexpr uint32_t RX_FIFO_RD_BIT_CNT = (19 << 13);  ///< Indicates the current read bit number from Rx FIFO.
    }

    /// TX_ST0 Register bits
    namespace tx_st0_bits {
        constexpr uint32_t TX_CNT = (7 << 6);  ///< Indicates the cycle number of reading Tx FIFO.
        constexpr uint32_t TX_FIFO_RD_BIT_CNT = (19 << 13);  ///< Indicates the current read bit number from Tx FIFO.
    }

    /// RX_CLK_CFG Register bits
    namespace rx_clk_cfg_bits {
        constexpr uint32_t RX_CLK_I_INV = (1U << 30);  ///< Set this bit to invert the input Rx core clock.
        constexpr uint32_t RX_CLK_O_INV = (1U << 31);  ///< Set this bit to invert the output Rx core clock.
    }

    /// TX_CLK_CFG Register bits
    namespace tx_clk_cfg_bits {
        constexpr uint32_t TX_CLK_I_INV = (1U << 30);  ///< Set this bit to invert the input Tx core clock.
        constexpr uint32_t TX_CLK_O_INV = (1U << 31);  ///< Set this bit to invert the output Tx core clock.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EN = (1U << 31);  ///< Force clock on for this register file
    }

    /// VERSION Register bits
    namespace version_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Version of this register file
    }

}

// ============================================================================
// PAU Peripheral
// ============================================================================

namespace pau {
    /// Base addresses
    constexpr uint32_t PAU_BASE = 0x60093000;

    /// PAU Register structure
    struct Registers {
        volatile uint32_t REGDMA_CONF;  ///< Offset: 0x00 - Peri backup control register
        volatile uint32_t REGDMA_CLK_CONF;  ///< Offset: 0x04 - Clock control register
        volatile uint32_t REGDMA_ETM_CTRL;  ///< Offset: 0x08 - ETM start ctrl reg
        volatile uint32_t REGDMA_LINK_0_ADDR;  ///< Offset: 0x0C - link_0_addr
        volatile uint32_t REGDMA_LINK_1_ADDR;  ///< Offset: 0x10 - Link_1_addr
        volatile uint32_t REGDMA_LINK_2_ADDR;  ///< Offset: 0x14 - Link_2_addr
        volatile uint32_t REGDMA_LINK_3_ADDR;  ///< Offset: 0x18 - Link_3_addr
        volatile uint32_t REGDMA_LINK_MAC_ADDR;  ///< Offset: 0x1C - Link_mac_addr
        volatile uint32_t REGDMA_CURRENT_LINK_ADDR;  ///< Offset: 0x20 - current link addr
        volatile uint32_t REGDMA_BACKUP_ADDR;  ///< Offset: 0x24 - Backup addr
        volatile uint32_t REGDMA_MEM_ADDR;  ///< Offset: 0x28 - mem addr
        volatile uint32_t REGDMA_BKP_CONF;  ///< Offset: 0x2C - backup config
        volatile uint32_t INT_ENA;  ///< Offset: 0x30 - Read only register for error and done
        volatile uint32_t INT_RAW;  ///< Offset: 0x34 - Read only register for error and done
        volatile uint32_t INT_CLR;  ///< Offset: 0x38 - Read only register for error and done
        volatile uint32_t INT_ST;  ///< Offset: 0x3C - Read only register for error and done
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Date register.
    };

    /// Peripheral instances
    inline Registers* PAU = reinterpret_cast<Registers*>(PAU_BASE);

    // Bit definitions
    /// REGDMA_CONF Register bits
    namespace regdma_conf_bits {
        constexpr uint32_t FLOW_ERR = (3 << 0);  ///< backup error type
        constexpr uint32_t START = (1U << 3);  ///< backup start signal
        constexpr uint32_t TO_MEM = (1U << 4);  ///< backup direction(reg to mem / mem to reg)
        constexpr uint32_t LINK_SEL = (2 << 5);  ///< Link select
        constexpr uint32_t START_MAC = (1U << 7);  ///< mac sw backup start signal
        constexpr uint32_t TO_MEM_MAC = (1U << 8);  ///< mac sw backup direction(reg to mem / mem to reg)
        constexpr uint32_t SEL_MAC = (1U << 9);  ///< mac hw/sw select
    }

    /// REGDMA_CLK_CONF Register bits
    namespace regdma_clk_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< clock enable
    }

    /// REGDMA_ETM_CTRL Register bits
    namespace regdma_etm_ctrl_bits {
        constexpr uint32_t ETM_START_0 = (1U << 0);  ///< etm_start_0 reg
        constexpr uint32_t ETM_START_1 = (1U << 1);  ///< etm_start_1 reg
        constexpr uint32_t ETM_START_2 = (1U << 2);  ///< etm_start_2 reg
        constexpr uint32_t ETM_START_3 = (1U << 3);  ///< etm_start_3 reg
    }

    /// REGDMA_LINK_0_ADDR Register bits
    namespace regdma_link_0_addr_bits {
        constexpr uint32_t LINK_ADDR_0 = (32 << 0);  ///< link_0_addr reg
    }

    /// REGDMA_LINK_1_ADDR Register bits
    namespace regdma_link_1_addr_bits {
        constexpr uint32_t LINK_ADDR_1 = (32 << 0);  ///< Link_1_addr reg
    }

    /// REGDMA_LINK_2_ADDR Register bits
    namespace regdma_link_2_addr_bits {
        constexpr uint32_t LINK_ADDR_2 = (32 << 0);  ///< Link_2_addr reg
    }

    /// REGDMA_LINK_3_ADDR Register bits
    namespace regdma_link_3_addr_bits {
        constexpr uint32_t LINK_ADDR_3 = (32 << 0);  ///< Link_3_addr reg
    }

    /// REGDMA_LINK_MAC_ADDR Register bits
    namespace regdma_link_mac_addr_bits {
        constexpr uint32_t LINK_ADDR_MAC = (32 << 0);  ///< Link_mac_addr reg
    }

    /// REGDMA_CURRENT_LINK_ADDR Register bits
    namespace regdma_current_link_addr_bits {
        constexpr uint32_t CURRENT_LINK_ADDR = (32 << 0);  ///< current link addr reg
    }

    /// REGDMA_BACKUP_ADDR Register bits
    namespace regdma_backup_addr_bits {
        constexpr uint32_t BACKUP_ADDR = (32 << 0);  ///< backup addr reg
    }

    /// REGDMA_MEM_ADDR Register bits
    namespace regdma_mem_addr_bits {
        constexpr uint32_t MEM_ADDR = (32 << 0);  ///< mem addr reg
    }

    /// REGDMA_BKP_CONF Register bits
    namespace regdma_bkp_conf_bits {
        constexpr uint32_t READ_INTERVAL = (7 << 0);  ///< Link read_interval
        constexpr uint32_t LINK_TOUT_THRES = (10 << 7);  ///< link wait timeout threshold
        constexpr uint32_t BURST_LIMIT = (5 << 17);  ///< burst limit
        constexpr uint32_t BACKUP_TOUT_THRES = (10 << 22);  ///< Backup timeout threshold
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t DONE_INT_ENA = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_ENA = (1U << 1);  ///< error flag
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t DONE_INT_RAW = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_RAW = (1U << 1);  ///< error flag
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t DONE_INT_CLR = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_CLR = (1U << 1);  ///< error flag
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t DONE_INT_ST = (1U << 0);  ///< backup done flag
        constexpr uint32_t ERROR_INT_ST = (1U << 1);  ///< error flag
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< REGDMA date information/ REGDMA version information.
    }

}

// ============================================================================
// PCNT Peripheral
// ============================================================================

namespace pcnt {
    /// Base addresses
    constexpr uint32_t PCNT_BASE = 0x500C9000;

    /// PCNT Register structure
    struct Registers {
        volatile uint32_t U%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for unit %s
        volatile uint32_t U%s_CONF1;  ///< Offset: 0x04 - Configuration register 1 for unit %s
        volatile uint32_t U%s_CONF2;  ///< Offset: 0x08 - Configuration register 2 for unit %s
        volatile uint32_t U%s_CNT;  ///< Offset: 0x30 - Counter value for unit %s
        volatile uint32_t INT_RAW;  ///< Offset: 0x40 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - Interrupt status register
        volatile uint32_t INT_ENA;  ///< Offset: 0x48 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - Interrupt clear register
        volatile uint32_t U%s_STATUS;  ///< Offset: 0x50 - PNCT UNIT%s status register
        volatile uint32_t CTRL;  ///< Offset: 0x60 - Control register for all counters
        volatile uint32_t U3_CHANGE_CONF;  ///< Offset: 0x64 - Configuration register for unit $n's step value.
        volatile uint32_t U2_CHANGE_CONF;  ///< Offset: 0x68 - Configuration register for unit $n's step value.
        volatile uint32_t U1_CHANGE_CONF;  ///< Offset: 0x6C - Configuration register for unit $n's step value.
        volatile uint32_t U0_CHANGE_CONF;  ///< Offset: 0x70 - Configuration register for unit $n's step value.
        volatile uint32_t DATE;  ///< Offset: 0xFC - PCNT version control register
    };

    /// Peripheral instances
    inline Registers* PCNT = reinterpret_cast<Registers*>(PCNT_BASE);

    // Bit definitions
    /// U%s_CONF0 Register bits
    namespace u%s_conf0_bits {
        constexpr uint32_t FILTER_THRES_U = (10 << 0);  ///< This sets the maximum threshold, in APB_CLK cycles, for the filter. Any pulses with width less than this will be ignored when the filter is enabled.
        constexpr uint32_t FILTER_EN_U = (1U << 10);  ///< This is the enable bit for unit %s's input filter.
        constexpr uint32_t THR_ZERO_EN_U = (1U << 11);  ///< This is the enable bit for unit %s's zero comparator.
        constexpr uint32_t THR_H_LIM_EN_U = (1U << 12);  ///< This is the enable bit for unit %s's thr_h_lim comparator. Configures it to enable the high limit interrupt.
        constexpr uint32_t THR_L_LIM_EN_U = (1U << 13);  ///< This is the enable bit for unit %s's thr_l_lim comparator. Configures it to enable the low limit interrupt.
        constexpr uint32_t THR_THRES0_EN_U = (1U << 14);  ///< This is the enable bit for unit %s's thres0 comparator.
        constexpr uint32_t THR_THRES1_EN_U = (1U << 15);  ///< This is the enable bit for unit %s's thres1 comparator.
        constexpr uint32_t CH0_NEG_MODE_U = (2 << 16);  ///< This register sets the behavior when the signal input of channel 0 detects a negative edge. 1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
        constexpr uint32_t CH0_POS_MODE_U = (2 << 18);  ///< This register sets the behavior when the signal input of channel 0 detects a positive edge. 1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
        constexpr uint32_t CH0_HCTRL_MODE_U = (2 << 20);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH0_LCTRL_MODE_U = (2 << 22);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH1_NEG_MODE_U = (2 << 24);  ///< This register sets the behavior when the signal input of channel 1 detects a negative edge. 1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
        constexpr uint32_t CH1_POS_MODE_U = (2 << 26);  ///< This register sets the behavior when the signal input of channel 1 detects a positive edge. 1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
        constexpr uint32_t CH1_HCTRL_MODE_U = (2 << 28);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
        constexpr uint32_t CH1_LCTRL_MODE_U = (2 << 30);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
    }

    /// U%s_CONF1 Register bits
    namespace u%s_conf1_bits {
        constexpr uint32_t CNT_THRES0_U = (16 << 0);  ///< This register is used to configure the thres0 value for unit %s.
        constexpr uint32_t CNT_THRES1_U = (16 << 16);  ///< This register is used to configure the thres1 value for unit %s.
    }

    /// U%s_CONF2 Register bits
    namespace u%s_conf2_bits {
        constexpr uint32_t CNT_H_LIM_U = (16 << 0);  ///< This register is used to configure the thr_h_lim value for unit %s. When pcnt reaches this value, the counter will be cleared to 0.
        constexpr uint32_t CNT_L_LIM_U = (16 << 16);  ///< This register is used to configure the thr_l_lim value for unit %s. When pcnt reaches this value, the counter will be cleared to 0.
    }

    /// U%s_CNT Register bits
    namespace u%s_cnt_bits {
        constexpr uint32_t PULSE_CNT_U = (16 << 0);  ///< This register stores the current pulse count value for unit %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CNT_THR_EVENT_U0_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CNT_THR_EVENT_U0_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CNT_THR_EVENT_U0_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CNT_THR_EVENT_U0_INT_CLR = (1U << 0);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1_INT_CLR = (1U << 1);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2_INT_CLR = (1U << 2);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3_INT_CLR = (1U << 3);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// U%s_STATUS Register bits
    namespace u%s_status_bits {
        constexpr uint32_t CNT_THR_ZERO_MODE_U = (2 << 0);  ///< The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
        constexpr uint32_t CNT_THR_THRES1_LAT_U = (1U << 2);  ///< The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
        constexpr uint32_t CNT_THR_THRES0_LAT_U = (1U << 3);  ///< The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
        constexpr uint32_t CNT_THR_L_LIM_LAT_U = (1U << 4);  ///< The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
        constexpr uint32_t CNT_THR_H_LIM_LAT_U = (1U << 5);  ///< The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
        constexpr uint32_t CNT_THR_ZERO_LAT_U = (1U << 6);  ///< The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PULSE_CNT_RST_U0 = (1U << 0);  ///< Set this bit to clear unit 0's counter.
        constexpr uint32_t CNT_PAUSE_U0 = (1U << 1);  ///< Set this bit to freeze unit 0's counter.
        constexpr uint32_t PULSE_CNT_RST_U1 = (1U << 2);  ///< Set this bit to clear unit 1's counter.
        constexpr uint32_t CNT_PAUSE_U1 = (1U << 3);  ///< Set this bit to freeze unit 1's counter.
        constexpr uint32_t PULSE_CNT_RST_U2 = (1U << 4);  ///< Set this bit to clear unit 2's counter.
        constexpr uint32_t CNT_PAUSE_U2 = (1U << 5);  ///< Set this bit to freeze unit 2's counter.
        constexpr uint32_t PULSE_CNT_RST_U3 = (1U << 6);  ///< Set this bit to clear unit 3's counter.
        constexpr uint32_t CNT_PAUSE_U3 = (1U << 7);  ///< Set this bit to freeze unit 3's counter.
        constexpr uint32_t DALTA_CHANGE_EN_U0 = (1U << 8);  ///< Configures this bit to enable unit 0's step comparator.
        constexpr uint32_t DALTA_CHANGE_EN_U1 = (1U << 9);  ///< Configures this bit to enable unit 1's step comparator.
        constexpr uint32_t DALTA_CHANGE_EN_U2 = (1U << 10);  ///< Configures this bit to enable unit 2's step comparator.
        constexpr uint32_t DALTA_CHANGE_EN_U3 = (1U << 11);  ///< Configures this bit to enable unit 3's step comparator.
        constexpr uint32_t CLK_EN = (1U << 16);  ///< The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
    }

    /// U3_CHANGE_CONF Register bits
    namespace u3_change_conf_bits {
        constexpr uint32_t CNT_STEP_U3 = (16 << 0);  ///< Configures the step value for unit 3.
        constexpr uint32_t CNT_STEP_LIM_U3 = (16 << 16);  ///< Configures the step limit value for unit 3.
    }

    /// U2_CHANGE_CONF Register bits
    namespace u2_change_conf_bits {
        constexpr uint32_t CNT_STEP_U2 = (16 << 0);  ///< Configures the step value for unit 2.
        constexpr uint32_t CNT_STEP_LIM_U2 = (16 << 16);  ///< Configures the step limit value for unit 2.
    }

    /// U1_CHANGE_CONF Register bits
    namespace u1_change_conf_bits {
        constexpr uint32_t CNT_STEP_U1 = (16 << 0);  ///< Configures the step value for unit 1.
        constexpr uint32_t CNT_STEP_LIM_U1 = (16 << 16);  ///< Configures the step limit value for unit 1.
    }

    /// U0_CHANGE_CONF Register bits
    namespace u0_change_conf_bits {
        constexpr uint32_t CNT_STEP_U0 = (16 << 0);  ///< Configures the step value for unit 0.
        constexpr uint32_t CNT_STEP_LIM_U0 = (16 << 16);  ///< Configures the step limit value for unit 0.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the PCNT version control register.
    }

}

// ============================================================================
// PMU Peripheral
// ============================================================================

namespace pmu {
    /// Base addresses
    constexpr uint32_t PMU_BASE = 0x50115000;

    /// PMU Register structure
    struct Registers {
        volatile uint32_t HP_ACTIVE_DIG_POWER;  ///< Offset: 0x00 - need_des
        volatile uint32_t HP_ACTIVE_ICG_HP_FUNC;  ///< Offset: 0x04 - need_des
        volatile uint32_t HP_ACTIVE_ICG_HP_APB;  ///< Offset: 0x08 - need_des
        volatile uint32_t HP_ACTIVE_ICG_MODEM;  ///< Offset: 0x0C - need_des
        volatile uint32_t HP_ACTIVE_HP_SYS_CNTL;  ///< Offset: 0x10 - need_des
        volatile uint32_t HP_ACTIVE_HP_CK_POWER;  ///< Offset: 0x14 - need_des
        volatile uint32_t HP_ACTIVE_BIAS;  ///< Offset: 0x18 - need_des
        volatile uint32_t HP_ACTIVE_BACKUP;  ///< Offset: 0x1C - need_des
        volatile uint32_t HP_ACTIVE_BACKUP_CLK;  ///< Offset: 0x20 - need_des
        volatile uint32_t HP_ACTIVE_SYSCLK;  ///< Offset: 0x24 - need_des
        volatile uint32_t HP_ACTIVE_HP_REGULATOR0;  ///< Offset: 0x28 - need_des
        volatile uint32_t HP_ACTIVE_HP_REGULATOR1;  ///< Offset: 0x2C - need_des
        volatile uint32_t HP_ACTIVE_XTAL;  ///< Offset: 0x30 - need_des
        volatile uint32_t HP_MODEM_DIG_POWER;  ///< Offset: 0x34 - need_des
        volatile uint32_t HP_MODEM_ICG_HP_FUNC;  ///< Offset: 0x38 - need_des
        volatile uint32_t HP_MODEM_ICG_HP_APB;  ///< Offset: 0x3C - need_des
        volatile uint32_t HP_MODEM_ICG_MODEM;  ///< Offset: 0x40 - need_des
        volatile uint32_t HP_MODEM_HP_SYS_CNTL;  ///< Offset: 0x44 - need_des
        volatile uint32_t HP_MODEM_HP_CK_POWER;  ///< Offset: 0x48 - need_des
        volatile uint32_t HP_MODEM_BIAS;  ///< Offset: 0x4C - need_des
        volatile uint32_t HP_MODEM_BACKUP;  ///< Offset: 0x50 - need_des
        volatile uint32_t HP_MODEM_BACKUP_CLK;  ///< Offset: 0x54 - need_des
        volatile uint32_t HP_MODEM_SYSCLK;  ///< Offset: 0x58 - need_des
        volatile uint32_t HP_MODEM_HP_REGULATOR0;  ///< Offset: 0x5C - need_des
        volatile uint32_t HP_MODEM_HP_REGULATOR1;  ///< Offset: 0x60 - need_des
        volatile uint32_t HP_MODEM_XTAL;  ///< Offset: 0x64 - need_des
        volatile uint32_t HP_SLEEP_DIG_POWER;  ///< Offset: 0x68 - need_des
        volatile uint32_t HP_SLEEP_ICG_HP_FUNC;  ///< Offset: 0x6C - need_des
        volatile uint32_t HP_SLEEP_ICG_HP_APB;  ///< Offset: 0x70 - need_des
        volatile uint32_t HP_SLEEP_ICG_MODEM;  ///< Offset: 0x74 - need_des
        volatile uint32_t HP_SLEEP_HP_SYS_CNTL;  ///< Offset: 0x78 - need_des
        volatile uint32_t HP_SLEEP_HP_CK_POWER;  ///< Offset: 0x7C - need_des
        volatile uint32_t HP_SLEEP_BIAS;  ///< Offset: 0x80 - need_des
        volatile uint32_t HP_SLEEP_BACKUP;  ///< Offset: 0x84 - need_des
        volatile uint32_t HP_SLEEP_BACKUP_CLK;  ///< Offset: 0x88 - need_des
        volatile uint32_t HP_SLEEP_SYSCLK;  ///< Offset: 0x8C - need_des
        volatile uint32_t HP_SLEEP_HP_REGULATOR0;  ///< Offset: 0x90 - need_des
        volatile uint32_t HP_SLEEP_HP_REGULATOR1;  ///< Offset: 0x94 - need_des
        volatile uint32_t HP_SLEEP_XTAL;  ///< Offset: 0x98 - need_des
        volatile uint32_t HP_SLEEP_LP_REGULATOR0;  ///< Offset: 0x9C - need_des
        volatile uint32_t HP_SLEEP_LP_REGULATOR1;  ///< Offset: 0xA0 - need_des
        volatile uint32_t HP_SLEEP_LP_DCDC_RESERVE;  ///< Offset: 0xA4 - need_des
        volatile uint32_t HP_SLEEP_LP_DIG_POWER;  ///< Offset: 0xA8 - need_des
        volatile uint32_t HP_SLEEP_LP_CK_POWER;  ///< Offset: 0xAC - need_des
        volatile uint32_t LP_SLEEP_LP_BIAS_RESERVE;  ///< Offset: 0xB0 - need_des
        volatile uint32_t LP_SLEEP_LP_REGULATOR0;  ///< Offset: 0xB4 - need_des
        volatile uint32_t LP_SLEEP_LP_REGULATOR1;  ///< Offset: 0xB8 - need_des
        volatile uint32_t LP_SLEEP_XTAL;  ///< Offset: 0xBC - need_des
        volatile uint32_t LP_SLEEP_LP_DIG_POWER;  ///< Offset: 0xC0 - need_des
        volatile uint32_t LP_SLEEP_LP_CK_POWER;  ///< Offset: 0xC4 - need_des
        volatile uint32_t LP_SLEEP_BIAS;  ///< Offset: 0xC8 - need_des
        volatile uint32_t IMM_HP_CK_POWER;  ///< Offset: 0xCC - need_des
        volatile uint32_t IMM_SLEEP_SYSCLK;  ///< Offset: 0xD0 - need_des
        volatile uint32_t IMM_HP_FUNC_ICG;  ///< Offset: 0xD4 - need_des
        volatile uint32_t IMM_HP_APB_ICG;  ///< Offset: 0xD8 - need_des
        volatile uint32_t IMM_MODEM_ICG;  ///< Offset: 0xDC - need_des
        volatile uint32_t IMM_LP_ICG;  ///< Offset: 0xE0 - need_des
        volatile uint32_t IMM_PAD_HOLD_ALL;  ///< Offset: 0xE4 - need_des
        volatile uint32_t IMM_I2C_ISO;  ///< Offset: 0xE8 - need_des
        volatile uint32_t POWER_WAIT_TIMER0;  ///< Offset: 0xEC - need_des
        volatile uint32_t POWER_WAIT_TIMER1;  ///< Offset: 0xF0 - need_des
        volatile uint32_t POWER_PD_TOP_CNTL;  ///< Offset: 0xF4 - need_des
        volatile uint32_t POWER_PD_CNNT_CNTL;  ///< Offset: 0xF8 - need_des
        volatile uint32_t POWER_PD_HPMEM_CNTL;  ///< Offset: 0xFC - need_des
        volatile uint32_t POWER_PD_TOP_MASK;  ///< Offset: 0x100 - need_des
        volatile uint32_t POWER_PD_CNNT_MASK;  ///< Offset: 0x104 - need_des
        volatile uint32_t POWER_PD_HPMEM_MASK;  ///< Offset: 0x108 - need_des
        volatile uint32_t POWER_DCDC_SWITCH;  ///< Offset: 0x10C - need_des
        volatile uint32_t POWER_PD_LPPERI_CNTL;  ///< Offset: 0x110 - need_des
        volatile uint32_t POWER_PD_LPPERI_MASK;  ///< Offset: 0x114 - need_des
        volatile uint32_t POWER_HP_PAD;  ///< Offset: 0x118 - need_des
        volatile uint32_t POWER_CK_WAIT_CNTL;  ///< Offset: 0x11C - need_des
        volatile uint32_t SLP_WAKEUP_CNTL0;  ///< Offset: 0x120 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL1;  ///< Offset: 0x124 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL2;  ///< Offset: 0x128 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL3;  ///< Offset: 0x12C - need_des
        volatile uint32_t SLP_WAKEUP_CNTL4;  ///< Offset: 0x130 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL5;  ///< Offset: 0x134 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL6;  ///< Offset: 0x138 - need_des
        volatile uint32_t SLP_WAKEUP_CNTL7;  ///< Offset: 0x13C - need_des
        volatile uint32_t SLP_WAKEUP_CNTL8;  ///< Offset: 0x140 - need_des
        volatile uint32_t SLP_WAKEUP_STATUS0;  ///< Offset: 0x144 - need_des
        volatile uint32_t SLP_WAKEUP_STATUS1;  ///< Offset: 0x148 - need_des
        volatile uint32_t SLP_WAKEUP_STATUS2;  ///< Offset: 0x14C - need_des
        volatile uint32_t HP_CK_POWERON;  ///< Offset: 0x150 - need_des
        volatile uint32_t HP_CK_CNTL;  ///< Offset: 0x154 - need_des
        volatile uint32_t POR_STATUS;  ///< Offset: 0x158 - need_des
        volatile uint32_t RF_PWC;  ///< Offset: 0x15C - need_des
        volatile uint32_t BACKUP_CFG;  ///< Offset: 0x160 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x164 - need_des
        volatile uint32_t HP_INT_ST;  ///< Offset: 0x168 - need_des
        volatile uint32_t HP_INT_ENA;  ///< Offset: 0x16C - need_des
        volatile uint32_t HP_INT_CLR;  ///< Offset: 0x170 - need_des
        volatile uint32_t LP_INT_RAW;  ///< Offset: 0x174 - need_des
        volatile uint32_t LP_INT_ST;  ///< Offset: 0x178 - need_des
        volatile uint32_t LP_INT_ENA;  ///< Offset: 0x17C - need_des
        volatile uint32_t LP_INT_CLR;  ///< Offset: 0x180 - need_des
        volatile uint32_t LP_CPU_PWR0;  ///< Offset: 0x184 - need_des
        volatile uint32_t LP_CPU_PWR1;  ///< Offset: 0x188 - need_des
        volatile uint32_t LP_CPU_PWR2;  ///< Offset: 0x18C - need_des
        volatile uint32_t LP_CPU_PWR3;  ///< Offset: 0x190 - need_des
        volatile uint32_t LP_CPU_PWR4;  ///< Offset: 0x194 - need_des
        volatile uint32_t LP_CPU_PWR5;  ///< Offset: 0x198 - need_des
        volatile uint32_t HP_LP_CPU_COMM;  ///< Offset: 0x19C - need_des
        volatile uint32_t HP_REGULATOR_CFG;  ///< Offset: 0x1A0 - need_des
        volatile uint32_t MAIN_STATE;  ///< Offset: 0x1A4 - need_des
        volatile uint32_t PWR_STATE;  ///< Offset: 0x1A8 - need_des
        volatile uint32_t CLK_STATE0;  ///< Offset: 0x1AC - need_des
        volatile uint32_t CLK_STATE1;  ///< Offset: 0x1B0 - need_des
        volatile uint32_t CLK_STATE2;  ///< Offset: 0x1B4 - need_des
        volatile uint32_t EXT_LDO_P0_0P1A;  ///< Offset: 0x1B8 - need_des
        volatile uint32_t EXT_LDO_P0_0P1A_ANA;  ///< Offset: 0x1BC - need_des
        volatile uint32_t EXT_LDO_P0_0P2A;  ///< Offset: 0x1C0 - need_des
        volatile uint32_t EXT_LDO_P0_0P2A_ANA;  ///< Offset: 0x1C4 - need_des
        volatile uint32_t EXT_LDO_P0_0P3A;  ///< Offset: 0x1C8 - need_des
        volatile uint32_t EXT_LDO_P0_0P3A_ANA;  ///< Offset: 0x1CC - need_des
        volatile uint32_t EXT_LDO_P1_0P1A;  ///< Offset: 0x1D0 - need_des
        volatile uint32_t EXT_LDO_P1_0P1A_ANA;  ///< Offset: 0x1D4 - need_des
        volatile uint32_t EXT_LDO_P1_0P2A;  ///< Offset: 0x1D8 - need_des
        volatile uint32_t EXT_LDO_P1_0P2A_ANA;  ///< Offset: 0x1DC - need_des
        volatile uint32_t EXT_LDO_P1_0P3A;  ///< Offset: 0x1E0 - need_des
        volatile uint32_t EXT_LDO_P1_0P3A_ANA;  ///< Offset: 0x1E4 - need_des
        volatile uint32_t EXT_WAKEUP_LV;  ///< Offset: 0x1E8 - need_des
        volatile uint32_t EXT_WAKEUP_SEL;  ///< Offset: 0x1EC - need_des
        volatile uint32_t EXT_WAKEUP_ST;  ///< Offset: 0x1F0 - need_des
        volatile uint32_t EXT_WAKEUP_CNTL;  ///< Offset: 0x1F4 - need_des
        volatile uint32_t SDIO_WAKEUP_CNTL;  ///< Offset: 0x1F8 - need_des
        volatile uint32_t XTAL_SLP;  ///< Offset: 0x1FC - need_des
        volatile uint32_t CPU_SW_STALL;  ///< Offset: 0x200 - need_des
        volatile uint32_t DCM_CTRL;  ///< Offset: 0x204 - need_des
        volatile uint32_t DCM_WAIT_DELAY;  ///< Offset: 0x208 - need_des
        volatile uint32_t VDDBAT_CFG;  ///< Offset: 0x20C - need_des
        volatile uint32_t TOUCH_PWR_CNTL;  ///< Offset: 0x210 - need_des
        volatile uint32_t RDN_ECO;  ///< Offset: 0x214 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* PMU = reinterpret_cast<Registers*>(PMU_BASE);

    // Bit definitions
    /// HP_ACTIVE_DIG_POWER Register bits
    namespace hp_active_dig_power_bits {
        constexpr uint32_t HP_ACTIVE_DCDC_SWITCH_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_HP_MEM_PD_EN = (1U << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_CNNT_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_ACTIVE_ICG_HP_FUNC Register bits
    namespace hp_active_icg_hp_func_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_ICG_HP_APB Register bits
    namespace hp_active_icg_hp_apb_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_ICG_MODEM Register bits
    namespace hp_active_icg_modem_bits {
        constexpr uint32_t HP_ACTIVE_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_ACTIVE_HP_SYS_CNTL Register bits
    namespace hp_active_hp_sys_cntl_bits {
        constexpr uint32_t HP_ACTIVE_HP_POWER_DET_BYPASS = (1U << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_ACTIVE_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_ACTIVE_HP_CK_POWER Register bits
    namespace hp_active_hp_ck_power_bits {
        constexpr uint32_t HP_ACTIVE_I2C_ISO_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_ACTIVE_I2C_RETENTION = (1U << 22);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_PLL_I2C = (4 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_PLL = (4 << 27);  ///< need_des
    }

    /// HP_ACTIVE_BIAS Register bits
    namespace hp_active_bias_bits {
        constexpr uint32_t HP_ACTIVE_DCM_VSET = (5 << 18);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DCM_MODE = (2 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DBG_ATTEN = (4 << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_ACTIVE_BACKUP Register bits
    namespace hp_active_backup_bits {
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE = (2 << 4);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE = (2 << 6);  ///< need_des
        constexpr uint32_t HP_ACTIVE_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_RETENTION_EN = (1U << 11);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_RETENTION_EN = (1U << 12);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_CLK_SEL = (2 << 14);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_CLK_SEL = (2 << 16);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_MODE = (3 << 20);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_MODE = (3 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP2ACTIVE_BACKUP_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM2ACTIVE_BACKUP_EN = (1U << 30);  ///< need_des
    }

    /// HP_ACTIVE_BACKUP_CLK Register bits
    namespace hp_active_backup_clk_bits {
        constexpr uint32_t HP_ACTIVE_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_ACTIVE_SYSCLK Register bits
    namespace hp_active_sysclk_bits {
        constexpr uint32_t HP_ACTIVE_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_ACTIVE_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_ACTIVE_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_ACTIVE_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_ACTIVE_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_ACTIVE_HP_REGULATOR0 Register bits
    namespace hp_active_hp_regulator0_bits {
        constexpr uint32_t LP_DBIAS_VOL = (5 << 4);  ///< need_des
        constexpr uint32_t HP_DBIAS_VOL = (5 << 9);  ///< need_des
        constexpr uint32_t DIG_REGULATOR0_DBIAS_SEL = (1U << 14);  ///< need_des
        constexpr uint32_t DIG_DBIAS_INIT = (1U << 15);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_ACTIVE_HP_REGULATOR1 Register bits
    namespace hp_active_hp_regulator1_bits {
        constexpr uint32_t HP_ACTIVE_HP_REGULATOR_DRV_B = (6 << 26);  ///< need_des
    }

    /// HP_ACTIVE_XTAL Register bits
    namespace hp_active_xtal_bits {
        constexpr uint32_t HP_ACTIVE_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_DIG_POWER Register bits
    namespace hp_modem_dig_power_bits {
        constexpr uint32_t HP_MODEM_DCDC_SWITCH_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_MEM_PD_EN = (4 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_WIFI_PD_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_HP_CPU_PD_EN = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_CNNT_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_ICG_HP_FUNC Register bits
    namespace hp_modem_icg_hp_func_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_ICG_HP_APB Register bits
    namespace hp_modem_icg_hp_apb_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_ICG_MODEM Register bits
    namespace hp_modem_icg_modem_bits {
        constexpr uint32_t HP_MODEM_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_MODEM_HP_SYS_CNTL Register bits
    namespace hp_modem_hp_sys_cntl_bits {
        constexpr uint32_t HP_MODEM_HP_POWER_DET_BYPASS = (1U << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_MODEM_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_MODEM_HP_CK_POWER Register bits
    namespace hp_modem_hp_ck_power_bits {
        constexpr uint32_t HP_MODEM_I2C_ISO_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_MODEM_I2C_RETENTION = (1U << 22);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_PLL_I2C = (4 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_PLL = (4 << 27);  ///< need_des
    }

    /// HP_MODEM_BIAS Register bits
    namespace hp_modem_bias_bits {
        constexpr uint32_t HP_MODEM_DCM_VSET = (5 << 18);  ///< need_des
        constexpr uint32_t HP_MODEM_DCM_MODE = (2 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_MODEM_DBG_ATTEN = (4 << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_MODEM_BACKUP Register bits
    namespace hp_modem_backup_bits {
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE = (2 << 4);  ///< need_des
        constexpr uint32_t HP_MODEM_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_RETENTION_EN = (1U << 11);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_CLK_SEL = (2 << 14);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_MODE = (3 << 20);  ///< need_des
        constexpr uint32_t HP_SLEEP2MODEM_BACKUP_EN = (1U << 29);  ///< need_des
    }

    /// HP_MODEM_BACKUP_CLK Register bits
    namespace hp_modem_backup_clk_bits {
        constexpr uint32_t HP_MODEM_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_MODEM_SYSCLK Register bits
    namespace hp_modem_sysclk_bits {
        constexpr uint32_t HP_MODEM_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_MODEM_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_MODEM_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_MODEM_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_MODEM_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_MODEM_HP_REGULATOR0 Register bits
    namespace hp_modem_hp_regulator0_bits {
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_MODEM_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_MODEM_HP_REGULATOR1 Register bits
    namespace hp_modem_hp_regulator1_bits {
        constexpr uint32_t HP_MODEM_HP_REGULATOR_DRV_B = (24 << 8);  ///< need_des
    }

    /// HP_MODEM_XTAL Register bits
    namespace hp_modem_xtal_bits {
        constexpr uint32_t HP_MODEM_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_DIG_POWER Register bits
    namespace hp_sleep_dig_power_bits {
        constexpr uint32_t HP_SLEEP_DCDC_SWITCH_PD_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_MEM_DSLP = (1U << 22);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_HP_MEM_PD_EN = (1U << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_CNNT_PD_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_TOP_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_ICG_HP_FUNC Register bits
    namespace hp_sleep_icg_hp_func_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_ICG_HP_APB Register bits
    namespace hp_sleep_icg_hp_apb_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_APB_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_ICG_MODEM Register bits
    namespace hp_sleep_icg_modem_bits {
        constexpr uint32_t HP_SLEEP_DIG_ICG_MODEM_CODE = (2 << 30);  ///< need_des
    }

    /// HP_SLEEP_HP_SYS_CNTL Register bits
    namespace hp_sleep_hp_sys_cntl_bits {
        constexpr uint32_t HP_SLEEP_HP_POWER_DET_BYPASS = (1U << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_UART_WAKEUP_EN = (1U << 24);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_PAD_HOLD_ALL = (1U << 25);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_PAD_HOLD_ALL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_PAUSE_WDT = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_CPU_STALL = (1U << 29);  ///< need_des
    }

    /// HP_SLEEP_HP_CK_POWER Register bits
    namespace hp_sleep_hp_ck_power_bits {
        constexpr uint32_t HP_SLEEP_I2C_ISO_EN = (1U << 21);  ///< need_des
        constexpr uint32_t HP_SLEEP_I2C_RETENTION = (1U << 22);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_PLL_I2C = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_PLL = (4 << 27);  ///< need_des
    }

    /// HP_SLEEP_BIAS Register bits
    namespace hp_sleep_bias_bits {
        constexpr uint32_t HP_SLEEP_DCM_VSET = (5 << 18);  ///< need_des
        constexpr uint32_t HP_SLEEP_DCM_MODE = (2 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t HP_SLEEP_DBG_ATTEN = (4 << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_BACKUP Register bits
    namespace hp_sleep_backup_bits {
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE = (2 << 6);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE = (2 << 8);  ///< need_des
        constexpr uint32_t HP_SLEEP_RETENTION_MODE = (1U << 10);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_RETENTION_EN = (1U << 12);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_RETENTION_EN = (1U << 13);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_CLK_SEL = (2 << 16);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_CLK_SEL = (2 << 18);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_MODE = (3 << 23);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_MODE = (3 << 26);  ///< need_des
        constexpr uint32_t HP_MODEM2SLEEP_BACKUP_EN = (1U << 30);  ///< need_des
        constexpr uint32_t HP_ACTIVE2SLEEP_BACKUP_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_BACKUP_CLK Register bits
    namespace hp_sleep_backup_clk_bits {
        constexpr uint32_t HP_SLEEP_BACKUP_ICG_FUNC_EN = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_SYSCLK Register bits
    namespace hp_sleep_sysclk_bits {
        constexpr uint32_t HP_SLEEP_DIG_SYS_CLK_NO_DIV = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_ICG_SYS_CLOCK_EN = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_SYS_CLK_SLP_SEL = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_DIG_SYS_CLK_SEL = (2 << 30);  ///< need_des
    }

    /// HP_SLEEP_HP_REGULATOR0 Register bits
    namespace hp_sleep_hp_regulator0_bits {
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD = (1U << 16);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD = (1U << 17);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_XPD = (1U << 18);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS = (4 << 19);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_SLEEP_HP_REGULATOR1 Register bits
    namespace hp_sleep_hp_regulator1_bits {
        constexpr uint32_t HP_SLEEP_HP_REGULATOR_DRV_B = (6 << 26);  ///< need_des
    }

    /// HP_SLEEP_XTAL Register bits
    namespace hp_sleep_xtal_bits {
        constexpr uint32_t HP_SLEEP_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_LP_REGULATOR0 Register bits
    namespace hp_sleep_lp_regulator0_bits {
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_SLP_XPD = (1U << 21);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_XPD = (1U << 22);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_SLP_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// HP_SLEEP_LP_REGULATOR1 Register bits
    namespace hp_sleep_lp_regulator1_bits {
        constexpr uint32_t HP_SLEEP_LP_REGULATOR_DRV_B = (6 << 26);  ///< need_des
    }

    /// HP_SLEEP_LP_DCDC_RESERVE Register bits
    namespace hp_sleep_lp_dcdc_reserve_bits {
        constexpr uint32_t PMU_HP_SLEEP_LP_DCDC_RESERVE = (32 << 0);  ///< need_des
    }

    /// HP_SLEEP_LP_DIG_POWER Register bits
    namespace hp_sleep_lp_dig_power_bits {
        constexpr uint32_t HP_SLEEP_LP_PAD_SLP_SEL = (1U << 26);  ///< need_des
        constexpr uint32_t HP_SLEEP_BOD_SOURCE_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_VDDBAT_MODE = (2 << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_LP_MEM_DSLP = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_LP_PERI_PD_EN = (1U << 31);  ///< need_des
    }

    /// HP_SLEEP_LP_CK_POWER Register bits
    namespace hp_sleep_lp_ck_power_bits {
        constexpr uint32_t HP_SLEEP_XPD_LPPLL = (1U << 27);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_XTAL32K = (1U << 28);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_RC32K = (1U << 29);  ///< need_des
        constexpr uint32_t HP_SLEEP_XPD_FOSC_CLK = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SLEEP_PD_OSC_CLK = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_BIAS_RESERVE Register bits
    namespace lp_sleep_lp_bias_reserve_bits {
        constexpr uint32_t PMU_LP_SLEEP_LP_BIAS_RESERVE = (32 << 0);  ///< need_des
    }

    /// LP_SLEEP_LP_REGULATOR0 Register bits
    namespace lp_sleep_lp_regulator0_bits {
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_SLP_XPD = (1U << 21);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_XPD = (1U << 22);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_SLP_DBIAS = (4 << 23);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_DBIAS = (5 << 27);  ///< need_des
    }

    /// LP_SLEEP_LP_REGULATOR1 Register bits
    namespace lp_sleep_lp_regulator1_bits {
        constexpr uint32_t LP_SLEEP_LP_REGULATOR_DRV_B = (6 << 26);  ///< need_des
    }

    /// LP_SLEEP_XTAL Register bits
    namespace lp_sleep_xtal_bits {
        constexpr uint32_t LP_SLEEP_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_DIG_POWER Register bits
    namespace lp_sleep_lp_dig_power_bits {
        constexpr uint32_t LP_SLEEP_LP_PAD_SLP_SEL = (1U << 26);  ///< need_des
        constexpr uint32_t LP_SLEEP_BOD_SOURCE_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t LP_SLEEP_VDDBAT_MODE = (2 << 28);  ///< need_des
        constexpr uint32_t LP_SLEEP_LP_MEM_DSLP = (1U << 30);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_LP_PERI_PD_EN = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_LP_CK_POWER Register bits
    namespace lp_sleep_lp_ck_power_bits {
        constexpr uint32_t LP_SLEEP_XPD_LPPLL = (1U << 27);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_XTAL32K = (1U << 28);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_RC32K = (1U << 29);  ///< need_des
        constexpr uint32_t LP_SLEEP_XPD_FOSC_CLK = (1U << 30);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_OSC_CLK = (1U << 31);  ///< need_des
    }

    /// LP_SLEEP_BIAS Register bits
    namespace lp_sleep_bias_bits {
        constexpr uint32_t LP_SLEEP_XPD_BIAS = (1U << 25);  ///< need_des
        constexpr uint32_t LP_SLEEP_DBG_ATTEN = (4 << 26);  ///< need_des
        constexpr uint32_t LP_SLEEP_PD_CUR = (1U << 30);  ///< need_des
        constexpr uint32_t SLEEP = (1U << 31);  ///< need_des
    }

    /// IMM_HP_CK_POWER Register bits
    namespace imm_hp_ck_power_bits {
        constexpr uint32_t TIE_LOW_CALI_XTAL_ICG = (1U << 0);  ///< need_des
        constexpr uint32_t TIE_LOW_GLOBAL_PLL_ICG = (4 << 1);  ///< need_des
        constexpr uint32_t TIE_LOW_GLOBAL_XTAL_ICG = (1U << 5);  ///< need_des
        constexpr uint32_t TIE_LOW_I2C_RETENTION = (1U << 6);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_PLL_I2C = (4 << 7);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_PLL = (4 << 11);  ///< need_des
        constexpr uint32_t TIE_LOW_XPD_XTAL = (1U << 15);  ///< need_des
        constexpr uint32_t TIE_HIGH_CALI_XTAL_ICG = (1U << 16);  ///< need_des
        constexpr uint32_t TIE_HIGH_GLOBAL_PLL_ICG = (4 << 17);  ///< need_des
        constexpr uint32_t TIE_HIGH_GLOBAL_XTAL_ICG = (1U << 21);  ///< need_des
        constexpr uint32_t TIE_HIGH_I2C_RETENTION = (1U << 22);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_PLL_I2C = (4 << 23);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_PLL = (4 << 27);  ///< need_des
        constexpr uint32_t TIE_HIGH_XPD_XTAL = (1U << 31);  ///< need_des
    }

    /// IMM_SLEEP_SYSCLK Register bits
    namespace imm_sleep_sysclk_bits {
        constexpr uint32_t UPDATE_DIG_ICG_SWITCH = (1U << 28);  ///< need_des
        constexpr uint32_t TIE_LOW_ICG_SLP_SEL = (1U << 29);  ///< need_des
        constexpr uint32_t TIE_HIGH_ICG_SLP_SEL = (1U << 30);  ///< need_des
        constexpr uint32_t UPDATE_DIG_SYS_CLK_SEL = (1U << 31);  ///< need_des
    }

    /// IMM_HP_FUNC_ICG Register bits
    namespace imm_hp_func_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_FUNC_EN = (1U << 31);  ///< need_des
    }

    /// IMM_HP_APB_ICG Register bits
    namespace imm_hp_apb_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_APB_EN = (1U << 31);  ///< need_des
    }

    /// IMM_MODEM_ICG Register bits
    namespace imm_modem_icg_bits {
        constexpr uint32_t UPDATE_DIG_ICG_MODEM_EN = (1U << 31);  ///< need_des
    }

    /// IMM_LP_ICG Register bits
    namespace imm_lp_icg_bits {
        constexpr uint32_t TIE_LOW_LP_ROOTCLK_SEL = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_HIGH_LP_ROOTCLK_SEL = (1U << 31);  ///< need_des
    }

    /// IMM_PAD_HOLD_ALL Register bits
    namespace imm_pad_hold_all_bits {
        constexpr uint32_t PAD_SLP_SEL = (1U << 0);  ///< need_des
        constexpr uint32_t LP_PAD_HOLD_ALL = (1U << 1);  ///< need_des
        constexpr uint32_t HP_PAD_HOLD_ALL = (1U << 2);  ///< need_des
        constexpr uint32_t TIE_HIGH_PAD_SLP_SEL = (1U << 26);  ///< need_des
        constexpr uint32_t TIE_LOW_PAD_SLP_SEL = (1U << 27);  ///< need_des
        constexpr uint32_t TIE_HIGH_LP_PAD_HOLD_ALL = (1U << 28);  ///< need_des
        constexpr uint32_t TIE_LOW_LP_PAD_HOLD_ALL = (1U << 29);  ///< need_des
        constexpr uint32_t TIE_HIGH_HP_PAD_HOLD_ALL = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_LOW_HP_PAD_HOLD_ALL = (1U << 31);  ///< need_des
    }

    /// IMM_I2C_ISO Register bits
    namespace imm_i2c_iso_bits {
        constexpr uint32_t TIE_HIGH_I2C_ISO_EN = (1U << 30);  ///< need_des
        constexpr uint32_t TIE_LOW_I2C_ISO_EN = (1U << 31);  ///< need_des
    }

    /// POWER_WAIT_TIMER0 Register bits
    namespace power_wait_timer0_bits {
        constexpr uint32_t DG_HP_POWERDOWN_TIMER = (9 << 5);  ///< need_des
        constexpr uint32_t DG_HP_POWERUP_TIMER = (9 << 14);  ///< need_des
        constexpr uint32_t DG_HP_WAIT_TIMER = (9 << 23);  ///< need_des
    }

    /// POWER_WAIT_TIMER1 Register bits
    namespace power_wait_timer1_bits {
        constexpr uint32_t DG_LP_POWERDOWN_TIMER = (9 << 5);  ///< need_des
        constexpr uint32_t DG_LP_POWERUP_TIMER = (9 << 14);  ///< need_des
        constexpr uint32_t DG_LP_WAIT_TIMER = (9 << 23);  ///< need_des
    }

    /// POWER_PD_TOP_CNTL Register bits
    namespace power_pd_top_cntl_bits {
        constexpr uint32_t FORCE_TOP_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_TOP_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_TOP_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_TOP_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_TOP_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_TOP_PD = (1U << 5);  ///< need_des
    }

    /// POWER_PD_CNNT_CNTL Register bits
    namespace power_pd_cnnt_cntl_bits {
        constexpr uint32_t FORCE_CNNT_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_CNNT_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_CNNT_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_CNNT_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_CNNT_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_CNNT_PD = (1U << 5);  ///< need_des
    }

    /// POWER_PD_HPMEM_CNTL Register bits
    namespace power_pd_hpmem_cntl_bits {
        constexpr uint32_t FORCE_HP_MEM_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_HP_MEM_PD = (1U << 5);  ///< need_des
    }

    /// POWER_PD_TOP_MASK Register bits
    namespace power_pd_top_mask_bits {
        constexpr uint32_t XPD_TOP_MASK = (5 << 0);  ///< need_des
        constexpr uint32_t PD_TOP_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_CNNT_MASK Register bits
    namespace power_pd_cnnt_mask_bits {
        constexpr uint32_t XPD_CNNT_MASK = (5 << 0);  ///< need_des
        constexpr uint32_t PD_CNNT_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_PD_HPMEM_MASK Register bits
    namespace power_pd_hpmem_mask_bits {
        constexpr uint32_t XPD_HP_MEM_MASK = (6 << 0);  ///< need_des
        constexpr uint32_t PD_HP_MEM_MASK = (6 << 26);  ///< need_des
    }

    /// POWER_DCDC_SWITCH Register bits
    namespace power_dcdc_switch_bits {
        constexpr uint32_t FORCE_DCDC_SWITCH_PU = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_DCDC_SWITCH_PD = (1U << 1);  ///< need_des
    }

    /// POWER_PD_LPPERI_CNTL Register bits
    namespace power_pd_lpperi_cntl_bits {
        constexpr uint32_t FORCE_LP_PERI_RESET = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_ISO = (1U << 1);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_PU = (1U << 2);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_NO_RESET = (1U << 3);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_NO_ISO = (1U << 4);  ///< need_des
        constexpr uint32_t FORCE_LP_PERI_PD = (1U << 5);  ///< need_des
    }

    /// POWER_PD_LPPERI_MASK Register bits
    namespace power_pd_lpperi_mask_bits {
        constexpr uint32_t XPD_LP_PERI_MASK = (5 << 0);  ///< need_des
        constexpr uint32_t PD_LP_PERI_MASK = (5 << 27);  ///< need_des
    }

    /// POWER_HP_PAD Register bits
    namespace power_hp_pad_bits {
        constexpr uint32_t FORCE_HP_PAD_NO_ISO_ALL = (1U << 0);  ///< need_des
        constexpr uint32_t FORCE_HP_PAD_ISO_ALL = (1U << 1);  ///< need_des
    }

    /// POWER_CK_WAIT_CNTL Register bits
    namespace power_ck_wait_cntl_bits {
        constexpr uint32_t PMU_WAIT_XTL_STABLE = (16 << 0);  ///< need_des
        constexpr uint32_t PMU_WAIT_PLL_STABLE = (16 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL0 Register bits
    namespace slp_wakeup_cntl0_bits {
        constexpr uint32_t SLEEP_REQ = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL1 Register bits
    namespace slp_wakeup_cntl1_bits {
        constexpr uint32_t SLEEP_REJECT_ENA = (31 << 0);  ///< need_des
        constexpr uint32_t SLP_REJECT_EN = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL2 Register bits
    namespace slp_wakeup_cntl2_bits {
        constexpr uint32_t WAKEUP_ENA = (31 << 0);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL3 Register bits
    namespace slp_wakeup_cntl3_bits {
        constexpr uint32_t LP_MIN_SLP_VAL = (8 << 0);  ///< need_des
        constexpr uint32_t HP_MIN_SLP_VAL = (8 << 8);  ///< need_des
        constexpr uint32_t SLEEP_PRT_SEL = (2 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL4 Register bits
    namespace slp_wakeup_cntl4_bits {
        constexpr uint32_t SLP_REJECT_CAUSE_CLR = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL5 Register bits
    namespace slp_wakeup_cntl5_bits {
        constexpr uint32_t MODEM_WAIT_TARGET = (20 << 0);  ///< need_des
        constexpr uint32_t LP_ANA_WAIT_TARGET = (8 << 24);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL6 Register bits
    namespace slp_wakeup_cntl6_bits {
        constexpr uint32_t SOC_WAKEUP_WAIT = (20 << 0);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_WAIT_CFG = (2 << 30);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL7 Register bits
    namespace slp_wakeup_cntl7_bits {
        constexpr uint32_t ANA_WAIT_TARGET = (16 << 16);  ///< need_des
    }

    /// SLP_WAKEUP_CNTL8 Register bits
    namespace slp_wakeup_cntl8_bits {
        constexpr uint32_t LP_LITE_WAKEUP_ENA = (1U << 31);  ///< need_des
    }

    /// SLP_WAKEUP_STATUS0 Register bits
    namespace slp_wakeup_status0_bits {
        constexpr uint32_t WAKEUP_CAUSE = (31 << 0);  ///< need_des
    }

    /// SLP_WAKEUP_STATUS1 Register bits
    namespace slp_wakeup_status1_bits {
        constexpr uint32_t REJECT_CAUSE = (31 << 0);  ///< need_des
    }

    /// SLP_WAKEUP_STATUS2 Register bits
    namespace slp_wakeup_status2_bits {
        constexpr uint32_t LP_LITE_WAKEUP_CAUSE = (1U << 31);  ///< need_des
    }

    /// HP_CK_POWERON Register bits
    namespace hp_ck_poweron_bits {
        constexpr uint32_t I2C_POR_WAIT_TARGET = (8 << 0);  ///< need_des
    }

    /// HP_CK_CNTL Register bits
    namespace hp_ck_cntl_bits {
        constexpr uint32_t MODIFY_ICG_CNTL_WAIT = (8 << 0);  ///< need_des
        constexpr uint32_t SWITCH_ICG_CNTL_WAIT = (8 << 8);  ///< need_des
    }

    /// POR_STATUS Register bits
    namespace por_status_bits {
        constexpr uint32_t POR_DONE = (1U << 31);  ///< need_des
    }

    /// RF_PWC Register bits
    namespace rf_pwc_bits {
        constexpr uint32_t MSPI_PHY_XPD = (1U << 24);  ///< need_des
        constexpr uint32_t SDIO_PLL_XPD = (1U << 25);  ///< need_des
        constexpr uint32_t PERIF_I2C_RSTB = (1U << 26);  ///< need_des
        constexpr uint32_t XPD_PERIF_I2C = (1U << 27);  ///< need_des
        constexpr uint32_t XPD_TXRF_I2C = (1U << 28);  ///< need_des
        constexpr uint32_t XPD_RFRX_PBUS = (1U << 29);  ///< need_des
        constexpr uint32_t XPD_CKGEN_I2C = (1U << 30);  ///< need_des
    }

    /// BACKUP_CFG Register bits
    namespace backup_cfg_bits {
        constexpr uint32_t BACKUP_SYS_CLK_NO_DIV = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_HP_INT_RAW = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_HP_INT_RAW = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_HP_INT_RAW = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_HP_INT_RAW = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_HP_INT_RAW = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_HP_INT_RAW = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_HP_INT_RAW = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_HP_INT_RAW = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_HP_INT_RAW = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_HP_INT_RAW = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_HP_INT_RAW = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_HP_INT_RAW = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_EXC_INT_RAW = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_RAW = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_RAW = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// HP_INT_ST Register bits
    namespace hp_int_st_bits {
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_HP_INT_ST = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_HP_INT_ST = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_HP_INT_ST = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_HP_INT_ST = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_HP_INT_ST = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_HP_INT_ST = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_HP_INT_ST = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_HP_INT_ST = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_HP_INT_ST = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_HP_INT_ST = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_HP_INT_ST = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_HP_INT_ST = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_EXC_INT_ST = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_ST = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_ST = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ST = (1U << 31);  ///< need_des
    }

    /// HP_INT_ENA Register bits
    namespace hp_int_ena_bits {
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_HP_INT_ENA = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_HP_INT_ENA = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_HP_INT_ENA = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_HP_INT_ENA = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_HP_INT_ENA = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_HP_INT_ENA = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_HP_INT_ENA = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_HP_INT_ENA = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_HP_INT_ENA = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_HP_INT_ENA = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_HP_INT_ENA = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_HP_INT_ENA = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_EXC_INT_ENA = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_ENA = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_ENA = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// HP_INT_CLR Register bits
    namespace hp_int_clr_bits {
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_HP_INT_CLR = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_HP_INT_CLR = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_HP_INT_CLR = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_HP_INT_CLR = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_HP_INT_CLR = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_HP_INT_CLR = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_HP_INT_CLR = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_HP_INT_CLR = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_HP_INT_CLR = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_HP_INT_CLR = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_HP_INT_CLR = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_HP_INT_CLR = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_EXC_INT_CLR = (1U << 27);  ///< need_des
        constexpr uint32_t SDIO_IDLE_INT_CLR = (1U << 28);  ///< need_des
        constexpr uint32_t SW_INT_CLR = (1U << 29);  ///< need_des
        constexpr uint32_t SOC_SLEEP_REJECT_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_INT_RAW Register bits
    namespace lp_int_raw_bits {
        constexpr uint32_t LP_CPU_SLEEP_REJECT_INT_RAW = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_LP_INT_RAW = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_LP_INT_RAW = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_LP_INT_RAW = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_LP_INT_RAW = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_LP_INT_RAW = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_LP_INT_RAW = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_LP_INT_RAW = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_LP_INT_RAW = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_LP_INT_RAW = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_LP_INT_RAW = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_LP_INT_RAW = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_LP_INT_RAW = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_WAKEUP_INT_RAW = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_RAW = (1U << 27);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_RAW = (1U << 28);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_RAW = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_RAW = (1U << 31);  ///< need_des
    }

    /// LP_INT_ST Register bits
    namespace lp_int_st_bits {
        constexpr uint32_t LP_CPU_SLEEP_REJECT_INT_ST = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_LP_INT_ST = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_LP_INT_ST = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_LP_INT_ST = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_LP_INT_ST = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_LP_INT_ST = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_LP_INT_ST = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_LP_INT_ST = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_LP_INT_ST = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_LP_INT_ST = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_LP_INT_ST = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_LP_INT_ST = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_LP_INT_ST = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_WAKEUP_INT_ST = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_ST = (1U << 27);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_ST = (1U << 28);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_ST = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_ST = (1U << 31);  ///< need_des
    }

    /// LP_INT_ENA Register bits
    namespace lp_int_ena_bits {
        constexpr uint32_t LP_CPU_SLEEP_REJECT_INT_ENA = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_LP_INT_ENA = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_LP_INT_ENA = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_LP_INT_ENA = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_LP_INT_ENA = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_LP_INT_ENA = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_LP_INT_ENA = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_LP_INT_ENA = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_LP_INT_ENA = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_LP_INT_ENA = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_LP_INT_ENA = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_LP_INT_ENA = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_LP_INT_ENA = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_WAKEUP_INT_ENA = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_ENA = (1U << 27);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_ENA = (1U << 28);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_ENA = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_ENA = (1U << 31);  ///< need_des
    }

    /// LP_INT_CLR Register bits
    namespace lp_int_clr_bits {
        constexpr uint32_t LP_CPU_SLEEP_REJECT_LP_INT_CLR = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_0_LP_INT_CLR = (1U << 14);  ///< reg_0p1a_0_counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_0_LP_INT_CLR = (1U << 15);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P1A_CNT_TARGET0_REACH_1_LP_INT_CLR = (1U << 16);  ///< reg_0p1a_0 counter after xpd reach target0
        constexpr uint32_t _0P1A_CNT_TARGET1_REACH_1_LP_INT_CLR = (1U << 17);  ///< reg_0p1a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_0_LP_INT_CLR = (1U << 18);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_0_LP_INT_CLR = (1U << 19);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P2A_CNT_TARGET0_REACH_1_LP_INT_CLR = (1U << 20);  ///< reg_0p2a_0 counter after xpd reach target0
        constexpr uint32_t _0P2A_CNT_TARGET1_REACH_1_LP_INT_CLR = (1U << 21);  ///< reg_0p2a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_0_LP_INT_CLR = (1U << 22);  ///< reg_0p3a_0 counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_0_LP_INT_CLR = (1U << 23);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t _0P3A_CNT_TARGET0_REACH_1_LP_INT_CLR = (1U << 24);  ///< reg_0p3a_0_counter after xpd reach target0
        constexpr uint32_t _0P3A_CNT_TARGET1_REACH_1_LP_INT_CLR = (1U << 25);  ///< reg_0p3a_1_counter after xpd reach target1
        constexpr uint32_t LP_CPU_WAKEUP_INT_CLR = (1U << 26);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_END_INT_CLR = (1U << 27);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_END_INT_CLR = (1U << 28);  ///< need_des
        constexpr uint32_t SLEEP_SWITCH_ACTIVE_START_INT_CLR = (1U << 29);  ///< need_des
        constexpr uint32_t ACTIVE_SWITCH_SLEEP_START_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t HP_SW_TRIGGER_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_CPU_PWR0 Register bits
    namespace lp_cpu_pwr0_bits {
        constexpr uint32_t LP_CPU_WAITI_RDY = (1U << 0);  ///< need_des
        constexpr uint32_t LP_CPU_STALL_RDY = (1U << 1);  ///< need_des
        constexpr uint32_t LP_CPU_FORCE_STALL = (1U << 18);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_WAITI_FLAG_EN = (1U << 19);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_FLAG_EN = (1U << 20);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_WAIT = (8 << 21);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_STALL_EN = (1U << 29);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_RESET_EN = (1U << 30);  ///< need_des
        constexpr uint32_t LP_CPU_SLP_BYPASS_INTR_EN = (1U << 31);  ///< need_des
    }

    /// LP_CPU_PWR1 Register bits
    namespace lp_cpu_pwr1_bits {
        constexpr uint32_t LP_CPU_SLEEP_REQ = (1U << 31);  ///< need_des
    }

    /// LP_CPU_PWR2 Register bits
    namespace lp_cpu_pwr2_bits {
        constexpr uint32_t LP_CPU_WAKEUP_EN = (31 << 0);  ///< need_des
    }

    /// LP_CPU_PWR3 Register bits
    namespace lp_cpu_pwr3_bits {
        constexpr uint32_t LP_CPU_WAKEUP_CAUSE = (31 << 0);  ///< need_des
    }

    /// LP_CPU_PWR4 Register bits
    namespace lp_cpu_pwr4_bits {
        constexpr uint32_t LP_CPU_REJECT_EN = (31 << 0);  ///< need_des
    }

    /// LP_CPU_PWR5 Register bits
    namespace lp_cpu_pwr5_bits {
        constexpr uint32_t LP_CPU_REJECT_CAUSE = (31 << 0);  ///< need_des
    }

    /// HP_LP_CPU_COMM Register bits
    namespace hp_lp_cpu_comm_bits {
        constexpr uint32_t LP_TRIGGER_HP = (1U << 30);  ///< need_des
        constexpr uint32_t HP_TRIGGER_LP = (1U << 31);  ///< need_des
    }

    /// HP_REGULATOR_CFG Register bits
    namespace hp_regulator_cfg_bits {
        constexpr uint32_t DIG_REGULATOR_EN_CAL = (1U << 31);  ///< need_des
    }

    /// MAIN_STATE Register bits
    namespace main_state_bits {
        constexpr uint32_t ENABLE_CALI_PMU_CNTL = (1U << 0);  ///< need_des
        constexpr uint32_t PMU_MAIN_LAST_ST_STATE = (7 << 11);  ///< need_des
        constexpr uint32_t PMU_MAIN_TAR_ST_STATE = (7 << 18);  ///< need_des
        constexpr uint32_t PMU_MAIN_CUR_ST_STATE = (7 << 25);  ///< need_des
    }

    /// PWR_STATE Register bits
    namespace pwr_state_bits {
        constexpr uint32_t PMU_BACKUP_ST_STATE = (5 << 13);  ///< need_des
        constexpr uint32_t PMU_LP_PWR_ST_STATE = (5 << 18);  ///< need_des
        constexpr uint32_t PMU_HP_PWR_ST_STATE = (9 << 23);  ///< need_des
    }

    /// CLK_STATE0 Register bits
    namespace clk_state0_bits {
        constexpr uint32_t STABLE_XPD_PLL_STATE = (3 << 0);  ///< need_des
        constexpr uint32_t STABLE_XPD_XTAL_STATE = (1U << 3);  ///< need_des
        constexpr uint32_t PMU_ANA_XPD_PLL_I2C_STATE = (3 << 4);  ///< need_des
        constexpr uint32_t PMU_SYS_CLK_SLP_SEL_STATE = (1U << 10);  ///< need_des
        constexpr uint32_t PMU_SYS_CLK_SEL_STATE = (2 << 11);  ///< need_des
        constexpr uint32_t PMU_SYS_CLK_NO_DIV_STATE = (1U << 13);  ///< need_des
        constexpr uint32_t PMU_ICG_SYS_CLK_EN_STATE = (1U << 14);  ///< need_des
        constexpr uint32_t PMU_ICG_MODEM_SWITCH_STATE = (1U << 15);  ///< need_des
        constexpr uint32_t PMU_ICG_MODEM_CODE_STATE = (2 << 16);  ///< need_des
        constexpr uint32_t PMU_ICG_SLP_SEL_STATE = (1U << 18);  ///< need_des
        constexpr uint32_t PMU_ICG_GLOBAL_XTAL_STATE = (1U << 19);  ///< need_des
        constexpr uint32_t PMU_ICG_GLOBAL_PLL_STATE = (4 << 20);  ///< need_des
        constexpr uint32_t PMU_ANA_I2C_ISO_EN_STATE = (1U << 24);  ///< need_des
        constexpr uint32_t PMU_ANA_I2C_RETENTION_STATE = (1U << 25);  ///< need_des
        constexpr uint32_t PMU_ANA_XPD_PLL_STATE = (4 << 27);  ///< need_des
        constexpr uint32_t PMU_ANA_XPD_XTAL_STATE = (1U << 31);  ///< need_des
    }

    /// CLK_STATE1 Register bits
    namespace clk_state1_bits {
        constexpr uint32_t PMU_ICG_FUNC_EN_STATE = (32 << 0);  ///< need_des
    }

    /// CLK_STATE2 Register bits
    namespace clk_state2_bits {
        constexpr uint32_t PMU_ICG_APB_EN_STATE = (32 << 0);  ///< need_des
    }

    /// EXT_LDO_P0_0P1A Register bits
    namespace ext_ldo_p0_0p1a_bits {
        constexpr uint32_t _0P1A_FORCE_TIEH_SEL_0 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P1A_XPD_0 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_SEL_0 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_POS_EN_0 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_NEG_EN_0 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_0 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P1A_TARGET1_0 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P1A_TARGET0_0 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P1A_LDO_CNT_PRESCALER_SEL_0 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P0_0P1A_ANA Register bits
    namespace ext_ldo_p0_0p1a_ana_bits {
        constexpr uint32_t ANA_0P1A_MUL_0 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P1A_EN_VDET_0 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P1A_EN_CUR_LIM_0 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P1A_DREF_0 = (4 << 28);  ///< need_des
    }

    /// EXT_LDO_P0_0P2A Register bits
    namespace ext_ldo_p0_0p2a_bits {
        constexpr uint32_t _0P2A_FORCE_TIEH_SEL_0 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P2A_XPD_0 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_SEL_0 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_POS_EN_0 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_NEG_EN_0 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_0 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P2A_TARGET1_0 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P2A_TARGET0_0 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P2A_LDO_CNT_PRESCALER_SEL_0 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P0_0P2A_ANA Register bits
    namespace ext_ldo_p0_0p2a_ana_bits {
        constexpr uint32_t ANA_0P2A_MUL_0 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P2A_EN_VDET_0 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P2A_EN_CUR_LIM_0 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P2A_DREF_0 = (4 << 28);  ///< need_des
    }

    /// EXT_LDO_P0_0P3A Register bits
    namespace ext_ldo_p0_0p3a_bits {
        constexpr uint32_t _0P3A_FORCE_TIEH_SEL_0 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P3A_XPD_0 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_SEL_0 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_POS_EN_0 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_NEG_EN_0 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_0 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P3A_TARGET1_0 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P3A_TARGET0_0 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P3A_LDO_CNT_PRESCALER_SEL_0 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P0_0P3A_ANA Register bits
    namespace ext_ldo_p0_0p3a_ana_bits {
        constexpr uint32_t ANA_0P3A_MUL_0 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P3A_EN_VDET_0 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P3A_EN_CUR_LIM_0 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P3A_DREF_0 = (4 << 28);  ///< need_des
    }

    /// EXT_LDO_P1_0P1A Register bits
    namespace ext_ldo_p1_0p1a_bits {
        constexpr uint32_t _0P1A_FORCE_TIEH_SEL_1 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P1A_XPD_1 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_SEL_1 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_POS_EN_1 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_NEG_EN_1 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P1A_TIEH_1 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P1A_TARGET1_1 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P1A_TARGET0_1 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P1A_LDO_CNT_PRESCALER_SEL_1 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P1_0P1A_ANA Register bits
    namespace ext_ldo_p1_0p1a_ana_bits {
        constexpr uint32_t ANA_0P1A_MUL_1 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P1A_EN_VDET_1 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P1A_EN_CUR_LIM_1 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P1A_DREF_1 = (4 << 28);  ///< need_des
    }

    /// EXT_LDO_P1_0P2A Register bits
    namespace ext_ldo_p1_0p2a_bits {
        constexpr uint32_t _0P2A_FORCE_TIEH_SEL_1 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P2A_XPD_1 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_SEL_1 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_POS_EN_1 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_NEG_EN_1 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P2A_TIEH_1 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P2A_TARGET1_1 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P2A_TARGET0_1 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P2A_LDO_CNT_PRESCALER_SEL_1 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P1_0P2A_ANA Register bits
    namespace ext_ldo_p1_0p2a_ana_bits {
        constexpr uint32_t ANA_0P2A_MUL_1 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P2A_EN_VDET_1 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P2A_EN_CUR_LIM_1 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P2A_DREF_1 = (4 << 28);  ///< need_des
    }

    /// EXT_LDO_P1_0P3A Register bits
    namespace ext_ldo_p1_0p3a_bits {
        constexpr uint32_t _0P3A_FORCE_TIEH_SEL_1 = (1U << 7);  ///< need_des
        constexpr uint32_t _0P3A_XPD_1 = (1U << 8);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_SEL_1 = (3 << 9);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_POS_EN_1 = (1U << 12);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_NEG_EN_1 = (1U << 13);  ///< need_des
        constexpr uint32_t _0P3A_TIEH_1 = (1U << 14);  ///< need_des
        constexpr uint32_t _0P3A_TARGET1_1 = (8 << 15);  ///< need_des
        constexpr uint32_t _0P3A_TARGET0_1 = (8 << 23);  ///< need_des
        constexpr uint32_t _0P3A_LDO_CNT_PRESCALER_SEL_1 = (1U << 31);  ///< need_des
    }

    /// EXT_LDO_P1_0P3A_ANA Register bits
    namespace ext_ldo_p1_0p3a_ana_bits {
        constexpr uint32_t ANA_0P3A_MUL_1 = (3 << 23);  ///< need_des
        constexpr uint32_t ANA_0P3A_EN_VDET_1 = (1U << 26);  ///< need_des
        constexpr uint32_t ANA_0P3A_EN_CUR_LIM_1 = (1U << 27);  ///< need_des
        constexpr uint32_t ANA_0P3A_DREF_1 = (4 << 28);  ///< need_des
    }

    /// EXT_WAKEUP_LV Register bits
    namespace ext_wakeup_lv_bits {
        constexpr uint32_t EXT_WAKEUP_LV = (32 << 0);  ///< need_des
    }

    /// EXT_WAKEUP_SEL Register bits
    namespace ext_wakeup_sel_bits {
        constexpr uint32_t EXT_WAKEUP_SEL = (32 << 0);  ///< need_des
    }

    /// EXT_WAKEUP_ST Register bits
    namespace ext_wakeup_st_bits {
        constexpr uint32_t EXT_WAKEUP_STATUS = (32 << 0);  ///< need_des
    }

    /// EXT_WAKEUP_CNTL Register bits
    namespace ext_wakeup_cntl_bits {
        constexpr uint32_t EXT_WAKEUP_STATUS_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t EXT_WAKEUP_FILTER = (1U << 31);  ///< need_des
    }

    /// SDIO_WAKEUP_CNTL Register bits
    namespace sdio_wakeup_cntl_bits {
        constexpr uint32_t SDIO_ACT_DNUM = (10 << 0);  ///< need_des
    }

    /// XTAL_SLP Register bits
    namespace xtal_slp_bits {
        constexpr uint32_t CNT_TARGET = (16 << 16);  ///< need_des
    }

    /// CPU_SW_STALL Register bits
    namespace cpu_sw_stall_bits {
        constexpr uint32_t HPCORE1_SW_STALL_CODE = (8 << 16);  ///< need_des
        constexpr uint32_t HPCORE0_SW_STALL_CODE = (8 << 24);  ///< need_des
    }

    /// DCM_CTRL Register bits
    namespace dcm_ctrl_bits {
        constexpr uint32_t DCDC_ON_REQ = (1U << 0);  ///< SW trigger dcdc on
        constexpr uint32_t DCDC_OFF_REQ = (1U << 1);  ///< SW trigger dcdc off
        constexpr uint32_t DCDC_LIGHTSLP_REQ = (1U << 2);  ///< SW trigger dcdc enter lightsleep
        constexpr uint32_t DCDC_DEEPSLP_REQ = (1U << 3);  ///< SW trigger dcdc enter deepsleep
        constexpr uint32_t DCDC_DONE_FORCE = (1U << 7);  ///< need_des
        constexpr uint32_t DCDC_ON_FORCE_PU = (1U << 8);  ///< need_des
        constexpr uint32_t DCDC_ON_FORCE_PD = (1U << 9);  ///< need_des
        constexpr uint32_t DCDC_FB_RES_FORCE_PU = (1U << 10);  ///< need_des
        constexpr uint32_t DCDC_FB_RES_FORCE_PD = (1U << 11);  ///< need_des
        constexpr uint32_t DCDC_LS_FORCE_PU = (1U << 12);  ///< need_des
        constexpr uint32_t DCDC_LS_FORCE_PD = (1U << 13);  ///< need_des
        constexpr uint32_t DCDC_DS_FORCE_PU = (1U << 14);  ///< need_des
        constexpr uint32_t DCDC_DS_FORCE_PD = (1U << 15);  ///< need_des
        constexpr uint32_t DCM_CUR_ST = (8 << 16);  ///< need_des
        constexpr uint32_t DCDC_EN_AMUX_TEST = (1U << 29);  ///< Enable analog mux to pull PAD TEST_DCDC voltage signal
    }

    /// DCM_WAIT_DELAY Register bits
    namespace dcm_wait_delay_bits {
        constexpr uint32_t DCDC_PRE_DELAY = (8 << 0);  ///< DCDC pre-on/post off delay
        constexpr uint32_t DCDC_RES_OFF_DELAY = (8 << 8);  ///< DCDC fb res off delay
        constexpr uint32_t DCDC_STABLE_DELAY = (10 << 16);  ///< DCDC stable delay
    }

    /// VDDBAT_CFG Register bits
    namespace vddbat_cfg_bits {
        constexpr uint32_t ANA_VDDBAT_MODE = (2 << 0);  ///< need_des
        constexpr uint32_t VDDBAT_SW_UPDATE = (1U << 31);  ///< need_des
    }

    /// TOUCH_PWR_CNTL Register bits
    namespace touch_pwr_cntl_bits {
        constexpr uint32_t TOUCH_WAIT_CYCLES = (9 << 5);  ///< need_des
        constexpr uint32_t TOUCH_SLEEP_CYCLES = (16 << 14);  ///< need_des
        constexpr uint32_t TOUCH_FORCE_DONE = (1U << 30);  ///< need_des
        constexpr uint32_t TOUCH_SLEEP_TIMER_EN = (1U << 31);  ///< need_des
    }

    /// RDN_ECO Register bits
    namespace rdn_eco_bits {
        constexpr uint32_t PMU_RDN_ECO_RESULT = (1U << 0);  ///< need_des
        constexpr uint32_t PMU_RDN_ECO_EN = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t PMU_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// PPA Peripheral
// ============================================================================

namespace ppa {
    /// Base addresses
    constexpr uint32_t PPA_BASE = 0x50087000;

    /// PPA Register structure
    struct Registers {
        volatile uint32_t BLEND0_CLUT_DATA;  ///< Offset: 0x00 - CLUT sram data read/write register in background plane of blender
        volatile uint32_t BLEND1_CLUT_DATA;  ///< Offset: 0x04 - CLUT sram data read/write register in foreground plane of blender
        volatile uint32_t CLUT_CONF;  ///< Offset: 0x0C - CLUT configure register
        volatile uint32_t INT_RAW;  ///< Offset: 0x10 - Raw status interrupt
        volatile uint32_t INT_ST;  ///< Offset: 0x14 - Masked interrupt
        volatile uint32_t INT_ENA;  ///< Offset: 0x18 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x1C - Interrupt clear bits
        volatile uint32_t SR_COLOR_MODE;  ///< Offset: 0x20 - Scaling and rotating engine color mode register
        volatile uint32_t BLEND_COLOR_MODE;  ///< Offset: 0x24 - blending engine color mode register
        volatile uint32_t SR_BYTE_ORDER;  ///< Offset: 0x28 - Scaling and rotating engine byte order register
        volatile uint32_t BLEND_BYTE_ORDER;  ///< Offset: 0x2C - Blending engine byte order register
        volatile uint32_t BLEND_TRANS_MODE;  ///< Offset: 0x34 - Blending engine mode configure register
        volatile uint32_t SR_FIX_ALPHA;  ///< Offset: 0x38 - Scaling and rotating engine alpha override register
        volatile uint32_t BLEND_TX_SIZE;  ///< Offset: 0x3C - Fix pixel filling mode image size register
        volatile uint32_t BLEND_FIX_ALPHA;  ///< Offset: 0x40 - Blending engine alpha override register
        volatile uint32_t BLEND_RGB;  ///< Offset: 0x48 - RGB color register
        volatile uint32_t BLEND_FIX_PIXEL;  ///< Offset: 0x4C - Blending engine fix pixel register
        volatile uint32_t CK_FG_LOW;  ///< Offset: 0x50 - foreground color key lower threshold
        volatile uint32_t CK_FG_HIGH;  ///< Offset: 0x54 - foreground color key higher threshold
        volatile uint32_t CK_BG_LOW;  ///< Offset: 0x58 - background color key lower threshold
        volatile uint32_t CK_BG_HIGH;  ///< Offset: 0x5C - background color key higher threshold
        volatile uint32_t CK_DEFAULT;  ///< Offset: 0x60 - default value when foreground and background both in...
        volatile uint32_t SR_SCAL_ROTATE;  ///< Offset: 0x64 - Scaling and rotating coefficient register
        volatile uint32_t SR_MEM_PD;  ///< Offset: 0x68 - SR memory power done register
        volatile uint32_t REG_CONF;  ///< Offset: 0x6C - Register clock enable register
        volatile uint32_t CLUT_CNT;  ///< Offset: 0x70 - BLEND CLUT write counter register
        volatile uint32_t BLEND_ST;  ///< Offset: 0x74 - Blending engine status register
        volatile uint32_t SR_PARAM_ERR_ST;  ///< Offset: 0x78 - Scaling and rotating coefficient error register
        volatile uint32_t SR_STATUS;  ///< Offset: 0x7C - SR FSM register
        volatile uint32_t ECO_LOW;  ///< Offset: 0x80 - Reserved.
        volatile uint32_t ECO_HIGH;  ///< Offset: 0x84 - Reserved.
        volatile uint32_t ECO_CELL_CTRL;  ///< Offset: 0x88 - Reserved.
        volatile uint32_t SRAM_CTRL;  ///< Offset: 0x8C - PPA SRAM Control Register
        volatile uint32_t DATE;  ///< Offset: 0x100 - PPA Version register
    };

    /// Peripheral instances
    inline Registers* PPA = reinterpret_cast<Registers*>(PPA_BASE);

    // Bit definitions
    /// BLEND0_CLUT_DATA Register bits
    namespace blend0_clut_data_bits {
        constexpr uint32_t RDWR_WORD_BLEND0_CLUT = (32 << 0);  ///< Write and read data to/from CLUT RAM in background plane of blender engine through this field in fifo mode.
    }

    /// BLEND1_CLUT_DATA Register bits
    namespace blend1_clut_data_bits {
        constexpr uint32_t RDWR_WORD_BLEND1_CLUT = (32 << 0);  ///< Write and read data to/from CLUT RAM in foreground plane of blender engine through this field in fifo mode.
    }

    /// CLUT_CONF Register bits
    namespace clut_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< 1'b0: fifo mode to wr/rd clut0/clut1 RAM through register PPA_SR_CLUT_DATA_REG/PPA_BLEND0_CLUT_DATA_REG/PPA_BLEND1_CLUT_DATA_REG. 1'b1: memory mode to wr/rd sr/blend0/blend1 clut RAM. The bit 11 and 10 of the waddr should be 01 to access sr clut and should be 10 to access blend0 clut and should be 11 to access blend 1 clut in memory mode.
        constexpr uint32_t BLEND0_CLUT_MEM_RST = (1U << 1);  ///< Write 1 then write 0 to this bit to reset BLEND0 CLUT.
        constexpr uint32_t BLEND1_CLUT_MEM_RST = (1U << 2);  ///< Write 1 then write 0 to this bit to reset BLEND1 CLUT.
        constexpr uint32_t BLEND0_CLUT_MEM_RDADDR_RST = (1U << 3);  ///< Write 1 then write 0 to reset the read address of BLEND0 CLUT in fifo mode.
        constexpr uint32_t BLEND1_CLUT_MEM_RDADDR_RST = (1U << 4);  ///< Write 1 then write 0 to reset the read address of BLEND1 CLUT in fifo mode.
        constexpr uint32_t BLEND0_CLUT_MEM_FORCE_PD = (1U << 5);  ///< 1: force power down BLEND CLUT memory.
        constexpr uint32_t BLEND0_CLUT_MEM_FORCE_PU = (1U << 6);  ///< 1: force power up BLEND CLUT memory.
        constexpr uint32_t BLEND0_CLUT_MEM_CLK_ENA = (1U << 7);  ///< 1: Force clock on for BLEND CLUT memory.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t SR_EOF_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when scaling and rotating engine calculate one frame image.
        constexpr uint32_t BLEND_EOF_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when blending engine calculate one frame image.
        constexpr uint32_t SR_PARAM_CFG_ERR_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when the configured scaling and rotating coefficient is wrong. User can check the reasons through register PPA_SR_PARAM_ERR_ST_REG.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t SR_EOF_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the PPA_SR_EOF_INT interrupt.
        constexpr uint32_t BLEND_EOF_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the PPA_BLEND_EOF_INT interrupt.
        constexpr uint32_t SR_PARAM_CFG_ERR_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the PPA_SR_RX_YSCAL_ERR_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t SR_EOF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the PPA_SR_EOF_INT interrupt.
        constexpr uint32_t BLEND_EOF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the PPA_BLEND_EOF_INT interrupt.
        constexpr uint32_t SR_PARAM_CFG_ERR_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the PPA_SR_RX_YSCAL_ERR_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t SR_EOF_INT_CLR = (1U << 0);  ///< Set this bit to clear the PPA_SR_EOF_INT interrupt.
        constexpr uint32_t BLEND_EOF_INT_CLR = (1U << 1);  ///< Set this bit to clear the PPA_BLEND_EOF_INT interrupt.
        constexpr uint32_t SR_PARAM_CFG_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear the PPA_SR_RX_YSCAL_ERR_INT interrupt.
    }

    /// SR_COLOR_MODE Register bits
    namespace sr_color_mode_bits {
        constexpr uint32_t SR_RX_CM = (4 << 0);  ///< The source image color mode for Scaling and Rotating engine Rx. 0: ARGB8888. 1: RGB888. 2: RGB565. 8: YUV420. others: Reserved.
        constexpr uint32_t SR_TX_CM = (4 << 4);  ///< The destination image color mode for Scaling and Rotating engine Tx. 0: ARGB8888. 1: RGB888. 2: RGB565. 8: YUV420. others: Reserved.
        constexpr uint32_t YUV_RX_RANGE = (1U << 8);  ///< YUV input range when reg_sr_rx_cm is 4'd8. 0: limit range. 1: full range
        constexpr uint32_t YUV_TX_RANGE = (1U << 9);  ///< YUV output range when reg_sr_tx_cm is 4'd8. 0: limit range. 1: full range
        constexpr uint32_t YUV2RGB_PROTOCAL = (1U << 10);  ///< YUV to RGB protocal when reg_sr_rx_cm is 4'd8. 0: BT601. 1: BT709
        constexpr uint32_t RGB2YUV_PROTOCAL = (1U << 11);  ///< RGB to YUV protocal when reg_sr_tx_cm is 4'd8. 0: BT601. 1: BT709
    }

    /// BLEND_COLOR_MODE Register bits
    namespace blend_color_mode_bits {
        constexpr uint32_t BLEND0_RX_CM = (4 << 0);  ///< The source image color mode for background plane. 0: ARGB8888. 1: RGB888. 2: RGB565. 3: Reserved. 4: L8. 5: L4.
        constexpr uint32_t BLEND1_RX_CM = (4 << 4);  ///< The source image color mode for foreground plane. 0: ARGB8888. 1: RGB888. 2: RGB565. 3: Reserved. 4: L8. 5: L4. 6: A8. 7: A4.
        constexpr uint32_t BLEND_TX_CM = (4 << 8);  ///< The destination image color mode for output of blender. 0: ARGB8888. 1: RGB888. 2: RGB565. 3: Reserved..
    }

    /// SR_BYTE_ORDER Register bits
    namespace sr_byte_order_bits {
        constexpr uint32_t SR_RX_BYTE_SWAP_EN = (1U << 0);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in byte. The Byte0 and Byte1 would be swapped while byte 2 and byte 3 would be swappped.
        constexpr uint32_t SR_RX_RGB_SWAP_EN = (1U << 1);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in rgb. It means rgb would be swap to bgr.
        constexpr uint32_t SR_MACRO_BK_RO_BYPASS = (1U << 2);  ///< Set this bit to 1 to bypass the macro block order function. This function is used to improve efficient accessing external memory.
    }

    /// BLEND_BYTE_ORDER Register bits
    namespace blend_byte_order_bits {
        constexpr uint32_t BLEND0_RX_BYTE_SWAP_EN = (1U << 0);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in byte. The Byte0 and Byte1 would be swapped while byte 2 and byte 3 would be swappped.
        constexpr uint32_t BLEND1_RX_BYTE_SWAP_EN = (1U << 1);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in byte. The Byte0 and Byte1 would be swapped while byte 2 and byte 3 would be swappped.
        constexpr uint32_t BLEND0_RX_RGB_SWAP_EN = (1U << 2);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in rgb. It means rgb would be swap to bgr.
        constexpr uint32_t BLEND1_RX_RGB_SWAP_EN = (1U << 3);  ///< Set this bit to 1 the data into Rx channel 0 would be swapped in rgb. It means rgb would be swap to bgr.
    }

    /// BLEND_TRANS_MODE Register bits
    namespace blend_trans_mode_bits {
        constexpr uint32_t BLEND_EN = (1U << 0);  ///< Set this bit to enable alpha blending.
        constexpr uint32_t BLEND_BYPASS = (1U << 1);  ///< Set this bit to bypass blender. Then background date would be output.
        constexpr uint32_t BLEND_FIX_PIXEL_FILL_EN = (1U << 2);  ///< This bit is used to enable fix pixel filling. When this mode is enable only Tx channel is work and the output pixel is configured by PPA_OUT_FIX_PIXEL.
        constexpr uint32_t UPDATE = (1U << 3);  ///< Set this bit to update the transfer mode. Only the bit is set the transfer mode is valid.
        constexpr uint32_t BLEND_RST = (1U << 4);  ///< write 1 then write 0 to reset blending engine.
    }

    /// SR_FIX_ALPHA Register bits
    namespace sr_fix_alpha_bits {
        constexpr uint32_t SR_RX_FIX_ALPHA = (8 << 0);  ///< The value would replace the alpha value in received pixel for Scaling and Rotating engine when PPA_SR_RX_ALPHA_CONF_EN is enabled.
        constexpr uint32_t SR_RX_ALPHA_MOD = (2 << 8);  ///< Alpha mode. 0/3: not replace alpha. 1: replace alpha with PPA_SR_FIX_ALPHA. 2: Original alpha multiply with PPA_SR_FIX_ALPHA/256.
        constexpr uint32_t SR_RX_ALPHA_INV = (1U << 10);  ///< Set this bit to invert the original alpha value. When RX color mode is RGB565/RGB88. The original alpha value is 255.
    }

    /// BLEND_TX_SIZE Register bits
    namespace blend_tx_size_bits {
        constexpr uint32_t BLEND_HB = (14 << 0);  ///< The horizontal width of image block that would be filled in fix pixel filling mode. The unit is pixel
        constexpr uint32_t BLEND_VB = (14 << 14);  ///< The vertical width of image block that would be filled in fix pixel filling mode. The unit is pixel
    }

    /// BLEND_FIX_ALPHA Register bits
    namespace blend_fix_alpha_bits {
        constexpr uint32_t BLEND0_RX_FIX_ALPHA = (8 << 0);  ///< The value would replace the alpha value in received pixel for background plane of blender when PPA_BLEND0_RX_ALPHA_CONF_EN is enabled.
        constexpr uint32_t BLEND1_RX_FIX_ALPHA = (8 << 8);  ///< The value would replace the alpha value in received pixel for foreground plane of blender when PPA_BLEND1_RX_ALPHA_CONF_EN is enabled.
        constexpr uint32_t BLEND0_RX_ALPHA_MOD = (2 << 16);  ///< Alpha mode. 0/3: not replace alpha. 1: replace alpha with PPA_SR_FIX_ALPHA. 2: Original alpha multiply with PPA_SR_FIX_ALPHA/256.
        constexpr uint32_t BLEND1_RX_ALPHA_MOD = (2 << 18);  ///< Alpha mode. 0/3: not replace alpha. 1: replace alpha with PPA_SR_FIX_ALPHA. 2: Original alpha multiply with PPA_SR_FIX_ALPHA/256.
        constexpr uint32_t BLEND0_RX_ALPHA_INV = (1U << 20);  ///< Set this bit to invert the original alpha value. When RX color mode is RGB565/RGB88. The original alpha value is 255.
        constexpr uint32_t BLEND1_RX_ALPHA_INV = (1U << 21);  ///< Set this bit to invert the original alpha value. When RX color mode is RGB565/RGB88. The original alpha value is 255.
    }

    /// BLEND_RGB Register bits
    namespace blend_rgb_bits {
        constexpr uint32_t BLEND1_RX_B = (8 << 0);  ///< blue color for A4/A8 mode.
        constexpr uint32_t BLEND1_RX_G = (8 << 8);  ///< green color for A4/A8 mode.
        constexpr uint32_t BLEND1_RX_R = (8 << 16);  ///< red color for A4/A8 mode.
    }

    /// BLEND_FIX_PIXEL Register bits
    namespace blend_fix_pixel_bits {
        constexpr uint32_t BLEND_TX_FIX_PIXEL = (32 << 0);  ///< The configure fix pixel in fix pixel filling mode for blender engine.
    }

    /// CK_FG_LOW Register bits
    namespace ck_fg_low_bits {
        constexpr uint32_t COLORKEY_FG_B_LOW = (8 << 0);  ///< color key lower threshold of foreground b channel
        constexpr uint32_t COLORKEY_FG_G_LOW = (8 << 8);  ///< color key lower threshold of foreground g channel
        constexpr uint32_t COLORKEY_FG_R_LOW = (8 << 16);  ///< color key lower threshold of foreground r channel
    }

    /// CK_FG_HIGH Register bits
    namespace ck_fg_high_bits {
        constexpr uint32_t COLORKEY_FG_B_HIGH = (8 << 0);  ///< color key higher threshold of foreground b channel
        constexpr uint32_t COLORKEY_FG_G_HIGH = (8 << 8);  ///< color key higher threshold of foreground g channel
        constexpr uint32_t COLORKEY_FG_R_HIGH = (8 << 16);  ///< color key higher threshold of foreground r channel
    }

    /// CK_BG_LOW Register bits
    namespace ck_bg_low_bits {
        constexpr uint32_t COLORKEY_BG_B_LOW = (8 << 0);  ///< color key lower threshold of background b channel
        constexpr uint32_t COLORKEY_BG_G_LOW = (8 << 8);  ///< color key lower threshold of background g channel
        constexpr uint32_t COLORKEY_BG_R_LOW = (8 << 16);  ///< color key lower threshold of background r channel
    }

    /// CK_BG_HIGH Register bits
    namespace ck_bg_high_bits {
        constexpr uint32_t COLORKEY_BG_B_HIGH = (8 << 0);  ///< color key higher threshold of background b channel
        constexpr uint32_t COLORKEY_BG_G_HIGH = (8 << 8);  ///< color key higher threshold of background g channel
        constexpr uint32_t COLORKEY_BG_R_HIGH = (8 << 16);  ///< color key higher threshold of background r channel
    }

    /// CK_DEFAULT Register bits
    namespace ck_default_bits {
        constexpr uint32_t COLORKEY_DEFAULT_B = (8 << 0);  ///< default B channle value of color key
        constexpr uint32_t COLORKEY_DEFAULT_G = (8 << 8);  ///< default G channle value of color key
        constexpr uint32_t COLORKEY_DEFAULT_R = (8 << 16);  ///< default R channle value of color key
        constexpr uint32_t COLORKEY_FG_BG_REVERSE = (1U << 24);  ///< when pixel in bg ck range but not in fg ck range, 0: the result is bg, 1: the result is fg
    }

    /// SR_SCAL_ROTATE Register bits
    namespace sr_scal_rotate_bits {
        constexpr uint32_t SR_SCAL_X_INT = (8 << 0);  ///< The integrated part of scaling coefficient in X direction.
        constexpr uint32_t SR_SCAL_X_FRAG = (4 << 8);  ///< The fragment part of scaling coefficient in X direction.
        constexpr uint32_t SR_SCAL_Y_INT = (8 << 12);  ///< The integrated part of scaling coefficient in Y direction.
        constexpr uint32_t SR_SCAL_Y_FRAG = (4 << 20);  ///< The fragment part of scaling coefficient in Y direction.
        constexpr uint32_t SR_ROTATE_ANGLE = (2 << 24);  ///< The rotate angle. 0: 0 degree. 1: 90 degree. 2: 180 degree. 3: 270 degree.
        constexpr uint32_t SCAL_ROTATE_RST = (1U << 26);  ///< Write 1 then write 0 to this bit to reset scaling and rotating engine.
        constexpr uint32_t SCAL_ROTATE_START = (1U << 27);  ///< Write 1 to enable scaling and rotating engine after parameter is configured.
        constexpr uint32_t SR_MIRROR_X = (1U << 28);  ///< Image mirror in X direction. 0: disable, 1: enable
        constexpr uint32_t SR_MIRROR_Y = (1U << 29);  ///< Image mirror in Y direction. 0: disable, 1: enable
    }

    /// SR_MEM_PD Register bits
    namespace sr_mem_pd_bits {
        constexpr uint32_t SR_MEM_CLK_ENA = (1U << 0);  ///< Set this bit to force clock enable of scaling and rotating engine's data memory.
        constexpr uint32_t SR_MEM_FORCE_PD = (1U << 1);  ///< Set this bit to force power down scaling and rotating engine's data memory.
        constexpr uint32_t SR_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force power up scaling and rotating engine's data memory.
    }

    /// REG_CONF Register bits
    namespace reg_conf_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< PPA register clock gate enable signal.
    }

    /// CLUT_CNT Register bits
    namespace clut_cnt_bits {
        constexpr uint32_t BLEND0_CLUT_CNT = (9 << 0);  ///< The write data counter of BLEND0 CLUT in fifo mode.
        constexpr uint32_t BLEND1_CLUT_CNT = (9 << 9);  ///< The write data counter of BLEND1 CLUT in fifo mode.
    }

    /// BLEND_ST Register bits
    namespace blend_st_bits {
        constexpr uint32_t BLEND_SIZE_DIFF_ST = (1U << 0);  ///< 1: indicate the size of two image is different.
    }

    /// SR_PARAM_ERR_ST Register bits
    namespace sr_param_err_st_bits {
        constexpr uint32_t TX_DSCR_VB_ERR_ST = (1U << 0);  ///< The error is that the scaled VB plus the offset of Y coordinate in 2DDMA receive descriptor is larger than VA in 2DDMA receive descriptor.
        constexpr uint32_t TX_DSCR_HB_ERR_ST = (1U << 1);  ///< The error is that the scaled HB plus the offset of X coordinate in 2DDMA receive descriptor is larger than HA in 2DDMA receive descriptor.
        constexpr uint32_t Y_RX_SCAL_EQUAL_0_ERR_ST = (1U << 2);  ///< The error is that the PPA_SR_SCAL_Y_INT and PPA_SR_CAL_Y_FRAG both are 0.
        constexpr uint32_t RX_DSCR_VB_ERR_ST = (1U << 3);  ///< The error is that VB in 2DDMA receive descriptor plus the offset of Y coordinate in 2DDMA transmit descriptor is larger than VA in 2DDMA transmit descriptor
        constexpr uint32_t YDST_LEN_TOO_SAMLL_ERR_ST = (1U << 4);  ///< The error is that the scaled image width is 0. For example. when source width is 14. scaled value is 1/16. and no rotate operation. then scaled width would be 0 as the result would be floored.
        constexpr uint32_t YDST_LEN_TOO_LARGE_ERR_ST = (1U << 5);  ///< The error is that the scaled width is larger than (2^13 - 1).
        constexpr uint32_t X_RX_SCAL_EQUAL_0_ERR_ST = (1U << 6);  ///< The error is that the scaled image height is 0.
        constexpr uint32_t RX_DSCR_HB_ERR_ST = (1U << 7);  ///< The error is that the HB in 2DDMA transmit descriptor plus the offset of X coordinate in 2DDMA transmit descriptor is larger than HA in 2DDMA transmit descriptor.
        constexpr uint32_t XDST_LEN_TOO_SAMLL_ERR_ST = (1U << 8);  ///< The error is that the scaled image height is 0. For example. when source height is 14. scaled value is 1/16. and no rotate operation. then scaled height would be 0 as the result would be floored.
        constexpr uint32_t XDST_LEN_TOO_LARGE_ERR_ST = (1U << 9);  ///< The error is that the scaled image height is larger than (2^13 - 1).
        constexpr uint32_t X_YUV420_RX_SCALE_ERR_ST = (1U << 10);  ///< The error is that the ha/hb/x param in dma2d descriptor is an odd num when enable yuv420 rx
        constexpr uint32_t Y_YUV420_RX_SCALE_ERR_ST = (1U << 11);  ///< The error is that the va/vb/y param in dma2d descriptor is an odd num when enable yuv420 rx
        constexpr uint32_t X_YUV420_TX_SCALE_ERR_ST = (1U << 12);  ///< The error is that the ha/hb/x param in dma2d descriptor is an odd num when enable yuv420 tx
        constexpr uint32_t Y_YUV420_TX_SCALE_ERR_ST = (1U << 13);  ///< The error is that the va/vb/y param in dma2d descriptor is an odd num when enable yuv420 tx
    }

    /// SR_STATUS Register bits
    namespace sr_status_bits {
        constexpr uint32_t SR_RX_DSCR_SAMPLE_STATE = (2 << 0);  ///< Reserved.
        constexpr uint32_t SR_RX_SCAN_STATE = (2 << 2);  ///< Reserved.
        constexpr uint32_t SR_TX_DSCR_SAMPLE_STATE = (2 << 4);  ///< Reserved.
        constexpr uint32_t SR_TX_SCAN_STATE = (3 << 6);  ///< Reserved.
    }

    /// ECO_LOW Register bits
    namespace eco_low_bits {
        constexpr uint32_t RND_ECO_LOW = (32 << 0);  ///< Reserved.
    }

    /// ECO_HIGH Register bits
    namespace eco_high_bits {
        constexpr uint32_t RND_ECO_HIGH = (32 << 0);  ///< Reserved.
    }

    /// ECO_CELL_CTRL Register bits
    namespace eco_cell_ctrl_bits {
        constexpr uint32_t RDN_RESULT = (1U << 0);  ///< Reserved.
        constexpr uint32_t RDN_ENA = (1U << 1);  ///< Reserved.
    }

    /// SRAM_CTRL Register bits
    namespace sram_ctrl_bits {
        constexpr uint32_t MEM_AUX_CTRL = (14 << 0);  ///< Control signals
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

}

// ============================================================================
// PVT Peripheral
// ============================================================================

namespace pvt {
    /// Base addresses
    constexpr uint32_t PVT_BASE = 0x5009E000;

    /// PVT Register structure
    struct Registers {
        volatile uint32_t PMUP_BITMAP_HIGH0;  ///< Offset: 0x00 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_HIGH1;  ///< Offset: 0x04 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_HIGH2;  ///< Offset: 0x08 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_HIGH3;  ///< Offset: 0x0C - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_HIGH4;  ///< Offset: 0x10 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_LOW0;  ///< Offset: 0x14 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_LOW1;  ///< Offset: 0x18 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_LOW2;  ///< Offset: 0x1C - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_LOW3;  ///< Offset: 0x20 - select valid pvt channel
        volatile uint32_t PMUP_BITMAP_LOW4;  ///< Offset: 0x24 - select valid pvt channel
        volatile uint32_t PMUP_DRV_CFG;  ///< Offset: 0x28 - configure pump drv
        volatile uint32_t PMUP_CHANNEL_CFG;  ///< Offset: 0x2C - configure the code of valid pump channel code
        volatile uint32_t CLK_CFG;  ///< Offset: 0x30 - configure pvt clk
        volatile uint32_t DBIAS_CHANNEL_SEL0;  ///< Offset: 0x34 - needs desc
        volatile uint32_t DBIAS_CHANNEL_SEL1;  ///< Offset: 0x38 - needs desc
        volatile uint32_t DBIAS_CHANNEL0_SEL;  ///< Offset: 0x3C - needs desc
        volatile uint32_t DBIAS_CHANNEL1_SEL;  ///< Offset: 0x40 - needs desc
        volatile uint32_t DBIAS_CHANNEL2_SEL;  ///< Offset: 0x44 - needs desc
        volatile uint32_t DBIAS_CHANNEL3_SEL;  ///< Offset: 0x48 - needs desc
        volatile uint32_t DBIAS_CHANNEL4_SEL;  ///< Offset: 0x4C - needs desc
        volatile uint32_t DBIAS_CMD0;  ///< Offset: 0x50 - needs desc
        volatile uint32_t DBIAS_CMD1;  ///< Offset: 0x54 - needs desc
        volatile uint32_t DBIAS_CMD2;  ///< Offset: 0x58 - needs desc
        volatile uint32_t DBIAS_CMD3;  ///< Offset: 0x5C - needs desc
        volatile uint32_t DBIAS_CMD4;  ///< Offset: 0x60 - needs desc
        volatile uint32_t DBIAS_TIMER;  ///< Offset: 0x64 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT0_CONF1;  ///< Offset: 0x68 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT0_CONF1;  ///< Offset: 0x6C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT0_CONF1;  ///< Offset: 0x70 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT0_CONF1;  ///< Offset: 0x74 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT1_CONF1;  ///< Offset: 0x78 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT1_CONF1;  ///< Offset: 0x7C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT1_CONF1;  ///< Offset: 0x80 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT1_CONF1;  ///< Offset: 0x84 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT2_CONF1;  ///< Offset: 0x88 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT2_CONF1;  ///< Offset: 0x8C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT2_CONF1;  ///< Offset: 0x90 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT2_CONF1;  ///< Offset: 0x94 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT0_CONF1;  ///< Offset: 0x98 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT0_CONF1;  ///< Offset: 0x9C - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT0_CONF1;  ///< Offset: 0xA0 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT0_CONF1;  ///< Offset: 0xA4 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT1_CONF1;  ///< Offset: 0xA8 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT1_CONF1;  ///< Offset: 0xAC - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT1_CONF1;  ///< Offset: 0xB0 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT1_CONF1;  ///< Offset: 0xB4 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT2_CONF1;  ///< Offset: 0xB8 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT2_CONF1;  ///< Offset: 0xBC - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT2_CONF1;  ///< Offset: 0xC0 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT2_CONF1;  ///< Offset: 0xC4 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT0_CONF1;  ///< Offset: 0xC8 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT0_CONF1;  ///< Offset: 0xCC - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT0_CONF1;  ///< Offset: 0xD0 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT0_CONF1;  ///< Offset: 0xD4 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT1_CONF1;  ///< Offset: 0xD8 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT1_CONF1;  ///< Offset: 0xDC - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT1_CONF1;  ///< Offset: 0xE0 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT1_CONF1;  ///< Offset: 0xE4 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT2_CONF1;  ///< Offset: 0xE8 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT2_CONF1;  ///< Offset: 0xEC - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT2_CONF1;  ///< Offset: 0xF0 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT2_CONF1;  ///< Offset: 0xF4 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT0_CONF1;  ///< Offset: 0xF8 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT0_CONF1;  ///< Offset: 0xFC - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT0_CONF1;  ///< Offset: 0x100 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT0_CONF1;  ///< Offset: 0x104 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT1_CONF1;  ///< Offset: 0x108 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT1_CONF1;  ///< Offset: 0x10C - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT1_CONF1;  ///< Offset: 0x110 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT1_CONF1;  ///< Offset: 0x114 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT2_CONF1;  ///< Offset: 0x118 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT2_CONF1;  ///< Offset: 0x11C - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT2_CONF1;  ///< Offset: 0x120 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT2_CONF1;  ///< Offset: 0x124 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT0_CONF2;  ///< Offset: 0x128 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT0_CONF2;  ///< Offset: 0x12C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT0_CONF2;  ///< Offset: 0x130 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT0_CONF2;  ///< Offset: 0x134 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT1_CONF2;  ///< Offset: 0x138 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT1_CONF2;  ///< Offset: 0x13C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT1_CONF2;  ///< Offset: 0x140 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT1_CONF2;  ///< Offset: 0x144 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT0_VT2_CONF2;  ///< Offset: 0x148 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT1_VT2_CONF2;  ///< Offset: 0x14C - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT2_VT2_CONF2;  ///< Offset: 0x150 - needs desc
        volatile uint32_t COMB_PD_SITE0_UNIT3_VT2_CONF2;  ///< Offset: 0x154 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT0_CONF2;  ///< Offset: 0x158 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT0_CONF2;  ///< Offset: 0x15C - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT0_CONF2;  ///< Offset: 0x160 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT0_CONF2;  ///< Offset: 0x164 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT1_CONF2;  ///< Offset: 0x168 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT1_CONF2;  ///< Offset: 0x16C - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT1_CONF2;  ///< Offset: 0x170 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT1_CONF2;  ///< Offset: 0x174 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT0_VT2_CONF2;  ///< Offset: 0x178 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT1_VT2_CONF2;  ///< Offset: 0x17C - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT2_VT2_CONF2;  ///< Offset: 0x180 - needs desc
        volatile uint32_t COMB_PD_SITE1_UNIT3_VT2_CONF2;  ///< Offset: 0x184 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT0_CONF2;  ///< Offset: 0x188 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT0_CONF2;  ///< Offset: 0x18C - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT0_CONF2;  ///< Offset: 0x190 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT0_CONF2;  ///< Offset: 0x194 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT1_CONF2;  ///< Offset: 0x198 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT1_CONF2;  ///< Offset: 0x19C - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT1_CONF2;  ///< Offset: 0x1A0 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT1_CONF2;  ///< Offset: 0x1A4 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT0_VT2_CONF2;  ///< Offset: 0x1A8 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT1_VT2_CONF2;  ///< Offset: 0x1AC - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT2_VT2_CONF2;  ///< Offset: 0x1B0 - needs desc
        volatile uint32_t COMB_PD_SITE2_UNIT3_VT2_CONF2;  ///< Offset: 0x1B4 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT0_CONF2;  ///< Offset: 0x1B8 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT0_CONF2;  ///< Offset: 0x1BC - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT0_CONF2;  ///< Offset: 0x1C0 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT0_CONF2;  ///< Offset: 0x1C4 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT1_CONF2;  ///< Offset: 0x1C8 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT1_CONF2;  ///< Offset: 0x1CC - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT1_CONF2;  ///< Offset: 0x1D0 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT1_CONF2;  ///< Offset: 0x1D4 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT0_VT2_CONF2;  ///< Offset: 0x1D8 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT1_VT2_CONF2;  ///< Offset: 0x1DC - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT2_VT2_CONF2;  ///< Offset: 0x1E0 - needs desc
        volatile uint32_t COMB_PD_SITE3_UNIT3_VT2_CONF2;  ///< Offset: 0x1E4 - needs desc
        volatile uint32_t VALUE_UPDATE;  ///< Offset: 0x1E8 - needs field desc
        volatile uint32_t DATE;  ///< Offset: 0xFFC - version register
    };

    /// Peripheral instances
    inline Registers* PVT = reinterpret_cast<Registers*>(PVT_BASE);

    // Bit definitions
    /// PMUP_BITMAP_HIGH0 Register bits
    namespace pmup_bitmap_high0_bits {
        constexpr uint32_t PUMP_BITMAP_HIGH0 = (32 << 0);  ///< select valid high channel0
    }

    /// PMUP_BITMAP_HIGH1 Register bits
    namespace pmup_bitmap_high1_bits {
        constexpr uint32_t PUMP_BITMAP_HIGH1 = (32 << 0);  ///< select valid high channel1
    }

    /// PMUP_BITMAP_HIGH2 Register bits
    namespace pmup_bitmap_high2_bits {
        constexpr uint32_t PUMP_BITMAP_HIGH2 = (32 << 0);  ///< select valid high channel2
    }

    /// PMUP_BITMAP_HIGH3 Register bits
    namespace pmup_bitmap_high3_bits {
        constexpr uint32_t PUMP_BITMAP_HIGH3 = (32 << 0);  ///< select valid high channel3
    }

    /// PMUP_BITMAP_HIGH4 Register bits
    namespace pmup_bitmap_high4_bits {
        constexpr uint32_t PUMP_BITMAP_HIGH4 = (32 << 0);  ///< select valid high channel4
    }

    /// PMUP_BITMAP_LOW0 Register bits
    namespace pmup_bitmap_low0_bits {
        constexpr uint32_t PUMP_BITMAP_LOW0 = (32 << 0);  ///< select valid low channel0
    }

    /// PMUP_BITMAP_LOW1 Register bits
    namespace pmup_bitmap_low1_bits {
        constexpr uint32_t PUMP_BITMAP_LOW1 = (32 << 0);  ///< select valid low channel1
    }

    /// PMUP_BITMAP_LOW2 Register bits
    namespace pmup_bitmap_low2_bits {
        constexpr uint32_t PUMP_BITMAP_LOW2 = (32 << 0);  ///< select valid low channel2
    }

    /// PMUP_BITMAP_LOW3 Register bits
    namespace pmup_bitmap_low3_bits {
        constexpr uint32_t PUMP_BITMAP_LOW3 = (32 << 0);  ///< select valid low channel3
    }

    /// PMUP_BITMAP_LOW4 Register bits
    namespace pmup_bitmap_low4_bits {
        constexpr uint32_t PUMP_BITMAP_LOW4 = (32 << 0);  ///< select valid low channel4
    }

    /// PMUP_DRV_CFG Register bits
    namespace pmup_drv_cfg_bits {
        constexpr uint32_t PUMP_EN = (1U << 9);  ///< configure pvt charge xpd
        constexpr uint32_t CLK_EN = (1U << 10);  ///< force register clken
        constexpr uint32_t PUMP_DRV4 = (4 << 11);  ///< configure cmd4 drv
        constexpr uint32_t PUMP_DRV3 = (4 << 15);  ///< configure cmd3 drv
        constexpr uint32_t PUMP_DRV2 = (4 << 19);  ///< configure cmd2 drv
        constexpr uint32_t PUMP_DRV1 = (4 << 23);  ///< configure cmd1 drv
        constexpr uint32_t PUMP_DRV0 = (4 << 27);  ///< configure cmd0 drv
    }

    /// PMUP_CHANNEL_CFG Register bits
    namespace pmup_channel_cfg_bits {
        constexpr uint32_t PUMP_CHANNEL_CODE4 = (5 << 7);  ///< configure cmd4 code
        constexpr uint32_t PUMP_CHANNEL_CODE3 = (5 << 12);  ///< configure cmd3 code
        constexpr uint32_t PUMP_CHANNEL_CODE2 = (5 << 17);  ///< configure cmd2 code
        constexpr uint32_t PUMP_CHANNEL_CODE1 = (5 << 22);  ///< configure cmd1 code
        constexpr uint32_t PUMP_CHANNEL_CODE0 = (5 << 27);  ///< configure cmd0 code
    }

    /// CLK_CFG Register bits
    namespace clk_cfg_bits {
        constexpr uint32_t PUMP_CLK_DIV_NUM = (8 << 0);  ///< needs field desc
        constexpr uint32_t MONITOR_CLK_PVT_EN = (1U << 8);  ///< needs field desc
        constexpr uint32_t CLK_SEL = (1U << 31);  ///< select pvt clk
    }

    /// DBIAS_CHANNEL_SEL0 Register bits
    namespace dbias_channel_sel0_bits {
        constexpr uint32_t DBIAS_CHANNEL3_SEL = (7 << 4);  ///< needs field desc
        constexpr uint32_t DBIAS_CHANNEL2_SEL = (7 << 11);  ///< needs field desc
        constexpr uint32_t DBIAS_CHANNEL1_SEL = (7 << 18);  ///< needs field desc
        constexpr uint32_t DBIAS_CHANNEL0_SEL = (7 << 25);  ///< needs field desc
    }

    /// DBIAS_CHANNEL_SEL1 Register bits
    namespace dbias_channel_sel1_bits {
        constexpr uint32_t DBIAS_CHANNEL4_SEL = (7 << 25);  ///< needs field desc
    }

    /// DBIAS_CHANNEL0_SEL Register bits
    namespace dbias_channel0_sel_bits {
        constexpr uint32_t DBIAS_CHANNEL0_CFG = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CHANNEL1_SEL Register bits
    namespace dbias_channel1_sel_bits {
        constexpr uint32_t DBIAS_CHANNEL1_CFG = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CHANNEL2_SEL Register bits
    namespace dbias_channel2_sel_bits {
        constexpr uint32_t DBIAS_CHANNEL2_CFG = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CHANNEL3_SEL Register bits
    namespace dbias_channel3_sel_bits {
        constexpr uint32_t DBIAS_CHANNEL3_CFG = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CHANNEL4_SEL Register bits
    namespace dbias_channel4_sel_bits {
        constexpr uint32_t DBIAS_CHANNEL4_CFG = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CMD0 Register bits
    namespace dbias_cmd0_bits {
        constexpr uint32_t DBIAS_CMD0 = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CMD1 Register bits
    namespace dbias_cmd1_bits {
        constexpr uint32_t DBIAS_CMD1 = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CMD2 Register bits
    namespace dbias_cmd2_bits {
        constexpr uint32_t DBIAS_CMD2 = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CMD3 Register bits
    namespace dbias_cmd3_bits {
        constexpr uint32_t DBIAS_CMD3 = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_CMD4 Register bits
    namespace dbias_cmd4_bits {
        constexpr uint32_t DBIAS_CMD4 = (17 << 0);  ///< needs field desc
    }

    /// DBIAS_TIMER Register bits
    namespace dbias_timer_bits {
        constexpr uint32_t TIMER_TARGET = (16 << 15);  ///< needs field desc
        constexpr uint32_t TIMER_EN = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT0_CONF1 Register bits
    namespace comb_pd_site0_unit0_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE0_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE0_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE0_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE0_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE0_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT0_CONF1 Register bits
    namespace comb_pd_site0_unit1_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE0_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE0_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE0_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE0_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE0_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT0_CONF1 Register bits
    namespace comb_pd_site0_unit2_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE0_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE0_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE0_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE0_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE0_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT0_CONF1 Register bits
    namespace comb_pd_site0_unit3_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE0_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE0_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE0_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE0_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE0_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT1_CONF1 Register bits
    namespace comb_pd_site0_unit0_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE0_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE0_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE0_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE0_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE0_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT1_CONF1 Register bits
    namespace comb_pd_site0_unit1_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE0_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE0_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE0_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE0_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE0_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT1_CONF1 Register bits
    namespace comb_pd_site0_unit2_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE0_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE0_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE0_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE0_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE0_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT1_CONF1 Register bits
    namespace comb_pd_site0_unit3_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE0_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE0_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE0_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE0_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE0_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT2_CONF1 Register bits
    namespace comb_pd_site0_unit0_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE0_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE0_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE0_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE0_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE0_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT2_CONF1 Register bits
    namespace comb_pd_site0_unit1_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE0_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE0_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE0_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE0_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE0_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT2_CONF1 Register bits
    namespace comb_pd_site0_unit2_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE0_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE0_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE0_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE0_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE0_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT2_CONF1 Register bits
    namespace comb_pd_site0_unit3_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE0_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE0_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE0_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE0_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE0_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT0_CONF1 Register bits
    namespace comb_pd_site1_unit0_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE1_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE1_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE1_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE1_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE1_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT0_CONF1 Register bits
    namespace comb_pd_site1_unit1_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE1_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE1_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE1_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE1_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE1_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT0_CONF1 Register bits
    namespace comb_pd_site1_unit2_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE1_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE1_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE1_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE1_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE1_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT0_CONF1 Register bits
    namespace comb_pd_site1_unit3_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE1_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE1_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE1_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE1_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE1_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT1_CONF1 Register bits
    namespace comb_pd_site1_unit0_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE1_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE1_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE1_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE1_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE1_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT1_CONF1 Register bits
    namespace comb_pd_site1_unit1_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE1_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE1_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE1_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE1_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE1_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT1_CONF1 Register bits
    namespace comb_pd_site1_unit2_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE1_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE1_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE1_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE1_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE1_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT1_CONF1 Register bits
    namespace comb_pd_site1_unit3_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE1_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE1_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE1_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE1_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE1_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT2_CONF1 Register bits
    namespace comb_pd_site1_unit0_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE1_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE1_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE1_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE1_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE1_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT2_CONF1 Register bits
    namespace comb_pd_site1_unit1_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE1_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE1_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE1_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE1_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE1_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT2_CONF1 Register bits
    namespace comb_pd_site1_unit2_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE1_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE1_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE1_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE1_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE1_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT2_CONF1 Register bits
    namespace comb_pd_site1_unit3_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE1_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE1_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE1_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE1_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE1_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT0_CONF1 Register bits
    namespace comb_pd_site2_unit0_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE2_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE2_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE2_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE2_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE2_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT0_CONF1 Register bits
    namespace comb_pd_site2_unit1_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE2_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE2_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE2_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE2_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE2_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT0_CONF1 Register bits
    namespace comb_pd_site2_unit2_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE2_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE2_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE2_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE2_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE2_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT0_CONF1 Register bits
    namespace comb_pd_site2_unit3_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE2_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE2_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE2_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE2_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE2_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT1_CONF1 Register bits
    namespace comb_pd_site2_unit0_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE2_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE2_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE2_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE2_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE2_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT1_CONF1 Register bits
    namespace comb_pd_site2_unit1_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE2_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE2_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE2_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE2_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE2_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT1_CONF1 Register bits
    namespace comb_pd_site2_unit2_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE2_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE2_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE2_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE2_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE2_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT1_CONF1 Register bits
    namespace comb_pd_site2_unit3_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE2_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE2_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE2_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE2_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE2_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT2_CONF1 Register bits
    namespace comb_pd_site2_unit0_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE2_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE2_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE2_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE2_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE2_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT2_CONF1 Register bits
    namespace comb_pd_site2_unit1_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE2_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE2_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE2_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE2_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE2_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT2_CONF1 Register bits
    namespace comb_pd_site2_unit2_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE2_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE2_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE2_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE2_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE2_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT2_CONF1 Register bits
    namespace comb_pd_site2_unit3_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE2_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE2_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE2_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE2_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE2_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT0_CONF1 Register bits
    namespace comb_pd_site3_unit0_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE3_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE3_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE3_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE3_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE3_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT0_CONF1 Register bits
    namespace comb_pd_site3_unit1_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE3_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE3_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE3_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE3_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE3_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT0_CONF1 Register bits
    namespace comb_pd_site3_unit2_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE3_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE3_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE3_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE3_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE3_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT0_CONF1 Register bits
    namespace comb_pd_site3_unit3_vt0_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT0_PD_SITE3_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT0_PD_SITE3_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT0_PD_SITE3_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT0_PD_SITE3_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT0_PD_SITE3_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT1_CONF1 Register bits
    namespace comb_pd_site3_unit0_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE3_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE3_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE3_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE3_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE3_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT1_CONF1 Register bits
    namespace comb_pd_site3_unit1_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE3_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE3_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE3_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE3_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE3_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT1_CONF1 Register bits
    namespace comb_pd_site3_unit2_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE3_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE3_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE3_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE3_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE3_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT1_CONF1 Register bits
    namespace comb_pd_site3_unit3_vt1_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT1_PD_SITE3_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT1_PD_SITE3_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT1_PD_SITE3_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT1_PD_SITE3_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT1_PD_SITE3_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT2_CONF1 Register bits
    namespace comb_pd_site3_unit0_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE3_UNIT0 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE3_UNIT0 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE3_UNIT0 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE3_UNIT0 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE3_UNIT0 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT2_CONF1 Register bits
    namespace comb_pd_site3_unit1_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE3_UNIT1 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE3_UNIT1 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE3_UNIT1 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE3_UNIT1 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE3_UNIT1 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT2_CONF1 Register bits
    namespace comb_pd_site3_unit2_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE3_UNIT2 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE3_UNIT2 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE3_UNIT2 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE3_UNIT2 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE3_UNIT2 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT2_CONF1 Register bits
    namespace comb_pd_site3_unit3_vt2_conf1_bits {
        constexpr uint32_t MONITOR_EN_VT2_PD_SITE3_UNIT3 = (1U << 0);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_CLR_VT2_PD_SITE3_UNIT3 = (1U << 1);  ///< needs field desc
        constexpr uint32_t DELAY_LIMIT_VT2_PD_SITE3_UNIT3 = (8 << 2);  ///< needs field desc
        constexpr uint32_t DELAY_NUM_O_VT2_PD_SITE3_UNIT3 = (8 << 23);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_VT2_PD_SITE3_UNIT3 = (1U << 31);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT0_CONF2 Register bits
    namespace comb_pd_site0_unit0_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE0_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE0_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE0_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT0_CONF2 Register bits
    namespace comb_pd_site0_unit1_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE0_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE0_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE0_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT0_CONF2 Register bits
    namespace comb_pd_site0_unit2_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE0_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE0_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE0_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT0_CONF2 Register bits
    namespace comb_pd_site0_unit3_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE0_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE0_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE0_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT1_CONF2 Register bits
    namespace comb_pd_site0_unit0_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE0_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE0_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE0_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT1_CONF2 Register bits
    namespace comb_pd_site0_unit1_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE0_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE0_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE0_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT1_CONF2 Register bits
    namespace comb_pd_site0_unit2_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE0_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE0_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE0_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT1_CONF2 Register bits
    namespace comb_pd_site0_unit3_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE0_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE0_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE0_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT0_VT2_CONF2 Register bits
    namespace comb_pd_site0_unit0_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE0_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE0_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE0_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT1_VT2_CONF2 Register bits
    namespace comb_pd_site0_unit1_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE0_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE0_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE0_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT2_VT2_CONF2 Register bits
    namespace comb_pd_site0_unit2_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE0_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE0_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE0_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE0_UNIT3_VT2_CONF2 Register bits
    namespace comb_pd_site0_unit3_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE0_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE0_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE0_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT0_CONF2 Register bits
    namespace comb_pd_site1_unit0_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE1_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE1_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE1_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT0_CONF2 Register bits
    namespace comb_pd_site1_unit1_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE1_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE1_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE1_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT0_CONF2 Register bits
    namespace comb_pd_site1_unit2_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE1_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE1_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE1_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT0_CONF2 Register bits
    namespace comb_pd_site1_unit3_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE1_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE1_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE1_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT1_CONF2 Register bits
    namespace comb_pd_site1_unit0_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE1_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE1_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE1_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT1_CONF2 Register bits
    namespace comb_pd_site1_unit1_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE1_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE1_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE1_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT1_CONF2 Register bits
    namespace comb_pd_site1_unit2_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE1_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE1_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE1_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT1_CONF2 Register bits
    namespace comb_pd_site1_unit3_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE1_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE1_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE1_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT0_VT2_CONF2 Register bits
    namespace comb_pd_site1_unit0_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE1_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE1_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE1_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT1_VT2_CONF2 Register bits
    namespace comb_pd_site1_unit1_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE1_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE1_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE1_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT2_VT2_CONF2 Register bits
    namespace comb_pd_site1_unit2_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE1_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE1_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE1_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE1_UNIT3_VT2_CONF2 Register bits
    namespace comb_pd_site1_unit3_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE1_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE1_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE1_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT0_CONF2 Register bits
    namespace comb_pd_site2_unit0_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE2_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE2_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE2_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT0_CONF2 Register bits
    namespace comb_pd_site2_unit1_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE2_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE2_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE2_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT0_CONF2 Register bits
    namespace comb_pd_site2_unit2_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE2_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE2_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE2_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT0_CONF2 Register bits
    namespace comb_pd_site2_unit3_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE2_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE2_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE2_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT1_CONF2 Register bits
    namespace comb_pd_site2_unit0_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE2_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE2_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE2_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT1_CONF2 Register bits
    namespace comb_pd_site2_unit1_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE2_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE2_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE2_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT1_CONF2 Register bits
    namespace comb_pd_site2_unit2_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE2_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE2_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE2_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT1_CONF2 Register bits
    namespace comb_pd_site2_unit3_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE2_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE2_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE2_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT0_VT2_CONF2 Register bits
    namespace comb_pd_site2_unit0_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE2_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE2_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE2_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT1_VT2_CONF2 Register bits
    namespace comb_pd_site2_unit1_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE2_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE2_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE2_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT2_VT2_CONF2 Register bits
    namespace comb_pd_site2_unit2_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE2_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE2_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE2_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE2_UNIT3_VT2_CONF2 Register bits
    namespace comb_pd_site2_unit3_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE2_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE2_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE2_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT0_CONF2 Register bits
    namespace comb_pd_site3_unit0_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE3_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE3_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE3_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT0_CONF2 Register bits
    namespace comb_pd_site3_unit1_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE3_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE3_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE3_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT0_CONF2 Register bits
    namespace comb_pd_site3_unit2_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE3_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE3_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE3_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT0_CONF2 Register bits
    namespace comb_pd_site3_unit3_vt0_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT0_PD_SITE3_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT0_PD_SITE3_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT0_PD_SITE3_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT1_CONF2 Register bits
    namespace comb_pd_site3_unit0_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE3_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE3_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE3_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT1_CONF2 Register bits
    namespace comb_pd_site3_unit1_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE3_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE3_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE3_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT1_CONF2 Register bits
    namespace comb_pd_site3_unit2_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE3_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE3_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE3_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT1_CONF2 Register bits
    namespace comb_pd_site3_unit3_vt1_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT1_PD_SITE3_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT1_PD_SITE3_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT1_PD_SITE3_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT0_VT2_CONF2 Register bits
    namespace comb_pd_site3_unit0_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE3_UNIT0 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE3_UNIT0 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE3_UNIT0 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT1_VT2_CONF2 Register bits
    namespace comb_pd_site3_unit1_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE3_UNIT1 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE3_UNIT1 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE3_UNIT1 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT2_VT2_CONF2 Register bits
    namespace comb_pd_site3_unit2_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE3_UNIT2 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE3_UNIT2 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE3_UNIT2 = (16 << 16);  ///< needs field desc
    }

    /// COMB_PD_SITE3_UNIT3_VT2_CONF2 Register bits
    namespace comb_pd_site3_unit3_vt2_conf2_bits {
        constexpr uint32_t MONITOR_EDG_MOD_VT2_PD_SITE3_UNIT3 = (2 << 0);  ///< needs field desc
        constexpr uint32_t DELAY_OVF_VT2_PD_SITE3_UNIT3 = (1U << 15);  ///< needs field desc
        constexpr uint32_t TIMING_ERR_CNT_O_VT2_PD_SITE3_UNIT3 = (16 << 16);  ///< needs field desc
    }

    /// VALUE_UPDATE Register bits
    namespace value_update_bits {
        constexpr uint32_t VALUE_UPDATE = (1U << 0);  ///< needs field desc
        constexpr uint32_t BYPASS = (1U << 1);  ///< needs field desc
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< version register
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x500D4000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t TX_CH%sDATA;  ///< Offset: 0x00 - The read and write data register for CHANNEL%s by apb...
        volatile uint32_t RX_CH%sDATA;  ///< Offset: 0x10 - The read and write data register for CHANNEL$n by apb...
        volatile uint32_t TX_CH%sCONF0;  ///< Offset: 0x20 - Channel %s configure register 0
        volatile uint32_t RX_CH%sCONF0;  ///< Offset: 0x30 - Channel %s configure register 0
        volatile uint32_t RX_CH%sCONF1;  ///< Offset: 0x34 - Channel %s configure register 1
        volatile uint32_t TX_CH%sSTATUS;  ///< Offset: 0x50 - Channel %s status register
        volatile uint32_t RX_CH%sSTATUS;  ///< Offset: 0x60 - Channel %s status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x70 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x74 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x78 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x7C - Interrupt clear bits
        volatile uint32_t CH%sCARRIER_DUTY;  ///< Offset: 0x80 - Channel %s duty cycle configuration register
        volatile uint32_t CH%s_RX_CARRIER_RM;  ///< Offset: 0x90 - Channel %s carrier remove register
        volatile uint32_t CH%s_TX_LIM;  ///< Offset: 0xA0 - Channel %s Tx event configuration register
        volatile uint32_t CH%s_RX_LIM;  ///< Offset: 0xB0 - Channel %s Rx event configuration register
        volatile uint32_t SYS_CONF;  ///< Offset: 0xC0 - RMT apb configuration register
        volatile uint32_t TX_SIM;  ///< Offset: 0xC4 - RMT TX synchronous register
        volatile uint32_t REF_CNT_RST;  ///< Offset: 0xC8 - RMT clock divider reset register
        volatile uint32_t DATE;  ///< Offset: 0xCC - RMT version register
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// TX_CH%sDATA Register bits
    namespace tx_ch%sdata_bits {
        constexpr uint32_t CHDATA = (32 << 0);  ///< Read and write data for channel %s via APB FIFO.
    }

    /// RX_CH%sDATA Register bits
    namespace rx_ch%sdata_bits {
        constexpr uint32_t CHDATA = (32 << 0);  ///< Read and write data for channel 0 via APB FIFO.
    }

    /// TX_CH%sCONF0 Register bits
    namespace tx_ch%sconf0_bits {
        constexpr uint32_t TX_START_CH0 = (1U << 0);  ///< Set this bit to start sending data on CHANNEL%s.
        constexpr uint32_t MEM_RD_RST_CH0 = (1U << 1);  ///< Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
        constexpr uint32_t APB_MEM_RST_CH0 = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t TX_CONTI_MODE_CH0 = (1U << 3);  ///< Set this bit to restart transmission from the first data to the last data in CHANNEL%s.
        constexpr uint32_t MEM_TX_WRAP_EN_CH0 = (1U << 4);  ///< This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
        constexpr uint32_t IDLE_OUT_LV_CH0 = (1U << 5);  ///< This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
        constexpr uint32_t IDLE_OUT_EN_CH0 = (1U << 6);  ///< This is the output enable-control bit for CHANNEL%s in IDLE state.
        constexpr uint32_t TX_STOP_CH0 = (1U << 7);  ///< Set this bit to stop the transmitter of CHANNEL%s sending data out.
        constexpr uint32_t DIV_CNT_CH0 = (8 << 8);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t MEM_SIZE_CH0 = (4 << 16);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EFF_EN_CH0 = (1U << 20);  ///< 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
        constexpr uint32_t CARRIER_EN_CH0 = (1U << 21);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV_CH0 = (1U << 22);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
        constexpr uint32_t AFIFO_RST_CH0 = (1U << 23);  ///< Reserved
        constexpr uint32_t CONF_UPDATE_CH0 = (1U << 24);  ///< synchronization bit for CHANNEL%s
    }

    /// RX_CH%sCONF0 Register bits
    namespace rx_ch%sconf0_bits {
        constexpr uint32_t DIV_CNT_CH4 = (8 << 0);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t IDLE_THRES_CH4 = (15 << 8);  ///< When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
        constexpr uint32_t MEM_SIZE_CH4 = (4 << 24);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EN_CH4 = (1U << 28);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV_CH4 = (1U << 29);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
    }

    /// RX_CH%sCONF1 Register bits
    namespace rx_ch%sconf1_bits {
        constexpr uint32_t RX_EN_CH4 = (1U << 0);  ///< Set this bit to enable receiver to receive data on CHANNEL%s.
        constexpr uint32_t MEM_WR_RST_CH4 = (1U << 1);  ///< Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
        constexpr uint32_t APB_MEM_RST_CH4 = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t MEM_OWNER_CH4 = (1U << 3);  ///< This register marks the ownership of CHANNEL%s's ram block.1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
        constexpr uint32_t RX_FILTER_EN_CH4 = (1U << 4);  ///< This is the receive filter's enable bit for CHANNEL%s.
        constexpr uint32_t RX_FILTER_THRES_CH4 = (8 << 5);  ///< Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
        constexpr uint32_t MEM_RX_WRAP_EN_CH4 = (1U << 13);  ///< This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
        constexpr uint32_t AFIFO_RST_CH4 = (1U << 14);  ///< Reserved
        constexpr uint32_t CONF_UPDATE_CH4 = (1U << 15);  ///< synchronization bit for CHANNEL%s
    }

    /// TX_CH%sSTATUS Register bits
    namespace tx_ch%sstatus_bits {
        constexpr uint32_t MEM_RADDR_EX_CH0 = (10 << 0);  ///< This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
        constexpr uint32_t APB_MEM_WADDR_CH0 = (10 << 11);  ///< This register records the memory address offset when writes RAM over APB bus.
        constexpr uint32_t STATE_CH0 = (3 << 22);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_EMPTY_CH0 = (1U << 25);  ///< This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
        constexpr uint32_t APB_MEM_WR_ERR_CH0 = (1U << 26);  ///< This status bit will be set if the offset address out of memory size when writes via APB bus.
    }

    /// RX_CH%sSTATUS Register bits
    namespace rx_ch%sstatus_bits {
        constexpr uint32_t MEM_WADDR_EX_CH4 = (10 << 0);  ///< This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
        constexpr uint32_t APB_MEM_RADDR_CH4 = (10 << 11);  ///< This register records the memory address offset when reads RAM over APB bus.
        constexpr uint32_t STATE_CH4 = (3 << 22);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_OWNER_ERR_CH4 = (1U << 25);  ///< This status bit will be set when the ownership of memory block is wrong.
        constexpr uint32_t MEM_FULL_CH4 = (1U << 26);  ///< This status bit will be set if the receiver receives more data than the memory size.
        constexpr uint32_t APB_MEM_RD_ERR_CH4 = (1U << 27);  ///< This status bit will be set if the offset address out of memory size when reads via APB bus.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH0_TX_END_INT_RAW = (1U << 0);  ///< The interrupt raw bit for CHANNEL0. Triggered when transmission done.
        constexpr uint32_t CH1_TX_END_INT_RAW = (1U << 1);  ///< The interrupt raw bit for CHANNEL1. Triggered when transmission done.
        constexpr uint32_t CH2_TX_END_INT_RAW = (1U << 2);  ///< The interrupt raw bit for CHANNEL2. Triggered when transmission done.
        constexpr uint32_t CH3_TX_END_INT_RAW = (1U << 3);  ///< The interrupt raw bit for CHANNEL3. Triggered when transmission done.
        constexpr uint32_t TX_CH0_ERR_INT_RAW = (1U << 4);  ///< The interrupt raw bit for CHANNEL0. Triggered when error occurs.
        constexpr uint32_t TX_CH1_ERR_INT_RAW = (1U << 5);  ///< The interrupt raw bit for CHANNEL1. Triggered when error occurs.
        constexpr uint32_t TX_CH2_ERR_INT_RAW = (1U << 6);  ///< The interrupt raw bit for CHANNEL2. Triggered when error occurs.
        constexpr uint32_t TX_CH3_ERR_INT_RAW = (1U << 7);  ///< The interrupt raw bit for CHANNEL3. Triggered when error occurs.
        constexpr uint32_t CH0_TX_THR_EVENT_INT_RAW = (1U << 8);  ///< The interrupt raw bit for CHANNEL0. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH1_TX_THR_EVENT_INT_RAW = (1U << 9);  ///< The interrupt raw bit for CHANNEL1. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH2_TX_THR_EVENT_INT_RAW = (1U << 10);  ///< The interrupt raw bit for CHANNEL2. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH3_TX_THR_EVENT_INT_RAW = (1U << 11);  ///< The interrupt raw bit for CHANNEL3. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH0_TX_LOOP_INT_RAW = (1U << 12);  ///< The interrupt raw bit for CHANNEL0. Triggered when the loop count reaches the configured threshold value.
        constexpr uint32_t CH1_TX_LOOP_INT_RAW = (1U << 13);  ///< The interrupt raw bit for CHANNEL1. Triggered when the loop count reaches the configured threshold value.
        constexpr uint32_t CH2_TX_LOOP_INT_RAW = (1U << 14);  ///< The interrupt raw bit for CHANNEL2. Triggered when the loop count reaches the configured threshold value.
        constexpr uint32_t CH3_TX_LOOP_INT_RAW = (1U << 15);  ///< The interrupt raw bit for CHANNEL3. Triggered when the loop count reaches the configured threshold value.
        constexpr uint32_t CH4_RX_END_INT_RAW = (1U << 16);  ///< The interrupt raw bit for CHANNEL4. Triggered when reception done.
        constexpr uint32_t CH5_RX_END_INT_RAW = (1U << 17);  ///< The interrupt raw bit for CHANNEL5. Triggered when reception done.
        constexpr uint32_t CH6_RX_END_INT_RAW = (1U << 18);  ///< The interrupt raw bit for CHANNEL6. Triggered when reception done.
        constexpr uint32_t CH7_RX_END_INT_RAW = (1U << 19);  ///< The interrupt raw bit for CHANNEL7. Triggered when reception done.
        constexpr uint32_t RX_CH4_ERR_INT_RAW = (1U << 20);  ///< The interrupt raw bit for CHANNEL4. Triggered when error occurs.
        constexpr uint32_t RX_CH5_ERR_INT_RAW = (1U << 21);  ///< The interrupt raw bit for CHANNEL5. Triggered when error occurs.
        constexpr uint32_t RX_CH6_ERR_INT_RAW = (1U << 22);  ///< The interrupt raw bit for CHANNEL6. Triggered when error occurs.
        constexpr uint32_t RX_CH7_ERR_INT_RAW = (1U << 23);  ///< The interrupt raw bit for CHANNEL7. Triggered when error occurs.
        constexpr uint32_t CH4_RX_THR_EVENT_INT_RAW = (1U << 24);  ///< The interrupt raw bit for CHANNEL4. Triggered when receiver receive more data than configured value.
        constexpr uint32_t CH5_RX_THR_EVENT_INT_RAW = (1U << 25);  ///< The interrupt raw bit for CHANNEL5. Triggered when receiver receive more data than configured value.
        constexpr uint32_t CH6_RX_THR_EVENT_INT_RAW = (1U << 26);  ///< The interrupt raw bit for CHANNEL6. Triggered when receiver receive more data than configured value.
        constexpr uint32_t CH7_RX_THR_EVENT_INT_RAW = (1U << 27);  ///< The interrupt raw bit for CHANNEL7. Triggered when receiver receive more data than configured value.
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL_INT_RAW = (1U << 28);  ///< The interrupt raw bit for CHANNEL3. Triggered when dma accessing CHANNEL3 fails.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL_INT_RAW = (1U << 29);  ///< The interrupt raw bit for CHANNEL7. Triggered when dma accessing CHANNEL7 fails.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH0_TX_END_INT_ST = (1U << 0);  ///< The masked interrupt status bit for CH0_TX_END_INT.
        constexpr uint32_t CH1_TX_END_INT_ST = (1U << 1);  ///< The masked interrupt status bit for CH1_TX_END_INT.
        constexpr uint32_t CH2_TX_END_INT_ST = (1U << 2);  ///< The masked interrupt status bit for CH2_TX_END_INT.
        constexpr uint32_t CH3_TX_END_INT_ST = (1U << 3);  ///< The masked interrupt status bit for CH3_TX_END_INT.
        constexpr uint32_t TX_CH0_ERR_INT_ST = (1U << 4);  ///< The masked interrupt status bit for CH0_ERR_INT.
        constexpr uint32_t TX_CH1_ERR_INT_ST = (1U << 5);  ///< The masked interrupt status bit for CH1_ERR_INT.
        constexpr uint32_t TX_CH2_ERR_INT_ST = (1U << 6);  ///< The masked interrupt status bit for CH2_ERR_INT.
        constexpr uint32_t TX_CH3_ERR_INT_ST = (1U << 7);  ///< The masked interrupt status bit for CH3_ERR_INT.
        constexpr uint32_t CH0_TX_THR_EVENT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for CH0_TX_THR_EVENT_INT.
        constexpr uint32_t CH1_TX_THR_EVENT_INT_ST = (1U << 9);  ///< The masked interrupt status bit for CH1_TX_THR_EVENT_INT.
        constexpr uint32_t CH2_TX_THR_EVENT_INT_ST = (1U << 10);  ///< The masked interrupt status bit for CH2_TX_THR_EVENT_INT.
        constexpr uint32_t CH3_TX_THR_EVENT_INT_ST = (1U << 11);  ///< The masked interrupt status bit for CH3_TX_THR_EVENT_INT.
        constexpr uint32_t CH0_TX_LOOP_INT_ST = (1U << 12);  ///< The masked interrupt status bit for CH0_TX_LOOP_INT.
        constexpr uint32_t CH1_TX_LOOP_INT_ST = (1U << 13);  ///< The masked interrupt status bit for CH1_TX_LOOP_INT.
        constexpr uint32_t CH2_TX_LOOP_INT_ST = (1U << 14);  ///< The masked interrupt status bit for CH2_TX_LOOP_INT.
        constexpr uint32_t CH3_TX_LOOP_INT_ST = (1U << 15);  ///< The masked interrupt status bit for CH3_TX_LOOP_INT.
        constexpr uint32_t CH4_RX_END_INT_ST = (1U << 16);  ///< The masked interrupt status bit for CH4_RX_END_INT.
        constexpr uint32_t CH5_RX_END_INT_ST = (1U << 17);  ///< The masked interrupt status bit for CH5_RX_END_INT.
        constexpr uint32_t CH6_RX_END_INT_ST = (1U << 18);  ///< The masked interrupt status bit for CH6_RX_END_INT.
        constexpr uint32_t CH7_RX_END_INT_ST = (1U << 19);  ///< The masked interrupt status bit for CH7_RX_END_INT.
        constexpr uint32_t RX_CH4_ERR_INT_ST = (1U << 20);  ///< The masked interrupt status bit for CH4_ERR_INT.
        constexpr uint32_t RX_CH5_ERR_INT_ST = (1U << 21);  ///< The masked interrupt status bit for CH5_ERR_INT.
        constexpr uint32_t RX_CH6_ERR_INT_ST = (1U << 22);  ///< The masked interrupt status bit for CH6_ERR_INT.
        constexpr uint32_t RX_CH7_ERR_INT_ST = (1U << 23);  ///< The masked interrupt status bit for CH7_ERR_INT.
        constexpr uint32_t CH4_RX_THR_EVENT_INT_ST = (1U << 24);  ///< The masked interrupt status bit for CH4_RX_THR_EVENT_INT.
        constexpr uint32_t CH5_RX_THR_EVENT_INT_ST = (1U << 25);  ///< The masked interrupt status bit for CH5_RX_THR_EVENT_INT.
        constexpr uint32_t CH6_RX_THR_EVENT_INT_ST = (1U << 26);  ///< The masked interrupt status bit for CH6_RX_THR_EVENT_INT.
        constexpr uint32_t CH7_RX_THR_EVENT_INT_ST = (1U << 27);  ///< The masked interrupt status bit for CH7_RX_THR_EVENT_INT.
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL_INT_ST = (1U << 28);  ///< The masked interrupt status bit for CH3_DMA_ACCESS_FAIL_INT.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL_INT_ST = (1U << 29);  ///< The masked interrupt status bit for CH7_DMA_ACCESS_FAIL_INT.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH0_TX_END_INT_ENA = (1U << 0);  ///< The interrupt enable bit for CH0_TX_END_INT.
        constexpr uint32_t CH1_TX_END_INT_ENA = (1U << 1);  ///< The interrupt enable bit for CH1_TX_END_INT.
        constexpr uint32_t CH2_TX_END_INT_ENA = (1U << 2);  ///< The interrupt enable bit for CH2_TX_END_INT.
        constexpr uint32_t CH3_TX_END_INT_ENA = (1U << 3);  ///< The interrupt enable bit for CH3_TX_END_INT.
        constexpr uint32_t TX_CH0_ERR_INT_ENA = (1U << 4);  ///< The interrupt enable bit for CH0_ERR_INT.
        constexpr uint32_t TX_CH1_ERR_INT_ENA = (1U << 5);  ///< The interrupt enable bit for CH1_ERR_INT.
        constexpr uint32_t TX_CH2_ERR_INT_ENA = (1U << 6);  ///< The interrupt enable bit for CH2_ERR_INT.
        constexpr uint32_t TX_CH3_ERR_INT_ENA = (1U << 7);  ///< The interrupt enable bit for CH3_ERR_INT.
        constexpr uint32_t CH0_TX_THR_EVENT_INT_ENA = (1U << 8);  ///< The interrupt enable bit for CH0_TX_THR_EVENT_INT.
        constexpr uint32_t CH1_TX_THR_EVENT_INT_ENA = (1U << 9);  ///< The interrupt enable bit for CH1_TX_THR_EVENT_INT.
        constexpr uint32_t CH2_TX_THR_EVENT_INT_ENA = (1U << 10);  ///< The interrupt enable bit for CH2_TX_THR_EVENT_INT.
        constexpr uint32_t CH3_TX_THR_EVENT_INT_ENA = (1U << 11);  ///< The interrupt enable bit for CH3_TX_THR_EVENT_INT.
        constexpr uint32_t CH0_TX_LOOP_INT_ENA = (1U << 12);  ///< The interrupt enable bit for CH0_TX_LOOP_INT.
        constexpr uint32_t CH1_TX_LOOP_INT_ENA = (1U << 13);  ///< The interrupt enable bit for CH1_TX_LOOP_INT.
        constexpr uint32_t CH2_TX_LOOP_INT_ENA = (1U << 14);  ///< The interrupt enable bit for CH2_TX_LOOP_INT.
        constexpr uint32_t CH3_TX_LOOP_INT_ENA = (1U << 15);  ///< The interrupt enable bit for CH3_TX_LOOP_INT.
        constexpr uint32_t CH4_RX_END_INT_ENA = (1U << 16);  ///< The interrupt enable bit for CH4_RX_END_INT.
        constexpr uint32_t CH5_RX_END_INT_ENA = (1U << 17);  ///< The interrupt enable bit for CH5_RX_END_INT.
        constexpr uint32_t CH6_RX_END_INT_ENA = (1U << 18);  ///< The interrupt enable bit for CH6_RX_END_INT.
        constexpr uint32_t CH7_RX_END_INT_ENA = (1U << 19);  ///< The interrupt enable bit for CH7_RX_END_INT.
        constexpr uint32_t CH4_ERR_INT_ENA = (1U << 20);  ///< The interrupt enable bit for CH4_ERR_INT.
        constexpr uint32_t CH5_ERR_INT_ENA = (1U << 21);  ///< The interrupt enable bit for CH5_ERR_INT.
        constexpr uint32_t CH6_ERR_INT_ENA = (1U << 22);  ///< The interrupt enable bit for CH6_ERR_INT.
        constexpr uint32_t CH7_ERR_INT_ENA = (1U << 23);  ///< The interrupt enable bit for CH7_ERR_INT.
        constexpr uint32_t CH4_RX_THR_EVENT_INT_ENA = (1U << 24);  ///< The interrupt enable bit for CH4_RX_THR_EVENT_INT.
        constexpr uint32_t CH5_RX_THR_EVENT_INT_ENA = (1U << 25);  ///< The interrupt enable bit for CH5_RX_THR_EVENT_INT.
        constexpr uint32_t CH6_RX_THR_EVENT_INT_ENA = (1U << 26);  ///< The interrupt enable bit for CH6_RX_THR_EVENT_INT.
        constexpr uint32_t CH7_RX_THR_EVENT_INT_ENA = (1U << 27);  ///< The interrupt enable bit for CH7_RX_THR_EVENT_INT.
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL_INT_ENA = (1U << 28);  ///< The interrupt enable bit for CH3_DMA_ACCESS_FAIL_INT.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL_INT_ENA = (1U << 29);  ///< The interrupt enable bit for CH7_DMA_ACCESS_FAIL_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH0_TX_END_INT_CLR = (1U << 0);  ///< Set this bit to clear theCH0_TX_END_INT interrupt.
        constexpr uint32_t CH1_TX_END_INT_CLR = (1U << 1);  ///< Set this bit to clear theCH1_TX_END_INT interrupt.
        constexpr uint32_t CH2_TX_END_INT_CLR = (1U << 2);  ///< Set this bit to clear theCH2_TX_END_INT interrupt.
        constexpr uint32_t CH3_TX_END_INT_CLR = (1U << 3);  ///< Set this bit to clear theCH3_TX_END_INT interrupt.
        constexpr uint32_t TX_CH0_ERR_INT_CLR = (1U << 4);  ///< Set this bit to clear theCH0_ERR_INT interrupt.
        constexpr uint32_t TX_CH1_ERR_INT_CLR = (1U << 5);  ///< Set this bit to clear theCH1_ERR_INT interrupt.
        constexpr uint32_t TX_CH2_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear theCH2_ERR_INT interrupt.
        constexpr uint32_t TX_CH3_ERR_INT_CLR = (1U << 7);  ///< Set this bit to clear theCH3_ERR_INT interrupt.
        constexpr uint32_t CH0_TX_THR_EVENT_INT_CLR = (1U << 8);  ///< Set this bit to clear theCH0_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH1_TX_THR_EVENT_INT_CLR = (1U << 9);  ///< Set this bit to clear theCH1_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH2_TX_THR_EVENT_INT_CLR = (1U << 10);  ///< Set this bit to clear theCH2_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH3_TX_THR_EVENT_INT_CLR = (1U << 11);  ///< Set this bit to clear theCH3_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH0_TX_LOOP_INT_CLR = (1U << 12);  ///< Set this bit to clear theCH0_TX_LOOP_INT interrupt.
        constexpr uint32_t CH1_TX_LOOP_INT_CLR = (1U << 13);  ///< Set this bit to clear theCH1_TX_LOOP_INT interrupt.
        constexpr uint32_t CH2_TX_LOOP_INT_CLR = (1U << 14);  ///< Set this bit to clear theCH2_TX_LOOP_INT interrupt.
        constexpr uint32_t CH3_TX_LOOP_INT_CLR = (1U << 15);  ///< Set this bit to clear theCH3_TX_LOOP_INT interrupt.
        constexpr uint32_t CH4_RX_END_INT_CLR = (1U << 16);  ///< Set this bit to clear theCH4_RX_END_INT interrupt.
        constexpr uint32_t CH5_RX_END_INT_CLR = (1U << 17);  ///< Set this bit to clear theCH5_RX_END_INT interrupt.
        constexpr uint32_t CH6_RX_END_INT_CLR = (1U << 18);  ///< Set this bit to clear theCH6_RX_END_INT interrupt.
        constexpr uint32_t CH7_RX_END_INT_CLR = (1U << 19);  ///< Set this bit to clear theCH7_RX_END_INT interrupt.
        constexpr uint32_t RX_CH4_ERR_INT_CLR = (1U << 20);  ///< Set this bit to clear theCH4_ERR_INT interrupt.
        constexpr uint32_t RX_CH5_ERR_INT_CLR = (1U << 21);  ///< Set this bit to clear theCH5_ERR_INT interrupt.
        constexpr uint32_t RX_CH6_ERR_INT_CLR = (1U << 22);  ///< Set this bit to clear theCH6_ERR_INT interrupt.
        constexpr uint32_t RX_CH7_ERR_INT_CLR = (1U << 23);  ///< Set this bit to clear theCH7_ERR_INT interrupt.
        constexpr uint32_t CH4_RX_THR_EVENT_INT_CLR = (1U << 24);  ///< Set this bit to clear theCH4_RX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH5_RX_THR_EVENT_INT_CLR = (1U << 25);  ///< Set this bit to clear theCH5_RX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH6_RX_THR_EVENT_INT_CLR = (1U << 26);  ///< Set this bit to clear theCH6_RX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH7_RX_THR_EVENT_INT_CLR = (1U << 27);  ///< Set this bit to clear theCH7_RX_THR_EVENT_INT interrupt.
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL_INT_CLR = (1U << 28);  ///< Set this bit to clear the CH3_DMA_ACCESS_FAIL_INT interrupt.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL_INT_CLR = (1U << 29);  ///< Set this bit to clear the CH7_DMA_ACCESS_FAIL_INT interrupt.
    }

    /// CH%sCARRIER_DUTY Register bits
    namespace ch%scarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW_CH = (16 << 0);  ///< This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
        constexpr uint32_t CARRIER_HIGH_CH = (16 << 16);  ///< This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
    }

    /// CH%s_RX_CARRIER_RM Register bits
    namespace ch%s_rx_carrier_rm_bits {
        constexpr uint32_t CARRIER_LOW_THRES_CH = (16 << 0);  ///< The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
        constexpr uint32_t CARRIER_HIGH_THRES_CH = (16 << 16);  ///< The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
    }

    /// CH%s_TX_LIM Register bits
    namespace ch%s_tx_lim_bits {
        constexpr uint32_t TX_LIM_CH = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can send out.
        constexpr uint32_t TX_LOOP_NUM_CH = (10 << 9);  ///< This register is used to configure the maximum loop count when tx_conti_mode is valid.
        constexpr uint32_t TX_LOOP_CNT_EN_CH = (1U << 19);  ///< This register is the enabled bit for loop count.
        constexpr uint32_t LOOP_COUNT_RESET_CH = (1U << 20);  ///< This register is used to reset the loop count when tx_conti_mode is valid.
        constexpr uint32_t LOOP_STOP_EN_CH = (1U << 21);  ///< This bit is used to enable the loop send stop function after the loop counter counts to loop number for CHANNEL%s.
    }

    /// CH%s_RX_LIM Register bits
    namespace ch%s_rx_lim_bits {
        constexpr uint32_t RX_LIM_CH4 = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can receive.
    }

    /// SYS_CONF Register bits
    namespace sys_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< 1'h1: access memory directly. 1'h0: access memory by FIFO.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit to enable the clock for RMT memory.
        constexpr uint32_t MEM_FORCE_PD = (1U << 2);  ///< Set this bit to power down RMT memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 3);  ///< 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 4);  ///< the integral part of the fractional divisor
        constexpr uint32_t SCLK_DIV_A = (6 << 12);  ///< the numerator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_DIV_B = (6 << 18);  ///< the denominator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_SEL = (2 << 24);  ///< choose the clock source of rmt_sclk. 1:CLK_80Mhz.2:CLK_8MHz.3:XTAL
        constexpr uint32_t SCLK_ACTIVE = (1U << 26);  ///< rmt_sclk switch
        constexpr uint32_t CLK_EN = (1U << 31);  ///< RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
    }

    /// TX_SIM Register bits
    namespace tx_sim_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH1 = (1U << 1);  ///< Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH2 = (1U << 2);  ///< Set this bit to enable CHANNEL2 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH3 = (1U << 3);  ///< Set this bit to enable CHANNEL3 to start sending data synchronously with other enabled channels.
        constexpr uint32_t EN = (1U << 4);  ///< This register is used to enable multiple of channels to start sending data synchronously.
    }

    /// REF_CNT_RST Register bits
    namespace ref_cnt_rst_bits {
        constexpr uint32_t TX_REF_CNT_RST_CH0 = (1U << 0);  ///< This register is used to reset the clock divider of CHANNEL0.
        constexpr uint32_t TX_REF_CNT_RST_CH1 = (1U << 1);  ///< This register is used to reset the clock divider of CHANNEL1.
        constexpr uint32_t TX_REF_CNT_RST_CH2 = (1U << 2);  ///< This register is used to reset the clock divider of CHANNEL2.
        constexpr uint32_t TX_REF_CNT_RST_CH3 = (1U << 3);  ///< This register is used to reset the clock divider of CHANNEL3.
        constexpr uint32_t RX_REF_CNT_RST_CH4 = (1U << 4);  ///< This register is used to reset the clock divider of CHANNEL4.
        constexpr uint32_t RX_REF_CNT_RST_CH5 = (1U << 5);  ///< This register is used to reset the clock divider of CHANNEL5.
        constexpr uint32_t RX_REF_CNT_RST_CH6 = (1U << 6);  ///< This register is used to reset the clock divider of CHANNEL6.
        constexpr uint32_t RX_REF_CNT_RST_CH7 = (1U << 7);  ///< This register is used to reset the clock divider of CHANNEL7.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LP_TIMER_BASE = 0x50112000;
    constexpr uint32_t SYSTIMER_BASE = 0x500E2000;
    constexpr uint32_t TIMG0_BASE = 0x500C2000;
    constexpr uint32_t TIMG1_BASE = 0x500C3000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TAR0_LOW;  ///< Offset: 0x00 - need_des
        volatile uint32_t TAR0_HIGH;  ///< Offset: 0x04 - need_des
        volatile uint32_t TAR1_LOW;  ///< Offset: 0x08 - need_des
        volatile uint32_t TAR1_HIGH;  ///< Offset: 0x0C - need_des
        volatile uint32_t UPDATE;  ///< Offset: 0x10 - need_des
        volatile uint32_t MAIN_BUF0_LOW;  ///< Offset: 0x14 - need_des
        volatile uint32_t MAIN_BUF0_HIGH;  ///< Offset: 0x18 - need_des
        volatile uint32_t MAIN_BUF1_LOW;  ///< Offset: 0x1C - need_des
        volatile uint32_t MAIN_BUF1_HIGH;  ///< Offset: 0x20 - need_des
        volatile uint32_t MAIN_OVERFLOW;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ST;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_ENA;  ///< Offset: 0x30 - need_des
        volatile uint32_t INT_CLR;  ///< Offset: 0x34 - need_des
        volatile uint32_t LP_INT_RAW;  ///< Offset: 0x38 - need_des
        volatile uint32_t LP_INT_ST;  ///< Offset: 0x3C - need_des
        volatile uint32_t LP_INT_ENA;  ///< Offset: 0x40 - need_des
        volatile uint32_t LP_INT_CLR;  ///< Offset: 0x44 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_TIMER = reinterpret_cast<Registers*>(LP_TIMER_BASE);
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// TAR0_LOW Register bits
    namespace tar0_low_bits {
        constexpr uint32_t MAIN_TIMER_TAR_LOW0 = (32 << 0);  ///< need_des
    }

    /// TAR0_HIGH Register bits
    namespace tar0_high_bits {
        constexpr uint32_t MAIN_TIMER_TAR_HIGH0 = (16 << 0);  ///< need_des
        constexpr uint32_t MAIN_TIMER_TAR_EN0 = (1U << 31);  ///< need_des
    }

    /// TAR1_LOW Register bits
    namespace tar1_low_bits {
        constexpr uint32_t MAIN_TIMER_TAR_LOW1 = (32 << 0);  ///< need_des
    }

    /// TAR1_HIGH Register bits
    namespace tar1_high_bits {
        constexpr uint32_t MAIN_TIMER_TAR_HIGH1 = (16 << 0);  ///< need_des
        constexpr uint32_t MAIN_TIMER_TAR_EN1 = (1U << 31);  ///< need_des
    }

    /// UPDATE Register bits
    namespace update_bits {
        constexpr uint32_t MAIN_TIMER_UPDATE = (1U << 28);  ///< need_des
        constexpr uint32_t MAIN_TIMER_XTAL_OFF = (1U << 29);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_STALL = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_SYS_RST = (1U << 31);  ///< need_des
    }

    /// MAIN_BUF0_LOW Register bits
    namespace main_buf0_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF0_HIGH Register bits
    namespace main_buf0_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF0_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_BUF1_LOW Register bits
    namespace main_buf1_low_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_LOW = (32 << 0);  ///< need_des
    }

    /// MAIN_BUF1_HIGH Register bits
    namespace main_buf1_high_bits {
        constexpr uint32_t MAIN_TIMER_BUF1_HIGH = (16 << 0);  ///< need_des
    }

    /// MAIN_OVERFLOW Register bits
    namespace main_overflow_bits {
        constexpr uint32_t MAIN_TIMER_ALARM_LOAD = (1U << 31);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t OVERFLOW_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t OVERFLOW_ST = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t OVERFLOW_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t OVERFLOW_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t SOC_WAKEUP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// LP_INT_RAW Register bits
    namespace lp_int_raw_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_RAW = (1U << 31);  ///< need_des
    }

    /// LP_INT_ST Register bits
    namespace lp_int_st_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_ST = (1U << 31);  ///< need_des
    }

    /// LP_INT_ENA Register bits
    namespace lp_int_ena_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_ENA = (1U << 31);  ///< need_des
    }

    /// LP_INT_CLR Register bits
    namespace lp_int_clr_bits {
        constexpr uint32_t MAIN_TIMER_OVERFLOW_LP_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t MAIN_TIMER_LP_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t LP_WDT_BASE = 0x50116000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t CONFIG0;  ///< Offset: 0x00 - need_des
        volatile uint32_t CONFIG1;  ///< Offset: 0x04 - need_des
        volatile uint32_t CONFIG2;  ///< Offset: 0x08 - need_des
        volatile uint32_t CONFIG3;  ///< Offset: 0x0C - need_des
        volatile uint32_t CONFIG4;  ///< Offset: 0x10 - need_des
        volatile uint32_t FEED;  ///< Offset: 0x14 - need_des
        volatile uint32_t WPROTECT;  ///< Offset: 0x18 - need_des
        volatile uint32_t SWD_CONFIG;  ///< Offset: 0x1C - need_des
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0x20 - need_des
        volatile uint32_t INT_RAW;  ///< Offset: 0x24 - need_des
        volatile uint32_t INT_ST;  ///< Offset: 0x28 - need_des
        volatile uint32_t INT_ENA;  ///< Offset: 0x2C - need_des
        volatile uint32_t INT_CLR;  ///< Offset: 0x30 - need_des
        volatile uint32_t DATE;  ///< Offset: 0x3FC - need_des
    };

    /// Peripheral instances
    inline Registers* LP_WDT = reinterpret_cast<Registers*>(LP_WDT_BASE);

    // Bit definitions
    /// CONFIG0 Register bits
    namespace config0_bits {
        constexpr uint32_t WDT_CHIP_RESET_WIDTH = (8 << 0);  ///< need_des
        constexpr uint32_t WDT_CHIP_RESET_EN = (1U << 8);  ///< need_des
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< need_des
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 10);  ///< need_des
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< need_des
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< need_des
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< need_des
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< need_des
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< need_des
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< need_des
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< need_des
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< need_des
        constexpr uint32_t WDT_EN = (1U << 31);  ///< need_des
    }

    /// CONFIG1 Register bits
    namespace config1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG2 Register bits
    namespace config2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG3 Register bits
    namespace config3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< need_des
    }

    /// CONFIG4 Register bits
    namespace config4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< need_des
    }

    /// FEED Register bits
    namespace feed_bits {
        constexpr uint32_t FEED = (1U << 31);  ///< need_des
    }

    /// WPROTECT Register bits
    namespace wprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< need_des
    }

    /// SWD_CONFIG Register bits
    namespace swd_config_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< need_des
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 18);  ///< need_des
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 19);  ///< need_des
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 20);  ///< need_des
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< need_des
        constexpr uint32_t SWD_FEED = (1U << 31);  ///< need_des
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< need_des
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t SUPER_WDT_INT_RAW = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_RAW = (1U << 31);  ///< need_des
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t SUPER_WDT_INT_ST = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_ST = (1U << 31);  ///< need_des
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t SUPER_WDT_INT_ENA = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_ENA = (1U << 31);  ///< need_des
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t SUPER_WDT_INT_CLR = (1U << 30);  ///< need_des
        constexpr uint32_t LP_WDT_INT_CLR = (1U << 31);  ///< need_des
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t LP_WDT_DATE = (31 << 0);  ///< need_des
        constexpr uint32_t CLK_EN = (1U << 31);  ///< need_des
    }

}

// ============================================================================
// SDHOST Peripheral
// ============================================================================

namespace sdhost {
    /// Base addresses
    constexpr uint32_t SDHOST_BASE = 0x50083000;

    /// SDHOST Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLKDIV;  ///< Offset: 0x08 - Clock divider configuration register
        volatile uint32_t CLKSRC;  ///< Offset: 0x0C - Clock source selection register
        volatile uint32_t CLKENA;  ///< Offset: 0x10 - Clock enable register
        volatile uint32_t TMOUT;  ///< Offset: 0x14 - Data and response timeout configuration register
        volatile uint32_t CTYPE;  ///< Offset: 0x18 - Card bus width configuration register
        volatile uint32_t BLKSIZ;  ///< Offset: 0x1C - Card data block size configuration register
        volatile uint32_t BYTCNT;  ///< Offset: 0x20 - Data transfer length configuration register
        volatile uint32_t INTMASK;  ///< Offset: 0x24 - SDIO interrupt mask register
        volatile uint32_t CMDARG;  ///< Offset: 0x28 - Command argument data register
        volatile uint32_t CMD;  ///< Offset: 0x2C - Command and boot configuration register
        volatile uint32_t RESP0;  ///< Offset: 0x30 - Response data register
        volatile uint32_t RESP1;  ///< Offset: 0x34 - Long response data register
        volatile uint32_t RESP2;  ///< Offset: 0x38 - Long response data register
        volatile uint32_t RESP3;  ///< Offset: 0x3C - Long response data register
        volatile uint32_t MINTSTS;  ///< Offset: 0x40 - Masked interrupt status register
        volatile uint32_t RINTSTS;  ///< Offset: 0x44 - Raw interrupt status register
        volatile uint32_t STATUS;  ///< Offset: 0x48 - SD/MMC status register
        volatile uint32_t FIFOTH;  ///< Offset: 0x4C - FIFO configuration register
        volatile uint32_t CDETECT;  ///< Offset: 0x50 - Card detect register
        volatile uint32_t WRTPRT;  ///< Offset: 0x54 - Card write protection (WP) status register
        volatile uint32_t TCBCNT;  ///< Offset: 0x5C - Transferred byte count register
        volatile uint32_t TBBCNT;  ///< Offset: 0x60 - Transferred byte count register
        volatile uint32_t DEBNCE;  ///< Offset: 0x64 - Debounce filter time configuration register
        volatile uint32_t USRID;  ///< Offset: 0x68 - User ID (scratchpad) register
        volatile uint32_t VERID;  ///< Offset: 0x6C - Version ID (scratchpad) register
        volatile uint32_t HCON;  ///< Offset: 0x70 - Hardware feature register
        volatile uint32_t UHS;  ///< Offset: 0x74 - UHS-1 register
        volatile uint32_t RST_N;  ///< Offset: 0x78 - Card reset register
        volatile uint32_t BMOD;  ///< Offset: 0x80 - Burst mode transfer configuration register
        volatile uint32_t PLDMND;  ///< Offset: 0x84 - Poll demand configuration register
        volatile uint32_t DBADDR;  ///< Offset: 0x88 - Descriptor base address register
        volatile uint32_t IDSTS;  ///< Offset: 0x8C - IDMAC status register
        volatile uint32_t IDINTEN;  ///< Offset: 0x90 - IDMAC interrupt enable register
        volatile uint32_t DSCADDR;  ///< Offset: 0x94 - Host descriptor address pointer
        volatile uint32_t BUFADDR;  ///< Offset: 0x98 - Host buffer address pointer register
        volatile uint32_t CARDTHRCTL;  ///< Offset: 0x100 - Card Threshold Control register
        volatile uint32_t EMMCDDR;  ///< Offset: 0x10C - eMMC DDR register
        volatile uint32_t ENSHIFT;  ///< Offset: 0x110 - Enable Phase Shift register
        volatile uint32_t BUFFIFO;  ///< Offset: 0x200 - CPU write and read transmit data by FIFO
        volatile uint32_t CLK_EDGE_SEL;  ///< Offset: 0x800 - SDIO control register.
        volatile uint32_t RAW_INTS;  ///< Offset: 0x804 - SDIO raw ints register.
        volatile uint32_t DLL_CLK_CONF;  ///< Offset: 0x808 - SDIO DLL clock control register.
        volatile uint32_t DLL_CONF;  ///< Offset: 0x80C - SDIO DLL configuration register.
    };

    /// Peripheral instances
    inline Registers* SDHOST = reinterpret_cast<Registers*>(SDHOST_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CONTROLLER_RESET = (1U << 0);  ///< To reset controller, firmware should set this bit. This bit is auto-cleared after two AHB and two sdhost_cclk_in clock cycles.
        constexpr uint32_t FIFO_RESET = (1U << 1);  ///< To reset FIFO, firmware should set bit to 1. This bit is auto-cleared after completion of reset operation. Note: FIFO pointers will be out of reset after 2 cycles of system clocks in addition to synchronization delay (2 cycles of card clock), after the fifo_reset is cleared.
        constexpr uint32_t DMA_RESET = (1U << 2);  ///< To reset DMA interface, firmware should set bit to 1. This bit is auto-cleared after two AHB clocks.
        constexpr uint32_t INT_ENABLE = (1U << 4);  ///< Global interrupt enable/disable bit. 0: Disable; 1: Enable.
        constexpr uint32_t READ_WAIT = (1U << 6);  ///< For sending read-wait to SDIO cards.
        constexpr uint32_t SEND_IRQ_RESPONSE = (1U << 7);  ///< Bit automatically clears once response is sent. To wait for MMC card interrupts, host issues CMD40 and waits for interrupt response from MMC card(s). In the meantime, if host wants SD/MMC to exit waiting for interrupt state, it can set this bit, at which time SD/MMC command state-machine sends CMD40 response on bus and returns to idle state.
        constexpr uint32_t ABORT_READ_DATA = (1U << 8);  ///< After a suspend-command is issued during a read-operation, software polls the card to find when the suspend-event occurred. Once the suspend-event has occurred, software sets the bit which will reset the data state machine that is waiting for the next block of data. This bit is automatically cleared once the data state machine is reset to idle.
        constexpr uint32_t SEND_CCSD = (1U << 9);  ///< When set, SD/MMC sends CCSD to the CE-ATA device. Software sets this bit only if the current command is expecting CCS (that is, RW_BLK), and if interrupts are enabled for the CE-ATA device. Once the CCSD pattern is sent to the device, SD/MMC automatically clears the SDHOST_SEND_CCSD bit. It also sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG register, and generates an interrupt for the host, in case the Command Done interrupt is not masked. NOTE: Once the SDHOST_SEND_CCSD bit is set, it takes two card clock cycles to drive the CCSD on the CMD line. Due to this, within the boundary conditions the CCSD may be sent to the CE-ATA device, even if the device has signalled CCS.
        constexpr uint32_t SEND_AUTO_STOP_CCSD = (1U << 10);  ///< Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits together; SDHOST_SEND_AUTO_STOP_CCSD should not be set independently of send_ccsd. When set, SD/MMC automatically sends an internally-generated STOP command (CMD12) to the CE-ATA device. After sending this internally-generated STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG is set and an interrupt is generated for the host, in case the ACD interrupt is not masked. After sending the Command Completion Signal Disable (CCSD), SD/MMC automatically clears the SDHOST_SEND_AUTO_STOP_CCSD bit.
        constexpr uint32_t CEATA_DEVICE_INTERRUPT_STATUS = (1U << 11);  ///< Software should appropriately write to this bit after the power-on reset or any other reset to the CE-ATA device. After reset, the CE-ATA device's interrupt is usually disabled (nIEN = 1). If the host enables the CE-ATA device's interrupt, then software should set this bit.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLK_DIVIDER0 = (8 << 0);  ///< Clock divider0 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER1 = (8 << 8);  ///< Clock divider1 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER2 = (8 << 16);  ///< Clock divider2 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER3 = (8 << 24);  ///< Clock divider3 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
    }

    /// CLKSRC Register bits
    namespace clksrc_bits {
        constexpr uint32_t CLKSRC = (4 << 0);  ///< Clock divider source for two SD cards is supported. Each card has two bits assigned to it. For example, bit[1:0] are assigned for card 0, bit[3:2] are assigned for card 1. Card 0 maps and internally routes clock divider[0:3] outputs to cclk_out[1:0] pins, depending on bit value. 00 : Clock divider 0; 01 : Clock divider 1; 10 : Clock divider 2; 11 : Clock divider 3.
    }

    /// CLKENA Register bits
    namespace clkena_bits {
        constexpr uint32_t CCLK_ENABLE = (2 << 0);  ///< Clock-enable control for two SD card clocks and one MMC card clock is supported. One bit per card. 0: Clock disabled; 1: Clock enabled.
        constexpr uint32_t LP_ENABLE = (2 << 16);  ///< Disable clock when the card is in IDLE state. One bit per card. 0: clock disabled; 1: clock enabled.
    }

    /// TMOUT Register bits
    namespace tmout_bits {
        constexpr uint32_t RESPONSE_TIMEOUT = (8 << 0);  ///< Response timeout value. Value is specified in terms of number of card output clocks, i.e., sdhost_cclk_out.
        constexpr uint32_t DATA_TIMEOUT = (24 << 8);  ///< Value for card data read timeout. This value is also used for data starvation by host timeout. The timeout counter is started only after the card clock is stopped. This value is specified in number of card output clocks, i.e. sdhost_cclk_out of the selected card. NOTE: The software timer should be used if the timeout value is in the order of 100 ms. In this case, read data timeout interrupt needs to be disabled.
    }

    /// CTYPE Register bits
    namespace ctype_bits {
        constexpr uint32_t CARD_WIDTH4 = (2 << 0);  ///< One bit per card indicates if card is 1-bit or 4-bit mode. 0: 1-bit mode; 1: 4-bit mode. Bit[1:0] correspond to card[1:0] respectively.
        constexpr uint32_t CARD_WIDTH8 = (2 << 16);  ///< One bit per card indicates if card is in 8-bit mode. 0: Non 8-bit mode; 1: 8-bit mode. Bit[17:16] correspond to card[1:0] respectively.
    }

    /// BLKSIZ Register bits
    namespace blksiz_bits {
        constexpr uint32_t BLOCK_SIZE = (16 << 0);  ///< Block size.
    }

    /// BYTCNT Register bits
    namespace bytcnt_bits {
        constexpr uint32_t BYTE_COUNT = (32 << 0);  ///< Number of bytes to be transferred, should be an integral multiple of Block Size for block transfers. For data transfers of undefined byte lengths, byte count should be set to 0. When byte count is set to 0, it is the responsibility of host to explicitly send stop/abort command to terminate data transfer.
    }

    /// INTMASK Register bits
    namespace intmask_bits {
        constexpr uint32_t INT_MASK = (16 << 0);  ///< These bits used to mask unwanted interrupts. A value of 0 masks interrupt, and a value of 1 enables the interrupt. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): Rx Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation-by-host timeout; Bit 9 (DRTO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INT_MASK = (2 << 16);  ///< SDIO interrupt mask, one bit for each card. Bit[17:16] correspond to card[15:0] respectively. When masked, SDIO interrupt detection for that card is disabled. 0 masks an interrupt, and 1 enables an interrupt.
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Value indicates command argument to be passed to the card.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Command index.
        constexpr uint32_t RESPONSE_EXPECT = (1U << 6);  ///< 0: No response expected from card; 1: Response expected from card.
        constexpr uint32_t RESPONSE_LENGTH = (1U << 7);  ///< 0: Short response expected from card; 1: Long response expected from card.
        constexpr uint32_t CHECK_RESPONSE_CRC = (1U << 8);  ///< 0: Do not check; 1: Check response CRC. Some of command responses do not return valid CRC bits. Software should disable CRC checks for those commands in order to disable CRC checking by controller.
        constexpr uint32_t DATA_EXPECTED = (1U << 9);  ///< 0: No data transfer expected; 1: Data transfer expected.
        constexpr uint32_t READ_WRITE = (1U << 10);  ///< 0: Read from card; 1: Write to card. Don't care if no data is expected from card.
        constexpr uint32_t TRANSFER_MODE = (1U << 11);  ///< 0: Block data transfer command; 1: Stream data transfer command. Don't care if no data expected.
        constexpr uint32_t SEND_AUTO_STOP = (1U << 12);  ///< 0: No stop command is sent at the end of data transfer; 1: Send stop command at the end of data transfer.
        constexpr uint32_t WAIT_PRVDATA_COMPLETE = (1U << 13);  ///< 0: Send command at once, even if previous data transfer has not completed; 1: Wait for previous data transfer to complete before sending Command. The SDHOST_WAIT_PRVDATA_COMPLETE] = 0 option is typically used to query status of card during data transfer or to stop current data transfer. SDHOST_CARD_NUMBERr should be same as in previous command.
        constexpr uint32_t STOP_ABORT_CMD = (1U << 14);  ///< 0: Neither stop nor abort command can stop current data transfer. If abort is sent to function-number currently selected or not in data-transfer mode, then bit should be set to 0; 1: Stop or abort command intended to stop current data transfer in progress. When open-ended or predefined data transfer is in progress, and host issues stop or abort command to stop data transfer, bit should be set so that command/data state-machines of CIU can return correctly to idle state.
        constexpr uint32_t SEND_INITIALIZATION = (1U << 15);  ///< 0: Do not send initialization sequence (80 clocks of 1) before sending this command; 1: Send initialization sequence before sending this command. After powered on, 80 clocks must be sent to card for initialization before sending any commands to card. Bit should be set while sending first command to card so that controller will initialize clocks before sending command to card.
        constexpr uint32_t CARD_NUMBER = (5 << 16);  ///< Card number in use. Represents physical slot number of card being accessed. In SD-only mode, up to two cards are supported.
        constexpr uint32_t UPDATE_CLOCK_REGISTERS_ONLY = (1U << 21);  ///< 0: Normal command sequence; 1: Do not send commands, just update clock register value into card clock domain. Following register values are transferred into card clock domain: CLKDIV, CLRSRC, and CLKENA. Changes card clocks (change frequency, truncate off or on, and set low-frequency mode). This is provided in order to change clock frequency or stop clock without having to send command to cards. During normal command sequence, when sdhost_update_clock_registers_only = 0, following control registers are transferred from BIU to CIU: CMD, CMDARG, TMOUT, CTYPE, BLKSIZ, and BYTCNT. CIU uses new register values for new command sequence to card(s). When bit is set, there are no Command Done interrupts because no command is sent to SD_MMC_CEATA cards.
        constexpr uint32_t READ_CEATA_DEVICE = (1U << 22);  ///< Read access flag. 0: Host is not performing read access (RW_REG or RW_BLK)towards CE-ATA device; 1: Host is performing read access (RW_REG or RW_BLK) towards CE-ATA device. Software should set this bit to indicate that CE-ATA device is being accessed for read transfer. This bit is used to disable read data timeout indication while performing CE-ATA read transfers. Maximum value of I/O transmission delay can be no less than 10 seconds. SD/MMC should not indicate read data timeout while waiting for data from CE-ATA device.
        constexpr uint32_t CCS_EXPECTED = (1U << 23);  ///< Expected Command Completion Signal (CCS) configuration. 0: Interrupts are not enabled in CE-ATA device (nIEN = 1 in ATA control register), or command does not expect CCS from device; 1: Interrupts are enabled in CE-ATA device (nIEN = 0), and RW_BLK command expects command completion signal from CE-ATA device. If the command expects Command Completion Signal (CCS) from the CE-ATA device, the software should set this control bit. SD/MMC sets Data Transfer Over (DTO) bit in RINTSTS register and generates interrupt to host if Data Transfer Over interrupt is not masked.
        constexpr uint32_t USE_HOLE = (1U << 29);  ///< Use Hold Register. 0: CMD and DATA sent to card bypassing HOLD Register; 1: CMD and DATA sent to card through the HOLD Register.
        constexpr uint32_t START_CMD = (1U << 31);  ///< Start command. Once command is served by the CIU, this bit is automatically cleared. When this bit is set, host should not attempt to write to any command registers. If a write is attempted, hardware lock error is set in raw interrupt register. Once command is sent and a response is received from SD_MMC_CEATA cards, Command Done bit is set in the raw interrupt Register.
    }

    /// RESP0 Register bits
    namespace resp0_bits {
        constexpr uint32_t RESPONSE0 = (32 << 0);  ///< Bit[31:0] of response.
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t RESPONSE1 = (32 << 0);  ///< Bit[63:32] of long response.
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t RESPONSE2 = (32 << 0);  ///< Bit[95:64] of long response.
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t RESPONSE3 = (32 << 0);  ///< Bit[127:96] of long response.
    }

    /// MINTSTS Register bits
    namespace mintsts_bits {
        constexpr uint32_t INT_STATUS_MSK = (16 << 0);  ///< Interrupt enabled only if corresponding bit in interrupt mask register is set. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_MSK = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. SDIO interrupt for card is enabled only if corresponding sdhost_sdio_int_mask bit is set in Interrupt mask register (Setting mask bit enables interrupt).
    }

    /// RINTSTS Register bits
    namespace rintsts_bits {
        constexpr uint32_t INT_STATUS_RAW = (16 << 0);  ///< Setting a bit clears the corresponding interrupt and writing 0 has no effect. Bits are logged regardless of interrupt mask status. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_RAW = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. Setting a bit clears the corresponding interrupt bit and writing 0 has no effect. 0: No SDIO interrupt from card; 1: SDIO interrupt from card.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t FIFO_RX_WATERMARK = (1U << 0);  ///< FIFO reached Receive watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_TX_WATERMARK = (1U << 1);  ///< FIFO reached Transmit watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_EMPTY = (1U << 2);  ///< FIFO is empty status.
        constexpr uint32_t FIFO_FULL = (1U << 3);  ///< FIFO is full status.
        constexpr uint32_t COMMAND_FSM_STATES = (4 << 4);  ///< Command FSM states. 0: Idle; 1: Send init sequence; 2: Send cmd start bit; 3: Send cmd tx bit; 4: Send cmd index + arg; 5: Send cmd crc7; 6: Send cmd end bit; 7: Receive resp start bit; 8: Receive resp IRQ response; 9: Receive resp tx bit; 10: Receive resp cmd idx; 11: Receive resp data; 12: Receive resp crc7; 13: Receive resp end bit; 14: Cmd path wait NCC; 15: Wait, cmd-to-response turnaround.
        constexpr uint32_t DATA_3_STATUS = (1U << 8);  ///< Raw selected sdhost_card_data[3], checks whether card is present. 0: card not present; 1: card present.
        constexpr uint32_t DATA_BUSY = (1U << 9);  ///< Inverted version of raw selected sdhost_card_data[0]. 0: Card data not busy; 1: Card data busy.
        constexpr uint32_t DATA_STATE_MC_BUSY = (1U << 10);  ///< Data transmit or receive state-machine is busy.
        constexpr uint32_t RESPONSE_INDEX = (6 << 11);  ///< Index of previous response, including any auto-stop sent by core.
        constexpr uint32_t FIFO_COUNT = (13 << 17);  ///< FIFO count, number of filled locations in FIFO.
    }

    /// FIFOTH Register bits
    namespace fifoth_bits {
        constexpr uint32_t TX_WMARK = (12 << 0);  ///< FIFO threshold watermark level when transmitting data to card. When FIFO data count is less than or equal to this number, DMA/FIFO request is raised. If Interrupt is enabled, then interrupt occurs. During end of packet, request or interrupt is generated, regardless of threshold programming.In non-DMA mode, when transmit FIFO threshold (TXDR) interrupt is enabled, then interrupt is generated instead of DMA request. During end of packet, on last interrupt, host is responsible for filling FIFO with only required remaining bytes (not before FIFO is full or after CIU completes data transfers, because FIFO may not be empty). In DMA mode, at end of packet, if last transfer is less than burst size, DMA controller does single cycles until required bytes are transferred.
        constexpr uint32_t RX_WMARK = (11 << 16);  ///< FIFO threshold watermark level when receiving data to card.When FIFO data count reaches greater than this number , DMA/FIFO request is raised. During end of packet, request is generated regardless of threshold programming in order to complete any remaining data.In non-DMA mode, when receiver FIFO threshold (RXDR) interrupt is enabled, then interrupt is generated instead of DMA request.During end of packet, interrupt is not generated if threshold programming is larger than any remaining data. It is responsibility of host to read remaining bytes on seeing Data Transfer Done interrupt.In DMA mode, at end of packet, even if remaining bytes are less than threshold, DMA request does single transfers to flush out any remaining bytes before Data Transfer Done interrupt is set.
        constexpr uint32_t DMA_MULTIPLE_TRANSACTION_SIZE = (3 << 28);  ///< Burst size of multiple transaction, should be programmed same as DMA controller multiple-transaction-size SDHOST_SRC/DEST_MSIZE. 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer.
    }

    /// CDETECT Register bits
    namespace cdetect_bits {
        constexpr uint32_t CARD_DETECT_N = (2 << 0);  ///< Value on sdhost_card_detect_n input ports (1 bit per card), read-only bits. 0 represents presence of card. Only NUM_CARDS number of bits are implemented.
    }

    /// WRTPRT Register bits
    namespace wrtprt_bits {
        constexpr uint32_t WRITE_PROTECT = (2 << 0);  ///< Value on sdhost_card_write_prt input ports (1 bit per card). 1 represents write protection. Only NUM_CARDS number of bits are implemented.
    }

    /// TCBCNT Register bits
    namespace tcbcnt_bits {
        constexpr uint32_t TCBCNT = (32 << 0);  ///< Number of bytes transferred by CIU unit to card.
    }

    /// TBBCNT Register bits
    namespace tbbcnt_bits {
        constexpr uint32_t TBBCNT = (32 << 0);  ///< Number of bytes transferred between Host/DMA memory and BIU FIFO.
    }

    /// DEBNCE Register bits
    namespace debnce_bits {
        constexpr uint32_t DEBOUNCE_COUNT = (24 << 0);  ///< Number of host clocks (clk) used by debounce filter logic. The typical debounce time is 5 \verb+~+ 25 ms to prevent the card instability when the card is inserted or removed.
    }

    /// USRID Register bits
    namespace usrid_bits {
        constexpr uint32_t USRID = (32 << 0);  ///< User identification register, value set by user. Can also be used as a scratchpad register by user.
    }

    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSIONID = (32 << 0);  ///< Hardware version register. Can also be read by fireware.
    }

    /// HCON Register bits
    namespace hcon_bits {
        constexpr uint32_t CARD_TYPE = (1U << 0);  ///< Hardware support SDIO and MMC.
        constexpr uint32_t CARD_NUM = (5 << 1);  ///< Support card number is 2.
        constexpr uint32_t BUS_TYPE = (1U << 6);  ///< Register config is APB bus.
        constexpr uint32_t DATA_WIDTH = (3 << 7);  ///< Regisger data widht is 32.
        constexpr uint32_t ADDR_WIDTH = (6 << 10);  ///< Register address width is 32.
        constexpr uint32_t DMA_WIDTH = (3 << 18);  ///< DMA data witdth is 32.
        constexpr uint32_t RAM_INDISE = (1U << 21);  ///< Inside RAM in SDMMC module.
        constexpr uint32_t HOLD = (1U << 22);  ///< Have a hold regiser in data path .
        constexpr uint32_t NUM_CLK_DIV = (2 << 24);  ///< Have 4 clk divider in design .
    }

    /// UHS Register bits
    namespace uhs_bits {
        constexpr uint32_t DDR = (2 << 16);  ///< DDR mode selecton,1 bit for each card. 0-Non-DDR mdoe. 1-DDR mdoe.
    }

    /// RST_N Register bits
    namespace rst_n_bits {
        constexpr uint32_t CARD_RESET = (2 << 0);  ///< Hardware reset. 1: Active mode; 0: Reset. These bits cause the cards to enter pre-idle state, which requires them to be re-initialized. SDHOST_RST_CARD_RESET[0] should be set to 1'b0 to reset card0, SDHOST_RST_CARD_RESET[1] should be set to 1'b0 to reset card1.
    }

    /// BMOD Register bits
    namespace bmod_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset. When set, the DMA Controller resets all its internal registers. It is automatically cleared after one clock cycle.
        constexpr uint32_t FB = (1U << 1);  ///< Fixed Burst. Controls whether the AHB Master interface performs fixed burst transfers or not. When set, the AHB will use only SINGLE, INCR4, INCR8 or INCR16 during start of normal burst transfers. When reset, the AHB will use SINGLE and INCR burst transfer operations.
        constexpr uint32_t DE = (1U << 7);  ///< IDMAC Enable. When set, the IDMAC is enabled.
        constexpr uint32_t PBL = (3 << 8);  ///< Programmable Burst Length. These bits indicate the maximum number of beats to be performed in one IDMAC???Internal DMA Control???transaction. The IDMAC will always attempt to burst as specified in PBL each time it starts a burst transfer on the host bus. The permissible values are 1, 4, 8, 16, 32, 64, 128 and 256. This value is the mirror of MSIZE of FIFOTH register. In order to change this value, write the required value to FIFOTH register. This is an encode value as follows: 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer. PBL is a read-only value and is applicable only for data access, it does not apply to descriptor access.
    }

    /// PLDMND Register bits
    namespace pldmnd_bits {
        constexpr uint32_t PD = (32 << 0);  ///< Poll Demand. If the OWNER bit of a descriptor is not set, the FSM goes to the Suspend state. The host needs to write any value into this register for the IDMAC FSM to resume normal descriptor fetch operation. This is a write only .
    }

    /// DBADDR Register bits
    namespace dbaddr_bits {
        constexpr uint32_t DBADDR = (32 << 0);  ///< Start of Descriptor List. Contains the base address of the First Descriptor. The LSB bits [1:0] are ignored and taken as all-zero by the IDMAC internally. Hence these LSB bits may be treated as read-only.
    }

    /// IDSTS Register bits
    namespace idsts_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt. Indicates that data transmission is finished for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt. Indicates the completion of data reception for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Interrupt. Indicates that a Bus Error occurred (IDSTS[12:10]) . When this bit is set, the DMA disables all its bus accesses. Writing 1 clears this bit.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. This bit is set when the descriptor is unavailable due to OWNER bit = 0 (DES0[31] = 0). Writing 1 clears this bit.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error Summary. Indicates the status of the transaction to/from the card, also present in RINTSTS. Indicates the logical OR of the following bits: EBE : End Bit Error; RTO : Response Timeout/Boot Ack Timeout; RCRC : Response CRC; SBE : Start Bit Error; DRTO : Data Read Timeout/BDS timeout; DCRC : Data CRC for Receive; RE : Response Error. Writing 1 clears this bit. The abort condition of the IDMAC depends on the setting of this CES bit. If the CES bit is enabled, then the IDMAC aborts on a response error.
        constexpr uint32_t NIS = (1U << 8);  ///< Normal Interrupt Summary. Logical OR of the following: IDSTS[0] : Transmit Interrupt, IDSTS[1] : Receive Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes NIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t AIS = (1U << 9);  ///< Abnormal Interrupt Summary. Logical OR of the following: IDSTS[2] : Fatal Bus Interrupt, IDSTS[4] : DU bit Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes AIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t FBE_CODE = (3 << 10);  ///< Fatal Bus Error Code. Indicates the type of error that caused a Bus Error. Valid only when the Fatal Bus Error bit IDSTS[2] is set. This field does not generate an interrupt. 001: Host Abort received during transmission; 010: Host Abort received during reception; Others: Reserved.
        constexpr uint32_t FSM = (4 << 13);  ///< DMAC FSM present state. 0: DMA_IDLE (idle state); 1: DMA_SUSPEND (suspend state); 2: DESC_RD (descriptor reading state); 3: DESC_CHK (descriptor checking state); 4: DMA_RD_REQ_WAIT (read-data request waiting state); 5: DMA_WR_REQ_WAIT (write-data request waiting state); 6: DMA_RD (data-read state); 7: DMA_WR (data-write state); 8: DESC_CLOSE (descriptor close state).
    }

    /// IDINTEN Register bits
    namespace idinten_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable, Transmit Interrupt is enabled. When reset, Transmit Interrupt is disabled.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive Interrupt is enabled. When reset, Receive Interrupt is disabled.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Enable. When set with Abnormal Interrupt Summary Enable, the Fatal Bus Error Interrupt is enabled. When reset, Fatal Bus Error Enable Interrupt is disabled.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary Enable, the DU interrupt is enabled.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error summary Interrupt Enable. When set, it enables the Card Interrupt summary.
        constexpr uint32_t NI = (1U << 8);  ///< Normal Interrupt Summary Enable. When set, a normal interrupt is enabled. When reset, a normal interrupt is disabled. This bit enables the following bits: IDINTEN[0]: Transmit Interrupt; IDINTEN[1]: Receive Interrupt.
        constexpr uint32_t AI = (1U << 9);  ///< Abnormal Interrupt Summary Enable. When set, an abnormal interrupt is enabled. This bit enables the following bits: IDINTEN[2]: Fatal Bus Error Interrupt; IDINTEN[4]: DU Interrupt.
    }

    /// DSCADDR Register bits
    namespace dscaddr_bits {
        constexpr uint32_t DSCADDR = (32 << 0);  ///< Host Descriptor Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the start address of the current descriptor read by the IDMAC.
    }

    /// BUFADDR Register bits
    namespace bufaddr_bits {
        constexpr uint32_t BUFADDR = (32 << 0);  ///< Host Buffer Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the current Data Buffer Address being accessed by the IDMAC.
    }

    /// CARDTHRCTL Register bits
    namespace cardthrctl_bits {
        constexpr uint32_t CARDRDTHREN = (1U << 0);  ///< Card read threshold enable. 1'b0-Card read threshold disabled. 1'b1-Card read threshold enabled.
        constexpr uint32_t CARDCLRINTEN = (1U << 1);  ///< Busy clear interrupt generation: 1'b0-Busy clear interrypt disabled. 1'b1-Busy clear interrypt enabled.
        constexpr uint32_t CARDWRTHREN = (1U << 2);  ///< Applicable when HS400 mode is enabled. 1'b0-Card write Threshold disabled. 1'b1-Card write Threshold enabled.
        constexpr uint32_t CARDTHRESHOLD = (16 << 16);  ///< The inside FIFO size is 512,This register is applicable when SDHOST_CARDERTHREN_REG is set to 1 or SDHOST_CARDRDTHREN_REG set to 1.
    }

    /// EMMCDDR Register bits
    namespace emmcddr_bits {
        constexpr uint32_t HALFSTARTBIT = (2 << 0);  ///< Control for start bit detection mechanism duration of start bit.Each bit refers to one slot.Set this bit to 1 for eMMC4.5 and above,set to 0 for SD applications.For eMMC4.5,start bit can be: 1'b0-Full cycle. 1'b1-less than one full cycle.
        constexpr uint32_t HS400_MODE = (1U << 31);  ///< Set 1 to enable HS400 mode.
    }

    /// ENSHIFT Register bits
    namespace enshift_bits {
        constexpr uint32_t ENABLE_SHIFT = (4 << 0);  ///< Control for the amount of phase shift provided on the default enables in the design.Two bits assigned for each card. 2'b00-Default phase shift. 2'b01-Enables shifted to next immediate positive edge. 2'b10-Enables shifted to next immediate negative edge. 2'b11-Reserved.
    }

    /// BUFFIFO Register bits
    namespace buffifo_bits {
        constexpr uint32_t BUFFIFO = (32 << 0);  ///< CPU write and read transmit data by FIFO. This register points to the current Data FIFO .
    }

    /// CLK_EDGE_SEL Register bits
    namespace clk_edge_sel_bits {
        constexpr uint32_t CCLKIN_EDGE_DRV_SEL = (3 << 0);  ///< It's used to select the clock phase of the output signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SAM_SEL = (3 << 3);  ///< It's used to select the clock phase of the input signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SLF_SEL = (3 << 6);  ///< It's used to select the clock phase of the internal signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLLKIN_EDGE_H = (4 << 9);  ///< The high level of the divider clock. The value should be smaller than CCLKIN_EDGE_L.
        constexpr uint32_t CCLLKIN_EDGE_L = (4 << 13);  ///< The low level of the divider clock. The value should be larger than CCLKIN_EDGE_H.
        constexpr uint32_t CCLLKIN_EDGE_N = (4 << 17);  ///< The clock division of cclk_in.
        constexpr uint32_t ESDIO_MODE = (1U << 21);  ///< Enable esdio mode.
        constexpr uint32_t ESD_MODE = (1U << 22);  ///< Enable esd mode.
        constexpr uint32_t CCLK_EN = (1U << 23);  ///< Sdio clock enable.
        constexpr uint32_t ULTRA_HIGH_SPEED_MODE = (1U << 24);  ///< Enable ultra high speed mode, use dll to generate clk.
    }

    /// RAW_INTS Register bits
    namespace raw_ints_bits {
        constexpr uint32_t RAW_INTS = (32 << 0);  ///< It indicates raw ints.
    }

    /// DLL_CLK_CONF Register bits
    namespace dll_clk_conf_bits {
        constexpr uint32_t DLL_CCLK_IN_SLF_EN = (1U << 0);  ///< Clock enable of cclk_in_slf when ULTRA_HIGH_SPEED_MODE==1.
        constexpr uint32_t DLL_CCLK_IN_DRV_EN = (1U << 1);  ///< Clock enable of cclk_in_drv when ULTRA_HIGH_SPEED_MODE==1.
        constexpr uint32_t DLL_CCLK_IN_SAM_EN = (1U << 2);  ///< Clock enable of cclk_in_sam when ULTRA_HIGH_SPEED_MODE==1.
        constexpr uint32_t DLL_CCLK_IN_SLF_PHASE = (6 << 3);  ///< It's used to control the phase of cclk_in_slf when ULTRA_HIGH_SPEED_MODE==1.
        constexpr uint32_t DLL_CCLK_IN_DRV_PHASE = (6 << 9);  ///< It's used to control the phase of cclk_in_drv when ULTRA_HIGH_SPEED_MODE==1.
        constexpr uint32_t DLL_CCLK_IN_SAM_PHASE = (6 << 15);  ///< It's used to control the phase of cclk_in_sam when ULTRA_HIGH_SPEED_MODE==1.
    }

    /// DLL_CONF Register bits
    namespace dll_conf_bits {
        constexpr uint32_t DLL_CAL_STOP = (1U << 0);  ///< Set 1 to stop calibration.
        constexpr uint32_t DLL_CAL_END = (1U << 1);  ///< 1 means calibration finished.
    }

}

// ============================================================================
// SOC Peripheral
// ============================================================================

namespace soc {
    /// Base addresses
    constexpr uint32_t SOC_ETM_BASE = 0x500D5000;

    /// SOC Register structure
    struct Registers {
        volatile uint32_t CH_ENA_AD0;  ///< Offset: 0x00 - Channel enable status register
        volatile uint32_t CH_ENA_AD0_SET;  ///< Offset: 0x04 - Channel enable set register
        volatile uint32_t CH_ENA_AD0_CLR;  ///< Offset: 0x08 - Channel enable clear register
        volatile uint32_t CH_ENA_AD1;  ///< Offset: 0x0C - Channel enable status register
        volatile uint32_t CH_ENA_AD1_SET;  ///< Offset: 0x10 - Channel enable set register
        volatile uint32_t CH_ENA_AD1_CLR;  ///< Offset: 0x14 - Channel enable clear register
        volatile uint32_t CH0_EVT_ID;  ///< Offset: 0x18 - Channel0 event id register
        volatile uint32_t CH0_TASK_ID;  ///< Offset: 0x1C - Channel0 task id register
        volatile uint32_t CH1_EVT_ID;  ///< Offset: 0x20 - Channel1 event id register
        volatile uint32_t CH1_TASK_ID;  ///< Offset: 0x24 - Channel1 task id register
        volatile uint32_t CH2_EVT_ID;  ///< Offset: 0x28 - Channel2 event id register
        volatile uint32_t CH2_TASK_ID;  ///< Offset: 0x2C - Channel2 task id register
        volatile uint32_t CH3_EVT_ID;  ///< Offset: 0x30 - Channel3 event id register
        volatile uint32_t CH3_TASK_ID;  ///< Offset: 0x34 - Channel3 task id register
        volatile uint32_t CH4_EVT_ID;  ///< Offset: 0x38 - Channel4 event id register
        volatile uint32_t CH4_TASK_ID;  ///< Offset: 0x3C - Channel4 task id register
        volatile uint32_t CH5_EVT_ID;  ///< Offset: 0x40 - Channel5 event id register
        volatile uint32_t CH5_TASK_ID;  ///< Offset: 0x44 - Channel5 task id register
        volatile uint32_t CH6_EVT_ID;  ///< Offset: 0x48 - Channel6 event id register
        volatile uint32_t CH6_TASK_ID;  ///< Offset: 0x4C - Channel6 task id register
        volatile uint32_t CH7_EVT_ID;  ///< Offset: 0x50 - Channel7 event id register
        volatile uint32_t CH7_TASK_ID;  ///< Offset: 0x54 - Channel7 task id register
        volatile uint32_t CH8_EVT_ID;  ///< Offset: 0x58 - Channel8 event id register
        volatile uint32_t CH8_TASK_ID;  ///< Offset: 0x5C - Channel8 task id register
        volatile uint32_t CH9_EVT_ID;  ///< Offset: 0x60 - Channel9 event id register
        volatile uint32_t CH9_TASK_ID;  ///< Offset: 0x64 - Channel9 task id register
        volatile uint32_t CH10_EVT_ID;  ///< Offset: 0x68 - Channel10 event id register
        volatile uint32_t CH10_TASK_ID;  ///< Offset: 0x6C - Channel10 task id register
        volatile uint32_t CH11_EVT_ID;  ///< Offset: 0x70 - Channel11 event id register
        volatile uint32_t CH11_TASK_ID;  ///< Offset: 0x74 - Channel11 task id register
        volatile uint32_t CH12_EVT_ID;  ///< Offset: 0x78 - Channel12 event id register
        volatile uint32_t CH12_TASK_ID;  ///< Offset: 0x7C - Channel12 task id register
        volatile uint32_t CH13_EVT_ID;  ///< Offset: 0x80 - Channel13 event id register
        volatile uint32_t CH13_TASK_ID;  ///< Offset: 0x84 - Channel13 task id register
        volatile uint32_t CH14_EVT_ID;  ///< Offset: 0x88 - Channel14 event id register
        volatile uint32_t CH14_TASK_ID;  ///< Offset: 0x8C - Channel14 task id register
        volatile uint32_t CH15_EVT_ID;  ///< Offset: 0x90 - Channel15 event id register
        volatile uint32_t CH15_TASK_ID;  ///< Offset: 0x94 - Channel15 task id register
        volatile uint32_t CH16_EVT_ID;  ///< Offset: 0x98 - Channel16 event id register
        volatile uint32_t CH16_TASK_ID;  ///< Offset: 0x9C - Channel16 task id register
        volatile uint32_t CH17_EVT_ID;  ///< Offset: 0xA0 - Channel17 event id register
        volatile uint32_t CH17_TASK_ID;  ///< Offset: 0xA4 - Channel17 task id register
        volatile uint32_t CH18_EVT_ID;  ///< Offset: 0xA8 - Channel18 event id register
        volatile uint32_t CH18_TASK_ID;  ///< Offset: 0xAC - Channel18 task id register
        volatile uint32_t CH19_EVT_ID;  ///< Offset: 0xB0 - Channel19 event id register
        volatile uint32_t CH19_TASK_ID;  ///< Offset: 0xB4 - Channel19 task id register
        volatile uint32_t CH20_EVT_ID;  ///< Offset: 0xB8 - Channel20 event id register
        volatile uint32_t CH20_TASK_ID;  ///< Offset: 0xBC - Channel20 task id register
        volatile uint32_t CH21_EVT_ID;  ///< Offset: 0xC0 - Channel21 event id register
        volatile uint32_t CH21_TASK_ID;  ///< Offset: 0xC4 - Channel21 task id register
        volatile uint32_t CH22_EVT_ID;  ///< Offset: 0xC8 - Channel22 event id register
        volatile uint32_t CH22_TASK_ID;  ///< Offset: 0xCC - Channel22 task id register
        volatile uint32_t CH23_EVT_ID;  ///< Offset: 0xD0 - Channel23 event id register
        volatile uint32_t CH23_TASK_ID;  ///< Offset: 0xD4 - Channel23 task id register
        volatile uint32_t CH24_EVT_ID;  ///< Offset: 0xD8 - Channel24 event id register
        volatile uint32_t CH24_TASK_ID;  ///< Offset: 0xDC - Channel24 task id register
        volatile uint32_t CH25_EVT_ID;  ///< Offset: 0xE0 - Channel25 event id register
        volatile uint32_t CH25_TASK_ID;  ///< Offset: 0xE4 - Channel25 task id register
        volatile uint32_t CH26_EVT_ID;  ///< Offset: 0xE8 - Channel26 event id register
        volatile uint32_t CH26_TASK_ID;  ///< Offset: 0xEC - Channel26 task id register
        volatile uint32_t CH27_EVT_ID;  ///< Offset: 0xF0 - Channel27 event id register
        volatile uint32_t CH27_TASK_ID;  ///< Offset: 0xF4 - Channel27 task id register
        volatile uint32_t CH28_EVT_ID;  ///< Offset: 0xF8 - Channel28 event id register
        volatile uint32_t CH28_TASK_ID;  ///< Offset: 0xFC - Channel28 task id register
        volatile uint32_t CH29_EVT_ID;  ///< Offset: 0x100 - Channel29 event id register
        volatile uint32_t CH29_TASK_ID;  ///< Offset: 0x104 - Channel29 task id register
        volatile uint32_t CH30_EVT_ID;  ///< Offset: 0x108 - Channel30 event id register
        volatile uint32_t CH30_TASK_ID;  ///< Offset: 0x10C - Channel30 task id register
        volatile uint32_t CH31_EVT_ID;  ///< Offset: 0x110 - Channel31 event id register
        volatile uint32_t CH31_TASK_ID;  ///< Offset: 0x114 - Channel31 task id register
        volatile uint32_t CH32_EVT_ID;  ///< Offset: 0x118 - Channel32 event id register
        volatile uint32_t CH32_TASK_ID;  ///< Offset: 0x11C - Channel32 task id register
        volatile uint32_t CH33_EVT_ID;  ///< Offset: 0x120 - Channel33 event id register
        volatile uint32_t CH33_TASK_ID;  ///< Offset: 0x124 - Channel33 task id register
        volatile uint32_t CH34_EVT_ID;  ///< Offset: 0x128 - Channel34 event id register
        volatile uint32_t CH34_TASK_ID;  ///< Offset: 0x12C - Channel34 task id register
        volatile uint32_t CH35_EVT_ID;  ///< Offset: 0x130 - Channel35 event id register
        volatile uint32_t CH35_TASK_ID;  ///< Offset: 0x134 - Channel35 task id register
        volatile uint32_t CH36_EVT_ID;  ///< Offset: 0x138 - Channel36 event id register
        volatile uint32_t CH36_TASK_ID;  ///< Offset: 0x13C - Channel36 task id register
        volatile uint32_t CH37_EVT_ID;  ///< Offset: 0x140 - Channel37 event id register
        volatile uint32_t CH37_TASK_ID;  ///< Offset: 0x144 - Channel37 task id register
        volatile uint32_t CH38_EVT_ID;  ///< Offset: 0x148 - Channel38 event id register
        volatile uint32_t CH38_TASK_ID;  ///< Offset: 0x14C - Channel38 task id register
        volatile uint32_t CH39_EVT_ID;  ///< Offset: 0x150 - Channel39 event id register
        volatile uint32_t CH39_TASK_ID;  ///< Offset: 0x154 - Channel39 task id register
        volatile uint32_t CH40_EVT_ID;  ///< Offset: 0x158 - Channel40 event id register
        volatile uint32_t CH40_TASK_ID;  ///< Offset: 0x15C - Channel40 task id register
        volatile uint32_t CH41_EVT_ID;  ///< Offset: 0x160 - Channel41 event id register
        volatile uint32_t CH41_TASK_ID;  ///< Offset: 0x164 - Channel41 task id register
        volatile uint32_t CH42_EVT_ID;  ///< Offset: 0x168 - Channel42 event id register
        volatile uint32_t CH42_TASK_ID;  ///< Offset: 0x16C - Channel42 task id register
        volatile uint32_t CH43_EVT_ID;  ///< Offset: 0x170 - Channel43 event id register
        volatile uint32_t CH43_TASK_ID;  ///< Offset: 0x174 - Channel43 task id register
        volatile uint32_t CH44_EVT_ID;  ///< Offset: 0x178 - Channel44 event id register
        volatile uint32_t CH44_TASK_ID;  ///< Offset: 0x17C - Channel44 task id register
        volatile uint32_t CH45_EVT_ID;  ///< Offset: 0x180 - Channel45 event id register
        volatile uint32_t CH45_TASK_ID;  ///< Offset: 0x184 - Channel45 task id register
        volatile uint32_t CH46_EVT_ID;  ///< Offset: 0x188 - Channel46 event id register
        volatile uint32_t CH46_TASK_ID;  ///< Offset: 0x18C - Channel46 task id register
        volatile uint32_t CH47_EVT_ID;  ///< Offset: 0x190 - Channel47 event id register
        volatile uint32_t CH47_TASK_ID;  ///< Offset: 0x194 - Channel47 task id register
        volatile uint32_t CH48_EVT_ID;  ///< Offset: 0x198 - Channel48 event id register
        volatile uint32_t CH48_TASK_ID;  ///< Offset: 0x19C - Channel48 task id register
        volatile uint32_t CH49_EVT_ID;  ///< Offset: 0x1A0 - Channel49 event id register
        volatile uint32_t CH49_TASK_ID;  ///< Offset: 0x1A4 - Channel49 task id register
        volatile uint32_t EVT_ST0;  ///< Offset: 0x1A8 - Events trigger status register
        volatile uint32_t EVT_ST0_CLR;  ///< Offset: 0x1AC - Events trigger status clear register
        volatile uint32_t EVT_ST1;  ///< Offset: 0x1B0 - Events trigger status register
        volatile uint32_t EVT_ST1_CLR;  ///< Offset: 0x1B4 - Events trigger status clear register
        volatile uint32_t EVT_ST2;  ///< Offset: 0x1B8 - Events trigger status register
        volatile uint32_t EVT_ST2_CLR;  ///< Offset: 0x1BC - Events trigger status clear register
        volatile uint32_t EVT_ST3;  ///< Offset: 0x1C0 - Events trigger status register
        volatile uint32_t EVT_ST3_CLR;  ///< Offset: 0x1C4 - Events trigger status clear register
        volatile uint32_t EVT_ST4;  ///< Offset: 0x1C8 - Events trigger status register
        volatile uint32_t EVT_ST4_CLR;  ///< Offset: 0x1CC - Events trigger status clear register
        volatile uint32_t EVT_ST5;  ///< Offset: 0x1D0 - Events trigger status register
        volatile uint32_t EVT_ST5_CLR;  ///< Offset: 0x1D4 - Events trigger status clear register
        volatile uint32_t EVT_ST6;  ///< Offset: 0x1D8 - Events trigger status register
        volatile uint32_t EVT_ST6_CLR;  ///< Offset: 0x1DC - Events trigger status clear register
        volatile uint32_t EVT_ST7;  ///< Offset: 0x1E0 - Events trigger status register
        volatile uint32_t EVT_ST7_CLR;  ///< Offset: 0x1E4 - Events trigger status clear register
        volatile uint32_t TASK_ST0;  ///< Offset: 0x1E8 - Tasks trigger status register
        volatile uint32_t TASK_ST0_CLR;  ///< Offset: 0x1EC - Tasks trigger status clear register
        volatile uint32_t TASK_ST1;  ///< Offset: 0x1F0 - Tasks trigger status register
        volatile uint32_t TASK_ST1_CLR;  ///< Offset: 0x1F4 - Tasks trigger status clear register
        volatile uint32_t TASK_ST2;  ///< Offset: 0x1F8 - Tasks trigger status register
        volatile uint32_t TASK_ST2_CLR;  ///< Offset: 0x1FC - Tasks trigger status clear register
        volatile uint32_t TASK_ST3;  ///< Offset: 0x200 - Tasks trigger status register
        volatile uint32_t TASK_ST3_CLR;  ///< Offset: 0x204 - Tasks trigger status clear register
        volatile uint32_t TASK_ST4;  ///< Offset: 0x208 - Tasks trigger status register
        volatile uint32_t TASK_ST4_CLR;  ///< Offset: 0x20C - Tasks trigger status clear register
        volatile uint32_t TASK_ST5;  ///< Offset: 0x210 - Tasks trigger status register
        volatile uint32_t TASK_ST5_CLR;  ///< Offset: 0x214 - Tasks trigger status clear register
        volatile uint32_t TASK_ST6;  ///< Offset: 0x218 - Tasks trigger status register
        volatile uint32_t TASK_ST6_CLR;  ///< Offset: 0x21C - Tasks trigger status clear register
        volatile uint32_t CLK_EN;  ///< Offset: 0x220 - ETM clock enable register
        volatile uint32_t DATE;  ///< Offset: 0x224 - ETM date register
    };

    /// Peripheral instances
    inline Registers* SOC_ETM = reinterpret_cast<Registers*>(SOC_ETM_BASE);

    // Bit definitions
    /// CH_ENA_AD0 Register bits
    namespace ch_ena_ad0_bits {
        constexpr uint32_t CH_ENA0 = (1U << 0);  ///< Represents ch0 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA1 = (1U << 1);  ///< Represents ch1 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA2 = (1U << 2);  ///< Represents ch2 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA3 = (1U << 3);  ///< Represents ch3 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA4 = (1U << 4);  ///< Represents ch4 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA5 = (1U << 5);  ///< Represents ch5 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA6 = (1U << 6);  ///< Represents ch6 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA7 = (1U << 7);  ///< Represents ch7 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA8 = (1U << 8);  ///< Represents ch8 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA9 = (1U << 9);  ///< Represents ch9 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA10 = (1U << 10);  ///< Represents ch10 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA11 = (1U << 11);  ///< Represents ch11 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA12 = (1U << 12);  ///< Represents ch12 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA13 = (1U << 13);  ///< Represents ch13 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA14 = (1U << 14);  ///< Represents ch14 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA15 = (1U << 15);  ///< Represents ch15 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA16 = (1U << 16);  ///< Represents ch16 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA17 = (1U << 17);  ///< Represents ch17 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA18 = (1U << 18);  ///< Represents ch18 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA19 = (1U << 19);  ///< Represents ch19 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA20 = (1U << 20);  ///< Represents ch20 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA21 = (1U << 21);  ///< Represents ch21 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA22 = (1U << 22);  ///< Represents ch22 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA23 = (1U << 23);  ///< Represents ch23 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA24 = (1U << 24);  ///< Represents ch24 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA25 = (1U << 25);  ///< Represents ch25 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA26 = (1U << 26);  ///< Represents ch26 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA27 = (1U << 27);  ///< Represents ch27 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA28 = (1U << 28);  ///< Represents ch28 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA29 = (1U << 29);  ///< Represents ch29 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA30 = (1U << 30);  ///< Represents ch30 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA31 = (1U << 31);  ///< Represents ch31 enable status.\\0: Disable\\1: Enable
    }

    /// CH_ENA_AD0_SET Register bits
    namespace ch_ena_ad0_set_bits {
        constexpr uint32_t CH_SET0 = (1U << 0);  ///< Configures whether or not to enable ch0.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET1 = (1U << 1);  ///< Configures whether or not to enable ch1.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET2 = (1U << 2);  ///< Configures whether or not to enable ch2.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET3 = (1U << 3);  ///< Configures whether or not to enable ch3.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET4 = (1U << 4);  ///< Configures whether or not to enable ch4.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET5 = (1U << 5);  ///< Configures whether or not to enable ch5.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET6 = (1U << 6);  ///< Configures whether or not to enable ch6.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET7 = (1U << 7);  ///< Configures whether or not to enable ch7.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET8 = (1U << 8);  ///< Configures whether or not to enable ch8.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET9 = (1U << 9);  ///< Configures whether or not to enable ch9.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET10 = (1U << 10);  ///< Configures whether or not to enable ch10.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET11 = (1U << 11);  ///< Configures whether or not to enable ch11.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET12 = (1U << 12);  ///< Configures whether or not to enable ch12.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET13 = (1U << 13);  ///< Configures whether or not to enable ch13.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET14 = (1U << 14);  ///< Configures whether or not to enable ch14.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET15 = (1U << 15);  ///< Configures whether or not to enable ch15.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET16 = (1U << 16);  ///< Configures whether or not to enable ch16.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET17 = (1U << 17);  ///< Configures whether or not to enable ch17.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET18 = (1U << 18);  ///< Configures whether or not to enable ch18.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET19 = (1U << 19);  ///< Configures whether or not to enable ch19.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET20 = (1U << 20);  ///< Configures whether or not to enable ch20.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET21 = (1U << 21);  ///< Configures whether or not to enable ch21.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET22 = (1U << 22);  ///< Configures whether or not to enable ch22.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET23 = (1U << 23);  ///< Configures whether or not to enable ch23.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET24 = (1U << 24);  ///< Configures whether or not to enable ch24.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET25 = (1U << 25);  ///< Configures whether or not to enable ch25.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET26 = (1U << 26);  ///< Configures whether or not to enable ch26.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET27 = (1U << 27);  ///< Configures whether or not to enable ch27.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET28 = (1U << 28);  ///< Configures whether or not to enable ch28.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET29 = (1U << 29);  ///< Configures whether or not to enable ch29.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET30 = (1U << 30);  ///< Configures whether or not to enable ch30.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET31 = (1U << 31);  ///< Configures whether or not to enable ch31.\\0: Invalid, No effect\\1: Enable
    }

    /// CH_ENA_AD0_CLR Register bits
    namespace ch_ena_ad0_clr_bits {
        constexpr uint32_t CH_CLR0 = (1U << 0);  ///< Configures whether or not to clear ch0 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR1 = (1U << 1);  ///< Configures whether or not to clear ch1 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR2 = (1U << 2);  ///< Configures whether or not to clear ch2 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR3 = (1U << 3);  ///< Configures whether or not to clear ch3 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR4 = (1U << 4);  ///< Configures whether or not to clear ch4 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR5 = (1U << 5);  ///< Configures whether or not to clear ch5 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR6 = (1U << 6);  ///< Configures whether or not to clear ch6 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR7 = (1U << 7);  ///< Configures whether or not to clear ch7 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR8 = (1U << 8);  ///< Configures whether or not to clear ch8 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR9 = (1U << 9);  ///< Configures whether or not to clear ch9 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR10 = (1U << 10);  ///< Configures whether or not to clear ch10 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR11 = (1U << 11);  ///< Configures whether or not to clear ch11 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR12 = (1U << 12);  ///< Configures whether or not to clear ch12 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR13 = (1U << 13);  ///< Configures whether or not to clear ch13 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR14 = (1U << 14);  ///< Configures whether or not to clear ch14 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR15 = (1U << 15);  ///< Configures whether or not to clear ch15 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR16 = (1U << 16);  ///< Configures whether or not to clear ch16 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR17 = (1U << 17);  ///< Configures whether or not to clear ch17 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR18 = (1U << 18);  ///< Configures whether or not to clear ch18 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR19 = (1U << 19);  ///< Configures whether or not to clear ch19 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR20 = (1U << 20);  ///< Configures whether or not to clear ch20 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR21 = (1U << 21);  ///< Configures whether or not to clear ch21 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR22 = (1U << 22);  ///< Configures whether or not to clear ch22 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR23 = (1U << 23);  ///< Configures whether or not to clear ch23 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR24 = (1U << 24);  ///< Configures whether or not to clear ch24 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR25 = (1U << 25);  ///< Configures whether or not to clear ch25 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR26 = (1U << 26);  ///< Configures whether or not to clear ch26 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR27 = (1U << 27);  ///< Configures whether or not to clear ch27 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR28 = (1U << 28);  ///< Configures whether or not to clear ch28 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR29 = (1U << 29);  ///< Configures whether or not to clear ch29 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR30 = (1U << 30);  ///< Configures whether or not to clear ch30 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR31 = (1U << 31);  ///< Configures whether or not to clear ch31 enable.\\0: Invalid, No effect\\1: Clear
    }

    /// CH_ENA_AD1 Register bits
    namespace ch_ena_ad1_bits {
        constexpr uint32_t CH_ENA32 = (1U << 0);  ///< Represents ch32 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA33 = (1U << 1);  ///< Represents ch33 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA34 = (1U << 2);  ///< Represents ch34 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA35 = (1U << 3);  ///< Represents ch35 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA36 = (1U << 4);  ///< Represents ch36 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA37 = (1U << 5);  ///< Represents ch37 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA38 = (1U << 6);  ///< Represents ch38 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA39 = (1U << 7);  ///< Represents ch39 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA40 = (1U << 8);  ///< Represents ch40 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA41 = (1U << 9);  ///< Represents ch41 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA42 = (1U << 10);  ///< Represents ch42 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA43 = (1U << 11);  ///< Represents ch43 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA44 = (1U << 12);  ///< Represents ch44 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA45 = (1U << 13);  ///< Represents ch45 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA46 = (1U << 14);  ///< Represents ch46 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA47 = (1U << 15);  ///< Represents ch47 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA48 = (1U << 16);  ///< Represents ch48 enable status.\\0: Disable\\1: Enable
        constexpr uint32_t CH_ENA49 = (1U << 17);  ///< Represents ch49 enable status.\\0: Disable\\1: Enable
    }

    /// CH_ENA_AD1_SET Register bits
    namespace ch_ena_ad1_set_bits {
        constexpr uint32_t CH_SET32 = (1U << 0);  ///< Configures whether or not to enable ch32.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET33 = (1U << 1);  ///< Configures whether or not to enable ch33.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET34 = (1U << 2);  ///< Configures whether or not to enable ch34.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET35 = (1U << 3);  ///< Configures whether or not to enable ch35.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET36 = (1U << 4);  ///< Configures whether or not to enable ch36.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET37 = (1U << 5);  ///< Configures whether or not to enable ch37.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET38 = (1U << 6);  ///< Configures whether or not to enable ch38.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET39 = (1U << 7);  ///< Configures whether or not to enable ch39.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET40 = (1U << 8);  ///< Configures whether or not to enable ch40.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET41 = (1U << 9);  ///< Configures whether or not to enable ch41.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET42 = (1U << 10);  ///< Configures whether or not to enable ch42.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET43 = (1U << 11);  ///< Configures whether or not to enable ch43.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET44 = (1U << 12);  ///< Configures whether or not to enable ch44.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET45 = (1U << 13);  ///< Configures whether or not to enable ch45.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET46 = (1U << 14);  ///< Configures whether or not to enable ch46.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET47 = (1U << 15);  ///< Configures whether or not to enable ch47.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET48 = (1U << 16);  ///< Configures whether or not to enable ch48.\\0: Invalid, No effect\\1: Enable
        constexpr uint32_t CH_SET49 = (1U << 17);  ///< Configures whether or not to enable ch49.\\0: Invalid, No effect\\1: Enable
    }

    /// CH_ENA_AD1_CLR Register bits
    namespace ch_ena_ad1_clr_bits {
        constexpr uint32_t CH_CLR32 = (1U << 0);  ///< Configures whether or not to clear ch32 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR33 = (1U << 1);  ///< Configures whether or not to clear ch33 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR34 = (1U << 2);  ///< Configures whether or not to clear ch34 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR35 = (1U << 3);  ///< Configures whether or not to clear ch35 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR36 = (1U << 4);  ///< Configures whether or not to clear ch36 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR37 = (1U << 5);  ///< Configures whether or not to clear ch37 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR38 = (1U << 6);  ///< Configures whether or not to clear ch38 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR39 = (1U << 7);  ///< Configures whether or not to clear ch39 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR40 = (1U << 8);  ///< Configures whether or not to clear ch40 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR41 = (1U << 9);  ///< Configures whether or not to clear ch41 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR42 = (1U << 10);  ///< Configures whether or not to clear ch42 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR43 = (1U << 11);  ///< Configures whether or not to clear ch43 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR44 = (1U << 12);  ///< Configures whether or not to clear ch44 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR45 = (1U << 13);  ///< Configures whether or not to clear ch45 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR46 = (1U << 14);  ///< Configures whether or not to clear ch46 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR47 = (1U << 15);  ///< Configures whether or not to clear ch47 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR48 = (1U << 16);  ///< Configures whether or not to clear ch48 enable.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t CH_CLR49 = (1U << 17);  ///< Configures whether or not to clear ch49 enable.\\0: Invalid, No effect\\1: Clear
    }

    /// CH0_EVT_ID Register bits
    namespace ch0_evt_id_bits {
        constexpr uint32_t CH0_EVT_ID = (8 << 0);  ///< Configures ch0_evt_id
    }

    /// CH0_TASK_ID Register bits
    namespace ch0_task_id_bits {
        constexpr uint32_t CH0_TASK_ID = (8 << 0);  ///< Configures ch0_task_id
    }

    /// CH1_EVT_ID Register bits
    namespace ch1_evt_id_bits {
        constexpr uint32_t CH1_EVT_ID = (8 << 0);  ///< Configures ch1_evt_id
    }

    /// CH1_TASK_ID Register bits
    namespace ch1_task_id_bits {
        constexpr uint32_t CH1_TASK_ID = (8 << 0);  ///< Configures ch1_task_id
    }

    /// CH2_EVT_ID Register bits
    namespace ch2_evt_id_bits {
        constexpr uint32_t CH2_EVT_ID = (8 << 0);  ///< Configures ch2_evt_id
    }

    /// CH2_TASK_ID Register bits
    namespace ch2_task_id_bits {
        constexpr uint32_t CH2_TASK_ID = (8 << 0);  ///< Configures ch2_task_id
    }

    /// CH3_EVT_ID Register bits
    namespace ch3_evt_id_bits {
        constexpr uint32_t CH3_EVT_ID = (8 << 0);  ///< Configures ch3_evt_id
    }

    /// CH3_TASK_ID Register bits
    namespace ch3_task_id_bits {
        constexpr uint32_t CH3_TASK_ID = (8 << 0);  ///< Configures ch3_task_id
    }

    /// CH4_EVT_ID Register bits
    namespace ch4_evt_id_bits {
        constexpr uint32_t CH4_EVT_ID = (8 << 0);  ///< Configures ch4_evt_id
    }

    /// CH4_TASK_ID Register bits
    namespace ch4_task_id_bits {
        constexpr uint32_t CH4_TASK_ID = (8 << 0);  ///< Configures ch4_task_id
    }

    /// CH5_EVT_ID Register bits
    namespace ch5_evt_id_bits {
        constexpr uint32_t CH5_EVT_ID = (8 << 0);  ///< Configures ch5_evt_id
    }

    /// CH5_TASK_ID Register bits
    namespace ch5_task_id_bits {
        constexpr uint32_t CH5_TASK_ID = (8 << 0);  ///< Configures ch5_task_id
    }

    /// CH6_EVT_ID Register bits
    namespace ch6_evt_id_bits {
        constexpr uint32_t CH6_EVT_ID = (8 << 0);  ///< Configures ch6_evt_id
    }

    /// CH6_TASK_ID Register bits
    namespace ch6_task_id_bits {
        constexpr uint32_t CH6_TASK_ID = (8 << 0);  ///< Configures ch6_task_id
    }

    /// CH7_EVT_ID Register bits
    namespace ch7_evt_id_bits {
        constexpr uint32_t CH7_EVT_ID = (8 << 0);  ///< Configures ch7_evt_id
    }

    /// CH7_TASK_ID Register bits
    namespace ch7_task_id_bits {
        constexpr uint32_t CH7_TASK_ID = (8 << 0);  ///< Configures ch7_task_id
    }

    /// CH8_EVT_ID Register bits
    namespace ch8_evt_id_bits {
        constexpr uint32_t CH8_EVT_ID = (8 << 0);  ///< Configures ch8_evt_id
    }

    /// CH8_TASK_ID Register bits
    namespace ch8_task_id_bits {
        constexpr uint32_t CH8_TASK_ID = (8 << 0);  ///< Configures ch8_task_id
    }

    /// CH9_EVT_ID Register bits
    namespace ch9_evt_id_bits {
        constexpr uint32_t CH9_EVT_ID = (8 << 0);  ///< Configures ch9_evt_id
    }

    /// CH9_TASK_ID Register bits
    namespace ch9_task_id_bits {
        constexpr uint32_t CH9_TASK_ID = (8 << 0);  ///< Configures ch9_task_id
    }

    /// CH10_EVT_ID Register bits
    namespace ch10_evt_id_bits {
        constexpr uint32_t CH10_EVT_ID = (8 << 0);  ///< Configures ch10_evt_id
    }

    /// CH10_TASK_ID Register bits
    namespace ch10_task_id_bits {
        constexpr uint32_t CH10_TASK_ID = (8 << 0);  ///< Configures ch10_task_id
    }

    /// CH11_EVT_ID Register bits
    namespace ch11_evt_id_bits {
        constexpr uint32_t CH11_EVT_ID = (8 << 0);  ///< Configures ch11_evt_id
    }

    /// CH11_TASK_ID Register bits
    namespace ch11_task_id_bits {
        constexpr uint32_t CH11_TASK_ID = (8 << 0);  ///< Configures ch11_task_id
    }

    /// CH12_EVT_ID Register bits
    namespace ch12_evt_id_bits {
        constexpr uint32_t CH12_EVT_ID = (8 << 0);  ///< Configures ch12_evt_id
    }

    /// CH12_TASK_ID Register bits
    namespace ch12_task_id_bits {
        constexpr uint32_t CH12_TASK_ID = (8 << 0);  ///< Configures ch12_task_id
    }

    /// CH13_EVT_ID Register bits
    namespace ch13_evt_id_bits {
        constexpr uint32_t CH13_EVT_ID = (8 << 0);  ///< Configures ch13_evt_id
    }

    /// CH13_TASK_ID Register bits
    namespace ch13_task_id_bits {
        constexpr uint32_t CH13_TASK_ID = (8 << 0);  ///< Configures ch13_task_id
    }

    /// CH14_EVT_ID Register bits
    namespace ch14_evt_id_bits {
        constexpr uint32_t CH14_EVT_ID = (8 << 0);  ///< Configures ch14_evt_id
    }

    /// CH14_TASK_ID Register bits
    namespace ch14_task_id_bits {
        constexpr uint32_t CH14_TASK_ID = (8 << 0);  ///< Configures ch14_task_id
    }

    /// CH15_EVT_ID Register bits
    namespace ch15_evt_id_bits {
        constexpr uint32_t CH15_EVT_ID = (8 << 0);  ///< Configures ch15_evt_id
    }

    /// CH15_TASK_ID Register bits
    namespace ch15_task_id_bits {
        constexpr uint32_t CH15_TASK_ID = (8 << 0);  ///< Configures ch15_task_id
    }

    /// CH16_EVT_ID Register bits
    namespace ch16_evt_id_bits {
        constexpr uint32_t CH16_EVT_ID = (8 << 0);  ///< Configures ch16_evt_id
    }

    /// CH16_TASK_ID Register bits
    namespace ch16_task_id_bits {
        constexpr uint32_t CH16_TASK_ID = (8 << 0);  ///< Configures ch16_task_id
    }

    /// CH17_EVT_ID Register bits
    namespace ch17_evt_id_bits {
        constexpr uint32_t CH17_EVT_ID = (8 << 0);  ///< Configures ch17_evt_id
    }

    /// CH17_TASK_ID Register bits
    namespace ch17_task_id_bits {
        constexpr uint32_t CH17_TASK_ID = (8 << 0);  ///< Configures ch17_task_id
    }

    /// CH18_EVT_ID Register bits
    namespace ch18_evt_id_bits {
        constexpr uint32_t CH18_EVT_ID = (8 << 0);  ///< Configures ch18_evt_id
    }

    /// CH18_TASK_ID Register bits
    namespace ch18_task_id_bits {
        constexpr uint32_t CH18_TASK_ID = (8 << 0);  ///< Configures ch18_task_id
    }

    /// CH19_EVT_ID Register bits
    namespace ch19_evt_id_bits {
        constexpr uint32_t CH19_EVT_ID = (8 << 0);  ///< Configures ch19_evt_id
    }

    /// CH19_TASK_ID Register bits
    namespace ch19_task_id_bits {
        constexpr uint32_t CH19_TASK_ID = (8 << 0);  ///< Configures ch19_task_id
    }

    /// CH20_EVT_ID Register bits
    namespace ch20_evt_id_bits {
        constexpr uint32_t CH20_EVT_ID = (8 << 0);  ///< Configures ch20_evt_id
    }

    /// CH20_TASK_ID Register bits
    namespace ch20_task_id_bits {
        constexpr uint32_t CH20_TASK_ID = (8 << 0);  ///< Configures ch20_task_id
    }

    /// CH21_EVT_ID Register bits
    namespace ch21_evt_id_bits {
        constexpr uint32_t CH21_EVT_ID = (8 << 0);  ///< Configures ch21_evt_id
    }

    /// CH21_TASK_ID Register bits
    namespace ch21_task_id_bits {
        constexpr uint32_t CH21_TASK_ID = (8 << 0);  ///< Configures ch21_task_id
    }

    /// CH22_EVT_ID Register bits
    namespace ch22_evt_id_bits {
        constexpr uint32_t CH22_EVT_ID = (8 << 0);  ///< Configures ch22_evt_id
    }

    /// CH22_TASK_ID Register bits
    namespace ch22_task_id_bits {
        constexpr uint32_t CH22_TASK_ID = (8 << 0);  ///< Configures ch22_task_id
    }

    /// CH23_EVT_ID Register bits
    namespace ch23_evt_id_bits {
        constexpr uint32_t CH23_EVT_ID = (8 << 0);  ///< Configures ch23_evt_id
    }

    /// CH23_TASK_ID Register bits
    namespace ch23_task_id_bits {
        constexpr uint32_t CH23_TASK_ID = (8 << 0);  ///< Configures ch23_task_id
    }

    /// CH24_EVT_ID Register bits
    namespace ch24_evt_id_bits {
        constexpr uint32_t CH24_EVT_ID = (8 << 0);  ///< Configures ch24_evt_id
    }

    /// CH24_TASK_ID Register bits
    namespace ch24_task_id_bits {
        constexpr uint32_t CH24_TASK_ID = (8 << 0);  ///< Configures ch24_task_id
    }

    /// CH25_EVT_ID Register bits
    namespace ch25_evt_id_bits {
        constexpr uint32_t CH25_EVT_ID = (8 << 0);  ///< Configures ch25_evt_id
    }

    /// CH25_TASK_ID Register bits
    namespace ch25_task_id_bits {
        constexpr uint32_t CH25_TASK_ID = (8 << 0);  ///< Configures ch25_task_id
    }

    /// CH26_EVT_ID Register bits
    namespace ch26_evt_id_bits {
        constexpr uint32_t CH26_EVT_ID = (8 << 0);  ///< Configures ch26_evt_id
    }

    /// CH26_TASK_ID Register bits
    namespace ch26_task_id_bits {
        constexpr uint32_t CH26_TASK_ID = (8 << 0);  ///< Configures ch26_task_id
    }

    /// CH27_EVT_ID Register bits
    namespace ch27_evt_id_bits {
        constexpr uint32_t CH27_EVT_ID = (8 << 0);  ///< Configures ch27_evt_id
    }

    /// CH27_TASK_ID Register bits
    namespace ch27_task_id_bits {
        constexpr uint32_t CH27_TASK_ID = (8 << 0);  ///< Configures ch27_task_id
    }

    /// CH28_EVT_ID Register bits
    namespace ch28_evt_id_bits {
        constexpr uint32_t CH28_EVT_ID = (8 << 0);  ///< Configures ch28_evt_id
    }

    /// CH28_TASK_ID Register bits
    namespace ch28_task_id_bits {
        constexpr uint32_t CH28_TASK_ID = (8 << 0);  ///< Configures ch28_task_id
    }

    /// CH29_EVT_ID Register bits
    namespace ch29_evt_id_bits {
        constexpr uint32_t CH29_EVT_ID = (8 << 0);  ///< Configures ch29_evt_id
    }

    /// CH29_TASK_ID Register bits
    namespace ch29_task_id_bits {
        constexpr uint32_t CH29_TASK_ID = (8 << 0);  ///< Configures ch29_task_id
    }

    /// CH30_EVT_ID Register bits
    namespace ch30_evt_id_bits {
        constexpr uint32_t CH30_EVT_ID = (8 << 0);  ///< Configures ch30_evt_id
    }

    /// CH30_TASK_ID Register bits
    namespace ch30_task_id_bits {
        constexpr uint32_t CH30_TASK_ID = (8 << 0);  ///< Configures ch30_task_id
    }

    /// CH31_EVT_ID Register bits
    namespace ch31_evt_id_bits {
        constexpr uint32_t CH31_EVT_ID = (8 << 0);  ///< Configures ch31_evt_id
    }

    /// CH31_TASK_ID Register bits
    namespace ch31_task_id_bits {
        constexpr uint32_t CH31_TASK_ID = (8 << 0);  ///< Configures ch31_task_id
    }

    /// CH32_EVT_ID Register bits
    namespace ch32_evt_id_bits {
        constexpr uint32_t CH32_EVT_ID = (8 << 0);  ///< Configures ch32_evt_id
    }

    /// CH32_TASK_ID Register bits
    namespace ch32_task_id_bits {
        constexpr uint32_t CH32_TASK_ID = (8 << 0);  ///< Configures ch32_task_id
    }

    /// CH33_EVT_ID Register bits
    namespace ch33_evt_id_bits {
        constexpr uint32_t CH33_EVT_ID = (8 << 0);  ///< Configures ch33_evt_id
    }

    /// CH33_TASK_ID Register bits
    namespace ch33_task_id_bits {
        constexpr uint32_t CH33_TASK_ID = (8 << 0);  ///< Configures ch33_task_id
    }

    /// CH34_EVT_ID Register bits
    namespace ch34_evt_id_bits {
        constexpr uint32_t CH34_EVT_ID = (8 << 0);  ///< Configures ch34_evt_id
    }

    /// CH34_TASK_ID Register bits
    namespace ch34_task_id_bits {
        constexpr uint32_t CH34_TASK_ID = (8 << 0);  ///< Configures ch34_task_id
    }

    /// CH35_EVT_ID Register bits
    namespace ch35_evt_id_bits {
        constexpr uint32_t CH35_EVT_ID = (8 << 0);  ///< Configures ch35_evt_id
    }

    /// CH35_TASK_ID Register bits
    namespace ch35_task_id_bits {
        constexpr uint32_t CH35_TASK_ID = (8 << 0);  ///< Configures ch35_task_id
    }

    /// CH36_EVT_ID Register bits
    namespace ch36_evt_id_bits {
        constexpr uint32_t CH36_EVT_ID = (8 << 0);  ///< Configures ch36_evt_id
    }

    /// CH36_TASK_ID Register bits
    namespace ch36_task_id_bits {
        constexpr uint32_t CH36_TASK_ID = (8 << 0);  ///< Configures ch36_task_id
    }

    /// CH37_EVT_ID Register bits
    namespace ch37_evt_id_bits {
        constexpr uint32_t CH37_EVT_ID = (8 << 0);  ///< Configures ch37_evt_id
    }

    /// CH37_TASK_ID Register bits
    namespace ch37_task_id_bits {
        constexpr uint32_t CH37_TASK_ID = (8 << 0);  ///< Configures ch37_task_id
    }

    /// CH38_EVT_ID Register bits
    namespace ch38_evt_id_bits {
        constexpr uint32_t CH38_EVT_ID = (8 << 0);  ///< Configures ch38_evt_id
    }

    /// CH38_TASK_ID Register bits
    namespace ch38_task_id_bits {
        constexpr uint32_t CH38_TASK_ID = (8 << 0);  ///< Configures ch38_task_id
    }

    /// CH39_EVT_ID Register bits
    namespace ch39_evt_id_bits {
        constexpr uint32_t CH39_EVT_ID = (8 << 0);  ///< Configures ch39_evt_id
    }

    /// CH39_TASK_ID Register bits
    namespace ch39_task_id_bits {
        constexpr uint32_t CH39_TASK_ID = (8 << 0);  ///< Configures ch39_task_id
    }

    /// CH40_EVT_ID Register bits
    namespace ch40_evt_id_bits {
        constexpr uint32_t CH40_EVT_ID = (8 << 0);  ///< Configures ch40_evt_id
    }

    /// CH40_TASK_ID Register bits
    namespace ch40_task_id_bits {
        constexpr uint32_t CH40_TASK_ID = (8 << 0);  ///< Configures ch40_task_id
    }

    /// CH41_EVT_ID Register bits
    namespace ch41_evt_id_bits {
        constexpr uint32_t CH41_EVT_ID = (8 << 0);  ///< Configures ch41_evt_id
    }

    /// CH41_TASK_ID Register bits
    namespace ch41_task_id_bits {
        constexpr uint32_t CH41_TASK_ID = (8 << 0);  ///< Configures ch41_task_id
    }

    /// CH42_EVT_ID Register bits
    namespace ch42_evt_id_bits {
        constexpr uint32_t CH42_EVT_ID = (8 << 0);  ///< Configures ch42_evt_id
    }

    /// CH42_TASK_ID Register bits
    namespace ch42_task_id_bits {
        constexpr uint32_t CH42_TASK_ID = (8 << 0);  ///< Configures ch42_task_id
    }

    /// CH43_EVT_ID Register bits
    namespace ch43_evt_id_bits {
        constexpr uint32_t CH43_EVT_ID = (8 << 0);  ///< Configures ch43_evt_id
    }

    /// CH43_TASK_ID Register bits
    namespace ch43_task_id_bits {
        constexpr uint32_t CH43_TASK_ID = (8 << 0);  ///< Configures ch43_task_id
    }

    /// CH44_EVT_ID Register bits
    namespace ch44_evt_id_bits {
        constexpr uint32_t CH44_EVT_ID = (8 << 0);  ///< Configures ch44_evt_id
    }

    /// CH44_TASK_ID Register bits
    namespace ch44_task_id_bits {
        constexpr uint32_t CH44_TASK_ID = (8 << 0);  ///< Configures ch44_task_id
    }

    /// CH45_EVT_ID Register bits
    namespace ch45_evt_id_bits {
        constexpr uint32_t CH45_EVT_ID = (8 << 0);  ///< Configures ch45_evt_id
    }

    /// CH45_TASK_ID Register bits
    namespace ch45_task_id_bits {
        constexpr uint32_t CH45_TASK_ID = (8 << 0);  ///< Configures ch45_task_id
    }

    /// CH46_EVT_ID Register bits
    namespace ch46_evt_id_bits {
        constexpr uint32_t CH46_EVT_ID = (8 << 0);  ///< Configures ch46_evt_id
    }

    /// CH46_TASK_ID Register bits
    namespace ch46_task_id_bits {
        constexpr uint32_t CH46_TASK_ID = (8 << 0);  ///< Configures ch46_task_id
    }

    /// CH47_EVT_ID Register bits
    namespace ch47_evt_id_bits {
        constexpr uint32_t CH47_EVT_ID = (8 << 0);  ///< Configures ch47_evt_id
    }

    /// CH47_TASK_ID Register bits
    namespace ch47_task_id_bits {
        constexpr uint32_t CH47_TASK_ID = (8 << 0);  ///< Configures ch47_task_id
    }

    /// CH48_EVT_ID Register bits
    namespace ch48_evt_id_bits {
        constexpr uint32_t CH48_EVT_ID = (8 << 0);  ///< Configures ch48_evt_id
    }

    /// CH48_TASK_ID Register bits
    namespace ch48_task_id_bits {
        constexpr uint32_t CH48_TASK_ID = (8 << 0);  ///< Configures ch48_task_id
    }

    /// CH49_EVT_ID Register bits
    namespace ch49_evt_id_bits {
        constexpr uint32_t CH49_EVT_ID = (8 << 0);  ///< Configures ch49_evt_id
    }

    /// CH49_TASK_ID Register bits
    namespace ch49_task_id_bits {
        constexpr uint32_t CH49_TASK_ID = (8 << 0);  ///< Configures ch49_task_id
    }

    /// EVT_ST0 Register bits
    namespace evt_st0_bits {
        constexpr uint32_t GPIO_EVT_CH0_RISE_EDGE_ST = (1U << 0);  ///< Represents GPIO_evt_ch0_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH1_RISE_EDGE_ST = (1U << 1);  ///< Represents GPIO_evt_ch1_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH2_RISE_EDGE_ST = (1U << 2);  ///< Represents GPIO_evt_ch2_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH3_RISE_EDGE_ST = (1U << 3);  ///< Represents GPIO_evt_ch3_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH4_RISE_EDGE_ST = (1U << 4);  ///< Represents GPIO_evt_ch4_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH5_RISE_EDGE_ST = (1U << 5);  ///< Represents GPIO_evt_ch5_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH6_RISE_EDGE_ST = (1U << 6);  ///< Represents GPIO_evt_ch6_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH7_RISE_EDGE_ST = (1U << 7);  ///< Represents GPIO_evt_ch7_rise_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH0_FALL_EDGE_ST = (1U << 8);  ///< Represents GPIO_evt_ch0_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH1_FALL_EDGE_ST = (1U << 9);  ///< Represents GPIO_evt_ch1_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH2_FALL_EDGE_ST = (1U << 10);  ///< Represents GPIO_evt_ch2_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH3_FALL_EDGE_ST = (1U << 11);  ///< Represents GPIO_evt_ch3_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH4_FALL_EDGE_ST = (1U << 12);  ///< Represents GPIO_evt_ch4_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH5_FALL_EDGE_ST = (1U << 13);  ///< Represents GPIO_evt_ch5_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH6_FALL_EDGE_ST = (1U << 14);  ///< Represents GPIO_evt_ch6_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH7_FALL_EDGE_ST = (1U << 15);  ///< Represents GPIO_evt_ch7_fall_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH0_ANY_EDGE_ST = (1U << 16);  ///< Represents GPIO_evt_ch0_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH1_ANY_EDGE_ST = (1U << 17);  ///< Represents GPIO_evt_ch1_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH2_ANY_EDGE_ST = (1U << 18);  ///< Represents GPIO_evt_ch2_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH3_ANY_EDGE_ST = (1U << 19);  ///< Represents GPIO_evt_ch3_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH4_ANY_EDGE_ST = (1U << 20);  ///< Represents GPIO_evt_ch4_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH5_ANY_EDGE_ST = (1U << 21);  ///< Represents GPIO_evt_ch5_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH6_ANY_EDGE_ST = (1U << 22);  ///< Represents GPIO_evt_ch6_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_CH7_ANY_EDGE_ST = (1U << 23);  ///< Represents GPIO_evt_ch7_any_edge trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_ZERO_DET_POS0_ST = (1U << 24);  ///< Represents GPIO_evt_zero_det_pos0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_ZERO_DET_NEG0_ST = (1U << 25);  ///< Represents GPIO_evt_zero_det_neg0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_ZERO_DET_POS1_ST = (1U << 26);  ///< Represents GPIO_evt_zero_det_pos1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_EVT_ZERO_DET_NEG1_ST = (1U << 27);  ///< Represents GPIO_evt_zero_det_neg1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH0_ST = (1U << 28);  ///< Represents LEDC_evt_duty_chng_end_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH1_ST = (1U << 29);  ///< Represents LEDC_evt_duty_chng_end_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH2_ST = (1U << 30);  ///< Represents LEDC_evt_duty_chng_end_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH3_ST = (1U << 31);  ///< Represents LEDC_evt_duty_chng_end_ch3 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST0_CLR Register bits
    namespace evt_st0_clr_bits {
        constexpr uint32_t GPIO_EVT_CH0_RISE_EDGE_ST_CLR = (1U << 0);  ///< Configures whether or not to clear GPIO_evt_ch0_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH1_RISE_EDGE_ST_CLR = (1U << 1);  ///< Configures whether or not to clear GPIO_evt_ch1_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH2_RISE_EDGE_ST_CLR = (1U << 2);  ///< Configures whether or not to clear GPIO_evt_ch2_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH3_RISE_EDGE_ST_CLR = (1U << 3);  ///< Configures whether or not to clear GPIO_evt_ch3_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH4_RISE_EDGE_ST_CLR = (1U << 4);  ///< Configures whether or not to clear GPIO_evt_ch4_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH5_RISE_EDGE_ST_CLR = (1U << 5);  ///< Configures whether or not to clear GPIO_evt_ch5_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH6_RISE_EDGE_ST_CLR = (1U << 6);  ///< Configures whether or not to clear GPIO_evt_ch6_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH7_RISE_EDGE_ST_CLR = (1U << 7);  ///< Configures whether or not to clear GPIO_evt_ch7_rise_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH0_FALL_EDGE_ST_CLR = (1U << 8);  ///< Configures whether or not to clear GPIO_evt_ch0_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH1_FALL_EDGE_ST_CLR = (1U << 9);  ///< Configures whether or not to clear GPIO_evt_ch1_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH2_FALL_EDGE_ST_CLR = (1U << 10);  ///< Configures whether or not to clear GPIO_evt_ch2_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH3_FALL_EDGE_ST_CLR = (1U << 11);  ///< Configures whether or not to clear GPIO_evt_ch3_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH4_FALL_EDGE_ST_CLR = (1U << 12);  ///< Configures whether or not to clear GPIO_evt_ch4_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH5_FALL_EDGE_ST_CLR = (1U << 13);  ///< Configures whether or not to clear GPIO_evt_ch5_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH6_FALL_EDGE_ST_CLR = (1U << 14);  ///< Configures whether or not to clear GPIO_evt_ch6_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH7_FALL_EDGE_ST_CLR = (1U << 15);  ///< Configures whether or not to clear GPIO_evt_ch7_fall_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH0_ANY_EDGE_ST_CLR = (1U << 16);  ///< Configures whether or not to clear GPIO_evt_ch0_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH1_ANY_EDGE_ST_CLR = (1U << 17);  ///< Configures whether or not to clear GPIO_evt_ch1_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH2_ANY_EDGE_ST_CLR = (1U << 18);  ///< Configures whether or not to clear GPIO_evt_ch2_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH3_ANY_EDGE_ST_CLR = (1U << 19);  ///< Configures whether or not to clear GPIO_evt_ch3_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH4_ANY_EDGE_ST_CLR = (1U << 20);  ///< Configures whether or not to clear GPIO_evt_ch4_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH5_ANY_EDGE_ST_CLR = (1U << 21);  ///< Configures whether or not to clear GPIO_evt_ch5_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH6_ANY_EDGE_ST_CLR = (1U << 22);  ///< Configures whether or not to clear GPIO_evt_ch6_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_CH7_ANY_EDGE_ST_CLR = (1U << 23);  ///< Configures whether or not to clear GPIO_evt_ch7_any_edge trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_ZERO_DET_POS0_ST_CLR = (1U << 24);  ///< Configures whether or not to clear GPIO_evt_zero_det_pos0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_ZERO_DET_NEG0_ST_CLR = (1U << 25);  ///< Configures whether or not to clear GPIO_evt_zero_det_neg0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_ZERO_DET_POS1_ST_CLR = (1U << 26);  ///< Configures whether or not to clear GPIO_evt_zero_det_pos1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_EVT_ZERO_DET_NEG1_ST_CLR = (1U << 27);  ///< Configures whether or not to clear GPIO_evt_zero_det_neg1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH0_ST_CLR = (1U << 28);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH1_ST_CLR = (1U << 29);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH2_ST_CLR = (1U << 30);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH3_ST_CLR = (1U << 31);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST1 Register bits
    namespace evt_st1_bits {
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH4_ST = (1U << 0);  ///< Represents LEDC_evt_duty_chng_end_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH5_ST = (1U << 1);  ///< Represents LEDC_evt_duty_chng_end_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH6_ST = (1U << 2);  ///< Represents LEDC_evt_duty_chng_end_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH7_ST = (1U << 3);  ///< Represents LEDC_evt_duty_chng_end_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH0_ST = (1U << 4);  ///< Represents LEDC_evt_ovf_cnt_pls_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH1_ST = (1U << 5);  ///< Represents LEDC_evt_ovf_cnt_pls_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH2_ST = (1U << 6);  ///< Represents LEDC_evt_ovf_cnt_pls_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH3_ST = (1U << 7);  ///< Represents LEDC_evt_ovf_cnt_pls_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH4_ST = (1U << 8);  ///< Represents LEDC_evt_ovf_cnt_pls_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH5_ST = (1U << 9);  ///< Represents LEDC_evt_ovf_cnt_pls_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH6_ST = (1U << 10);  ///< Represents LEDC_evt_ovf_cnt_pls_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH7_ST = (1U << 11);  ///< Represents LEDC_evt_ovf_cnt_pls_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER0_ST = (1U << 12);  ///< Represents LEDC_evt_time_ovf_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER1_ST = (1U << 13);  ///< Represents LEDC_evt_time_ovf_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER2_ST = (1U << 14);  ///< Represents LEDC_evt_time_ovf_timer2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER3_ST = (1U << 15);  ///< Represents LEDC_evt_time_ovf_timer3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIMER0_CMP_ST = (1U << 16);  ///< Represents LEDC_evt_timer0_cmp trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIMER1_CMP_ST = (1U << 17);  ///< Represents LEDC_evt_timer1_cmp trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIMER2_CMP_ST = (1U << 18);  ///< Represents LEDC_evt_timer2_cmp trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_EVT_TIMER3_CMP_ST = (1U << 19);  ///< Represents LEDC_evt_timer3_cmp trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_EVT_CNT_CMP_TIMER0_ST = (1U << 20);  ///< Represents TG0_evt_cnt_cmp_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_EVT_CNT_CMP_TIMER1_ST = (1U << 21);  ///< Represents TG0_evt_cnt_cmp_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_EVT_CNT_CMP_TIMER0_ST = (1U << 22);  ///< Represents TG1_evt_cnt_cmp_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_EVT_CNT_CMP_TIMER1_ST = (1U << 23);  ///< Represents TG1_evt_cnt_cmp_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP0_ST = (1U << 24);  ///< Represents SYSTIMER_evt_cnt_cmp0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP1_ST = (1U << 25);  ///< Represents SYSTIMER_evt_cnt_cmp1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP2_ST = (1U << 26);  ///< Represents SYSTIMER_evt_cnt_cmp2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER0_STOP_ST = (1U << 27);  ///< Represents MCPWM0_evt_timer0_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER1_STOP_ST = (1U << 28);  ///< Represents MCPWM0_evt_timer1_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER2_STOP_ST = (1U << 29);  ///< Represents MCPWM0_evt_timer2_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER0_TEZ_ST = (1U << 30);  ///< Represents MCPWM0_evt_timer0_tez trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER1_TEZ_ST = (1U << 31);  ///< Represents MCPWM0_evt_timer1_tez trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST1_CLR Register bits
    namespace evt_st1_clr_bits {
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH4_ST_CLR = (1U << 0);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH5_ST_CLR = (1U << 1);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH6_ST_CLR = (1U << 2);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_DUTY_CHNG_END_CH7_ST_CLR = (1U << 3);  ///< Configures whether or not to clear LEDC_evt_duty_chng_end_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH0_ST_CLR = (1U << 4);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH2_ST_CLR = (1U << 6);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH3_ST_CLR = (1U << 7);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH4_ST_CLR = (1U << 8);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH5_ST_CLR = (1U << 9);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH6_ST_CLR = (1U << 10);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_OVF_CNT_PLS_CH7_ST_CLR = (1U << 11);  ///< Configures whether or not to clear LEDC_evt_ovf_cnt_pls_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER0_ST_CLR = (1U << 12);  ///< Configures whether or not to clear LEDC_evt_time_ovf_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER1_ST_CLR = (1U << 13);  ///< Configures whether or not to clear LEDC_evt_time_ovf_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER2_ST_CLR = (1U << 14);  ///< Configures whether or not to clear LEDC_evt_time_ovf_timer2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIME_OVF_TIMER3_ST_CLR = (1U << 15);  ///< Configures whether or not to clear LEDC_evt_time_ovf_timer3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIMER0_CMP_ST_CLR = (1U << 16);  ///< Configures whether or not to clear LEDC_evt_timer0_cmp trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIMER1_CMP_ST_CLR = (1U << 17);  ///< Configures whether or not to clear LEDC_evt_timer1_cmp trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIMER2_CMP_ST_CLR = (1U << 18);  ///< Configures whether or not to clear LEDC_evt_timer2_cmp trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_EVT_TIMER3_CMP_ST_CLR = (1U << 19);  ///< Configures whether or not to clear LEDC_evt_timer3_cmp trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_EVT_CNT_CMP_TIMER0_ST_CLR = (1U << 20);  ///< Configures whether or not to clear TG0_evt_cnt_cmp_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_EVT_CNT_CMP_TIMER1_ST_CLR = (1U << 21);  ///< Configures whether or not to clear TG0_evt_cnt_cmp_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_EVT_CNT_CMP_TIMER0_ST_CLR = (1U << 22);  ///< Configures whether or not to clear TG1_evt_cnt_cmp_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_EVT_CNT_CMP_TIMER1_ST_CLR = (1U << 23);  ///< Configures whether or not to clear TG1_evt_cnt_cmp_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP0_ST_CLR = (1U << 24);  ///< Configures whether or not to clear SYSTIMER_evt_cnt_cmp0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP1_ST_CLR = (1U << 25);  ///< Configures whether or not to clear SYSTIMER_evt_cnt_cmp1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t SYSTIMER_EVT_CNT_CMP2_ST_CLR = (1U << 26);  ///< Configures whether or not to clear SYSTIMER_evt_cnt_cmp2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER0_STOP_ST_CLR = (1U << 27);  ///< Configures whether or not to clear MCPWM0_evt_timer0_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER1_STOP_ST_CLR = (1U << 28);  ///< Configures whether or not to clear MCPWM0_evt_timer1_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER2_STOP_ST_CLR = (1U << 29);  ///< Configures whether or not to clear MCPWM0_evt_timer2_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER0_TEZ_ST_CLR = (1U << 30);  ///< Configures whether or not to clear MCPWM0_evt_timer0_tez trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER1_TEZ_ST_CLR = (1U << 31);  ///< Configures whether or not to clear MCPWM0_evt_timer1_tez trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST2 Register bits
    namespace evt_st2_bits {
        constexpr uint32_t MCPWM0_EVT_TIMER2_TEZ_ST = (1U << 0);  ///< Represents MCPWM0_evt_timer2_tez trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER0_TEP_ST = (1U << 1);  ///< Represents MCPWM0_evt_timer0_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER1_TEP_ST = (1U << 2);  ///< Represents MCPWM0_evt_timer1_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TIMER2_TEP_ST = (1U << 3);  ///< Represents MCPWM0_evt_timer2_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP0_TEA_ST = (1U << 4);  ///< Represents MCPWM0_evt_op0_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP1_TEA_ST = (1U << 5);  ///< Represents MCPWM0_evt_op1_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP2_TEA_ST = (1U << 6);  ///< Represents MCPWM0_evt_op2_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP0_TEB_ST = (1U << 7);  ///< Represents MCPWM0_evt_op0_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP1_TEB_ST = (1U << 8);  ///< Represents MCPWM0_evt_op1_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP2_TEB_ST = (1U << 9);  ///< Represents MCPWM0_evt_op2_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F0_ST = (1U << 10);  ///< Represents MCPWM0_evt_f0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F1_ST = (1U << 11);  ///< Represents MCPWM0_evt_f1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F2_ST = (1U << 12);  ///< Represents MCPWM0_evt_f2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F0_CLR_ST = (1U << 13);  ///< Represents MCPWM0_evt_f0_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F1_CLR_ST = (1U << 14);  ///< Represents MCPWM0_evt_f1_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_F2_CLR_ST = (1U << 15);  ///< Represents MCPWM0_evt_f2_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ0_CBC_ST = (1U << 16);  ///< Represents MCPWM0_evt_tz0_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ1_CBC_ST = (1U << 17);  ///< Represents MCPWM0_evt_tz1_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ2_CBC_ST = (1U << 18);  ///< Represents MCPWM0_evt_tz2_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ0_OST_ST = (1U << 19);  ///< Represents MCPWM0_evt_tz0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ1_OST_ST = (1U << 20);  ///< Represents MCPWM0_evt_tz1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_TZ2_OST_ST = (1U << 21);  ///< Represents MCPWM0_evt_tz2_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_CAP0_ST = (1U << 22);  ///< Represents MCPWM0_evt_cap0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_CAP1_ST = (1U << 23);  ///< Represents MCPWM0_evt_cap1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_CAP2_ST = (1U << 24);  ///< Represents MCPWM0_evt_cap2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP0_TEE1_ST = (1U << 25);  ///< Represents MCPWM0_evt_op0_tee1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP1_TEE1_ST = (1U << 26);  ///< Represents MCPWM0_evt_op1_tee1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP2_TEE1_ST = (1U << 27);  ///< Represents MCPWM0_evt_op2_tee1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP0_TEE2_ST = (1U << 28);  ///< Represents MCPWM0_evt_op0_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP1_TEE2_ST = (1U << 29);  ///< Represents MCPWM0_evt_op1_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_EVT_OP2_TEE2_ST = (1U << 30);  ///< Represents MCPWM0_evt_op2_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER0_STOP_ST = (1U << 31);  ///< Represents MCPWM1_evt_timer0_stop trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST2_CLR Register bits
    namespace evt_st2_clr_bits {
        constexpr uint32_t MCPWM0_EVT_TIMER2_TEZ_ST_CLR = (1U << 0);  ///< Configures whether or not to clear MCPWM0_evt_timer2_tez trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER0_TEP_ST_CLR = (1U << 1);  ///< Configures whether or not to clear MCPWM0_evt_timer0_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER1_TEP_ST_CLR = (1U << 2);  ///< Configures whether or not to clear MCPWM0_evt_timer1_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TIMER2_TEP_ST_CLR = (1U << 3);  ///< Configures whether or not to clear MCPWM0_evt_timer2_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP0_TEA_ST_CLR = (1U << 4);  ///< Configures whether or not to clear MCPWM0_evt_op0_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP1_TEA_ST_CLR = (1U << 5);  ///< Configures whether or not to clear MCPWM0_evt_op1_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP2_TEA_ST_CLR = (1U << 6);  ///< Configures whether or not to clear MCPWM0_evt_op2_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP0_TEB_ST_CLR = (1U << 7);  ///< Configures whether or not to clear MCPWM0_evt_op0_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP1_TEB_ST_CLR = (1U << 8);  ///< Configures whether or not to clear MCPWM0_evt_op1_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP2_TEB_ST_CLR = (1U << 9);  ///< Configures whether or not to clear MCPWM0_evt_op2_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F0_ST_CLR = (1U << 10);  ///< Configures whether or not to clear MCPWM0_evt_f0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F1_ST_CLR = (1U << 11);  ///< Configures whether or not to clear MCPWM0_evt_f1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F2_ST_CLR = (1U << 12);  ///< Configures whether or not to clear MCPWM0_evt_f2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F0_CLR_ST_CLR = (1U << 13);  ///< Configures whether or not to clear MCPWM0_evt_f0_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F1_CLR_ST_CLR = (1U << 14);  ///< Configures whether or not to clear MCPWM0_evt_f1_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_F2_CLR_ST_CLR = (1U << 15);  ///< Configures whether or not to clear MCPWM0_evt_f2_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ0_CBC_ST_CLR = (1U << 16);  ///< Configures whether or not to clear MCPWM0_evt_tz0_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ1_CBC_ST_CLR = (1U << 17);  ///< Configures whether or not to clear MCPWM0_evt_tz1_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ2_CBC_ST_CLR = (1U << 18);  ///< Configures whether or not to clear MCPWM0_evt_tz2_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ0_OST_ST_CLR = (1U << 19);  ///< Configures whether or not to clear MCPWM0_evt_tz0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ1_OST_ST_CLR = (1U << 20);  ///< Configures whether or not to clear MCPWM0_evt_tz1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_TZ2_OST_ST_CLR = (1U << 21);  ///< Configures whether or not to clear MCPWM0_evt_tz2_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_CAP0_ST_CLR = (1U << 22);  ///< Configures whether or not to clear MCPWM0_evt_cap0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_CAP1_ST_CLR = (1U << 23);  ///< Configures whether or not to clear MCPWM0_evt_cap1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_CAP2_ST_CLR = (1U << 24);  ///< Configures whether or not to clear MCPWM0_evt_cap2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP0_TEE1_ST_CLR = (1U << 25);  ///< Configures whether or not to clear MCPWM0_evt_op0_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP1_TEE1_ST_CLR = (1U << 26);  ///< Configures whether or not to clear MCPWM0_evt_op1_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP2_TEE1_ST_CLR = (1U << 27);  ///< Configures whether or not to clear MCPWM0_evt_op2_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP0_TEE2_ST_CLR = (1U << 28);  ///< Configures whether or not to clear MCPWM0_evt_op0_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP1_TEE2_ST_CLR = (1U << 29);  ///< Configures whether or not to clear MCPWM0_evt_op1_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_EVT_OP2_TEE2_ST_CLR = (1U << 30);  ///< Configures whether or not to clear MCPWM0_evt_op2_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER0_STOP_ST_CLR = (1U << 31);  ///< Configures whether or not to clear MCPWM1_evt_timer0_stop trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST3 Register bits
    namespace evt_st3_bits {
        constexpr uint32_t MCPWM1_EVT_TIMER1_STOP_ST = (1U << 0);  ///< Represents MCPWM1_evt_timer1_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER2_STOP_ST = (1U << 1);  ///< Represents MCPWM1_evt_timer2_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER0_TEZ_ST = (1U << 2);  ///< Represents MCPWM1_evt_timer0_tez trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER1_TEZ_ST = (1U << 3);  ///< Represents MCPWM1_evt_timer1_tez trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER2_TEZ_ST = (1U << 4);  ///< Represents MCPWM1_evt_timer2_tez trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER0_TEP_ST = (1U << 5);  ///< Represents MCPWM1_evt_timer0_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER1_TEP_ST = (1U << 6);  ///< Represents MCPWM1_evt_timer1_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TIMER2_TEP_ST = (1U << 7);  ///< Represents MCPWM1_evt_timer2_tep trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP0_TEA_ST = (1U << 8);  ///< Represents MCPWM1_evt_op0_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP1_TEA_ST = (1U << 9);  ///< Represents MCPWM1_evt_op1_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP2_TEA_ST = (1U << 10);  ///< Represents MCPWM1_evt_op2_tea trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP0_TEB_ST = (1U << 11);  ///< Represents MCPWM1_evt_op0_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP1_TEB_ST = (1U << 12);  ///< Represents MCPWM1_evt_op1_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP2_TEB_ST = (1U << 13);  ///< Represents MCPWM1_evt_op2_teb trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F0_ST = (1U << 14);  ///< Represents MCPWM1_evt_f0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F1_ST = (1U << 15);  ///< Represents MCPWM1_evt_f1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F2_ST = (1U << 16);  ///< Represents MCPWM1_evt_f2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F0_CLR_ST = (1U << 17);  ///< Represents MCPWM1_evt_f0_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F1_CLR_ST = (1U << 18);  ///< Represents MCPWM1_evt_f1_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_F2_CLR_ST = (1U << 19);  ///< Represents MCPWM1_evt_f2_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ0_CBC_ST = (1U << 20);  ///< Represents MCPWM1_evt_tz0_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ1_CBC_ST = (1U << 21);  ///< Represents MCPWM1_evt_tz1_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ2_CBC_ST = (1U << 22);  ///< Represents MCPWM1_evt_tz2_cbc trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ0_OST_ST = (1U << 23);  ///< Represents MCPWM1_evt_tz0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ1_OST_ST = (1U << 24);  ///< Represents MCPWM1_evt_tz1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_TZ2_OST_ST = (1U << 25);  ///< Represents MCPWM1_evt_tz2_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_CAP0_ST = (1U << 26);  ///< Represents MCPWM1_evt_cap0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_CAP1_ST = (1U << 27);  ///< Represents MCPWM1_evt_cap1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_CAP2_ST = (1U << 28);  ///< Represents MCPWM1_evt_cap2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP0_TEE1_ST = (1U << 29);  ///< Represents MCPWM1_evt_op0_tee1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP1_TEE1_ST = (1U << 30);  ///< Represents MCPWM1_evt_op1_tee1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP2_TEE1_ST = (1U << 31);  ///< Represents MCPWM1_evt_op2_tee1 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST3_CLR Register bits
    namespace evt_st3_clr_bits {
        constexpr uint32_t MCPWM1_EVT_TIMER1_STOP_ST_CLR = (1U << 0);  ///< Configures whether or not to clear MCPWM1_evt_timer1_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER2_STOP_ST_CLR = (1U << 1);  ///< Configures whether or not to clear MCPWM1_evt_timer2_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER0_TEZ_ST_CLR = (1U << 2);  ///< Configures whether or not to clear MCPWM1_evt_timer0_tez trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER1_TEZ_ST_CLR = (1U << 3);  ///< Configures whether or not to clear MCPWM1_evt_timer1_tez trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER2_TEZ_ST_CLR = (1U << 4);  ///< Configures whether or not to clear MCPWM1_evt_timer2_tez trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER0_TEP_ST_CLR = (1U << 5);  ///< Configures whether or not to clear MCPWM1_evt_timer0_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER1_TEP_ST_CLR = (1U << 6);  ///< Configures whether or not to clear MCPWM1_evt_timer1_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TIMER2_TEP_ST_CLR = (1U << 7);  ///< Configures whether or not to clear MCPWM1_evt_timer2_tep trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP0_TEA_ST_CLR = (1U << 8);  ///< Configures whether or not to clear MCPWM1_evt_op0_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP1_TEA_ST_CLR = (1U << 9);  ///< Configures whether or not to clear MCPWM1_evt_op1_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP2_TEA_ST_CLR = (1U << 10);  ///< Configures whether or not to clear MCPWM1_evt_op2_tea trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP0_TEB_ST_CLR = (1U << 11);  ///< Configures whether or not to clear MCPWM1_evt_op0_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP1_TEB_ST_CLR = (1U << 12);  ///< Configures whether or not to clear MCPWM1_evt_op1_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP2_TEB_ST_CLR = (1U << 13);  ///< Configures whether or not to clear MCPWM1_evt_op2_teb trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F0_ST_CLR = (1U << 14);  ///< Configures whether or not to clear MCPWM1_evt_f0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F1_ST_CLR = (1U << 15);  ///< Configures whether or not to clear MCPWM1_evt_f1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F2_ST_CLR = (1U << 16);  ///< Configures whether or not to clear MCPWM1_evt_f2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F0_CLR_ST_CLR = (1U << 17);  ///< Configures whether or not to clear MCPWM1_evt_f0_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F1_CLR_ST_CLR = (1U << 18);  ///< Configures whether or not to clear MCPWM1_evt_f1_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_F2_CLR_ST_CLR = (1U << 19);  ///< Configures whether or not to clear MCPWM1_evt_f2_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ0_CBC_ST_CLR = (1U << 20);  ///< Configures whether or not to clear MCPWM1_evt_tz0_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ1_CBC_ST_CLR = (1U << 21);  ///< Configures whether or not to clear MCPWM1_evt_tz1_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ2_CBC_ST_CLR = (1U << 22);  ///< Configures whether or not to clear MCPWM1_evt_tz2_cbc trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ0_OST_ST_CLR = (1U << 23);  ///< Configures whether or not to clear MCPWM1_evt_tz0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ1_OST_ST_CLR = (1U << 24);  ///< Configures whether or not to clear MCPWM1_evt_tz1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_TZ2_OST_ST_CLR = (1U << 25);  ///< Configures whether or not to clear MCPWM1_evt_tz2_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_CAP0_ST_CLR = (1U << 26);  ///< Configures whether or not to clear MCPWM1_evt_cap0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_CAP1_ST_CLR = (1U << 27);  ///< Configures whether or not to clear MCPWM1_evt_cap1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_CAP2_ST_CLR = (1U << 28);  ///< Configures whether or not to clear MCPWM1_evt_cap2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP0_TEE1_ST_CLR = (1U << 29);  ///< Configures whether or not to clear MCPWM1_evt_op0_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP1_TEE1_ST_CLR = (1U << 30);  ///< Configures whether or not to clear MCPWM1_evt_op1_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP2_TEE1_ST_CLR = (1U << 31);  ///< Configures whether or not to clear MCPWM1_evt_op2_tee1 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST4 Register bits
    namespace evt_st4_bits {
        constexpr uint32_t MCPWM1_EVT_OP0_TEE2_ST = (1U << 0);  ///< Represents MCPWM1_evt_op0_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP1_TEE2_ST = (1U << 1);  ///< Represents MCPWM1_evt_op1_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_EVT_OP2_TEE2_ST = (1U << 2);  ///< Represents MCPWM1_evt_op2_tee2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_CONV_CMPLT0_ST = (1U << 3);  ///< Represents ADC_evt_conv_cmplt0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_EQ_ABOVE_THRESH0_ST = (1U << 4);  ///< Represents ADC_evt_eq_above_thresh0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_EQ_ABOVE_THRESH1_ST = (1U << 5);  ///< Represents ADC_evt_eq_above_thresh1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_EQ_BELOW_THRESH0_ST = (1U << 6);  ///< Represents ADC_evt_eq_below_thresh0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_EQ_BELOW_THRESH1_ST = (1U << 7);  ///< Represents ADC_evt_eq_below_thresh1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_RESULT_DONE0_ST = (1U << 8);  ///< Represents ADC_evt_result_done0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_STOPPED0_ST = (1U << 9);  ///< Represents ADC_evt_stopped0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_EVT_STARTED0_ST = (1U << 10);  ///< Represents ADC_evt_started0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_DONE0_ST = (1U << 11);  ///< Represents REGDMA_evt_done0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_DONE1_ST = (1U << 12);  ///< Represents REGDMA_evt_done1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_DONE2_ST = (1U << 13);  ///< Represents REGDMA_evt_done2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_DONE3_ST = (1U << 14);  ///< Represents REGDMA_evt_done3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_ERR0_ST = (1U << 15);  ///< Represents REGDMA_evt_err0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_ERR1_ST = (1U << 16);  ///< Represents REGDMA_evt_err1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_ERR2_ST = (1U << 17);  ///< Represents REGDMA_evt_err2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_EVT_ERR3_ST = (1U << 18);  ///< Represents REGDMA_evt_err3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TMPSNSR_EVT_OVER_LIMIT_ST = (1U << 19);  ///< Represents TMPSNSR_evt_over_limit trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_EVT_RX_DONE_ST = (1U << 20);  ///< Represents I2S0_evt_rx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_EVT_TX_DONE_ST = (1U << 21);  ///< Represents I2S0_evt_tx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_EVT_X_WORDS_RECEIVED_ST = (1U << 22);  ///< Represents I2S0_evt_x_words_received trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_EVT_X_WORDS_SENT_ST = (1U << 23);  ///< Represents I2S0_evt_x_words_sent trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_EVT_RX_DONE_ST = (1U << 24);  ///< Represents I2S1_evt_rx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_EVT_TX_DONE_ST = (1U << 25);  ///< Represents I2S1_evt_tx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_EVT_X_WORDS_RECEIVED_ST = (1U << 26);  ///< Represents I2S1_evt_x_words_received trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_EVT_X_WORDS_SENT_ST = (1U << 27);  ///< Represents I2S1_evt_x_words_sent trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_EVT_RX_DONE_ST = (1U << 28);  ///< Represents I2S2_evt_rx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_EVT_TX_DONE_ST = (1U << 29);  ///< Represents I2S2_evt_tx_done trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_EVT_X_WORDS_RECEIVED_ST = (1U << 30);  ///< Represents I2S2_evt_x_words_received trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_EVT_X_WORDS_SENT_ST = (1U << 31);  ///< Represents I2S2_evt_x_words_sent trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST4_CLR Register bits
    namespace evt_st4_clr_bits {
        constexpr uint32_t MCPWM1_EVT_OP0_TEE2_ST_CLR = (1U << 0);  ///< Configures whether or not to clear MCPWM1_evt_op0_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP1_TEE2_ST_CLR = (1U << 1);  ///< Configures whether or not to clear MCPWM1_evt_op1_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_EVT_OP2_TEE2_ST_CLR = (1U << 2);  ///< Configures whether or not to clear MCPWM1_evt_op2_tee2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_CONV_CMPLT0_ST_CLR = (1U << 3);  ///< Configures whether or not to clear ADC_evt_conv_cmplt0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_EQ_ABOVE_THRESH0_ST_CLR = (1U << 4);  ///< Configures whether or not to clear ADC_evt_eq_above_thresh0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_EQ_ABOVE_THRESH1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear ADC_evt_eq_above_thresh1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_EQ_BELOW_THRESH0_ST_CLR = (1U << 6);  ///< Configures whether or not to clear ADC_evt_eq_below_thresh0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_EQ_BELOW_THRESH1_ST_CLR = (1U << 7);  ///< Configures whether or not to clear ADC_evt_eq_below_thresh1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_RESULT_DONE0_ST_CLR = (1U << 8);  ///< Configures whether or not to clear ADC_evt_result_done0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_STOPPED0_ST_CLR = (1U << 9);  ///< Configures whether or not to clear ADC_evt_stopped0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_EVT_STARTED0_ST_CLR = (1U << 10);  ///< Configures whether or not to clear ADC_evt_started0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_DONE0_ST_CLR = (1U << 11);  ///< Configures whether or not to clear REGDMA_evt_done0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_DONE1_ST_CLR = (1U << 12);  ///< Configures whether or not to clear REGDMA_evt_done1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_DONE2_ST_CLR = (1U << 13);  ///< Configures whether or not to clear REGDMA_evt_done2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_DONE3_ST_CLR = (1U << 14);  ///< Configures whether or not to clear REGDMA_evt_done3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_ERR0_ST_CLR = (1U << 15);  ///< Configures whether or not to clear REGDMA_evt_err0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_ERR1_ST_CLR = (1U << 16);  ///< Configures whether or not to clear REGDMA_evt_err1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_ERR2_ST_CLR = (1U << 17);  ///< Configures whether or not to clear REGDMA_evt_err2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_EVT_ERR3_ST_CLR = (1U << 18);  ///< Configures whether or not to clear REGDMA_evt_err3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TMPSNSR_EVT_OVER_LIMIT_ST_CLR = (1U << 19);  ///< Configures whether or not to clear TMPSNSR_evt_over_limit trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_EVT_RX_DONE_ST_CLR = (1U << 20);  ///< Configures whether or not to clear I2S0_evt_rx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_EVT_TX_DONE_ST_CLR = (1U << 21);  ///< Configures whether or not to clear I2S0_evt_tx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_EVT_X_WORDS_RECEIVED_ST_CLR = (1U << 22);  ///< Configures whether or not to clear I2S0_evt_x_words_received trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_EVT_X_WORDS_SENT_ST_CLR = (1U << 23);  ///< Configures whether or not to clear I2S0_evt_x_words_sent trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_EVT_RX_DONE_ST_CLR = (1U << 24);  ///< Configures whether or not to clear I2S1_evt_rx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_EVT_TX_DONE_ST_CLR = (1U << 25);  ///< Configures whether or not to clear I2S1_evt_tx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_EVT_X_WORDS_RECEIVED_ST_CLR = (1U << 26);  ///< Configures whether or not to clear I2S1_evt_x_words_received trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_EVT_X_WORDS_SENT_ST_CLR = (1U << 27);  ///< Configures whether or not to clear I2S1_evt_x_words_sent trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_EVT_RX_DONE_ST_CLR = (1U << 28);  ///< Configures whether or not to clear I2S2_evt_rx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_EVT_TX_DONE_ST_CLR = (1U << 29);  ///< Configures whether or not to clear I2S2_evt_tx_done trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_EVT_X_WORDS_RECEIVED_ST_CLR = (1U << 30);  ///< Configures whether or not to clear I2S2_evt_x_words_received trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_EVT_X_WORDS_SENT_ST_CLR = (1U << 31);  ///< Configures whether or not to clear I2S2_evt_x_words_sent trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST5 Register bits
    namespace evt_st5_bits {
        constexpr uint32_t ULP_EVT_ERR_INTR_ST = (1U << 0);  ///< Represents ULP_evt_err_intr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ULP_EVT_HALT_ST = (1U << 1);  ///< Represents ULP_evt_halt trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ULP_EVT_START_INTR_ST = (1U << 2);  ///< Represents ULP_evt_start_intr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_EVT_TICK_ST = (1U << 3);  ///< Represents RTC_evt_tick trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_EVT_OVF_ST = (1U << 4);  ///< Represents RTC_evt_ovf trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_EVT_CMP_ST = (1U << 5);  ///< Represents RTC_evt_cmp trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH0_ST = (1U << 6);  ///< Represents PDMA_AHB_evt_in_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH1_ST = (1U << 7);  ///< Represents PDMA_AHB_evt_in_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH2_ST = (1U << 8);  ///< Represents PDMA_AHB_evt_in_done_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH0_ST = (1U << 9);  ///< Represents PDMA_AHB_evt_in_suc_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH1_ST = (1U << 10);  ///< Represents PDMA_AHB_evt_in_suc_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH2_ST = (1U << 11);  ///< Represents PDMA_AHB_evt_in_suc_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH0_ST = (1U << 12);  ///< Represents PDMA_AHB_evt_in_fifo_empty_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH1_ST = (1U << 13);  ///< Represents PDMA_AHB_evt_in_fifo_empty_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH2_ST = (1U << 14);  ///< Represents PDMA_AHB_evt_in_fifo_empty_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH0_ST = (1U << 15);  ///< Represents PDMA_AHB_evt_in_fifo_full_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH1_ST = (1U << 16);  ///< Represents PDMA_AHB_evt_in_fifo_full_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH2_ST = (1U << 17);  ///< Represents PDMA_AHB_evt_in_fifo_full_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH0_ST = (1U << 18);  ///< Represents PDMA_AHB_evt_out_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH1_ST = (1U << 19);  ///< Represents PDMA_AHB_evt_out_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH2_ST = (1U << 20);  ///< Represents PDMA_AHB_evt_out_done_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH0_ST = (1U << 21);  ///< Represents PDMA_AHB_evt_out_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH1_ST = (1U << 22);  ///< Represents PDMA_AHB_evt_out_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH2_ST = (1U << 23);  ///< Represents PDMA_AHB_evt_out_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH0_ST = (1U << 24);  ///< Represents PDMA_AHB_evt_out_total_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH1_ST = (1U << 25);  ///< Represents PDMA_AHB_evt_out_total_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH2_ST = (1U << 26);  ///< Represents PDMA_AHB_evt_out_total_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH0_ST = (1U << 27);  ///< Represents PDMA_AHB_evt_out_fifo_empty_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH1_ST = (1U << 28);  ///< Represents PDMA_AHB_evt_out_fifo_empty_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH2_ST = (1U << 29);  ///< Represents PDMA_AHB_evt_out_fifo_empty_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH0_ST = (1U << 30);  ///< Represents PDMA_AHB_evt_out_fifo_full_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH1_ST = (1U << 31);  ///< Represents PDMA_AHB_evt_out_fifo_full_ch1 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST5_CLR Register bits
    namespace evt_st5_clr_bits {
        constexpr uint32_t ULP_EVT_ERR_INTR_ST_CLR = (1U << 0);  ///< Configures whether or not to clear ULP_evt_err_intr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ULP_EVT_HALT_ST_CLR = (1U << 1);  ///< Configures whether or not to clear ULP_evt_halt trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ULP_EVT_START_INTR_ST_CLR = (1U << 2);  ///< Configures whether or not to clear ULP_evt_start_intr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_EVT_TICK_ST_CLR = (1U << 3);  ///< Configures whether or not to clear RTC_evt_tick trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_EVT_OVF_ST_CLR = (1U << 4);  ///< Configures whether or not to clear RTC_evt_ovf trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_EVT_CMP_ST_CLR = (1U << 5);  ///< Configures whether or not to clear RTC_evt_cmp trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH0_ST_CLR = (1U << 6);  ///< Configures whether or not to clear PDMA_AHB_evt_in_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH1_ST_CLR = (1U << 7);  ///< Configures whether or not to clear PDMA_AHB_evt_in_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_DONE_CH2_ST_CLR = (1U << 8);  ///< Configures whether or not to clear PDMA_AHB_evt_in_done_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH0_ST_CLR = (1U << 9);  ///< Configures whether or not to clear PDMA_AHB_evt_in_suc_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH1_ST_CLR = (1U << 10);  ///< Configures whether or not to clear PDMA_AHB_evt_in_suc_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_SUC_EOF_CH2_ST_CLR = (1U << 11);  ///< Configures whether or not to clear PDMA_AHB_evt_in_suc_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH0_ST_CLR = (1U << 12);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_empty_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH1_ST_CLR = (1U << 13);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_empty_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_EMPTY_CH2_ST_CLR = (1U << 14);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_empty_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH0_ST_CLR = (1U << 15);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_full_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH1_ST_CLR = (1U << 16);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_full_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_IN_FIFO_FULL_CH2_ST_CLR = (1U << 17);  ///< Configures whether or not to clear PDMA_AHB_evt_in_fifo_full_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH0_ST_CLR = (1U << 18);  ///< Configures whether or not to clear PDMA_AHB_evt_out_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH1_ST_CLR = (1U << 19);  ///< Configures whether or not to clear PDMA_AHB_evt_out_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_DONE_CH2_ST_CLR = (1U << 20);  ///< Configures whether or not to clear PDMA_AHB_evt_out_done_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH0_ST_CLR = (1U << 21);  ///< Configures whether or not to clear PDMA_AHB_evt_out_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH1_ST_CLR = (1U << 22);  ///< Configures whether or not to clear PDMA_AHB_evt_out_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_EOF_CH2_ST_CLR = (1U << 23);  ///< Configures whether or not to clear PDMA_AHB_evt_out_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH0_ST_CLR = (1U << 24);  ///< Configures whether or not to clear PDMA_AHB_evt_out_total_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH1_ST_CLR = (1U << 25);  ///< Configures whether or not to clear PDMA_AHB_evt_out_total_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_TOTAL_EOF_CH2_ST_CLR = (1U << 26);  ///< Configures whether or not to clear PDMA_AHB_evt_out_total_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH0_ST_CLR = (1U << 27);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_empty_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH1_ST_CLR = (1U << 28);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_empty_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_EMPTY_CH2_ST_CLR = (1U << 29);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_empty_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH0_ST_CLR = (1U << 30);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_full_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH1_ST_CLR = (1U << 31);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_full_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST6 Register bits
    namespace evt_st6_bits {
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH2_ST = (1U << 0);  ///< Represents PDMA_AHB_evt_out_fifo_full_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH0_ST = (1U << 1);  ///< Represents PDMA_AXI_evt_in_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH1_ST = (1U << 2);  ///< Represents PDMA_AXI_evt_in_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH2_ST = (1U << 3);  ///< Represents PDMA_AXI_evt_in_done_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH0_ST = (1U << 4);  ///< Represents PDMA_AXI_evt_in_suc_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH1_ST = (1U << 5);  ///< Represents PDMA_AXI_evt_in_suc_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH2_ST = (1U << 6);  ///< Represents PDMA_AXI_evt_in_suc_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH0_ST = (1U << 7);  ///< Represents PDMA_AXI_evt_in_fifo_empty_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH1_ST = (1U << 8);  ///< Represents PDMA_AXI_evt_in_fifo_empty_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH2_ST = (1U << 9);  ///< Represents PDMA_AXI_evt_in_fifo_empty_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH0_ST = (1U << 10);  ///< Represents PDMA_AXI_evt_in_fifo_full_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH1_ST = (1U << 11);  ///< Represents PDMA_AXI_evt_in_fifo_full_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH2_ST = (1U << 12);  ///< Represents PDMA_AXI_evt_in_fifo_full_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH0_ST = (1U << 13);  ///< Represents PDMA_AXI_evt_out_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH1_ST = (1U << 14);  ///< Represents PDMA_AXI_evt_out_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH2_ST = (1U << 15);  ///< Represents PDMA_AXI_evt_out_done_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH0_ST = (1U << 16);  ///< Represents PDMA_AXI_evt_out_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH1_ST = (1U << 17);  ///< Represents PDMA_AXI_evt_out_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH2_ST = (1U << 18);  ///< Represents PDMA_AXI_evt_out_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH0_ST = (1U << 19);  ///< Represents PDMA_AXI_evt_out_total_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH1_ST = (1U << 20);  ///< Represents PDMA_AXI_evt_out_total_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH2_ST = (1U << 21);  ///< Represents PDMA_AXI_evt_out_total_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH0_ST = (1U << 22);  ///< Represents PDMA_AXI_evt_out_fifo_empty_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH1_ST = (1U << 23);  ///< Represents PDMA_AXI_evt_out_fifo_empty_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH2_ST = (1U << 24);  ///< Represents PDMA_AXI_evt_out_fifo_empty_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH0_ST = (1U << 25);  ///< Represents PDMA_AXI_evt_out_fifo_full_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH1_ST = (1U << 26);  ///< Represents PDMA_AXI_evt_out_fifo_full_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH2_ST = (1U << 27);  ///< Represents PDMA_AXI_evt_out_fifo_full_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PMU_EVT_SLEEP_WEEKUP_ST = (1U << 28);  ///< Represents PMU_evt_sleep_weekup trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_IN_DONE_CH0_ST = (1U << 29);  ///< Represents DMA2D_evt_in_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_IN_DONE_CH1_ST = (1U << 30);  ///< Represents DMA2D_evt_in_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_IN_SUC_EOF_CH0_ST = (1U << 31);  ///< Represents DMA2D_evt_in_suc_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST6_CLR Register bits
    namespace evt_st6_clr_bits {
        constexpr uint32_t PDMA_AHB_EVT_OUT_FIFO_FULL_CH2_ST_CLR = (1U << 0);  ///< Configures whether or not to clear PDMA_AHB_evt_out_fifo_full_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH0_ST_CLR = (1U << 1);  ///< Configures whether or not to clear PDMA_AXI_evt_in_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH1_ST_CLR = (1U << 2);  ///< Configures whether or not to clear PDMA_AXI_evt_in_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_DONE_CH2_ST_CLR = (1U << 3);  ///< Configures whether or not to clear PDMA_AXI_evt_in_done_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH0_ST_CLR = (1U << 4);  ///< Configures whether or not to clear PDMA_AXI_evt_in_suc_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear PDMA_AXI_evt_in_suc_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_SUC_EOF_CH2_ST_CLR = (1U << 6);  ///< Configures whether or not to clear PDMA_AXI_evt_in_suc_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH0_ST_CLR = (1U << 7);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_empty_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH1_ST_CLR = (1U << 8);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_empty_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_EMPTY_CH2_ST_CLR = (1U << 9);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_empty_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH0_ST_CLR = (1U << 10);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_full_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH1_ST_CLR = (1U << 11);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_full_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_IN_FIFO_FULL_CH2_ST_CLR = (1U << 12);  ///< Configures whether or not to clear PDMA_AXI_evt_in_fifo_full_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH0_ST_CLR = (1U << 13);  ///< Configures whether or not to clear PDMA_AXI_evt_out_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH1_ST_CLR = (1U << 14);  ///< Configures whether or not to clear PDMA_AXI_evt_out_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_DONE_CH2_ST_CLR = (1U << 15);  ///< Configures whether or not to clear PDMA_AXI_evt_out_done_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH0_ST_CLR = (1U << 16);  ///< Configures whether or not to clear PDMA_AXI_evt_out_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH1_ST_CLR = (1U << 17);  ///< Configures whether or not to clear PDMA_AXI_evt_out_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_EOF_CH2_ST_CLR = (1U << 18);  ///< Configures whether or not to clear PDMA_AXI_evt_out_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH0_ST_CLR = (1U << 19);  ///< Configures whether or not to clear PDMA_AXI_evt_out_total_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH1_ST_CLR = (1U << 20);  ///< Configures whether or not to clear PDMA_AXI_evt_out_total_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_TOTAL_EOF_CH2_ST_CLR = (1U << 21);  ///< Configures whether or not to clear PDMA_AXI_evt_out_total_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH0_ST_CLR = (1U << 22);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_empty_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH1_ST_CLR = (1U << 23);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_empty_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_EMPTY_CH2_ST_CLR = (1U << 24);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_empty_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH0_ST_CLR = (1U << 25);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_full_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH1_ST_CLR = (1U << 26);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_full_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_EVT_OUT_FIFO_FULL_CH2_ST_CLR = (1U << 27);  ///< Configures whether or not to clear PDMA_AXI_evt_out_fifo_full_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PMU_EVT_SLEEP_WEEKUP_ST_CLR = (1U << 28);  ///< Configures whether or not to clear PMU_evt_sleep_weekup trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_IN_DONE_CH0_ST_CLR = (1U << 29);  ///< Configures whether or not to clear DMA2D_evt_in_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_IN_DONE_CH1_ST_CLR = (1U << 30);  ///< Configures whether or not to clear DMA2D_evt_in_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_IN_SUC_EOF_CH0_ST_CLR = (1U << 31);  ///< Configures whether or not to clear DMA2D_evt_in_suc_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// EVT_ST7 Register bits
    namespace evt_st7_bits {
        constexpr uint32_t DMA2D_EVT_IN_SUC_EOF_CH1_ST = (1U << 0);  ///< Represents DMA2D_evt_in_suc_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH0_ST = (1U << 1);  ///< Represents DMA2D_evt_out_done_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH1_ST = (1U << 2);  ///< Represents DMA2D_evt_out_done_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH2_ST = (1U << 3);  ///< Represents DMA2D_evt_out_done_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH0_ST = (1U << 4);  ///< Represents DMA2D_evt_out_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH1_ST = (1U << 5);  ///< Represents DMA2D_evt_out_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH2_ST = (1U << 6);  ///< Represents DMA2D_evt_out_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH0_ST = (1U << 7);  ///< Represents DMA2D_evt_out_total_eof_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH1_ST = (1U << 8);  ///< Represents DMA2D_evt_out_total_eof_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH2_ST = (1U << 9);  ///< Represents DMA2D_evt_out_total_eof_ch2 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// EVT_ST7_CLR Register bits
    namespace evt_st7_clr_bits {
        constexpr uint32_t DMA2D_EVT_IN_SUC_EOF_CH1_ST_CLR = (1U << 0);  ///< Configures whether or not to clear DMA2D_evt_in_suc_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH0_ST_CLR = (1U << 1);  ///< Configures whether or not to clear DMA2D_evt_out_done_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH1_ST_CLR = (1U << 2);  ///< Configures whether or not to clear DMA2D_evt_out_done_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_DONE_CH2_ST_CLR = (1U << 3);  ///< Configures whether or not to clear DMA2D_evt_out_done_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH0_ST_CLR = (1U << 4);  ///< Configures whether or not to clear DMA2D_evt_out_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear DMA2D_evt_out_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_EOF_CH2_ST_CLR = (1U << 6);  ///< Configures whether or not to clear DMA2D_evt_out_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH0_ST_CLR = (1U << 7);  ///< Configures whether or not to clear DMA2D_evt_out_total_eof_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH1_ST_CLR = (1U << 8);  ///< Configures whether or not to clear DMA2D_evt_out_total_eof_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_EVT_OUT_TOTAL_EOF_CH2_ST_CLR = (1U << 9);  ///< Configures whether or not to clear DMA2D_evt_out_total_eof_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST0 Register bits
    namespace task_st0_bits {
        constexpr uint32_t GPIO_TASK_CH0_SET_ST = (1U << 0);  ///< Represents GPIO_task_ch0_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH1_SET_ST = (1U << 1);  ///< Represents GPIO_task_ch1_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH2_SET_ST = (1U << 2);  ///< Represents GPIO_task_ch2_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH3_SET_ST = (1U << 3);  ///< Represents GPIO_task_ch3_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH4_SET_ST = (1U << 4);  ///< Represents GPIO_task_ch4_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH5_SET_ST = (1U << 5);  ///< Represents GPIO_task_ch5_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH6_SET_ST = (1U << 6);  ///< Represents GPIO_task_ch6_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH7_SET_ST = (1U << 7);  ///< Represents GPIO_task_ch7_set trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH0_CLEAR_ST = (1U << 8);  ///< Represents GPIO_task_ch0_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH1_CLEAR_ST = (1U << 9);  ///< Represents GPIO_task_ch1_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH2_CLEAR_ST = (1U << 10);  ///< Represents GPIO_task_ch2_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH3_CLEAR_ST = (1U << 11);  ///< Represents GPIO_task_ch3_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH4_CLEAR_ST = (1U << 12);  ///< Represents GPIO_task_ch4_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH5_CLEAR_ST = (1U << 13);  ///< Represents GPIO_task_ch5_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH6_CLEAR_ST = (1U << 14);  ///< Represents GPIO_task_ch6_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH7_CLEAR_ST = (1U << 15);  ///< Represents GPIO_task_ch7_clear trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH0_TOGGLE_ST = (1U << 16);  ///< Represents GPIO_task_ch0_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH1_TOGGLE_ST = (1U << 17);  ///< Represents GPIO_task_ch1_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH2_TOGGLE_ST = (1U << 18);  ///< Represents GPIO_task_ch2_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH3_TOGGLE_ST = (1U << 19);  ///< Represents GPIO_task_ch3_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH4_TOGGLE_ST = (1U << 20);  ///< Represents GPIO_task_ch4_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH5_TOGGLE_ST = (1U << 21);  ///< Represents GPIO_task_ch5_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH6_TOGGLE_ST = (1U << 22);  ///< Represents GPIO_task_ch6_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t GPIO_TASK_CH7_TOGGLE_ST = (1U << 23);  ///< Represents GPIO_task_ch7_toggle trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER0_RES_UPDATE_ST = (1U << 24);  ///< Represents LEDC_task_timer0_res_update trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER1_RES_UPDATE_ST = (1U << 25);  ///< Represents LEDC_task_timer1_res_update trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER2_RES_UPDATE_ST = (1U << 26);  ///< Represents LEDC_task_timer2_res_update trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER3_RES_UPDATE_ST = (1U << 27);  ///< Represents LEDC_task_timer3_res_update trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH0_ST = (1U << 28);  ///< Represents LEDC_task_duty_scale_update_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH1_ST = (1U << 29);  ///< Represents LEDC_task_duty_scale_update_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH2_ST = (1U << 30);  ///< Represents LEDC_task_duty_scale_update_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH3_ST = (1U << 31);  ///< Represents LEDC_task_duty_scale_update_ch3 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST0_CLR Register bits
    namespace task_st0_clr_bits {
        constexpr uint32_t GPIO_TASK_CH0_SET_ST_CLR = (1U << 0);  ///< Configures whether or not to clear GPIO_task_ch0_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH1_SET_ST_CLR = (1U << 1);  ///< Configures whether or not to clear GPIO_task_ch1_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH2_SET_ST_CLR = (1U << 2);  ///< Configures whether or not to clear GPIO_task_ch2_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH3_SET_ST_CLR = (1U << 3);  ///< Configures whether or not to clear GPIO_task_ch3_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH4_SET_ST_CLR = (1U << 4);  ///< Configures whether or not to clear GPIO_task_ch4_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH5_SET_ST_CLR = (1U << 5);  ///< Configures whether or not to clear GPIO_task_ch5_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH6_SET_ST_CLR = (1U << 6);  ///< Configures whether or not to clear GPIO_task_ch6_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH7_SET_ST_CLR = (1U << 7);  ///< Configures whether or not to clear GPIO_task_ch7_set trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH0_CLEAR_ST_CLR = (1U << 8);  ///< Configures whether or not to clear GPIO_task_ch0_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH1_CLEAR_ST_CLR = (1U << 9);  ///< Configures whether or not to clear GPIO_task_ch1_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH2_CLEAR_ST_CLR = (1U << 10);  ///< Configures whether or not to clear GPIO_task_ch2_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH3_CLEAR_ST_CLR = (1U << 11);  ///< Configures whether or not to clear GPIO_task_ch3_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH4_CLEAR_ST_CLR = (1U << 12);  ///< Configures whether or not to clear GPIO_task_ch4_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH5_CLEAR_ST_CLR = (1U << 13);  ///< Configures whether or not to clear GPIO_task_ch5_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH6_CLEAR_ST_CLR = (1U << 14);  ///< Configures whether or not to clear GPIO_task_ch6_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH7_CLEAR_ST_CLR = (1U << 15);  ///< Configures whether or not to clear GPIO_task_ch7_clear trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH0_TOGGLE_ST_CLR = (1U << 16);  ///< Configures whether or not to clear GPIO_task_ch0_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH1_TOGGLE_ST_CLR = (1U << 17);  ///< Configures whether or not to clear GPIO_task_ch1_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH2_TOGGLE_ST_CLR = (1U << 18);  ///< Configures whether or not to clear GPIO_task_ch2_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH3_TOGGLE_ST_CLR = (1U << 19);  ///< Configures whether or not to clear GPIO_task_ch3_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH4_TOGGLE_ST_CLR = (1U << 20);  ///< Configures whether or not to clear GPIO_task_ch4_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH5_TOGGLE_ST_CLR = (1U << 21);  ///< Configures whether or not to clear GPIO_task_ch5_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH6_TOGGLE_ST_CLR = (1U << 22);  ///< Configures whether or not to clear GPIO_task_ch6_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t GPIO_TASK_CH7_TOGGLE_ST_CLR = (1U << 23);  ///< Configures whether or not to clear GPIO_task_ch7_toggle trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER0_RES_UPDATE_ST_CLR = (1U << 24);  ///< Configures whether or not to clear LEDC_task_timer0_res_update trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER1_RES_UPDATE_ST_CLR = (1U << 25);  ///< Configures whether or not to clear LEDC_task_timer1_res_update trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER2_RES_UPDATE_ST_CLR = (1U << 26);  ///< Configures whether or not to clear LEDC_task_timer2_res_update trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER3_RES_UPDATE_ST_CLR = (1U << 27);  ///< Configures whether or not to clear LEDC_task_timer3_res_update trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH0_ST_CLR = (1U << 28);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH1_ST_CLR = (1U << 29);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH2_ST_CLR = (1U << 30);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH3_ST_CLR = (1U << 31);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST1 Register bits
    namespace task_st1_bits {
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH4_ST = (1U << 0);  ///< Represents LEDC_task_duty_scale_update_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH5_ST = (1U << 1);  ///< Represents LEDC_task_duty_scale_update_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH6_ST = (1U << 2);  ///< Represents LEDC_task_duty_scale_update_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH7_ST = (1U << 3);  ///< Represents LEDC_task_duty_scale_update_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER0_CAP_ST = (1U << 4);  ///< Represents LEDC_task_timer0_cap trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER1_CAP_ST = (1U << 5);  ///< Represents LEDC_task_timer1_cap trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER2_CAP_ST = (1U << 6);  ///< Represents LEDC_task_timer2_cap trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER3_CAP_ST = (1U << 7);  ///< Represents LEDC_task_timer3_cap trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH0_ST = (1U << 8);  ///< Represents LEDC_task_sig_out_dis_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH1_ST = (1U << 9);  ///< Represents LEDC_task_sig_out_dis_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH2_ST = (1U << 10);  ///< Represents LEDC_task_sig_out_dis_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH3_ST = (1U << 11);  ///< Represents LEDC_task_sig_out_dis_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH4_ST = (1U << 12);  ///< Represents LEDC_task_sig_out_dis_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH5_ST = (1U << 13);  ///< Represents LEDC_task_sig_out_dis_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH6_ST = (1U << 14);  ///< Represents LEDC_task_sig_out_dis_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH7_ST = (1U << 15);  ///< Represents LEDC_task_sig_out_dis_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH0_ST = (1U << 16);  ///< Represents LEDC_task_ovf_cnt_rst_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH1_ST = (1U << 17);  ///< Represents LEDC_task_ovf_cnt_rst_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH2_ST = (1U << 18);  ///< Represents LEDC_task_ovf_cnt_rst_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH3_ST = (1U << 19);  ///< Represents LEDC_task_ovf_cnt_rst_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH4_ST = (1U << 20);  ///< Represents LEDC_task_ovf_cnt_rst_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH5_ST = (1U << 21);  ///< Represents LEDC_task_ovf_cnt_rst_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH6_ST = (1U << 22);  ///< Represents LEDC_task_ovf_cnt_rst_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH7_ST = (1U << 23);  ///< Represents LEDC_task_ovf_cnt_rst_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER0_RST_ST = (1U << 24);  ///< Represents LEDC_task_timer0_rst trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER1_RST_ST = (1U << 25);  ///< Represents LEDC_task_timer1_rst trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER2_RST_ST = (1U << 26);  ///< Represents LEDC_task_timer2_rst trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER3_RST_ST = (1U << 27);  ///< Represents LEDC_task_timer3_rst trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER0_RESUME_ST = (1U << 28);  ///< Represents LEDC_task_timer0_resume trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER1_RESUME_ST = (1U << 29);  ///< Represents LEDC_task_timer1_resume trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER2_RESUME_ST = (1U << 30);  ///< Represents LEDC_task_timer2_resume trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER3_RESUME_ST = (1U << 31);  ///< Represents LEDC_task_timer3_resume trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST1_CLR Register bits
    namespace task_st1_clr_bits {
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH4_ST_CLR = (1U << 0);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH5_ST_CLR = (1U << 1);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH6_ST_CLR = (1U << 2);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_DUTY_SCALE_UPDATE_CH7_ST_CLR = (1U << 3);  ///< Configures whether or not to clear LEDC_task_duty_scale_update_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER0_CAP_ST_CLR = (1U << 4);  ///< Configures whether or not to clear LEDC_task_timer0_cap trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER1_CAP_ST_CLR = (1U << 5);  ///< Configures whether or not to clear LEDC_task_timer1_cap trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER2_CAP_ST_CLR = (1U << 6);  ///< Configures whether or not to clear LEDC_task_timer2_cap trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER3_CAP_ST_CLR = (1U << 7);  ///< Configures whether or not to clear LEDC_task_timer3_cap trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH0_ST_CLR = (1U << 8);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH1_ST_CLR = (1U << 9);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH2_ST_CLR = (1U << 10);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH3_ST_CLR = (1U << 11);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH4_ST_CLR = (1U << 12);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH5_ST_CLR = (1U << 13);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH6_ST_CLR = (1U << 14);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_SIG_OUT_DIS_CH7_ST_CLR = (1U << 15);  ///< Configures whether or not to clear LEDC_task_sig_out_dis_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH0_ST_CLR = (1U << 16);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH1_ST_CLR = (1U << 17);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH2_ST_CLR = (1U << 18);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH3_ST_CLR = (1U << 19);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH4_ST_CLR = (1U << 20);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH5_ST_CLR = (1U << 21);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH6_ST_CLR = (1U << 22);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_OVF_CNT_RST_CH7_ST_CLR = (1U << 23);  ///< Configures whether or not to clear LEDC_task_ovf_cnt_rst_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER0_RST_ST_CLR = (1U << 24);  ///< Configures whether or not to clear LEDC_task_timer0_rst trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER1_RST_ST_CLR = (1U << 25);  ///< Configures whether or not to clear LEDC_task_timer1_rst trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER2_RST_ST_CLR = (1U << 26);  ///< Configures whether or not to clear LEDC_task_timer2_rst trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER3_RST_ST_CLR = (1U << 27);  ///< Configures whether or not to clear LEDC_task_timer3_rst trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER0_RESUME_ST_CLR = (1U << 28);  ///< Configures whether or not to clear LEDC_task_timer0_resume trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER1_RESUME_ST_CLR = (1U << 29);  ///< Configures whether or not to clear LEDC_task_timer1_resume trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER2_RESUME_ST_CLR = (1U << 30);  ///< Configures whether or not to clear LEDC_task_timer2_resume trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER3_RESUME_ST_CLR = (1U << 31);  ///< Configures whether or not to clear LEDC_task_timer3_resume trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST2 Register bits
    namespace task_st2_bits {
        constexpr uint32_t LEDC_TASK_TIMER0_PAUSE_ST = (1U << 0);  ///< Represents LEDC_task_timer0_pause trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER1_PAUSE_ST = (1U << 1);  ///< Represents LEDC_task_timer1_pause trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER2_PAUSE_ST = (1U << 2);  ///< Represents LEDC_task_timer2_pause trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_TIMER3_PAUSE_ST = (1U << 3);  ///< Represents LEDC_task_timer3_pause trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH0_ST = (1U << 4);  ///< Represents LEDC_task_gamma_restart_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH1_ST = (1U << 5);  ///< Represents LEDC_task_gamma_restart_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH2_ST = (1U << 6);  ///< Represents LEDC_task_gamma_restart_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH3_ST = (1U << 7);  ///< Represents LEDC_task_gamma_restart_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH4_ST = (1U << 8);  ///< Represents LEDC_task_gamma_restart_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH5_ST = (1U << 9);  ///< Represents LEDC_task_gamma_restart_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH6_ST = (1U << 10);  ///< Represents LEDC_task_gamma_restart_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH7_ST = (1U << 11);  ///< Represents LEDC_task_gamma_restart_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH0_ST = (1U << 12);  ///< Represents LEDC_task_gamma_pause_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH1_ST = (1U << 13);  ///< Represents LEDC_task_gamma_pause_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH2_ST = (1U << 14);  ///< Represents LEDC_task_gamma_pause_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH3_ST = (1U << 15);  ///< Represents LEDC_task_gamma_pause_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH4_ST = (1U << 16);  ///< Represents LEDC_task_gamma_pause_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH5_ST = (1U << 17);  ///< Represents LEDC_task_gamma_pause_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH6_ST = (1U << 18);  ///< Represents LEDC_task_gamma_pause_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH7_ST = (1U << 19);  ///< Represents LEDC_task_gamma_pause_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH0_ST = (1U << 20);  ///< Represents LEDC_task_gamma_resume_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH1_ST = (1U << 21);  ///< Represents LEDC_task_gamma_resume_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH2_ST = (1U << 22);  ///< Represents LEDC_task_gamma_resume_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH3_ST = (1U << 23);  ///< Represents LEDC_task_gamma_resume_ch3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH4_ST = (1U << 24);  ///< Represents LEDC_task_gamma_resume_ch4 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH5_ST = (1U << 25);  ///< Represents LEDC_task_gamma_resume_ch5 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH6_ST = (1U << 26);  ///< Represents LEDC_task_gamma_resume_ch6 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH7_ST = (1U << 27);  ///< Represents LEDC_task_gamma_resume_ch7 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_START_TIMER0_ST = (1U << 28);  ///< Represents TG0_task_cnt_start_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_ALARM_START_TIMER0_ST = (1U << 29);  ///< Represents TG0_task_alarm_start_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_STOP_TIMER0_ST = (1U << 30);  ///< Represents TG0_task_cnt_stop_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_RELOAD_TIMER0_ST = (1U << 31);  ///< Represents TG0_task_cnt_reload_timer0 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST2_CLR Register bits
    namespace task_st2_clr_bits {
        constexpr uint32_t LEDC_TASK_TIMER0_PAUSE_ST_CLR = (1U << 0);  ///< Configures whether or not to clear LEDC_task_timer0_pause trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER1_PAUSE_ST_CLR = (1U << 1);  ///< Configures whether or not to clear LEDC_task_timer1_pause trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER2_PAUSE_ST_CLR = (1U << 2);  ///< Configures whether or not to clear LEDC_task_timer2_pause trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_TIMER3_PAUSE_ST_CLR = (1U << 3);  ///< Configures whether or not to clear LEDC_task_timer3_pause trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH0_ST_CLR = (1U << 4);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH2_ST_CLR = (1U << 6);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH3_ST_CLR = (1U << 7);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH4_ST_CLR = (1U << 8);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH5_ST_CLR = (1U << 9);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH6_ST_CLR = (1U << 10);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESTART_CH7_ST_CLR = (1U << 11);  ///< Configures whether or not to clear LEDC_task_gamma_restart_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH0_ST_CLR = (1U << 12);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH1_ST_CLR = (1U << 13);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH2_ST_CLR = (1U << 14);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH3_ST_CLR = (1U << 15);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH4_ST_CLR = (1U << 16);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH5_ST_CLR = (1U << 17);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH6_ST_CLR = (1U << 18);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_PAUSE_CH7_ST_CLR = (1U << 19);  ///< Configures whether or not to clear LEDC_task_gamma_pause_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH0_ST_CLR = (1U << 20);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH1_ST_CLR = (1U << 21);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH2_ST_CLR = (1U << 22);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH3_ST_CLR = (1U << 23);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH4_ST_CLR = (1U << 24);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch4 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH5_ST_CLR = (1U << 25);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch5 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH6_ST_CLR = (1U << 26);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch6 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t LEDC_TASK_GAMMA_RESUME_CH7_ST_CLR = (1U << 27);  ///< Configures whether or not to clear LEDC_task_gamma_resume_ch7 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_START_TIMER0_ST_CLR = (1U << 28);  ///< Configures whether or not to clear TG0_task_cnt_start_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_ALARM_START_TIMER0_ST_CLR = (1U << 29);  ///< Configures whether or not to clear TG0_task_alarm_start_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_STOP_TIMER0_ST_CLR = (1U << 30);  ///< Configures whether or not to clear TG0_task_cnt_stop_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_RELOAD_TIMER0_ST_CLR = (1U << 31);  ///< Configures whether or not to clear TG0_task_cnt_reload_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST3 Register bits
    namespace task_st3_bits {
        constexpr uint32_t TG0_TASK_CNT_CAP_TIMER0_ST = (1U << 0);  ///< Represents TG0_task_cnt_cap_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_START_TIMER1_ST = (1U << 1);  ///< Represents TG0_task_cnt_start_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_ALARM_START_TIMER1_ST = (1U << 2);  ///< Represents TG0_task_alarm_start_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_STOP_TIMER1_ST = (1U << 3);  ///< Represents TG0_task_cnt_stop_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_RELOAD_TIMER1_ST = (1U << 4);  ///< Represents TG0_task_cnt_reload_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG0_TASK_CNT_CAP_TIMER1_ST = (1U << 5);  ///< Represents TG0_task_cnt_cap_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_START_TIMER0_ST = (1U << 6);  ///< Represents TG1_task_cnt_start_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_ALARM_START_TIMER0_ST = (1U << 7);  ///< Represents TG1_task_alarm_start_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_STOP_TIMER0_ST = (1U << 8);  ///< Represents TG1_task_cnt_stop_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_RELOAD_TIMER0_ST = (1U << 9);  ///< Represents TG1_task_cnt_reload_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_CAP_TIMER0_ST = (1U << 10);  ///< Represents TG1_task_cnt_cap_timer0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_START_TIMER1_ST = (1U << 11);  ///< Represents TG1_task_cnt_start_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_ALARM_START_TIMER1_ST = (1U << 12);  ///< Represents TG1_task_alarm_start_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_STOP_TIMER1_ST = (1U << 13);  ///< Represents TG1_task_cnt_stop_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_RELOAD_TIMER1_ST = (1U << 14);  ///< Represents TG1_task_cnt_reload_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TG1_TASK_CNT_CAP_TIMER1_ST = (1U << 15);  ///< Represents TG1_task_cnt_cap_timer1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR0_A_UP_ST = (1U << 16);  ///< Represents MCPWM0_task_cmpr0_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR1_A_UP_ST = (1U << 17);  ///< Represents MCPWM0_task_cmpr1_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR2_A_UP_ST = (1U << 18);  ///< Represents MCPWM0_task_cmpr2_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR0_B_UP_ST = (1U << 19);  ///< Represents MCPWM0_task_cmpr0_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR1_B_UP_ST = (1U << 20);  ///< Represents MCPWM0_task_cmpr1_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CMPR2_B_UP_ST = (1U << 21);  ///< Represents MCPWM0_task_cmpr2_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_GEN_STOP_ST = (1U << 22);  ///< Represents MCPWM0_task_gen_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER0_SYN_ST = (1U << 23);  ///< Represents MCPWM0_task_timer0_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER1_SYN_ST = (1U << 24);  ///< Represents MCPWM0_task_timer1_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER2_SYN_ST = (1U << 25);  ///< Represents MCPWM0_task_timer2_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER0_PERIOD_UP_ST = (1U << 26);  ///< Represents MCPWM0_task_timer0_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER1_PERIOD_UP_ST = (1U << 27);  ///< Represents MCPWM0_task_timer1_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TIMER2_PERIOD_UP_ST = (1U << 28);  ///< Represents MCPWM0_task_timer2_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TZ0_OST_ST = (1U << 29);  ///< Represents MCPWM0_task_tz0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TZ1_OST_ST = (1U << 30);  ///< Represents MCPWM0_task_tz1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_TZ2_OST_ST = (1U << 31);  ///< Represents MCPWM0_task_tz2_ost trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST3_CLR Register bits
    namespace task_st3_clr_bits {
        constexpr uint32_t TG0_TASK_CNT_CAP_TIMER0_ST_CLR = (1U << 0);  ///< Configures whether or not to clear TG0_task_cnt_cap_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_START_TIMER1_ST_CLR = (1U << 1);  ///< Configures whether or not to clear TG0_task_cnt_start_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_ALARM_START_TIMER1_ST_CLR = (1U << 2);  ///< Configures whether or not to clear TG0_task_alarm_start_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_STOP_TIMER1_ST_CLR = (1U << 3);  ///< Configures whether or not to clear TG0_task_cnt_stop_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_RELOAD_TIMER1_ST_CLR = (1U << 4);  ///< Configures whether or not to clear TG0_task_cnt_reload_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG0_TASK_CNT_CAP_TIMER1_ST_CLR = (1U << 5);  ///< Configures whether or not to clear TG0_task_cnt_cap_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_START_TIMER0_ST_CLR = (1U << 6);  ///< Configures whether or not to clear TG1_task_cnt_start_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_ALARM_START_TIMER0_ST_CLR = (1U << 7);  ///< Configures whether or not to clear TG1_task_alarm_start_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_STOP_TIMER0_ST_CLR = (1U << 8);  ///< Configures whether or not to clear TG1_task_cnt_stop_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_RELOAD_TIMER0_ST_CLR = (1U << 9);  ///< Configures whether or not to clear TG1_task_cnt_reload_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_CAP_TIMER0_ST_CLR = (1U << 10);  ///< Configures whether or not to clear TG1_task_cnt_cap_timer0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_START_TIMER1_ST_CLR = (1U << 11);  ///< Configures whether or not to clear TG1_task_cnt_start_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_ALARM_START_TIMER1_ST_CLR = (1U << 12);  ///< Configures whether or not to clear TG1_task_alarm_start_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_STOP_TIMER1_ST_CLR = (1U << 13);  ///< Configures whether or not to clear TG1_task_cnt_stop_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_RELOAD_TIMER1_ST_CLR = (1U << 14);  ///< Configures whether or not to clear TG1_task_cnt_reload_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TG1_TASK_CNT_CAP_TIMER1_ST_CLR = (1U << 15);  ///< Configures whether or not to clear TG1_task_cnt_cap_timer1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR0_A_UP_ST_CLR = (1U << 16);  ///< Configures whether or not to clear MCPWM0_task_cmpr0_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR1_A_UP_ST_CLR = (1U << 17);  ///< Configures whether or not to clear MCPWM0_task_cmpr1_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR2_A_UP_ST_CLR = (1U << 18);  ///< Configures whether or not to clear MCPWM0_task_cmpr2_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR0_B_UP_ST_CLR = (1U << 19);  ///< Configures whether or not to clear MCPWM0_task_cmpr0_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR1_B_UP_ST_CLR = (1U << 20);  ///< Configures whether or not to clear MCPWM0_task_cmpr1_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CMPR2_B_UP_ST_CLR = (1U << 21);  ///< Configures whether or not to clear MCPWM0_task_cmpr2_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_GEN_STOP_ST_CLR = (1U << 22);  ///< Configures whether or not to clear MCPWM0_task_gen_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER0_SYN_ST_CLR = (1U << 23);  ///< Configures whether or not to clear MCPWM0_task_timer0_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER1_SYN_ST_CLR = (1U << 24);  ///< Configures whether or not to clear MCPWM0_task_timer1_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER2_SYN_ST_CLR = (1U << 25);  ///< Configures whether or not to clear MCPWM0_task_timer2_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER0_PERIOD_UP_ST_CLR = (1U << 26);  ///< Configures whether or not to clear MCPWM0_task_timer0_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER1_PERIOD_UP_ST_CLR = (1U << 27);  ///< Configures whether or not to clear MCPWM0_task_timer1_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TIMER2_PERIOD_UP_ST_CLR = (1U << 28);  ///< Configures whether or not to clear MCPWM0_task_timer2_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TZ0_OST_ST_CLR = (1U << 29);  ///< Configures whether or not to clear MCPWM0_task_tz0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TZ1_OST_ST_CLR = (1U << 30);  ///< Configures whether or not to clear MCPWM0_task_tz1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_TZ2_OST_ST_CLR = (1U << 31);  ///< Configures whether or not to clear MCPWM0_task_tz2_ost trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST4 Register bits
    namespace task_st4_bits {
        constexpr uint32_t MCPWM0_TASK_CLR0_OST_ST = (1U << 0);  ///< Represents MCPWM0_task_clr0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CLR1_OST_ST = (1U << 1);  ///< Represents MCPWM0_task_clr1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CLR2_OST_ST = (1U << 2);  ///< Represents MCPWM0_task_clr2_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CAP0_ST = (1U << 3);  ///< Represents MCPWM0_task_cap0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CAP1_ST = (1U << 4);  ///< Represents MCPWM0_task_cap1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM0_TASK_CAP2_ST = (1U << 5);  ///< Represents MCPWM0_task_cap2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR0_A_UP_ST = (1U << 6);  ///< Represents MCPWM1_task_cmpr0_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR1_A_UP_ST = (1U << 7);  ///< Represents MCPWM1_task_cmpr1_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR2_A_UP_ST = (1U << 8);  ///< Represents MCPWM1_task_cmpr2_a_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR0_B_UP_ST = (1U << 9);  ///< Represents MCPWM1_task_cmpr0_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR1_B_UP_ST = (1U << 10);  ///< Represents MCPWM1_task_cmpr1_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CMPR2_B_UP_ST = (1U << 11);  ///< Represents MCPWM1_task_cmpr2_b_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_GEN_STOP_ST = (1U << 12);  ///< Represents MCPWM1_task_gen_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER0_SYN_ST = (1U << 13);  ///< Represents MCPWM1_task_timer0_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER1_SYN_ST = (1U << 14);  ///< Represents MCPWM1_task_timer1_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER2_SYN_ST = (1U << 15);  ///< Represents MCPWM1_task_timer2_syn trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER0_PERIOD_UP_ST = (1U << 16);  ///< Represents MCPWM1_task_timer0_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER1_PERIOD_UP_ST = (1U << 17);  ///< Represents MCPWM1_task_timer1_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TIMER2_PERIOD_UP_ST = (1U << 18);  ///< Represents MCPWM1_task_timer2_period_up trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TZ0_OST_ST = (1U << 19);  ///< Represents MCPWM1_task_tz0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TZ1_OST_ST = (1U << 20);  ///< Represents MCPWM1_task_tz1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_TZ2_OST_ST = (1U << 21);  ///< Represents MCPWM1_task_tz2_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CLR0_OST_ST = (1U << 22);  ///< Represents MCPWM1_task_clr0_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CLR1_OST_ST = (1U << 23);  ///< Represents MCPWM1_task_clr1_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CLR2_OST_ST = (1U << 24);  ///< Represents MCPWM1_task_clr2_ost trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CAP0_ST = (1U << 25);  ///< Represents MCPWM1_task_cap0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CAP1_ST = (1U << 26);  ///< Represents MCPWM1_task_cap1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t MCPWM1_TASK_CAP2_ST = (1U << 27);  ///< Represents MCPWM1_task_cap2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_TASK_SAMPLE0_ST = (1U << 28);  ///< Represents ADC_task_sample0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_TASK_SAMPLE1_ST = (1U << 29);  ///< Represents ADC_task_sample1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_TASK_START0_ST = (1U << 30);  ///< Represents ADC_task_start0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ADC_TASK_STOP0_ST = (1U << 31);  ///< Represents ADC_task_stop0 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST4_CLR Register bits
    namespace task_st4_clr_bits {
        constexpr uint32_t MCPWM0_TASK_CLR0_OST_ST_CLR = (1U << 0);  ///< Configures whether or not to clear MCPWM0_task_clr0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CLR1_OST_ST_CLR = (1U << 1);  ///< Configures whether or not to clear MCPWM0_task_clr1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CLR2_OST_ST_CLR = (1U << 2);  ///< Configures whether or not to clear MCPWM0_task_clr2_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CAP0_ST_CLR = (1U << 3);  ///< Configures whether or not to clear MCPWM0_task_cap0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CAP1_ST_CLR = (1U << 4);  ///< Configures whether or not to clear MCPWM0_task_cap1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM0_TASK_CAP2_ST_CLR = (1U << 5);  ///< Configures whether or not to clear MCPWM0_task_cap2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR0_A_UP_ST_CLR = (1U << 6);  ///< Configures whether or not to clear MCPWM1_task_cmpr0_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR1_A_UP_ST_CLR = (1U << 7);  ///< Configures whether or not to clear MCPWM1_task_cmpr1_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR2_A_UP_ST_CLR = (1U << 8);  ///< Configures whether or not to clear MCPWM1_task_cmpr2_a_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR0_B_UP_ST_CLR = (1U << 9);  ///< Configures whether or not to clear MCPWM1_task_cmpr0_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR1_B_UP_ST_CLR = (1U << 10);  ///< Configures whether or not to clear MCPWM1_task_cmpr1_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CMPR2_B_UP_ST_CLR = (1U << 11);  ///< Configures whether or not to clear MCPWM1_task_cmpr2_b_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_GEN_STOP_ST_CLR = (1U << 12);  ///< Configures whether or not to clear MCPWM1_task_gen_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER0_SYN_ST_CLR = (1U << 13);  ///< Configures whether or not to clear MCPWM1_task_timer0_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER1_SYN_ST_CLR = (1U << 14);  ///< Configures whether or not to clear MCPWM1_task_timer1_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER2_SYN_ST_CLR = (1U << 15);  ///< Configures whether or not to clear MCPWM1_task_timer2_syn trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER0_PERIOD_UP_ST_CLR = (1U << 16);  ///< Configures whether or not to clear MCPWM1_task_timer0_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER1_PERIOD_UP_ST_CLR = (1U << 17);  ///< Configures whether or not to clear MCPWM1_task_timer1_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TIMER2_PERIOD_UP_ST_CLR = (1U << 18);  ///< Configures whether or not to clear MCPWM1_task_timer2_period_up trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TZ0_OST_ST_CLR = (1U << 19);  ///< Configures whether or not to clear MCPWM1_task_tz0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TZ1_OST_ST_CLR = (1U << 20);  ///< Configures whether or not to clear MCPWM1_task_tz1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_TZ2_OST_ST_CLR = (1U << 21);  ///< Configures whether or not to clear MCPWM1_task_tz2_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CLR0_OST_ST_CLR = (1U << 22);  ///< Configures whether or not to clear MCPWM1_task_clr0_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CLR1_OST_ST_CLR = (1U << 23);  ///< Configures whether or not to clear MCPWM1_task_clr1_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CLR2_OST_ST_CLR = (1U << 24);  ///< Configures whether or not to clear MCPWM1_task_clr2_ost trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CAP0_ST_CLR = (1U << 25);  ///< Configures whether or not to clear MCPWM1_task_cap0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CAP1_ST_CLR = (1U << 26);  ///< Configures whether or not to clear MCPWM1_task_cap1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t MCPWM1_TASK_CAP2_ST_CLR = (1U << 27);  ///< Configures whether or not to clear MCPWM1_task_cap2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_TASK_SAMPLE0_ST_CLR = (1U << 28);  ///< Configures whether or not to clear ADC_task_sample0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_TASK_SAMPLE1_ST_CLR = (1U << 29);  ///< Configures whether or not to clear ADC_task_sample1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_TASK_START0_ST_CLR = (1U << 30);  ///< Configures whether or not to clear ADC_task_start0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ADC_TASK_STOP0_ST_CLR = (1U << 31);  ///< Configures whether or not to clear ADC_task_stop0 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST5 Register bits
    namespace task_st5_bits {
        constexpr uint32_t REGDMA_TASK_START0_ST = (1U << 0);  ///< Represents REGDMA_task_start0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_TASK_START1_ST = (1U << 1);  ///< Represents REGDMA_task_start1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_TASK_START2_ST = (1U << 2);  ///< Represents REGDMA_task_start2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t REGDMA_TASK_START3_ST = (1U << 3);  ///< Represents REGDMA_task_start3 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TMPSNSR_TASK_START_SAMPLE_ST = (1U << 4);  ///< Represents TMPSNSR_task_start_sample trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t TMPSNSR_TASK_STOP_SAMPLE_ST = (1U << 5);  ///< Represents TMPSNSR_task_stop_sample trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_TASK_START_RX_ST = (1U << 6);  ///< Represents I2S0_task_start_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_TASK_START_TX_ST = (1U << 7);  ///< Represents I2S0_task_start_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_TASK_STOP_RX_ST = (1U << 8);  ///< Represents I2S0_task_stop_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S0_TASK_STOP_TX_ST = (1U << 9);  ///< Represents I2S0_task_stop_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_TASK_START_RX_ST = (1U << 10);  ///< Represents I2S1_task_start_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_TASK_START_TX_ST = (1U << 11);  ///< Represents I2S1_task_start_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_TASK_STOP_RX_ST = (1U << 12);  ///< Represents I2S1_task_stop_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S1_TASK_STOP_TX_ST = (1U << 13);  ///< Represents I2S1_task_stop_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_TASK_START_RX_ST = (1U << 14);  ///< Represents I2S2_task_start_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_TASK_START_TX_ST = (1U << 15);  ///< Represents I2S2_task_start_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_TASK_STOP_RX_ST = (1U << 16);  ///< Represents I2S2_task_stop_rx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t I2S2_TASK_STOP_TX_ST = (1U << 17);  ///< Represents I2S2_task_stop_tx trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ULP_TASK_WAKEUP_CPU_ST = (1U << 18);  ///< Represents ULP_task_wakeup_cpu trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t ULP_TASK_INT_CPU_ST = (1U << 19);  ///< Represents ULP_task_int_cpu trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_TASK_START_ST = (1U << 20);  ///< Represents RTC_task_start trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_TASK_STOP_ST = (1U << 21);  ///< Represents RTC_task_stop trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_TASK_CLR_ST = (1U << 22);  ///< Represents RTC_task_clr trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t RTC_TASK_TRIGGERFLW_ST = (1U << 23);  ///< Represents RTC_task_triggerflw trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH0_ST = (1U << 24);  ///< Represents PDMA_AHB_task_in_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH1_ST = (1U << 25);  ///< Represents PDMA_AHB_task_in_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH2_ST = (1U << 26);  ///< Represents PDMA_AHB_task_in_start_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH0_ST = (1U << 27);  ///< Represents PDMA_AHB_task_out_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH1_ST = (1U << 28);  ///< Represents PDMA_AHB_task_out_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH2_ST = (1U << 29);  ///< Represents PDMA_AHB_task_out_start_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH0_ST = (1U << 30);  ///< Represents PDMA_AXI_task_in_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH1_ST = (1U << 31);  ///< Represents PDMA_AXI_task_in_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST5_CLR Register bits
    namespace task_st5_clr_bits {
        constexpr uint32_t REGDMA_TASK_START0_ST_CLR = (1U << 0);  ///< Configures whether or not to clear REGDMA_task_start0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_TASK_START1_ST_CLR = (1U << 1);  ///< Configures whether or not to clear REGDMA_task_start1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_TASK_START2_ST_CLR = (1U << 2);  ///< Configures whether or not to clear REGDMA_task_start2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t REGDMA_TASK_START3_ST_CLR = (1U << 3);  ///< Configures whether or not to clear REGDMA_task_start3 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TMPSNSR_TASK_START_SAMPLE_ST_CLR = (1U << 4);  ///< Configures whether or not to clear TMPSNSR_task_start_sample trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t TMPSNSR_TASK_STOP_SAMPLE_ST_CLR = (1U << 5);  ///< Configures whether or not to clear TMPSNSR_task_stop_sample trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_TASK_START_RX_ST_CLR = (1U << 6);  ///< Configures whether or not to clear I2S0_task_start_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_TASK_START_TX_ST_CLR = (1U << 7);  ///< Configures whether or not to clear I2S0_task_start_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_TASK_STOP_RX_ST_CLR = (1U << 8);  ///< Configures whether or not to clear I2S0_task_stop_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S0_TASK_STOP_TX_ST_CLR = (1U << 9);  ///< Configures whether or not to clear I2S0_task_stop_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_TASK_START_RX_ST_CLR = (1U << 10);  ///< Configures whether or not to clear I2S1_task_start_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_TASK_START_TX_ST_CLR = (1U << 11);  ///< Configures whether or not to clear I2S1_task_start_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_TASK_STOP_RX_ST_CLR = (1U << 12);  ///< Configures whether or not to clear I2S1_task_stop_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S1_TASK_STOP_TX_ST_CLR = (1U << 13);  ///< Configures whether or not to clear I2S1_task_stop_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_TASK_START_RX_ST_CLR = (1U << 14);  ///< Configures whether or not to clear I2S2_task_start_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_TASK_START_TX_ST_CLR = (1U << 15);  ///< Configures whether or not to clear I2S2_task_start_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_TASK_STOP_RX_ST_CLR = (1U << 16);  ///< Configures whether or not to clear I2S2_task_stop_rx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t I2S2_TASK_STOP_TX_ST_CLR = (1U << 17);  ///< Configures whether or not to clear I2S2_task_stop_tx trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ULP_TASK_WAKEUP_CPU_ST_CLR = (1U << 18);  ///< Configures whether or not to clear ULP_task_wakeup_cpu trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t ULP_TASK_INT_CPU_ST_CLR = (1U << 19);  ///< Configures whether or not to clear ULP_task_int_cpu trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_TASK_START_ST_CLR = (1U << 20);  ///< Configures whether or not to clear RTC_task_start trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_TASK_STOP_ST_CLR = (1U << 21);  ///< Configures whether or not to clear RTC_task_stop trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_TASK_CLR_ST_CLR = (1U << 22);  ///< Configures whether or not to clear RTC_task_clr trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t RTC_TASK_TRIGGERFLW_ST_CLR = (1U << 23);  ///< Configures whether or not to clear RTC_task_triggerflw trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH0_ST_CLR = (1U << 24);  ///< Configures whether or not to clear PDMA_AHB_task_in_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH1_ST_CLR = (1U << 25);  ///< Configures whether or not to clear PDMA_AHB_task_in_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_IN_START_CH2_ST_CLR = (1U << 26);  ///< Configures whether or not to clear PDMA_AHB_task_in_start_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH0_ST_CLR = (1U << 27);  ///< Configures whether or not to clear PDMA_AHB_task_out_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH1_ST_CLR = (1U << 28);  ///< Configures whether or not to clear PDMA_AHB_task_out_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AHB_TASK_OUT_START_CH2_ST_CLR = (1U << 29);  ///< Configures whether or not to clear PDMA_AHB_task_out_start_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH0_ST_CLR = (1U << 30);  ///< Configures whether or not to clear PDMA_AXI_task_in_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH1_ST_CLR = (1U << 31);  ///< Configures whether or not to clear PDMA_AXI_task_in_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// TASK_ST6 Register bits
    namespace task_st6_bits {
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH2_ST = (1U << 0);  ///< Represents PDMA_AXI_task_in_start_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH0_ST = (1U << 1);  ///< Represents PDMA_AXI_task_out_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH1_ST = (1U << 2);  ///< Represents PDMA_AXI_task_out_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH2_ST = (1U << 3);  ///< Represents PDMA_AXI_task_out_start_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t PMU_TASK_SLEEP_REQ_ST = (1U << 4);  ///< Represents PMU_task_sleep_req trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_IN_START_CH0_ST = (1U << 5);  ///< Represents DMA2D_task_in_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_IN_START_CH1_ST = (1U << 6);  ///< Represents DMA2D_task_in_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_IN_DSCR_READY_CH0_ST = (1U << 7);  ///< Represents DMA2D_task_in_dscr_ready_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_IN_DSCR_READY_CH1_ST = (1U << 8);  ///< Represents DMA2D_task_in_dscr_ready_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_START_CH0_ST = (1U << 9);  ///< Represents DMA2D_task_out_start_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_START_CH1_ST = (1U << 10);  ///< Represents DMA2D_task_out_start_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_START_CH2_ST = (1U << 11);  ///< Represents DMA2D_task_out_start_ch2 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH0_ST = (1U << 12);  ///< Represents DMA2D_task_out_dscr_ready_ch0 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH1_ST = (1U << 13);  ///< Represents DMA2D_task_out_dscr_ready_ch1 trigger status.\\0: Not triggered\\1: Triggered
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH2_ST = (1U << 14);  ///< Represents DMA2D_task_out_dscr_ready_ch2 trigger status.\\0: Not triggered\\1: Triggered
    }

    /// TASK_ST6_CLR Register bits
    namespace task_st6_clr_bits {
        constexpr uint32_t PDMA_AXI_TASK_IN_START_CH2_ST_CLR = (1U << 0);  ///< Configures whether or not to clear PDMA_AXI_task_in_start_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH0_ST_CLR = (1U << 1);  ///< Configures whether or not to clear PDMA_AXI_task_out_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH1_ST_CLR = (1U << 2);  ///< Configures whether or not to clear PDMA_AXI_task_out_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PDMA_AXI_TASK_OUT_START_CH2_ST_CLR = (1U << 3);  ///< Configures whether or not to clear PDMA_AXI_task_out_start_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t PMU_TASK_SLEEP_REQ_ST_CLR = (1U << 4);  ///< Configures whether or not to clear PMU_task_sleep_req trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_IN_START_CH0_ST_CLR = (1U << 5);  ///< Configures whether or not to clear DMA2D_task_in_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_IN_START_CH1_ST_CLR = (1U << 6);  ///< Configures whether or not to clear DMA2D_task_in_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_IN_DSCR_READY_CH0_ST_CLR = (1U << 7);  ///< Configures whether or not to clear DMA2D_task_in_dscr_ready_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_IN_DSCR_READY_CH1_ST_CLR = (1U << 8);  ///< Configures whether or not to clear DMA2D_task_in_dscr_ready_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_START_CH0_ST_CLR = (1U << 9);  ///< Configures whether or not to clear DMA2D_task_out_start_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_START_CH1_ST_CLR = (1U << 10);  ///< Configures whether or not to clear DMA2D_task_out_start_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_START_CH2_ST_CLR = (1U << 11);  ///< Configures whether or not to clear DMA2D_task_out_start_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH0_ST_CLR = (1U << 12);  ///< Configures whether or not to clear DMA2D_task_out_dscr_ready_ch0 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH1_ST_CLR = (1U << 13);  ///< Configures whether or not to clear DMA2D_task_out_dscr_ready_ch1 trigger status.\\0: Invalid, No effect\\1: Clear
        constexpr uint32_t DMA2D_TASK_OUT_DSCR_READY_CH2_ST_CLR = (1U << 14);  ///< Configures whether or not to clear DMA2D_task_out_dscr_ready_ch2 trigger status.\\0: Invalid, No effect\\1: Clear
    }

    /// CLK_EN Register bits
    namespace clk_en_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Configures whether or not to open register clock gate.\\0: Open the clock gate only when application writes registers\\1: Force open the clock gate for register
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Configures the version.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x5008C000;
    constexpr uint32_t SPI1_BASE = 0x5008D000;
    constexpr uint32_t SPI2_BASE = 0x500D0000;
    constexpr uint32_t SPI3_BASE = 0x500D1000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_MEM_CMD;  ///< Offset: 0x00 - SPI0 FSM status register
        volatile uint32_t SPI_MEM_CTRL;  ///< Offset: 0x08 - SPI0 control register.
        volatile uint32_t SPI_MEM_CTRL1;  ///< Offset: 0x0C - SPI0 control1 register.
        volatile uint32_t SPI_MEM_CTRL2;  ///< Offset: 0x10 - SPI0 control2 register.
        volatile uint32_t SPI_MEM_CLOCK;  ///< Offset: 0x14 - SPI clock division control register.
        volatile uint32_t SPI_MEM_USER;  ///< Offset: 0x18 - SPI0 user register.
        volatile uint32_t SPI_MEM_USER1;  ///< Offset: 0x1C - SPI0 user1 register.
        volatile uint32_t SPI_MEM_USER2;  ///< Offset: 0x20 - SPI0 user2 register.
        volatile uint32_t SPI_MEM_RD_STATUS;  ///< Offset: 0x2C - SPI0 read control register.
        volatile uint32_t SPI_MEM_MISC;  ///< Offset: 0x34 - SPI0 misc register
        volatile uint32_t SPI_MEM_CACHE_FCTRL;  ///< Offset: 0x3C - SPI0 bit mode control register.
        volatile uint32_t SPI_MEM_CACHE_SCTRL;  ///< Offset: 0x40 - SPI0 external RAM control register
        volatile uint32_t SPI_MEM_SRAM_CMD;  ///< Offset: 0x44 - SPI0 external RAM mode control register
        volatile uint32_t SPI_MEM_SRAM_DRD_CMD;  ///< Offset: 0x48 - SPI0 external RAM DDR read command control register
        volatile uint32_t SPI_MEM_SRAM_DWR_CMD;  ///< Offset: 0x4C - SPI0 external RAM DDR write command control register
        volatile uint32_t SPI_MEM_SRAM_CLK;  ///< Offset: 0x50 - SPI0 external RAM clock control register
        volatile uint32_t SPI_MEM_FSM;  ///< Offset: 0x54 - SPI0 FSM status register
        volatile uint32_t SPI_MEM_INT_ENA;  ///< Offset: 0xC0 - SPI0 interrupt enable register
        volatile uint32_t SPI_MEM_INT_CLR;  ///< Offset: 0xC4 - SPI0 interrupt clear register
        volatile uint32_t SPI_MEM_INT_RAW;  ///< Offset: 0xC8 - SPI0 interrupt raw register
        volatile uint32_t SPI_MEM_INT_ST;  ///< Offset: 0xCC - SPI0 interrupt status register
        volatile uint32_t SPI_MEM_DDR;  ///< Offset: 0xD4 - SPI0 flash DDR mode control register
        volatile uint32_t SPI_SMEM_DDR;  ///< Offset: 0xD8 - SPI0 external RAM DDR mode control register
        volatile uint32_t SPI_FMEM_PMS%s_ATTR;  ///< Offset: 0x100 - MSPI flash PMS section %s attribute register
        volatile uint32_t SPI_FMEM_PMS%s_ADDR;  ///< Offset: 0x110 - SPI1 flash PMS section %s start address register
        volatile uint32_t SPI_FMEM_PMS%s_SIZE;  ///< Offset: 0x120 - SPI1 flash PMS section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_ATTR;  ///< Offset: 0x130 - SPI1 flash PMS section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_ADDR;  ///< Offset: 0x140 - SPI1 external RAM PMS section %s start address register
        volatile uint32_t SPI_SMEM_PMS%s_SIZE;  ///< Offset: 0x150 - SPI1 external RAM PMS section %s start address register
        volatile uint32_t SPI_MEM_PMS_REJECT;  ///< Offset: 0x164 - SPI1 access reject register
        volatile uint32_t SPI_MEM_ECC_CTRL;  ///< Offset: 0x168 - MSPI ECC control register
        volatile uint32_t SPI_MEM_ECC_ERR_ADDR;  ///< Offset: 0x16C - MSPI ECC error address register
        volatile uint32_t SPI_MEM_AXI_ERR_ADDR;  ///< Offset: 0x170 - SPI0 AXI request error address.
        volatile uint32_t SPI_SMEM_ECC_CTRL;  ///< Offset: 0x174 - MSPI ECC control register
        volatile uint32_t SPI_SMEM_AXI_ADDR_CTRL;  ///< Offset: 0x178 - SPI0 AXI address control register
        volatile uint32_t SPI_MEM_AXI_ERR_RESP_EN;  ///< Offset: 0x17C - SPI0 AXI error response enable register
        volatile uint32_t SPI_MEM_TIMING_CALI;  ///< Offset: 0x180 - SPI0 flash timing calibration register
        volatile uint32_t SPI_MEM_DIN_MODE;  ///< Offset: 0x184 - MSPI flash input timing delay mode control register
        volatile uint32_t SPI_MEM_DIN_NUM;  ///< Offset: 0x188 - MSPI flash input timing delay number control register
        volatile uint32_t SPI_MEM_DOUT_MODE;  ///< Offset: 0x18C - MSPI flash output timing adjustment control register
        volatile uint32_t SPI_SMEM_TIMING_CALI;  ///< Offset: 0x190 - MSPI external RAM timing calibration register
        volatile uint32_t SPI_SMEM_DIN_MODE;  ///< Offset: 0x194 - MSPI external RAM input timing delay mode control register
        volatile uint32_t SPI_SMEM_DIN_NUM;  ///< Offset: 0x198 - MSPI external RAM input timing delay number control register
        volatile uint32_t SPI_SMEM_DOUT_MODE;  ///< Offset: 0x19C - MSPI external RAM output timing adjustment control register
        volatile uint32_t SPI_SMEM_AC;  ///< Offset: 0x1A0 - MSPI external RAM ECC and SPI CS timing control register
        volatile uint32_t SPI_SMEM_DIN_HEX_MODE;  ///< Offset: 0x1A4 - MSPI 16x external RAM input timing delay mode control register
        volatile uint32_t SPI_SMEM_DIN_HEX_NUM;  ///< Offset: 0x1A8 - MSPI 16x external RAM input timing delay number control register
        volatile uint32_t SPI_SMEM_DOUT_HEX_MODE;  ///< Offset: 0x1AC - MSPI 16x external RAM output timing adjustment control register
        volatile uint32_t SPI_MEM_CLOCK_GATE;  ///< Offset: 0x200 - SPI0 clock gate register
        volatile uint32_t SPI_MEM_XTS_PLAIN_BASE;  ///< Offset: 0x300 - The base address of the memory that stores plaintext in...
        volatile uint32_t SPI_MEM_XTS_LINESIZE;  ///< Offset: 0x340 - Manual Encryption Line-Size register
        volatile uint32_t SPI_MEM_XTS_DESTINATION;  ///< Offset: 0x344 - Manual Encryption destination register
        volatile uint32_t SPI_MEM_XTS_PHYSICAL_ADDRESS;  ///< Offset: 0x348 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_TRIGGER;  ///< Offset: 0x34C - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_RELEASE;  ///< Offset: 0x350 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_DESTROY;  ///< Offset: 0x354 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_STATE;  ///< Offset: 0x358 - Manual Encryption physical address register
        volatile uint32_t SPI_MEM_XTS_DATE;  ///< Offset: 0x35C - Manual Encryption version register
        volatile uint32_t SPI_MEM_MMU_ITEM_CONTENT;  ///< Offset: 0x37C - MSPI-MMU item content register
        volatile uint32_t SPI_MEM_MMU_ITEM_INDEX;  ///< Offset: 0x380 - MSPI-MMU item index register
        volatile uint32_t SPI_MEM_MMU_POWER_CTRL;  ///< Offset: 0x384 - MSPI MMU power control register
        volatile uint32_t SPI_MEM_DPA_CTRL;  ///< Offset: 0x388 - SPI memory cryption DPA register
        volatile uint32_t SPI_MEM_REGISTERRND_ECO_HIGH;  ///< Offset: 0x3F0 - MSPI ECO high register
        volatile uint32_t SPI_MEM_REGISTERRND_ECO_LOW;  ///< Offset: 0x3F4 - MSPI ECO low register
        volatile uint32_t SPI_MEM_DATE;  ///< Offset: 0x3FC - SPI0 version control register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);

    // Bit definitions
    /// SPI_MEM_CMD Register bits
    namespace spi_mem_cmd_bits {
        constexpr uint32_t SPI_MEM_MST_ST = (4 << 0);  ///< The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:SPI0_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
        constexpr uint32_t SPI_MEM_SLV_ST = (4 << 4);  ///< The current status of SPI0 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
        constexpr uint32_t SPI_MEM_USR = (1U << 18);  ///< SPI0 USR_CMD start bit, only used when SPI_MEM_AXI_REQ_EN is cleared. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    }

    /// SPI_MEM_CTRL Register bits
    namespace spi_mem_ctrl_bits {
        constexpr uint32_t SPI_MEM_WDUMMY_DQS_ALWAYS_OUT = (1U << 0);  ///< In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_DQS is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_WDUMMY_ALWAYS_OUT = (1U << 1);  ///< In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_FDUMMY_RIN = (1U << 2);  ///< In an MSPI read data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the first half part of dummy phase. It is used to mask invalid SPI_DQS in the half part of dummy phase.
        constexpr uint32_t SPI_MEM_FDUMMY_WOUT = (1U << 3);  ///< In an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the second half part of dummy phase. It is used to pre-drive flash.
        constexpr uint32_t SPI_MEM_FDOUT_OCT = (1U << 4);  ///< Apply 8 signals during write-data phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FDIN_OCT = (1U << 5);  ///< Apply 8 signals during read-data phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FADDR_OCT = (1U << 6);  ///< Apply 8 signals during address phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FCMD_QUAD = (1U << 8);  ///< Apply 4 signals during command phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FCMD_OCT = (1U << 9);  ///< Apply 8 signals during command phase 1:enable 0: disable
        constexpr uint32_t SPI_MEM_FASTRD_MODE = (1U << 13);  ///< This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT and SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_FREAD_DUAL = (1U << 14);  ///< In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low
        constexpr uint32_t SPI_MEM_D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low
        constexpr uint32_t SPI_MEM_FREAD_QUAD = (1U << 20);  ///< In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low.
        constexpr uint32_t SPI_MEM_FREAD_DIO = (1U << 23);  ///< In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_FREAD_QIO = (1U << 24);  ///< In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_DQS_IE_ALWAYS_ON = (1U << 30);  ///< When accesses to flash, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        constexpr uint32_t SPI_MEM_DATA_IE_ALWAYS_ON = (1U << 31);  ///< When accesses to flash, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
    }

    /// SPI_MEM_CTRL1 Register bits
    namespace spi_mem_ctrl1_bits {
        constexpr uint32_t SPI_MEM_CLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
        constexpr uint32_t SPI_AR_SIZE0_1_SUPPORT_EN = (1U << 21);  ///< 1: MSPI supports ARSIZE 0~3. When ARSIZE =0~2, MSPI read address is 4*n and reply the real AXI read data back. 0: When ARSIZE 0~1, MSPI reply SLV_ERR.
        constexpr uint32_t SPI_AW_SIZE0_1_SUPPORT_EN = (1U << 22);  ///< 1: MSPI supports AWSIZE 0~3. 0: When AWSIZE 0~1, MSPI reply SLV_ERR.
        constexpr uint32_t SPI_AXI_RDATA_BACK_FAST = (1U << 23);  ///< 1: Reply AXI read data to AXI bus when one AXI read beat data is available. 0: Reply AXI read data to AXI bus when all the read data is available.
        constexpr uint32_t SPI_MEM_RRESP_ECC_ERR_EN = (1U << 24);  ///< 1: RRESP is SLV_ERR when there is a ECC error in AXI read data. 0: RRESP is OKAY when there is a ECC error in AXI read data. The ECC error information is recorded in SPI_MEM_ECC_ERR_ADDR_REG.
        constexpr uint32_t SPI_MEM_AR_SPLICE_EN = (1U << 25);  ///< Set this bit to enable AXI Read Splice-transfer.
        constexpr uint32_t SPI_MEM_AW_SPLICE_EN = (1U << 26);  ///< Set this bit to enable AXI Write Splice-transfer.
        constexpr uint32_t SPI_MEM_RAM0_EN = (1U << 27);  ///< When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 1, only EXT_RAM0 will be accessed. When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 0, only EXT_RAM1 will be accessed. When SPI_MEM_DUAL_RAM_EN is 1, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        constexpr uint32_t SPI_MEM_DUAL_RAM_EN = (1U << 28);  ///< Set this bit to enable DUAL-RAM mode, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        constexpr uint32_t SPI_MEM_FAST_WRITE_EN = (1U << 29);  ///< Set this bit to write data faster, do not wait write data has been stored in tx_bus_fifo_l2. It will wait 4*T_clk_ctrl to insure the write data has been stored in tx_bus_fifo_l2.
        constexpr uint32_t SPI_MEM_RXFIFO_RST = (1U << 30);  ///< The synchronous reset signal for SPI0 RX AFIFO and all the AES_MSPI SYNC FIFO to receive signals from AXI. Set this bit to reset these FIFO.
        constexpr uint32_t SPI_MEM_TXFIFO_RST = (1U << 31);  ///< The synchronous reset signal for SPI0 TX AFIFO and all the AES_MSPI SYNC FIFO to send signals to AXI. Set this bit to reset these FIFO.
    }

    /// SPI_MEM_CTRL2 Register bits
    namespace spi_mem_ctrl2_bits {
        constexpr uint32_t SPI_MEM_CS_SETUP_TIME = (5 << 0);  ///< (cycles-1) of prepare phase by SPI Bus clock, this bits are combined with SPI_MEM_CS_SETUP bit.
        constexpr uint32_t SPI_MEM_CS_HOLD_TIME = (5 << 5);  ///< SPI CS signal is delayed to inactive by SPI bus clock, this bits are combined with SPI_MEM_CS_HOLD bit.
        constexpr uint32_t SPI_MEM_ECC_CS_HOLD_TIME = (3 << 10);  ///< SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI0 CS hold cycle in ECC mode when accessed flash.
        constexpr uint32_t SPI_MEM_ECC_SKIP_PAGE_CORNER = (1U << 13);  ///< 1: SPI0 and SPI1 skip page corner when accesses flash. 0: Not skip page corner when accesses flash.
        constexpr uint32_t SPI_MEM_ECC_16TO18_BYTE_EN = (1U << 14);  ///< Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
        constexpr uint32_t SPI_MEM_SPLIT_TRANS_EN = (1U << 24);  ///< Set this bit to enable SPI0 split one AXI read flash transfer into two SPI transfers when one transfer will cross flash or EXT_RAM page corner, valid no matter whether there is an ECC region or not.
        constexpr uint32_t SPI_MEM_CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SPI_MEM_SYNC_RESET = (1U << 31);  ///< The spi0_mst_st and spi0_slv_st will be reset.
    }

    /// SPI_MEM_CLOCK Register bits
    namespace spi_mem_clock_bits {
        constexpr uint32_t SPI_MEM_CLKCNT_L = (8 << 0);  ///< In the master mode it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t SPI_MEM_CLKCNT_H = (8 << 8);  ///< In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t SPI_MEM_CLKCNT_N = (8 << 16);  ///< In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t SPI_MEM_CLK_EQU_SYSCLK = (1U << 31);  ///< 1: 1-division mode, the frequency of SPI bus clock equals to that of MSPI module clock.
    }

    /// SPI_MEM_USER Register bits
    namespace spi_mem_user_bits {
        constexpr uint32_t SPI_MEM_CS_HOLD = (1U << 6);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_CS_SETUP = (1U << 7);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_CK_OUT_EDGE = (1U << 9);  ///< The bit combined with SPI_MEM_CK_IDLE_EDGE bit to control SPI clock mode 0~3.
        constexpr uint32_t SPI_MEM_USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable.
        constexpr uint32_t SPI_MEM_USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation.
    }

    /// SPI_MEM_USER1 Register bits
    namespace spi_mem_user1_bits {
        constexpr uint32_t SPI_MEM_USR_DUMMY_CYCLELEN = (6 << 0);  ///< The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        constexpr uint32_t SPI_MEM_USR_DBYTELEN = (3 << 6);  ///< SPI0 USR_CMD read or write data byte length -1
        constexpr uint32_t SPI_MEM_USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of address phase. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_USER2 Register bits
    namespace spi_mem_user2_bits {
        constexpr uint32_t SPI_MEM_USR_COMMAND_VALUE = (16 << 0);  ///< The value of command.
        constexpr uint32_t SPI_MEM_USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1)
    }

    /// SPI_MEM_RD_STATUS Register bits
    namespace spi_mem_rd_status_bits {
        constexpr uint32_t SPI_MEM_WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode bit.
    }

    /// SPI_MEM_MISC Register bits
    namespace spi_mem_misc_bits {
        constexpr uint32_t SPI_MEM_FSUB_PIN = (1U << 7);  ///< For SPI0, flash is connected to SUBPINs.
        constexpr uint32_t SPI_MEM_SSUB_PIN = (1U << 8);  ///< For SPI0, sram is connected to SUBPINs.
        constexpr uint32_t SPI_MEM_CK_IDLE_EDGE = (1U << 9);  ///< 1: SPI_CLK line is high when idle 0: spi clk line is low when idle
        constexpr uint32_t SPI_MEM_CS_KEEP_ACTIVE = (1U << 10);  ///< SPI_CS line keep low when the bit is set.
    }

    /// SPI_MEM_CACHE_FCTRL Register bits
    namespace spi_mem_cache_fctrl_bits {
        constexpr uint32_t SPI_MEM_AXI_REQ_EN = (1U << 0);  ///< For SPI0, AXI master access enable, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_CACHE_USR_ADDR_4BYTE = (1U << 1);  ///< For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_CACHE_FLASH_USR_CMD = (1U << 2);  ///< For SPI0, cache read flash for user define command, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_FDIN_DUAL = (1U << 3);  ///< For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FDOUT_DUAL = (1U << 4);  ///< For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FADDR_DUAL = (1U << 5);  ///< For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        constexpr uint32_t SPI_MEM_FDIN_QUAD = (1U << 6);  ///< For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_MEM_FDOUT_QUAD = (1U << 7);  ///< For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_MEM_FADDR_QUAD = (1U << 8);  ///< For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        constexpr uint32_t SPI_SAME_AW_AR_ADDR_CHK_EN = (1U << 30);  ///< Set this bit to check AXI read/write the same address region.
        constexpr uint32_t SPI_CLOSE_AXI_INF_EN = (1U << 31);  ///< Set this bit to close AXI read/write transfer to MSPI, which means that only SLV_ERR will be replied to BRESP/RRESP.
    }

    /// SPI_MEM_CACHE_SCTRL Register bits
    namespace spi_mem_cache_sctrl_bits {
        constexpr uint32_t SPI_MEM_CACHE_USR_SADDR_4BYTE = (1U << 0);  ///< For SPI0, In the external RAM mode, cache read flash with 4 bytes command, 1: enable, 0:disable.
        constexpr uint32_t SPI_MEM_USR_SRAM_DIO = (1U << 1);  ///< For SPI0, In the external RAM mode, spi dual I/O mode enable, 1: enable, 0:disable
        constexpr uint32_t SPI_MEM_USR_SRAM_QIO = (1U << 2);  ///< For SPI0, In the external RAM mode, spi quad I/O mode enable, 1: enable, 0:disable
        constexpr uint32_t SPI_MEM_USR_WR_SRAM_DUMMY = (1U << 3);  ///< For SPI0, In the external RAM mode, it is the enable bit of dummy phase for write operations.
        constexpr uint32_t SPI_MEM_USR_RD_SRAM_DUMMY = (1U << 4);  ///< For SPI0, In the external RAM mode, it is the enable bit of dummy phase for read operations.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RCMD = (1U << 5);  ///< For SPI0, In the external RAM mode cache read external RAM for user define command.
        constexpr uint32_t SPI_MEM_SRAM_RDUMMY_CYCLELEN = (6 << 6);  ///< For SPI0, In the external RAM mode, it is the length in bits of read dummy phase. The register value shall be (bit_num-1).
        constexpr uint32_t SPI_MEM_SRAM_ADDR_BITLEN = (6 << 14);  ///< For SPI0, In the external RAM mode, it is the length in bits of address phase. The register value shall be (bit_num-1).
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WCMD = (1U << 20);  ///< For SPI0, In the external RAM mode cache write sram for user define command
        constexpr uint32_t SPI_MEM_SRAM_OCT = (1U << 21);  ///< reserved
        constexpr uint32_t SPI_MEM_SRAM_WDUMMY_CYCLELEN = (6 << 22);  ///< For SPI0, In the external RAM mode, it is the length in bits of write dummy phase. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_CMD Register bits
    namespace spi_mem_sram_cmd_bits {
        constexpr uint32_t SPI_MEM_SCLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is always on.
        constexpr uint32_t SPI_MEM_SWB_MODE = (8 << 2);  ///< Mode bits in the external RAM fast read mode it is combined with spi_mem_fastrd_mode bit.
        constexpr uint32_t SPI_MEM_SDIN_DUAL = (1U << 10);  ///< For SPI0 external RAM , din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SDOUT_DUAL = (1U << 11);  ///< For SPI0 external RAM , dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SADDR_DUAL = (1U << 12);  ///< For SPI0 external RAM , address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        constexpr uint32_t SPI_MEM_SDIN_QUAD = (1U << 14);  ///< For SPI0 external RAM , din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SDOUT_QUAD = (1U << 15);  ///< For SPI0 external RAM , dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SADDR_QUAD = (1U << 16);  ///< For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SCMD_QUAD = (1U << 17);  ///< For SPI0 external RAM , cmd phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        constexpr uint32_t SPI_MEM_SDIN_OCT = (1U << 18);  ///< For SPI0 external RAM , din phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SDOUT_OCT = (1U << 19);  ///< For SPI0 external RAM , dout phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SADDR_OCT = (1U << 20);  ///< For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SCMD_OCT = (1U << 21);  ///< For SPI0 external RAM , cmd phase apply 8 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SDUMMY_RIN = (1U << 22);  ///< In the dummy phase of a MSPI read data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_SDUMMY_WOUT = (1U << 23);  ///< In the dummy phase of a MSPI write data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        constexpr uint32_t SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT = (1U << 24);  ///< In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_DQS is output by the MSPI controller.
        constexpr uint32_t SPI_SMEM_WDUMMY_ALWAYS_OUT = (1U << 25);  ///< In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_IO[7:0] is output by the MSPI controller.
        constexpr uint32_t SPI_MEM_SDIN_HEX = (1U << 26);  ///< For SPI0 external RAM , din phase apply 16 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_MEM_SDOUT_HEX = (1U << 27);  ///< For SPI0 external RAM , dout phase apply 16 signals. 1: enable 0: disable.
        constexpr uint32_t SPI_SMEM_DQS_IE_ALWAYS_ON = (1U << 30);  ///< When accesses to external RAM, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        constexpr uint32_t SPI_SMEM_DATA_IE_ALWAYS_ON = (1U << 31);  ///< When accesses to external RAM, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
    }

    /// SPI_MEM_SRAM_DRD_CMD Register bits
    namespace spi_mem_sram_drd_cmd_bits {
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE = (16 << 0);  ///< For SPI0,When cache mode is enable it is the read command value of command phase for sram.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN = (4 << 28);  ///< For SPI0,When cache mode is enable it is the length in bits of command phase for sram. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_DWR_CMD Register bits
    namespace spi_mem_sram_dwr_cmd_bits {
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE = (16 << 0);  ///< For SPI0,When cache mode is enable it is the write command value of command phase for sram.
        constexpr uint32_t SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN = (4 << 28);  ///< For SPI0,When cache mode is enable it is the in bits of command phase for sram. The register value shall be (bit_num-1).
    }

    /// SPI_MEM_SRAM_CLK Register bits
    namespace spi_mem_sram_clk_bits {
        constexpr uint32_t SPI_MEM_SCLKCNT_L = (8 << 0);  ///< For SPI0 external RAM interface, it must be equal to spi_mem_clkcnt_N.
        constexpr uint32_t SPI_MEM_SCLKCNT_H = (8 << 8);  ///< For SPI0 external RAM interface, it must be floor((spi_mem_clkcnt_N+1)/2-1).
        constexpr uint32_t SPI_MEM_SCLKCNT_N = (8 << 16);  ///< For SPI0 external RAM interface, it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        constexpr uint32_t SPI_MEM_SCLK_EQU_SYSCLK = (1U << 31);  ///< For SPI0 external RAM interface, 1: spi_mem_clk is eqaul to system 0: spi_mem_clk is divided from system clock.
    }

    /// SPI_MEM_FSM Register bits
    namespace spi_mem_fsm_bits {
        constexpr uint32_t SPI_MEM_LOCK_DELAY_TIME = (5 << 7);  ///< The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
    }

    /// SPI_MEM_INT_ENA Register bits
    namespace spi_mem_int_ena_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_ENA = (1U << 3);  ///< The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_ENA = (1U << 4);  ///< The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_ENA = (1U << 5);  ///< The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_ENA = (1U << 6);  ///< The enable bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_ENA = (1U << 7);  ///< The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA = (1U << 8);  ///< The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT__ENA = (1U << 9);  ///< The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS0_AFIFO_OVF_INT_ENA = (1U << 28);  ///< The enable bit for SPI_MEM_DQS0_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS1_AFIFO_OVF_INT_ENA = (1U << 29);  ///< The enable bit for SPI_MEM_DQS1_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO1_UDF_INT_ENA = (1U << 30);  ///< The enable bit for SPI_MEM_BUS_FIFO1_UDF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO0_UDF_INT_ENA = (1U << 31);  ///< The enable bit for SPI_MEM_BUS_FIFO0_UDF_INT interrupt.
    }

    /// SPI_MEM_INT_CLR Register bits
    namespace spi_mem_int_clr_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_CLR = (1U << 3);  ///< The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_CLR = (1U << 4);  ///< The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_CLR = (1U << 5);  ///< The clear bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_CLR = (1U << 6);  ///< The clear bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_CLR = (1U << 7);  ///< The clear bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR = (1U << 8);  ///< The clear bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_CLR = (1U << 9);  ///< The clear bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS0_AFIFO_OVF_INT_CLR = (1U << 28);  ///< The clear bit for SPI_MEM_DQS0_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS1_AFIFO_OVF_INT_CLR = (1U << 29);  ///< The clear bit for SPI_MEM_DQS1_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO1_UDF_INT_CLR = (1U << 30);  ///< The clear bit for SPI_MEM_BUS_FIFO1_UDF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO0_UDF_INT_CLR = (1U << 31);  ///< The clear bit for SPI_MEM_BUS_FIFO0_UDF_INT interrupt.
    }

    /// SPI_MEM_INT_RAW Register bits
    namespace spi_mem_int_raw_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_RAW = (1U << 3);  ///< The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi0_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_RAW = (1U << 4);  ///< The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi0_mst_st is changed from non idle state to idle state. 0: Others.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_RAW = (1U << 5);  ///< The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When SPI_FMEM_ECC_ERR_INT_EN is set and SPI_SMEM_ECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN is cleared and SPI_SMEM_ECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are cleared, this bit will not be triggered.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_RAW = (1U << 6);  ///< The raw bit for SPI_MEM_PMS_REJECT_INT interrupt. 1: Triggered when SPI1 access is rejected. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_RAW = (1U << 7);  ///< The raw bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt. 1: Triggered when AXI read address is invalid by compared to MMU configuration. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW = (1U << 8);  ///< The raw bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt. 1: Triggered when AXI write flash request is received. 0: Others.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_RAW = (1U << 9);  ///< The raw bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt. 1: Triggered when AXI write address is invalid by compared to MMU configuration. 0: Others.
        constexpr uint32_t SPI_MEM_DQS0_AFIFO_OVF_INT_RAW = (1U << 28);  ///< The raw bit for SPI_MEM_DQS0_AFIFO_OVF_INT interrupt. 1: Triggered when the AFIFO connected to SPI_DQS1 is overflow.
        constexpr uint32_t SPI_MEM_DQS1_AFIFO_OVF_INT_RAW = (1U << 29);  ///< The raw bit for SPI_MEM_DQS1_AFIFO_OVF_INT interrupt. 1: Triggered when the AFIFO connected to SPI_DQS is overflow.
        constexpr uint32_t SPI_MEM_BUS_FIFO1_UDF_INT_RAW = (1U << 30);  ///< The raw bit for SPI_MEM_BUS_FIFO1_UDF_INT interrupt. 1: Triggered when BUS1 FIFO is underflow.
        constexpr uint32_t SPI_MEM_BUS_FIFO0_UDF_INT_RAW = (1U << 31);  ///< The raw bit for SPI_MEM_BUS_FIFO0_UDF_INT interrupt. 1: Triggered when BUS0 FIFO is underflow.
    }

    /// SPI_MEM_INT_ST Register bits
    namespace spi_mem_int_st_bits {
        constexpr uint32_t SPI_MEM_SLV_ST_END_INT_ST = (1U << 3);  ///< The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_MST_ST_END_INT_ST = (1U << 4);  ///< The status bit for SPI_MEM_MST_ST_END_INT interrupt.
        constexpr uint32_t SPI_MEM_ECC_ERR_INT_ST = (1U << 5);  ///< The status bit for SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_PMS_REJECT_INT_ST = (1U << 6);  ///< The status bit for SPI_MEM_PMS_REJECT_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_RADDR_ERR_INT_ST = (1U << 7);  ///< The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WR_FLASH_ERR_INT_ST = (1U << 8);  ///< The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_AXI_WADDR_ERR_INT_ST = (1U << 9);  ///< The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS0_AFIFO_OVF_INT_ST = (1U << 28);  ///< The status bit for SPI_MEM_DQS0_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_DQS1_AFIFO_OVF_INT_ST = (1U << 29);  ///< The status bit for SPI_MEM_DQS1_AFIFO_OVF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO1_UDF_INT_ST = (1U << 30);  ///< The status bit for SPI_MEM_BUS_FIFO1_UDF_INT interrupt.
        constexpr uint32_t SPI_MEM_BUS_FIFO0_UDF_INT_ST = (1U << 31);  ///< The status bit for SPI_MEM_BUS_FIFO0_UDF_INT interrupt.
    }

    /// SPI_MEM_DDR Register bits
    namespace spi_mem_ddr_bits {
        constexpr uint32_t SPI_FMEM_DDR_EN = (1U << 0);  ///< 1: in DDR mode, 0 in SDR mode
        constexpr uint32_t SPI_FMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_RDAT_SWP = (1U << 2);  ///< Set the bit to reorder rx data of the word in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_WDAT_SWP = (1U << 3);  ///< Set the bit to reorder tx data of the word in spi DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in command phase when DDR mode.
        constexpr uint32_t SPI_FMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the panda device.
        constexpr uint32_t SPI_FMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI clock.
        constexpr uint32_t SPI_FMEM_DDR_DQS_LOOP = (1U << 21);  ///< 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_FMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_FMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to flash. .
        constexpr uint32_t SPI_FMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_FMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// SPI_SMEM_DDR Register bits
    namespace spi_smem_ddr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< 1: in DDR mode, 0 in SDR mode
        constexpr uint32_t SPI_SMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in spi DDR mode.
        constexpr uint32_t RDAT_SWP = (1U << 2);  ///< Set the bit to reorder rx data of the word in spi DDR mode.
        constexpr uint32_t WDAT_SWP = (1U << 3);  ///< Set the bit to reorder tx data of the word in spi DDR mode.
        constexpr uint32_t CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in command phase when DDR mode.
        constexpr uint32_t SPI_SMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the DDR psram.
        constexpr uint32_t SPI_SMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI clock.
        constexpr uint32_t DQS_LOOP = (1U << 21);  ///< 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_SMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_SMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to external RAM. .
        constexpr uint32_t SPI_SMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_SMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// SPI_FMEM_PMS%s_ATTR Register bits
    namespace spi_fmem_pms%s_attr_bits {
        constexpr uint32_t SPI_FMEM_PMS_RD_ATTR = (1U << 0);  ///< 1: SPI1 flash PMS section %s read accessible. 0: Not allowed.
        constexpr uint32_t SPI_FMEM_PMS_WR_ATTR = (1U << 1);  ///< 1: SPI1 flash PMS section %s write accessible. 0: Not allowed.
        constexpr uint32_t SPI_FMEM_PMS_ECC = (1U << 2);  ///< SPI1 flash PMS section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash PMS section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
    }

    /// SPI_FMEM_PMS%s_ADDR Register bits
    namespace spi_fmem_pms%s_addr_bits {
        constexpr uint32_t S = (27 << 0);  ///< SPI1 flash PMS section %s start address value
    }

    /// SPI_FMEM_PMS%s_SIZE Register bits
    namespace spi_fmem_pms%s_size_bits {
        constexpr uint32_t SPI_FMEM_PMS_SIZE = (15 << 0);  ///< SPI1 flash PMS section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
    }

    /// SPI_SMEM_PMS%s_ATTR Register bits
    namespace spi_smem_pms%s_attr_bits {
        constexpr uint32_t SPI_SMEM_PMS_RD_ATTR = (1U << 0);  ///< 1: SPI1 external RAM PMS section %s read accessible. 0: Not allowed.
        constexpr uint32_t SPI_SMEM_PMS_WR_ATTR = (1U << 1);  ///< 1: SPI1 external RAM PMS section %s write accessible. 0: Not allowed.
        constexpr uint32_t SPI_SMEM_PMS_ECC = (1U << 2);  ///< SPI1 external RAM PMS section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM PMS section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
    }

    /// SPI_SMEM_PMS%s_ADDR Register bits
    namespace spi_smem_pms%s_addr_bits {
        constexpr uint32_t S = (27 << 0);  ///< SPI1 external RAM PMS section %s start address value
    }

    /// SPI_SMEM_PMS%s_SIZE Register bits
    namespace spi_smem_pms%s_size_bits {
        constexpr uint32_t SPI_SMEM_PMS_SIZE = (15 << 0);  ///< SPI1 external RAM PMS section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
    }

    /// SPI_MEM_PMS_REJECT Register bits
    namespace spi_mem_pms_reject_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (27 << 0);  ///< This bits show the first SPI1 access error address. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PM_EN = (1U << 27);  ///< Set this bit to enable SPI0/1 transfer permission control function.
        constexpr uint32_t SPI_MEM_PMS_LD = (1U << 28);  ///< 1: SPI1 write access error. 0: No write access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_ST = (1U << 29);  ///< 1: SPI1 read access error. 0: No read access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_MULTI_HIT = (1U << 30);  ///< 1: SPI1 access is rejected because of address miss. 0: No address miss error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        constexpr uint32_t SPI_MEM_PMS_IVD = (1U << 31);  ///< 1: SPI1 access is rejected because of address multi-hit. 0: No address multi-hit error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
    }

    /// SPI_MEM_ECC_CTRL Register bits
    namespace spi_mem_ecc_ctrl_bits {
        constexpr uint32_t SPI_MEM_ECC_ERR_CNT = (6 << 5);  ///< This bits show the error times of MSPI ECC read. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
        constexpr uint32_t SPI_FMEM_ECC_ERR_INT_NUM = (6 << 11);  ///< Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_FMEM_ECC_ERR_INT_EN = (1U << 17);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
        constexpr uint32_t SPI_FMEM_PAGE_SIZE = (2 << 18);  ///< Set the page size of the flash accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        constexpr uint32_t SPI_FMEM_ECC_ADDR_EN = (1U << 20);  ///< Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of flash. If there is no ECC region in flash, this bit should be 0. Otherwise, this bit should be 1.
        constexpr uint32_t SPI_MEM_USR_ECC_ADDR_EN = (1U << 21);  ///< Set this bit to enable ECC address convert in SPI0/1 USR_CMD transfer.
        constexpr uint32_t SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN = (1U << 24);  ///< 1: The error information in SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR is updated when there is an ECC error. 0: SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR record the first ECC error information.
        constexpr uint32_t SPI_MEM_ECC_ERR_BITS = (7 << 25);  ///< Records the first ECC error bit number in the 16 bytes(From 0~127, corresponding to byte 0 bit 0 to byte 15 bit 7)
    }

    /// SPI_MEM_ECC_ERR_ADDR Register bits
    namespace spi_mem_ecc_err_addr_bits {
        constexpr uint32_t SPI_MEM_ECC_ERR_ADDR = (27 << 0);  ///< This bits show the first MSPI ECC error address. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
    }

    /// SPI_MEM_AXI_ERR_ADDR Register bits
    namespace spi_mem_axi_err_addr_bits {
        constexpr uint32_t SPI_MEM_AXI_ERR_ADDR = (27 << 0);  ///< This bits show the first AXI write/read invalid error or AXI write flash error address. It is cleared by when SPI_MEM_AXI_WADDR_ERR_INT_CLR, SPI_MEM_AXI_WR_FLASH_ERR_IN_CLR or SPI_MEM_AXI_RADDR_ERR_IN_CLR bit is set.
    }

    /// SPI_SMEM_ECC_CTRL Register bits
    namespace spi_smem_ecc_ctrl_bits {
        constexpr uint32_t SPI_SMEM_ECC_ERR_INT_EN = (1U << 17);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_PAGE_SIZE = (2 << 18);  ///< Set the page size of the external RAM accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        constexpr uint32_t SPI_SMEM_ECC_ADDR_EN = (1U << 20);  ///< Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of external RAM. If there is no ECC region in external RAM, this bit should be 0. Otherwise, this bit should be 1.
    }

    /// SPI_SMEM_AXI_ADDR_CTRL Register bits
    namespace spi_smem_axi_addr_ctrl_bits {
        constexpr uint32_t SPI_MEM_ALL_FIFO_EMPTY = (1U << 26);  ///< The empty status of all AFIFO and SYNC_FIFO in MSPI module. 1: All AXI transfers and SPI0 transfers are done. 0: Others.
        constexpr uint32_t SPI_RDATA_AFIFO_REMPTY = (1U << 27);  ///< 1: RDATA_AFIFO is empty. 0: At least one AXI read transfer is pending.
        constexpr uint32_t SPI_RADDR_AFIFO_REMPTY = (1U << 28);  ///< 1: AXI_RADDR_CTL_AFIFO is empty. 0: At least one AXI read transfer is pending.
        constexpr uint32_t SPI_WDATA_AFIFO_REMPTY = (1U << 29);  ///< 1: WDATA_AFIFO is empty. 0: At least one AXI write transfer is pending.
        constexpr uint32_t SPI_WBLEN_AFIFO_REMPTY = (1U << 30);  ///< 1: WBLEN_AFIFO is empty. 0: At least one AXI write transfer is pending.
        constexpr uint32_t SPI_ALL_AXI_TRANS_AFIFO_EMPTY = (1U << 31);  ///< This bit is set when WADDR_AFIFO, WBLEN_AFIFO, WDATA_AFIFO, AXI_RADDR_CTL_AFIFO and RDATA_AFIFO are empty and spi0_mst_st is IDLE.
    }

    /// SPI_MEM_AXI_ERR_RESP_EN Register bits
    namespace spi_mem_axi_err_resp_en_bits {
        constexpr uint32_t SPI_MEM_AW_RESP_EN_MMU_VLD = (1U << 0);  ///< Set this bit to enable AXI response function for mmu valid err in axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_MMU_GID = (1U << 1);  ///< Set this bit to enable AXI response function for mmu gid err in axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_AXI_SIZE = (1U << 2);  ///< Set this bit to enable AXI response function for axi size err in axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_AXI_FLASH = (1U << 3);  ///< Set this bit to enable AXI response function for axi flash err in axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_MMU_ECC = (1U << 4);  ///< Set this bit to enable AXI response function for mmu ecc err in axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_MMU_SENS = (1U << 5);  ///< Set this bit to enable AXI response function for mmu sens in err axi write trans.
        constexpr uint32_t SPI_MEM_AW_RESP_EN_AXI_WSTRB = (1U << 6);  ///< Set this bit to enable AXI response function for axi wstrb err in axi write trans.
        constexpr uint32_t SPI_MEM_AR_RESP_EN_MMU_VLD = (1U << 7);  ///< Set this bit to enable AXI response function for mmu valid err in axi read trans.
        constexpr uint32_t SPI_MEM_AR_RESP_EN_MMU_GID = (1U << 8);  ///< Set this bit to enable AXI response function for mmu gid err in axi read trans.
        constexpr uint32_t SPI_MEM_AR_RESP_EN_MMU_ECC = (1U << 9);  ///< Set this bit to enable AXI response function for mmu ecc err in axi read trans.
        constexpr uint32_t SPI_MEM_AR_RESP_EN_MMU_SENS = (1U << 10);  ///< Set this bit to enable AXI response function for mmu sensitive err in axi read trans.
        constexpr uint32_t SPI_MEM_AR_RESP_EN_AXI_SIZE = (1U << 11);  ///< Set this bit to enable AXI response function for axi size err in axi read trans.
    }

    /// SPI_MEM_TIMING_CALI Register bits
    namespace spi_mem_timing_cali_bits {
        constexpr uint32_t SPI_MEM_TIMING_CLK_ENA = (1U << 0);  ///< The bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t SPI_MEM_TIMING_CALI = (1U << 1);  ///< The bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t SPI_MEM_EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< add extra dummy spi clock cycle length for spi clock calibration.
        constexpr uint32_t SPI_MEM_DLL_TIMING_CALI = (1U << 5);  ///< Set this bit to enable DLL for timing calibration in DDR mode when accessed to flash.
        constexpr uint32_t UPDATE = (1U << 6);  ///< Set this bit to update delay mode, delay num and extra dummy in MSPI.
    }

    /// SPI_MEM_DIN_MODE Register bits
    namespace spi_mem_din_mode_bits {
        constexpr uint32_t SPI_MEM_DIN0_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN1_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN2_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN3_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DIN4_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN5_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN6_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DIN7_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        constexpr uint32_t SPI_MEM_DINS_MODE = (3 << 24);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
    }

    /// SPI_MEM_DIN_NUM Register bits
    namespace spi_mem_din_num_bits {
        constexpr uint32_t SPI_MEM_DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN4_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN5_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN6_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DIN7_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_MEM_DINS_NUM = (2 << 16);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// SPI_MEM_DOUT_MODE Register bits
    namespace spi_mem_dout_mode_bits {
        constexpr uint32_t SPI_MEM_DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_MEM_DOUT4_MODE = (1U << 4);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT5_MODE = (1U << 5);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT6_MODE = (1U << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUT7_MODE = (1U << 7);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        constexpr uint32_t SPI_MEM_DOUTS_MODE = (1U << 8);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
    }

    /// SPI_SMEM_TIMING_CALI Register bits
    namespace spi_smem_timing_cali_bits {
        constexpr uint32_t SPI_SMEM_TIMING_CLK_ENA = (1U << 0);  ///< For sram, the bit is used to enable timing adjust clock for all reading operations.
        constexpr uint32_t SPI_SMEM_TIMING_CALI = (1U << 1);  ///< For sram, the bit is used to enable timing auto-calibration for all reading operations.
        constexpr uint32_t SPI_SMEM_EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< For sram, add extra dummy spi clock cycle length for spi clock calibration.
        constexpr uint32_t SPI_SMEM_DLL_TIMING_CALI = (1U << 5);  ///< Set this bit to enable DLL for timing calibration in DDR mode when accessed to EXT_RAM.
    }

    /// SPI_SMEM_DIN_MODE Register bits
    namespace spi_smem_din_mode_bits {
        constexpr uint32_t SPI_SMEM_DIN0_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN1_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN2_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN3_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN4_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN5_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN6_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN7_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DINS_MODE = (3 << 24);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// SPI_SMEM_DIN_NUM Register bits
    namespace spi_smem_din_num_bits {
        constexpr uint32_t SPI_SMEM_DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN4_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN5_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN6_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN7_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DINS_NUM = (2 << 16);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// SPI_SMEM_DOUT_MODE Register bits
    namespace spi_smem_dout_mode_bits {
        constexpr uint32_t SPI_SMEM_DOUT0_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT1_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT2_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT3_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT4_MODE = (1U << 4);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT5_MODE = (1U << 5);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT6_MODE = (1U << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT7_MODE = (1U << 7);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUTS_MODE = (1U << 8);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
    }

    /// SPI_SMEM_AC Register bits
    namespace spi_smem_ac_bits {
        constexpr uint32_t SPI_SMEM_CS_SETUP = (1U << 0);  ///< For SPI0 and SPI1, spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        constexpr uint32_t SPI_SMEM_CS_HOLD = (1U << 1);  ///< For SPI0 and SPI1, spi cs keep low when spi is in done phase. 1: enable 0: disable.
        constexpr uint32_t SPI_SMEM_CS_SETUP_TIME = (5 << 2);  ///< For spi0, (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
        constexpr uint32_t SPI_SMEM_CS_HOLD_TIME = (5 << 7);  ///< For SPI0 and SPI1, spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
        constexpr uint32_t SPI_SMEM_ECC_CS_HOLD_TIME = (3 << 12);  ///< SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the SPI0 and SPI1 CS hold cycles in ECC mode when accessed external RAM.
        constexpr uint32_t SPI_SMEM_ECC_SKIP_PAGE_CORNER = (1U << 15);  ///< 1: SPI0 skips page corner when accesses external RAM. 0: Not skip page corner when accesses external RAM.
        constexpr uint32_t SPI_SMEM_ECC_16TO18_BYTE_EN = (1U << 16);  ///< Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses external RAM.
        constexpr uint32_t SPI_SMEM_CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SPI_SMEM_SPLIT_TRANS_EN = (1U << 31);  ///< Set this bit to enable SPI0 split one AXI accesses EXT_RAM transfer into two SPI transfers when one transfer will cross flash/EXT_RAM page corner, valid no matter whether there is an ECC region or not.
    }

    /// SPI_SMEM_DIN_HEX_MODE Register bits
    namespace spi_smem_din_hex_mode_bits {
        constexpr uint32_t SPI_SMEM_DIN08_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN09_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN10_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN11_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN12_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN13_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN14_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DIN15_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DINS_HEX_MODE = (3 << 24);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
    }

    /// SPI_SMEM_DIN_HEX_NUM Register bits
    namespace spi_smem_din_hex_num_bits {
        constexpr uint32_t SPI_SMEM_DIN08_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN09_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN10_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN11_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN12_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN13_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN14_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DIN15_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        constexpr uint32_t SPI_SMEM_DINS_HEX_NUM = (2 << 16);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
    }

    /// SPI_SMEM_DOUT_HEX_MODE Register bits
    namespace spi_smem_dout_hex_mode_bits {
        constexpr uint32_t SPI_SMEM_DOUT08_MODE = (1U << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT09_MODE = (1U << 1);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT10_MODE = (1U << 2);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT11_MODE = (1U << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT12_MODE = (1U << 4);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT13_MODE = (1U << 5);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT14_MODE = (1U << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUT15_MODE = (1U << 7);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        constexpr uint32_t SPI_SMEM_DOUTS_HEX_MODE = (1U << 8);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
    }

    /// SPI_MEM_CLOCK_GATE Register bits
    namespace spi_mem_clock_gate_bits {
        constexpr uint32_t SPI_CLK_EN = (1U << 0);  ///< Register clock gate enable signal. 1: Enable. 0: Disable.
    }

    /// SPI_MEM_XTS_PLAIN_BASE Register bits
    namespace spi_mem_xts_plain_base_bits {
        constexpr uint32_t SPI_XTS_PLAIN = (32 << 0);  ///< This field is only used to generate include file in c case. This field is useless. Please do not use this field.
    }

    /// SPI_MEM_XTS_LINESIZE Register bits
    namespace spi_mem_xts_linesize_bits {
        constexpr uint32_t SPI_XTS_LINESIZE = (2 << 0);  ///< This bits stores the line-size parameter which will be used in manual encryption calculation. It decides how many bytes will be encrypted one time. 0: 16-bytes, 1: 32-bytes, 2: 64-bytes, 3:reserved.
    }

    /// SPI_MEM_XTS_DESTINATION Register bits
    namespace spi_mem_xts_destination_bits {
        constexpr uint32_t SPI_XTS_DESTINATION = (1U << 0);  ///< This bit stores the destination parameter which will be used in manual encryption calculation. 0: flash(default), 1: psram(reserved). Only default value can be used.
    }

    /// SPI_MEM_XTS_PHYSICAL_ADDRESS Register bits
    namespace spi_mem_xts_physical_address_bits {
        constexpr uint32_t SPI_XTS_PHYSICAL_ADDRESS = (26 << 0);  ///< This bits stores the physical-address parameter which will be used in manual encryption calculation. This value should aligned with byte number decided by line-size parameter.
    }

    /// SPI_MEM_XTS_TRIGGER Register bits
    namespace spi_mem_xts_trigger_bits {
        constexpr uint32_t SPI_XTS_TRIGGER = (1U << 0);  ///< Set this bit to trigger the process of manual encryption calculation. This action should only be asserted when manual encryption status is 0. After this action, manual encryption status becomes 1. After calculation is done, manual encryption status becomes 2.
    }

    /// SPI_MEM_XTS_RELEASE Register bits
    namespace spi_mem_xts_release_bits {
        constexpr uint32_t SPI_XTS_RELEASE = (1U << 0);  ///< Set this bit to release encrypted result to mspi. This action should only be asserted when manual encryption status is 2. After this action, manual encryption status will become 3.
    }

    /// SPI_MEM_XTS_DESTROY Register bits
    namespace spi_mem_xts_destroy_bits {
        constexpr uint32_t SPI_XTS_DESTROY = (1U << 0);  ///< Set this bit to destroy encrypted result. This action should be asserted only when manual encryption status is 3. After this action, manual encryption status will become 0.
    }

    /// SPI_MEM_XTS_STATE Register bits
    namespace spi_mem_xts_state_bits {
        constexpr uint32_t SPI_XTS_STATE = (2 << 0);  ///< This bits stores the status of manual encryption. 0: idle, 1: busy of encryption calculation, 2: encryption calculation is done but the encrypted result is invisible to mspi, 3: the encrypted result is visible to mspi.
    }

    /// SPI_MEM_XTS_DATE Register bits
    namespace spi_mem_xts_date_bits {
        constexpr uint32_t SPI_XTS_DATE = (30 << 0);  ///< This bits stores the last modified-time of manual encryption feature.
    }

    /// SPI_MEM_MMU_ITEM_CONTENT Register bits
    namespace spi_mem_mmu_item_content_bits {
        constexpr uint32_t SPI_MMU_ITEM_CONTENT = (32 << 0);  ///< MSPI-MMU item content
    }

    /// SPI_MEM_MMU_ITEM_INDEX Register bits
    namespace spi_mem_mmu_item_index_bits {
        constexpr uint32_t SPI_MMU_ITEM_INDEX = (32 << 0);  ///< MSPI-MMU item index
    }

    /// SPI_MEM_MMU_POWER_CTRL Register bits
    namespace spi_mem_mmu_power_ctrl_bits {
        constexpr uint32_t SPI_MMU_MEM_FORCE_ON = (1U << 0);  ///< Set this bit to enable mmu-memory clock force on
        constexpr uint32_t SPI_MMU_MEM_FORCE_PD = (1U << 1);  ///< Set this bit to force mmu-memory powerdown
        constexpr uint32_t SPI_MMU_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force mmu-memory powerup, in this case, the power should also be controlled by rtc.
        constexpr uint32_t SPI_MEM_AUX_CTRL = (14 << 16);  ///< MMU PSRAM aux control register
        constexpr uint32_t SPI_MEM_RDN_ENA = (1U << 30);  ///< ECO register enable bit
        constexpr uint32_t SPI_MEM_RDN_RESULT = (1U << 31);  ///< MSPI module clock domain and AXI clock domain ECO register result register
    }

    /// SPI_MEM_DPA_CTRL Register bits
    namespace spi_mem_dpa_ctrl_bits {
        constexpr uint32_t SPI_CRYPT_SECURITY_LEVEL = (3 << 0);  ///< Set the security level of spi mem cryption. 0: Shut off cryption DPA funtion. 1-7: The bigger the number is, the more secure the cryption is. (Note that the performance of cryption will decrease together with this number increasing)
        constexpr uint32_t SPI_CRYPT_CALC_D_DPA_EN = (1U << 3);  ///< Only available when SPI_CRYPT_SECURITY_LEVEL is not 0. 1: Enable DPA in the calculation that using key 1 or key 2. 0: Enable DPA only in the calculation that using key 1.
        constexpr uint32_t SPI_CRYPT_DPA_SELECT_REGISTER = (1U << 4);  ///< 1: MSPI XTS DPA clock gate is controlled by SPI_CRYPT_CALC_D_DPA_EN and SPI_CRYPT_SECURITY_LEVEL. 0: Controlled by efuse bits.
    }

    /// SPI_MEM_REGISTERRND_ECO_HIGH Register bits
    namespace spi_mem_registerrnd_eco_high_bits {
        constexpr uint32_t SPI_MEM_REGISTERRND_ECO_HIGH = (32 << 0);  ///< ECO high register
    }

    /// SPI_MEM_REGISTERRND_ECO_LOW Register bits
    namespace spi_mem_registerrnd_eco_low_bits {
        constexpr uint32_t SPI_MEM_REGISTERRND_ECO_LOW = (32 << 0);  ///< ECO low register
    }

    /// SPI_MEM_DATE Register bits
    namespace spi_mem_date_bits {
        constexpr uint32_t SPI_MEM_DATE = (28 << 0);  ///< SPI0 register version.
    }

}

// ============================================================================
// TRACE0 Peripheral
// ============================================================================

namespace trace0 {
    /// Base addresses
    constexpr uint32_t TRACE0_BASE = 0x3FF04000;

    /// TRACE0 Register structure
    struct Registers {
        volatile uint32_t MEM_START_ADDR;  ///< Offset: 0x00 - mem start addr
        volatile uint32_t MEM_END_ADDR;  ///< Offset: 0x04 - mem end addr
        volatile uint32_t MEM_CURRENT_ADDR;  ///< Offset: 0x08 - mem current addr
        volatile uint32_t MEM_ADDR_UPDATE;  ///< Offset: 0x0C - mem addr update
        volatile uint32_t FIFO_STATUS;  ///< Offset: 0x10 - fifo status register
        volatile uint32_t INTR_ENA;  ///< Offset: 0x14 - interrupt enable register
        volatile uint32_t INTR_RAW;  ///< Offset: 0x18 - interrupt status register
        volatile uint32_t INTR_CLR;  ///< Offset: 0x1C - interrupt clear register
        volatile uint32_t TRIGGER;  ///< Offset: 0x20 - trigger register
        volatile uint32_t CONFIG;  ///< Offset: 0x24 - trace configuration register
        volatile uint32_t FILTER_CONTROL;  ///< Offset: 0x28 - filter control register
        volatile uint32_t FILTER_MATCH_CONTROL;  ///< Offset: 0x2C - filter match control register
        volatile uint32_t FILTER_COMPARATOR_CONTROL;  ///< Offset: 0x30 - filter comparator match control register
        volatile uint32_t FILTER_P_COMPARATOR_MATCH;  ///< Offset: 0x34 - primary comparator match value
        volatile uint32_t FILTER_S_COMPARATOR_MATCH;  ///< Offset: 0x38 - secondary comparator match value
        volatile uint32_t RESYNC_PROLONGED;  ///< Offset: 0x3C - resync configuration register
        volatile uint32_t AHB_CONFIG;  ///< Offset: 0x40 - AHB config register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x44 - Clock gate control register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* TRACE0 = reinterpret_cast<Registers*>(TRACE0_BASE);

    // Bit definitions
    /// MEM_START_ADDR Register bits
    namespace mem_start_addr_bits {
        constexpr uint32_t MEM_START_ADDR = (32 << 0);  ///< The start address of trace memory
    }

    /// MEM_END_ADDR Register bits
    namespace mem_end_addr_bits {
        constexpr uint32_t MEM_END_ADDR = (32 << 0);  ///< The end address of trace memory
    }

    /// MEM_CURRENT_ADDR Register bits
    namespace mem_current_addr_bits {
        constexpr uint32_t MEM_CURRENT_ADDR = (32 << 0);  ///< current_mem_addr,indicate that next writing addr
    }

    /// MEM_ADDR_UPDATE Register bits
    namespace mem_addr_update_bits {
        constexpr uint32_t MEM_CURRENT_ADDR_UPDATE = (1U << 0);  ///< when set, the will \hyperref[fielddesc:TRACEMEMCURRENTADDR]{TRACE_MEM_CURRENT_ADDR} update to \hyperref[fielddesc:TRACEMEMSTARTADDR]{TRACE_MEM_START_ADDR}.
    }

    /// FIFO_STATUS Register bits
    namespace fifo_status_bits {
        constexpr uint32_t FIFO_EMPTY = (1U << 0);  ///< Represent whether the fifo is empty. \\1: empty \\0: not empty
        constexpr uint32_t WORK_STATUS = (2 << 1);  ///< Represent trace work status: \\0: idle state \\1: working state\\ 2: wait state due to hart halted or havereset \\3: lost state
    }

    /// INTR_ENA Register bits
    namespace intr_ena_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_ENA = (1U << 0);  ///< Set 1 enable fifo_overflow interrupt
        constexpr uint32_t MEM_FULL_INTR_ENA = (1U << 1);  ///< Set 1 enable mem_full interrupt
    }

    /// INTR_RAW Register bits
    namespace intr_raw_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_RAW = (1U << 0);  ///< fifo_overflow interrupt status
        constexpr uint32_t MEM_FULL_INTR_RAW = (1U << 1);  ///< mem_full interrupt status
    }

    /// INTR_CLR Register bits
    namespace intr_clr_bits {
        constexpr uint32_t FIFO_OVERFLOW_INTR_CLR = (1U << 0);  ///< Set 1 clear fifo overflow interrupt
        constexpr uint32_t MEM_FULL_INTR_CLR = (1U << 1);  ///< Set 1 clear mem full interrupt
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t ON = (1U << 0);  ///< Configure whether or not start trace.\\1: start trace \\0: invalid\\
        constexpr uint32_t OFF = (1U << 1);  ///< Configure whether or not stop trace.\\1: stop trace \\0: invalid\\
        constexpr uint32_t MEM_LOOP = (1U << 2);  ///< Configure memory loop mode. \\1: trace will loop wrtie trace_mem. \\0: when mem_current_addr at mem_end_addr, it will stop at the mem_end_addr\\
        constexpr uint32_t RESTART_ENA = (1U << 3);  ///< Configure whether or not enable auto-restart.\\1: enable\\0: disable\\
    }

    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t DM_TRIGGER_ENA = (1U << 0);  ///< Configure whether or not enable cpu trigger action.\\1: enable\\0:disable\\
        constexpr uint32_t RESET_ENA = (1U << 1);  ///< Configure whether or not enable trace cpu haverest, when enabeld, if cpu have reset, the encoder will output a packet to report the address of the last instruction, and upon reset deassertion, the encoder start again.\\1: enabeld\\0: disabled\\
        constexpr uint32_t HALT_ENA = (1U << 2);  ///< Configure whether or not enable trace cpu is halted, when enabeld, if the cpu halted, the encoder will output a packet to report the address of the last instruction, and upon halted deassertion, the encoder start again.When disabled, encoder will not report the last address before halted and first address after halted, cpu halted information will not be tracked. \\1: enabeld\\0: disabled\\
        constexpr uint32_t STALL_ENA = (1U << 3);  ///< Configure whether or not enable stall cpu. When enabled, when the fifo almost full, the cpu will be stalled until the packets is able to write to fifo.\\1: enabled.\\0: disabled\\
        constexpr uint32_t FULL_ADDRESS = (1U << 4);  ///< Configure whether or not enable full-address mode.\\1: full address mode.\\0: delta address mode\\
        constexpr uint32_t IMPLICIT_EXCEPT = (1U << 5);  ///< Configure whether or not enabel implicit exception mode. When enabled,, do not sent exception address, only exception cause in exception packets.\\1: enabled\\0: disabled\\
    }

    /// FILTER_CONTROL Register bits
    namespace filter_control_bits {
        constexpr uint32_t FILTER_EN = (1U << 0);  ///< Configure whether or not enable filter unit. \\1: enable filter.\\ 0: always match
        constexpr uint32_t MATCH_COMP = (1U << 1);  ///< when set, the comparator must be high in order for the filter to match
        constexpr uint32_t MATCH_PRIVILEGE = (1U << 2);  ///< when set, match privilege levels specified by \hyperref[fielddesc:TRACEMATCHCHOICEPRIVILEGE]{TRACE_MATCH_CHOICE_PRIVILEGE}.
        constexpr uint32_t MATCH_ECAUSE = (1U << 3);  ///< when set, start matching from exception cause codes specified by \hyperref[fielddesc:TRACEMATCHCHOICEECAUSE]{TRACE_MATCH_CHOICE_ECAUSE}, and stop matching upon return from the 1st matching exception.
        constexpr uint32_t MATCH_INTERRUPT = (1U << 4);  ///< when set, start matching from a trap with the interrupt level codes specified by \hyperref[fielddesc:TRACEMATCHVALUEINTERRUPT]{TRACE_MATCH_VALUE_INTERRUPT}, and stop matching upon return from the 1st matching trap.
    }

    /// FILTER_MATCH_CONTROL Register bits
    namespace filter_match_control_bits {
        constexpr uint32_t MATCH_CHOICE_PRIVILEGE = (1U << 0);  ///< Select match which privilege level when \hyperref[fielddesc:TRACEMATCHPRIVILEGE]{TRACE_MATCH_PRIVILEGE} is set. \\1: machine mode. \\0: user mode
        constexpr uint32_t MATCH_VALUE_INTERRUPT = (1U << 1);  ///< Select which match which itype when \hyperref[fielddesc:TRACEMATCHINTERRUPT]{TRACE_MATCH_INTERRUP} is set. \\1: match itype of 2. \\0: match itype or 1.
        constexpr uint32_t MATCH_CHOICE_ECAUSE = (6 << 2);  ///< specified which ecause matched.
    }

    /// FILTER_COMPARATOR_CONTROL Register bits
    namespace filter_comparator_control_bits {
        constexpr uint32_t P_INPUT = (1U << 0);  ///< Determines which input to compare against the primary comparator, \\0: iaddr, \\1: tval.
        constexpr uint32_t P_FUNCTION = (3 << 2);  ///< Select the primary comparator function. \\0: equal, \\1: not equal, \\2: less than, \\3: less than or equal, \\4: greater than, \\5: greater than or equal, \\other: always match
        constexpr uint32_t P_NOTIFY = (1U << 5);  ///< Generate a trace packet explicitly reporting the address that cause the primary match
        constexpr uint32_t S_INPUT = (1U << 8);  ///< Determines which input to compare against the secondary comparator, \\0: iaddr, \\1: tval.
        constexpr uint32_t S_FUNCTION = (3 << 10);  ///< Select the secondary comparator function. \\0: equal, \\1: not equal, \\2: less than, \\3: less than or equal, \\4: greater than, \\5: greater than or equal, \\other: always match
        constexpr uint32_t S_NOTIFY = (1U << 13);  ///< Generate a trace packet explicitly reporting the address that cause the secondary match
        constexpr uint32_t MATCH_MODE = (2 << 16);  ///< 0: only primary matches, \\1: primary and secondary comparator both matches(P\&\&S),\\ 2:either primary or secondary comparator matches !(P\&\&S), \\3: set when primary matches and continue to match until after secondary comparator matches
    }

    /// FILTER_P_COMPARATOR_MATCH Register bits
    namespace filter_p_comparator_match_bits {
        constexpr uint32_t P_MATCH = (32 << 0);  ///< primary comparator match value
    }

    /// FILTER_S_COMPARATOR_MATCH Register bits
    namespace filter_s_comparator_match_bits {
        constexpr uint32_t S_MATCH = (32 << 0);  ///< secondary comparator match value
    }

    /// RESYNC_PROLONGED Register bits
    namespace resync_prolonged_bits {
        constexpr uint32_t RESYNC_PROLONGED = (24 << 0);  ///< count number, when count to this value, send a sync package
        constexpr uint32_t RESYNC_MODE = (2 << 24);  ///< resyc mode sel: \\0: off, \\2: cycle count \\3: package num count
    }

    /// AHB_CONFIG Register bits
    namespace ahb_config_bits {
        constexpr uint32_t HBURST = (3 << 0);  ///< set hburst
        constexpr uint32_t MAX_INCR = (3 << 3);  ///< set max continuous access for incr mode
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< The bit is used to enable clock gate when access all registers in this module.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version control register. Note that this default value stored is the latest date when the hardware logic was updated.
    }

}

// ============================================================================
// TRACE1 Peripheral
// ============================================================================

namespace trace1 {
    /// Base addresses
    constexpr uint32_t TRACE1_BASE = 0x3FF05000;

    /// TRACE1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* TRACE1 = reinterpret_cast<Registers*>(TRACE1_BASE);

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x500D7000;
    constexpr uint32_t TWAI1_BASE = 0x500D8000;
    constexpr uint32_t TWAI2_BASE = 0x500D9000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - TWAI mode register.
        volatile uint32_t CMD;  ///< Offset: 0x04 - TWAI command register.
        volatile uint32_t STATUS;  ///< Offset: 0x08 - TWAI status register.
        volatile uint32_t INTERRUPT;  ///< Offset: 0x0C - Interrupt signals' register.
        volatile uint32_t INTERRUPT_ENABLE;  ///< Offset: 0x10 - Interrupt enable register.
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bit timing configuration register 0.
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bit timing configuration register 1.
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - TWAI arbiter lost capture register.
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - TWAI error info capture register.
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - TWAI error threshold configuration register.
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Rx error counter register.
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Tx error counter register.
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0.
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1.
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2.
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3.
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4.
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5.
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6.
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7.
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8.
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9.
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10.
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11.
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12.
        volatile uint32_t RX_MESSAGE_COUNTER;  ///< Offset: 0x74 - Received message counter register.
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock divider register.
        volatile uint32_t SW_STANDBY_CFG;  ///< Offset: 0x80 - Software configure standby pin directly.
        volatile uint32_t HW_CFG;  ///< Offset: 0x84 - Hardware configure standby pin.
        volatile uint32_t HW_STANDBY_CNT;  ///< Offset: 0x88 - Configure standby counter.
        volatile uint32_t IDLE_INTR_CNT;  ///< Offset: 0x8C - Configure idle interrupt counter.
        volatile uint32_t ECO_CFG;  ///< Offset: 0x90 - ECO configuration register.
        volatile uint32_t TIMESTAMP_DATA;  ///< Offset: 0x94 - Timestamp data register
        volatile uint32_t TIMESTAMP_PRESCALER;  ///< Offset: 0x98 - Timestamp configuration register
        volatile uint32_t TIMESTAMP_CFG;  ///< Offset: 0x9C - Timestamp configuration register
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);
    inline Registers* TWAI1 = reinterpret_cast<Registers*>(TWAI1_BASE);
    inline Registers* TWAI2 = reinterpret_cast<Registers*>(TWAI2_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< 1: reset, detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode. 0: normal, on the '1-to-0' transition of the reset mode bit, the TWAI controller returns to the operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: listen only, in this mode the TWAI controller would give no acknowledge to the TWAI-bus, even if a message is received successfully. The error counters are stopped at the current value. 0: normal.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: self test, in this mode a full node test is possible without any other active node on the bus using the self reception request command. The TWAI controller will perform a successful transmission, even if there is no acknowledge received. 0: normal, an acknowledge is required for successful transmission.
        constexpr uint32_t ACCEPTANCE_FILTER_MODE = (1U << 3);  ///< 1:single, the single acceptance filter option is enabled (one filter with the length of 32 bit is active). 0:dual, the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active).
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQUEST = (1U << 0);  ///< 1: present, a message shall be transmitted. 0: absent
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< 1: present, if not already in progress, a pending transmission request is cancelled. 0: absent
        constexpr uint32_t RELEASE_BUFFER = (1U << 2);  ///< 1: released, the receive buffer, representing the message memory space in the RXFIFO is released. 0: no action
        constexpr uint32_t CLEAR_DATA_OVERRUN = (1U << 3);  ///< 1: clear, the data overrun status bit is cleared. 0: no action.
        constexpr uint32_t SELF_RX_REQUEST = (1U << 4);  ///< 1: present, a message shall be transmitted and received simultaneously. 0: absent.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RECEIVE_BUFFER = (1U << 0);  ///< 1: full, one or more complete messages are available in the RXFIFO. 0: empty, no message is available
        constexpr uint32_t OVERRUN = (1U << 1);  ///< 1: overrun, a message was lost because there was not enough space for that message in the RXFIFO. 0: absent, no data overrun has occurred since the last clear data overrun command was given
        constexpr uint32_t TRANSMIT_BUFFER = (1U << 2);  ///< 1: released, the CPU may write a message into the transmit buffer. 0: locked, the CPU cannot access the transmit buffer, a message is either waiting for transmission or is in the process of being transmitted
        constexpr uint32_t TRANSMISSION_COMPLETE = (1U << 3);  ///< 1: complete, last requested transmission has been successfully completed. 0: incomplete, previously requested transmission is not yet completed
        constexpr uint32_t RECEIVE = (1U << 4);  ///< 1: receive, the TWAI controller is receiving a message. 0: idle
        constexpr uint32_t TRANSMIT = (1U << 5);  ///< 1: transmit, the TWAI controller is transmitting a message. 0: idle
        constexpr uint32_t ERR = (1U << 6);  ///< 1: error, at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR). 0: ok, both error counters are below the warning limit
        constexpr uint32_t NODE_BUS_OFF = (1U << 7);  ///< 1: bus-off, the TWAI controller is not involved in bus activities. 0: bus-on, the TWAI controller is involved in bus activities
        constexpr uint32_t MISS = (1U << 8);  ///< 1: current message is destroyed because of FIFO overflow.
    }

    /// INTERRUPT Register bits
    namespace interrupt_bits {
        constexpr uint32_t RECEIVE_INT_ST = (1U << 0);  ///< 1: this bit is set while the receive FIFO is not empty and the RIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t TRANSMIT_INT_ST = (1U << 1);  ///< 1: this bit is set whenever the transmit buffer status changes from '0-to-1' (released) and the TIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t ERR_WARNING_INT_ST = (1U << 2);  ///< 1: this bit is set on every change (set and clear) of either the error status or bus status bits and the EIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t DATA_OVERRUN_INT_ST = (1U << 3);  ///< 1: this bit is set on a '0-to-1' transition of the data overrun status bit and the DOIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t TS_COUNTER_OVFL_INT_ST = (1U << 4);  ///< 1: this bit is set then the timestamp counter reaches the maximum value and overflow.
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< 1: this bit is set whenever the TWAI controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the TWAI controller is in the error passive status and enters the error active status again and the EPIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 6);  ///< 1: this bit is set when the TWAI controller lost the arbitration and becomes a receiver and the ALIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< 1: this bit is set when the TWAI controller detects an error on the TWAI-bus and the BEIE bit is set within the interrupt enable register. 0: reset
        constexpr uint32_t IDLE_INT_ST = (1U << 8);  ///< 1: this bit is set when the TWAI controller detects state of TWAI become IDLE and this interrupt enable bit is set within the interrupt enable register. 0: reset
    }

    /// INTERRUPT_ENABLE Register bits
    namespace interrupt_enable_bits {
        constexpr uint32_t EXT_RECEIVE_INT_ENA = (1U << 0);  ///< 1: enabled, when the receive buffer status is 'full' the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t EXT_TRANSMIT_INT_ENA = (1U << 1);  ///< 1: enabled, when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t EXT_ERR_WARNING_INT_ENA = (1U << 2);  ///< 1: enabled, if the error or bus status change (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
        constexpr uint32_t EXT_DATA_OVERRUN_INT_ENA = (1U << 3);  ///< 1: enabled, if the data overrun status bit is set (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
        constexpr uint32_t TS_COUNTER_OVFL_INT_ENA = (1U << 4);  ///< enable the timestamp counter overflow interrupt request.
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< 1: enabled, if the error status of the TWAI controller changes from error active to error passive or vice versa, the respective interrupt is requested. 0: disable
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 6);  ///< 1: enabled, if the TWAI controller has lost arbitration, the respective interrupt is requested. 0: disable
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< 1: enabled, if an bus error has been detected, the TWAI controller requests the respective interrupt. 0: disable
        constexpr uint32_t IDLE_INT_ENA = (1U << 8);  ///< 1: enabled, if state of TWAI become IDLE, the TWAI controller requests the respective interrupt. 0: disable
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (14 << 0);  ///< The period of the TWAI system clock is programmable and determines the individual bit timing. Software has R/W permission in reset mode and RO permission in operation mode.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 14);  ///< The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEGMENT1 = (4 << 0);  ///< The number of clock cycles in TSEG1 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
        constexpr uint32_t TIME_SEGMENT2 = (3 << 4);  ///< The number of clock cycles in TSEG2 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
        constexpr uint32_t TIME_SAMPLING = (1U << 7);  ///< 1: triple, the bus is sampled three times. 0: single, the bus is sampled once. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARBITRATION_LOST_CAPTURE = (5 << 0);  ///< This register contains information about the bit position of losing arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ERR_CAPTURE_CODE_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors on the bus.
        constexpr uint32_t ERR_CAPTURE_CODE_DIRECTION = (1U << 5);  ///< 1: RX, error occurred during reception. 0: TX, error occurred during transmission.
        constexpr uint32_t ERR_CAPTURE_CODE_TYPE = (2 << 6);  ///< 00: bit error. 01: form error. 10:stuff error. 11:other type of error.
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< The threshold that trigger error warning interrupt when this interrupt is enabled. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t DATA_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 0 and when software initiate read operation, it is rx data register 0.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t DATA_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 1 and when software initiate read operation, it is rx data register 1.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t DATA_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 2 and when software initiate read operation, it is rx data register 2.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t DATA_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 3 and when software initiate read operation, it is rx data register 3.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t DATA_4 = (8 << 0);  ///< In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 4 and when software initiate read operation, it is rx data register 4.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t DATA_5 = (8 << 0);  ///< In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 5 and when software initiate read operation, it is rx data register 5.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t DATA_6 = (8 << 0);  ///< In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 6 and when software initiate read operation, it is rx data register 6.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t DATA_7 = (8 << 0);  ///< In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 7 and when software initiate read operation, it is rx data register 7.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t DATA_8 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 8 and when software initiate read operation, it is rx data register 8.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t DATA_9 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 9 and when software initiate read operation, it is rx data register 9.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t DATA_10 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 10 and when software initiate read operation, it is rx data register 10.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t DATA_11 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 11 and when software initiate read operation, it is rx data register 11.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t DATA_12 = (8 << 0);  ///< In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 12 and when software initiate read operation, it is rx data register 12.
    }

    /// RX_MESSAGE_COUNTER Register bits
    namespace rx_message_counter_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to define the frequency at the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< 1: Disable the external CLKOUT pin. 0: Enable the external CLKOUT pin. Software has R/W permission in reset mode and RO in operation mode.
    }

    /// SW_STANDBY_CFG Register bits
    namespace sw_standby_cfg_bits {
        constexpr uint32_t SW_STANDBY_EN = (1U << 0);  ///< Enable standby pin.
        constexpr uint32_t SW_STANDBY_CLR = (1U << 1);  ///< Clear standby pin.
    }

    /// HW_CFG Register bits
    namespace hw_cfg_bits {
        constexpr uint32_t HW_STANDBY_EN = (1U << 0);  ///< Enable function that hardware control standby pin.
    }

    /// HW_STANDBY_CNT Register bits
    namespace hw_standby_cnt_bits {
        constexpr uint32_t STANDBY_WAIT_CNT = (32 << 0);  ///< Configure the number of cycles before standby becomes high when TWAI_HW_STANDBY_EN is enabled.
    }

    /// IDLE_INTR_CNT Register bits
    namespace idle_intr_cnt_bits {
        constexpr uint32_t IDLE_INTR_CNT = (32 << 0);  ///< Configure the number of cycles before triggering idle interrupt.
    }

    /// ECO_CFG Register bits
    namespace eco_cfg_bits {
        constexpr uint32_t RDN_ENA = (1U << 0);  ///< Enable eco module.
        constexpr uint32_t RDN_RESULT = (1U << 1);  ///< Output of eco module.
    }

    /// TIMESTAMP_DATA Register bits
    namespace timestamp_data_bits {
        constexpr uint32_t TIMESTAMP_DATA = (32 << 0);  ///< Data of timestamp of a CAN frame.
    }

    /// TIMESTAMP_PRESCALER Register bits
    namespace timestamp_prescaler_bits {
        constexpr uint32_t TS_DIV_NUM = (16 << 0);  ///< Configures the clock division number of timestamp counter.
    }

    /// TIMESTAMP_CFG Register bits
    namespace timestamp_cfg_bits {
        constexpr uint32_t TS_ENABLE = (1U << 0);  ///< enable the timestamp collection function.
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x500DF000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - UHCI Configuration Register0
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - UHCI Interrupt Raw Register
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - UHCI Interrupt Status Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - UHCI Interrupt Enable Register
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - UHCI Interrupt Clear Register
        volatile uint32_t CONF1;  ///< Offset: 0x14 - UHCI Configuration Register1
        volatile uint32_t STATE0;  ///< Offset: 0x18 - UHCI Receive Status Register
        volatile uint32_t STATE1;  ///< Offset: 0x1C - UHCI Transmit Status Register
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x20 - UHCI Escapes Configuration Register0
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x24 - UHCI Hung Configuration Register0
        volatile uint32_t ACK_NUM;  ///< Offset: 0x28 - UHCI Ack Value Configuration Register0
        volatile uint32_t RX_HEAD;  ///< Offset: 0x2C - UHCI Head Register
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x30 - UCHI Quick send Register
        volatile uint32_t REG_Q0_WORD0;  ///< Offset: 0x34 - UHCI Q0_WORD0 Quick Send Register
        volatile uint32_t REG_Q0_WORD1;  ///< Offset: 0x38 - UHCI Q0_WORD1 Quick Send Register
        volatile uint32_t REG_Q1_WORD0;  ///< Offset: 0x3C - UHCI Q1_WORD0 Quick Send Register
        volatile uint32_t REG_Q1_WORD1;  ///< Offset: 0x40 - UHCI Q1_WORD1 Quick Send Register
        volatile uint32_t REG_Q2_WORD0;  ///< Offset: 0x44 - UHCI Q2_WORD0 Quick Send Register
        volatile uint32_t REG_Q2_WORD1;  ///< Offset: 0x48 - UHCI Q2_WORD1 Quick Send Register
        volatile uint32_t REG_Q3_WORD0;  ///< Offset: 0x4C - UHCI Q3_WORD0 Quick Send Register
        volatile uint32_t REG_Q3_WORD1;  ///< Offset: 0x50 - UHCI Q3_WORD1 Quick Send Register
        volatile uint32_t REG_Q4_WORD0;  ///< Offset: 0x54 - UHCI Q4_WORD0 Quick Send Register
        volatile uint32_t REG_Q4_WORD1;  ///< Offset: 0x58 - UHCI Q4_WORD1 Quick Send Register
        volatile uint32_t REG_Q5_WORD0;  ///< Offset: 0x5C - UHCI Q5_WORD0 Quick Send Register
        volatile uint32_t REG_Q5_WORD1;  ///< Offset: 0x60 - UHCI Q5_WORD1 Quick Send Register
        volatile uint32_t REG_Q6_WORD0;  ///< Offset: 0x64 - UHCI Q6_WORD0 Quick Send Register
        volatile uint32_t REG_Q6_WORD1;  ///< Offset: 0x68 - UHCI Q6_WORD1 Quick Send Register
        volatile uint32_t ESC_CONF0;  ///< Offset: 0x6C - UHCI Escapes Sequence Configuration Register0
        volatile uint32_t ESC_CONF1;  ///< Offset: 0x70 - UHCI Escapes Sequence Configuration Register1
        volatile uint32_t ESC_CONF2;  ///< Offset: 0x74 - UHCI Escapes Sequence Configuration Register2
        volatile uint32_t ESC_CONF3;  ///< Offset: 0x78 - UHCI Escapes Sequence Configuration Register3
        volatile uint32_t PKT_THRES;  ///< Offset: 0x7C - UCHI Packet Length Configuration Register
        volatile uint32_t DATE;  ///< Offset: 0x80 - UHCI Version Register
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t TX_RST = (1U << 0);  ///< Write 1 then write 0 to this bit to reset decode state machine.
        constexpr uint32_t RX_RST = (1U << 1);  ///< Write 1 then write 0 to this bit to reset encode state machine.
        constexpr uint32_t UART_SEL = (3 << 2);  ///< Select which uart to connect with GDMA.
        constexpr uint32_t SEPER_EN = (1U << 5);  ///< Set this bit to separate the data frame using a special char.
        constexpr uint32_t HEAD_EN = (1U << 6);  ///< Set this bit to encode the data packet with a formatting header.
        constexpr uint32_t CRC_REC_EN = (1U << 7);  ///< Set this bit to enable UHCI to receive the 16 bit CRC.
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 8);  ///< If this bit is set to 1 UHCI will end the payload receiving process when UART has been in idle state.
        constexpr uint32_t LEN_EOF_EN = (1U << 9);  ///< If this bit is set to 1 UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0 UHCI decoder receiving payload data is end when 0xc0 is received.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 10);  ///< Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
        constexpr uint32_t CLK_EN = (1U << 11);  ///< 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 12);  ///< If this bit is set to 1 UHCI will end payload receive process when NULL frame is received by UART.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< Indicates the raw interrupt of UHCI_RX_START_INT. Interrupt will be triggered when delimiter is sent successfully.
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< Indicates the raw interrupt of UHCI_TX_START_INT. Interrupt will be triggered when DMA detects delimiter.
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< Indicates the raw interrupt of UHCI_RX_HUNG_INT. Interrupt will be triggered when the required time of DMA receiving data exceeds the configuration value.
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< Indicates the raw interrupt of UHCI_TX_HUNG_INT. Interrupt will be triggered when the required time of DMA reading RAM data exceeds the configuration value.
        constexpr uint32_t SEND_S_REG_Q_INT_RAW = (1U << 4);  ///< Indicates the raw interrupt of UHCI_SEND_S_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with single_send mode.
        constexpr uint32_t SEND_A_REG_Q_INT_RAW = (1U << 5);  ///< Indicates the raw interrupt of UHCI_SEND_A_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with always_send mode.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 6);  ///< Indicates the raw interrupt of UHCI_OUT_EOF_INT. Interrupt will be triggered when there are errors in EOF.
        constexpr uint32_t APP_CTRL0_INT_RAW = (1U << 7);  ///< Indicates the raw interrupt of UHCI_APP_CTRL0_INT. Interrupt will be triggered when UHCI_APP_CTRL0_IN_SET is set to 1.
        constexpr uint32_t APP_CTRL1_INT_RAW = (1U << 8);  ///< Indicates the raw interrupt of UHCI_APP_CTRL1_INT. Interrupt will be triggered when UHCI_APP_CTRL1_IN_SET is set to 1.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< Indicates the interrupt status of UHCI_RX_START_INT.
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< Indicates the interrupt status of UHCI_TX_START_INT.
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< Indicates the interrupt status of UHCI_RX_HUNG_INT.
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< Indicates the interrupt status of UHCI_TX_HUNG_INT.
        constexpr uint32_t SEND_S_REG_Q_INT_ST = (1U << 4);  ///< Indicates the interrupt status of UHCI_SEND_S_REG_Q_INT.
        constexpr uint32_t SEND_A_REG_Q_INT_ST = (1U << 5);  ///< Indicates the interrupt status of UHCI_SEND_A_REG_Q_INT.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 6);  ///< Indicates the interrupt status of UHCI_OUT_EOF_INT.
        constexpr uint32_t APP_CTRL0_INT_ST = (1U << 7);  ///< Indicates the interrupt status of UHCI_APP_CTRL0_INT.
        constexpr uint32_t APP_CTRL1_INT_ST = (1U << 8);  ///< Indicates the interrupt status of UHCI_APP_CTRL1_INT.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< Set this bit to enable the interrupt of UHCI_RX_START_INT.
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< Set this bit to enable the interrupt of UHCI_TX_START_INT.
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< Set this bit to enable the interrupt of UHCI_RX_HUNG_INT.
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< Set this bit to enable the interrupt of UHCI_TX_HUNG_INT.
        constexpr uint32_t SEND_S_REG_Q_INT_ENA = (1U << 4);  ///< Set this bit to enable the interrupt of UHCI_SEND_S_REG_Q_INT.
        constexpr uint32_t SEND_A_REG_Q_INT_ENA = (1U << 5);  ///< Set this bit to enable the interrupt of UHCI_SEND_A_REG_Q_INT.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 6);  ///< Set this bit to enable the interrupt of UHCI_OUT_EOF_INT.
        constexpr uint32_t APP_CTRL0_INT_ENA = (1U << 7);  ///< Set this bit to enable the interrupt of UHCI_APP_CTRL0_INT.
        constexpr uint32_t APP_CTRL1_INT_ENA = (1U << 8);  ///< Set this bit to enable the interrupt of UHCI_APP_CTRL1_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< Set this bit to clear the raw interrupt of UHCI_RX_START_INT.
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< Set this bit to clear the raw interrupt of UHCI_TX_START_INT.
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear the raw interrupt of UHCI_RX_HUNG_INT.
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear the raw interrupt of UHCI_TX_HUNG_INT.
        constexpr uint32_t SEND_S_REG_Q_INT_CLR = (1U << 4);  ///< Set this bit to clear the raw interrupt of UHCI_SEND_S_REG_Q_INT.
        constexpr uint32_t SEND_A_REG_Q_INT_CLR = (1U << 5);  ///< Set this bit to clear the raw interrupt of UHCI_SEND_A_REG_Q_INT.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear the raw interrupt of UHCI_OUT_EOF_INT.
        constexpr uint32_t APP_CTRL0_INT_CLR = (1U << 7);  ///< Set this bit to clear the raw interrupt of UHCI_APP_CTRL0_INT.
        constexpr uint32_t APP_CTRL1_INT_CLR = (1U << 8);  ///< Set this bit to clear the raw interrupt of UHCI_APP_CTRL1_INT.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< Set this bit to enable head checksum check when receiving.
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< Set this bit to enable sequence number check when receiving.
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< Set this bit to support CRC calculation, and data integrity check bit should 1.
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< Set this bit to save data packet head when UHCI receive data.
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< Set this bit to encode data packet with checksum.
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< Set this bit to encode data packet with ACK when reliable data packet is ready.
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< Set this bit to enable UHCI encoder transfer to ST_SW_WAIT status.
        constexpr uint32_t SW_START = (1U << 8);  ///< Set this bit to transmit data packet if UCHI_ENCODE_STATE is ST_SW_WAIT.
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t RX_ERR_CAUSE = (3 << 0);  ///< Indicates the error types when DMA receives the error frame. 3'b001: UHCI packet checksum error. 3'b010: UHCI packet sequence number error. 3'b011: UHCI packet CRC bit error. 3'b100: find 0xC0, but received packet is uncompleted. 3'b101: 0xC0 is not found, but received packet is completed. 3'b110: CRC check error.
        constexpr uint32_t DECODE_STATE = (3 << 3);  ///< Indicates UHCI decoder status.
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t ENCODE_STATE = (3 << 0);  ///< Indicates UHCI encoder status.
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< Set this bit to enable resolve char 0xC0 when DMA receiving data.
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< Set this bit to enable resolve char 0xDB when DMA receiving data.
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< Set this bit to enable resolve flow control char 0x11 when DMA receiving data.
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< Set this bit to enable resolve flow control char 0x13 when DMA receiving data.
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< Set this bit to enable replacing 0xC0 with special char when DMA receiving data.
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< Set this bit to enable replacing 0xDB with special char when DMA receiving data.
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< Set this bit to enable replacing 0x11 with special char when DMA receiving data.
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< Set this bit to enable replacing 0x13 with special char when DMA receiving data.
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when receiving data.
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< Configures the maximum counter value.
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< Set this bit to enable TX FIFO timeout when receiving.
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when reading RAM data.
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< Configures the maximum counter value.
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< Set this bit to enable TX FIFO timeout when DMA sending data.
    }

    /// ACK_NUM Register bits
    namespace ack_num_bits {
        constexpr uint32_t ACK_NUM = (3 << 0);  ///< Indicates the ACK number during software flow control.
        constexpr uint32_t LOAD = (1U << 3);  ///< Set this bit to load the ACK value of UHCI_ACK_NUM.
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< Stores the head of received packet.
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< Configures single_send mode.
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< Set this bit to enable sending short packet with single_send mode.
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< Configures always_send mode.
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< Set this bit to enable sending short packet with always_send mode.
    }

    /// REG_Q0_WORD0 Register bits
    namespace reg_q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q0_WORD1 Register bits
    namespace reg_q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q1_WORD0 Register bits
    namespace reg_q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q1_WORD1 Register bits
    namespace reg_q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q2_WORD0 Register bits
    namespace reg_q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q2_WORD1 Register bits
    namespace reg_q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q3_WORD0 Register bits
    namespace reg_q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q3_WORD1 Register bits
    namespace reg_q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q4_WORD0 Register bits
    namespace reg_q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q4_WORD1 Register bits
    namespace reg_q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q5_WORD0 Register bits
    namespace reg_q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q5_WORD1 Register bits
    namespace reg_q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q6_WORD0 Register bits
    namespace reg_q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q6_WORD1 Register bits
    namespace reg_q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< Configures the delimiter for encoding, default value is 0xC0.
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< Configures the first char of SLIP escape character, default value is 0xDB.
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< Configures the second char of SLIP escape character, default value is 0xDC.
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< Configures the char needing encoding, which is 0xDB as flow control char by default.
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< Configures the first char of SLIP escape character, default value is 0xDB.
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< Configures the second char of SLIP escape character, default value is 0xDD.
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< Configures the char needing encoding, which is 0x11 as flow control char by default.
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< Configures the first char of SLIP escape character, default value is 0xDB.
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< Configures the second char of SLIP escape character, default value is 0xDE.
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< Configures the char needing encoding, which is 0x13 as flow control char by default.
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< Configures the first char of SLIP escape character, default value is 0xDB.
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< Configures the second char of SLIP escape character, default value is 0xDF.
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< Configures the data packet's maximum length when UHCI_HEAD_EN is 0.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Configures version.
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB_DEVICE_BASE = 0x500D2000;
    constexpr uint32_t USB_WRAP_BASE = 0x50080000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t EP1;  ///< Offset: 0x00 - FIFO access for the CDC-ACM data IN and OUT endpoints.
        volatile uint32_t EP1_CONF;  ///< Offset: 0x04 - Configuration and control registers for the CDC-ACM FIFOs.
        volatile uint32_t INT_RAW;  ///< Offset: 0x08 - Interrupt raw status register.
        volatile uint32_t INT_ST;  ///< Offset: 0x0C - Interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt enable status register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x14 - Interrupt clear status register.
        volatile uint32_t CONF0;  ///< Offset: 0x18 - PHY hardware configuration.
        volatile uint32_t TEST;  ///< Offset: 0x1C - Registers used for debugging the PHY.
        volatile uint32_t JFIFO_ST;  ///< Offset: 0x20 - JTAG FIFO status and control registers.
        volatile uint32_t FRAM_NUM;  ///< Offset: 0x24 - Last received SOF frame index register.
        volatile uint32_t IN_EP0_ST;  ///< Offset: 0x28 - Control IN endpoint status information.
        volatile uint32_t IN_EP1_ST;  ///< Offset: 0x2C - CDC-ACM IN endpoint status information.
        volatile uint32_t IN_EP2_ST;  ///< Offset: 0x30 - CDC-ACM interrupt IN endpoint status information.
        volatile uint32_t IN_EP3_ST;  ///< Offset: 0x34 - JTAG IN endpoint status information.
        volatile uint32_t OUT_EP0_ST;  ///< Offset: 0x38 - Control OUT endpoint status information.
        volatile uint32_t OUT_EP1_ST;  ///< Offset: 0x3C - CDC-ACM OUT endpoint status information.
        volatile uint32_t OUT_EP2_ST;  ///< Offset: 0x40 - JTAG OUT endpoint status information.
        volatile uint32_t MISC_CONF;  ///< Offset: 0x44 - Clock enable control
        volatile uint32_t MEM_CONF;  ///< Offset: 0x48 - Memory power control
        volatile uint32_t CHIP_RST;  ///< Offset: 0x4C - CDC-ACM chip reset control.
        volatile uint32_t SET_LINE_CODE_W0;  ///< Offset: 0x50 - W0 of SET_LINE_CODING command.
        volatile uint32_t SET_LINE_CODE_W1;  ///< Offset: 0x54 - W1 of SET_LINE_CODING command.
        volatile uint32_t GET_LINE_CODE_W0;  ///< Offset: 0x58 - W0 of GET_LINE_CODING command.
        volatile uint32_t GET_LINE_CODE_W1;  ///< Offset: 0x5C - W1 of GET_LINE_CODING command.
        volatile uint32_t CONFIG_UPDATE;  ///< Offset: 0x60 - Configuration registers' value update
        volatile uint32_t SER_AFIFO_CONFIG;  ///< Offset: 0x64 - Serial AFIFO configure register
        volatile uint32_t BUS_RESET_ST;  ///< Offset: 0x68 - USB Bus reset status register
        volatile uint32_t ECO_LOW_48;  ///< Offset: 0x6C - Reserved.
        volatile uint32_t ECO_HIGH_48;  ///< Offset: 0x70 - Reserved.
        volatile uint32_t ECO_CELL_CTRL_48;  ///< Offset: 0x74 - Reserved.
        volatile uint32_t ECO_LOW_APB;  ///< Offset: 0x78 - Reserved.
        volatile uint32_t ECO_HIGH_APB;  ///< Offset: 0x7C - Reserved.
        volatile uint32_t ECO_CELL_CTRL_APB;  ///< Offset: 0x80 - Reserved.
        volatile uint32_t SRAM_CTRL;  ///< Offset: 0x84 - PPA SRAM Control Register
        volatile uint32_t DATE;  ///< Offset: 0x88 - Date register
    };

    /// Peripheral instances
    inline Registers* USB_DEVICE = reinterpret_cast<Registers*>(USB_DEVICE_BASE);
    inline Registers* USB_WRAP = reinterpret_cast<Registers*>(USB_WRAP_BASE);

    // Bit definitions
    /// EP1 Register bits
    namespace ep1_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RDWR_BYTE = (8 << 0);  ///< Write and read byte data to/from UART Tx/Rx FIFO through this field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes) into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many data is received, then read data from UART Rx FIFO.
    }

    /// EP1_CONF Register bits
    namespace ep1_conf_bits {
        constexpr uint32_t USB_SERIAL_JTAG_WR_DONE = (1U << 0);  ///< Set this bit to indicate writing byte data to UART Tx FIFO is done.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_EP_DATA_FREE = (1U << 1);  ///< 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is read by USB Host.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_EP_DATA_AVAIL = (1U << 2);  ///< 1'b1: Indicate there is data in UART Rx FIFO.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t USB_SERIAL_JTAG_JTAG_IN_FLUSH_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when flush cmd is received for IN endpoint 2 of JTAG.
        constexpr uint32_t USB_SERIAL_JTAG_SOF_INT_RAW = (1U << 1);  ///< The raw interrupt bit turns to high level when SOF frame is received.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_RECV_PKT_INT_RAW = (1U << 2);  ///< The raw interrupt bit turns to high level when Serial Port OUT Endpoint received one packet.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_EMPTY_INT_RAW = (1U << 3);  ///< The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
        constexpr uint32_t USB_SERIAL_JTAG_PID_ERR_INT_RAW = (1U << 4);  ///< The raw interrupt bit turns to high level when pid error is detected.
        constexpr uint32_t USB_SERIAL_JTAG_CRC5_ERR_INT_RAW = (1U << 5);  ///< The raw interrupt bit turns to high level when CRC5 error is detected.
        constexpr uint32_t USB_SERIAL_JTAG_CRC16_ERR_INT_RAW = (1U << 6);  ///< The raw interrupt bit turns to high level when CRC16 error is detected.
        constexpr uint32_t USB_SERIAL_JTAG_STUFF_ERR_INT_RAW = (1U << 7);  ///< The raw interrupt bit turns to high level when stuff error is detected.
        constexpr uint32_t USB_SERIAL_JTAG_IN_TOKEN_REC_IN_EP1_INT_RAW = (1U << 8);  ///< The raw interrupt bit turns to high level when IN token for IN endpoint 1 is received.
        constexpr uint32_t USB_SERIAL_JTAG_USB_BUS_RESET_INT_RAW = (1U << 9);  ///< The raw interrupt bit turns to high level when usb bus reset is detected.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_ZERO_PAYLOAD_INT_RAW = (1U << 10);  ///< The raw interrupt bit turns to high level when OUT endpoint 1 received packet with zero palyload.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_ZERO_PAYLOAD_INT_RAW = (1U << 11);  ///< The raw interrupt bit turns to high level when OUT endpoint 2 received packet with zero palyload.
        constexpr uint32_t USB_SERIAL_JTAG_RTS_CHG_INT_RAW = (1U << 12);  ///< The raw interrupt bit turns to high level when level of RTS from usb serial channel is changed.
        constexpr uint32_t USB_SERIAL_JTAG_DTR_CHG_INT_RAW = (1U << 13);  ///< The raw interrupt bit turns to high level when level of DTR from usb serial channel is changed.
        constexpr uint32_t USB_SERIAL_JTAG_GET_LINE_CODE_INT_RAW = (1U << 14);  ///< The raw interrupt bit turns to high level when level of GET LINE CODING request is received.
        constexpr uint32_t USB_SERIAL_JTAG_SET_LINE_CODE_INT_RAW = (1U << 15);  ///< The raw interrupt bit turns to high level when level of SET LINE CODING request is received.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_JTAG_IN_FLUSH_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SOF_INT_ST = (1U << 1);  ///< The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_RECV_PKT_INT_ST = (1U << 2);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_EMPTY_INT_ST = (1U << 3);  ///< The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_PID_ERR_INT_ST = (1U << 4);  ///< The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC5_ERR_INT_ST = (1U << 5);  ///< The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC16_ERR_INT_ST = (1U << 6);  ///< The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_STUFF_ERR_INT_ST = (1U << 7);  ///< The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_IN_TOKEN_REC_IN_EP1_INT_ST = (1U << 8);  ///< The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_USB_BUS_RESET_INT_ST = (1U << 9);  ///< The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_ZERO_PAYLOAD_INT_ST = (1U << 10);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_ZERO_PAYLOAD_INT_ST = (1U << 11);  ///< The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_RTS_CHG_INT_ST = (1U << 12);  ///< The raw interrupt status bit for the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_DTR_CHG_INT_ST = (1U << 13);  ///< The raw interrupt status bit for the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_GET_LINE_CODE_INT_ST = (1U << 14);  ///< The raw interrupt status bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SET_LINE_CODE_INT_ST = (1U << 15);  ///< The raw interrupt status bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t USB_SERIAL_JTAG_JTAG_IN_FLUSH_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SOF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_RECV_PKT_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_EMPTY_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_PID_ERR_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC5_ERR_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC16_ERR_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_STUFF_ERR_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_IN_TOKEN_REC_IN_EP1_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_USB_BUS_RESET_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_ZERO_PAYLOAD_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_ZERO_PAYLOAD_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_RTS_CHG_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_DTR_CHG_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_GET_LINE_CODE_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SET_LINE_CODE_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t USB_SERIAL_JTAG_JTAG_IN_FLUSH_INT_CLR = (1U << 0);  ///< Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SOF_INT_CLR = (1U << 1);  ///< Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_RECV_PKT_INT_CLR = (1U << 2);  ///< Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_EMPTY_INT_CLR = (1U << 3);  ///< Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_PID_ERR_INT_CLR = (1U << 4);  ///< Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC5_ERR_INT_CLR = (1U << 5);  ///< Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_CRC16_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_STUFF_ERR_INT_CLR = (1U << 7);  ///< Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_IN_TOKEN_REC_IN_EP1_INT_CLR = (1U << 8);  ///< Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_USB_BUS_RESET_INT_CLR = (1U << 9);  ///< Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_ZERO_PAYLOAD_INT_CLR = (1U << 10);  ///< Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_ZERO_PAYLOAD_INT_CLR = (1U << 11);  ///< Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_RTS_CHG_INT_CLR = (1U << 12);  ///< Set this bit to clear the USB_DEVICE_RTS_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_DTR_CHG_INT_CLR = (1U << 13);  ///< Set this bit to clear the USB_DEVICE_DTR_CHG_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_GET_LINE_CODE_INT_CLR = (1U << 14);  ///< Set this bit to clear the USB_DEVICE_GET_LINE_CODE_INT interrupt.
        constexpr uint32_t USB_SERIAL_JTAG_SET_LINE_CODE_INT_CLR = (1U << 15);  ///< Set this bit to clear the USB_DEVICE_SET_LINE_CODE_INT interrupt.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t USB_SERIAL_JTAG_PHY_SEL = (1U << 0);  ///< Select internal/external PHY
        constexpr uint32_t USB_SERIAL_JTAG_EXCHG_PINS_OVERRIDE = (1U << 1);  ///< Enable software control USB D+ D- exchange
        constexpr uint32_t USB_SERIAL_JTAG_EXCHG_PINS = (1U << 2);  ///< USB D+ D- exchange
        constexpr uint32_t USB_SERIAL_JTAG_VREFH = (2 << 3);  ///< Control single-end input high threshold,1.76V to 2V, step 80mV
        constexpr uint32_t USB_SERIAL_JTAG_VREFL = (2 << 5);  ///< Control single-end input low threshold,0.8V to 1.04V, step 80mV
        constexpr uint32_t USB_SERIAL_JTAG_VREF_OVERRIDE = (1U << 7);  ///< Enable software control input threshold
        constexpr uint32_t USB_SERIAL_JTAG_PAD_PULL_OVERRIDE = (1U << 8);  ///< Enable software control USB D+ D- pullup pulldown
        constexpr uint32_t USB_SERIAL_JTAG_DP_PULLUP = (1U << 9);  ///< Control USB D+ pull up.
        constexpr uint32_t USB_SERIAL_JTAG_DP_PULLDOWN = (1U << 10);  ///< Control USB D+ pull down.
        constexpr uint32_t USB_SERIAL_JTAG_DM_PULLUP = (1U << 11);  ///< Control USB D- pull up.
        constexpr uint32_t USB_SERIAL_JTAG_DM_PULLDOWN = (1U << 12);  ///< Control USB D- pull down.
        constexpr uint32_t USB_SERIAL_JTAG_PULLUP_VALUE = (1U << 13);  ///< Control pull up value.
        constexpr uint32_t USB_SERIAL_JTAG_USB_PAD_ENABLE = (1U << 14);  ///< Enable USB pad function.
        constexpr uint32_t USB_SERIAL_JTAG_USB_JTAG_BRIDGE_EN = (1U << 15);  ///< Set this bit usb_jtag, the connection between usb_jtag and internal JTAG is disconnected, and MTMS, MTDI, MTCK are output through GPIO Matrix, MTDO is input through GPIO Matrix.
    }

    /// TEST Register bits
    namespace test_bits {
        constexpr uint32_t USB_SERIAL_JTAG_TEST_ENABLE = (1U << 0);  ///< Enable test of the USB pad
        constexpr uint32_t USB_SERIAL_JTAG_TEST_USB_OE = (1U << 1);  ///< USB pad oen in test
        constexpr uint32_t USB_SERIAL_JTAG_TEST_TX_DP = (1U << 2);  ///< USB D+ tx value in test
        constexpr uint32_t USB_SERIAL_JTAG_TEST_TX_DM = (1U << 3);  ///< USB D- tx value in test
        constexpr uint32_t USB_SERIAL_JTAG_TEST_RX_RCV = (1U << 4);  ///< USB RCV value in test
        constexpr uint32_t USB_SERIAL_JTAG_TEST_RX_DP = (1U << 5);  ///< USB D+ rx value in test
        constexpr uint32_t USB_SERIAL_JTAG_TEST_RX_DM = (1U << 6);  ///< USB D- rx value in test
    }

    /// JFIFO_ST Register bits
    namespace jfifo_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_IN_FIFO_CNT = (2 << 0);  ///< JTAT in fifo counter.
        constexpr uint32_t USB_SERIAL_JTAG_IN_FIFO_EMPTY = (1U << 2);  ///< 1: JTAG in fifo is empty.
        constexpr uint32_t USB_SERIAL_JTAG_IN_FIFO_FULL = (1U << 3);  ///< 1: JTAG in fifo is full.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_FIFO_CNT = (2 << 4);  ///< JTAT out fifo counter.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_FIFO_EMPTY = (1U << 6);  ///< 1: JTAG out fifo is empty.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_FIFO_FULL = (1U << 7);  ///< 1: JTAG out fifo is full.
        constexpr uint32_t USB_SERIAL_JTAG_IN_FIFO_RESET = (1U << 8);  ///< Write 1 to reset JTAG in fifo.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_FIFO_RESET = (1U << 9);  ///< Write 1 to reset JTAG out fifo.
    }

    /// FRAM_NUM Register bits
    namespace fram_num_bits {
        constexpr uint32_t USB_SERIAL_JTAG_SOF_FRAME_INDEX = (11 << 0);  ///< Frame index of received SOF frame.
    }

    /// IN_EP0_ST Register bits
    namespace in_ep0_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP0_STATE = (2 << 0);  ///< State of IN Endpoint 0.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP0_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 0.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP0_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 0.
    }

    /// IN_EP1_ST Register bits
    namespace in_ep1_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP1_STATE = (2 << 0);  ///< State of IN Endpoint 1.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP1_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 1.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP1_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 1.
    }

    /// IN_EP2_ST Register bits
    namespace in_ep2_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP2_STATE = (2 << 0);  ///< State of IN Endpoint 2.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP2_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 2.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP2_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 2.
    }

    /// IN_EP3_ST Register bits
    namespace in_ep3_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP3_STATE = (2 << 0);  ///< State of IN Endpoint 3.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP3_WR_ADDR = (7 << 2);  ///< Write data address of IN endpoint 3.
        constexpr uint32_t USB_SERIAL_JTAG_IN_EP3_RD_ADDR = (7 << 9);  ///< Read data address of IN endpoint 3.
    }

    /// OUT_EP0_ST Register bits
    namespace out_ep0_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP0_STATE = (2 << 0);  ///< State of OUT Endpoint 0.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP0_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP0_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 0.
    }

    /// OUT_EP1_ST Register bits
    namespace out_ep1_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_STATE = (2 << 0);  ///< State of OUT Endpoint 1.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 1.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP1_REC_DATA_CNT = (7 << 16);  ///< Data count in OUT endpoint 1 when one packet is received.
    }

    /// OUT_EP2_ST Register bits
    namespace out_ep2_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_STATE = (2 << 0);  ///< State of OUT Endpoint 2.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_WR_ADDR = (7 << 2);  ///< Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
        constexpr uint32_t USB_SERIAL_JTAG_OUT_EP2_RD_ADDR = (7 << 9);  ///< Read data address of OUT endpoint 2.
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t USB_SERIAL_JTAG_CLK_EN = (1U << 0);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t USB_SERIAL_JTAG_USB_MEM_PD = (1U << 0);  ///< 1: power down usb memory.
        constexpr uint32_t USB_SERIAL_JTAG_USB_MEM_CLK_EN = (1U << 1);  ///< 1: Force clock on for usb memory.
    }

    /// CHIP_RST Register bits
    namespace chip_rst_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RTS = (1U << 0);  ///< 1: Chip reset is detected from usb serial channel. Software write 1 to clear it.
        constexpr uint32_t USB_SERIAL_JTAG_DTR = (1U << 1);  ///< 1: Chip reset is detected from usb jtag channel. Software write 1 to clear it.
        constexpr uint32_t USB_SERIAL_JTAG_USB_UART_CHIP_RST_DIS = (1U << 2);  ///< Set this bit to disable chip reset from usb serial channel to reset chip.
    }

    /// SET_LINE_CODE_W0 Register bits
    namespace set_line_code_w0_bits {
        constexpr uint32_t USB_SERIAL_JTAG_DW_DTE_RATE = (32 << 0);  ///< The value of dwDTERate set by host through SET_LINE_CODING command.
    }

    /// SET_LINE_CODE_W1 Register bits
    namespace set_line_code_w1_bits {
        constexpr uint32_t USB_SERIAL_JTAG_BCHAR_FORMAT = (8 << 0);  ///< The value of bCharFormat set by host through SET_LINE_CODING command.
        constexpr uint32_t USB_SERIAL_JTAG_BPARITY_TYPE = (8 << 8);  ///< The value of bParityTpye set by host through SET_LINE_CODING command.
        constexpr uint32_t USB_SERIAL_JTAG_BDATA_BITS = (8 << 16);  ///< The value of bDataBits set by host through SET_LINE_CODING command.
    }

    /// GET_LINE_CODE_W0 Register bits
    namespace get_line_code_w0_bits {
        constexpr uint32_t USB_SERIAL_JTAG_GET_DW_DTE_RATE = (32 << 0);  ///< The value of dwDTERate set by software which is requested by GET_LINE_CODING command.
    }

    /// GET_LINE_CODE_W1 Register bits
    namespace get_line_code_w1_bits {
        constexpr uint32_t USB_SERIAL_JTAG_GET_BDATA_BITS = (8 << 0);  ///< The value of bCharFormat set by software which is requested by GET_LINE_CODING command.
        constexpr uint32_t USB_SERIAL_JTAG_GET_BPARITY_TYPE = (8 << 8);  ///< The value of bParityTpye set by software which is requested by GET_LINE_CODING command.
        constexpr uint32_t USB_SERIAL_JTAG_GET_BCHAR_FORMAT = (8 << 16);  ///< The value of bDataBits set by software which is requested by GET_LINE_CODING command.
    }

    /// CONFIG_UPDATE Register bits
    namespace config_update_bits {
        constexpr uint32_t USB_SERIAL_JTAG_CONFIG_UPDATE = (1U << 0);  ///< Write 1 to this register would update the value of configure registers from APB clock domain to 48MHz clock domain.
    }

    /// SER_AFIFO_CONFIG Register bits
    namespace ser_afifo_config_bits {
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_AFIFO_RESET_WR = (1U << 0);  ///< Write 1 to reset CDC_ACM IN async FIFO write clock domain.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_AFIFO_RESET_RD = (1U << 1);  ///< Write 1 to reset CDC_ACM IN async FIFO read clock domain.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_AFIFO_RESET_WR = (1U << 2);  ///< Write 1 to reset CDC_ACM OUT async FIFO write clock domain.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_AFIFO_RESET_RD = (1U << 3);  ///< Write 1 to reset CDC_ACM OUT async FIFO read clock domain.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_OUT_AFIFO_REMPTY = (1U << 4);  ///< CDC_ACM OUTOUT async FIFO empty signal in read clock domain.
        constexpr uint32_t USB_SERIAL_JTAG_SERIAL_IN_AFIFO_WFULL = (1U << 5);  ///< CDC_ACM OUT IN async FIFO empty signal in write clock domain.
    }

    /// BUS_RESET_ST Register bits
    namespace bus_reset_st_bits {
        constexpr uint32_t USB_SERIAL_JTAG_USB_BUS_RESET_ST = (1U << 0);  ///< USB bus reset status. 0: USB-Serial-JTAG is in usb bus reset status. 1: USB bus reset is released.
    }

    /// ECO_LOW_48 Register bits
    namespace eco_low_48_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RND_ECO_LOW_48 = (32 << 0);  ///< Reserved.
    }

    /// ECO_HIGH_48 Register bits
    namespace eco_high_48_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RND_ECO_HIGH_48 = (32 << 0);  ///< Reserved.
    }

    /// ECO_CELL_CTRL_48 Register bits
    namespace eco_cell_ctrl_48_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RDN_RESULT_48 = (1U << 0);  ///< Reserved.
        constexpr uint32_t USB_SERIAL_JTAG_RDN_ENA_48 = (1U << 1);  ///< Reserved.
    }

    /// ECO_LOW_APB Register bits
    namespace eco_low_apb_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RND_ECO_LOW_APB = (32 << 0);  ///< Reserved.
    }

    /// ECO_HIGH_APB Register bits
    namespace eco_high_apb_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RND_ECO_HIGH_APB = (32 << 0);  ///< Reserved.
    }

    /// ECO_CELL_CTRL_APB Register bits
    namespace eco_cell_ctrl_apb_bits {
        constexpr uint32_t USB_SERIAL_JTAG_RDN_RESULT_APB = (1U << 0);  ///< Reserved.
        constexpr uint32_t USB_SERIAL_JTAG_RDN_ENA_APB = (1U << 1);  ///< Reserved.
    }

    /// SRAM_CTRL Register bits
    namespace sram_ctrl_bits {
        constexpr uint32_t USB_SERIAL_JTAG_MEM_AUX_CTRL = (14 << 0);  ///< Control signals
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t USB_SERIAL_JTAG_DATE = (32 << 0);  ///< register version.
    }

}


} // namespace alloy::generated::esp32-p4

#endif // ALLOY_GENERATED_ESP32-P4_PERIPHERALS_HPP