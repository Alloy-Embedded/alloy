/// Auto-generated code for ESP32-S2
/// Generated by Alloy Code Generator
/// Source: espressif_esp32s2.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:01:10
#ifndef ALLOY_GENERATED_ESP32-S2_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-S2_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-s2 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_bb = true;
    constexpr uint32_t num_bb_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_extmem = true;
    constexpr uint32_t num_extmem_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 1;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 1;
    constexpr bool has_pcnt = true;
    constexpr uint32_t num_pcnt_instances = 1;
    constexpr bool has_pms = true;
    constexpr uint32_t num_pms_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sens = true;
    constexpr uint32_t num_sens_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 5;
    constexpr bool has_syscon = true;
    constexpr uint32_t num_syscon_instances = 1;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct extmem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcnt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pms_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sens_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct syscon_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x6003A000;
    constexpr uint32_t HMAC_BASE = 0x6003E000;
    constexpr uint32_t RSA_BASE = 0x6003C000;
    constexpr uint32_t SHA_BASE = 0x6003B000;
    constexpr uint32_t XTS_AES_BASE = 0x6003A100;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t KEY_%s;  ///< Offset: 0x00 - AES key register %s
        volatile uint32_t TEXT_IN_%s;  ///< Offset: 0x20 - Source data register %s
        volatile uint32_t TEXT_OUT_%s;  ///< Offset: 0x30 - Result data register %s
        volatile uint32_t MODE;  ///< Offset: 0x40 - AES working mode configuration register
        volatile uint32_t ENDIAN;  ///< Offset: 0x44 - Endian configuration register
        volatile uint32_t TRIGGER;  ///< Offset: 0x48 - Operation start controlling register
        volatile uint32_t STATE;  ///< Offset: 0x4C - Operation status register
        volatile uint32_t IV_%s;  ///< Offset: 0x50 - initialization vector
        volatile uint32_t H_%s;  ///< Offset: 0x60 - GCM hash subkey
        volatile uint32_t J0_%s;  ///< Offset: 0x70 - J0
        volatile uint32_t T0_%s;  ///< Offset: 0x80 - T0
        volatile uint32_t DMA_ENABLE;  ///< Offset: 0x90 - DMA enable register
        volatile uint32_t BLOCK_MODE;  ///< Offset: 0x94 - Block operation type register
        volatile uint32_t BLOCK_NUM;  ///< Offset: 0x98 - Block number configuration register
        volatile uint32_t INC_SEL;  ///< Offset: 0x9C - Standard incrementing function register
        volatile uint32_t AAD_BLOCK_NUM;  ///< Offset: 0xA0 - AAD block number configuration register
        volatile uint32_t REMAINDER_BIT_NUM;  ///< Offset: 0xA4 - Remainder bit number of plaintext/ciphertext
        volatile uint32_t CONTINUE_OP;  ///< Offset: 0xA8 - Operation continue controlling register
        volatile uint32_t INT_CLR;  ///< Offset: 0xAC - DMA-AES interrupt clear register
        volatile uint32_t INT_ENA;  ///< Offset: 0xB0 - DMA-AES interrupt enable register
        volatile uint32_t DATE;  ///< Offset: 0xB4 - Version control register
        volatile uint32_t DMA_EXIT;  ///< Offset: 0xB8 - Operation exit controlling register
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* HMAC = reinterpret_cast<Registers*>(HMAC_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);
    inline Registers* XTS_AES = reinterpret_cast<Registers*>(XTS_AES_BASE);

    // Bit definitions
    /// KEY_%s Register bits
    namespace key_%s_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Stores AES keys.
    }

    /// TEXT_IN_%s Register bits
    namespace text_in_%s_bits {
        constexpr uint32_t TEXT_IN = (32 << 0);  ///< Stores the source data when the AES Accelerator operates in the Typical AES working mode.
    }

    /// TEXT_OUT_%s Register bits
    namespace text_out_%s_bits {
        constexpr uint32_t TEXT_OUT = (32 << 0);  ///< Stores the result data when the AES Accelerator operates in the Typical AES working mode.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< Defines the operation type of the AES Accelerator operating under the Typical AES working mode. & 0x0(AES_EN_128): AES-EN-128 # 0x1(AES_EN_192): AES-EN-192 # 0x2(AES_EN_256): AES-EN-256 # 0x4(AES_DE_128): AES-DE-128 # 0x5(AES_DE_192): AES-DE-192 # 0x6(AES_DE_256): AES-DE-256 &
    }

    /// ENDIAN Register bits
    namespace endian_bits {
        constexpr uint32_t ENDIAN = (6 << 0);  ///< Defines the endianness of input and output texts. & [1:0] key endian # [3:2] text_in endian or in_stream endian # [5:4] text_out endian or out_stream endian # &
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< Set this bit to 1 to start AES operation.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< Stores the working status of the AES Accelerator. For details, see Table 3 for Typical AES working mode and Table 9 for DMA AES working mode. For typical AES; 0 = idle; 1 = busy. For DMA-AES; 0 = idle; 1 = busy; 2 = calculation_done.
    }

    /// IV_%s Register bits
    namespace iv_%s_bits {
        constexpr uint32_t IV = (32 << 0);  ///< This register stores the %sth 32-bit piece of 128-bit initialization vector
    }

    /// H_%s Register bits
    namespace h_%s_bits {
        constexpr uint32_t H = (32 << 0);  ///< GCM hash subkey
    }

    /// J0_%s Register bits
    namespace j0_%s_bits {
        constexpr uint32_t J0 = (32 << 0);  ///< This register stores the %sth 32-bit piece of 128-bit J0
    }

    /// T0_%s Register bits
    namespace t0_%s_bits {
        constexpr uint32_t T0 = (32 << 0);  ///< This register stores the %sth 32-bit piece of 128-bit T0
    }

    /// DMA_ENABLE Register bits
    namespace dma_enable_bits {
        constexpr uint32_t DMA_ENABLE = (1U << 0);  ///< Defines the working mode of the AES Accelerator. For details, see Table 1. 1'h0: typical AES operation 1'h1: DMA-AES operation
    }

    /// BLOCK_MODE Register bits
    namespace block_mode_bits {
        constexpr uint32_t BLOCK_MODE = (3 << 0);  ///< Defines the operation type of the AES Accelerator operating under the DMA-AES working mode. For details, see Table 8. & 3'h0(BLOCK_MODE_ECB): ECB # 3'h1(BLOCK_MODE_CBC): CBC # 3'h2(BLOCK_MODE_OFB): OFB # 3'h3(BLOCK_MODE_CTR): CTR # 3'h4(BLOCK_MODE_CFB8): CFB-8 # 3'h5(BLOCK_MODE_CFB128): CFB-128 # 3'h6(BLOCK_MODE_GCM): GCM &
    }

    /// BLOCK_NUM Register bits
    namespace block_num_bits {
        constexpr uint32_t BLOCK_NUM = (32 << 0);  ///< Stores the Block Number of plaintext or cipertext when the AES Accelerator operates under the DMA-AES working mode. For details, see Section 1.5.4.
    }

    /// INC_SEL Register bits
    namespace inc_sel_bits {
        constexpr uint32_t INC_SEL = (1U << 0);  ///< Defines the Standard Incrementing Function for CTR block operation. Set this bit to 0 or 1 to choose INC 32 or INC 128 .
    }

    /// AAD_BLOCK_NUM Register bits
    namespace aad_block_num_bits {
        constexpr uint32_t AAD_BLOCK_NUM = (32 << 0);  ///< Stores the ADD Block Number for the GCM operation.
    }

    /// REMAINDER_BIT_NUM Register bits
    namespace remainder_bit_num_bits {
        constexpr uint32_t REMAINDER_BIT_NUM = (7 << 0);  ///< Stores the Remainder Bit Number for the GCM operation.
    }

    /// CONTINUE_OP Register bits
    namespace continue_op_bits {
        constexpr uint32_t CONTINUE_OP = (1U << 0);  ///< Set this bit to 1 to continue AES operation.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t INT_CLR = (1U << 0);  ///< Set this bit to 1 to clear AES interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable AES interrupt and 0 to disable interrupt.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< Version control register
    }

    /// DMA_EXIT Register bits
    namespace dma_exit_bits {
        constexpr uint32_t DMA_EXIT = (1U << 0);  ///< Set this bit to 1 to exit AES operation. This register is only effective for DMA-AES operation.
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t APB_SARADC_BASE = 0x3F440000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - DIG ADC common configuration
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - DIG ADC common configuration
        volatile uint32_t FSM;  ///< Offset: 0x08 - digital adc control register
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - configure saradc fsm internal parameter base on test
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - digital adc1 status
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - digital adc2 status
        volatile uint32_t SAR1_PATT_TAB1;  ///< Offset: 0x18 - item 0 ~ 3 for pattern table 1 (each item one byte)
        volatile uint32_t SAR1_PATT_TAB2;  ///< Offset: 0x1C - Item 4 ~ 7 for pattern table 1 (each item one byte)
        volatile uint32_t SAR1_PATT_TAB3;  ///< Offset: 0x20 - Item 8 ~ 11 for pattern table 1 (each item one byte)
        volatile uint32_t SAR1_PATT_TAB4;  ///< Offset: 0x24 - Item 12 ~ 15 for pattern table 1 (each item one byte)
        volatile uint32_t SAR2_PATT_TAB1;  ///< Offset: 0x28 - item 0 ~ 3 for pattern table 2 (each item one byte)
        volatile uint32_t SAR2_PATT_TAB2;  ///< Offset: 0x2C - Item 4 ~ 7 for pattern table 2 (each item one byte)
        volatile uint32_t SAR2_PATT_TAB3;  ///< Offset: 0x30 - Item 8 ~ 11 for pattern table 2 (each item one byte)
        volatile uint32_t SAR2_PATT_TAB4;  ///< Offset: 0x34 - Item 12 ~ 15 for pattern table 2 (each item one byte)
        volatile uint32_t ARB_CTRL;  ///< Offset: 0x38 - Configure the settings of DIG ADC2 arbiter
        volatile uint32_t FILTER_CTRL;  ///< Offset: 0x3C - Configure the settings of DIG ADC2 filter
        volatile uint32_t FILTER_STATUS;  ///< Offset: 0x40 - Data status of DIG ADC2 filter
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x44 - Configure monitor threshold for DIG ADC2
        volatile uint32_t INT_ENA;  ///< Offset: 0x48 - Enable DIG ADC interrupts
        volatile uint32_t INT_RAW;  ///< Offset: 0x4C - DIG ADC interrupt raw bits
        volatile uint32_t INT_ST;  ///< Offset: 0x50 - DIG ADC interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x54 - Clear DIG ADC interrupts
        volatile uint32_t DMA_CONF;  ///< Offset: 0x58 - Configure digital ADC DMA path
        volatile uint32_t CLKM_CONF;  ///< Offset: 0x5C - Configure DIG ADC clock
        volatile uint32_t APB_DAC_CTRL;  ///< Offset: 0x60 - Configure DAC settings
        volatile uint32_t APB_CTRL_DATE;  ///< Offset: 0x3FC - Version control register
    };

    /// Peripheral instances
    inline Registers* APB_SARADC = reinterpret_cast<Registers*>(APB_SARADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t START_FORCE = (1U << 0);  ///< 0: select FSM to start SAR ADC. 1: select software to start SAR ADC.
        constexpr uint32_t START = (1U << 1);  ///< Start SAR ADC by software.
        constexpr uint32_t WORK_MODE = (2 << 3);  ///< 0: single-channel scan mode. 1: double-channel scan mode. 2: alternate-channel scan mode.
        constexpr uint32_t SAR_SEL = (1U << 5);  ///< 0: select SAR ADC1. 1: select SAR ADC2, only work for single-channel scan mode.
        constexpr uint32_t SAR_CLK_GATED = (1U << 6);  ///< SAR clock gate enable bit.
        constexpr uint32_t SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SAR1_PATT_LEN = (4 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SAR2_PATT_LEN = (4 << 19);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SAR1_PATT_P_CLEAR = (1U << 23);  ///< Clear the pointer of pattern table for DIG ADC1 CTRL.
        constexpr uint32_t SAR2_PATT_P_CLEAR = (1U << 24);  ///< Clear the pointer of pattern table for DIG ADC2 CTRL.
        constexpr uint32_t DATA_SAR_SEL = (1U << 25);  ///< 1: sar_sel will be coded to the MSB of the 16-bit output data, in this case the resolution should not be larger than 11 bits.
        constexpr uint32_t DATA_TO_I2S = (1U << 26);  ///< 1: I2S input data is from SAR ADC (for DMA), 0: I2S input data is from GPIO matrix
        constexpr uint32_t XPD_SAR_FORCE = (2 << 27);  ///< Force option to xpd sar blocks.
        constexpr uint32_t WAIT_ARB_CYCLE = (2 << 30);  ///< Wait arbit signal stable after sar_done.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t MEAS_NUM_LIMIT = (1U << 0);  ///< Enable limit times of SAR ADC sample.
        constexpr uint32_t MAX_MEAS_NUM = (8 << 1);  ///< Set maximum conversion number.
        constexpr uint32_t SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not.
        constexpr uint32_t SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not.
        constexpr uint32_t TIMER_SEL = (1U << 11);  ///< 1: select saradc timer 0: i2s_ws trigger
        constexpr uint32_t TIMER_TARGET = (12 << 12);  ///< Set SAR ADC timer target.
        constexpr uint32_t TIMER_EN = (1U << 24);  ///< Enable SAR ADC timer trigger.
    }

    /// FSM Register bits
    namespace fsm_bits {
        constexpr uint32_t SAMPLE_NUM = (8 << 16);  ///< sample number
        constexpr uint32_t SAMPLE_CYCLE = (8 << 24);  ///< sample cycles
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t XPD_WAIT = (8 << 0);  ///< xpd wait
        constexpr uint32_t RSTB_WAIT = (8 << 8);  ///< reset time
        constexpr uint32_t STANDBY_WAIT = (8 << 16);  ///< standby wait
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SAR1_STATUS = (32 << 0);  ///< digital adc1 status
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SAR2_STATUS = (32 << 0);  ///< digital adc2 status
    }

    /// SAR1_PATT_TAB1 Register bits
    namespace sar1_patt_tab1_bits {
        constexpr uint32_t SAR1_PATT_TAB1 = (32 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB2 Register bits
    namespace sar1_patt_tab2_bits {
        constexpr uint32_t SAR1_PATT_TAB2 = (32 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB3 Register bits
    namespace sar1_patt_tab3_bits {
        constexpr uint32_t SAR1_PATT_TAB3 = (32 << 0);  ///< Item 8 ~ 11 for pattern table 1 (each item one byte)
    }

    /// SAR1_PATT_TAB4 Register bits
    namespace sar1_patt_tab4_bits {
        constexpr uint32_t SAR1_PATT_TAB4 = (32 << 0);  ///< Item 12 ~ 15 for pattern table 1 (each item one byte)
    }

    /// SAR2_PATT_TAB1 Register bits
    namespace sar2_patt_tab1_bits {
        constexpr uint32_t SAR2_PATT_TAB1 = (32 << 0);  ///< item 0 ~ 3 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB2 Register bits
    namespace sar2_patt_tab2_bits {
        constexpr uint32_t SAR2_PATT_TAB2 = (32 << 0);  ///< Item 4 ~ 7 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB3 Register bits
    namespace sar2_patt_tab3_bits {
        constexpr uint32_t SAR2_PATT_TAB3 = (32 << 0);  ///< Item 8 ~ 11 for pattern table 2 (each item one byte)
    }

    /// SAR2_PATT_TAB4 Register bits
    namespace sar2_patt_tab4_bits {
        constexpr uint32_t SAR2_PATT_TAB4 = (32 << 0);  ///< Item 12 ~ 15 for pattern table 2 (each item one byte)
    }

    /// ARB_CTRL Register bits
    namespace arb_ctrl_bits {
        constexpr uint32_t ADC_ARB_APB_FORCE = (1U << 2);  ///< ADC2 arbiter forces to enable DIG ADC2 CTRL.
        constexpr uint32_t ADC_ARB_RTC_FORCE = (1U << 3);  ///< ADC2 arbiter forces to enable RTC ADC2 CTRL.
        constexpr uint32_t ADC_ARB_WIFI_FORCE = (1U << 4);  ///< ADC2 arbiter forces to enable PWDET/PKDET CTRL.
        constexpr uint32_t ADC_ARB_GRANT_FORCE = (1U << 5);  ///< ADC2 arbiter force grant.
        constexpr uint32_t ADC_ARB_APB_PRIORITY = (2 << 6);  ///< Set DIG ADC2 CTRL priority.
        constexpr uint32_t ADC_ARB_RTC_PRIORITY = (2 << 8);  ///< Set RTC ADC2 CTRL priority.
        constexpr uint32_t ADC_ARB_WIFI_PRIORITY = (2 << 10);  ///< Set PWDET/PKDET CTRL priority.
        constexpr uint32_t ADC_ARB_FIX_PRIORITY = (1U << 12);  ///< ADC2 arbiter uses fixed priority.
    }

    /// FILTER_CTRL Register bits
    namespace filter_ctrl_bits {
        constexpr uint32_t ADC2_FILTER_RESET = (1U << 0);  ///< Reset ADC2 filter.
        constexpr uint32_t ADC1_FILTER_RESET = (1U << 1);  ///< Reset ADC1 filter.
        constexpr uint32_t ADC2_FILTER_FACTOR = (7 << 16);  ///< Set filter factor for DIG ADC2 CRTL.
        constexpr uint32_t ADC1_FILTER_FACTOR = (7 << 23);  ///< Set filter factor for DIG ADC1 CRTL.
        constexpr uint32_t ADC2_FILTER_EN = (1U << 30);  ///< Enable DIG ADC2 CRTL filter.
        constexpr uint32_t ADC1_FILTER_EN = (1U << 31);  ///< Enable DIG ADC1 CRTL filter.
    }

    /// FILTER_STATUS Register bits
    namespace filter_status_bits {
        constexpr uint32_t ADC2_FILTER_DATA = (16 << 0);  ///< ADC2 filter data.
        constexpr uint32_t ADC1_FILTER_DATA = (16 << 16);  ///< ADC1 filter data.
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Clock gate enable.
        constexpr uint32_t ADC2_THRES_MODE = (1U << 2);  ///< 1: ADC_DATA > = threshold, generate interrupt. 0: ADC_DATA < threshold, generate interrupt.
        constexpr uint32_t ADC1_THRES_MODE = (1U << 3);  ///< 1: ADC_DATA > = threshold, generate interrupt. 0: ADC_DATA < threshold, generate interrupt.
        constexpr uint32_t ADC2_THRES = (13 << 4);  ///< ADC2 threshold.
        constexpr uint32_t ADC1_THRES = (13 << 17);  ///< ADC1 threshold.
        constexpr uint32_t ADC2_THRES_EN = (1U << 30);  ///< Enable ADC2 threshold monitor.
        constexpr uint32_t ADC1_THRES_EN = (1U << 31);  ///< Enable ADC1 threshold monitor.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t ADC2_THRES_INT_ENA = (1U << 28);  ///< Enable bit of APB_SARADC_ADC2_THRES_INT interrupt.
        constexpr uint32_t ADC1_THRES_INT_ENA = (1U << 29);  ///< Enable bit of APB_SARADC_ADC1_THRES_INT interrupt.
        constexpr uint32_t ADC2_DONE_INT_ENA = (1U << 30);  ///< Enable bit of APB_SARADC_ADC2_DONE_INT interrupt.
        constexpr uint32_t ADC1_DONE_INT_ENA = (1U << 31);  ///< Enable bit of APB_SARADC_ADC1_DONE_INT interrupt.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t ADC2_THRES_INT_RAW = (1U << 28);  ///< Raw bit of APB_SARADC_ADC2_THRES_INT interrupt.
        constexpr uint32_t ADC1_THRES_INT_RAW = (1U << 29);  ///< Raw bit of APB_SARADC_ADC1_THRES_INT interrupt.
        constexpr uint32_t ADC2_DONE_INT_RAW = (1U << 30);  ///< Raw bit of APB_SARADC_ADC2_DONE_INT interrupt.
        constexpr uint32_t ADC1_DONE_INT_RAW = (1U << 31);  ///< Raw bit of APB_SARADC_ADC1_DONE_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t ADC2_THRES_INT_ST = (1U << 28);  ///< Status of APB_SARADC_ADC2_THRES_INT interrupt.
        constexpr uint32_t ADC1_THRES_INT_ST = (1U << 29);  ///< Status of APB_SARADC_ADC1_THRES_INT interrupt.
        constexpr uint32_t ADC2_DONE_INT_ST = (1U << 30);  ///< Status of APB_SARADC_ADC2_DONE_INT interrupt.
        constexpr uint32_t ADC1_DONE_INT_ST = (1U << 31);  ///< Status of APB_SARADC_ADC1_DONE_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t ADC2_THRES_INT_CLR = (1U << 28);  ///< Clear bit of APB_SARADC_ADC2_THRES_INT interrupt.
        constexpr uint32_t ADC1_THRES_INT_CLR = (1U << 29);  ///< Clear bit of APB_SARADC_ADC1_THRES_INT interrupt.
        constexpr uint32_t ADC2_DONE_INT_CLR = (1U << 30);  ///< Clear bit of APB_SARADC_ADC2_DONE_INT interrupt.
        constexpr uint32_t ADC1_DONE_INT_CLR = (1U << 31);  ///< Clear bit of APB_SARADC_ADC1_DONE_INT interrupt.
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< Generate dma_in_suc_eof when sample cnt = spi_eof_num.
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< Reset DIG ADC CTRL status.
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< Set this bit, DIG ADC CTRL uses SPI DMA.
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< Integral DIG_ADC clock divider value
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value
        constexpr uint32_t CLK_SEL = (2 << 21);  ///< 1: select APLL. 2: select APB_CLK. Other values: disable clock.
    }

    /// APB_DAC_CTRL Register bits
    namespace apb_dac_ctrl_bits {
        constexpr uint32_t DAC_TIMER_TARGET = (12 << 0);  ///< Set DAC timer target.
        constexpr uint32_t DAC_TIMER_EN = (1U << 12);  ///< Enable read dac data.
        constexpr uint32_t APB_DAC_ALTER_MODE = (1U << 13);  ///< Enable DAC alter mode.
        constexpr uint32_t APB_DAC_TRANS = (1U << 14);  ///< Enable DMA_DAC.
        constexpr uint32_t DAC_RESET_FIFO = (1U << 15);  ///< Reset DIG DAC FIFO.
        constexpr uint32_t APB_DAC_RST = (1U << 16);  ///< Reset DIG DAC by software.
    }

    /// APB_CTRL_DATE Register bits
    namespace apb_ctrl_date_bits {
        constexpr uint32_t APB_CTRL_DATE = (32 << 0);  ///< Version control register
    }

}

// ============================================================================
// BB Peripheral
// ============================================================================

namespace bb {
    /// Base addresses
    constexpr uint32_t BB_BASE = 0x3F41D000;

    /// BB Register structure
    struct Registers {
        volatile uint32_t BBPD_CTRL;  ///< Offset: 0x54 - Baseband control register
    };

    /// Peripheral instances
    inline Registers* BB = reinterpret_cast<Registers*>(BB_BASE);

    // Bit definitions
    /// BBPD_CTRL Register bits
    namespace bbpd_ctrl_bits {
        constexpr uint32_t DC_EST_FORCE_PD = (1U << 0);  ///< DC_EST_FORCE_PD
        constexpr uint32_t DC_EST_FORCE_PU = (1U << 1);  ///< DC_EST_FORCE_PU
        constexpr uint32_t FFT_FORCE_PD = (1U << 2);  ///< FFT_FORCE_PD
        constexpr uint32_t FFT_FORCE_PU = (1U << 3);  ///< FFT_FORCE_PU
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t DEDICATED_GPIO_BASE = 0x3F4CF000;
    constexpr uint32_t GPIO_BASE = 0x3F404000;
    constexpr uint32_t GPIO_SD_BASE = 0x3F404F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t OUT_DRT;  ///< Offset: 0x00 - Dedicated GPIO directive output register
        volatile uint32_t OUT_MSK;  ///< Offset: 0x04 - Dedicated GPIO mask output register
        volatile uint32_t OUT_IDV;  ///< Offset: 0x08 - Dedicated GPIO individual output register
        volatile uint32_t OUT_SCAN;  ///< Offset: 0x0C - Dedicated GPIO output status register
        volatile uint32_t OUT_CPU;  ///< Offset: 0x10 - Dedicated GPIO output mode selection register
        volatile uint32_t IN_DLY;  ///< Offset: 0x14 - Dedicated GPIO input delay configuration register
        volatile uint32_t IN_SCAN;  ///< Offset: 0x18 - Dedicated GPIO input status register
        volatile uint32_t INTR_RCGN;  ///< Offset: 0x1C - Dedicated GPIO interrupts generation mode register
        volatile uint32_t INTR_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INTR_RLS;  ///< Offset: 0x24 - Interrupt enable bits
        volatile uint32_t INTR_ST;  ///< Offset: 0x28 - Masked interrupt status
        volatile uint32_t INTR_CLR;  ///< Offset: 0x2C - Interrupt clear bits
    };

    /// Peripheral instances
    inline Registers* DEDICATED_GPIO = reinterpret_cast<Registers*>(DEDICATED_GPIO_BASE);
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);

    // Bit definitions
    /// OUT_DRT Register bits
    namespace out_drt_bits {
        constexpr uint32_t VLAUE = (8 << 0);  ///< This register is used to configure directive output value of 8-channel dedicated GPIO.
    }

    /// OUT_MSK Register bits
    namespace out_msk_bits {
        constexpr uint32_t OUT_VALUE = (8 << 0);  ///< This register is used to configure updated output value of 8-channel dedicated GPIO.
        constexpr uint32_t OUT_MSK = (8 << 8);  ///< This register is used to configure channels which would be updated. 1: corresponding channel's output would be updated.
    }

    /// OUT_IDV Register bits
    namespace out_idv_bits {
        constexpr uint32_t CH0 = (2 << 0);  ///< Configure channel 0 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH1 = (2 << 2);  ///< Configure channel 1 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH2 = (2 << 4);  ///< Configure channel 2 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH3 = (2 << 6);  ///< Configure channel 3 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH4 = (2 << 8);  ///< Configure channel 4 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH5 = (2 << 10);  ///< Configure channel 5 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH6 = (2 << 12);  ///< Configure channel 6 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
        constexpr uint32_t CH7 = (2 << 14);  ///< Configure channel 7 output value. 0: hold output value. 1: set output value. 2: clear output value. 3: inverse output value.
    }

    /// OUT_SCAN Register bits
    namespace out_scan_bits {
        constexpr uint32_t OUT_STATUS = (8 << 0);  ///< GPIO out value configured by DEDIC_GPIO_OUT_DRT_REG, DEDIC_GPIO_OUT_MSK_REG, DEDIC_GPIO_OUT_IDV_REG.
    }

    /// OUT_CPU Register bits
    namespace out_cpu_bits {
        constexpr uint32_t SEL0 = (1U << 0);  ///< Select GPIO out value configured by registers or CPU instructions for channel 0. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL1 = (1U << 1);  ///< Select GPIO out value configured by registers or CPU instructions for channel 1. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL2 = (1U << 2);  ///< Select GPIO out value configured by registers or CPU instructions for channel 2. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL3 = (1U << 3);  ///< Select GPIO out value configured by registers or CPU instructions for channel 3. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL4 = (1U << 4);  ///< Select GPIO out value configured by registers or CPU instructions for channel 4. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL5 = (1U << 5);  ///< Select GPIO out value configured by registers or CPU instructions for channel 5. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL6 = (1U << 6);  ///< Select GPIO out value configured by registers or CPU instructions for channel 6. 0: Configured by registers. 1: configured by CPU instructions.
        constexpr uint32_t SEL7 = (1U << 7);  ///< Select GPIO out value configured by registers or CPU instructions for channel 7. 0: Configured by registers. 1: configured by CPU instructions.
    }

    /// IN_DLY Register bits
    namespace in_dly_bits {
        constexpr uint32_t CH0 = (2 << 0);  ///< Configure GPIO0 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH1 = (2 << 2);  ///< Configure GPIO1 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH2 = (2 << 4);  ///< Configure GPIO2 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH3 = (2 << 6);  ///< Configure GPIO3 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH4 = (2 << 8);  ///< Configure GPIO4 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH5 = (2 << 10);  ///< Configure GPIO5 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH6 = (2 << 12);  ///< Configure GPIO6 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
        constexpr uint32_t CH7 = (2 << 14);  ///< Configure GPIO7 input delay. 0: no delay. 1: one clock delay. 2: two clock delay. 3: three clock delay.
    }

    /// IN_SCAN Register bits
    namespace in_scan_bits {
        constexpr uint32_t IN_STATUS = (8 << 0);  ///< GPIO input value after configured by DEDIC_GPIO_IN_DLY_REG.
    }

    /// INTR_RCGN Register bits
    namespace intr_rcgn_bits {
        constexpr uint32_t INTR_MODE_CH0 = (3 << 0);  ///< Configure channel 0 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH1 = (3 << 3);  ///< Configure channel 1 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH2 = (3 << 6);  ///< Configure channel 2 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH3 = (3 << 9);  ///< Configure channel 3 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH4 = (3 << 12);  ///< Configure channel 4 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH5 = (3 << 15);  ///< Configure channel 5 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH6 = (3 << 18);  ///< Configure channel 6 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
        constexpr uint32_t INTR_MODE_CH7 = (3 << 21);  ///< Configure channel 7 interrupt generate mode. 0/1: do not generate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5: raising edge trigger. 6/7: falling and raising edge trigger.
    }

    /// INTR_RAW Register bits
    namespace intr_raw_bits {
        constexpr uint32_t GPIO0 = (1U << 0);  ///< This interrupt raw bit turns to high level when dedicated GPIO0 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO1 = (1U << 1);  ///< This interrupt raw bit turns to high level when dedicated GPIO1 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO2 = (1U << 2);  ///< This interrupt raw bit turns to high level when dedicated GPIO2 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO3 = (1U << 3);  ///< This interrupt raw bit turns to high level when dedicated GPIO3 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO4 = (1U << 4);  ///< This interrupt raw bit turns to high level when dedicated GPIO4 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO5 = (1U << 5);  ///< This interrupt raw bit turns to high level when dedicated GPIO5 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO6 = (1U << 6);  ///< This interrupt raw bit turns to high level when dedicated GPIO6 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
        constexpr uint32_t GPIO7 = (1U << 7);  ///< This interrupt raw bit turns to high level when dedicated GPIO7 has level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.
    }

    /// INTR_RLS Register bits
    namespace intr_rls_bits {
        constexpr uint32_t GPIO0_INT_ENA = (1U << 0);  ///< The enable bit for DEDIC_GPIO0_INT_ST register.
        constexpr uint32_t GPIO1_INT_ENA = (1U << 1);  ///< The enable bit for DEDIC_GPIO1_INT_ST register.
        constexpr uint32_t GPIO2_INT_ENA = (1U << 2);  ///< The enable bit for DEDIC_GPIO2_INT_ST register.
        constexpr uint32_t GPIO3_INT_ENA = (1U << 3);  ///< The enable bit for DEDIC_GPIO3_INT_ST register.
        constexpr uint32_t GPIO4_INT_ENA = (1U << 4);  ///< The enable bit for DEDIC_GPIO4_INT_ST register.
        constexpr uint32_t GPIO5_INT_ENA = (1U << 5);  ///< The enable bit for DEDIC_GPIO5_INT_ST register.
        constexpr uint32_t GPIO6_INT_ENA = (1U << 6);  ///< The enable bit for DEDIC_GPIO6_INT_ST register.
        constexpr uint32_t GPIO7_INT_ENA = (1U << 7);  ///< The enable bit for DEDIC_GPIO7_INT_ST register.
    }

    /// INTR_ST Register bits
    namespace intr_st_bits {
        constexpr uint32_t GPIO0_INT_ST = (1U << 0);  ///< This is the status bit for DEDIC_GPIO0_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO1_INT_ST = (1U << 1);  ///< This is the status bit for DEDIC_GPIO1_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO2_INT_ST = (1U << 2);  ///< This is the status bit for DEDIC_GPIO2_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO3_INT_ST = (1U << 3);  ///< This is the status bit for DEDIC_GPIO3_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO4_INT_ST = (1U << 4);  ///< This is the status bit for DEDIC_GPIO4_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO5_INT_ST = (1U << 5);  ///< This is the status bit for DEDIC_GPIO5_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO6_INT_ST = (1U << 6);  ///< This is the status bit for DEDIC_GPIO6_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
        constexpr uint32_t GPIO7_INT_ST = (1U << 7);  ///< This is the status bit for DEDIC_GPIO7_INT_RAW when DEDIC_GPIO7_INT_ENA is set to 1.
    }

    /// INTR_CLR Register bits
    namespace intr_clr_bits {
        constexpr uint32_t GPIO0_INT_CLR = (1U << 0);  ///< Set this bit to clear the DEDIC_GPIO0_INT_RAW interrupt.
        constexpr uint32_t GPIO1_INT_CLR = (1U << 1);  ///< Set this bit to clear the DEDIC_GPIO1_INT_RAW interrupt.
        constexpr uint32_t GPIO2_INT_CLR = (1U << 2);  ///< Set this bit to clear the DEDIC_GPIO2_INT_RAW interrupt.
        constexpr uint32_t GPIO3_INT_CLR = (1U << 3);  ///< Set this bit to clear the DEDIC_GPIO3_INT_RAW interrupt.
        constexpr uint32_t GPIO4_INT_CLR = (1U << 4);  ///< Set this bit to clear the DEDIC_GPIO4_INT_RAW interrupt.
        constexpr uint32_t GPIO5_INT_CLR = (1U << 5);  ///< Set this bit to clear the DEDIC_GPIO5_INT_RAW interrupt.
        constexpr uint32_t GPIO6_INT_CLR = (1U << 6);  ///< Set this bit to clear the DEDIC_GPIO6_INT_RAW interrupt.
        constexpr uint32_t GPIO7_INT_CLR = (1U << 7);  ///< Set this bit to clear the DEDIC_GPIO7_INT_RAW interrupt.
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x6003D000;

    /// DS Register structure
    struct Registers {
        volatile uint32_t C_MEM[%s];  ///< Offset: 0x00 - memory C
        volatile uint32_t IV_%s;  ///< Offset: 0x630 - IV block data.
        volatile uint32_t X_MEM[%s];  ///< Offset: 0x800 - memory X
        volatile uint32_t Z_MEM[%s];  ///< Offset: 0xA00 - memory Z
        volatile uint32_t SET_START;  ///< Offset: 0xE00 - Activates the DS peripheral
        volatile uint32_t SET_ME;  ///< Offset: 0xE04 - Starts DS operation
        volatile uint32_t SET_FINISH;  ///< Offset: 0xE08 - Ends DS operation
        volatile uint32_t QUERY_BUSY;  ///< Offset: 0xE0C - Status of the DS
        volatile uint32_t QUERY_KEY_WRONG;  ///< Offset: 0xE10 - Checks the reason why DS_KEY is not ready.
        volatile uint32_t QUERY_CHECK;  ///< Offset: 0xE14 - Queries DS check result
        volatile uint32_t DATE;  ///< Offset: 0xE20 - Version control register
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// IV_%s Register bits
    namespace iv_%s_bits {
        constexpr uint32_t IV = (32 << 0);  ///< IV block data.
    }

    /// SET_START Register bits
    namespace set_start_bits {
        constexpr uint32_t SET_START = (1U << 0);  ///< Write 1 to this register to activate the DS peripheral.
    }

    /// SET_ME Register bits
    namespace set_me_bits {
        constexpr uint32_t SET_ME = (1U << 0);  ///< Write 1 to this register to start DS operation.
    }

    /// SET_FINISH Register bits
    namespace set_finish_bits {
        constexpr uint32_t SET_FINISH = (1U << 0);  ///< Write 1 to this register to end DS operation.
    }

    /// QUERY_BUSY Register bits
    namespace query_busy_bits {
        constexpr uint32_t QUERY_BUSY = (1U << 0);  ///< 1: The DS peripheral is busy. 0: The DS peripheral is idle.
    }

    /// QUERY_KEY_WRONG Register bits
    namespace query_key_wrong_bits {
        constexpr uint32_t QUERY_KEY_WRONG = (4 << 0);  ///< 1-15: HMAC was activated, but the DS peripheral did not successfully receive the DS_KEY value from the HMAC peripheral. The biggest value is 15. 0: HMAC is not activated.
    }

    /// QUERY_CHECK Register bits
    namespace query_check_bits {
        constexpr uint32_t MD_ERROR = (1U << 0);  ///< 1: MD check fails. 0: MD check passes.
        constexpr uint32_t PADDING_BAD = (1U << 1);  ///< 1: The padding check fails. 0: The padding check passes.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< Version control register.
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x3F41A000;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA%s;  ///< Offset: 0x00 - Register %s that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE%s;  ///< Offset: 0x20 - Register %s that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - Register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - Register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_DATA1;  ///< Offset: 0x34 - Register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_DATA2;  ///< Offset: 0x38 - Register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_DATA3;  ///< Offset: 0x3C - Register 4 of BLOCK0.
        volatile uint32_t RD_REPEAT_DATA4;  ///< Offset: 0x40 - Register 5 of BLOCK0.
        volatile uint32_t RD_MAC_SPI_SYS_0;  ///< Offset: 0x44 - Register 0 of BLOCK1.
        volatile uint32_t RD_MAC_SPI_SYS_1;  ///< Offset: 0x48 - Register 1 of BLOCK1.
        volatile uint32_t RD_MAC_SPI_SYS_2;  ///< Offset: 0x4C - Register 2 of BLOCK1.
        volatile uint32_t RD_MAC_SPI_SYS_3;  ///< Offset: 0x50 - Register 3 of BLOCK1.
        volatile uint32_t RD_MAC_SPI_SYS_4;  ///< Offset: 0x54 - Register 4 of BLOCK1.
        volatile uint32_t RD_MAC_SPI_SYS_5;  ///< Offset: 0x58 - Register 5 of BLOCK1.
        volatile uint32_t RD_SYS_DATA_PART1_%s;  ///< Offset: 0x5C - Register %s of BLOCK2 (system).
        volatile uint32_t RD_USR_DATA%s;  ///< Offset: 0x7C - Register %s of BLOCK3 (user).
        volatile uint32_t RD_KEY0_DATA%s;  ///< Offset: 0x9C - Register %s of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY1_DATA%s;  ///< Offset: 0xBC - Register %s of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY2_DATA%s;  ///< Offset: 0xDC - Register %s of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY3_DATA%s;  ///< Offset: 0xFC - Register %s of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY4_DATA%s;  ///< Offset: 0x11C - Register %s of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY5_DATA%s;  ///< Offset: 0x13C - Register %s of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_DATA_PART2_%s;  ///< Offset: 0x15C - Register %s of BLOCK10 (system).
        volatile uint32_t RD_REPEAT_ERR0;  ///< Offset: 0x17C - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR1;  ///< Offset: 0x180 - Programming error record register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR2;  ///< Offset: 0x184 - Programming error record register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR3;  ///< Offset: 0x188 - Programming error record register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR4;  ///< Offset: 0x190 - Programming error record register 4 of BLOCK0.
        volatile uint32_t RD_RS_ERR0;  ///< Offset: 0x1C0 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t RD_RS_ERR1;  ///< Offset: 0x1C4 - Programming error record register 1 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x1C8 - eFuse clock configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x1CC - eFuse operation mode configuration register.
        volatile uint32_t STATUS;  ///< Offset: 0x1D0 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x1D4 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1D8 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x1DC - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x1E0 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x1E4 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x1E8 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x1EC - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF0;  ///< Offset: 0x1F0 - Configuration register 0 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x1F4 - Configuration register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x1F8 - Configuration register 2 of eFuse programming timing parameters.
        volatile uint32_t DATE;  ///< Offset: 0x1FC - Version control register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA%s Register bits
    namespace pgm_data%s_bits {
        constexpr uint32_t PGM_DATA = (32 << 0);  ///< The content of the %sth 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE%s Register bits
    namespace pgm_check_value%s_bits {
        constexpr uint32_t PGM_RS_DATA = (32 << 0);  ///< The content of the %sth 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (32 << 0);  ///< Disables programming of individual eFuses.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (7 << 0);  ///< Disables software reading from individual eFuse blocks (BLOCK4-10).
        constexpr uint32_t DIS_RTC_RAM_BOOT = (1U << 7);  ///< Reserved.
        constexpr uint32_t DIS_ICACHE = (1U << 8);  ///< Set this bit to disable Icache.
        constexpr uint32_t DIS_DCACHE = (1U << 9);  ///< Set this bit to disable Dcache.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE = (1U << 10);  ///< Disables Icache when SoC is in Download mode.
        constexpr uint32_t DIS_DOWNLOAD_DCACHE = (1U << 11);  ///< Disables Dcache when SoC is in Download mode.
        constexpr uint32_t DIS_FORCE_DOWNLOAD = (1U << 12);  ///< Set this bit to disable the function that forces chip into download mode.
        constexpr uint32_t DIS_USB = (1U << 13);  ///< Set this bit to disable USB OTG function.
        constexpr uint32_t DIS_CAN = (1U << 14);  ///< Set this bit to disable the TWAI Controller function.
        constexpr uint32_t DIS_BOOT_REMAP = (1U << 15);  ///< Disables capability to Remap RAM to ROM address space.
        constexpr uint32_t RPT4_RESERVED5 = (1U << 16);  ///< Reserved (used for four backups method).
        constexpr uint32_t SOFT_DIS_JTAG = (1U << 17);  ///< Software disables JTAG. When software disabled, JTAG can be activated temporarily by HMAC peripheral.
        constexpr uint32_t HARD_DIS_JTAG = (1U << 18);  ///< Hardware disables JTAG permanently.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 19);  ///< Disables flash encryption when in download boot modes.
        constexpr uint32_t USB_DREFH = (2 << 20);  ///< Controls single-end input threshold vrefh, 1.76 V to 2 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_DREFL = (2 << 22);  ///< Controls single-end input threshold vrefl, 0.8 V to 1.04 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_EXCHG_PINS = (1U << 24);  ///< Set this bit to exchange USB D+ and D- pins.
        constexpr uint32_t EXT_PHY_ENABLE = (1U << 25);  ///< Set this bit to enable external USB PHY.
        constexpr uint32_t USB_FORCE_NOPERSIST = (1U << 26);  ///< If set, forces USB BVALID to 1.
        constexpr uint32_t RPT4_RESERVED0 = (2 << 27);  ///< Reserved (used for four backups method).
        constexpr uint32_t VDD_SPI_MODECURLIM = (1U << 29);  ///< SPI regulator switches current limit mode.
        constexpr uint32_t VDD_SPI_DREFH = (2 << 30);  ///< SPI regulator high voltage reference.
    }

    /// RD_REPEAT_DATA1 Register bits
    namespace rd_repeat_data1_bits {
        constexpr uint32_t VDD_SPI_DREFM = (2 << 0);  ///< SPI regulator medium voltage reference.
        constexpr uint32_t VDD_SPI_DREFL = (2 << 2);  ///< SPI regulator low voltage reference.
        constexpr uint32_t VDD_SPI_XPD = (1U << 4);  ///< If VDD_SPI_FORCE is 1, this value determines if the VDD_SPI regulator is powered on.
        constexpr uint32_t VDD_SPI_TIEH = (1U << 5);  ///< If VDD_SPI_FORCE is 1, determines VDD_SPI voltage. 0: VDD_SPI connects to 1.8 V LDO. 1: VDD_SPI connects to VDD_RTC_IO.
        constexpr uint32_t VDD_SPI_FORCE = (1U << 6);  ///< Set this bit to use XPD_VDD_PSI_REG and VDD_SPI_TIEH to configure VDD_SPI LDO.
        constexpr uint32_t VDD_SPI_EN_INIT = (1U << 7);  ///< Set SPI regulator to 0 to configure init[1:0]=0.
        constexpr uint32_t VDD_SPI_ENCURLIM = (1U << 8);  ///< Set SPI regulator to 1 to enable output current limit.
        constexpr uint32_t VDD_SPI_DCURLIM = (3 << 9);  ///< Tunes the current limit threshold of SPI regulator when tieh=0, about 800 mA/(8+d).
        constexpr uint32_t VDD_SPI_INIT = (2 << 12);  ///< Adds resistor from LDO output to ground. 0: no resistance. 1: 6 K. 2: 4 K. 3: 2 K.
        constexpr uint32_t VDD_SPI_DCAP = (2 << 14);  ///< Prevents SPI regulator from overshoot.
        constexpr uint32_t WDT_DELAY_SEL = (2 << 16);  ///< Selects RTC watchdog timeout threshold at startup. 0: 40,000 slow clock cycles. 1: 80,000 slow clock cycles. 2: 160,000 slow clock cycles. 3: 320,000 slow clock cycles.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT = (3 << 18);  ///< Enables encryption and decryption, when an SPI boot mode is set. Feature is enabled 1 or 3 bits are set in the eFuse, disabled otherwise.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0 = (1U << 21);  ///< If set, revokes use of secure boot key digest 0.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1 = (1U << 22);  ///< If set, revokes use of secure boot key digest 1.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2 = (1U << 23);  ///< If set, revokes use of secure boot key digest 2.
        constexpr uint32_t KEY_PURPOSE_0 = (4 << 24);  ///< Purpose of KEY0. Refer to Table Key Purpose Values.
        constexpr uint32_t KEY_PURPOSE_1 = (4 << 28);  ///< Purpose of KEY1. Refer to Table Key Purpose Values.
    }

    /// RD_REPEAT_DATA2 Register bits
    namespace rd_repeat_data2_bits {
        constexpr uint32_t KEY_PURPOSE_2 = (4 << 0);  ///< Purpose of KEY2. Refer to Table Key Purpose Values.
        constexpr uint32_t KEY_PURPOSE_3 = (4 << 4);  ///< Purpose of KEY3. Refer to Table Key Purpose Values.
        constexpr uint32_t KEY_PURPOSE_4 = (4 << 8);  ///< Purpose of KEY4. Refer to Table Key Purpose Values.
        constexpr uint32_t KEY_PURPOSE_5 = (4 << 12);  ///< Purpose of KEY5. Refer to Table Key Purpose Values.
        constexpr uint32_t KEY_PURPOSE_6 = (4 << 16);  ///< Purpose of KEY6. Refer to Table Key Purpose Values.
        constexpr uint32_t SECURE_BOOT_EN = (1U << 20);  ///< Set this bit to enable secure boot.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE = (1U << 21);  ///< Set this bit to enable aggressive secure boot key revocation mode.
        constexpr uint32_t RPT4_RESERVED1 = (6 << 22);  ///< Reserved (used for four backups method).
        constexpr uint32_t FLASH_TPUW = (4 << 28);  ///< Configures flash startup delay after SoC power-up, in unit of (ms/2). When the value is 15, delay is 7.5 ms.
    }

    /// RD_REPEAT_DATA3 Register bits
    namespace rd_repeat_data3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 0);  ///< Set this bit to disable all download boot modes.
        constexpr uint32_t DIS_LEGACY_SPI_BOOT = (1U << 1);  ///< Set this bit to disable Legacy SPI boot mode.
        constexpr uint32_t UART_PRINT_CHANNEL = (1U << 2);  ///< Selects the default UART for printing boot messages. 0: UART0. 1: UART1.
        constexpr uint32_t RPT4_RESERVED3 = (1U << 3);  ///< Reserved (used for four backups method).
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE = (1U << 4);  ///< Set this bit to disable use of USB OTG in UART download boot mode.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 5);  ///< Set this bit to enable secure UART download mode (read/write flash only).
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 6);  ///< Set the default UART boot message output mode. 00: Enabled. 01: Enable when GPIO46 is low at reset. 10: Enable when GPIO46 is high at reset. 11: Disabled.
        constexpr uint32_t PIN_POWER_SELECTION = (1U << 8);  ///< Set default power supply for GPIO33-GPIO37, set when SPI flash is initialized. 0: VDD3P3_CPU. 1: VDD_SPI.
        constexpr uint32_t FLASH_TYPE = (1U << 9);  ///< SPI flash type. 0: maximum four data lines, 1: eight data lines.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 10);  ///< If set, forces ROM code to send an SPI flash resume command during SPI boot.
        constexpr uint32_t SECURE_VERSION = (16 << 11);  ///< Secure version (used by ESP-IDF anti-rollback feature).
        constexpr uint32_t RPT4_RESERVED2 = (5 << 27);  ///< Reserved (used for four backups method).
    }

    /// RD_REPEAT_DATA4 Register bits
    namespace rd_repeat_data4_bits {
        constexpr uint32_t RPT4_RESERVED4 = (24 << 0);  ///< Reserved (used for four backups method).
    }

    /// RD_MAC_SPI_SYS_0 Register bits
    namespace rd_mac_spi_sys_0_bits {
        constexpr uint32_t MAC_0 = (32 << 0);  ///< Stores the low 32 bits of MAC address.
    }

    /// RD_MAC_SPI_SYS_1 Register bits
    namespace rd_mac_spi_sys_1_bits {
        constexpr uint32_t MAC_1 = (16 << 0);  ///< Stores the high 16 bits of MAC address.
        constexpr uint32_t SPI_PAD_CONF_0 = (16 << 16);  ///< Stores the zeroth part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_2 Register bits
    namespace rd_mac_spi_sys_2_bits {
        constexpr uint32_t SPI_PAD_CONF_1 = (32 << 0);  ///< Stores the first part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_3 Register bits
    namespace rd_mac_spi_sys_3_bits {
        constexpr uint32_t SPI_PAD_CONF_2 = (18 << 0);  ///< Stores the second part of SPI_PAD_CONF.
        constexpr uint32_t SYS_DATA_PART0_0 = (14 << 18);  ///< Stores the zeroth part of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_4 Register bits
    namespace rd_mac_spi_sys_4_bits {
        constexpr uint32_t SYS_DATA_PART0_1 = (32 << 0);  ///< Stores the fist part of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_5 Register bits
    namespace rd_mac_spi_sys_5_bits {
        constexpr uint32_t SYS_DATA_PART0_2 = (32 << 0);  ///< Stores the second part of the zeroth part of system data.
    }

    /// RD_SYS_DATA_PART1_%s Register bits
    namespace rd_sys_data_part1_%s_bits {
        constexpr uint32_t SYS_DATA_PART1 = (32 << 0);  ///< Stores the %sth 32 bits of the first part of system data.
    }

    /// RD_USR_DATA%s Register bits
    namespace rd_usr_data%s_bits {
        constexpr uint32_t USR_DATA = (32 << 0);  ///< Stores the %sth 32 bits of BLOCK3 (user).
    }

    /// RD_KEY0_DATA%s Register bits
    namespace rd_key0_data%s_bits {
        constexpr uint32_t KEY0_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY0.
    }

    /// RD_KEY1_DATA%s Register bits
    namespace rd_key1_data%s_bits {
        constexpr uint32_t KEY1_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY1.
    }

    /// RD_KEY2_DATA%s Register bits
    namespace rd_key2_data%s_bits {
        constexpr uint32_t KEY2_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY2.
    }

    /// RD_KEY3_DATA%s Register bits
    namespace rd_key3_data%s_bits {
        constexpr uint32_t KEY3_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY3.
    }

    /// RD_KEY4_DATA%s Register bits
    namespace rd_key4_data%s_bits {
        constexpr uint32_t KEY4_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY4.
    }

    /// RD_KEY5_DATA%s Register bits
    namespace rd_key5_data%s_bits {
        constexpr uint32_t KEY5_DATA = (32 << 0);  ///< Stores the %sth 32 bits of KEY5.
    }

    /// RD_SYS_DATA_PART2_%s Register bits
    namespace rd_sys_data_part2_%s_bits {
        constexpr uint32_t SYS_DATA_PART2 = (32 << 0);  ///< Stores the %sth 32 bits of the 2nd part of system data.
    }

    /// RD_REPEAT_ERR0 Register bits
    namespace rd_repeat_err0_bits {
        constexpr uint32_t RD_DIS_ERR = (7 << 0);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RD_DIS.
        constexpr uint32_t DIS_RTC_RAM_BOOT_ERR = (1U << 7);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_RTC_RAM_BOOT.
        constexpr uint32_t DIS_ICACHE_ERR = (1U << 8);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_ICACHE.
        constexpr uint32_t DIS_DCACHE_ERR = (1U << 9);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_DCACHE.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE_ERR = (1U << 10);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_DOWNLOAD_ICACHE.
        constexpr uint32_t DIS_DOWNLOAD_DCACHE_ERR = (1U << 11);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_DOWNLOAD_DCACHE.
        constexpr uint32_t DIS_FORCE_DOWNLOAD_ERR = (1U << 12);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_FORCE_DOWNLOAD.
        constexpr uint32_t DIS_USB_ERR = (1U << 13);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_USB.
        constexpr uint32_t DIS_CAN_ERR = (1U << 14);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_CAN.
        constexpr uint32_t DIS_BOOT_REMAP_ERR = (1U << 15);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_BOOT_REMAP.
        constexpr uint32_t RPT4_RESERVED5_ERR = (1U << 16);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RPT4_RESERVED5.
        constexpr uint32_t SOFT_DIS_JTAG_ERR = (1U << 17);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SOFT_DIS_JTAG.
        constexpr uint32_t HARD_DIS_JTAG_ERR = (1U << 18);  ///< Any bit equal to 1 denotes a programming error in EFUSE_HARD_DIS_JTAG.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 19);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT.
        constexpr uint32_t USB_DREFH_ERR = (2 << 20);  ///< Any bit equal to 1 denotes a programming error in EFUSE_USB_DREFH.
        constexpr uint32_t USB_DREFL_ERR = (2 << 22);  ///< Any bit equal to 1 denotes a programming error in EFUSE_USB_DREFL.
        constexpr uint32_t USB_EXCHG_PINS_ERR = (1U << 24);  ///< Any bit equal to 1 denotes a programming error in EFUSE_USB_EXCHG_PINS.
        constexpr uint32_t EXT_PHY_ENABLE_ERR = (1U << 25);  ///< Any bit equal to 1 denotes a programming error in EFUSE_EXT_PHY_ENABLE.
        constexpr uint32_t USB_FORCE_NOPERSIST_ERR = (1U << 26);  ///< Any bit equal to 1 denotes a programming error in EFUSE_USB_FORCE_NOPERSIST.
        constexpr uint32_t RPT4_RESERVED0_ERR = (2 << 27);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RPT4_RESERVED0.
        constexpr uint32_t VDD_SPI_MODECURLIM_ERR = (1U << 29);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_MODECURLIM.
        constexpr uint32_t VDD_SPI_DREFH_ERR = (2 << 30);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_DREFH.
    }

    /// RD_REPEAT_ERR1 Register bits
    namespace rd_repeat_err1_bits {
        constexpr uint32_t VDD_SPI_DREFM_ERR = (2 << 0);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_DREFM.
        constexpr uint32_t VDD_SPI_DREFL_ERR = (2 << 2);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_DREFL.
        constexpr uint32_t VDD_SPI_XPD_ERR = (1U << 4);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_XPD.
        constexpr uint32_t VDD_SPI_TIEH_ERR = (1U << 5);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_TIEH.
        constexpr uint32_t VDD_SPI_FORCE_ERR = (1U << 6);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_FORCE.
        constexpr uint32_t VDD_SPI_EN_INIT_ERR = (1U << 7);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_EN_INIT.
        constexpr uint32_t VDD_SPI_ENCURLIM_ERR = (1U << 8);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_ENCURLIM.
        constexpr uint32_t VDD_SPI_DCURLIM_ERR = (3 << 9);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_DCURLIM.
        constexpr uint32_t VDD_SPI_INIT_ERR = (2 << 12);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_INIT.
        constexpr uint32_t VDD_SPI_DCAP_ERR = (2 << 14);  ///< Any bit equal to 1 denotes a programming error in EFUSE_VDD_SPI_DCAP.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 16);  ///< Any bit equal to 1 denotes a programming error in EFUSE_WDT_DELAY_SEL.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT_ERR = (3 << 18);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SPI_BOOT_CRYPT_CNT.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0_ERR = (1U << 21);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_BOOT_KEY_REVOKE0.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1_ERR = (1U << 22);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_BOOT_KEY_REVOKE1.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2_ERR = (1U << 23);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_BOOT_KEY_REVOKE2.
        constexpr uint32_t KEY_PURPOSE_0_ERR = (4 << 24);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_0.
        constexpr uint32_t KEY_PURPOSE_1_ERR = (4 << 28);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_1.
    }

    /// RD_REPEAT_ERR2 Register bits
    namespace rd_repeat_err2_bits {
        constexpr uint32_t KEY_PURPOSE_2_ERR = (4 << 0);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_2.
        constexpr uint32_t KEY_PURPOSE_3_ERR = (4 << 4);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_3.
        constexpr uint32_t KEY_PURPOSE_4_ERR = (4 << 8);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_4.
        constexpr uint32_t KEY_PURPOSE_5_ERR = (4 << 12);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_5.
        constexpr uint32_t KEY_PURPOSE_6_ERR = (4 << 16);  ///< Any bit equal to 1 denotes a programming error in EFUSE_KEY_PURPOSE_6.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 20);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_BOOT_EN.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = (1U << 21);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_BOOT_AGGRESSIVE_REVOKE.
        constexpr uint32_t RPT4_RESERVED1_ERR = (6 << 22);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RPT4_RESERVED1.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 28);  ///< Any bit equal to 1 denotes a programming error in EFUSE_FLASH_TPUW.
    }

    /// RD_REPEAT_ERR3 Register bits
    namespace rd_repeat_err3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 0);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_DOWNLOAD_MODE.
        constexpr uint32_t DIS_LEGACY_SPI_BOOT_ERR = (1U << 1);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_LEGACY_SPI_BOOT.
        constexpr uint32_t UART_PRINT_CHANNEL_ERR = (1U << 2);  ///< Any bit equal to 1 denotes a programming error in EFUSE_UART_PRINT_CHANNEL.
        constexpr uint32_t RPT4_RESERVED3_ERR = (1U << 3);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RPT4_RESERVED3.
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE_ERR = (1U << 4);  ///< Any bit equal to 1 denotes a programming error in EFUSE_DIS_USB_DOWNLOAD_MODE.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 5);  ///< Any bit equal to 1 denotes a programming error in EFUSE_ENABLE_SECURITY_DOWNLOAD.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 6);  ///< Any bit equal to 1 denotes a programming error in EFUSE_UART_PRINT_CONTROL.
        constexpr uint32_t PIN_POWER_SELECTION_ERR = (1U << 8);  ///< Any bit equal to 1 denotes a programming error in EFUSE_PIN_POWER_SELECTION.
        constexpr uint32_t FLASH_TYPE_ERR = (1U << 9);  ///< Any bit equal to 1 denotes a programming error in EFUSE_FLASH_TYPE.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 10);  ///< Any bit equal to 1 denotes a programming error in EFUSE_FORCE_SEND_RESUME.
        constexpr uint32_t SECURE_VERSION_ERR = (16 << 11);  ///< Any bit equal to 1 denotes a programming error in EFUSE_SECURE_VERSION.
        constexpr uint32_t RPT4_RESERVED2_ERR = (5 << 27);  ///< Any bit equal to 1 denotes a programming error in EFUSE_RPT4_RESERVED2.
    }

    /// RD_REPEAT_ERR4 Register bits
    namespace rd_repeat_err4_bits {
        constexpr uint32_t RPT4_RESERVED4_ERR = (24 << 0);  ///< If any bit in RPT4_RESERVED4 is 1, there is a programming error in EFUSE_RPT4_RESERVED4.
    }

    /// RD_RS_ERR0 Register bits
    namespace rd_rs_err0_bits {
        constexpr uint32_t MAC_SPI_8M_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes in BLOCK1.
        constexpr uint32_t MAC_SPI_8M_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of BLOCK1 is reliable. 1: Means that programming BLOCK1 data failed and the number of error bytes is over 5.
        constexpr uint32_t SYS_PART1_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes in BLOCK2.
        constexpr uint32_t SYS_PART1_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of BLOCK2 is reliable. 1: Means that programming BLOCK2 data failed and the number of error bytes is over 5.
        constexpr uint32_t USR_DATA_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes in BLOCK3.
        constexpr uint32_t USR_DATA_FAIL = (1U << 11);  ///< 0: Means no failure and that the data of BLOCK3 is reliable. 1: Means that programming BLOCK3 data failed and the number of error bytes is over 5.
        constexpr uint32_t KEY0_ERR_NUM = (3 << 12);  ///< The value of this signal means the number of error bytes in KEY0.
        constexpr uint32_t KEY0_FAIL = (1U << 15);  ///< 0: Means no failure and that the data of KEY0 is reliable. 1: Means that programming KEY0 failed and the number of error bytes is over 5.
        constexpr uint32_t KEY1_ERR_NUM = (3 << 16);  ///< The value of this signal means the number of error bytes in KEY1.
        constexpr uint32_t KEY1_FAIL = (1U << 19);  ///< 0: Means no failure and that the data of KEY1 is reliable. 1: Means that programming KEY1 failed and the number of error bytes is over 5.
        constexpr uint32_t KEY2_ERR_NUM = (3 << 20);  ///< The value of this signal means the number of error bytes in KEY2.
        constexpr uint32_t KEY2_FAIL = (1U << 23);  ///< 0: Means no failure and that the data of KEY2 is reliable. 1: Means that programming KEY2 failed and the number of error bytes is over 5.
        constexpr uint32_t KEY3_ERR_NUM = (3 << 24);  ///< The value of this signal means the number of error bytes in KEY3.
        constexpr uint32_t KEY3_FAIL = (1U << 27);  ///< 0: Means no failure and that the data of KEY3 is reliable. 1: Means that programming KEY3 failed and the number of error bytes is over 5.
        constexpr uint32_t KEY4_ERR_NUM = (3 << 28);  ///< The value of this signal means the number of error bytes in KEY4.
        constexpr uint32_t KEY4_FAIL = (1U << 31);  ///< 0: Means no failure and that the data of KEY4 is reliable. 1: Means that programming KEY4 failed and the number of error bytes is over 5.
    }

    /// RD_RS_ERR1 Register bits
    namespace rd_rs_err1_bits {
        constexpr uint32_t KEY5_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes in KEY5.
        constexpr uint32_t KEY5_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of KEY5 is reliable. 1: Means that programming user data failed and the number of error bytes is over 5.
        constexpr uint32_t SYS_PART2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes in BLOCK10.
        constexpr uint32_t SYS_PART2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of BLOCK10 is reliable. 1: Means that programming BLOCK10 data failed and the number of error bytes is over 5.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EFUSE_MEM_FORCE_PD = (1U << 0);  ///< If set, forces eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< If set, forces to activate clock signal of eFuse SRAM.
        constexpr uint32_t EFUSE_MEM_FORCE_PU = (1U << 2);  ///< If set, forces eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< If set, forces to enable clock signal of eFuse memory.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: Operate programming command. 0x5AA5: Operate read command.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t REPEAT_ERR_CNT = (8 << 10);  ///< Indicates the number of error bits during programming BLOCK0.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (4 << 2);  ///< The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t THR_A = (8 << 0);  ///< Configures the hold time of read operation.
        constexpr uint32_t TRD = (8 << 8);  ///< Configures the length of pulse of read operation.
        constexpr uint32_t TSUR_A = (8 << 16);  ///< Configures the setup time of read operation.
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the initial read time of eFuse.
    }

    /// WR_TIM_CONF0 Register bits
    namespace wr_tim_conf0_bits {
        constexpr uint32_t THP_A = (8 << 0);  ///< Configures the hold time of programming operation.
        constexpr uint32_t TPGM_INACTIVE = (8 << 8);  ///< Configures the length of pulse during programming 0 to eFuse.
        constexpr uint32_t TPGM = (16 << 16);  ///< Configures the length of pulse during programming 1 to eFuse.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t TSUP_A = (8 << 0);  ///< Configures the setup time of programming operation.
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Version control register.
    }

}

// ============================================================================
// EXTMEM Peripheral
// ============================================================================

namespace extmem {
    /// Base addresses
    constexpr uint32_t EXTMEM_BASE = 0x61800000;

    /// EXTMEM Register structure
    struct Registers {
        volatile uint32_t PRO_DCACHE_CTRL;  ///< Offset: 0x00 - register description
        volatile uint32_t PRO_DCACHE_CTRL1;  ///< Offset: 0x04 - register description
        volatile uint32_t PRO_DCACHE_TAG_POWER_CTRL;  ///< Offset: 0x08 - register description
        volatile uint32_t PRO_DCACHE_LOCK0_ADDR;  ///< Offset: 0x0C - register description
        volatile uint32_t PRO_DCACHE_LOCK0_SIZE;  ///< Offset: 0x10 - register description
        volatile uint32_t PRO_DCACHE_LOCK1_ADDR;  ///< Offset: 0x14 - register description
        volatile uint32_t PRO_DCACHE_LOCK1_SIZE;  ///< Offset: 0x18 - register description
        volatile uint32_t PRO_DCACHE_MEM_SYNC0;  ///< Offset: 0x1C - register description
        volatile uint32_t PRO_DCACHE_MEM_SYNC1;  ///< Offset: 0x20 - register description
        volatile uint32_t PRO_DCACHE_PRELOAD_ADDR;  ///< Offset: 0x24 - register description
        volatile uint32_t PRO_DCACHE_PRELOAD_SIZE;  ///< Offset: 0x28 - register description
        volatile uint32_t PRO_DCACHE_AUTOLOAD_CFG;  ///< Offset: 0x2C - register description
        volatile uint32_t PRO_DCACHE_AUTOLOAD_SECTION0_ADDR;  ///< Offset: 0x30 - register description
        volatile uint32_t PRO_DCACHE_AUTOLOAD_SECTION0_SIZE;  ///< Offset: 0x34 - register description
        volatile uint32_t PRO_DCACHE_AUTOLOAD_SECTION1_ADDR;  ///< Offset: 0x38 - register description
        volatile uint32_t PRO_DCACHE_AUTOLOAD_SECTION1_SIZE;  ///< Offset: 0x3C - register description
        volatile uint32_t PRO_ICACHE_CTRL;  ///< Offset: 0x40 - register description
        volatile uint32_t PRO_ICACHE_CTRL1;  ///< Offset: 0x44 - register description
        volatile uint32_t PRO_ICACHE_TAG_POWER_CTRL;  ///< Offset: 0x48 - register description
        volatile uint32_t PRO_ICACHE_LOCK0_ADDR;  ///< Offset: 0x4C - register description
        volatile uint32_t PRO_ICACHE_LOCK0_SIZE;  ///< Offset: 0x50 - register description
        volatile uint32_t PRO_ICACHE_LOCK1_ADDR;  ///< Offset: 0x54 - register description
        volatile uint32_t PRO_ICACHE_LOCK1_SIZE;  ///< Offset: 0x58 - register description
        volatile uint32_t PRO_ICACHE_MEM_SYNC0;  ///< Offset: 0x5C - register description
        volatile uint32_t PRO_ICACHE_MEM_SYNC1;  ///< Offset: 0x60 - register description
        volatile uint32_t PRO_ICACHE_PRELOAD_ADDR;  ///< Offset: 0x64 - register description
        volatile uint32_t PRO_ICACHE_PRELOAD_SIZE;  ///< Offset: 0x68 - register description
        volatile uint32_t PRO_ICACHE_AUTOLOAD_CFG;  ///< Offset: 0x6C - register description
        volatile uint32_t PRO_ICACHE_AUTOLOAD_SECTION0_ADDR;  ///< Offset: 0x70 - register description
        volatile uint32_t PRO_ICACHE_AUTOLOAD_SECTION0_SIZE;  ///< Offset: 0x74 - register description
        volatile uint32_t PRO_ICACHE_AUTOLOAD_SECTION1_ADDR;  ///< Offset: 0x78 - register description
        volatile uint32_t PRO_ICACHE_AUTOLOAD_SECTION1_SIZE;  ///< Offset: 0x7C - register description
        volatile uint32_t IC_PRELOAD_CNT;  ///< Offset: 0x80 - register description
        volatile uint32_t IC_PRELOAD_MISS_CNT;  ///< Offset: 0x84 - register description
        volatile uint32_t IBUS2_ABANDON_CNT;  ///< Offset: 0x88 - register description
        volatile uint32_t IBUS1_ABANDON_CNT;  ///< Offset: 0x8C - register description
        volatile uint32_t IBUS0_ABANDON_CNT;  ///< Offset: 0x90 - register description
        volatile uint32_t IBUS2_ACS_MISS_CNT;  ///< Offset: 0x94 - register description
        volatile uint32_t IBUS1_ACS_MISS_CNT;  ///< Offset: 0x98 - register description
        volatile uint32_t IBUS0_ACS_MISS_CNT;  ///< Offset: 0x9C - register description
        volatile uint32_t IBUS2_ACS_CNT;  ///< Offset: 0xA0 - register description
        volatile uint32_t IBUS1_ACS_CNT;  ///< Offset: 0xA4 - register description
        volatile uint32_t IBUS0_ACS_CNT;  ///< Offset: 0xA8 - register description
        volatile uint32_t DC_PRELOAD_CNT;  ///< Offset: 0xAC - register description
        volatile uint32_t DC_PRELOAD_EVICT_CNT;  ///< Offset: 0xB0 - register description
        volatile uint32_t DC_PRELOAD_MISS_CNT;  ///< Offset: 0xB4 - register description
        volatile uint32_t DBUS2_ABANDON_CNT;  ///< Offset: 0xB8 - register description
        volatile uint32_t DBUS1_ABANDON_CNT;  ///< Offset: 0xBC - register description
        volatile uint32_t DBUS0_ABANDON_CNT;  ///< Offset: 0xC0 - register description
        volatile uint32_t DBUS2_ACS_WB_CNT;  ///< Offset: 0xC4 - register description
        volatile uint32_t DBUS1_ACS_WB_CNT;  ///< Offset: 0xC8 - register description
        volatile uint32_t DBUS0_ACS_WB_CNT;  ///< Offset: 0xCC - register description
        volatile uint32_t DBUS2_ACS_MISS_CNT;  ///< Offset: 0xD0 - register description
        volatile uint32_t DBUS1_ACS_MISS_CNT;  ///< Offset: 0xD4 - register description
        volatile uint32_t DBUS0_ACS_MISS_CNT;  ///< Offset: 0xD8 - register description
        volatile uint32_t DBUS2_ACS_CNT;  ///< Offset: 0xDC - register description
        volatile uint32_t DBUS1_ACS_CNT;  ///< Offset: 0xE0 - register description
        volatile uint32_t DBUS0_ACS_CNT;  ///< Offset: 0xE4 - register description
        volatile uint32_t CACHE_DBG_INT_ENA;  ///< Offset: 0xE8 - register description
        volatile uint32_t CACHE_DBG_INT_CLR;  ///< Offset: 0xEC - register description
        volatile uint32_t CACHE_DBG_STATUS0;  ///< Offset: 0xF0 - register description
        volatile uint32_t CACHE_DBG_STATUS1;  ///< Offset: 0xF4 - register description
        volatile uint32_t PRO_CACHE_ACS_CNT_CLR;  ///< Offset: 0xF8 - register description
        volatile uint32_t PRO_DCACHE_REJECT_ST;  ///< Offset: 0xFC - register description
        volatile uint32_t PRO_DCACHE_REJECT_VADDR;  ///< Offset: 0x100 - register description
        volatile uint32_t PRO_ICACHE_REJECT_ST;  ///< Offset: 0x104 - register description
        volatile uint32_t PRO_ICACHE_REJECT_VADDR;  ///< Offset: 0x108 - register description
        volatile uint32_t PRO_CACHE_MMU_FAULT_CONTENT;  ///< Offset: 0x10C - register description
        volatile uint32_t PRO_CACHE_MMU_FAULT_VADDR;  ///< Offset: 0x110 - register description
        volatile uint32_t PRO_CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0x114 - register description
        volatile uint32_t PRO_CACHE_MMU_POWER_CTRL;  ///< Offset: 0x118 - register description
        volatile uint32_t PRO_CACHE_STATE;  ///< Offset: 0x11C - register description
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE;  ///< Offset: 0x120 - register description
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON;  ///< Offset: 0x124 - register description
        volatile uint32_t CACHE_BRIDGE_ARBITER_CTRL;  ///< Offset: 0x128 - register description
        volatile uint32_t CACHE_PRELOAD_INT_CTRL;  ///< Offset: 0x12C - register description
        volatile uint32_t CACHE_SYNC_INT_CTRL;  ///< Offset: 0x130 - register description
        volatile uint32_t CACHE_CONF_MISC;  ///< Offset: 0x134 - register description
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x138 - register description
        volatile uint32_t PRO_EXTMEM_REG_DATE;  ///< Offset: 0x3FC - register description
    };

    /// Peripheral instances
    inline Registers* EXTMEM = reinterpret_cast<Registers*>(EXTMEM_BASE);

    // Bit definitions
    /// PRO_DCACHE_CTRL Register bits
    namespace pro_dcache_ctrl_bits {
        constexpr uint32_t PRO_DCACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
        constexpr uint32_t PRO_DCACHE_SETSIZE_MODE = (1U << 2);  ///< The bit is used to configure cache memory size.0: 8KB, 1: 16KB
        constexpr uint32_t PRO_DCACHE_BLOCKSIZE_MODE = (1U << 3);  ///< The bit is used to configure cache block size.0: 16 bytes, 1: 32 bytes
        constexpr uint32_t PRO_DCACHE_INVALIDATE_ENA = (1U << 8);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t PRO_DCACHE_INVALIDATE_DONE = (1U << 9);  ///< The bit is used to indicate invalidate operation is finished.
        constexpr uint32_t PRO_DCACHE_FLUSH_ENA = (1U << 10);  ///< The bit is used to enable flush operation. It will be cleared by hardware after flush operation done.
        constexpr uint32_t PRO_DCACHE_FLUSH_DONE = (1U << 11);  ///< The bit is used to indicate flush operation is finished.
        constexpr uint32_t PRO_DCACHE_CLEAN_ENA = (1U << 12);  ///< The bit is used to enable clean operation. It will be cleared by hardware after clean operation done.
        constexpr uint32_t PRO_DCACHE_CLEAN_DONE = (1U << 13);  ///< The bit is used to indicate clean operation is finished.
        constexpr uint32_t PRO_DCACHE_LOCK0_EN = (1U << 14);  ///< The bit is used to enable pre-lock operation which is combined with PRO_DCACHE_LOCK0_ADDR_REG and PRO_DCACHE_LOCK0_SIZE_REG.
        constexpr uint32_t PRO_DCACHE_LOCK1_EN = (1U << 15);  ///< The bit is used to enable pre-lock operation which is combined with PRO_DCACHE_LOCK1_ADDR_REG and PRO_DCACHE_LOCK1_SIZE_REG.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_ENA = (1U << 18);  ///< The bit is used to enable and disable conditional-preload operation. It is combined with pre_dcache_autoload_done. 1: enable, 0: disable.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_DONE = (1U << 19);  ///< The bit is used to indicate conditional-preload operation is finished.
        constexpr uint32_t PRO_DCACHE_PRELOAD_ENA = (1U << 20);  ///< The bit is used to enable preload operation. It will be cleared by hardware after preload operation done.
        constexpr uint32_t PRO_DCACHE_PRELOAD_DONE = (1U << 21);  ///< The bit is used to indicate preload operation is finished.
        constexpr uint32_t PRO_DCACHE_UNLOCK_ENA = (1U << 22);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done.
        constexpr uint32_t PRO_DCACHE_UNLOCK_DONE = (1U << 23);  ///< The bit is used to indicate unlock operation is finished.
        constexpr uint32_t PRO_DCACHE_LOCK_ENA = (1U << 24);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done.
        constexpr uint32_t PRO_DCACHE_LOCK_DONE = (1U << 25);  ///< The bit is used to indicate lock operation is finished.
    }

    /// PRO_DCACHE_CTRL1 Register bits
    namespace pro_dcache_ctrl1_bits {
        constexpr uint32_t PRO_DCACHE_MASK_BUS0 = (1U << 0);  ///< The bit is used to disable dbus0, 0: enable, 1: disable
        constexpr uint32_t PRO_DCACHE_MASK_BUS1 = (1U << 1);  ///< The bit is used to disable dbus1, 0: enable, 1: disable
        constexpr uint32_t PRO_DCACHE_MASK_BUS2 = (1U << 2);  ///< The bit is used to disable dbus2, 0: enable, 1: disable
    }

    /// PRO_DCACHE_TAG_POWER_CTRL Register bits
    namespace pro_dcache_tag_power_ctrl_bits {
        constexpr uint32_t PRO_DCACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of dcache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t PRO_DCACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power dcache tag memory down, 0: follow rtc_lslp_pd, 1: power down
        constexpr uint32_t PRO_DCACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power dcache tag memory down, 0: follow rtc_lslp_pd, 1: power up
    }

    /// PRO_DCACHE_LOCK0_ADDR Register bits
    namespace pro_dcache_lock0_addr_bits {
        constexpr uint32_t PRO_DCACHE_LOCK0_ADDR = (32 << 0);  ///< The bits are used to configure the first start virtual address of data locking, which is combined with PRO_DCACHE_LOCK0_SIZE_REG
    }

    /// PRO_DCACHE_LOCK0_SIZE Register bits
    namespace pro_dcache_lock0_size_bits {
        constexpr uint32_t PRO_DCACHE_LOCK0_SIZE = (16 << 0);  ///< The bits are used to configure the first length of data locking, which is combined with PRO_DCACHE_LOCK0_ADDR_REG
    }

    /// PRO_DCACHE_LOCK1_ADDR Register bits
    namespace pro_dcache_lock1_addr_bits {
        constexpr uint32_t PRO_DCACHE_LOCK1_ADDR = (32 << 0);  ///< The bits are used to configure the second start virtual address of data locking, which is combined with PRO_DCACHE_LOCK1_SIZE_REG
    }

    /// PRO_DCACHE_LOCK1_SIZE Register bits
    namespace pro_dcache_lock1_size_bits {
        constexpr uint32_t PRO_DCACHE_LOCK1_SIZE = (16 << 0);  ///< The bits are used to configure the second length of data locking, which is combined with PRO_DCACHE_LOCK1_ADDR_REG
    }

    /// PRO_DCACHE_MEM_SYNC0 Register bits
    namespace pro_dcache_mem_sync0_bits {
        constexpr uint32_t PRO_DCACHE_MEMSYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for invalidate, flush, clean, lock and unlock operations. The manual operations will be issued if the address is validate. The auto operations will be issued if the address is invalidate. It should be combined with PRO_DCACHE_MEM_SYNC1.
    }

    /// PRO_DCACHE_MEM_SYNC1 Register bits
    namespace pro_dcache_mem_sync1_bits {
        constexpr uint32_t PRO_DCACHE_MEMSYNC_SIZE = (19 << 0);  ///< The bits are used to configure the length for invalidate, flush, clean, lock and unlock operations. The manual operations will be issued if it is validate. The auto operations will be issued if it is invalidate. It should be combined with PRO_DCACHE_MEM_SYNC0.
    }

    /// PRO_DCACHE_PRELOAD_ADDR Register bits
    namespace pro_dcache_preload_addr_bits {
        constexpr uint32_t PRO_DCACHE_PRELOAD_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for manual pre-load operation. It should be combined with PRO_DCACHE_PRELOAD_SIZE_REG.
    }

    /// PRO_DCACHE_PRELOAD_SIZE Register bits
    namespace pro_dcache_preload_size_bits {
        constexpr uint32_t PRO_DCACHE_PRELOAD_SIZE = (10 << 0);  ///< The bits are used to configure the length for manual pre-load operation. It should be combined with PRO_DCACHE_PRELOAD_ADDR_REG..
        constexpr uint32_t PRO_DCACHE_PRELOAD_ORDER = (1U << 10);  ///< The bits are used to configure the direction of manual pre-load operation. 1: descending, 0: ascending.
    }

    /// PRO_DCACHE_AUTOLOAD_CFG Register bits
    namespace pro_dcache_autoload_cfg_bits {
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_MODE = (1U << 0);  ///< Reserved.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_STEP = (2 << 1);  ///< Reserved.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_ORDER = (1U << 3);  ///< The bits are used to configure the direction of conditional pre-load operation. 1: descending, 0: ascending.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_RQST = (2 << 4);  ///< The bits are used to configure trigger conditions for conditional pre-load. 0/3: cache miss, 1: cache hit, 2: both cache miss and hit.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SIZE = (2 << 6);  ///< The bits are used to configure the numbers of the cache block for the issuing conditional pre-load operation.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bits are used to enable the second section for conditional pre-load operation.
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bits are used to enable the first section for conditional pre-load operation.
    }

    /// PRO_DCACHE_AUTOLOAD_SECTION0_ADDR Register bits
    namespace pro_dcache_autoload_section0_addr_bits {
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the first section for conditional pre-load operation. It should be combined with pro_dcache_autoload_sct0_ena.
    }

    /// PRO_DCACHE_AUTOLOAD_SECTION0_SIZE Register bits
    namespace pro_dcache_autoload_section0_size_bits {
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT0_SIZE = (24 << 0);  ///< The bits are used to configure the length of the first section for conditional pre-load operation. It should be combined with pro_dcache_autoload_sct0_ena.
    }

    /// PRO_DCACHE_AUTOLOAD_SECTION1_ADDR Register bits
    namespace pro_dcache_autoload_section1_addr_bits {
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the second section for conditional pre-load operation. It should be combined with pro_dcache_autoload_sct1_ena.
    }

    /// PRO_DCACHE_AUTOLOAD_SECTION1_SIZE Register bits
    namespace pro_dcache_autoload_section1_size_bits {
        constexpr uint32_t PRO_DCACHE_AUTOLOAD_SCT1_SIZE = (24 << 0);  ///< The bits are used to configure the length of the second section for conditional pre-load operation. It should be combined with pro_dcache_autoload_sct1_ena.
    }

    /// PRO_ICACHE_CTRL Register bits
    namespace pro_icache_ctrl_bits {
        constexpr uint32_t PRO_ICACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
        constexpr uint32_t PRO_ICACHE_SETSIZE_MODE = (1U << 2);  ///< The bit is used to configure cache memory size.0: 8KB, 1: 16KB
        constexpr uint32_t PRO_ICACHE_BLOCKSIZE_MODE = (1U << 3);  ///< The bit is used to configure cache block size.0: 16 bytes, 1: 32 bytes
        constexpr uint32_t PRO_ICACHE_INVALIDATE_ENA = (1U << 8);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t PRO_ICACHE_INVALIDATE_DONE = (1U << 9);  ///< The bit is used to indicate invalidate operation is finished.
        constexpr uint32_t PRO_ICACHE_LOCK0_EN = (1U << 14);  ///< The bit is used to enable pre-lock operation which is combined with PRO_ICACHE_LOCK0_ADDR_REG and PRO_ICACHE_LOCK0_SIZE_REG.
        constexpr uint32_t PRO_ICACHE_LOCK1_EN = (1U << 15);  ///< The bit is used to enable pre-lock operation which is combined with PRO_ICACHE_LOCK1_ADDR_REG and PRO_ICACHE_LOCK1_SIZE_REG.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_ENA = (1U << 18);  ///< The bit is used to enable and disable conditional-preload operation. It is combined with pre_dcache_autoload_done. 1: enable, 0: disable.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_DONE = (1U << 19);  ///< The bit is used to indicate conditional-preload operation is finished.
        constexpr uint32_t PRO_ICACHE_PRELOAD_ENA = (1U << 20);  ///< The bit is used to enable preload operation. It will be cleared by hardware after preload operation done.
        constexpr uint32_t PRO_ICACHE_PRELOAD_DONE = (1U << 21);  ///< The bit is used to indicate preload operation is finished.
        constexpr uint32_t PRO_ICACHE_UNLOCK_ENA = (1U << 22);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done.
        constexpr uint32_t PRO_ICACHE_UNLOCK_DONE = (1U << 23);  ///< The bit is used to indicate unlock operation is finished.
        constexpr uint32_t PRO_ICACHE_LOCK_ENA = (1U << 24);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done.
        constexpr uint32_t PRO_ICACHE_LOCK_DONE = (1U << 25);  ///< The bit is used to indicate lock operation is finished.
    }

    /// PRO_ICACHE_CTRL1 Register bits
    namespace pro_icache_ctrl1_bits {
        constexpr uint32_t PRO_ICACHE_MASK_BUS0 = (1U << 0);  ///< The bit is used to disable ibus0, 0: enable, 1: disable
        constexpr uint32_t PRO_ICACHE_MASK_BUS1 = (1U << 1);  ///< The bit is used to disable ibus1, 0: enable, 1: disable
        constexpr uint32_t PRO_ICACHE_MASK_BUS2 = (1U << 2);  ///< The bit is used to disable ibus2, 0: enable, 1: disable
    }

    /// PRO_ICACHE_TAG_POWER_CTRL Register bits
    namespace pro_icache_tag_power_ctrl_bits {
        constexpr uint32_t PRO_ICACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of icache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t PRO_ICACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power down
        constexpr uint32_t PRO_ICACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power up
    }

    /// PRO_ICACHE_LOCK0_ADDR Register bits
    namespace pro_icache_lock0_addr_bits {
        constexpr uint32_t PRO_ICACHE_LOCK0_ADDR = (32 << 0);  ///< The bits are used to configure the first start virtual address of data locking, which is combined with PRO_ICACHE_LOCK0_SIZE_REG
    }

    /// PRO_ICACHE_LOCK0_SIZE Register bits
    namespace pro_icache_lock0_size_bits {
        constexpr uint32_t PRO_ICACHE_LOCK0_SIZE = (16 << 0);  ///< The bits are used to configure the first length of data locking, which is combined with PRO_ICACHE_LOCK0_ADDR_REG
    }

    /// PRO_ICACHE_LOCK1_ADDR Register bits
    namespace pro_icache_lock1_addr_bits {
        constexpr uint32_t PRO_ICACHE_LOCK1_ADDR = (32 << 0);  ///< The bits are used to configure the second start virtual address of data locking, which is combined with PRO_ICACHE_LOCK1_SIZE_REG
    }

    /// PRO_ICACHE_LOCK1_SIZE Register bits
    namespace pro_icache_lock1_size_bits {
        constexpr uint32_t PRO_ICACHE_LOCK1_SIZE = (16 << 0);  ///< The bits are used to configure the second length of data locking, which is combined with PRO_ICACHE_LOCK1_ADDR_REG
    }

    /// PRO_ICACHE_MEM_SYNC0 Register bits
    namespace pro_icache_mem_sync0_bits {
        constexpr uint32_t PRO_ICACHE_MEMSYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for invalidate, flush, clean, lock and unlock operations. The manual operations will be issued if the address is validate. The auto operations will be issued if the address is invalidate. It should be combined with PRO_ICACHE_MEM_SYNC1.
    }

    /// PRO_ICACHE_MEM_SYNC1 Register bits
    namespace pro_icache_mem_sync1_bits {
        constexpr uint32_t PRO_ICACHE_MEMSYNC_SIZE = (19 << 0);  ///< The bits are used to configure the length for invalidate, flush, clean, lock and unlock operations. The manual operations will be issued if it is validate. The auto operations will be issued if it is invalidate. It should be combined with PRO_ICACHE_MEM_SYNC0.
    }

    /// PRO_ICACHE_PRELOAD_ADDR Register bits
    namespace pro_icache_preload_addr_bits {
        constexpr uint32_t PRO_ICACHE_PRELOAD_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for manual pre-load operation. It should be combined with PRO_ICACHE_PRELOAD_SIZE_REG.
    }

    /// PRO_ICACHE_PRELOAD_SIZE Register bits
    namespace pro_icache_preload_size_bits {
        constexpr uint32_t PRO_ICACHE_PRELOAD_SIZE = (10 << 0);  ///< The bits are used to configure the length for manual pre-load operation. It should be combined with PRO_ICACHE_PRELOAD_ADDR_REG..
        constexpr uint32_t PRO_ICACHE_PRELOAD_ORDER = (1U << 10);  ///< The bits are used to configure the direction of manual pre-load operation. 1: descending, 0: ascending.
    }

    /// PRO_ICACHE_AUTOLOAD_CFG Register bits
    namespace pro_icache_autoload_cfg_bits {
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_MODE = (1U << 0);  ///< Reserved.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_STEP = (2 << 1);  ///< Reserved.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_ORDER = (1U << 3);  ///< The bits are used to configure the direction of conditional pre-load operation. 1: descending, 0: ascending.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_RQST = (2 << 4);  ///< The bits are used to configure trigger conditions for conditional pre-load. 0/3: cache miss, 1: cache hit, 2: both cache miss and hit.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SIZE = (2 << 6);  ///< The bits are used to configure the numbers of the cache block for the issuing conditional pre-load operation.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT0_ENA = (1U << 8);  ///< The bits are used to enable the second section for conditional pre-load operation.
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT1_ENA = (1U << 9);  ///< The bits are used to enable the first section for conditional pre-load operation.
    }

    /// PRO_ICACHE_AUTOLOAD_SECTION0_ADDR Register bits
    namespace pro_icache_autoload_section0_addr_bits {
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the first section for conditional pre-load operation. It should be combined with pro_icache_autoload_sct0_ena.
    }

    /// PRO_ICACHE_AUTOLOAD_SECTION0_SIZE Register bits
    namespace pro_icache_autoload_section0_size_bits {
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT0_SIZE = (24 << 0);  ///< The bits are used to configure the length of the first section for conditional pre-load operation. It should be combined with pro_icache_autoload_sct0_ena.
    }

    /// PRO_ICACHE_AUTOLOAD_SECTION1_ADDR Register bits
    namespace pro_icache_autoload_section1_addr_bits {
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the second section for conditional pre-load operation. It should be combined with pro_icache_autoload_sct1_ena.
    }

    /// PRO_ICACHE_AUTOLOAD_SECTION1_SIZE Register bits
    namespace pro_icache_autoload_section1_size_bits {
        constexpr uint32_t PRO_ICACHE_AUTOLOAD_SCT1_SIZE = (24 << 0);  ///< The bits are used to configure the length of the second section for conditional pre-load operation. It should be combined with pro_icache_autoload_sct1_ena.
    }

    /// IC_PRELOAD_CNT Register bits
    namespace ic_preload_cnt_bits {
        constexpr uint32_t IC_PRELOAD_CNT = (16 << 0);  ///< The bits are used to count the number of issued pre-load which include manual pre-load and conditional pre-load.
    }

    /// IC_PRELOAD_MISS_CNT Register bits
    namespace ic_preload_miss_cnt_bits {
        constexpr uint32_t IC_PRELOAD_MISS_CNT = (16 << 0);  ///< The bits are used to count the number of missed pre-load which include manual pre-load and conditional pre-load.
    }

    /// IBUS2_ABANDON_CNT Register bits
    namespace ibus2_abandon_cnt_bits {
        constexpr uint32_t IBUS2_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned ibus2 access.
    }

    /// IBUS1_ABANDON_CNT Register bits
    namespace ibus1_abandon_cnt_bits {
        constexpr uint32_t IBUS1_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned ibus1 access.
    }

    /// IBUS0_ABANDON_CNT Register bits
    namespace ibus0_abandon_cnt_bits {
        constexpr uint32_t IBUS0_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned ibus0 access.
    }

    /// IBUS2_ACS_MISS_CNT Register bits
    namespace ibus2_acs_miss_cnt_bits {
        constexpr uint32_t IBUS2_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by ibus2 access.
    }

    /// IBUS1_ACS_MISS_CNT Register bits
    namespace ibus1_acs_miss_cnt_bits {
        constexpr uint32_t IBUS1_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by ibus1 access.
    }

    /// IBUS0_ACS_MISS_CNT Register bits
    namespace ibus0_acs_miss_cnt_bits {
        constexpr uint32_t IBUS0_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by ibus0 access.
    }

    /// IBUS2_ACS_CNT Register bits
    namespace ibus2_acs_cnt_bits {
        constexpr uint32_t IBUS2_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of ibus2 access icache.
    }

    /// IBUS1_ACS_CNT Register bits
    namespace ibus1_acs_cnt_bits {
        constexpr uint32_t IBUS1_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of ibus1 access icache.
    }

    /// IBUS0_ACS_CNT Register bits
    namespace ibus0_acs_cnt_bits {
        constexpr uint32_t IBUS0_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of ibus0 access icache.
    }

    /// DC_PRELOAD_CNT Register bits
    namespace dc_preload_cnt_bits {
        constexpr uint32_t DC_PRELOAD_CNT = (16 << 0);  ///< The bits are used to count the number of issued pre-load which include manual pre-load and conditional pre-load.
    }

    /// DC_PRELOAD_EVICT_CNT Register bits
    namespace dc_preload_evict_cnt_bits {
        constexpr uint32_t DC_PRELOAD_EVICT_CNT = (16 << 0);  ///< The bits are used to count the number of cache evictions by pre-load which include manual pre-load and conditional pre-load.
    }

    /// DC_PRELOAD_MISS_CNT Register bits
    namespace dc_preload_miss_cnt_bits {
        constexpr uint32_t DC_PRELOAD_MISS_CNT = (16 << 0);  ///< The bits are used to count the number of missed pre-load which include manual pre-load and conditional pre-load.
    }

    /// DBUS2_ABANDON_CNT Register bits
    namespace dbus2_abandon_cnt_bits {
        constexpr uint32_t DBUS2_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned dbus2 access.
    }

    /// DBUS1_ABANDON_CNT Register bits
    namespace dbus1_abandon_cnt_bits {
        constexpr uint32_t DBUS1_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned dbus1 access.
    }

    /// DBUS0_ABANDON_CNT Register bits
    namespace dbus0_abandon_cnt_bits {
        constexpr uint32_t DBUS0_ABANDON_CNT = (16 << 0);  ///< The bits are used to count the number of the abandoned dbus0 access.
    }

    /// DBUS2_ACS_WB_CNT Register bits
    namespace dbus2_acs_wb_cnt_bits {
        constexpr uint32_t DBUS2_ACS_WB_CNT = (20 << 0);  ///< The bits are used to count the number of cache evictions by dbus2 access cache.
    }

    /// DBUS1_ACS_WB_CNT Register bits
    namespace dbus1_acs_wb_cnt_bits {
        constexpr uint32_t DBUS1_ACS_WB_CNT = (20 << 0);  ///< The bits are used to count the number of cache evictions by dbus1 access cache.
    }

    /// DBUS0_ACS_WB_CNT Register bits
    namespace dbus0_acs_wb_cnt_bits {
        constexpr uint32_t DBUS0_ACS_WB_CNT = (20 << 0);  ///< The bits are used to count the number of cache evictions by dbus0 access cache.
    }

    /// DBUS2_ACS_MISS_CNT Register bits
    namespace dbus2_acs_miss_cnt_bits {
        constexpr uint32_t DBUS2_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus2 access.
    }

    /// DBUS1_ACS_MISS_CNT Register bits
    namespace dbus1_acs_miss_cnt_bits {
        constexpr uint32_t DBUS1_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus1 access.
    }

    /// DBUS0_ACS_MISS_CNT Register bits
    namespace dbus0_acs_miss_cnt_bits {
        constexpr uint32_t DBUS0_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus0 access.
    }

    /// DBUS2_ACS_CNT Register bits
    namespace dbus2_acs_cnt_bits {
        constexpr uint32_t DBUS2_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of dbus2 access dcache.
    }

    /// DBUS1_ACS_CNT Register bits
    namespace dbus1_acs_cnt_bits {
        constexpr uint32_t DBUS1_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of dbus1 access dcache.
    }

    /// DBUS0_ACS_CNT Register bits
    namespace dbus0_acs_cnt_bits {
        constexpr uint32_t DBUS0_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of dbus0 access dcache.
    }

    /// CACHE_DBG_INT_ENA Register bits
    namespace cache_dbg_int_ena_bits {
        constexpr uint32_t CACHE_DBG_EN = (1U << 0);  ///< The bit is used to activate the cache track function. 1: enable, 0: disable.
        constexpr uint32_t IBUS_ACS_MSK_IC_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding ibus is disabled which include speculative access.
        constexpr uint32_t IBUS_CNT_OVF_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by ibus counter overflow.
        constexpr uint32_t IC_SYNC_SIZE_FAULT_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by manual sync configurations fault.
        constexpr uint32_t IC_PRELOAD_SIZE_FAULT_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by manual pre-load configurations fault.
        constexpr uint32_t ICACHE_REJECT_INT_ENA = (1U << 6);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t ICACHE_SET_PRELOAD_ILG_INT_ENA = (1U << 7);  ///< The bit is used to enable interrupt by illegal writing preload registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t ICACHE_SET_SYNC_ILG_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt by illegal writing sync registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t ICACHE_SET_LOCK_ILG_INT_ENA = (1U << 9);  ///< The bit is used to enable interrupt by illegal writing lock registers of icache while icache is busy to issue lock,sync or pre-load operations.
        constexpr uint32_t DBUS_ACS_MSK_DC_INT_ENA = (1U << 10);  ///< The bit is used to enable interrupt by cpu access dcache while the corresponding dbus is disabled which include speculative access.
        constexpr uint32_t DBUS_CNT_OVF_INT_ENA = (1U << 11);  ///< The bit is used to enable interrupt by dbus counter overflow.
        constexpr uint32_t DC_SYNC_SIZE_FAULT_INT_ENA = (1U << 12);  ///< The bit is used to enable interrupt by manual sync configurations fault.
        constexpr uint32_t DC_PRELOAD_SIZE_FAULT_INT_ENA = (1U << 13);  ///< The bit is used to enable interrupt by manual pre-load configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_INT_ENA = (1U << 14);  ///< The bit is used to enable interrupt by dcache trying to write flash.
        constexpr uint32_t DCACHE_REJECT_INT_ENA = (1U << 15);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t DCACHE_SET_PRELOAD_ILG_INT_ENA = (1U << 16);  ///< The bit is used to enable interrupt by illegal writing preload registers of dcache while dcache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t DCACHE_SET_SYNC_ILG_INT_ENA = (1U << 17);  ///< The bit is used to enable interrupt by illegal writing sync registers of dcache while dcache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t DCACHE_SET_LOCK_ILG_INT_ENA = (1U << 18);  ///< The bit is used to enable interrupt by illegal writing lock registers of dcache while dcache is busy to issue lock,sync or pre-load operations.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_ENA = (1U << 19);  ///< The bit is used to enable interrupt by mmu entry fault.
    }

    /// CACHE_DBG_INT_CLR Register bits
    namespace cache_dbg_int_clr_bits {
        constexpr uint32_t IBUS_ACS_MSK_IC_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t IBUS_CNT_OVF_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by ibus counter overflow.
        constexpr uint32_t IC_SYNC_SIZE_FAULT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by manual sync configurations fault.
        constexpr uint32_t IC_PRELOAD_SIZE_FAULT_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by manual pre-load configurations fault.
        constexpr uint32_t ICACHE_REJECT_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t ICACHE_SET_ILG_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by illegal writing lock registers of icache while icache is busy to issue lock,sync or pre-load operations.
        constexpr uint32_t DBUS_ACS_MSK_DC_INT_CLR = (1U << 6);  ///< The bit is used to clear interrupt by cpu access dcache while the corresponding dbus is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t DBUS_CNT_OVF_INT_CLR = (1U << 7);  ///< The bit is used to clear interrupt by dbus counter overflow.
        constexpr uint32_t DC_SYNC_SIZE_FAULT_INT_CLR = (1U << 8);  ///< The bit is used to clear interrupt by manual sync configurations fault.
        constexpr uint32_t DC_PRELOAD_SIZE_FAULT_INT_CLR = (1U << 9);  ///< The bit is used to clear interrupt by manual pre-load configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_INT_CLR = (1U << 10);  ///< The bit is used to clear interrupt by dcache trying to write flash.
        constexpr uint32_t DCACHE_REJECT_INT_CLR = (1U << 11);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t DCACHE_SET_ILG_INT_CLR = (1U << 12);  ///< The bit is used to clear interrupt by illegal writing lock registers of dcache while dcache is busy to issue lock,sync or pre-load operations.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_CLR = (1U << 13);  ///< The bit is used to clear interrupt by mmu entry fault.
    }

    /// CACHE_DBG_STATUS0 Register bits
    namespace cache_dbg_status0_bits {
        constexpr uint32_t IBUS0_ACS_MSK_ICACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access icache while the ibus0 is disabled or icache is disabled which include speculative access.
        constexpr uint32_t IBUS1_ACS_MSK_ICACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by cpu access icache while the ibus1 is disabled or icache is disabled which include speculative access.
        constexpr uint32_t IBUS2_ACS_MSK_ICACHE_ST = (1U << 2);  ///< The bit is used to indicate interrupt by cpu access icache while the ibus2 is disabled or icache is disabled which include speculative access.
        constexpr uint32_t IBUS0_ACS_CNT_OVF_ST = (1U << 4);  ///< The bit is used to indicate interrupt by ibus0 counter overflow.
        constexpr uint32_t IBUS1_ACS_CNT_OVF_ST = (1U << 5);  ///< The bit is used to indicate interrupt by ibus1 counter overflow.
        constexpr uint32_t IBUS2_ACS_CNT_OVF_ST = (1U << 6);  ///< The bit is used to indicate interrupt by ibus2 counter overflow.
        constexpr uint32_t IBUS0_ACS_MISS_CNT_OVF_ST = (1U << 8);  ///< The bit is used to indicate interrupt by ibus0 miss counter overflow.
        constexpr uint32_t IBUS1_ACS_MISS_CNT_OVF_ST = (1U << 9);  ///< The bit is used to indicate interrupt by ibus1 miss counter overflow.
        constexpr uint32_t IBUS2_ACS_MISS_CNT_OVF_ST = (1U << 10);  ///< The bit is used to indicate interrupt by ibus2 miss counter overflow.
        constexpr uint32_t IBUS0_ABANDON_CNT_OVF_ST = (1U << 12);  ///< The bit is used to indicate interrupt by ibus0 abandon counter overflow.
        constexpr uint32_t IBUS1_ABANDON_CNT_OVF_ST = (1U << 13);  ///< The bit is used to indicate interrupt by ibus1 abandon counter overflow.
        constexpr uint32_t IBUS2_ABANDON_CNT_OVF_ST = (1U << 14);  ///< The bit is used to indicate interrupt by ibus2 abandon counter overflow.
        constexpr uint32_t IC_PRELOAD_MISS_CNT_OVF_ST = (1U << 16);  ///< The bit is used to indicate interrupt by pre-load miss counter overflow.
        constexpr uint32_t IC_PRELOAD_CNT_OVF_ST = (1U << 18);  ///< The bit is used to indicate interrupt by pre-load counter overflow.
        constexpr uint32_t IC_SYNC_SIZE_FAULT_ST = (1U << 19);  ///< The bit is used to indicate interrupt by manual sync configurations fault.
        constexpr uint32_t IC_PRELOAD_SIZE_FAULT_ST = (1U << 20);  ///< The bit is used to indicate interrupt by manual pre-load configurations fault.
        constexpr uint32_t ICACHE_REJECT_ST = (1U << 21);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t ICACHE_SET_PRELOAD_ILG_ST = (1U << 22);  ///< The bit is used to indicate interrupt by illegal writing preload registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t ICACHE_SET_SYNC_ILG_ST = (1U << 23);  ///< The bit is used to indicate interrupt by illegal writing sync registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t ICACHE_SET_LOCK_ILG_ST = (1U << 24);  ///< The bit is used to indicate interrupt by illegal writing lock registers of icache while icache is busy to issue lock,sync or pre-load operations.
    }

    /// CACHE_DBG_STATUS1 Register bits
    namespace cache_dbg_status1_bits {
        constexpr uint32_t DBUS0_ACS_MSK_DCACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access dcache while the dbus0 is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t DBUS1_ACS_MSK_DCACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by cpu access dcache while the dbus1 is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t DBUS2_ACS_MSK_DCACHE_ST = (1U << 2);  ///< The bit is used to indicate interrupt by cpu access dcache while the dbus2 is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t DBUS0_ACS_CNT_OVF_ST = (1U << 4);  ///< The bit is used to indicate interrupt by dbus0 counter overflow.
        constexpr uint32_t DBUS1_ACS_CNT_OVF_ST = (1U << 5);  ///< The bit is used to indicate interrupt by dbus1 counter overflow.
        constexpr uint32_t DBUS2_ACS_CNT_OVF_ST = (1U << 6);  ///< The bit is used to indicate interrupt by dbus2 counter overflow.
        constexpr uint32_t DBUS0_ACS_MISS_CNT_OVF_ST = (1U << 8);  ///< The bit is used to indicate interrupt by dbus0 miss counter overflow.
        constexpr uint32_t DBUS1_ACS_MISS_CNT_OVF_ST = (1U << 9);  ///< The bit is used to indicate interrupt by dbus1 miss counter overflow.
        constexpr uint32_t DBUS2_ACS_MISS_CNT_OVF_ST = (1U << 10);  ///< The bit is used to indicate interrupt by dbus2 miss counter overflow.
        constexpr uint32_t DBUS0_ACS_WB_CNT_OVF_ST = (1U << 12);  ///< The bit is used to indicate interrupt by dbus0 eviction counter overflow.
        constexpr uint32_t DBUS1_ACS_WB_CNT_OVF_ST = (1U << 13);  ///< The bit is used to indicate interrupt by dbus1 eviction counter overflow.
        constexpr uint32_t DBUS2_ACS_WB_CNT_OVF_ST = (1U << 14);  ///< The bit is used to indicate interrupt by dbus2 eviction counter overflow.
        constexpr uint32_t DBUS0_ABANDON_CNT_OVF_ST = (1U << 16);  ///< The bit is used to indicate interrupt by dbus0 abandon counter overflow.
        constexpr uint32_t DBUS1_ABANDON_CNT_OVF_ST = (1U << 17);  ///< The bit is used to indicate interrupt by dbus1 abandon counter overflow.
        constexpr uint32_t DBUS2_ABANDON_CNT_OVF_ST = (1U << 18);  ///< The bit is used to indicate interrupt by dbus2 abandon counter overflow.
        constexpr uint32_t DC_PRELOAD_MISS_CNT_OVF_ST = (1U << 20);  ///< The bit is used to indicate interrupt by pre-load miss counter overflow.
        constexpr uint32_t DC_PRELOAD_EVICT_CNT_OVF_ST = (1U << 21);  ///< The bit is used to indicate interrupt by pre-load eviction counter overflow.
        constexpr uint32_t DC_PRELOAD_CNT_OVF_ST = (1U << 22);  ///< The bit is used to indicate interrupt by pre-load counter overflow.
        constexpr uint32_t DC_SYNC_SIZE_FAULT_ST = (1U << 23);  ///< The bit is used to indicate interrupt by manual sync configurations fault.
        constexpr uint32_t DC_PRELOAD_SIZE_FAULT_ST = (1U << 24);  ///< The bit is used to indicate interrupt by manual pre-load configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_ST = (1U << 25);  ///< The bit is used to indicate interrupt by dcache trying to write flash.
        constexpr uint32_t DCACHE_REJECT_ST = (1U << 26);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t DCACHE_SET_PRELOAD_ILG_ST = (1U << 27);  ///< The bit is used to indicate interrupt by illegal writing preload registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t DCACHE_SET_SYNC_ILG_ST = (1U << 28);  ///< The bit is used to indicate interrupt by illegal writing sync registers of icache while icache is busy to issue lock,sync and pre-load operations.
        constexpr uint32_t DCACHE_SET_LOCK_ILG_ST = (1U << 29);  ///< The bit is used to indicate interrupt by illegal writing lock registers of icache while icache is busy to issue lock,sync or pre-load operations.
        constexpr uint32_t MMU_ENTRY_FAULT_ST = (1U << 30);  ///< The bit is used to indicate interrupt by mmu entry fault.
    }

    /// PRO_CACHE_ACS_CNT_CLR Register bits
    namespace pro_cache_acs_cnt_clr_bits {
        constexpr uint32_t PRO_DCACHE_ACS_CNT_CLR = (1U << 0);  ///< The bit is used to clear dcache counter which include DC_PRELOAD_CNT_REG, DC_PRELOAD_EVICT_CNT_REG, DC_PRELOAD_MISS_CNT_REG, DBUS0-2_ABANDON_CNT_REG, DBUS0-2_ACS_WB_CNT_REG, DBUS0-2_ACS_MISS_CNT_REG and DBUS0-2_ACS_CNT_REG.
        constexpr uint32_t PRO_ICACHE_ACS_CNT_CLR = (1U << 1);  ///< The bit is used to clear icache counter which include IC_PRELOAD_CNT_REG, IC_PRELOAD_MISS_CNT_REG, IBUS0-2_ABANDON_CNT_REG, IBUS0-2_ACS_MISS_CNT_REG and IBUS0-2_ACS_CNT_REG.
    }

    /// PRO_DCACHE_REJECT_ST Register bits
    namespace pro_dcache_reject_st_bits {
        constexpr uint32_t PRO_DCACHE_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t PRO_DCACHE_CPU_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access dcache when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
    }

    /// PRO_DCACHE_REJECT_VADDR Register bits
    namespace pro_dcache_reject_vaddr_bits {
        constexpr uint32_t PRO_DCACHE_CPU_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access dcache when authentication fail.
    }

    /// PRO_ICACHE_REJECT_ST Register bits
    namespace pro_icache_reject_st_bits {
        constexpr uint32_t PRO_ICACHE_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t PRO_ICACHE_CPU_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access icache when authentication fail. 0: invalidate, 1: execute-able, 2: read-able
    }

    /// PRO_ICACHE_REJECT_VADDR Register bits
    namespace pro_icache_reject_vaddr_bits {
        constexpr uint32_t PRO_ICACHE_CPU_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access icache when authentication fail.
    }

    /// PRO_CACHE_MMU_FAULT_CONTENT Register bits
    namespace pro_cache_mmu_fault_content_bits {
        constexpr uint32_t PRO_CACHE_MMU_FAULT_CONTENT = (17 << 0);  ///< The bits are used to indicate the content of mmu entry which cause mmu fault..
        constexpr uint32_t PRO_CACHE_MMU_FAULT_CODE = (3 << 17);  ///< The bits are used to indicate the operations which cause mmu fault occurrence. 0: default, 1: cpu miss, 2: preload miss, 3: flush, 4: cpu miss evict recovery address, 5: load miss evict recovery address, 6: external dma tx, 7: external dma rx
    }

    /// PRO_CACHE_MMU_FAULT_VADDR Register bits
    namespace pro_cache_mmu_fault_vaddr_bits {
        constexpr uint32_t PRO_CACHE_MMU_FAULT_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address which cause mmu fault..
    }

    /// PRO_CACHE_WRAP_AROUND_CTRL Register bits
    namespace pro_cache_wrap_around_ctrl_bits {
        constexpr uint32_t PRO_CACHE_FLASH_WRAP_AROUND = (1U << 0);  ///< The bit is used to enable wrap around mode when read data from flash.
        constexpr uint32_t PRO_CACHE_SRAM_RD_WRAP_AROUND = (1U << 1);  ///< The bit is used to enable wrap around mode when read data from spiram.
    }

    /// PRO_CACHE_MMU_POWER_CTRL Register bits
    namespace pro_cache_mmu_power_ctrl_bits {
        constexpr uint32_t PRO_CACHE_MMU_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to enable clock gating to save power when access mmu memory, 0: enable, 1: disable
        constexpr uint32_t PRO_CACHE_MMU_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power down
        constexpr uint32_t PRO_CACHE_MMU_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power up
    }

    /// PRO_CACHE_STATE Register bits
    namespace pro_cache_state_bits {
        constexpr uint32_t PRO_ICACHE_STATE = (12 << 0);  ///< The bit is used to indicate icache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
        constexpr uint32_t PRO_DCACHE_STATE = (12 << 12);  ///< The bit is used to indicate dcache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
    }

    /// CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE Register bits
    namespace cache_encrypt_decrypt_record_disable_bits {
        constexpr uint32_t RECORD_DISABLE_DB_ENCRYPT = (1U << 0);  ///< Reserved.
        constexpr uint32_t RECORD_DISABLE_G0CB_DECRYPT = (1U << 1);  ///< Reserved.
    }

    /// CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON Register bits
    namespace cache_encrypt_decrypt_clk_force_on_bits {
        constexpr uint32_t CLK_FORCE_ON_DB_ENCRYPT = (1U << 0);  ///< The bit is used to close clock gating of encrypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_G0CB_DECRYPT = (1U << 1);  ///< The bit is used to close clock gating of decrypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT = (1U << 2);  ///< The bit is used to close clock gating of encrypt and decrypt clock. 1: close gating, 0: open clock gating.
    }

    /// CACHE_BRIDGE_ARBITER_CTRL Register bits
    namespace cache_bridge_arbiter_ctrl_bits {
        constexpr uint32_t ALLOC_WB_HOLD_ARBITER = (1U << 0);  ///< Reserved.
    }

    /// CACHE_PRELOAD_INT_CTRL Register bits
    namespace cache_preload_int_ctrl_bits {
        constexpr uint32_t PRO_ICACHE_PRELOAD_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache pre-load done.
        constexpr uint32_t PRO_ICACHE_PRELOAD_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache pre-load done.
        constexpr uint32_t PRO_ICACHE_PRELOAD_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache pre-load done.
        constexpr uint32_t PRO_DCACHE_PRELOAD_INT_ST = (1U << 3);  ///< The bit is used to indicate the interrupt by dcache pre-load done.
        constexpr uint32_t PRO_DCACHE_PRELOAD_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt by dcache pre-load done.
        constexpr uint32_t PRO_DCACHE_PRELOAD_INT_CLR = (1U << 5);  ///< The bit is used to clear the interrupt by dcache pre-load done.
    }

    /// CACHE_SYNC_INT_CTRL Register bits
    namespace cache_sync_int_ctrl_bits {
        constexpr uint32_t PRO_ICACHE_SYNC_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache sync done.
        constexpr uint32_t PRO_ICACHE_SYNC_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache sync done.
        constexpr uint32_t PRO_ICACHE_SYNC_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache sync done.
        constexpr uint32_t PRO_DCACHE_SYNC_INT_ST = (1U << 3);  ///< The bit is used to indicate the interrupt by dcache sync done.
        constexpr uint32_t PRO_DCACHE_SYNC_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt by dcache sync done.
        constexpr uint32_t PRO_DCACHE_SYNC_INT_CLR = (1U << 5);  ///< The bit is used to clear the interrupt by dcache sync done.
    }

    /// CACHE_CONF_MISC Register bits
    namespace cache_conf_misc_bits {
        constexpr uint32_t PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT = (1U << 0);  ///< The bit is used to disable checking mmu entry fault by preload operation.
        constexpr uint32_t PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT = (1U << 1);  ///< The bit is used to disable checking mmu entry fault by sync operation.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Reserved.
    }

    /// PRO_EXTMEM_REG_DATE Register bits
    namespace pro_extmem_reg_date_bits {
        constexpr uint32_t PRO_EXTMEM_REG_DATE = (28 << 0);  ///< Reserved.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x3F413000;
    constexpr uint32_t I2C1_BASE = 0x3F427000;
    constexpr uint32_t RTC_I2C_BASE = 0x3F408C00;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - Configures the low level width of the SCL clock
        volatile uint32_t CTR;  ///< Offset: 0x04 - Transmission setting
        volatile uint32_t SR;  ///< Offset: 0x08 - Describe I2C work status
        volatile uint32_t TO;  ///< Offset: 0x0C - Setting time out control for receiving data
        volatile uint32_t SLAVE_ADDR;  ///< Offset: 0x10 - Local slave address setting
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - FIFO status register
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - FIFO configuration register
        volatile uint32_t DATA;  ///< Offset: 0x1C - RX FIFO read data
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Interrupt clear bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Interrupt enable bits
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - Status of captured I2C communication events
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - Configures the hold time after a negative SCL edge
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - Configures the sample time after a positive SCL edge
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - Configures the high level width of the SCL clock
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - Configures the interval between pulling SDA low and...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - Configures the interval between the positive edge of SCL...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - Configures the delay after the SCL clock edge for a stop...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - Configures the delay between the SDA and SCL positive...
        volatile uint32_t SCL_FILTER_CFG;  ///< Offset: 0x50 - SCL filter configuration register
        volatile uint32_t SDA_FILTER_CFG;  ///< Offset: 0x54 - SDA filter configuration register
        volatile uint32_t COMD%s;  ///< Offset: 0x58 - I2C command register %s
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x98 - SCL status time out register
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x9C - SCL main status time out register
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0xA0 - Power configuration register
        volatile uint32_t SCL_STRETCH_CONF;  ///< Offset: 0xA4 - Set SCL stretch of I2C slave
        volatile uint32_t DATE;  ///< Offset: 0xF8 - Version control register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* RTC_I2C = reinterpret_cast<Registers*>(RTC_I2C_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (14 << 0);  ///< This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 0: direct output. 1: open drain output.
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 0: direct output. 1: open drain output.
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< This register is used to select the sample mode. 1: sample SDA data on the SCL low level. 0: sample SDA data on the SCL high level.
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        constexpr uint32_t MS_MODE = (1U << 4);  ///< Set this bit to configure the module as an I2C Master. Clear this bit to configure the module as an I2C Slave.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending the data in TX FIFO.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit. 0: send data from the most significant bit.
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received data. 1: receive data from the least significant bit. 0: receive data from the most significant bit.
        constexpr uint32_t CLK_EN = (1U << 8);  ///< Reserved.
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< This is the enable bit for I2C bus arbitration function.
        constexpr uint32_t FSM_RST = (1U << 10);  ///< This register is used to reset the SCL_FSM.
        constexpr uint32_t REF_ALWAYS_ON = (1U << 11);  ///< This register is used to control the REF_TICK.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< The received ACK value in master mode or slave mode. 0: ACK. 1: NACK.
        constexpr uint32_t SLAVE_RW = (1U << 1);  ///< When in slave mode, 1: master reads from slave. 0: master writes to slave.
        constexpr uint32_t TIME_OUT = (1U << 2);  ///< When the I2C controller takes more than I2C_TIME_OUT clocks to receive a data bit, this field changes to 1.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< When the I2C controller loses control of SCL line, this register changes to 1.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1: the I2C bus is busy transferring data. 0: the I2C bus is in idle state.
        constexpr uint32_t SLAVE_ADDRESSED = (1U << 5);  ///< When configured as an I2C Slave, and the address sent by the master is equal to the address of the slave, then this bit will be of high level.
        constexpr uint32_t BYTE_TRANS = (1U << 6);  ///< This field changes to 1 when one byte is transferred.
        constexpr uint32_t RXFIFO_CNT = (6 << 8);  ///< This field represents the amount of data needed to be sent.
        constexpr uint32_t STRETCH_CAUSE = (2 << 14);  ///< The cause of stretching SCL low in slave mode. 0: stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C TX FIFO is empty in slave mode. 2: stretching SCL low when I2C RX FIFO is full in slave mode.
        constexpr uint32_t TXFIFO_CNT = (6 << 18);  ///< This field stores the amount of received data in RAM.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This field indicates the states of the I2C module state machine. 0: Idle. 1: Address shift. 2: ACK address. 3: RX data. 4: TX data. 5: Send ACK. 6: Wait ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This field indicates the states of the state machine used to produce SCL. 0: Idle. 1: Start. 2: Negative edge. 3: Low. 4: Positive edge. 5: High. 6: Stop
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (24 << 0);  ///< This register is used to configure the timeout for receiving a data bit in APB clock cycles.
        constexpr uint32_t TIME_OUT_EN = (1U << 24);  ///< This is the enable bit for time out control.
    }

    /// SLAVE_ADDR Register bits
    namespace slave_addr_bits {
        constexpr uint32_t SLAVE_ADDR = (15 << 0);  ///< When configured as an I2C Slave, this field is used to configure the slave address.
        constexpr uint32_t ADDR_10BIT_EN = (1U << 31);  ///< This field is used to enable the slave 10-bit addressing mode in master mode.
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (5 << 0);  ///< This is the offset address of the last received data, as described in I2C_NONFIFO_RX_THRES.
        constexpr uint32_t RXFIFO_END_ADDR = (5 << 5);  ///< This is the offset address of the last received data, as described in I2C_NONFIFO_RX_THRES. This value refreshes when an I2C_RXFIFO_UDF_INT or I2C_TRANS_COMPLETE_INT interrupt is generated.
        constexpr uint32_t TXFIFO_START_ADDR = (5 << 10);  ///< This is the offset address of the first sent data, as described in I2C_NONFIFO_TX_THRES.
        constexpr uint32_t TXFIFO_END_ADDR = (5 << 15);  ///< This is the offset address of the last sent data, as described in I2C_NONFIFO_TX_THRES. The value refreshes when an I2C_TXFIFO_OVF_INT or I2C_TRANS_COMPLETE_INT interrupt is generated.
        constexpr uint32_t RX_UPDATE = (1U << 20);  ///< Write 0 or 1 to I2C_RX_UPDATE to update the value of I2C_RXFIFO_END_ADDR and I2C_RXFIFO_START_ADDR.
        constexpr uint32_t TX_UPDATE = (1U << 21);  ///< Write 0 or 1 to I2C_TX_UPDATE to update the value of I2C_TXFIFO_END_ADDR and I2C_TXFIFO_START_ADDR.
        constexpr uint32_t SLAVE_RW_POINT = (8 << 22);  ///< The received data in I2C slave mode.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (5 << 0);  ///< The water mark threshold of RX FIFO in non-FIFO mode. When I2C_FIFO_PRT_EN is 1 and RX FIFO counter is bigger than I2C_RXFIFO_WM_THRHD[4:0], I2C_RXFIFO_WM_INT_RAW bit will be valid.
        constexpr uint32_t TXFIFO_WM_THRHD = (5 << 5);  ///< The water mark threshold of TX FIFO in non-FIFO mode. When I2C_FIFO_PRT_EN is 1 and TX FIFO counter is smaller than I2C_TXFIFO_WM_THRHD[4:0], I2C_TXFIFO_WM_INT_RAW bit will be valid.
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enable APB non-FIFO mode.
        constexpr uint32_t FIFO_ADDR_CFG_EN = (1U << 11);  ///< When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset RX FIFO.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset TX FIFO.
        constexpr uint32_t NONFIFO_RX_THRES = (6 << 14);  ///< When I2C receives more than I2C_NONFIFO_RX_THRES bytes of data, it will generate an I2C_RXFIFO_UDF_INT interrupt and update the current offset address of the received data.
        constexpr uint32_t NONFIFO_TX_THRES = (6 << 20);  ///< When I2C sends more than I2C_NONFIFO_TX_THRES bytes of data, it will generate an I2C_TXFIFO_OVF_INT interrupt and update the current offset address of the sent data.
        constexpr uint32_t FIFO_PRT_EN = (1U << 26);  ///< The control enable bit of FIFO pointer in non-FIFO mode. This bit controls the valid bits and the interrupts of TX/RX FIFO overflow, underflow, full and empty.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The value of RX FIFO read data.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_RAW = (1U << 16);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< Set this bit to clear I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_CLR = (1U << 16);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ENA = (1U << 16);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ST = (1U << 16);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the interval between changing the SDA output level and the falling edge of SCL, in I2C module clock cycles.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the interval between the rising edge of SCL and the level sampling time of SDA, in I2C module clock cycles.
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (14 << 0);  ///< This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (14 << 14);  ///< This register is used to configure for the SCL_FSM's waiting period for SCL to go high in master mode, in I2C module clock cycles.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure interval between pulling SDA low and pulling SCL low when the master generates a START condition, in I2C module clock cycles.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the interval between the positive edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (14 << 0);  ///< This register is used to configure the delay after the STOP condition, in I2C module clock cycles.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (10 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the positive edge of SDA, in I2C module clock cycles.
    }

    /// SCL_FILTER_CFG Register bits
    namespace scl_filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< When a pulse on the SCL input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 4);  ///< This is the filter enable bit for SCL.
    }

    /// SDA_FILTER_CFG Register bits
    namespace sda_filter_cfg_bits {
        constexpr uint32_t SDA_FILTER_THRES = (4 << 0);  ///< When a pulse on the SDA input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SDA_FILTER_EN = (1U << 4);  ///< This is the filter enable bit for SDA.
    }

    /// COMD%s Register bits
    namespace comd%s_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART. 1: WRITE. 2: READ. 3: STOP. 4: END. byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more information.
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< When command 0 is done in I2C Master mode, this bit changes to high level.
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO = (24 << 0);  ///< The threshold value of SCL_FSM state unchanged period.
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO = (24 << 0);  ///< The threshold value of SCL_MAIN_FSM state unchanged period.
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to I2C_SCL_RST_SLV_NUM[4:0].
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< Configure the pulses of SCL generated in I2C master mode. Valid when I2C_SCL_RST_SLV_EN is 1.
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set I2C_SCL_FORCE_OUT and I2C_SCL_PD_EN to 1 to stretch SCL low.
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set I2C_SDA_FORCE_OUT and I2C_SDA_PD_EN to 1 to stretch SDA low.
    }

    /// SCL_STRETCH_CONF Register bits
    namespace scl_stretch_conf_bits {
        constexpr uint32_t STRETCH_PROTECT_NUM = (10 << 0);  ///< Configure the period of I2C slave stretching SCL line.
        constexpr uint32_t SLAVE_SCL_STRETCH_EN = (1U << 10);  ///< The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when I2C_SLAVE_SCL_STRETCH_EN is 1 and stretch event happens. The stretch cause can be seen in I2C_STRETCH_CAUSE.
        constexpr uint32_t SLAVE_SCL_STRETCH_CLR = (1U << 11);  ///< Set this bit to clear the I2C slave SCL stretch function.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the the version control register.
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x3F40F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x08 - I2S configuration register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - Interrupt clear bits
        volatile uint32_t TIMING;  ///< Offset: 0x1C - I2S timing register
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x20 - I2S FIFO configuration register
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x24 - I2S DMA RX EOF data length
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x28 - Constant single channel data
        volatile uint32_t CONF_CHAN;  ///< Offset: 0x2C - I2S channel configuration register
        volatile uint32_t OUT_LINK;  ///< Offset: 0x30 - I2S DMA TX configuration register
        volatile uint32_t IN_LINK;  ///< Offset: 0x34 - I2S DMA RX configuration register
        volatile uint32_t OUT_EOF_DES_ADDR;  ///< Offset: 0x38 - Address of outlink descriptor that produces EOF
        volatile uint32_t IN_EOF_DES_ADDR;  ///< Offset: 0x3C - Address of inlink descriptor that produces EOF
        volatile uint32_t OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x40 - Address of buffer relative to the outlink descriptor...
        volatile uint32_t INLINK_DSCR;  ///< Offset: 0x48 - Address of current inlink descriptor
        volatile uint32_t INLINK_DSCR_BF0;  ///< Offset: 0x4C - Address of next inlink descriptor
        volatile uint32_t INLINK_DSCR_BF1;  ///< Offset: 0x50 - Address of next inlink data buffer
        volatile uint32_t OUTLINK_DSCR;  ///< Offset: 0x54 - Address of current outlink descriptor
        volatile uint32_t OUTLINK_DSCR_BF0;  ///< Offset: 0x58 - Address of next outlink descriptor
        volatile uint32_t OUTLINK_DSCR_BF1;  ///< Offset: 0x5C - Address of next outlink data buffer
        volatile uint32_t LC_CONF;  ///< Offset: 0x60 - I2S DMA configuration register
        volatile uint32_t OUTFIFO_PUSH;  ///< Offset: 0x64 - APB out FIFO mode register
        volatile uint32_t INFIFO_POP;  ///< Offset: 0x68 - APB in FIFO mode register
        volatile uint32_t LC_STATE0;  ///< Offset: 0x6C - I2S DMA TX status
        volatile uint32_t LC_STATE1;  ///< Offset: 0x70 - I2S DMA RX status
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x74 - I2S Hung configuration register
        volatile uint32_t CONF1;  ///< Offset: 0xA0 - I2S configuration register 1
        volatile uint32_t PD_CONF;  ///< Offset: 0xA4 - I2S power-down configuration register
        volatile uint32_t CONF2;  ///< Offset: 0xA8 - I2S configuration register 2
        volatile uint32_t CLKM_CONF;  ///< Offset: 0xAC - I2S module clock configuration register
        volatile uint32_t SAMPLE_RATE_CONF;  ///< Offset: 0xB0 - I2S sample rate register
        volatile uint32_t STATE;  ///< Offset: 0xBC - I2S TX status register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< Set this bit to reset transmitter.
        constexpr uint32_t RX_RESET = (1U << 1);  ///< Set this bit to reset receiver.
        constexpr uint32_t TX_FIFO_RESET = (1U << 2);  ///< Set this bit to reset TX FIFO.
        constexpr uint32_t RX_FIFO_RESET = (1U << 3);  ///< Set this bit to reset RX FIFO.
        constexpr uint32_t TX_START = (1U << 4);  ///< Set this bit to start transmitting data.
        constexpr uint32_t RX_START = (1U << 5);  ///< Set this bit to start receiving data.
        constexpr uint32_t TX_SLAVE_MOD = (1U << 6);  ///< Set this bit to enable slave transmitter mode.
        constexpr uint32_t RX_SLAVE_MOD = (1U << 7);  ///< Set this bit to enable slave receiver mode.
        constexpr uint32_t TX_RIGHT_FIRST = (1U << 8);  ///< Set this bit to transmit right channel data first.
        constexpr uint32_t RX_RIGHT_FIRST = (1U << 9);  ///< Set this bit to receive right channel data first.
        constexpr uint32_t TX_MSB_SHIFT = (1U << 10);  ///< Set this bit to enable transmitter in Phillips standard mode.
        constexpr uint32_t RX_MSB_SHIFT = (1U << 11);  ///< Set this bit to enable receiver in Phillips standard mode.
        constexpr uint32_t TX_SHORT_SYNC = (1U << 12);  ///< Set this bit to enable transmitter in PCM standard mode.
        constexpr uint32_t RX_SHORT_SYNC = (1U << 13);  ///< Set this bit to enable receiver in PCM standard mode.
        constexpr uint32_t TX_MONO = (1U << 14);  ///< Set this bit to enable transmitter in mono mode.
        constexpr uint32_t RX_MONO = (1U << 15);  ///< Set this bit to enable receiver in mono mode.
        constexpr uint32_t TX_MSB_RIGHT = (1U << 16);  ///< Set this bit to place right channel data at the MSB in TX FIFO.
        constexpr uint32_t RX_MSB_RIGHT = (1U << 17);  ///< Set this bit to place right channel data at the MSB in RX FIFO.
        constexpr uint32_t TX_LSB_FIRST_DMA = (1U << 18);  ///< 1:the data in DMA/APB transform from low bits. 0:the data from DMA/APB transform from high bits.
        constexpr uint32_t RX_LSB_FIRST_DMA = (1U << 19);  ///< 1:the data in DMA/APB transform from low bits. 0:the data from DMA/APB transform from high bits.
        constexpr uint32_t SIG_LOOPBACK = (1U << 20);  ///< Enable signal loopback mode with transmitter module and receiver module sharing the same WS and BCK signals.
        constexpr uint32_t TX_FIFO_RESET_ST = (1U << 21);  ///< I2S TX FIFO reset status. 1: I2S_TX_FIFO_RESET is not completed. 0: I2S_TX_FIFO_RESET is completed.
        constexpr uint32_t RX_FIFO_RESET_ST = (1U << 22);  ///< I2S RX FIFO reset status. 1: I2S_RX_FIFO_RESET is not completed. 0: I2S_RX_FIFO_RESET is completed.
        constexpr uint32_t TX_RESET_ST = (1U << 23);  ///< I2S TX reset status. 1: I2S_TX_RESET is not completed. 0: I2S_TX_RESET is completed.
        constexpr uint32_t TX_DMA_EQUAL = (1U << 24);  ///< 1: Data in left channel is equal to data in right channel. 0: Data in left channel is not equal to data in right channel.
        constexpr uint32_t RX_DMA_EQUAL = (1U << 25);  ///< 1: Data in left channel is equal to data in right channel. 0: Data in left channel is not equal to data in right channel.
        constexpr uint32_t PRE_REQ_EN = (1U << 26);  ///< Set this bit to enable I2S to prepare data earlier.
        constexpr uint32_t TX_BIG_ENDIAN = (1U << 27);  ///< I2S TX byte endianness.
        constexpr uint32_t RX_BIG_ENDIAN = (1U << 28);  ///< I2S RX byte endianness.
        constexpr uint32_t RX_RESET_ST = (1U << 29);  ///< I2S RX reset status. 1: I2S_RX_RESET is not completed. 0: I2S_RX_RESET is completed.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for I2S_RX_TAKE_DATA_INT interrupt.
        constexpr uint32_t TX_PUT_DATA_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for I2S_TX_PUT_DATA_INT interrupt.
        constexpr uint32_t RX_WFULL_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for I2S_RX_WFULL_INT interrupt.
        constexpr uint32_t RX_REMPTY_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for I2S_RX_REMPTY_INT interrupt.
        constexpr uint32_t TX_WFULL_INT_RAW = (1U << 4);  ///< The raw interrupt status bit for I2S_TX_WFULL_INT interrupt.
        constexpr uint32_t TX_REMPTY_INT_RAW = (1U << 5);  ///< The raw interrupt status bit for I2S_TX_REMPTY_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 6);  ///< The raw interrupt status bit for I2S_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 7);  ///< The raw interrupt status bit for I2S_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 8);  ///< The raw interrupt status bit for I2S_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 9);  ///< The raw interrupt status bit for I2S_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 10);  ///< Reserved.
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 11);  ///< The raw interrupt status bit for I2S_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 12);  ///< The raw interrupt status bit for I2S_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_RAW = (1U << 13);  ///< The raw interrupt status bit for I2S_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_RAW = (1U << 14);  ///< The raw interrupt status bit for I2S_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_RAW = (1U << 15);  ///< The raw interrupt status bit for I2S_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 16);  ///< The raw interrupt status bit for I2S_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t V_SYNC_INT_RAW = (1U << 17);  ///< The raw interrupt status bit for I2S_V_SYNC_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2S_RX_TAKE_DATA_INT interrupt.
        constexpr uint32_t TX_PUT_DATA_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2S_TX_PUT_DATA_INT interrupt.
        constexpr uint32_t RX_WFULL_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2S_RX_WFULL_INT interrupt.
        constexpr uint32_t RX_REMPTY_INT_ST = (1U << 3);  ///< The masked interrupt status bit for I2S_RX_REMPTY_INT interrupt.
        constexpr uint32_t TX_WFULL_INT_ST = (1U << 4);  ///< The masked interrupt status bit for I2S_TX_WFULL_INT interrupt.
        constexpr uint32_t TX_REMPTY_INT_ST = (1U << 5);  ///< The masked interrupt status bit for I2S_TX_REMPTY_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2S_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 7);  ///< The masked interrupt status bit for I2S_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_ST = (1U << 8);  ///< The masked interrupt status bit for I2S_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 9);  ///< The masked interrupt status bit for I2S_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 10);  ///< Reserved.
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2S_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2S_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2S_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2S_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2S_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 16);  ///< The masked interrupt status bit for I2S_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t V_SYNC_INT_ST = (1U << 17);  ///< The masked interrupt status bit for I2S_V_SYNC_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_TAKE_DATA_INT_ENA = (1U << 0);  ///< The interrupt enable bit for I2S_RX_TAKE_DATA_INT interrupt.
        constexpr uint32_t TX_PUT_DATA_INT_ENA = (1U << 1);  ///< The interrupt enable bit for I2S_TX_PUT_DATA_INT interrupt.
        constexpr uint32_t RX_WFULL_INT_ENA = (1U << 2);  ///< The interrupt enable bit for I2S_RX_WFULL_INT interrupt.
        constexpr uint32_t RX_REMPTY_INT_ENA = (1U << 3);  ///< The interrupt enable bit for I2S_RX_REMPTY_INT interrupt.
        constexpr uint32_t TX_WFULL_INT_ENA = (1U << 4);  ///< The interrupt enable bit for I2S_TX_WFULL_INT interrupt.
        constexpr uint32_t TX_REMPTY_INT_ENA = (1U << 5);  ///< The interrupt enable bit for I2S_TX_REMPTY_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 6);  ///< The interrupt enable bit for I2S_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 7);  ///< The interrupt enable bit for I2S_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 8);  ///< The interrupt enable bit for I2S_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 9);  ///< The interrupt enable bit for I2S_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 10);  ///< Reserved.
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 11);  ///< The interrupt enable bit for I2S_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 12);  ///< The interrupt enable bit for I2S_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_ENA = (1U << 13);  ///< The interrupt enable bit for I2S_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_ENA = (1U << 14);  ///< The interrupt enable bit for I2S_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_ENA = (1U << 15);  ///< The interrupt enable bit for I2S_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 16);  ///< The interrupt enable bit for I2S_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t V_SYNC_INT_ENA = (1U << 17);  ///< The interrupt enable bit for I2S_V_SYNC_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TAKE_DATA_INT_CLR = (1U << 0);  ///< Set this bit to clear I2S_RX_TAKE_DATA_INT interrupt.
        constexpr uint32_t PUT_DATA_INT_CLR = (1U << 1);  ///< Set this bit to clear I2S_TX_PUT_DATA_INT interrupt.
        constexpr uint32_t RX_WFULL_INT_CLR = (1U << 2);  ///< Set this bit to clear I2S_RX_WFULL_INT interrupt.
        constexpr uint32_t RX_REMPTY_INT_CLR = (1U << 3);  ///< Set this bit to clear I2S_RX_REMPTY_INT interrupt.
        constexpr uint32_t TX_WFULL_INT_CLR = (1U << 4);  ///< Set this bit to clear I2S_TX_WFULL_INT interrupt.
        constexpr uint32_t TX_REMPTY_INT_CLR = (1U << 5);  ///< Set this bit to clear I2S_TX_REMPTY_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 6);  ///< Set this bit to clear I2S_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 7);  ///< Set this bit to clear I2S_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 8);  ///< Set this bit to clear I2S_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 9);  ///< Set this bit to clear I2S_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 10);  ///< Reserved.
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 11);  ///< Set this bit to clear I2S_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2S_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_CLR = (1U << 13);  ///< Set this bit to clear I2S_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_CLR = (1U << 14);  ///< Set this bit to clear I2S_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_CLR = (1U << 15);  ///< Set this bit to clear I2S_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 16);  ///< Set this bit to clear I2S_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t V_SYNC_INT_CLR = (1U << 17);  ///< Set this bit to clear I2S_V_SYNC_INT interrupt.
    }

    /// TIMING Register bits
    namespace timing_bits {
        constexpr uint32_t TX_BCK_IN_DELAY = (2 << 0);  ///< Number of delay cycles for BCK signal into the transmitter based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t TX_WS_IN_DELAY = (2 << 2);  ///< Number of delay cycles for WS signal into the transmitter based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t RX_BCK_IN_DELAY = (2 << 4);  ///< Number of delay cycles for BCK signal into the receiver based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t RX_WS_IN_DELAY = (2 << 6);  ///< Number of delay cycles for WS signal into the receiver based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t RX_SD_IN_DELAY = (2 << 8);  ///< Number of delay cycles for SD signal into the receiver based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t TX_BCK_OUT_DELAY = (2 << 10);  ///< Number of delay cycles for BCK signal out of the transmitter based on I2S0_CLK. 0: delayed by 0 cycle. 1: delayed by 1 cycle. 2: delayed by 2 cycles. 3: delayed by 3 cycles.
        constexpr uint32_t TX_WS_OUT_DELAY = (2 << 12);  ///< Number of delay cycles for WS signal out of the transmitter based on I2S0_CLK. 0: delayed by 0 cycle. 1: delayed by 1 cycle. 2: delayed by 2 cycles. 3: delayed by 3 cycles.
        constexpr uint32_t TX_SD_OUT_DELAY = (2 << 14);  ///< Number of delay cycles for SD signal out of the transmitter based on I2S0_CLK. 0: delayed by 0 cycle. 1: delayed by 1 cycle. 2: delayed by 2 cycles. 3: delayed by 3 cycles.
        constexpr uint32_t RX_WS_OUT_DELAY = (2 << 16);  ///< Number of delay cycles for WS signal out of the receiver based on I2S0_CLK. 0: delayed by 0 cycle. 1: delayed by 1 cycle. 2: delayed by 2 cycles. 3: delayed by 3 cycles.
        constexpr uint32_t RX_BCK_OUT_DELAY = (2 << 18);  ///< Number of delay cycles for BCK signal out of the receiver based on I2S0_CLK. 0: delayed by 0 cycle. 1: delayed by 1 cycle. 2: delayed by 2 cycles. 3: delayed by 3 cycles.
        constexpr uint32_t TX_DSYNC_SW = (1U << 20);  ///< Set this bit to synchronize signals into the transmitter by two flip-flop synchronizer. 0: the signals will be firstly clocked by rising clock edge , then clocked by falling clock edge. 1: the signals will be firstly clocked by falling clock edge, then clocked by rising clock edge.
        constexpr uint32_t RX_DSYNC_SW = (1U << 21);  ///< Set this bit to synchronize signals into the receiver by two flip-flop synchronizer. 0: the signals will be clocked by rising clock edge firstly, then clocked by falling clock edge. 1: the signals will be clocked by falling clock edge firstly, then clocked by rising clock edge.
        constexpr uint32_t DATA_ENABLE_DELAY = (2 << 22);  ///< Number of delay cycles for data valid flag based on I2S0_CLK. 0: delayed by 1.5 cycles. 1: delayed by 2.5 cycles. 2: delayed by 3.5 cycles. 3: delayed by 4.5 cycles.
        constexpr uint32_t TX_BCK_IN_INV = (1U << 24);  ///< Set this bit to invert BCK signal input to the slave transmitter.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RX_DATA_NUM = (6 << 0);  ///< I2S_RX_TAKE_DATA_INT is triggered when the left and right channel data number in RX FIFO is larger than the value of I2S_RX_DATA_NUM[5:0]. (RX FIFO is almost full threshold.)
        constexpr uint32_t TX_DATA_NUM = (6 << 6);  ///< I2S_TX_PUT_DATA_INT is triggered when the left and right channel data number in TX FIFO is smaller than the value of I2S_TX_DATA_NUM[5:0]. (TX FIFO is almost empty threshold.)
        constexpr uint32_t DSCR_EN = (1U << 12);  ///< Set this bit to enable I2S DMA mode.
        constexpr uint32_t TX_FIFO_MOD = (3 << 13);  ///< Transmitter FIFO mode configuration bits
        constexpr uint32_t RX_FIFO_MOD = (3 << 16);  ///< Receiver FIFO mode configuration bits
        constexpr uint32_t TX_FIFO_MOD_FORCE_EN = (1U << 19);  ///< The bit should always be set to 1
        constexpr uint32_t RX_FIFO_MOD_FORCE_EN = (1U << 20);  ///< The bit should always be set to 1
        constexpr uint32_t RX_FIFO_SYNC = (1U << 21);  ///< force write back rx data to memory
        constexpr uint32_t RX_24MSB_EN = (1U << 22);  ///< Only useful in rx 24bit mode. 1: the high 24 bits are effective in i2s fifo 0: the low 24 bits are effective in i2s fifo
        constexpr uint32_t TX_24MSB_EN = (1U << 23);  ///< Only useful in tx 24bit mode. 1: the high 24 bits are effective in i2s fifo 0: the low 24 bits are effective in i2s fifo
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (32 << 0);  ///< The length of data to be received. It will trigger I2S_IN_SUC_EOF_INT.
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SIGLE_DATA = (32 << 0);  ///< The right channel or left channel transmits constant value stored in this register according to I2S_TX_CHAN_MOD and I2S_TX_MSB_RIGHT.
    }

    /// CONF_CHAN Register bits
    namespace conf_chan_bits {
        constexpr uint32_t TX_CHAN_MOD = (3 << 0);  ///< I2S transmitter channel mode configuration bits.
        constexpr uint32_t RX_CHAN_MOD = (2 << 3);  ///< I2S receiver channel mode configuration bits.
    }

    /// OUT_LINK Register bits
    namespace out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< The address of first outlink descriptor.
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< Set this bit to stop outlink descriptor.
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< Set this bit to start outlink descriptor.
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< Set this bit to restart outlink descriptor.
        constexpr uint32_t OUTLINK_PARK = (1U << 31);  ///< OUTLINK_PARK
    }

    /// IN_LINK Register bits
    namespace in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< The address of first inlink descriptor.
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< Set this bit to stop inlink descriptor.
        constexpr uint32_t INLINK_START = (1U << 29);  ///< Set this bit to start inlink descriptor.
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< Set this bit to restart inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 31);  ///< INLINK_PARK
    }

    /// OUT_EOF_DES_ADDR Register bits
    namespace out_eof_des_addr_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< The address of outlink descriptor that produces EOF.
    }

    /// IN_EOF_DES_ADDR Register bits
    namespace in_eof_des_addr_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< The address of inlink descriptor that produces EOF.
    }

    /// OUT_EOF_BFR_DES_ADDR Register bits
    namespace out_eof_bfr_des_addr_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< The address of buffer relative to the outlink descriptor that produces EOF.
    }

    /// INLINK_DSCR Register bits
    namespace inlink_dscr_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of current inlink descriptor.
    }

    /// INLINK_DSCR_BF0 Register bits
    namespace inlink_dscr_bf0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of next inlink descriptor.
    }

    /// INLINK_DSCR_BF1 Register bits
    namespace inlink_dscr_bf1_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of next inlink data buffer.
    }

    /// OUTLINK_DSCR Register bits
    namespace outlink_dscr_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of current outlink descriptor.
    }

    /// OUTLINK_DSCR_BF0 Register bits
    namespace outlink_dscr_bf0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of next outlink descriptor.
    }

    /// OUTLINK_DSCR_BF1 Register bits
    namespace outlink_dscr_bf1_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of next outlink data buffer.
    }

    /// LC_CONF Register bits
    namespace lc_conf_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< Set this bit to reset in-DMA FSM. Set this bit before the DMA configuration.
        constexpr uint32_t OUT_RST = (1U << 1);  ///< Set this bit to reset out-DMA FSM. Set this bit before the DMA configuration.
        constexpr uint32_t AHBM_FIFO_RST = (1U << 2);  ///< Set this bit to reset AHB interface cmdFIFO of DMA. Set this bit before the DMA configuration.
        constexpr uint32_t AHBM_RST = (1U << 3);  ///< Set this bit to reset AHB interface of DMA. Set this bit before the DMA configuration.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 4);  ///< Set this bit to loop test inlink.
        constexpr uint32_t IN_LOOP_TEST = (1U << 5);  ///< Set this bit to loop test outlink.
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 6);  ///< Set this bit to enable outlink-written-back automatically when out buffer is transmitted done.
        constexpr uint32_t OUT_NO_RESTART_CLR = (1U << 7);  ///< Reserved.
        constexpr uint32_t OUT_EOF_MODE = (1U << 8);  ///< DMA out EOF flag generation mode. 1: When DMA has popped all data from the FIFO. 0: When AHB has pushed all data to the FIFO.
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 9);  ///< DMA outlink descriptor transfer mode configuration bit. 1: Prepare outlink descriptor with burst mode. 0: Prepare outlink descriptor with byte mode.
        constexpr uint32_t INDSCR_BURST_EN = (1U << 10);  ///< DMA inlink descriptor transfer mode configuration bit. 1: Prepare inlink descriptor with burst mode. 0: Prepare inlink descriptor with byte mode.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 11);  ///< Transmitter data transfer mode configuration bit. 1: Prepare out data with burst mode. 0: Prepare out data with byte mode.
        constexpr uint32_t CHECK_OWNER = (1U << 12);  ///< Set this bit to enable check owner bit by hardware.
        constexpr uint32_t MEM_TRANS_EN = (1U << 13);  ///< Reserved.
        constexpr uint32_t EXT_MEM_BK_SIZE = (2 << 14);  ///< DMA access external memory block size. 0: 16 bytes. 1: 32 bytes. 2: 64 bytes. 3: reserved.
    }

    /// OUTFIFO_PUSH Register bits
    namespace outfifo_push_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< APB out FIFO write data.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 16);  ///< APB out FIFO push.
    }

    /// INFIFO_POP Register bits
    namespace infifo_pop_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< APB in FIFO read data.
        constexpr uint32_t INFIFO_POP = (1U << 16);  ///< APB in FIFO pop.
    }

    /// LC_STATE0 Register bits
    namespace lc_state0_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< I2S DMA out descriptor address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< I2S DMA out descriptor state.
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< I2S DMA out data state.
        constexpr uint32_t OUTFIFO_CNT = (7 << 23);  ///< The remains of I2S DMA outfifo data.
        constexpr uint32_t OUT_FULL = (1U << 30);  ///< I2S DMA outfifo is full.
        constexpr uint32_t OUT_EMPTY = (1U << 31);  ///< I2S DMA outfifo is empty.
    }

    /// LC_STATE1 Register bits
    namespace lc_state1_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< I2S DMA in descriptor address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< I2S DMA in descriptor state.
        constexpr uint32_t IN_STATE = (3 << 20);  ///< I2S DMA in data state.
        constexpr uint32_t INFIFO_CNT_DEBUG = (7 << 23);  ///< The remains of I2S DMA infifo data.
        constexpr uint32_t IN_FULL = (1U << 30);  ///< I2S DMA infifo is full.
        constexpr uint32_t IN_EMPTY = (1U << 31);  ///< I2S DMA infifo is empty.
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< I2S_TX_HUNG_INT interrupt or I2S_RX_HUNG_INT interrupt will be triggered when FIFO hung counter is equal to this value.
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The bits are used to set the tick counter threshold. The tick counter is clocked by APB_CLK. The tick counter threshold is 88000/2^I2S_LC_FIFO_TIMEOUT_SHIFT. The tick counter is reset when it reaches the threshold.
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for FIFO timeout.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t TX_PCM_CONF = (3 << 0);  ///< Compress/Decompress module configuration bits. 0: decompress transmitted data 1:compress transmitted data
        constexpr uint32_t TX_PCM_BYPASS = (1U << 3);  ///< Set this bit to bypass Compress/Decompress module for transmitted data.
        constexpr uint32_t RX_PCM_CONF = (3 << 4);  ///< Compress/Decompress module configuration bits. 0: decompress received data 1:compress received data
        constexpr uint32_t RX_PCM_BYPASS = (1U << 7);  ///< Set this bit to bypass Compress/Decompress module for received data.
        constexpr uint32_t TX_STOP_EN = (1U << 8);  ///< Set this bit to stop the output of BCK signal and WS signal when TX FIFO is empty.
        constexpr uint32_t TX_ZEROS_RM_EN = (1U << 9);  ///< Reserved.
    }

    /// PD_CONF Register bits
    namespace pd_conf_bits {
        constexpr uint32_t FIFO_FORCE_PD = (1U << 0);  ///< Force FIFO power-down.
        constexpr uint32_t FIFO_FORCE_PU = (1U << 1);  ///< Force FIFO power-up.
        constexpr uint32_t PLC_MEM_FORCE_PD = (1U << 2);  ///< Force I2S memory power-down.
        constexpr uint32_t PLC_MEM_FORCE_PU = (1U << 3);  ///< Force I2S memory power-up.
        constexpr uint32_t DMA_RAM_FORCE_PD = (1U << 4);  ///< Force DMA FIFO power-down.
        constexpr uint32_t DMA_RAM_FORCE_PU = (1U << 5);  ///< Force DMA FIFO power-up.
        constexpr uint32_t DMA_RAM_CLK_FO = (1U << 6);  ///< Set this bit to force on DMA RAM clock.
    }

    /// CONF2 Register bits
    namespace conf2_bits {
        constexpr uint32_t CAMERA_EN = (1U << 0);  ///< Set this bit to enable camera mode.
        constexpr uint32_t LCD_TX_WRX2_EN = (1U << 1);  ///< LCD WR double for one datum.
        constexpr uint32_t LCD_TX_SDX2_EN = (1U << 2);  ///< Set this bit to duplicate data pairs (Frame Form 2) in LCD mode.
        constexpr uint32_t DATA_ENABLE_TEST_EN = (1U << 3);  ///< for debug camera mode enable
        constexpr uint32_t DATA_ENABLE = (1U << 4);  ///< for debug camera mode enable
        constexpr uint32_t LCD_EN = (1U << 5);  ///< Set this bit to enable LCD mode.
        constexpr uint32_t EXT_ADC_START_EN = (1U << 6);  ///< Set this bit to enable the function that ADC mode is triggered by external signal.
        constexpr uint32_t INTER_VALID_EN = (1U << 7);  ///< Set this bit to enable camera VGA reducing-resolution mode: only receive two consecutive cycle data in four consecutive clocks.
        constexpr uint32_t CAM_SYNC_FIFO_RESET = (1U << 8);  ///< Set this bit to reset FIFO in camera mode.
        constexpr uint32_t CAM_CLK_LOOPBACK = (1U << 9);  ///< Set this bit to loopback PCLK from I2S0I_WS_out.
        constexpr uint32_t VSYNC_FILTER_EN = (1U << 10);  ///< Set this bit to enable I2S VSYNC filter function.
        constexpr uint32_t VSYNC_FILTER_THRES = (3 << 11);  ///< Configure the I2S VSYNC filter threshold value.
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value.
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value.
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value.
        constexpr uint32_t CLK_EN = (1U << 20);  ///< Set this bit to enable clock gate.
        constexpr uint32_t CLK_SEL = (2 << 21);  ///< Set this bit to select I2S module clock source. 0: No clock. 1: APLL_CLK. 2: PLL_160M_CLK. 3: No clock.
    }

    /// SAMPLE_RATE_CONF Register bits
    namespace sample_rate_conf_bits {
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 0);  ///< Bit clock configuration bits in transmitter mode.
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 6);  ///< Bit clock configuration bits in receiver mode.
        constexpr uint32_t TX_BITS_MOD = (6 << 12);  ///< Set the bits to configure bit length of I2S transmitter channel, the value of which can only be 8, 16, 24 and 32.
        constexpr uint32_t RX_BITS_MOD = (6 << 18);  ///< Set the bits to configure bit length of I2S receiver channel, the value of which can only be 8, 16, 24 and 32.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< 1: I2S TX is in idle state. 0: I2S TX is at work.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Version control register
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x3F4C2000;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t PRO_MAC_INTR_MAP;  ///< Offset: 0x00 - MAC_INTR interrupt configuration register
        volatile uint32_t PRO_MAC_NMI_MAP;  ///< Offset: 0x04 - MAC_NMI interrupt configuration register
        volatile uint32_t PRO_PWR_INTR_MAP;  ///< Offset: 0x08 - PWR_INTR interrupt configuration register
        volatile uint32_t PRO_BB_INT_MAP;  ///< Offset: 0x0C - BB_INT interrupt configuration register
        volatile uint32_t PRO_BT_MAC_INT_MAP;  ///< Offset: 0x10 - BT_MAC_INT interrupt configuration register
        volatile uint32_t PRO_BT_BB_INT_MAP;  ///< Offset: 0x14 - BT_BB_INT interrupt configuration register
        volatile uint32_t PRO_BT_BB_NMI_MAP;  ///< Offset: 0x18 - BT_BB_NMI interrupt configuration register
        volatile uint32_t PRO_RWBT_IRQ_MAP;  ///< Offset: 0x1C - RWBT_IRQ interrupt configuration register
        volatile uint32_t PRO_RWBLE_IRQ_MAP;  ///< Offset: 0x20 - RWBLE_IRQ interrupt configuration register
        volatile uint32_t PRO_RWBT_NMI_MAP;  ///< Offset: 0x24 - RWBT_NMI interrupt configuration register
        volatile uint32_t PRO_RWBLE_NMI_MAP;  ///< Offset: 0x28 - RWBLE_NMI interrupt configuration register
        volatile uint32_t PRO_SLC0_INTR_MAP;  ///< Offset: 0x2C - SLC0_INTR interrupt configuration register
        volatile uint32_t PRO_SLC1_INTR_MAP;  ///< Offset: 0x30 - SLC1_INTR interrupt configuration register
        volatile uint32_t PRO_UHCI0_INTR_MAP;  ///< Offset: 0x34 - UHCI0_INTR interrupt configuration register
        volatile uint32_t PRO_UHCI1_INTR_MAP;  ///< Offset: 0x38 - UHCI1_INTR interrupt configuration register
        volatile uint32_t PRO_TG_T0_LEVEL_INT_MAP;  ///< Offset: 0x3C - TG_T0_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG_T1_LEVEL_INT_MAP;  ///< Offset: 0x40 - TG_T1_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG_WDT_LEVEL_INT_MAP;  ///< Offset: 0x44 - TG_WDT_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG_LACT_LEVEL_INT_MAP;  ///< Offset: 0x48 - TG_LACT_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG1_T0_LEVEL_INT_MAP;  ///< Offset: 0x4C - TG1_T0_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG1_T1_LEVEL_INT_MAP;  ///< Offset: 0x50 - TG1_T1_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG1_WDT_LEVEL_INT_MAP;  ///< Offset: 0x54 - TG1_WDT_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_TG1_LACT_LEVEL_INT_MAP;  ///< Offset: 0x58 - TG1_LACT_LEVEL_INT interrupt configuration register
        volatile uint32_t PRO_GPIO_INTERRUPT_PRO_MAP;  ///< Offset: 0x5C - GPIO_INTERRUPT_PRO interrupt configuration register
        volatile uint32_t PRO_GPIO_INTERRUPT_PRO_NMI_MAP;  ///< Offset: 0x60 - GPIO_INTERRUPT_PRO_NMI interrupt configuration register
        volatile uint32_t PRO_GPIO_INTERRUPT_APP_MAP;  ///< Offset: 0x64 - GPIO_INTERRUPT_APP interrupt configuration register
        volatile uint32_t PRO_GPIO_INTERRUPT_APP_NMI_MAP;  ///< Offset: 0x68 - GPIO_INTERRUPT_APP_NMI interrupt configuration register
        volatile uint32_t PRO_DEDICATED_GPIO_IN_INTR_MAP;  ///< Offset: 0x6C - DEDICATED_GPIO_IN_INTR interrupt configuration register
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x70 - CPU_INTR_FROM_CPU_0 interrupt configuration register
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x74 - CPU_INTR_FROM_CPU_1 interrupt configuration register
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x78 - CPU_INTR_FROM_CPU_2 interrupt configuration register
        volatile uint32_t PRO_CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x7C - CPU_INTR_FROM_CPU_3 interrupt configuration register
        volatile uint32_t PRO_SPI_INTR_1_MAP;  ///< Offset: 0x80 - SPI_INTR_1 interrupt configuration register
        volatile uint32_t PRO_SPI_INTR_2_MAP;  ///< Offset: 0x84 - SPI_INTR_2 interrupt configuration register
        volatile uint32_t PRO_SPI_INTR_3_MAP;  ///< Offset: 0x88 - SPI_INTR_3 interrupt configuration register
        volatile uint32_t PRO_I2S0_INT_MAP;  ///< Offset: 0x8C - I2S0_INT interrupt configuration register
        volatile uint32_t PRO_I2S1_INT_MAP;  ///< Offset: 0x90 - I2S1_INT interrupt configuration register
        volatile uint32_t PRO_UART_INTR_MAP;  ///< Offset: 0x94 - UART_INT interrupt configuration register
        volatile uint32_t PRO_UART1_INTR_MAP;  ///< Offset: 0x98 - UART1_INT interrupt configuration register
        volatile uint32_t PRO_UART2_INTR_MAP;  ///< Offset: 0x9C - UART2_INT interrupt configuration register
        volatile uint32_t PRO_SDIO_HOST_INTERRUPT_MAP;  ///< Offset: 0xA0 - SDIO_HOST_INTERRUPT configuration register
        volatile uint32_t PRO_PWM0_INTR_MAP;  ///< Offset: 0xA4 - PWM0_INTR interrupt configuration register
        volatile uint32_t PRO_PWM1_INTR_MAP;  ///< Offset: 0xA8 - PWM1_INTR interrupt configuration register
        volatile uint32_t PRO_PWM2_INTR_MAP;  ///< Offset: 0xAC - PWM2_INTR interrupt configuration register
        volatile uint32_t PRO_PWM3_INTR_MAP;  ///< Offset: 0xB0 - PWM3_INTR interrupt configuration register
        volatile uint32_t PRO_LEDC_INT_MAP;  ///< Offset: 0xB4 - LEDC_INTR interrupt configuration register
        volatile uint32_t PRO_EFUSE_INT_MAP;  ///< Offset: 0xB8 - EFUSE_INT interrupt configuration register
        volatile uint32_t PRO_CAN_INT_MAP;  ///< Offset: 0xBC - CAN_INT interrupt configuration register
        volatile uint32_t PRO_USB_INTR_MAP;  ///< Offset: 0xC0 - USB_INT interrupt configuration register
        volatile uint32_t PRO_RTC_CORE_INTR_MAP;  ///< Offset: 0xC4 - RTC_CORE_INTR interrupt configuration register
        volatile uint32_t PRO_RMT_INTR_MAP;  ///< Offset: 0xC8 - RMT_INTR interrupt configuration register
        volatile uint32_t PRO_PCNT_INTR_MAP;  ///< Offset: 0xCC - PCNT_INTR interrupt configuration register
        volatile uint32_t PRO_I2C_EXT0_INTR_MAP;  ///< Offset: 0xD0 - I2C_EXT0_INTR interrupt configuration register
        volatile uint32_t PRO_I2C_EXT1_INTR_MAP;  ///< Offset: 0xD4 - I2C_EXT1_INTR interrupt configuration register
        volatile uint32_t PRO_RSA_INTR_MAP;  ///< Offset: 0xD8 - RSA_INTR interrupt configuration register
        volatile uint32_t PRO_SHA_INTR_MAP;  ///< Offset: 0xDC - SHA_INTR interrupt configuration register
        volatile uint32_t PRO_AES_INTR_MAP;  ///< Offset: 0xE0 - AES_INTR interrupt configuration register
        volatile uint32_t PRO_SPI2_DMA_INT_MAP;  ///< Offset: 0xE4 - SPI2_DMA_INT interrupt configuration register
        volatile uint32_t PRO_SPI3_DMA_INT_MAP;  ///< Offset: 0xE8 - SPI3_DMA_INT interrupt configuration register
        volatile uint32_t PRO_WDG_INT_MAP;  ///< Offset: 0xEC - WDG_INT interrupt configuration register
        volatile uint32_t PRO_TIMER_INT1_MAP;  ///< Offset: 0xF0 - TIMER_INT1 interrupt configuration register
        volatile uint32_t PRO_TIMER_INT2_MAP;  ///< Offset: 0xF4 - TIMER_INT2 interrupt configuration register
        volatile uint32_t PRO_TG_T0_EDGE_INT_MAP;  ///< Offset: 0xF8 - TG_T0_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG_T1_EDGE_INT_MAP;  ///< Offset: 0xFC - TG_T1_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG_WDT_EDGE_INT_MAP;  ///< Offset: 0x100 - TG_WDT_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG_LACT_EDGE_INT_MAP;  ///< Offset: 0x104 - TG_LACT_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG1_T0_EDGE_INT_MAP;  ///< Offset: 0x108 - TG1_T0_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG1_T1_EDGE_INT_MAP;  ///< Offset: 0x10C - TG1_T1_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG1_WDT_EDGE_INT_MAP;  ///< Offset: 0x110 - TG1_WDT_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_TG1_LACT_EDGE_INT_MAP;  ///< Offset: 0x114 - TG1_LACT_EDGE_INT interrupt configuration register
        volatile uint32_t PRO_CACHE_IA_INT_MAP;  ///< Offset: 0x118 - CACHE_IA_INT interrupt configuration register
        volatile uint32_t PRO_SYSTIMER_TARGET0_INT_MAP;  ///< Offset: 0x11C - SYSTIMER_TARGET0_INT interrupt configuration register
        volatile uint32_t PRO_SYSTIMER_TARGET1_INT_MAP;  ///< Offset: 0x120 - SYSTIMER_TARGET1_INT interrupt configuration register
        volatile uint32_t PRO_SYSTIMER_TARGET2_INT_MAP;  ///< Offset: 0x124 - SYSTIMER_TARGET2_INT interrupt configuration register
        volatile uint32_t PRO_ASSIST_DEBUG_INTR_MAP;  ///< Offset: 0x128 - ASSIST_DEBUG_INTR interrupt configuration register
        volatile uint32_t PRO_PMS_PRO_IRAM0_ILG_INTR_MAP;  ///< Offset: 0x12C - PMS_PRO_IRAM0_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_PRO_DRAM0_ILG_INTR_MAP;  ///< Offset: 0x130 - PMS_PRO_DRAM0_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_PRO_DPORT_ILG_INTR_MAP;  ///< Offset: 0x134 - PMS_PRO_DPORT_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_PRO_AHB_ILG_INTR_MAP;  ///< Offset: 0x138 - PMS_PRO_AHB_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_PRO_CACHE_ILG_INTR_MAP;  ///< Offset: 0x13C - PMS_PRO_CACHE_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_DMA_APB_I_ILG_INTR_MAP;  ///< Offset: 0x140 - PMS_DMA_APB_I_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_DMA_RX_I_ILG_INTR_MAP;  ///< Offset: 0x144 - PMS_DMA_RX_I_ILG interrupt configuration register
        volatile uint32_t PRO_PMS_DMA_TX_I_ILG_INTR_MAP;  ///< Offset: 0x148 - PMS_DMA_TX_I_ILG interrupt configuration register
        volatile uint32_t PRO_SPI_MEM_REJECT_INTR_MAP;  ///< Offset: 0x14C - SPI_MEM_REJECT_INTR interrupt configuration register
        volatile uint32_t PRO_DMA_COPY_INTR_MAP;  ///< Offset: 0x150 - DMA_COPY_INTR interrupt configuration register
        volatile uint32_t PRO_SPI4_DMA_INT_MAP;  ///< Offset: 0x154 - SPI4_DMA_INT interrupt configuration register
        volatile uint32_t PRO_SPI_INTR_4_MAP;  ///< Offset: 0x158 - SPI_INTR_4 interrupt configuration register
        volatile uint32_t PRO_DCACHE_PRELOAD_INT_MAP;  ///< Offset: 0x15C - DCACHE_PRELOAD_INT interrupt configuration register
        volatile uint32_t PRO_ICACHE_PRELOAD_INT_MAP;  ///< Offset: 0x160 - ICACHE_PRELOAD_INT interrupt configuration register
        volatile uint32_t PRO_APB_ADC_INT_MAP;  ///< Offset: 0x164 - APB_ADC_INT interrupt configuration register
        volatile uint32_t PRO_CRYPTO_DMA_INT_MAP;  ///< Offset: 0x168 - CRYPTO_DMA_INT interrupt configuration register
        volatile uint32_t PRO_CPU_PERI_ERROR_INT_MAP;  ///< Offset: 0x16C - CPU_PERI_ERROR_INT interrupt configuration register
        volatile uint32_t PRO_APB_PERI_ERROR_INT_MAP;  ///< Offset: 0x170 - APB_PERI_ERROR_INT interrupt configuration register
        volatile uint32_t PRO_DCACHE_SYNC_INT_MAP;  ///< Offset: 0x174 - DCACHE_SYNC_INT interrupt configuration register
        volatile uint32_t PRO_ICACHE_SYNC_INT_MAP;  ///< Offset: 0x178 - ICACHE_SYNC_INT interrupt configuration register
        volatile uint32_t PRO_INTR_STATUS_0;  ///< Offset: 0x17C - Interrupt status register 0
        volatile uint32_t PRO_INTR_STATUS_1;  ///< Offset: 0x180 - Interrupt status register 1
        volatile uint32_t PRO_INTR_STATUS_2;  ///< Offset: 0x184 - Interrupt status register 2
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x188 - NMI interrupt signals mask register
        volatile uint32_t REG_DATE;  ///< Offset: 0xFFC - Version control register
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);

    // Bit definitions
    /// PRO_MAC_INTR_MAP Register bits
    namespace pro_mac_intr_map_bits {
        constexpr uint32_t PRO_MAC_INTR_MAP = (5 << 0);  ///< This register is used to map MAC_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_MAC_NMI_MAP Register bits
    namespace pro_mac_nmi_map_bits {
        constexpr uint32_t PRO_MAC_NMI_MAP = (5 << 0);  ///< This register is used to map MAC_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PWR_INTR_MAP Register bits
    namespace pro_pwr_intr_map_bits {
        constexpr uint32_t PRO_PWR_INTR_MAP = (5 << 0);  ///< This register is used to map PWR_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_BB_INT_MAP Register bits
    namespace pro_bb_int_map_bits {
        constexpr uint32_t PRO_BB_INT_MAP = (5 << 0);  ///< This register is used to map BB_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_BT_MAC_INT_MAP Register bits
    namespace pro_bt_mac_int_map_bits {
        constexpr uint32_t PRO_BT_MAC_INT_MAP = (5 << 0);  ///< This register is used to map BT_MAC_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_BT_BB_INT_MAP Register bits
    namespace pro_bt_bb_int_map_bits {
        constexpr uint32_t PRO_BT_BB_INT_MAP = (5 << 0);  ///< This register is used to map BT_BB_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_BT_BB_NMI_MAP Register bits
    namespace pro_bt_bb_nmi_map_bits {
        constexpr uint32_t PRO_BT_BB_NMI_MAP = (5 << 0);  ///< This register is used to map BT_BB_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RWBT_IRQ_MAP Register bits
    namespace pro_rwbt_irq_map_bits {
        constexpr uint32_t PRO_RWBT_IRQ_MAP = (5 << 0);  ///< This register is used to map RWBT_IRQ interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RWBLE_IRQ_MAP Register bits
    namespace pro_rwble_irq_map_bits {
        constexpr uint32_t PRO_RWBLE_IRQ_MAP = (5 << 0);  ///< This register is used to map RWBLE_IRQ interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RWBT_NMI_MAP Register bits
    namespace pro_rwbt_nmi_map_bits {
        constexpr uint32_t PRO_RWBT_NMI_MAP = (5 << 0);  ///< This register is used to map RWBT_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RWBLE_NMI_MAP Register bits
    namespace pro_rwble_nmi_map_bits {
        constexpr uint32_t PRO_RWBLE_NMI_MAP = (5 << 0);  ///< This register is used to map RWBLE_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SLC0_INTR_MAP Register bits
    namespace pro_slc0_intr_map_bits {
        constexpr uint32_t PRO_SLC0_INTR_MAP = (5 << 0);  ///< This register is used to map SLC0_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SLC1_INTR_MAP Register bits
    namespace pro_slc1_intr_map_bits {
        constexpr uint32_t PRO_SLC1_INTR_MAP = (5 << 0);  ///< This register is used to map SLC1_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_UHCI0_INTR_MAP Register bits
    namespace pro_uhci0_intr_map_bits {
        constexpr uint32_t PRO_UHCI0_INTR_MAP = (5 << 0);  ///< This register is used to map UHCI0_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_UHCI1_INTR_MAP Register bits
    namespace pro_uhci1_intr_map_bits {
        constexpr uint32_t PRO_UHCI1_INTR_MAP = (5 << 0);  ///< This register is used to map UHCI1_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_T0_LEVEL_INT_MAP Register bits
    namespace pro_tg_t0_level_int_map_bits {
        constexpr uint32_t PRO_TG_T0_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG_T0_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_T1_LEVEL_INT_MAP Register bits
    namespace pro_tg_t1_level_int_map_bits {
        constexpr uint32_t PRO_TG_T1_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG_T1_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_WDT_LEVEL_INT_MAP Register bits
    namespace pro_tg_wdt_level_int_map_bits {
        constexpr uint32_t PRO_TG_WDT_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG_WDT_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_LACT_LEVEL_INT_MAP Register bits
    namespace pro_tg_lact_level_int_map_bits {
        constexpr uint32_t PRO_TG_LACT_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG_LACT_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_T0_LEVEL_INT_MAP Register bits
    namespace pro_tg1_t0_level_int_map_bits {
        constexpr uint32_t PRO_TG1_T0_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG1_T0_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_T1_LEVEL_INT_MAP Register bits
    namespace pro_tg1_t1_level_int_map_bits {
        constexpr uint32_t PRO_TG1_T1_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG1_T1_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_WDT_LEVEL_INT_MAP Register bits
    namespace pro_tg1_wdt_level_int_map_bits {
        constexpr uint32_t PRO_TG1_WDT_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG1_WDT_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_LACT_LEVEL_INT_MAP Register bits
    namespace pro_tg1_lact_level_int_map_bits {
        constexpr uint32_t PRO_TG1_LACT_LEVEL_INT_MAP = (5 << 0);  ///< This register is used to map TG1_LACT_LEVEL_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_GPIO_INTERRUPT_PRO_MAP Register bits
    namespace pro_gpio_interrupt_pro_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< This register is used to map GPIO_INTERRUPT_PRO interrupt signal to one of the CPU interrupts.
    }

    /// PRO_GPIO_INTERRUPT_PRO_NMI_MAP Register bits
    namespace pro_gpio_interrupt_pro_nmi_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< This register is used to map GPIO_INTERRUPT_PRO_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_GPIO_INTERRUPT_APP_MAP Register bits
    namespace pro_gpio_interrupt_app_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_APP_MAP = (5 << 0);  ///< This register is used to map GPIO_INTERRUPT_APP interrupt signal to one of the CPU interrupts.
    }

    /// PRO_GPIO_INTERRUPT_APP_NMI_MAP Register bits
    namespace pro_gpio_interrupt_app_nmi_map_bits {
        constexpr uint32_t PRO_GPIO_INTERRUPT_APP_NMI_MAP = (5 << 0);  ///< This register is used to map GPIO_INTERRUPT_APP_NMI interrupt signal to one of the CPU interrupts.
    }

    /// PRO_DEDICATED_GPIO_IN_INTR_MAP Register bits
    namespace pro_dedicated_gpio_in_intr_map_bits {
        constexpr uint32_t PRO_DEDICATED_GPIO_IN_INTR_MAP = (5 << 0);  ///< This register is used to map DEDICATED_GPIO_IN_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace pro_cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< This register is used to map CPU_INTR_FROM_CPU_0 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace pro_cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< This register is used to map CPU_INTR_FROM_CPU_1 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace pro_cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< This register is used to map CPU_INTR_FROM_CPU_2 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace pro_cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t PRO_CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< This register is used to map CPU_INTR_FROM_CPU_3 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI_INTR_1_MAP Register bits
    namespace pro_spi_intr_1_map_bits {
        constexpr uint32_t PRO_SPI_INTR_1_MAP = (5 << 0);  ///< This register is used to map SPI_INTR_1 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI_INTR_2_MAP Register bits
    namespace pro_spi_intr_2_map_bits {
        constexpr uint32_t PRO_SPI_INTR_2_MAP = (5 << 0);  ///< This register is used to map SPI_INTR_2 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI_INTR_3_MAP Register bits
    namespace pro_spi_intr_3_map_bits {
        constexpr uint32_t PRO_SPI_INTR_3_MAP = (5 << 0);  ///< This register is used to map SPI_INTR_3 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_I2S0_INT_MAP Register bits
    namespace pro_i2s0_int_map_bits {
        constexpr uint32_t PRO_I2S0_INT_MAP = (5 << 0);  ///< This register is used to map I2S0_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_I2S1_INT_MAP Register bits
    namespace pro_i2s1_int_map_bits {
        constexpr uint32_t PRO_I2S1_INT_MAP = (5 << 0);  ///< This register is used to map I2S1_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_UART_INTR_MAP Register bits
    namespace pro_uart_intr_map_bits {
        constexpr uint32_t PRO_UART_INTR_MAP = (5 << 0);  ///< This register is used to map UART_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_UART1_INTR_MAP Register bits
    namespace pro_uart1_intr_map_bits {
        constexpr uint32_t PRO_UART1_INTR_MAP = (5 << 0);  ///< This register is used to map UART1_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_UART2_INTR_MAP Register bits
    namespace pro_uart2_intr_map_bits {
        constexpr uint32_t PRO_UART2_INTR_MAP = (5 << 0);  ///< This register is used to map UART2_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SDIO_HOST_INTERRUPT_MAP Register bits
    namespace pro_sdio_host_interrupt_map_bits {
        constexpr uint32_t PRO_SDIO_HOST_INTERRUPT_MAP = (5 << 0);  ///< This register is used to map SDIO_HOST_INTERRUPT signal to one of the CPU interrupts.
    }

    /// PRO_PWM0_INTR_MAP Register bits
    namespace pro_pwm0_intr_map_bits {
        constexpr uint32_t PRO_PWM0_INTR_MAP = (5 << 0);  ///< This register is used to map PWM0_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PWM1_INTR_MAP Register bits
    namespace pro_pwm1_intr_map_bits {
        constexpr uint32_t PRO_PWM1_INTR_MAP = (5 << 0);  ///< This register is used to map PWM1_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PWM2_INTR_MAP Register bits
    namespace pro_pwm2_intr_map_bits {
        constexpr uint32_t PRO_PWM2_INTR_MAP = (5 << 0);  ///< This register is used to map PWM2_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PWM3_INTR_MAP Register bits
    namespace pro_pwm3_intr_map_bits {
        constexpr uint32_t PRO_PWM3_INTR_MAP = (5 << 0);  ///< This register is used to map PWM3_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_LEDC_INT_MAP Register bits
    namespace pro_ledc_int_map_bits {
        constexpr uint32_t PRO_LEDC_INT_MAP = (5 << 0);  ///< This register is used to map LEDC_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_EFUSE_INT_MAP Register bits
    namespace pro_efuse_int_map_bits {
        constexpr uint32_t PRO_EFUSE_INT_MAP = (5 << 0);  ///< This register is used to map EFUSE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CAN_INT_MAP Register bits
    namespace pro_can_int_map_bits {
        constexpr uint32_t PRO_CAN_INT_MAP = (5 << 0);  ///< This register is used to map CAN_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_USB_INTR_MAP Register bits
    namespace pro_usb_intr_map_bits {
        constexpr uint32_t PRO_USB_INTR_MAP = (5 << 0);  ///< This register is used to map USB_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RTC_CORE_INTR_MAP Register bits
    namespace pro_rtc_core_intr_map_bits {
        constexpr uint32_t PRO_RTC_CORE_INTR_MAP = (5 << 0);  ///< This register is used to map RTC_CORE_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RMT_INTR_MAP Register bits
    namespace pro_rmt_intr_map_bits {
        constexpr uint32_t PRO_RMT_INTR_MAP = (5 << 0);  ///< This register is used to map RMT_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PCNT_INTR_MAP Register bits
    namespace pro_pcnt_intr_map_bits {
        constexpr uint32_t PRO_PCNT_INTR_MAP = (5 << 0);  ///< This register is used to map PCNT_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_I2C_EXT0_INTR_MAP Register bits
    namespace pro_i2c_ext0_intr_map_bits {
        constexpr uint32_t PRO_I2C_EXT0_INTR_MAP = (5 << 0);  ///< This register is used to map I2C_EXT0_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_I2C_EXT1_INTR_MAP Register bits
    namespace pro_i2c_ext1_intr_map_bits {
        constexpr uint32_t PRO_I2C_EXT1_INTR_MAP = (5 << 0);  ///< This register is used to map I2C_EXT1_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_RSA_INTR_MAP Register bits
    namespace pro_rsa_intr_map_bits {
        constexpr uint32_t PRO_RSA_INTR_MAP = (5 << 0);  ///< This register is used to map RSA_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SHA_INTR_MAP Register bits
    namespace pro_sha_intr_map_bits {
        constexpr uint32_t PRO_SHA_INTR_MAP = (5 << 0);  ///< This register is used to map SHA_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_AES_INTR_MAP Register bits
    namespace pro_aes_intr_map_bits {
        constexpr uint32_t PRO_AES_INTR_MAP = (5 << 0);  ///< This register is used to map AES_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI2_DMA_INT_MAP Register bits
    namespace pro_spi2_dma_int_map_bits {
        constexpr uint32_t PRO_SPI2_DMA_INT_MAP = (5 << 0);  ///< This register is used to map AES_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI3_DMA_INT_MAP Register bits
    namespace pro_spi3_dma_int_map_bits {
        constexpr uint32_t PRO_SPI3_DMA_INT_MAP = (5 << 0);  ///< This register is used to map SPI3_DMA_INT dma interrupt signal to one of the CPU interrupts.
    }

    /// PRO_WDG_INT_MAP Register bits
    namespace pro_wdg_int_map_bits {
        constexpr uint32_t PRO_WDG_INT_MAP = (5 << 0);  ///< This register is used to map WDG_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TIMER_INT1_MAP Register bits
    namespace pro_timer_int1_map_bits {
        constexpr uint32_t PRO_TIMER_INT1_MAP = (5 << 0);  ///< This register is used to map TIMER_INT1 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TIMER_INT2_MAP Register bits
    namespace pro_timer_int2_map_bits {
        constexpr uint32_t PRO_TIMER_INT2_MAP = (5 << 0);  ///< This register is used to map TIMER_INT2 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_T0_EDGE_INT_MAP Register bits
    namespace pro_tg_t0_edge_int_map_bits {
        constexpr uint32_t PRO_TG_T0_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG_T0_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_T1_EDGE_INT_MAP Register bits
    namespace pro_tg_t1_edge_int_map_bits {
        constexpr uint32_t PRO_TG_T1_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG_T1_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_WDT_EDGE_INT_MAP Register bits
    namespace pro_tg_wdt_edge_int_map_bits {
        constexpr uint32_t PRO_TG_WDT_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG_WDT_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG_LACT_EDGE_INT_MAP Register bits
    namespace pro_tg_lact_edge_int_map_bits {
        constexpr uint32_t PRO_TG_LACT_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG_LACT_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_T0_EDGE_INT_MAP Register bits
    namespace pro_tg1_t0_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_T0_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG1_T0_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_T1_EDGE_INT_MAP Register bits
    namespace pro_tg1_t1_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_T1_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG1_T1_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_WDT_EDGE_INT_MAP Register bits
    namespace pro_tg1_wdt_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_WDT_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG1_WDT_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_TG1_LACT_EDGE_INT_MAP Register bits
    namespace pro_tg1_lact_edge_int_map_bits {
        constexpr uint32_t PRO_TG1_LACT_EDGE_INT_MAP = (5 << 0);  ///< This register is used to map TG1_LACT_EDGE_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CACHE_IA_INT_MAP Register bits
    namespace pro_cache_ia_int_map_bits {
        constexpr uint32_t PRO_CACHE_IA_INT_MAP = (5 << 0);  ///< This register is used to map CACHE_IA_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SYSTIMER_TARGET0_INT_MAP Register bits
    namespace pro_systimer_target0_int_map_bits {
        constexpr uint32_t PRO_SYSTIMER_TARGET0_INT_MAP = (5 << 0);  ///< This register is used to map SYSTIMER_TARGET0_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SYSTIMER_TARGET1_INT_MAP Register bits
    namespace pro_systimer_target1_int_map_bits {
        constexpr uint32_t PRO_SYSTIMER_TARGET1_INT_MAP = (5 << 0);  ///< This register is used to map SYSTIMER_TARGET1_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SYSTIMER_TARGET2_INT_MAP Register bits
    namespace pro_systimer_target2_int_map_bits {
        constexpr uint32_t PRO_SYSTIMER_TARGET2_INT_MAP = (5 << 0);  ///< This register is used to map SYSTIMER_TARGET2_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_ASSIST_DEBUG_INTR_MAP Register bits
    namespace pro_assist_debug_intr_map_bits {
        constexpr uint32_t PRO_ASSIST_DEBUG_INTR_MAP = (5 << 0);  ///< This register is used to map ASSIST_DEBUG_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_PRO_IRAM0_ILG_INTR_MAP Register bits
    namespace pro_pms_pro_iram0_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_PRO_IRAM0_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_PRO_IRAM0_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_PRO_DRAM0_ILG_INTR_MAP Register bits
    namespace pro_pms_pro_dram0_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_PRO_DRAM0_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_PRO_DRAM0_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_PRO_DPORT_ILG_INTR_MAP Register bits
    namespace pro_pms_pro_dport_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_PRO_DPORT_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_PRO_DPORT_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_PRO_AHB_ILG_INTR_MAP Register bits
    namespace pro_pms_pro_ahb_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_PRO_AHB_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_PRO_AHB_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_PRO_CACHE_ILG_INTR_MAP Register bits
    namespace pro_pms_pro_cache_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_PRO_CACHE_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_PRO_CACHE_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_DMA_APB_I_ILG_INTR_MAP Register bits
    namespace pro_pms_dma_apb_i_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_DMA_APB_I_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_DMA_APB_I_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_DMA_RX_I_ILG_INTR_MAP Register bits
    namespace pro_pms_dma_rx_i_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_DMA_RX_I_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_DMA_RX_I_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_PMS_DMA_TX_I_ILG_INTR_MAP Register bits
    namespace pro_pms_dma_tx_i_ilg_intr_map_bits {
        constexpr uint32_t PRO_PMS_DMA_TX_I_ILG_INTR_MAP = (5 << 0);  ///< This register is used to map PMS_DMA_TX_I_ILG interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI_MEM_REJECT_INTR_MAP Register bits
    namespace pro_spi_mem_reject_intr_map_bits {
        constexpr uint32_t PRO_SPI_MEM_REJECT_INTR_MAP = (5 << 0);  ///< This register is used to map SPI_MEM_REJECT_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_DMA_COPY_INTR_MAP Register bits
    namespace pro_dma_copy_intr_map_bits {
        constexpr uint32_t PRO_DMA_COPY_INTR_MAP = (5 << 0);  ///< This register is used to map DMA_COPY_INTR interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI4_DMA_INT_MAP Register bits
    namespace pro_spi4_dma_int_map_bits {
        constexpr uint32_t PRO_SPI4_DMA_INT_MAP = (5 << 0);  ///< This register is used to map SPI4_DMA_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_SPI_INTR_4_MAP Register bits
    namespace pro_spi_intr_4_map_bits {
        constexpr uint32_t PRO_SPI_INTR_4_MAP = (5 << 0);  ///< This register is used to map SPI_INTR_4 interrupt signal to one of the CPU interrupts.
    }

    /// PRO_DCACHE_PRELOAD_INT_MAP Register bits
    namespace pro_dcache_preload_int_map_bits {
        constexpr uint32_t PRO_DCACHE_PRELOAD_INT_MAP = (5 << 0);  ///< This register is used to map DCACHE_PRELOAD_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_ICACHE_PRELOAD_INT_MAP Register bits
    namespace pro_icache_preload_int_map_bits {
        constexpr uint32_t PRO_ICACHE_PRELOAD_INT_MAP = (5 << 0);  ///< This register is used to map ICACHE_PRELOAD_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_APB_ADC_INT_MAP Register bits
    namespace pro_apb_adc_int_map_bits {
        constexpr uint32_t PRO_APB_ADC_INT_MAP = (5 << 0);  ///< This register is used to map APB_ADC_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CRYPTO_DMA_INT_MAP Register bits
    namespace pro_crypto_dma_int_map_bits {
        constexpr uint32_t PRO_CRYPTO_DMA_INT_MAP = (5 << 0);  ///< This register is used to map CRYPTO_DMA_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_CPU_PERI_ERROR_INT_MAP Register bits
    namespace pro_cpu_peri_error_int_map_bits {
        constexpr uint32_t PRO_CPU_PERI_ERROR_INT_MAP = (5 << 0);  ///< This register is used to map CPU_PERI_ERROR_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_APB_PERI_ERROR_INT_MAP Register bits
    namespace pro_apb_peri_error_int_map_bits {
        constexpr uint32_t PRO_APB_PERI_ERROR_INT_MAP = (5 << 0);  ///< This register is used to map APB_PERI_ERROR_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_DCACHE_SYNC_INT_MAP Register bits
    namespace pro_dcache_sync_int_map_bits {
        constexpr uint32_t PRO_DCACHE_SYNC_INT_MAP = (5 << 0);  ///< This register is used to map DCACHE_SYNC_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_ICACHE_SYNC_INT_MAP Register bits
    namespace pro_icache_sync_int_map_bits {
        constexpr uint32_t PRO_ICACHE_SYNC_INT_MAP = (5 << 0);  ///< This register is used to map ICACHE_SYNC_INT interrupt signal to one of the CPU interrupts.
    }

    /// PRO_INTR_STATUS_0 Register bits
    namespace pro_intr_status_0_bits {
        constexpr uint32_t PRO_INTR_STATUS_0 = (32 << 0);  ///< This register stores the status of the first 32 input interrupt sources.
    }

    /// PRO_INTR_STATUS_1 Register bits
    namespace pro_intr_status_1_bits {
        constexpr uint32_t PRO_INTR_STATUS_1 = (32 << 0);  ///< This register stores the status of the second 32 input interrupt sources.
    }

    /// PRO_INTR_STATUS_2 Register bits
    namespace pro_intr_status_2_bits {
        constexpr uint32_t PRO_INTR_STATUS_2 = (32 << 0);  ///< This register stores the status of the last 31 input interrupt sources.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< This bit is used to enable or disable the clock of interrupt matrix. 1: enable the clock. 0: disable the clock.
        constexpr uint32_t PRO_NMI_MASK_HW = (1U << 1);  ///< This bit is used to disable all NMI interrupt signals to CPU.
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t INTERRUPT_REG_DATE = (28 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x3F409000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - Clock output configuration register
        volatile uint32_t GPIO0;  ///< Offset: 0x04 - Configuration register for pin GPIO0
        volatile uint32_t GPIO1;  ///< Offset: 0x08 - Configuration register for pin GPIO1
        volatile uint32_t GPIO2;  ///< Offset: 0x0C - Configuration register for pin GPIO2
        volatile uint32_t GPIO3;  ///< Offset: 0x10 - Configuration register for pin GPIO3
        volatile uint32_t GPIO4;  ///< Offset: 0x14 - Configuration register for pin GPIO4
        volatile uint32_t GPIO5;  ///< Offset: 0x18 - Configuration register for pin GPIO5
        volatile uint32_t GPIO6;  ///< Offset: 0x1C - Configuration register for pin GPIO6
        volatile uint32_t GPIO7;  ///< Offset: 0x20 - Configuration register for pin GPIO7
        volatile uint32_t GPIO8;  ///< Offset: 0x24 - Configuration register for pin GPIO8
        volatile uint32_t GPIO9;  ///< Offset: 0x28 - Configuration register for pin GPIO9
        volatile uint32_t GPIO10;  ///< Offset: 0x2C - Configuration register for pin GPIO10
        volatile uint32_t GPIO11;  ///< Offset: 0x30 - Configuration register for pin GPIO11
        volatile uint32_t GPIO12;  ///< Offset: 0x34 - Configuration register for pin GPIO12
        volatile uint32_t GPIO13;  ///< Offset: 0x38 - Configuration register for pin GPIO13
        volatile uint32_t GPIO14;  ///< Offset: 0x3C - Configuration register for pin GPIO14
        volatile uint32_t GPIO19;  ///< Offset: 0x50 - Configuration register for pin GPIO19
        volatile uint32_t GPIO20;  ///< Offset: 0x54 - Configuration register for pin GPIO20
        volatile uint32_t GPIO21;  ///< Offset: 0x58 - Configuration register for pin GPIO21
        volatile uint32_t GPIO33;  ///< Offset: 0x88 - Configuration register for pin GPIO33
        volatile uint32_t GPIO34;  ///< Offset: 0x8C - Configuration register for pin GPIO34
        volatile uint32_t GPIO35;  ///< Offset: 0x90 - Configuration register for pin GPIO35
        volatile uint32_t GPIO36;  ///< Offset: 0x94 - Configuration register for pin GPIO36
        volatile uint32_t GPIO37;  ///< Offset: 0x98 - Configuration register for pin GPIO37
        volatile uint32_t GPIO38;  ///< Offset: 0x9C - Configuration register for pin GPIO38
        volatile uint32_t GPIO45;  ///< Offset: 0xB8 - Configuration register for pin GPIO45
        volatile uint32_t GPIO46;  ///< Offset: 0xBC - Configuration register for pin GPIO46
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
        volatile uint32_t GPIO15;  ///< Offset: 0x40 - Configuration register for pin GPIO15
        volatile uint32_t GPIO16;  ///< Offset: 0x44 - Configuration register for pin GPIO16
        volatile uint32_t GPIO17;  ///< Offset: 0x48 - Configuration register for pin GPIO17
        volatile uint32_t GPIO18;  ///< Offset: 0x4C - Configuration register for pin GPIO18
        volatile uint32_t GPIO26;  ///< Offset: 0x6C - Configuration register for pin GPIO26
        volatile uint32_t GPIO27;  ///< Offset: 0x70 - Configuration register for pin GPIO27
        volatile uint32_t GPIO28;  ///< Offset: 0x74 - Configuration register for pin GPIO28
        volatile uint32_t GPIO29;  ///< Offset: 0x78 - Configuration register for pin GPIO29
        volatile uint32_t GPIO30;  ///< Offset: 0x7C - Configuration register for pin GPIO30
        volatile uint32_t GPIO31;  ///< Offset: 0x80 - Configuration register for pin GPIO31
        volatile uint32_t GPIO32;  ///< Offset: 0x84 - Configuration register for pin GPIO32
        volatile uint32_t GPIO39;  ///< Offset: 0xA0 - Configuration register for pin GPIO39
        volatile uint32_t GPIO40;  ///< Offset: 0xA4 - Configuration register for pin GPIO40
        volatile uint32_t GPIO41;  ///< Offset: 0xA8 - Configuration register for pin GPIO41
        volatile uint32_t GPIO42;  ///< Offset: 0xAC - Configuration register for pin GPIO42
        volatile uint32_t GPIO43;  ///< Offset: 0xB0 - Configuration register for pin GPIO43
        volatile uint32_t GPIO44;  ///< Offset: 0xB4 - Configuration register for pin GPIO44
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t PIN_CLK_OUT1 = (4 << 0);  ///< Configure I2S0 clock output. 0: output I2S0 clock to CLK_OUT1. 15: disabled.
        constexpr uint32_t PIN_CLK_OUT2 = (4 << 4);  ///< Configure I2S0 clock output. 0: output I2S0 clock to CLK_OUT2. 15: disabled.
        constexpr uint32_t PIN_CLK_OUT3 = (4 << 8);  ///< Configure I2S0 clock output. 0: output I2S0 clock to CLK_OUT3. 15: disabled.
        constexpr uint32_t SWITCH_PRT_NUM = (3 << 12);  ///< IO pin power switch delay, delay unit is one APB clock.
        constexpr uint32_t PAD_POWER_CTRL = (1U << 15);  ///< Select power voltage for GPIO33 ~ GPIO37. 1: select VDD_SPI 1.8 V. 0: select VDD3P3_CPU 3.3 V.
    }

    /// GPIO0 Register bits
    namespace gpio0_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO1 Register bits
    namespace gpio1_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO2 Register bits
    namespace gpio2_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO3 Register bits
    namespace gpio3_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO4 Register bits
    namespace gpio4_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO5 Register bits
    namespace gpio5_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO6 Register bits
    namespace gpio6_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO7 Register bits
    namespace gpio7_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO8 Register bits
    namespace gpio8_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO9 Register bits
    namespace gpio9_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO10 Register bits
    namespace gpio10_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO11 Register bits
    namespace gpio11_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO12 Register bits
    namespace gpio12_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO13 Register bits
    namespace gpio13_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO14 Register bits
    namespace gpio14_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO19 Register bits
    namespace gpio19_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO20 Register bits
    namespace gpio20_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO21 Register bits
    namespace gpio21_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO33 Register bits
    namespace gpio33_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO34 Register bits
    namespace gpio34_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO35 Register bits
    namespace gpio35_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO36 Register bits
    namespace gpio36_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO37 Register bits
    namespace gpio37_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO38 Register bits
    namespace gpio38_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO45 Register bits
    namespace gpio45_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO46 Register bits
    namespace gpio46_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t VERSION = (28 << 0);  ///< Version control register
    }

    /// GPIO15 Register bits
    namespace gpio15_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO16 Register bits
    namespace gpio16_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO17 Register bits
    namespace gpio17_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO18 Register bits
    namespace gpio18_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO26 Register bits
    namespace gpio26_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO27 Register bits
    namespace gpio27_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO28 Register bits
    namespace gpio28_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO29 Register bits
    namespace gpio29_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO30 Register bits
    namespace gpio30_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO31 Register bits
    namespace gpio31_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO32 Register bits
    namespace gpio32_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO39 Register bits
    namespace gpio39_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO40 Register bits
    namespace gpio40_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO41 Register bits
    namespace gpio41_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO42 Register bits
    namespace gpio42_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO43 Register bits
    namespace gpio43_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

    /// GPIO44 Register bits
    namespace gpio44_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pin in sleep mode. 1: Output enabled. 0: Output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pin. Set to 1 to put the pin in sleep mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pin during sleep mode. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pin during sleep mode. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pin during sleep mode. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pin. 1: Internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pin. 1: Internal pull-up enabled. 0: Internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pin. 1: Input enabled. 0: Input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pin. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2, etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled. 2: Filter disabled.
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x3F419000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for channel %s
        volatile uint32_t CH%s_HPOINT;  ///< Offset: 0x04 - High point register for channel %s
        volatile uint32_t CH%s_DUTY;  ///< Offset: 0x08 - Initial duty cycle for channel %s
        volatile uint32_t CH%s_CONF1;  ///< Offset: 0x0C - Configuration register 1 for channel %s
        volatile uint32_t CH%s_DUTY_R;  ///< Offset: 0x10 - Current duty cycle for channel %s
        volatile uint32_t TIMER%s_CONF;  ///< Offset: 0xA0 - Timer %s configuration
        volatile uint32_t TIMER%s_VALUE;  ///< Offset: 0xA4 - Timer %s current counter value
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear bits
        volatile uint32_t CONF;  ///< Offset: 0xD0 - Global ledc configuration register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);

    // Bit definitions
    /// CH%s_CONF0 Register bits
    namespace ch%s_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< This field is used to select one of timers for channel %s. 0: select timer 0. 1: select timer 1. 2: select timer 2. 3: select timer 3.
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< Set this bit to enable signal output on channel %s.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when channel %s is inactive.
        constexpr uint32_t PARA_UP = (1U << 4);  ///< This bit is used to update register LEDC_CH%s_HPOINT and LEDC_CH%s_DUTY for channel %s.
        constexpr uint32_t OVF_NUM = (10 << 5);  ///< This register is used to configure the maximum times of overflow minus 1. The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
        constexpr uint32_t OVF_CNT_EN = (1U << 15);  ///< This bit is used to enable the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET = (1U << 16);  ///< Set this bit to reset the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET_ST = (1U << 17);  ///< This is the status bit of LEDC_OVF_CNT_RESET_CH%s.
    }

    /// CH%s_HPOINT Register bits
    namespace ch%s_hpoint_bits {
        constexpr uint32_t HPOINT = (14 << 0);  ///< The output value changes to high when the selected timers has reached the value specified by this register.
    }

    /// CH%s_DUTY Register bits
    namespace ch%s_duty_bits {
        constexpr uint32_t DUTY = (19 << 0);  ///< This register is used to change the output duty by controlling the Lpoint. The output value turns to low when the selected timers has reached the Lpoint.
    }

    /// CH%s_CONF1 Register bits
    namespace ch%s_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< This register is used to configure the changing step scale of duty on channel %s.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< The duty will change every LEDC_DUTY_CYCLE_CH%s on channel %s.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< This register is used to control the number of times the duty cycle will be changed.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase. 0: Decrease.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
    }

    /// CH%s_DUTY_R Register bits
    namespace ch%s_duty_r_bits {
        constexpr uint32_t DUTY_R = (19 << 0);  ///< This register stores the current duty of output signal on channel %s.
    }

    /// TIMER%s_CONF Register bits
    namespace timer%s_conf_bits {
        constexpr uint32_t DUTY_RES = (4 << 0);  ///< This register is used to control the range of the counter in timer %s.
        constexpr uint32_t CLK_DIV = (18 << 4);  ///< This register is used to configure the divisor for the divider in timer %s. The least significant eight bits represent the fractional part.
        constexpr uint32_t PAUSE = (1U << 22);  ///< This bit is used to suspend the counter in timer %s.
        constexpr uint32_t RST = (1U << 23);  ///< This bit is used to reset timer %s. The counter will show 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 24);  ///< This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate. 0: LEDC_PWM_CLK. 1: REF_TICK.
        constexpr uint32_t PARA_UP = (1U << 25);  ///< Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
    }

    /// TIMER%s_VALUE Register bits
    namespace timer%s_value_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< This register stores the current counter value of timer %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TIMER0_OVF_INT_RAW = (1U << 0);  ///< Triggered when the timer0 has reached its maximum counter value.
        constexpr uint32_t TIMER1_OVF_INT_RAW = (1U << 1);  ///< Triggered when the timer1 has reached its maximum counter value.
        constexpr uint32_t TIMER2_OVF_INT_RAW = (1U << 2);  ///< Triggered when the timer2 has reached its maximum counter value.
        constexpr uint32_t TIMER3_OVF_INT_RAW = (1U << 3);  ///< Triggered when the timer3 has reached its maximum counter value.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_RAW = (1U << 4);  ///< Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_RAW = (1U << 5);  ///< Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_RAW = (1U << 6);  ///< Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_RAW = (1U << 7);  ///< Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_RAW = (1U << 8);  ///< Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_RAW = (1U << 9);  ///< Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_RAW = (1U << 10);  ///< Interrupt raw bit for channel 6. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_RAW = (1U << 11);  ///< Interrupt raw bit for channel 7. Triggered when the gradual change of duty has finished.
        constexpr uint32_t OVF_CNT_CH0_INT_RAW = (1U << 12);  ///< Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
        constexpr uint32_t OVF_CNT_CH1_INT_RAW = (1U << 13);  ///< Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
        constexpr uint32_t OVF_CNT_CH2_INT_RAW = (1U << 14);  ///< Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
        constexpr uint32_t OVF_CNT_CH3_INT_RAW = (1U << 15);  ///< Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
        constexpr uint32_t OVF_CNT_CH4_INT_RAW = (1U << 16);  ///< Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
        constexpr uint32_t OVF_CNT_CH5_INT_RAW = (1U << 17);  ///< Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
        constexpr uint32_t OVF_CNT_CH6_INT_RAW = (1U << 18);  ///< Interrupt raw bit for channel 6. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH6.
        constexpr uint32_t OVF_CNT_CH7_INT_RAW = (1U << 19);  ///< Interrupt raw bit for channel 7. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH7.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TIMER0_OVF_INT_ST = (1U << 0);  ///< This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER1_OVF_INT_ST = (1U << 1);  ///< This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER2_OVF_INT_ST = (1U << 2);  ///< This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER3_OVF_INT_ST = (1U << 3);  ///< This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ST = (1U << 4);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ST = (1U << 5);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ST = (1U << 6);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ST = (1U << 7);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ST = (1U << 8);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ST = (1U << 9);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ST = (1U << 10);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH6_INT interrupt when LEDC_DUTY_CHNG_END_CH6_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ST = (1U << 11);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH7_INT interrupt when LEDC_DUTY_CHNG_END_CH7_INT_ENAIS set to 1.
        constexpr uint32_t OVF_CNT_CH0_INT_ST = (1U << 12);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH1_INT_ST = (1U << 13);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH2_INT_ST = (1U << 14);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH3_INT_ST = (1U << 15);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH4_INT_ST = (1U << 16);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH5_INT_ST = (1U << 17);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH6_INT_ST = (1U << 18);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH6_INT interrupt when LEDC_OVF_CNT_CH6_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH7_INT_ST = (1U << 19);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH7_INT interrupt when LEDC_OVF_CNT_CH7_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TIMER0_OVF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH6_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH7_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_ENA = (1U << 16);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_ENA = (1U << 17);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH6_INT_ENA = (1U << 18);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH6_INT interrupt.
        constexpr uint32_t OVF_CNT_CH7_INT_ENA = (1U << 19);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH7_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TIMER0_OVF_INT_CLR = (1U << 0);  ///< Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_CLR = (1U << 1);  ///< Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_CLR = (1U << 3);  ///< Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_CLR = (1U << 4);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_CLR = (1U << 5);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_CLR = (1U << 6);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_CLR = (1U << 7);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_CLR = (1U << 8);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_CLR = (1U << 9);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_CLR = (1U << 10);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH6_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_CLR = (1U << 11);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH7_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_CLR = (1U << 12);  ///< Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_CLR = (1U << 13);  ///< Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_CLR = (1U << 14);  ///< Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_CLR = (1U << 15);  ///< Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_CLR = (1U << 16);  ///< Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_CLR = (1U << 17);  ///< Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH6_INT_CLR = (1U << 18);  ///< Set this bit to clear the LEDC_OVF_CNT_CH6_INT interrupt.
        constexpr uint32_t OVF_CNT_CH7_INT_CLR = (1U << 19);  ///< Set this bit to clear the LEDC_OVF_CNT_CH7_INT interrupt.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< This bit is used to select clock source for the 4 timers . 1: APB_CLK. 2: RTC8M_CLK. 3: XTAL_CLK.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< This bit is used to control clock. 1: Force clock on for register. 0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// PCNT Peripheral
// ============================================================================

namespace pcnt {
    /// Base addresses
    constexpr uint32_t PCNT_BASE = 0x3F417000;

    /// PCNT Register structure
    struct Registers {
        volatile uint32_t U%s_CONF0;  ///< Offset: 0x00 - Configuration register 0 for unit %s
        volatile uint32_t U%s_CONF1;  ///< Offset: 0x04 - Configuration register 1 for unit %s
        volatile uint32_t U%s_CONF2;  ///< Offset: 0x08 - Configuration register 2 for unit %s
        volatile uint32_t U%s_CNT;  ///< Offset: 0x30 - Counter value for unit %s
        volatile uint32_t INT_RAW;  ///< Offset: 0x40 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - Interrupt status register
        volatile uint32_t INT_ENA;  ///< Offset: 0x48 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - Interrupt clear register
        volatile uint32_t U%s_STATUS;  ///< Offset: 0x50 - PNCT UNIT%s status register
        volatile uint32_t CTRL;  ///< Offset: 0x60 - Control register for all counters
        volatile uint32_t DATE;  ///< Offset: 0xFC - PCNT version control register
    };

    /// Peripheral instances
    inline Registers* PCNT = reinterpret_cast<Registers*>(PCNT_BASE);

    // Bit definitions
    /// U%s_CONF0 Register bits
    namespace u%s_conf0_bits {
        constexpr uint32_t FILTER_THRES = (10 << 0);  ///< This sets the maximum threshold, in APB_CLK cycles, for the filter. Any pulses with width less than this will be ignored when the filter is enabled.
        constexpr uint32_t FILTER_EN = (1U << 10);  ///< This is the enable bit for unit %s's input filter.
        constexpr uint32_t THR_ZERO_EN = (1U << 11);  ///< This is the enable bit for unit %s's zero comparator.
        constexpr uint32_t THR_H_LIM_EN = (1U << 12);  ///< This is the enable bit for unit %s's thr_h_lim comparator.
        constexpr uint32_t THR_L_LIM_EN = (1U << 13);  ///< This is the enable bit for unit %s's thr_l_lim comparator.
        constexpr uint32_t THR_THRES0_EN = (1U << 14);  ///< This is the enable bit for unit %s's thres0 comparator.
        constexpr uint32_t THR_THRES1_EN = (1U << 15);  ///< This is the enable bit for unit %s's thres1 comparator.
        constexpr uint32_t CH0_NEG_MODE = (2 << 16);  ///< This register sets the behavior when the signal input of channel 0 detects a negative edge. 1: Increase the counter. 2: Decrease the counter. 0, 3: No effect on counter.
        constexpr uint32_t CH0_POS_MODE = (2 << 18);  ///< This register sets the behavior when the signal input of channel 0 detects a positive edge. 1: Increase the counter. 2: Decrease the counter. 0, 3: No effect on counter.
        constexpr uint32_t CH0_HCTRL_MODE = (2 << 20);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification. 1: Invert behavior (increase -> decrease, decrease -> increase). 2, 3: Inhibit counter modification.
        constexpr uint32_t CH0_LCTRL_MODE = (2 << 22);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification. 1: Invert behavior (increase -> decrease, decrease -> increase). 2, 3: Inhibit counter modification.
        constexpr uint32_t CH1_NEG_MODE = (2 << 24);  ///< This register sets the behavior when the signal input of channel 1 detects a negative edge. 1: Increment the counter. 2: Decrement the counter. 0, 3: No effect on counter.
        constexpr uint32_t CH1_POS_MODE = (2 << 26);  ///< This register sets the behavior when the signal input of channel 1 detects a positive edge. 1: Increment the counter. 2: Decrement the counter. 0, 3: No effect on counter.
        constexpr uint32_t CH1_HCTRL_MODE = (2 << 28);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification. 1: Invert behavior (increase -> decrease, decrease -> increase). 2, 3: Inhibit counter modification.
        constexpr uint32_t CH1_LCTRL_MODE = (2 << 30);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification. 1: Invert behavior (increase -> decrease, decrease -> increase). 2, 3: Inhibit counter modification.
    }

    /// U%s_CONF1 Register bits
    namespace u%s_conf1_bits {
        constexpr uint32_t CNT_THRES0 = (16 << 0);  ///< This register is used to configure the thres0 value for unit %s.
        constexpr uint32_t CNT_THRES1 = (16 << 16);  ///< This register is used to configure the thres1 value for unit %s.
    }

    /// U%s_CONF2 Register bits
    namespace u%s_conf2_bits {
        constexpr uint32_t CNT_H_LIM = (16 << 0);  ///< This register is used to configure the thr_h_lim value for unit %s.
        constexpr uint32_t CNT_L_LIM = (16 << 16);  ///< This register is used to configure the thr_l_lim value for unit %s.
    }

    /// U%s_CNT Register bits
    namespace u%s_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< This register stores the current pulse count value for unit %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// U%s_STATUS Register bits
    namespace u%s_status_bits {
        constexpr uint32_t ZERO_MODE = (2 << 0);  ///< The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
        constexpr uint32_t THRES1 = (1U << 2);  ///< The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others.
        constexpr uint32_t THRES0 = (1U << 3);  ///< The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others.
        constexpr uint32_t L_LIM = (1U << 4);  ///< The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others.
        constexpr uint32_t H_LIM = (1U << 5);  ///< The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others.
        constexpr uint32_t ZERO = (1U << 6);  ///< The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CNT_RST_U0 = (1U << 0);  ///< Set this bit to clear unit 0's counter.
        constexpr uint32_t CNT_PAUSE_U0 = (1U << 1);  ///< Set this bit to freeze unit 1's counter.
        constexpr uint32_t CNT_RST_U1 = (1U << 2);  ///< Set this bit to clear unit 2's counter.
        constexpr uint32_t CNT_PAUSE_U1 = (1U << 3);  ///< Set this bit to freeze unit 3's counter.
        constexpr uint32_t CNT_RST_U2 = (1U << 4);  ///< Set this bit to clear unit 4's counter.
        constexpr uint32_t CNT_PAUSE_U2 = (1U << 5);  ///< Set this bit to freeze unit 5's counter.
        constexpr uint32_t CNT_RST_U3 = (1U << 6);  ///< Set this bit to clear unit 6's counter.
        constexpr uint32_t CNT_PAUSE_U3 = (1U << 7);  ///< Set this bit to freeze unit 7's counter.
        constexpr uint32_t CLK_EN = (1U << 16);  ///< The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the PCNT version control register.
    }

}

// ============================================================================
// PMS Peripheral
// ============================================================================

namespace pms {
    /// Base addresses
    constexpr uint32_t PMS_BASE = 0x3F4C1000;

    /// PMS Register structure
    struct Registers {
        volatile uint32_t SDIO_0;  ///< Offset: 0x00 - SDIO permission control register 0.
        volatile uint32_t SDIO_1;  ///< Offset: 0x04 - SDIO permission control register 1.
        volatile uint32_t MAC_DUMP_0;  ///< Offset: 0x08 - MAC dump permission control register 0.
        volatile uint32_t MAC_DUMP_1;  ///< Offset: 0x0C - MAC dump permission control register 1.
        volatile uint32_t PRO_IRAM0_0;  ///< Offset: 0x10 - IBUS permission control register 0.
        volatile uint32_t PRO_IRAM0_1;  ///< Offset: 0x14 - IBUS permission control register 1.
        volatile uint32_t PRO_IRAM0_2;  ///< Offset: 0x18 - IBUS permission control register 2.
        volatile uint32_t PRO_IRAM0_3;  ///< Offset: 0x1C - IBUS permission control register 3.
        volatile uint32_t PRO_IRAM0_4;  ///< Offset: 0x20 - IBUS permission control register 4.
        volatile uint32_t PRO_IRAM0_5;  ///< Offset: 0x24 - IBUS status register.
        volatile uint32_t PRO_DRAM0_0;  ///< Offset: 0x28 - DBUS permission control register 0.
        volatile uint32_t PRO_DRAM0_1;  ///< Offset: 0x2C - DBUS permission control register 1.
        volatile uint32_t PRO_DRAM0_2;  ///< Offset: 0x30 - DBUS permission control register 2.
        volatile uint32_t PRO_DRAM0_3;  ///< Offset: 0x34 - DBUS permission control register 3.
        volatile uint32_t PRO_DRAM0_4;  ///< Offset: 0x38 - DBUS status register.
        volatile uint32_t PRO_DPORT_0;  ///< Offset: 0x3C - PeriBus1 permission control register 0.
        volatile uint32_t PRO_DPORT_1;  ///< Offset: 0x40 - PeriBus1 permission control register 1.
        volatile uint32_t PRO_DPORT_2;  ///< Offset: 0x44 - PeriBus1 permission control register 2.
        volatile uint32_t PRO_DPORT_3;  ///< Offset: 0x48 - PeriBus1 permission control register 3.
        volatile uint32_t PRO_DPORT_4;  ///< Offset: 0x4C - PeriBus1 permission control register 4.
        volatile uint32_t PRO_DPORT_5;  ///< Offset: 0x50 - PeriBus1 permission control register 5.
        volatile uint32_t PRO_DPORT_6;  ///< Offset: 0x54 - PeriBus1 permission control register 6.
        volatile uint32_t PRO_DPORT_7;  ///< Offset: 0x58 - PeriBus1 status register.
        volatile uint32_t PRO_AHB_0;  ///< Offset: 0x5C - PeriBus2 permission control register 0.
        volatile uint32_t PRO_AHB_1;  ///< Offset: 0x60 - PeriBus2 permission control register 1.
        volatile uint32_t PRO_AHB_2;  ///< Offset: 0x64 - PeriBus2 permission control register 2.
        volatile uint32_t PRO_AHB_3;  ///< Offset: 0x68 - PeriBus2 permission control register 3.
        volatile uint32_t PRO_AHB_4;  ///< Offset: 0x6C - PeriBus2 status register.
        volatile uint32_t PRO_TRACE_0;  ///< Offset: 0x70 - Trace memory permission control register 0.
        volatile uint32_t PRO_TRACE_1;  ///< Offset: 0x74 - Trace memory permission control register 1.
        volatile uint32_t PRO_CACHE_0;  ///< Offset: 0x78 - Cache permission control register 0.
        volatile uint32_t PRO_CACHE_1;  ///< Offset: 0x7C - Cache permission control register 1.
        volatile uint32_t PRO_CACHE_2;  ///< Offset: 0x80 - Cache permission control register 2.
        volatile uint32_t PRO_CACHE_3;  ///< Offset: 0x84 - Icache status register.
        volatile uint32_t PRO_CACHE_4;  ///< Offset: 0x88 - Dcache status register.
        volatile uint32_t DMA_APB_I_0;  ///< Offset: 0x8C - Internal DMA permission control register 0.
        volatile uint32_t DMA_APB_I_1;  ///< Offset: 0x90 - Internal DMA permission control register 1.
        volatile uint32_t DMA_APB_I_2;  ///< Offset: 0x94 - Internal DMA permission control register 2.
        volatile uint32_t DMA_APB_I_3;  ///< Offset: 0x98 - Internal DMA status register.
        volatile uint32_t DMA_RX_I_0;  ///< Offset: 0x9C - RX Copy DMA permission control register 0.
        volatile uint32_t DMA_RX_I_1;  ///< Offset: 0xA0 - RX Copy DMA permission control register 1.
        volatile uint32_t DMA_RX_I_2;  ///< Offset: 0xA4 - RX Copy DMA permission control register 2.
        volatile uint32_t DMA_RX_I_3;  ///< Offset: 0xA8 - RX Copy DMA status register.
        volatile uint32_t DMA_TX_I_0;  ///< Offset: 0xAC - TX Copy DMA permission control register 0.
        volatile uint32_t DMA_TX_I_1;  ///< Offset: 0xB0 - TX Copy DMA permission control register 1.
        volatile uint32_t DMA_TX_I_2;  ///< Offset: 0xB4 - TX Copy DMA permission control register 2.
        volatile uint32_t DMA_TX_I_3;  ///< Offset: 0xB8 - TX Copy DMA status register.
        volatile uint32_t PRO_BOOT_LOCATION_0;  ///< Offset: 0xBC - Boot permission control register 0.
        volatile uint32_t PRO_BOOT_LOCATION_1;  ///< Offset: 0xC0 - Boot permission control register 1.
        volatile uint32_t CACHE_SOURCE_0;  ///< Offset: 0xC4 - Cache access permission control register 0.
        volatile uint32_t CACHE_SOURCE_1;  ///< Offset: 0xC8 - Cache access permission control register 1.
        volatile uint32_t APB_PERIPHERAL_0;  ///< Offset: 0xCC - Peripheral access permission control register 0.
        volatile uint32_t APB_PERIPHERAL_1;  ///< Offset: 0xD0 - Peripheral access permission control register 1.
        volatile uint32_t OCCUPY_0;  ///< Offset: 0xD4 - Occupy permission control register 0.
        volatile uint32_t OCCUPY_1;  ///< Offset: 0xD8 - Occupy permission control register 1.
        volatile uint32_t OCCUPY_2;  ///< Offset: 0xDC - Occupy permission control register 2.
        volatile uint32_t OCCUPY_3;  ///< Offset: 0xE0 - Occupy permission control register 3.
        volatile uint32_t CACHE_TAG_ACCESS_0;  ///< Offset: 0xE4 - Cache tag permission control register 0.
        volatile uint32_t CACHE_TAG_ACCESS_1;  ///< Offset: 0xE8 - Cache tag permission control register 1.
        volatile uint32_t CACHE_MMU_ACCESS_0;  ///< Offset: 0xEC - Cache MMU permission control register 0.
        volatile uint32_t CACHE_MMU_ACCESS_1;  ///< Offset: 0xF0 - Cache MMU permission control register 1.
        volatile uint32_t APB_PERIPHERAL_INTR;  ///< Offset: 0xF4 - PeribBus2 permission control register.
        volatile uint32_t APB_PERIPHERAL_STATUS;  ///< Offset: 0xF8 - PeribBus2 peripheral access status register.
        volatile uint32_t CPU_PERIPHERAL_INTR;  ///< Offset: 0xFC - PeribBus1 permission control register.
        volatile uint32_t CPU_PERIPHERAL_STATUS;  ///< Offset: 0x100 - PeribBus1 peripheral access status register.
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x104 - Clock gate register of permission control.
        volatile uint32_t DATE;  ///< Offset: 0xFFC - Version control register.
    };

    /// Peripheral instances
    inline Registers* PMS = reinterpret_cast<Registers*>(PMS_BASE);

    // Bit definitions
    /// SDIO_0 Register bits
    namespace sdio_0_bits {
        constexpr uint32_t SDIO_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks SDIO permission control registers.
    }

    /// SDIO_1 Register bits
    namespace sdio_1_bits {
        constexpr uint32_t SDIO_DISABLE = (1U << 0);  ///< Setting to 1 disables the SDIO function.
    }

    /// MAC_DUMP_0 Register bits
    namespace mac_dump_0_bits {
        constexpr uint32_t MAC_DUMP_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks MAC dump permission control registers.
    }

    /// MAC_DUMP_1 Register bits
    namespace mac_dump_1_bits {
        constexpr uint32_t MAC_DUMP_CONNECT = (12 << 0);  ///< Configure MAC dump connection.
    }

    /// PRO_IRAM0_0 Register bits
    namespace pro_iram0_0_bits {
        constexpr uint32_t PRO_IRAM0_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks IBUS permission control registers.
    }

    /// PRO_IRAM0_1 Register bits
    namespace pro_iram0_1_bits {
        constexpr uint32_t PRO_IRAM0_SRAM_0_F = (1U << 0);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 0.
        constexpr uint32_t PRO_IRAM0_SRAM_0_R = (1U << 1);  ///< Setting to 1 grants IBUS permission to read SRAM Block 0.
        constexpr uint32_t PRO_IRAM0_SRAM_0_W = (1U << 2);  ///< Setting to 1 grants IBUS permission to write SRAM Block 0.
        constexpr uint32_t PRO_IRAM0_SRAM_1_F = (1U << 3);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 1.
        constexpr uint32_t PRO_IRAM0_SRAM_1_R = (1U << 4);  ///< Setting to 1 grants IBUS permission to read SRAM Block 1.
        constexpr uint32_t PRO_IRAM0_SRAM_1_W = (1U << 5);  ///< Setting to 1 grants IBUS permission to write SRAM Block 1.
        constexpr uint32_t PRO_IRAM0_SRAM_2_F = (1U << 6);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 2.
        constexpr uint32_t PRO_IRAM0_SRAM_2_R = (1U << 7);  ///< Setting to 1 grants IBUS permission to read SRAM Block 2.
        constexpr uint32_t PRO_IRAM0_SRAM_2_W = (1U << 8);  ///< Setting to 1 grants IBUS permission to write SRAM Block 2.
        constexpr uint32_t PRO_IRAM0_SRAM_3_F = (1U << 9);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 3.
        constexpr uint32_t PRO_IRAM0_SRAM_3_R = (1U << 10);  ///< Setting to 1 grants IBUS permission to read SRAM Block 3.
        constexpr uint32_t PRO_IRAM0_SRAM_3_W = (1U << 11);  ///< Setting to 1 grants IBUS permission to write SRAM Block 3.
    }

    /// PRO_IRAM0_2 Register bits
    namespace pro_iram0_2_bits {
        constexpr uint32_t PRO_IRAM0_SRAM_4_SPLTADDR = (17 << 0);  ///< Configure the split address of SRAM Block 4-21 for IBUS access.
        constexpr uint32_t PRO_IRAM0_SRAM_4_L_F = (1U << 17);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 4-21 low address region.
        constexpr uint32_t PRO_IRAM0_SRAM_4_L_R = (1U << 18);  ///< Setting to 1 grants IBUS permission to read SRAM Block 4-21 low address region.
        constexpr uint32_t PRO_IRAM0_SRAM_4_L_W = (1U << 19);  ///< Setting to 1 grants IBUS permission to write SRAM Block 4-21 low address region.
        constexpr uint32_t PRO_IRAM0_SRAM_4_H_F = (1U << 20);  ///< Setting to 1 grants IBUS permission to fetch SRAM Block 4-21 high address region.
        constexpr uint32_t PRO_IRAM0_SRAM_4_H_R = (1U << 21);  ///< Setting to 1 grants IBUS permission to read SRAM Block 4-21 high address region.
        constexpr uint32_t PRO_IRAM0_SRAM_4_H_W = (1U << 22);  ///< Setting to 1 grants IBUS permission to write SRAM Block 4-21 high address region.
    }

    /// PRO_IRAM0_3 Register bits
    namespace pro_iram0_3_bits {
        constexpr uint32_t PRO_IRAM0_RTCFAST_SPLTADDR = (11 << 0);  ///< Configure the split address of RTC FAST for IBUS access.
        constexpr uint32_t PRO_IRAM0_RTCFAST_L_F = (1U << 11);  ///< Setting to 1 grants IBUS permission to fetch RTC FAST low address region.
        constexpr uint32_t PRO_IRAM0_RTCFAST_L_R = (1U << 12);  ///< Setting to 1 grants IBUS permission to read RTC FAST low address region.
        constexpr uint32_t PRO_IRAM0_RTCFAST_L_W = (1U << 13);  ///< Setting to 1 grants IBUS permission to write RTC FAST low address region.
        constexpr uint32_t PRO_IRAM0_RTCFAST_H_F = (1U << 14);  ///< Setting to 1 grants IBUS permission to fetch RTC FAST high address region.
        constexpr uint32_t PRO_IRAM0_RTCFAST_H_R = (1U << 15);  ///< Setting to 1 grants IBUS permission to read RTC FAST high address region.
        constexpr uint32_t PRO_IRAM0_RTCFAST_H_W = (1U << 16);  ///< Setting to 1 grants IBUS permission to write RTC FAST high address region.
    }

    /// PRO_IRAM0_4 Register bits
    namespace pro_iram0_4_bits {
        constexpr uint32_t PRO_IRAM0_ILG_CLR = (1U << 0);  ///< The clear signal for IBUS access interrupt.
        constexpr uint32_t PRO_IRAM0_ILG_EN = (1U << 1);  ///< The enable signal for IBUS access interrupt.
        constexpr uint32_t PRO_IRAM0_ILG_INTR = (1U << 2);  ///< IBUS access interrupt signal.
    }

    /// PRO_IRAM0_5 Register bits
    namespace pro_iram0_5_bits {
        constexpr uint32_t PRO_IRAM0_ILG_ST = (22 << 0);  ///< Record the illegitimate information of IBUS. [21:2]: store the bits [21:2] of IBUS address. [1]: 1 means data access, 0 means instruction access. [0]: 1 means write operation, 0 means read operation.
    }

    /// PRO_DRAM0_0 Register bits
    namespace pro_dram0_0_bits {
        constexpr uint32_t PRO_DRAM0_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks DBUS0 permission control registers.
    }

    /// PRO_DRAM0_1 Register bits
    namespace pro_dram0_1_bits {
        constexpr uint32_t PRO_DRAM0_SRAM_0_R = (1U << 0);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 0.
        constexpr uint32_t PRO_DRAM0_SRAM_0_W = (1U << 1);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 0.
        constexpr uint32_t PRO_DRAM0_SRAM_1_R = (1U << 2);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 1.
        constexpr uint32_t PRO_DRAM0_SRAM_1_W = (1U << 3);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 1.
        constexpr uint32_t PRO_DRAM0_SRAM_2_R = (1U << 4);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 2.
        constexpr uint32_t PRO_DRAM0_SRAM_2_W = (1U << 5);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 2.
        constexpr uint32_t PRO_DRAM0_SRAM_3_R = (1U << 6);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 3.
        constexpr uint32_t PRO_DRAM0_SRAM_3_W = (1U << 7);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 3.
        constexpr uint32_t PRO_DRAM0_SRAM_4_SPLTADDR = (17 << 8);  ///< Configure the split address of SRAM Block 4-21 for DBUS0 access.
        constexpr uint32_t PRO_DRAM0_SRAM_4_L_R = (1U << 25);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 4-21 low address region.
        constexpr uint32_t PRO_DRAM0_SRAM_4_L_W = (1U << 26);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 4-21 low address region.
        constexpr uint32_t PRO_DRAM0_SRAM_4_H_R = (1U << 27);  ///< Setting to 1 grants DBUS0 permission to read SRAM Block 4-21 high address region.
        constexpr uint32_t PRO_DRAM0_SRAM_4_H_W = (1U << 28);  ///< Setting to 1 grants DBUS0 permission to write SRAM Block 4-21 high address region.
    }

    /// PRO_DRAM0_2 Register bits
    namespace pro_dram0_2_bits {
        constexpr uint32_t PRO_DRAM0_RTCFAST_SPLTADDR = (11 << 0);  ///< Configure the split address of RTC FAST for DBUS0 access.
        constexpr uint32_t PRO_DRAM0_RTCFAST_L_R = (1U << 11);  ///< Setting to 1 grants DBUS0 permission to read RTC FAST low address region.
        constexpr uint32_t PRO_DRAM0_RTCFAST_L_W = (1U << 12);  ///< Setting to 1 grants DBUS0 permission to write RTC FAST low address region.
        constexpr uint32_t PRO_DRAM0_RTCFAST_H_R = (1U << 13);  ///< Setting to 1 grants DBUS0 permission to read RTC FAST high address region.
        constexpr uint32_t PRO_DRAM0_RTCFAST_H_W = (1U << 14);  ///< Setting to 1 grants DBUS0 permission to write RTC FAST high address region.
    }

    /// PRO_DRAM0_3 Register bits
    namespace pro_dram0_3_bits {
        constexpr uint32_t PRO_DRAM0_ILG_CLR = (1U << 0);  ///< The clear signal for DBUS0 access interrupt.
        constexpr uint32_t PRO_DRAM0_ILG_EN = (1U << 1);  ///< The enable signal for DBUS0 access interrupt.
        constexpr uint32_t PRO_DRAM0_ILG_INTR = (1U << 2);  ///< DBUS0 access interrupt signal.
    }

    /// PRO_DRAM0_4 Register bits
    namespace pro_dram0_4_bits {
        constexpr uint32_t PRO_DRAM0_ILG_ST = (26 << 0);  ///< Record the illegitimate information of DBUS. [25:6]: store the bits [21:2] of DBUS address. [5]: 1 means atomic access, 0 means nonatomic access. [4]: 1 means write operation, 0 means read operation. [3:0]: DBUS0 bus byte enables.
    }

    /// PRO_DPORT_0 Register bits
    namespace pro_dport_0_bits {
        constexpr uint32_t PRO_DPORT_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks PeriBus1 permission control registers.
    }

    /// PRO_DPORT_1 Register bits
    namespace pro_dport_1_bits {
        constexpr uint32_t PRO_DPORT_APB_PERIPHERAL_FORBID = (1U << 0);  ///< Setting to 1 denies PeriBus1 bus???s access to APB peripheral.
        constexpr uint32_t PRO_DPORT_RTCSLOW_SPLTADDR = (11 << 1);  ///< Configure the split address of RTC FAST for PeriBus1 access.
        constexpr uint32_t PRO_DPORT_RTCSLOW_L_R = (1U << 12);  ///< Setting to 1 grants PeriBus1 permission to read RTC FAST low address region.
        constexpr uint32_t PRO_DPORT_RTCSLOW_L_W = (1U << 13);  ///< Setting to 1 grants PeriBus1 permission to write RTC FAST low address region.
        constexpr uint32_t PRO_DPORT_RTCSLOW_H_R = (1U << 14);  ///< Setting to 1 grants PeriBus1 permission to read RTC FAST high address region.
        constexpr uint32_t PRO_DPORT_RTCSLOW_H_W = (1U << 15);  ///< Setting to 1 grants PeriBus1 permission to write RTC FAST high address region.
        constexpr uint32_t PRO_DPORT_RESERVE_FIFO_VALID = (4 << 16);  ///< Configure whether to enable read protection for user-configured FIFO address.
    }

    /// PRO_DPORT_2 Register bits
    namespace pro_dport_2_bits {
        constexpr uint32_t PRO_DPORT_RESERVE_FIFO_0 = (18 << 0);  ///< Configure read-protection address 0.
    }

    /// PRO_DPORT_3 Register bits
    namespace pro_dport_3_bits {
        constexpr uint32_t PRO_DPORT_RESERVE_FIFO_1 = (18 << 0);  ///< Configure read-protection address 1.
    }

    /// PRO_DPORT_4 Register bits
    namespace pro_dport_4_bits {
        constexpr uint32_t PRO_DPORT_RESERVE_FIFO_2 = (18 << 0);  ///< Configure read-protection address 2.
    }

    /// PRO_DPORT_5 Register bits
    namespace pro_dport_5_bits {
        constexpr uint32_t PRO_DPORT_RESERVE_FIFO_3 = (18 << 0);  ///< Configure read-protection address 3.
    }

    /// PRO_DPORT_6 Register bits
    namespace pro_dport_6_bits {
        constexpr uint32_t PRO_DPORT_ILG_CLR = (1U << 0);  ///< The clear signal for PeriBus1 access interrupt.
        constexpr uint32_t PRO_DPORT_ILG_EN = (1U << 1);  ///< The enable signal for PeriBus1 access interrupt.
        constexpr uint32_t PRO_DPORT_ILG_INTR = (1U << 2);  ///< PeriBus1 access interrupt signal.
    }

    /// PRO_DPORT_7 Register bits
    namespace pro_dport_7_bits {
        constexpr uint32_t PRO_DPORT_ILG_ST = (26 << 0);  ///< Record the illegitimate information of PeriBus1. [25:6]: store the bits [21:2] of PeriBus1 address. [5]: 1 means atomic access, 0 means nonatomic access. [4]: if bits [31:22] of PeriBus1 address are 0xfd, then the bit value is 1, otherwise it is 0. [3:0]: PeriBus1 byte enables.
    }

    /// PRO_AHB_0 Register bits
    namespace pro_ahb_0_bits {
        constexpr uint32_t PRO_AHB_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks PeriBus2 permission control registers.
    }

    /// PRO_AHB_1 Register bits
    namespace pro_ahb_1_bits {
        constexpr uint32_t PRO_AHB_RTCSLOW_0_SPLTADDR = (11 << 0);  ///< Configure the split address of RTCSlow_0 for PeriBus2 access.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_L_F = (1U << 11);  ///< Setting to 1 grants PeriBus2 permission to fetch RTCSlow_0 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_L_R = (1U << 12);  ///< Setting to 1 grants PeriBus2 permission to read RTCSlow_0 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_L_W = (1U << 13);  ///< Setting to 1 grants PeriBus2 permission to write RTCSlow_0 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_H_F = (1U << 14);  ///< Setting to 1 grants PeriBus2 permission to fetch RTCSlow_0 high address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_H_R = (1U << 15);  ///< Setting to 1 grants PeriBus2 permission to read RTCSlow_0 high address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_0_H_W = (1U << 16);  ///< Setting to 1 grants PeriBus2 permission to write RTCSlow_0 high address region.
    }

    /// PRO_AHB_2 Register bits
    namespace pro_ahb_2_bits {
        constexpr uint32_t PRO_AHB_RTCSLOW_1_SPLTADDR = (11 << 0);  ///< Configure the split address of RTCSlow_1 for PeriBus2 access.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_L_F = (1U << 11);  ///< Setting to 1 grants PeriBus2 permission to fetch RTCSlow_1 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_L_R = (1U << 12);  ///< Setting to 1 grants PeriBus2 permission to read RTCSlow_1 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_L_W = (1U << 13);  ///< Setting to 1 grants PeriBus2 permission to write RTCSlow_1 low address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_H_F = (1U << 14);  ///< Setting to 1 grants PeriBus2 permission to fetch RTCSlow_1 high address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_H_R = (1U << 15);  ///< Setting to 1 grants PeriBus2 permission to read RTCSlow_1 high address region.
        constexpr uint32_t PRO_AHB_RTCSLOW_1_H_W = (1U << 16);  ///< Setting to 1 grants PeriBus2 permission to write RTCSlow_1 high address region.
    }

    /// PRO_AHB_3 Register bits
    namespace pro_ahb_3_bits {
        constexpr uint32_t PRO_AHB_ILG_CLR = (1U << 0);  ///< The clear signal for PeriBus2 access interrupt.
        constexpr uint32_t PRO_AHB_ILG_EN = (1U << 1);  ///< The enable signal for PeriBus2 access interrupt.
        constexpr uint32_t PRO_AHB_ILG_INTR = (1U << 2);  ///< PeriBus2 access interrupt signal.
    }

    /// PRO_AHB_4 Register bits
    namespace pro_ahb_4_bits {
        constexpr uint32_t PRO_AHB_ILG_ST = (32 << 0);  ///< Record the illegitimate information of PeriBus2. [31:2]: store the bits [31:2] of PeriBus2 address. [1]: 1 means data access, 0 means instruction access. [0]: 1 means write operation, 0 means read operation.
    }

    /// PRO_TRACE_0 Register bits
    namespace pro_trace_0_bits {
        constexpr uint32_t PRO_TRACE_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks trace function permission control registers.
    }

    /// PRO_TRACE_1 Register bits
    namespace pro_trace_1_bits {
        constexpr uint32_t PRO_TRACE_DISABLE = (1U << 0);  ///< Setting to 1 disables the trace memory function.
    }

    /// PRO_CACHE_0 Register bits
    namespace pro_cache_0_bits {
        constexpr uint32_t PRO_CACHE_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks cache permission control registers.
    }

    /// PRO_CACHE_1 Register bits
    namespace pro_cache_1_bits {
        constexpr uint32_t PRO_CACHE_CONNECT = (16 << 0);  ///< Configure which SRAM Block will be occupied by Icache or Dcache.
    }

    /// PRO_CACHE_2 Register bits
    namespace pro_cache_2_bits {
        constexpr uint32_t PRO_CACHE_ILG_CLR = (1U << 0);  ///< The clear signal for cache access interrupt.
        constexpr uint32_t PRO_CACHE_ILG_EN = (1U << 1);  ///< The enable signal for cache access interrupt.
        constexpr uint32_t PRO_CACHE_ILG_INTR = (1U << 2);  ///< Cache access interrupt signal.
    }

    /// PRO_CACHE_3 Register bits
    namespace pro_cache_3_bits {
        constexpr uint32_t PRO_CACHE_ILG_ST_I = (17 << 0);  ///< Record the illegitimate information of ICache to access memory. [16]: access enable, active low. [15:4]: store the bits [11:0] of address. [3:0]: Icache bus write byte enables, active low.
    }

    /// PRO_CACHE_4 Register bits
    namespace pro_cache_4_bits {
        constexpr uint32_t PRO_CACHE_ILG_ST_D = (17 << 0);  ///< Record the illegitimate information of Dcache to access memory. [16]: access enable, active low. [15:4]: store the bits [11:0] of address. [3:0]: Dcache bus write byte enables, active low.
    }

    /// DMA_APB_I_0 Register bits
    namespace dma_apb_i_0_bits {
        constexpr uint32_t DMA_APB_I_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks internal DMA permission control registers.
    }

    /// DMA_APB_I_1 Register bits
    namespace dma_apb_i_1_bits {
        constexpr uint32_t DMA_APB_I_SRAM_0_R = (1U << 0);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 0.
        constexpr uint32_t DMA_APB_I_SRAM_0_W = (1U << 1);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 0.
        constexpr uint32_t DMA_APB_I_SRAM_1_R = (1U << 2);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 1.
        constexpr uint32_t DMA_APB_I_SRAM_1_W = (1U << 3);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 1.
        constexpr uint32_t DMA_APB_I_SRAM_2_R = (1U << 4);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 2.
        constexpr uint32_t DMA_APB_I_SRAM_2_W = (1U << 5);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 2.
        constexpr uint32_t DMA_APB_I_SRAM_3_R = (1U << 6);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 3.
        constexpr uint32_t DMA_APB_I_SRAM_3_W = (1U << 7);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 3.
        constexpr uint32_t DMA_APB_I_SRAM_4_SPLTADDR = (17 << 8);  ///< Configure the split address of SRAM Block 4-21 for internal DMA access.
        constexpr uint32_t DMA_APB_I_SRAM_4_L_R = (1U << 25);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_APB_I_SRAM_4_L_W = (1U << 26);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_APB_I_SRAM_4_H_R = (1U << 27);  ///< Setting to 1 grants internal DMA permission to read SRAM Block 4-21 high address region.
        constexpr uint32_t DMA_APB_I_SRAM_4_H_W = (1U << 28);  ///< Setting to 1 grants internal DMA permission to write SRAM Block 4-21 high address region.
    }

    /// DMA_APB_I_2 Register bits
    namespace dma_apb_i_2_bits {
        constexpr uint32_t DMA_APB_I_ILG_CLR = (1U << 0);  ///< The clear signal for internal DMA access interrupt.
        constexpr uint32_t DMA_APB_I_ILG_EN = (1U << 1);  ///< The enable signal for internal DMA access interrupt.
        constexpr uint32_t DMA_APB_I_ILG_INTR = (1U << 2);  ///< Internal DMA access interrupt signal.
    }

    /// DMA_APB_I_3 Register bits
    namespace dma_apb_i_3_bits {
        constexpr uint32_t DMA_APB_I_ILG_ST = (23 << 0);  ///< Record the illegitimate information of Internal DMA. [22:6]: store the bits [18:2] of address. [5]: if bits [31:19] of address are 0x7ff, then the bit value is 1, otherwise it is 0. [4]: 1 means write operation, 0 means read operation. [3:0]: Internal DMA bus byte enables.
    }

    /// DMA_RX_I_0 Register bits
    namespace dma_rx_i_0_bits {
        constexpr uint32_t DMA_RX_I_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks RX Copy DMA permission control registers.
    }

    /// DMA_RX_I_1 Register bits
    namespace dma_rx_i_1_bits {
        constexpr uint32_t DMA_RX_I_SRAM_0_R = (1U << 0);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 0.
        constexpr uint32_t DMA_RX_I_SRAM_0_W = (1U << 1);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 0.
        constexpr uint32_t DMA_RX_I_SRAM_1_R = (1U << 2);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 1.
        constexpr uint32_t DMA_RX_I_SRAM_1_W = (1U << 3);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 1.
        constexpr uint32_t DMA_RX_I_SRAM_2_R = (1U << 4);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 2.
        constexpr uint32_t DMA_RX_I_SRAM_2_W = (1U << 5);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 2.
        constexpr uint32_t DMA_RX_I_SRAM_3_R = (1U << 6);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 3.
        constexpr uint32_t DMA_RX_I_SRAM_3_W = (1U << 7);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 3.
        constexpr uint32_t DMA_RX_I_SRAM_4_SPLTADDR = (17 << 8);  ///< Configure the split address of SRAM Block 4-21 for RX Copy DMA access.
        constexpr uint32_t DMA_RX_I_SRAM_4_L_R = (1U << 25);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_RX_I_SRAM_4_L_W = (1U << 26);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_RX_I_SRAM_4_H_R = (1U << 27);  ///< Setting to 1 grants RX Copy DMA permission to read SRAM Block 4-21 high address region.
        constexpr uint32_t DMA_RX_I_SRAM_4_H_W = (1U << 28);  ///< Setting to 1 grants RX Copy DMA permission to write SRAM Block 4~21 high address region.
    }

    /// DMA_RX_I_2 Register bits
    namespace dma_rx_i_2_bits {
        constexpr uint32_t DMA_RX_I_ILG_CLR = (1U << 0);  ///< The clear signal for RX Copy DMA access interrupt.
        constexpr uint32_t DMA_RX_I_ILG_EN = (1U << 1);  ///< The enable signal for RX Copy DMA access interrupt.
        constexpr uint32_t DMA_RX_I_ILG_INTR = (1U << 2);  ///< RX Copy DMA access interrupt signal.
    }

    /// DMA_RX_I_3 Register bits
    namespace dma_rx_i_3_bits {
        constexpr uint32_t DMA_RX_I_ILG_ST = (23 << 0);  ///< Record the illegitimate information of RX Copy DMA. [22:6]: store the bits [18:2] of address. [5]: if bits [31:19] of address are 0x7ff, then the bit value is 1, otherwise it is 0. [4]: 1 means write operation, 0 means read operation. [3:0]: RX Copy DMA bus byte enables.
    }

    /// DMA_TX_I_0 Register bits
    namespace dma_tx_i_0_bits {
        constexpr uint32_t DMA_TX_I_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks TX Copy DMA permission control registers.
    }

    /// DMA_TX_I_1 Register bits
    namespace dma_tx_i_1_bits {
        constexpr uint32_t DMA_TX_I_SRAM_0_R = (1U << 0);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 0.
        constexpr uint32_t DMA_TX_I_SRAM_0_W = (1U << 1);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 0.
        constexpr uint32_t DMA_TX_I_SRAM_1_R = (1U << 2);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 1.
        constexpr uint32_t DMA_TX_I_SRAM_1_W = (1U << 3);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 1.
        constexpr uint32_t DMA_TX_I_SRAM_2_R = (1U << 4);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 2.
        constexpr uint32_t DMA_TX_I_SRAM_2_W = (1U << 5);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 2.
        constexpr uint32_t DMA_TX_I_SRAM_3_R = (1U << 6);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 3.
        constexpr uint32_t DMA_TX_I_SRAM_3_W = (1U << 7);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 3.
        constexpr uint32_t DMA_TX_I_SRAM_4_SPLTADDR = (17 << 8);  ///< Configure the split address of SRAM Block 4-21 for TX Copy DMA access.
        constexpr uint32_t DMA_TX_I_SRAM_4_L_R = (1U << 25);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_TX_I_SRAM_4_L_W = (1U << 26);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 4-21 low address region.
        constexpr uint32_t DMA_TX_I_SRAM_4_H_R = (1U << 27);  ///< Setting to 1 grants TX Copy DMA permission to read SRAM Block 4-21 high address region.
        constexpr uint32_t DMA_TX_I_SRAM_4_H_W = (1U << 28);  ///< Setting to 1 grants TX Copy DMA permission to write SRAM Block 4-21 high address region.
    }

    /// DMA_TX_I_2 Register bits
    namespace dma_tx_i_2_bits {
        constexpr uint32_t DMA_TX_I_ILG_CLR = (1U << 0);  ///< The clear signal for TX Copy DMA access interrupt.
        constexpr uint32_t DMA_TX_I_ILG_EN = (1U << 1);  ///< The enable signal for TX Copy DMA access interrupt.
        constexpr uint32_t DMA_TX_I_ILG_INTR = (1U << 2);  ///< TX Copy DMA access interrupt signal.
    }

    /// DMA_TX_I_3 Register bits
    namespace dma_tx_i_3_bits {
        constexpr uint32_t DMA_TX_I_ILG_ST = (23 << 0);  ///< Record the illegitimate information of TX Copy DMA. [22:6]: store the bits [18:2] of address. [5]: if bits [31:19] of address are 0x7ff, then the bit value is 1, otherwise it is 0. [4]: 1 means write operation, 0 means read operation. [3:0]: TX Copy DMA bus byte enables.
    }

    /// PRO_BOOT_LOCATION_0 Register bits
    namespace pro_boot_location_0_bits {
        constexpr uint32_t PRO_BOOT_LOCATION_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks boot remap permission control registers.
    }

    /// PRO_BOOT_LOCATION_1 Register bits
    namespace pro_boot_location_1_bits {
        constexpr uint32_t PRO_BOOT_REMAP = (1U << 0);  ///< If set to 1, enable boot remap function.
    }

    /// CACHE_SOURCE_0 Register bits
    namespace cache_source_0_bits {
        constexpr uint32_t CACHE_SOURCE_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks cache access permission control registers.
    }

    /// CACHE_SOURCE_1 Register bits
    namespace cache_source_1_bits {
        constexpr uint32_t PRO_CACHE_I_SOURCE_PRO_IRAM1 = (1U << 0);  ///< xx
        constexpr uint32_t PRO_CACHE_I_SOURCE_PRO_IROM0 = (1U << 1);  ///< xx
        constexpr uint32_t PRO_CACHE_I_SOURCE_PRO_DROM0 = (1U << 2);  ///< xx
        constexpr uint32_t PRO_CACHE_D_SOURCE_PRO_DRAM0 = (1U << 3);  ///< xx
        constexpr uint32_t PRO_CACHE_D_SOURCE_PRO_DPORT = (1U << 4);  ///< xx
        constexpr uint32_t PRO_CACHE_D_SOURCE_PRO_DROM0 = (1U << 5);  ///< xx
    }

    /// APB_PERIPHERAL_0 Register bits
    namespace apb_peripheral_0_bits {
        constexpr uint32_t APB_PERIPHERAL_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks TX Copy DMA permission control registers.
    }

    /// APB_PERIPHERAL_1 Register bits
    namespace apb_peripheral_1_bits {
        constexpr uint32_t APB_PERIPHERAL_SPLIT_BURST = (1U << 0);  ///< Setting to 1 splits the data phase of the last access and the address phase of following access.
    }

    /// OCCUPY_0 Register bits
    namespace occupy_0_bits {
        constexpr uint32_t OCCUPY_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks occupy permission control registers.
    }

    /// OCCUPY_1 Register bits
    namespace occupy_1_bits {
        constexpr uint32_t OCCUPY_CACHE = (4 << 0);  ///< Configure whether SRAM Block 0-3 is used as cache memory.
    }

    /// OCCUPY_2 Register bits
    namespace occupy_2_bits {
        constexpr uint32_t OCCUPY_MAC_DUMP = (4 << 0);  ///< Configure whether SRAM Block 18-21 is used as mac dump.
    }

    /// OCCUPY_3 Register bits
    namespace occupy_3_bits {
        constexpr uint32_t OCCUPY_PRO_TRACE = (18 << 0);  ///< Configure one block of SRAM Block 4-21 is used as trace memory.
    }

    /// CACHE_TAG_ACCESS_0 Register bits
    namespace cache_tag_access_0_bits {
        constexpr uint32_t CACHE_TAG_ACCESS_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks cache tag permission control registers.
    }

    /// CACHE_TAG_ACCESS_1 Register bits
    namespace cache_tag_access_1_bits {
        constexpr uint32_t PRO_I_TAG_RD_ACS = (1U << 0);  ///< Setting to 1 permits read access to Icache tag memory.
        constexpr uint32_t PRO_I_TAG_WR_ACS = (1U << 1);  ///< Setting to 1 permits write access to Icache tag memory.
        constexpr uint32_t PRO_D_TAG_RD_ACS = (1U << 2);  ///< Setting to 1 permits read access to Dcache tag memory.
        constexpr uint32_t PRO_D_TAG_WR_ACS = (1U << 3);  ///< Setting to 1 permits write access to Dcache tag memory.
    }

    /// CACHE_MMU_ACCESS_0 Register bits
    namespace cache_mmu_access_0_bits {
        constexpr uint32_t CACHE_MMU_ACCESS_LOCK = (1U << 0);  ///< Lock register. Setting to 1 locks cache MMU permission control registers.
    }

    /// CACHE_MMU_ACCESS_1 Register bits
    namespace cache_mmu_access_1_bits {
        constexpr uint32_t PRO_MMU_RD_ACS = (1U << 0);  ///< Setting to 1 permits read access to MMU memory.
        constexpr uint32_t PRO_MMU_WR_ACS = (1U << 1);  ///< Setting to 1 permits write access to MMU memory.
    }

    /// APB_PERIPHERAL_INTR Register bits
    namespace apb_peripheral_intr_bits {
        constexpr uint32_t APB_PERI_BYTE_ERROR_CLR = (1U << 0);  ///< The clear signal for APB peripheral interrupt.
        constexpr uint32_t APB_PERI_BYTE_ERROR_EN = (1U << 1);  ///< The enable signal for APB peripheral access interrupt.
        constexpr uint32_t APB_PERI_BYTE_ERROR_INTR = (1U << 2);  ///< APB peripheral access interrupt signal.
    }

    /// APB_PERIPHERAL_STATUS Register bits
    namespace apb_peripheral_status_bits {
        constexpr uint32_t APB_PERI_BYTE_ERROR_ADDR = (32 << 0);  ///< Record the illegitimate address of APB peripheral.
    }

    /// CPU_PERIPHERAL_INTR Register bits
    namespace cpu_peripheral_intr_bits {
        constexpr uint32_t CPU_PERI_BYTE_ERROR_CLR = (1U << 0);  ///< The clear signal for CPU peripheral access interrupt.
        constexpr uint32_t CPU_PERI_BYTE_ERROR_EN = (1U << 1);  ///< The enable signal for CPU peripheral access interrupt.
        constexpr uint32_t CPU_PERI_BYTE_ERROR_INTR = (1U << 2);  ///< CPU peripheral access interrupt signal.
    }

    /// CPU_PERIPHERAL_STATUS Register bits
    namespace cpu_peripheral_status_bits {
        constexpr uint32_t CPU_PERI_BYTE_ERROR_ADDR = (32 << 0);  ///< Record the illegitimate address of CPU peripheral.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Enable the clock of permission control module when set to 1.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Version control register.
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x3F416000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t CH%sDATA;  ///< Offset: 0x00 - The read and write data register for CHANNEL%s by apb...
        volatile uint32_t CH%sCONF0;  ///< Offset: 0x10 - Channel %s configure register 0
        volatile uint32_t CH%sCONF1;  ///< Offset: 0x14 - Channel %s configure register 1
        volatile uint32_t CH%sSTATUS;  ///< Offset: 0x30 - Channel %s status register
        volatile uint32_t CH%sADDR;  ///< Offset: 0x40 - Channel %s address register
        volatile uint32_t INT_RAW;  ///< Offset: 0x50 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x54 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x58 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x5C - Interrupt clear bits
        volatile uint32_t CH%sCARRIER_DUTY;  ///< Offset: 0x60 - Channel %s duty cycle configuration register
        volatile uint32_t CH%s_TX_LIM;  ///< Offset: 0x70 - Channel %s Tx event configuration register
        volatile uint32_t APB_CONF;  ///< Offset: 0x80 - RMT apb configuration register
        volatile uint32_t TX_SIM;  ///< Offset: 0x84 - RMT TX synchronous register
        volatile uint32_t REF_CNT_RST;  ///< Offset: 0x88 - RMT clock divider reset register
        volatile uint32_t CH%s_RX_CARRIER_RM;  ///< Offset: 0x8C - Channel %s carrier remove register
        volatile uint32_t DATE;  ///< Offset: 0xFC - RMT version register
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// CH%sDATA Register bits
    namespace ch%sdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< The read and write data register for CHANNEL%s by apb fifo access.
    }

    /// CH%sCONF0 Register bits
    namespace ch%sconf0_bits {
        constexpr uint32_t DIV_CNT = (8 << 0);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t IDLE_THRES = (16 << 8);  ///< When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
        constexpr uint32_t MEM_SIZE = (3 << 24);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EFF_EN = (1U << 27);  ///< 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
        constexpr uint32_t CARRIER_EN = (1U << 28);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 29);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s. 1'h0: add carrier wave on low level. 1'h1: add carrier wave on high level.
    }

    /// CH%sCONF1 Register bits
    namespace ch%sconf1_bits {
        constexpr uint32_t TX_START = (1U << 0);  ///< Set this bit to start sending data on CHANNEL%s.
        constexpr uint32_t RX_EN = (1U << 1);  ///< Set this bit to enable receiver to receive data on CHANNEL%s.
        constexpr uint32_t MEM_WR_RST = (1U << 2);  ///< Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
        constexpr uint32_t MEM_RD_RST = (1U << 3);  ///< Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
        constexpr uint32_t APB_MEM_RST = (1U << 4);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t MEM_OWNER = (1U << 5);  ///< This register marks the ownership of CHANNEL%s's ram block. 1'h1: Receiver is using the ram. 1'h0: Transmitter is using the ram.
        constexpr uint32_t TX_CONTI_MODE = (1U << 6);  ///< Set this bit to restart transmission from the first data to the last data in CHANNEL%s.
        constexpr uint32_t RX_FILTER_EN = (1U << 7);  ///< This is the receive filter's enable bit for CHANNEL%s.
        constexpr uint32_t RX_FILTER_THRES = (8 << 8);  ///< Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
        constexpr uint32_t CHK_RX_CARRIER_EN = (1U << 16);  ///< Set this bit to enable memory loop read mode when carrier modulation is enabled for channel %s.
        constexpr uint32_t REF_ALWAYS_ON = (1U << 17);  ///< This bit is used to select the base clock for CHANNEL%s. 1'h1: clk_apb 1'h0:clk_ref
        constexpr uint32_t IDLE_OUT_LV = (1U << 18);  ///< This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
        constexpr uint32_t IDLE_OUT_EN = (1U << 19);  ///< This is the output enable-control bit for CHANNEL%s in IDLE state.
        constexpr uint32_t TX_STOP = (1U << 20);  ///< Set this bit to stop the transmitter of CHANNEL%s sending data out.
    }

    /// CH%sSTATUS Register bits
    namespace ch%sstatus_bits {
        constexpr uint32_t MEM_WADDR_EX = (9 << 0);  ///< This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
        constexpr uint32_t MEM_RADDR_EX = (9 << 10);  ///< This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
        constexpr uint32_t STATE = (3 << 20);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_OWNER_ERR = (1U << 23);  ///< This status bit will be set when the ownership of memory block is wrong.
        constexpr uint32_t MEM_FULL = (1U << 24);  ///< This status bit will be set if the receiver receives more data than the memory size.
        constexpr uint32_t MEM_EMPTY = (1U << 25);  ///< This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
        constexpr uint32_t APB_MEM_WR_ERR = (1U << 26);  ///< This status bit will be set if the offset address out of memory size when writes via APB bus.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 27);  ///< This status bit will be set if the offset address out of memory size when reads via APB bus.
    }

    /// CH%sADDR Register bits
    namespace ch%saddr_bits {
        constexpr uint32_t APB_MEM_WADDR = (9 << 0);  ///< This register records the memory address offset when writes RAM over APB bus.
        constexpr uint32_t APB_MEM_RADDR = (9 << 10);  ///< This register records the memory address offset when reads RAM over APB bus.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< The interrupt raw bit for CHANNEL%s. Triggered when reception done.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< The interrupt raw bit for CHANNEL%s. Triggered when error occurs.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 12);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 16);  ///< The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The masked interrupt status bit for CH%s_TX_END_INT.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< The masked interrupt status bit for CH%s_RX_END_INT.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< The masked interrupt status bit for CH%s_ERR_INT.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 12);  ///< The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 16);  ///< The masked interrupt status bit for CH%s_TX_LOOP_INT.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< The interrupt enabled bit for CH%s_TX_END_INT.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< The interrupt enabled bit for CH%s_RX_END_INT.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< The interrupt enabled bit for CH%s_ERR_INT.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 12);  ///< The interrupt enabled bit for CH%s_TX_THR_EVENT_INT.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 16);  ///< The interrupt enabled bit for CH%s_TX_LOOP_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH%s_TX_END = (1U << 0);  ///< Set this bit to clear the CH%s_TX_END_INT interrupt.
        constexpr uint32_t CH%s_RX_END = (1U << 1);  ///< Set this bit to clear the CH%s_RX_END_INT interrupt.
        constexpr uint32_t CH%s_ERR = (1U << 2);  ///< Set this bit to clear the CH%s_ERR_INT interrupt.
        constexpr uint32_t CH%s_TX_THR_EVENT = (1U << 12);  ///< Set this bit to clear the CH%s_TX_THR_EVENT_INT interrupt.
        constexpr uint32_t CH%s_TX_LOOP = (1U << 16);  ///< Set this bit to clear the CH%s_TX_LOOP_INT interrupt.
    }

    /// CH%sCARRIER_DUTY Register bits
    namespace ch%scarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW = (16 << 0);  ///< This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
        constexpr uint32_t CARRIER_HIGH = (16 << 16);  ///< This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
    }

    /// CH%s_TX_LIM Register bits
    namespace ch%s_tx_lim_bits {
        constexpr uint32_t TX_LIM = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can send out.
        constexpr uint32_t TX_LOOP_NUM = (10 << 9);  ///< This register is used to configure the maximum loop count when tx_conti_mode is valid.
        constexpr uint32_t TX_LOOP_CNT_EN = (1U << 19);  ///< This register is the enabled bit for loop count.
        constexpr uint32_t LOOP_COUNT_RESET = (1U << 20);  ///< This register is used to reset the loop count when tx_conti_mode is valid.
    }

    /// APB_CONF Register bits
    namespace apb_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< 1'h1: access memory directly. 1'h0: access memory by FIFO.
        constexpr uint32_t MEM_TX_WRAP_EN = (1U << 1);  ///< This is the enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 2);  ///< Set this bit to enable the clock for RMT memory.
        constexpr uint32_t MEM_FORCE_PD = (1U << 3);  ///< Set this bit to power down RMT memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 4);  ///< 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
    }

    /// TX_SIM Register bits
    namespace tx_sim_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH1 = (1U << 1);  ///< Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH2 = (1U << 2);  ///< Set this bit to enable CHANNEL2 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH3 = (1U << 3);  ///< Set this bit to enable CHANNEL3 to start sending data synchronously with other enabled channels.
        constexpr uint32_t EN = (1U << 4);  ///< This register is used to enable multiple of channels to start sending data synchronously.
    }

    /// REF_CNT_RST Register bits
    namespace ref_cnt_rst_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< This register is used to reset the clock divider of CHANNEL0.
        constexpr uint32_t CH1 = (1U << 1);  ///< This register is used to reset the clock divider of CHANNEL1.
        constexpr uint32_t CH2 = (1U << 2);  ///< This register is used to reset the clock divider of CHANNEL2.
        constexpr uint32_t CH3 = (1U << 3);  ///< This register is used to reset the clock divider of CHANNEL3.
    }

    /// CH%s_RX_CARRIER_RM Register bits
    namespace ch%s_rx_carrier_rm_bits {
        constexpr uint32_t CARRIER_LOW_THRES = (16 << 0);  ///< The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
        constexpr uint32_t CARRIER_HIGH_THRES = (16 << 16);  ///< The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x60035000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x110 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_IO_BASE = 0x3F408400;
    constexpr uint32_t RTC_CNTL_BASE = 0x3F408000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t RTC_GPIO_OUT;  ///< Offset: 0x00 - RTC GPIO output register
        volatile uint32_t RTC_GPIO_OUT_W1TS;  ///< Offset: 0x04 - RTC GPIO output bit set register
        volatile uint32_t RTC_GPIO_OUT_W1TC;  ///< Offset: 0x08 - RTC GPIO output bit clear register
        volatile uint32_t RTC_GPIO_ENABLE;  ///< Offset: 0x0C - RTC GPIO output enable register
        volatile uint32_t RTC_GPIO_ENABLE_W1TS;  ///< Offset: 0x10 - RTC GPIO output enable bit set register
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x14 - RTC GPIO output enable bit clear register
        volatile uint32_t RTC_GPIO_STATUS;  ///< Offset: 0x18 - RTC GPIO interrupt status register
        volatile uint32_t RTC_GPIO_STATUS_W1TS;  ///< Offset: 0x1C - RTC GPIO interrupt status bit set register
        volatile uint32_t RTC_GPIO_STATUS_W1TC;  ///< Offset: 0x20 - RTC GPIO interrupt status bit clear register
        volatile uint32_t RTC_GPIO_IN;  ///< Offset: 0x24 - RTC GPIO input register
        volatile uint32_t PIN%s;  ///< Offset: 0x28 - RTC configuration for pin %s
        volatile uint32_t RTC_DEBUG_SEL;  ///< Offset: 0x80 - RTC debug select register
        volatile uint32_t TOUCH_PAD%s;  ///< Offset: 0x84 - Touch pad %s configuration register
        volatile uint32_t XTAL_32P_PAD;  ///< Offset: 0xC0 - 32KHz crystal P-pad configuration register
        volatile uint32_t XTAL_32N_PAD;  ///< Offset: 0xC4 - 32KHz crystal N-pad configuration register
        volatile uint32_t PAD_DAC1;  ///< Offset: 0xC8 - DAC1 configuration register
        volatile uint32_t PAD_DAC2;  ///< Offset: 0xCC - DAC2 configuration register
        volatile uint32_t RTC_PAD19;  ///< Offset: 0xD0 - Touch pad 19 configuration register
        volatile uint32_t RTC_PAD20;  ///< Offset: 0xD4 - Touch pad 20 configuration register
        volatile uint32_t RTC_PAD21;  ///< Offset: 0xD8 - Touch pad 21 configuration register
        volatile uint32_t EXT_WAKEUP0;  ///< Offset: 0xDC - External wake up configuration register
        volatile uint32_t XTL_EXT_CTR;  ///< Offset: 0xE0 - Crystal power down enable GPIO source
        volatile uint32_t SAR_I2C_IO;  ///< Offset: 0xE4 - RTC I2C pad selection
        volatile uint32_t RTC_IO_TOUCH_CTRL;  ///< Offset: 0xE8 - Touch control register
        volatile uint32_t RTC_IO_DATE;  ///< Offset: 0x1FC - Version control register
    };

    /// Peripheral instances
    inline Registers* RTC_IO = reinterpret_cast<Registers*>(RTC_IO_BASE);
    inline Registers* RTC_CNTL = reinterpret_cast<Registers*>(RTC_CNTL_BASE);

    // Bit definitions
    /// RTC_GPIO_OUT Register bits
    namespace rtc_gpio_out_bits {
        constexpr uint32_t GPIO_OUT_DATA = (22 << 10);  ///< GPIO0 ~ 21 output register. Bit10 corresponds to GPIO0, bit11 corresponds to GPIO1, etc.
    }

    /// RTC_GPIO_OUT_W1TS Register bits
    namespace rtc_gpio_out_w1ts_bits {
        constexpr uint32_t GPIO_OUT_DATA_W1TS = (22 << 10);  ///< GPIO0 ~ 21 output set register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_RTC_GPIO_OUT_REG will be set to 1. Recommended operation: use this register to set RTCIO_RTC_GPIO_OUT_REG.
    }

    /// RTC_GPIO_OUT_W1TC Register bits
    namespace rtc_gpio_out_w1tc_bits {
        constexpr uint32_t GPIO_OUT_DATA_W1TC = (22 << 10);  ///< GPIO0 ~ 21 output clear register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_RTC_GPIO_OUT_REG will be cleared. Recommended operation: use this register to clear RTCIO_RTC_GPIO_OUT_REG.
    }

    /// RTC_GPIO_ENABLE Register bits
    namespace rtc_gpio_enable_bits {
        constexpr uint32_t REG_RTCIO_REG_GPIO_ENABLE = (22 << 10);  ///< GPIO0 ~ 21 output enable. Bit10 corresponds to GPIO0, bit11 corresponds to GPIO1, etc. If the bit is set to 1, it means this GPIO pad is output.
    }

    /// RTC_GPIO_ENABLE_W1TS Register bits
    namespace rtc_gpio_enable_w1ts_bits {
        constexpr uint32_t REG_RTCIO_REG_GPIO_ENABLE_W1TS = (22 << 10);  ///< GPIO0 ~ 21 output enable set register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_RTC_GPIO_ENABLE_REG will be set to 1. Recommended operation: use this register to set RTCIO_RTC_GPIO_ENABLE_REG.
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (22 << 10);  ///< GPIO0 ~ 21 output enable clear register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_RTC_GPIO_ENABLE_REG will be cleared. Recommended operation: use this register to clear RTCIO_RTC_GPIO_ENABLE_REG.
    }

    /// RTC_GPIO_STATUS Register bits
    namespace rtc_gpio_status_bits {
        constexpr uint32_t GPIO_STATUS_INT = (22 << 10);  ///< GPIO0 ~ 21 interrupt status register. Bit10 corresponds to GPIO0, bit11 corresponds to GPIO1, etc. This register should be used together with RTCIO_RTC_GPIO_PINn_INT_TYPE in RTCIO_RTC_GPIO_PINn_REG. 0: no interrupt; 1: corresponding interrupt.
    }

    /// RTC_GPIO_STATUS_W1TS Register bits
    namespace rtc_gpio_status_w1ts_bits {
        constexpr uint32_t GPIO_STATUS_INT_W1TS = (22 << 10);  ///< GPIO0 ~ 21 interrupt set register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_GPIO_STATUS_INT will be set to 1. Recommended operation: use this register to set RTCIO_GPIO_STATUS_INT.
    }

    /// RTC_GPIO_STATUS_W1TC Register bits
    namespace rtc_gpio_status_w1tc_bits {
        constexpr uint32_t GPIO_STATUS_INT_W1TC = (22 << 10);  ///< GPIO0 ~ 21 interrupt clear register. If the value 1 is written to a bit here, the corresponding bit in RTCIO_GPIO_STATUS_INT will be cleared. Recommended operation: use this register to clear RTCIO_GPIO_STATUS_INT.
    }

    /// RTC_GPIO_IN Register bits
    namespace rtc_gpio_in_bits {
        constexpr uint32_t GPIO_IN_NEXT = (22 << 10);  ///< GPIO0 ~ 21 input value. Bit10 corresponds to GPIO0, bit11 corresponds to GPIO1, etc. Each bit represents a pad input value, 1 for high level, and 0 for low level.
    }

    /// PIN%s Register bits
    namespace pin%s_bits {
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< Pad driver selection. 0: normal output. 1: open drain.
        constexpr uint32_t GPIO_PIN_INT_TYPE = (3 << 7);  ///< GPIO interrupt type selection. 0: GPIO interrupt disabled. 1: rising edge trigger. 2: falling edge trigger. 3: any edge trigger. 4: low level trigger. 5: high level trigger.
        constexpr uint32_t GPIO_PIN_WAKEUP_ENABLE = (1U << 10);  ///< GPIO wake-up enable. This will only wake up ESP32-S2 from Light-sleep.
    }

    /// RTC_DEBUG_SEL Register bits
    namespace rtc_debug_sel_bits {
        constexpr uint32_t RTC_DEBUG_SEL0 = (5 << 0);  ///< RTC_DEBUG_SEL0
        constexpr uint32_t RTC_DEBUG_SEL1 = (5 << 5);  ///< RTC_DEBUG_SEL1
        constexpr uint32_t RTC_DEBUG_SEL2 = (5 << 10);  ///< RTC_DEBUG_SEL2
        constexpr uint32_t RTC_DEBUG_SEL3 = (5 << 15);  ///< RTC_DEBUG_SEL3
        constexpr uint32_t RTC_DEBUG_SEL4 = (5 << 20);  ///< RTC_DEBUG_SEL4
        constexpr uint32_t RTC_DEBUG_12M_NO_GATING = (1U << 25);  ///< RTC_DEBUG_12M_NO_GATING
    }

    /// TOUCH_PAD%s Register bits
    namespace touch_pad%s_bits {
        constexpr uint32_t FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t SLP_SEL = (1U << 16);  ///< 0: no sleep mode. 1: enable sleep mode.
        constexpr uint32_t FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t MUX_SEL = (1U << 19);  ///< Connect the RTC pad input to digital pad input. 0 is available.
        constexpr uint32_t XPD = (1U << 20);  ///< Touch sensor power on.
        constexpr uint32_t TIE_OPT = (1U << 21);  ///< The tie option of touch sensor. 0: tie low. 1: tie high.
        constexpr uint32_t START = (1U << 22);  ///< Start touch sensor.
        constexpr uint32_t DAC = (3 << 23);  ///< Touch sensor slope control. 3-bit for each touch pad, defaults to 0x4.
        constexpr uint32_t RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// XTAL_32P_PAD Register bits
    namespace xtal_32p_pad_bits {
        constexpr uint32_t X32P_FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t X32P_SLP_OE = (1U << 14);  ///< output enable in sleep mode.
        constexpr uint32_t X32P_SLP_IE = (1U << 15);  ///< input enable in sleep mode.
        constexpr uint32_t X32P_SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode.
        constexpr uint32_t X32P_FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t X32P_MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t X32P_RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t X32P_RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t X32P_DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// XTAL_32N_PAD Register bits
    namespace xtal_32n_pad_bits {
        constexpr uint32_t X32N_FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t X32N_SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t X32N_SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t X32N_SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode.
        constexpr uint32_t X32N_FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t X32N_MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t X32N_RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t X32N_RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t X32N_DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// PAD_DAC1 Register bits
    namespace pad_dac1_bits {
        constexpr uint32_t PDAC1_DAC = (8 << 3);  ///< Configure DAC_1 output when RTCIO_PDAC1_DAC_XPD_FORCE is set to 1.
        constexpr uint32_t PDAC1_XPD_DAC = (1U << 11);  ///< When RTCIO_PDAC1_DAC_XPD_FORCE is set to 1, 1: enable DAC_1 output. 0: disable DAC_1 output.
        constexpr uint32_t PDAC1_DAC_XPD_FORCE = (1U << 12);  ///< 1: use RTCIO_PDAC1_XPD_DAC to control DAC_1 output. 0: use SAR ADC FSM to control DAC_1 output.
        constexpr uint32_t PDAC1_FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t PDAC1_SLP_OE = (1U << 14);  ///< Output enable in sleep mode
        constexpr uint32_t PDAC1_SLP_IE = (1U << 15);  ///< Input enable in sleep mode
        constexpr uint32_t PDAC1_SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode
        constexpr uint32_t PDAC1_FUN_SEL = (2 << 17);  ///< DAC_1 function selection.
        constexpr uint32_t PDAC1_MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO
        constexpr uint32_t PDAC1_RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t PDAC1_RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t PDAC1_DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// PAD_DAC2 Register bits
    namespace pad_dac2_bits {
        constexpr uint32_t PDAC2_DAC = (8 << 3);  ///< Configure DAC_2 output when RTCIO_PDAC2_DAC_XPD_FORCE is set to 1.
        constexpr uint32_t PDAC2_XPD_DAC = (1U << 11);  ///< When RTCIO_PDAC2_DAC_XPD_FORCE is set to 1, 1: enable DAC_2 output. 0: disable DAC_2 output.
        constexpr uint32_t PDAC2_DAC_XPD_FORCE = (1U << 12);  ///< 1: use RTCIO_PDAC2_XPD_DAC to control DAC_2 output. 0: use SAR ADC FSM to control DAC_2 output.
        constexpr uint32_t PDAC2_FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t PDAC2_SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t PDAC2_SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t PDAC2_SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode.
        constexpr uint32_t PDAC2_FUN_SEL = (2 << 17);  ///< DAC_2 function selection.
        constexpr uint32_t PDAC2_MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t PDAC2_RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t PDAC2_RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t PDAC2_DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA: 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// RTC_PAD19 Register bits
    namespace rtc_pad19_bits {
        constexpr uint32_t FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode
        constexpr uint32_t FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// RTC_PAD20 Register bits
    namespace rtc_pad20_bits {
        constexpr uint32_t FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode.
        constexpr uint32_t FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// RTC_PAD21 Register bits
    namespace rtc_pad21_bits {
        constexpr uint32_t FUN_IE = (1U << 13);  ///< Input enable in normal execution.
        constexpr uint32_t SLP_OE = (1U << 14);  ///< Output enable in sleep mode.
        constexpr uint32_t SLP_IE = (1U << 15);  ///< Input enable in sleep mode.
        constexpr uint32_t SLP_SEL = (1U << 16);  ///< 1: enable sleep mode. 0: no sleep mode.
        constexpr uint32_t FUN_SEL = (2 << 17);  ///< Function selection.
        constexpr uint32_t MUX_SEL = (1U << 19);  ///< 1: use RTC GPIO. 0: use digital GPIO.
        constexpr uint32_t RUE = (1U << 27);  ///< Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
        constexpr uint32_t RDE = (1U << 28);  ///< Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
        constexpr uint32_t DRV = (2 << 29);  ///< Select the drive strength of the pad. 0: ~5 mA. 1: ~10 mA. 2: ~20 mA. 3: ~40 mA.
    }

    /// EXT_WAKEUP0 Register bits
    namespace ext_wakeup0_bits {
        constexpr uint32_t SEL = (5 << 27);  ///< GPIO[0-17] can be used to wake up the chip when the chip is in the sleep mode. This register prompts the pad source to wake up the chip when the latter is indeep/light sleep mode. 0: select GPIO0; 1: select GPIO2, etc
    }

    /// XTL_EXT_CTR Register bits
    namespace xtl_ext_ctr_bits {
        constexpr uint32_t SEL = (5 << 27);  ///< Select the external crystal power down enable source to get into sleep mode. 0: select GPIO0. 1: select GPIO1, etc. The input value on this pin XOR RTC_CNTL_EXT_XTL_CONF_REG[30] is the crystal power down enable signal.
    }

    /// SAR_I2C_IO Register bits
    namespace sar_i2c_io_bits {
        constexpr uint32_t SAR_DEBUG_BIT_SEL = (5 << 23);  ///< SAR_DEBUG_BIT_SEL
        constexpr uint32_t SAR_I2C_SCL_SEL = (2 << 28);  ///< Selects a pad the RTC I2C SCL signal connects to. 0: use TOUCH PAD0. 1: use TOUCH PAD2.
        constexpr uint32_t SAR_I2C_SDA_SEL = (2 << 30);  ///< Selects a pad the RTC I2C SDA signal connects to. 0: use TOUCH PAD1. 1: use TOUCH PAD3.
    }

    /// RTC_IO_TOUCH_CTRL Register bits
    namespace rtc_io_touch_ctrl_bits {
        constexpr uint32_t IO_TOUCH_BUFSEL = (4 << 0);  ///< IO_TOUCH_BUFSEL
        constexpr uint32_t IO_TOUCH_BUFMODE = (1U << 4);  ///< IO_TOUCH_BUFMODE
    }

    /// RTC_IO_DATE Register bits
    namespace rtc_io_date_bits {
        constexpr uint32_t IO_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// SENS Peripheral
// ============================================================================

namespace sens {
    /// Base addresses
    constexpr uint32_t SENS_BASE = 0x3F408800;

    /// SENS Register structure
    struct Registers {
        volatile uint32_t SAR_READER1_CTRL;  ///< Offset: 0x00 - RTC ADC1 data and sampling control
        volatile uint32_t SAR_READER1_STATUS;  ///< Offset: 0x04 - saradc1 status for debug
        volatile uint32_t SAR_MEAS1_CTRL1;  ///< Offset: 0x08 - Configure RTC ADC1 controller
        volatile uint32_t SAR_MEAS1_CTRL2;  ///< Offset: 0x0C - Control RTC ADC1 conversion and status
        volatile uint32_t SAR_MEAS1_MUX;  ///< Offset: 0x10 - Select the controller for SAR ADC1
        volatile uint32_t SAR_ATTEN1;  ///< Offset: 0x14 - Configure SAR ADC1 attenuation
        volatile uint32_t SAR_AMP_CTRL1;  ///< Offset: 0x18 - AMP control
        volatile uint32_t SAR_AMP_CTRL2;  ///< Offset: 0x1C - AMP control
        volatile uint32_t SAR_AMP_CTRL3;  ///< Offset: 0x20 - AMP control register
        volatile uint32_t SAR_READER2_CTRL;  ///< Offset: 0x24 - RTC ADC2 data and sampling control
        volatile uint32_t SAR_READER2_STATUS;  ///< Offset: 0x28 - saradc2 status for debug
        volatile uint32_t SAR_MEAS2_CTRL1;  ///< Offset: 0x2C - configure rtc saradc2
        volatile uint32_t SAR_MEAS2_CTRL2;  ///< Offset: 0x30 - Control RTC ADC2 conversion and status
        volatile uint32_t SAR_MEAS2_MUX;  ///< Offset: 0x34 - Select the controller for SAR ADC2
        volatile uint32_t SAR_ATTEN2;  ///< Offset: 0x38 - Configure SAR ADC2 attenuation
        volatile uint32_t SAR_POWER_XPD_SAR;  ///< Offset: 0x3C - configure saradc’s power by sw
        volatile uint32_t SAR_SLAVE_ADDR1;  ///< Offset: 0x40 - Configure slave addresses 0-1 of RTC I2C
        volatile uint32_t SAR_SLAVE_ADDR2;  ///< Offset: 0x44 - Configure slave addresses 2-3 of RTC I2C
        volatile uint32_t SAR_SLAVE_ADDR3;  ///< Offset: 0x48 - Configure slave addresses 4-5 of RTC I2C
        volatile uint32_t SAR_SLAVE_ADDR4;  ///< Offset: 0x4C - Configure slave addresses 6-7 of RTC I2C
        volatile uint32_t SAR_TSENS_CTRL;  ///< Offset: 0x50 - Temperature sensor data control
        volatile uint32_t SAR_TSENS_CTRL2;  ///< Offset: 0x54 - Temperature sensor control
        volatile uint32_t SAR_I2C_CTRL;  ///< Offset: 0x58 - Configure RTC I2C transmission
        volatile uint32_t SAR_TOUCH_CONF;  ///< Offset: 0x5C - Touch sensor configuration register
        volatile uint32_t SAR_TOUCH_THRES1;  ///< Offset: 0x60 - Finger threshold for touch pad 1
        volatile uint32_t SAR_TOUCH_THRES2;  ///< Offset: 0x64 - Finger threshold for touch pad 2
        volatile uint32_t SAR_TOUCH_THRES3;  ///< Offset: 0x68 - Finger threshold for touch pad 3
        volatile uint32_t SAR_TOUCH_THRES4;  ///< Offset: 0x6C - Finger threshold for touch pad 4
        volatile uint32_t SAR_TOUCH_THRES5;  ///< Offset: 0x70 - Finger threshold for touch pad 5
        volatile uint32_t SAR_TOUCH_THRES6;  ///< Offset: 0x74 - Finger threshold for touch pad 6
        volatile uint32_t SAR_TOUCH_THRES7;  ///< Offset: 0x78 - Finger threshold for touch pad 7
        volatile uint32_t SAR_TOUCH_THRES8;  ///< Offset: 0x7C - Finger threshold for touch pad 8
        volatile uint32_t SAR_TOUCH_THRES9;  ///< Offset: 0x80 - Finger threshold for touch pad 9
        volatile uint32_t SAR_TOUCH_THRES10;  ///< Offset: 0x84 - Finger threshold for touch pad 10
        volatile uint32_t SAR_TOUCH_THRES11;  ///< Offset: 0x88 - Finger threshold for touch pad 11
        volatile uint32_t SAR_TOUCH_THRES12;  ///< Offset: 0x8C - Finger threshold for touch pad 12
        volatile uint32_t SAR_TOUCH_THRES13;  ///< Offset: 0x90 - Finger threshold for touch pad 13
        volatile uint32_t SAR_TOUCH_THRES14;  ///< Offset: 0x94 - Finger threshold for touch pad 14
        volatile uint32_t SAR_TOUCH_CHN_ST;  ///< Offset: 0xD4 - Touch channel status register
        volatile uint32_t SAR_TOUCH_STATUS0;  ///< Offset: 0xD8 - Status of touch controller
        volatile uint32_t SAR_TOUCH_STATUS1;  ///< Offset: 0xDC - Touch pad 1 status
        volatile uint32_t SAR_TOUCH_STATUS2;  ///< Offset: 0xE0 - Touch pad 2 status
        volatile uint32_t SAR_TOUCH_STATUS3;  ///< Offset: 0xE4 - Touch pad 3 status
        volatile uint32_t SAR_TOUCH_STATUS4;  ///< Offset: 0xE8 - Touch pad 4 status
        volatile uint32_t SAR_TOUCH_STATUS5;  ///< Offset: 0xEC - Touch pad 5 status
        volatile uint32_t SAR_TOUCH_STATUS6;  ///< Offset: 0xF0 - Touch pad 6 status
        volatile uint32_t SAR_TOUCH_STATUS7;  ///< Offset: 0xF4 - Touch pad 7 status
        volatile uint32_t SAR_TOUCH_STATUS8;  ///< Offset: 0xF8 - Touch pad 8 status
        volatile uint32_t SAR_TOUCH_STATUS9;  ///< Offset: 0xFC - Touch pad 9 status
        volatile uint32_t SAR_TOUCH_STATUS10;  ///< Offset: 0x100 - Touch pad 10 status
        volatile uint32_t SAR_TOUCH_STATUS11;  ///< Offset: 0x104 - Touch pad 11 status
        volatile uint32_t SAR_TOUCH_STATUS12;  ///< Offset: 0x108 - Touch pad 12 status
        volatile uint32_t SAR_TOUCH_STATUS13;  ///< Offset: 0x10C - Touch pad 13 status
        volatile uint32_t SAR_TOUCH_STATUS14;  ///< Offset: 0x110 - Touch pad 14 status
        volatile uint32_t SAR_TOUCH_STATUS15;  ///< Offset: 0x114 - Touch sleep pad status
        volatile uint32_t SAR_TOUCH_STATUS16;  ///< Offset: 0x118 - Touch approach count status
        volatile uint32_t SAR_DAC_CTRL1;  ///< Offset: 0x11C - DAC control
        volatile uint32_t SAR_DAC_CTRL2;  ///< Offset: 0x120 - DAC output control
        volatile uint32_t SAR_COCPU_STATE;  ///< Offset: 0x124 - ULP-RISCV status
        volatile uint32_t SAR_COCPU_INT_RAW;  ///< Offset: 0x128 - Interrupt raw bit of ULP-RISCV
        volatile uint32_t SAR_COCPU_INT_ENA;  ///< Offset: 0x12C - Interrupt enable bit of ULP-RISCV
        volatile uint32_t SAR_COCPU_INT_ST;  ///< Offset: 0x130 - Interrupt status bit of ULP-RISCV
        volatile uint32_t SAR_COCPU_INT_CLR;  ///< Offset: 0x134 - Interrupt clear bit of ULP-RISCV
        volatile uint32_t SAR_COCPU_DEBUG;  ///< Offset: 0x138 - ULP-RISCV debug register
        volatile uint32_t SAR_HALL_CTRL;  ///< Offset: 0x13C - hall control
        volatile uint32_t SAR_NOUSE;  ///< Offset: 0x140 - sar nouse
        volatile uint32_t SAR_IO_MUX_CONF;  ///< Offset: 0x144 - Configure and reset IO MUX
        volatile uint32_t SARDATE;  ///< Offset: 0x148 - Version Control Register
    };

    /// Peripheral instances
    inline Registers* SENS = reinterpret_cast<Registers*>(SENS_BASE);

    // Bit definitions
    /// SAR_READER1_CTRL Register bits
    namespace sar_reader1_ctrl_bits {
        constexpr uint32_t SAR1_CLK_DIV = (8 << 0);  ///< Clock divider.
        constexpr uint32_t SAR1_CLK_GATED = (1U << 18);  ///< SAR1_CLK_GATED
        constexpr uint32_t SAR1_SAMPLE_NUM = (8 << 19);  ///< SAR1_SAMPLE_NUM
        constexpr uint32_t SAR1_DATA_INV = (1U << 28);  ///< Invert SAR ADC1 data.
        constexpr uint32_t SAR1_INT_EN = (1U << 29);  ///< Enable SAR ADC1 to send out interrupt.
    }

    /// SAR_READER1_STATUS Register bits
    namespace sar_reader1_status_bits {
        constexpr uint32_t SAR1_READER_STATUS = (32 << 0);  ///< SAR1_READER_STATUS
    }

    /// SAR_MEAS1_CTRL1 Register bits
    namespace sar_meas1_ctrl1_bits {
        constexpr uint32_t RTC_SARADC_RESET = (1U << 22);  ///< SAR ADC software reset.
        constexpr uint32_t RTC_SARADC_CLKGATE_EN = (1U << 23);  ///< Enable bit of SAR ADC clock gate.
        constexpr uint32_t FORCE_XPD_AMP = (2 << 24);  ///< FORCE_XPD_AMP
        constexpr uint32_t AMP_RST_FB_FORCE = (2 << 26);  ///< AMP_RST_FB_FORCE
        constexpr uint32_t AMP_SHORT_REF_FORCE = (2 << 28);  ///< AMP_SHORT_REF_FORCE
        constexpr uint32_t AMP_SHORT_REF_GND_FORCE = (2 << 30);  ///< AMP_SHORT_REF_GND_FORCE
    }

    /// SAR_MEAS1_CTRL2 Register bits
    namespace sar_meas1_ctrl2_bits {
        constexpr uint32_t MEAS1_DATA_SAR = (16 << 0);  ///< SAR ADC1 data
        constexpr uint32_t MEAS1_DONE_SAR = (1U << 16);  ///< Indicate SAR ADC1 conversion is done.
        constexpr uint32_t MEAS1_START_SAR = (1U << 17);  ///< SAR ADC1 controller (in RTC) starts conversion, active only when SENS_MEAS1_START_FORCE = 1.
        constexpr uint32_t MEAS1_START_FORCE = (1U << 18);  ///< 1: SAR ADC1 controller (in RTC) is started by software. 0: SAR ADC1 controller is started by ULP coprocessor.
        constexpr uint32_t SAR1_EN_PAD = (12 << 19);  ///< SAR ADC1 pad enable bitmap, active only when SENS_SAR1_EN_PAD_FORCE = 1.
        constexpr uint32_t SAR1_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC1 pad enable bitmap is controlled by software. 0: SAR ADC1 pad enable bitmap is controlled by ULP coprocessor.
    }

    /// SAR_MEAS1_MUX Register bits
    namespace sar_meas1_mux_bits {
        constexpr uint32_t SAR1_DIG_FORCE = (1U << 31);  ///< 1: SAR ADC1 controlled by DIG ADC1 CTRL
    }

    /// SAR_ATTEN1 Register bits
    namespace sar_atten1_bits {
        constexpr uint32_t SAR1_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad. [1:0] is used for channel 0, [3:2] is used for channel 1, etc.
    }

    /// SAR_AMP_CTRL1 Register bits
    namespace sar_amp_ctrl1_bits {
        constexpr uint32_t SAR_AMP_WAIT1 = (16 << 0);  ///< SAR_AMP_WAIT1
        constexpr uint32_t SAR_AMP_WAIT2 = (16 << 16);  ///< SAR_AMP_WAIT2
    }

    /// SAR_AMP_CTRL2 Register bits
    namespace sar_amp_ctrl2_bits {
        constexpr uint32_t SAR1_DAC_XPD_FSM_IDLE = (1U << 0);  ///< SAR1_DAC_XPD_FSM_IDLE
        constexpr uint32_t XPD_SAR_AMP_FSM_IDLE = (1U << 1);  ///< XPD_SAR_AMP_FSM_IDLE
        constexpr uint32_t AMP_RST_FB_FSM_IDLE = (1U << 2);  ///< AMP_RST_FB_FSM_IDLE
        constexpr uint32_t AMP_SHORT_REF_FSM_IDLE = (1U << 3);  ///< AMP_SHORT_REF_FSM_IDLE
        constexpr uint32_t AMP_SHORT_REF_GND_FSM_IDLE = (1U << 4);  ///< AMP_SHORT_REF_GND_FSM_IDLE
        constexpr uint32_t XPD_SAR_FSM_IDLE = (1U << 5);  ///< XPD_SAR_FSM_IDLE
        constexpr uint32_t SAR_RSTB_FSM_IDLE = (1U << 6);  ///< SAR_RSTB_FSM_IDLE
        constexpr uint32_t SAR_AMP_WAIT3 = (16 << 16);  ///< SAR_AMP_WAIT3
    }

    /// SAR_AMP_CTRL3 Register bits
    namespace sar_amp_ctrl3_bits {
        constexpr uint32_t SAR1_DAC_XPD_FSM = (4 << 0);  ///< Control of DAC. 4’b0010: disable DAC. 4’b0000: power up DAC by FSM. 4’b0011: power up DAC by software.
        constexpr uint32_t XPD_SAR_AMP_FSM = (4 << 4);  ///< XPD_SAR_AMP_FSM
        constexpr uint32_t AMP_RST_FB_FSM = (4 << 8);  ///< AMP_RST_FB_FSM
        constexpr uint32_t AMP_SHORT_REF_FSM = (4 << 12);  ///< AMP_SHORT_REF_FSM
        constexpr uint32_t AMP_SHORT_REF_GND_FSM = (4 << 16);  ///< AMP_SHORT_REF_GND_FSM
        constexpr uint32_t XPD_SAR_FSM = (4 << 20);  ///< XPD_SAR_FSM
        constexpr uint32_t SAR_RSTB_FSM = (4 << 24);  ///< SAR_RSTB_FSM
    }

    /// SAR_READER2_CTRL Register bits
    namespace sar_reader2_ctrl_bits {
        constexpr uint32_t SAR2_CLK_DIV = (8 << 0);  ///< clock divider
        constexpr uint32_t SAR2_WAIT_ARB_CYCLE = (2 << 16);  ///< wait arbit stable after sar_done
        constexpr uint32_t SAR2_CLK_GATED = (1U << 18);  ///< SAR2_CLK_GATED
        constexpr uint32_t SAR2_SAMPLE_NUM = (8 << 19);  ///< SAR2_SAMPLE_NUM
        constexpr uint32_t SAR2_DATA_INV = (1U << 29);  ///< Invert SAR ADC2 data
        constexpr uint32_t SAR2_INT_EN = (1U << 30);  ///< enable saradc2 to send out interrupt
    }

    /// SAR_READER2_STATUS Register bits
    namespace sar_reader2_status_bits {
        constexpr uint32_t SAR2_READER_STATUS = (32 << 0);  ///< SAR2_READER_STATUS
    }

    /// SAR_MEAS2_CTRL1 Register bits
    namespace sar_meas2_ctrl1_bits {
        constexpr uint32_t SAR2_CNTL_STATE = (3 << 0);  ///< saradc2_cntl_fsm
        constexpr uint32_t SAR2_PWDET_CAL_EN = (1U << 3);  ///< rtc control pwdet enable
        constexpr uint32_t SAR2_PKDET_CAL_EN = (1U << 4);  ///< rtc control pkdet enable
        constexpr uint32_t SAR2_EN_TEST = (1U << 5);  ///< SAR2_EN_TEST
        constexpr uint32_t SAR2_RSTB_FORCE = (2 << 6);  ///< SAR2_RSTB_FORCE
        constexpr uint32_t SAR2_STANDBY_WAIT = (8 << 8);  ///< SAR2_STANDBY_WAIT
        constexpr uint32_t SAR2_RSTB_WAIT = (8 << 16);  ///< SAR2_RSTB_WAIT
        constexpr uint32_t SAR2_XPD_WAIT = (8 << 24);  ///< SAR2_XPD_WAIT
    }

    /// SAR_MEAS2_CTRL2 Register bits
    namespace sar_meas2_ctrl2_bits {
        constexpr uint32_t MEAS2_DATA_SAR = (16 << 0);  ///< SAR ADC2 data.
        constexpr uint32_t MEAS2_DONE_SAR = (1U << 16);  ///< Indicate SAR ADC2 conversion is done.
        constexpr uint32_t MEAS2_START_SAR = (1U << 17);  ///< SAR ADC2 controller (in RTC) starts conversion, active only when SENS_MEAS2_START_FORCE = 1.
        constexpr uint32_t MEAS2_START_FORCE = (1U << 18);  ///< 1: SAR ADC2 controller (in RTC) is started by software. 0: SAR ADC2 controller is started by ULP coprocessor.
        constexpr uint32_t SAR2_EN_PAD = (12 << 19);  ///< SAR ADC2 pad enable bitmap, active only whenSENS_SAR2_EN_PAD_FORCE = 1.
        constexpr uint32_t SAR2_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC2 pad enable bitmap is controlled by software. 0: SAR ADC2 pad enable bitmap is controlled by ULP coprocessor.
    }

    /// SAR_MEAS2_MUX Register bits
    namespace sar_meas2_mux_bits {
        constexpr uint32_t SAR2_PWDET_CCT = (3 << 28);  ///< SAR2_PWDET_CCT, PA power detector capacitance tuning.
        constexpr uint32_t SAR2_RTC_FORCE = (1U << 31);  ///< In sleep, force to use RTC to control ADC.
    }

    /// SAR_ATTEN2 Register bits
    namespace sar_atten2_bits {
        constexpr uint32_t SAR2_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad. [1:0] is used for channel 0, [3:2] is used for channel 1, etc.
    }

    /// SAR_POWER_XPD_SAR Register bits
    namespace sar_power_xpd_sar_bits {
        constexpr uint32_t FORCE_XPD_SAR = (2 << 29);  ///< FORCE_XPD_SAR
        constexpr uint32_t SARCLK_EN = (1U << 31);  ///< SARCLK_EN
    }

    /// SAR_SLAVE_ADDR1 Register bits
    namespace sar_slave_addr1_bits {
        constexpr uint32_t I2C_SLAVE_ADDR1 = (11 << 0);  ///< RTC I2C slave address 1
        constexpr uint32_t I2C_SLAVE_ADDR0 = (11 << 11);  ///< RTC I2C slave address 0
        constexpr uint32_t MEAS_STATUS = (8 << 22);  ///< MEAS_STATUS
    }

    /// SAR_SLAVE_ADDR2 Register bits
    namespace sar_slave_addr2_bits {
        constexpr uint32_t I2C_SLAVE_ADDR3 = (11 << 0);  ///< RTC I2C slave address 3
        constexpr uint32_t I2C_SLAVE_ADDR2 = (11 << 11);  ///< RTC I2C slave address 2
    }

    /// SAR_SLAVE_ADDR3 Register bits
    namespace sar_slave_addr3_bits {
        constexpr uint32_t I2C_SLAVE_ADDR5 = (11 << 0);  ///< RTC I2C slave address 5
        constexpr uint32_t I2C_SLAVE_ADDR4 = (11 << 11);  ///< RTC I2C slave address 4
    }

    /// SAR_SLAVE_ADDR4 Register bits
    namespace sar_slave_addr4_bits {
        constexpr uint32_t I2C_SLAVE_ADDR7 = (11 << 0);  ///< RTC I2C slave address 7
        constexpr uint32_t I2C_SLAVE_ADDR6 = (11 << 11);  ///< RTC I2C slave address 6
    }

    /// SAR_TSENS_CTRL Register bits
    namespace sar_tsens_ctrl_bits {
        constexpr uint32_t TSENS_OUT = (8 << 0);  ///< Temperature sensor data out.
        constexpr uint32_t TSENS_READY = (1U << 8);  ///< Indicate temperature sensor out ready.
        constexpr uint32_t TSENS_INT_EN = (1U << 12);  ///< Enable temperature sensor to send out interrupt.
        constexpr uint32_t TSENS_IN_INV = (1U << 13);  ///< Invert temperature sensor data.
        constexpr uint32_t TSENS_CLK_DIV = (8 << 14);  ///< Temperature sensor clock divider.
        constexpr uint32_t TSENS_POWER_UP = (1U << 22);  ///< Temperature sensor power up.
        constexpr uint32_t TSENS_POWER_UP_FORCE = (1U << 23);  ///< 1: dump out and power up controlled by software. 0: by FSM.
        constexpr uint32_t TSENS_DUMP_OUT = (1U << 24);  ///< Temperature sensor dump out only active when SENS_TSENS_POWER_UP_FORCE = 1.
    }

    /// SAR_TSENS_CTRL2 Register bits
    namespace sar_tsens_ctrl2_bits {
        constexpr uint32_t TSENS_XPD_WAIT = (12 << 0);  ///< TSENS_XPD_WAIT
        constexpr uint32_t TSENS_XPD_FORCE = (2 << 12);  ///< TSENS_XPD_FORCE
        constexpr uint32_t TSENS_CLK_INV = (1U << 14);  ///< TSENS_CLK_INV
        constexpr uint32_t TSENS_CLKGATE_EN = (1U << 15);  ///< Enable temperature sensor clock.
        constexpr uint32_t TSENS_RESET = (1U << 16);  ///< Reset temperature sensor.
    }

    /// SAR_I2C_CTRL Register bits
    namespace sar_i2c_ctrl_bits {
        constexpr uint32_t SAR_I2C_CTRL = (28 << 0);  ///< RTC I2C control data. Active only when SENS_SAR_I2C_START_FORCE = 1.
        constexpr uint32_t SAR_I2C_START = (1U << 28);  ///< Start RTC I2C. Active only when SENS_SAR_I2C_START_FORCE = 1
        constexpr uint32_t SAR_I2C_START_FORCE = (1U << 29);  ///< 0: RTC I2C started by FSM. 1: RTC I2C started by software.
    }

    /// SAR_TOUCH_CONF Register bits
    namespace sar_touch_conf_bits {
        constexpr uint32_t TOUCH_OUTEN = (15 << 0);  ///< Enable touch controller output.
        constexpr uint32_t TOUCH_STATUS_CLR = (1U << 15);  ///< Clear all touch active status.
        constexpr uint32_t TOUCH_DATA_SEL = (2 << 16);  ///< 0 and 1: touch_raw_data; 2: base_line; 3: touch_smooth_data.
        constexpr uint32_t TOUCH_DENOISE_END = (1U << 18);  ///< Touch denoise done.
        constexpr uint32_t TOUCH_UNIT_END = (1U << 19);  ///< Indicate the completion of sampling.
        constexpr uint32_t TOUCH_APPROACH_PAD2 = (4 << 20);  ///< Indicate which pad is selected as proximity pad2
        constexpr uint32_t TOUCH_APPROACH_PAD1 = (4 << 24);  ///< Indicate which pad is selected as proximity pad1
        constexpr uint32_t TOUCH_APPROACH_PAD0 = (4 << 28);  ///< Indicate which pad is selected as proximity pad0
    }

    /// SAR_TOUCH_THRES1 Register bits
    namespace sar_touch_thres1_bits {
        constexpr uint32_t TOUCH_OUT_TH1 = (22 << 0);  ///< Finger threshold for touch pad 1
    }

    /// SAR_TOUCH_THRES2 Register bits
    namespace sar_touch_thres2_bits {
        constexpr uint32_t TOUCH_OUT_TH2 = (22 << 0);  ///< Finger threshold for touch pad 2
    }

    /// SAR_TOUCH_THRES3 Register bits
    namespace sar_touch_thres3_bits {
        constexpr uint32_t TOUCH_OUT_TH3 = (22 << 0);  ///< Finger threshold for touch pad 3
    }

    /// SAR_TOUCH_THRES4 Register bits
    namespace sar_touch_thres4_bits {
        constexpr uint32_t TOUCH_OUT_TH4 = (22 << 0);  ///< Finger threshold for touch pad 4
    }

    /// SAR_TOUCH_THRES5 Register bits
    namespace sar_touch_thres5_bits {
        constexpr uint32_t TOUCH_OUT_TH5 = (22 << 0);  ///< Finger threshold for touch pad 5
    }

    /// SAR_TOUCH_THRES6 Register bits
    namespace sar_touch_thres6_bits {
        constexpr uint32_t TOUCH_OUT_TH6 = (22 << 0);  ///< Finger threshold for touch pad 6
    }

    /// SAR_TOUCH_THRES7 Register bits
    namespace sar_touch_thres7_bits {
        constexpr uint32_t TOUCH_OUT_TH7 = (22 << 0);  ///< Finger threshold for touch pad 7
    }

    /// SAR_TOUCH_THRES8 Register bits
    namespace sar_touch_thres8_bits {
        constexpr uint32_t TOUCH_OUT_TH8 = (22 << 0);  ///< Finger threshold for touch pad 8
    }

    /// SAR_TOUCH_THRES9 Register bits
    namespace sar_touch_thres9_bits {
        constexpr uint32_t TOUCH_OUT_TH9 = (22 << 0);  ///< Finger threshold for touch pad 9
    }

    /// SAR_TOUCH_THRES10 Register bits
    namespace sar_touch_thres10_bits {
        constexpr uint32_t TOUCH_OUT_TH10 = (22 << 0);  ///< Finger threshold for touch pad 10
    }

    /// SAR_TOUCH_THRES11 Register bits
    namespace sar_touch_thres11_bits {
        constexpr uint32_t TOUCH_OUT_TH11 = (22 << 0);  ///< Finger threshold for touch pad 11
    }

    /// SAR_TOUCH_THRES12 Register bits
    namespace sar_touch_thres12_bits {
        constexpr uint32_t TOUCH_OUT_TH12 = (22 << 0);  ///< Finger threshold for touch pad 12
    }

    /// SAR_TOUCH_THRES13 Register bits
    namespace sar_touch_thres13_bits {
        constexpr uint32_t TOUCH_OUT_TH13 = (22 << 0);  ///< Finger threshold for touch pad 13
    }

    /// SAR_TOUCH_THRES14 Register bits
    namespace sar_touch_thres14_bits {
        constexpr uint32_t TOUCH_OUT_TH14 = (22 << 0);  ///< Finger threshold for touch pad 14
    }

    /// SAR_TOUCH_CHN_ST Register bits
    namespace sar_touch_chn_st_bits {
        constexpr uint32_t TOUCH_PAD_ACTIVE = (15 << 0);  ///< Touch active status
        constexpr uint32_t TOUCH_CHANNEL_CLR = (15 << 15);  ///< Clear touch channel
        constexpr uint32_t TOUCH_MEAS_DONE = (1U << 31);  ///< Signal flag that indicates one touch pad is done.
    }

    /// SAR_TOUCH_STATUS0 Register bits
    namespace sar_touch_status0_bits {
        constexpr uint32_t TOUCH_DENOISE_DATA = (22 << 0);  ///< Denoise measure value from touch sensor 0.
        constexpr uint32_t TOUCH_SCAN_CURR = (4 << 22);  ///< Current pad in scan status
    }

    /// SAR_TOUCH_STATUS1 Register bits
    namespace sar_touch_status1_bits {
        constexpr uint32_t TOUCH_PAD1_DATA = (22 << 0);  ///< The data of touch pad 1, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD1_DEBOUNCE = (3 << 29);  ///< Touch pad 1 debounce value.
    }

    /// SAR_TOUCH_STATUS2 Register bits
    namespace sar_touch_status2_bits {
        constexpr uint32_t TOUCH_PAD2_DATA = (22 << 0);  ///< The data of touch pad 2, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD2_DEBOUNCE = (3 << 29);  ///< Touch pad 2 debounce value.
    }

    /// SAR_TOUCH_STATUS3 Register bits
    namespace sar_touch_status3_bits {
        constexpr uint32_t TOUCH_PAD3_DATA = (22 << 0);  ///< The data of touch pad 3, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD3_DEBOUNCE = (3 << 29);  ///< Touch pad 3 debounce value.
    }

    /// SAR_TOUCH_STATUS4 Register bits
    namespace sar_touch_status4_bits {
        constexpr uint32_t TOUCH_PAD4_DATA = (22 << 0);  ///< The data of touch pad 4, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD4_DEBOUNCE = (3 << 29);  ///< Touch pad 4 debounce value.
    }

    /// SAR_TOUCH_STATUS5 Register bits
    namespace sar_touch_status5_bits {
        constexpr uint32_t TOUCH_PAD5_DATA = (22 << 0);  ///< The data of touch pad 5, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD5_DEBOUNCE = (3 << 29);  ///< Touch pad 5 debounce value.
    }

    /// SAR_TOUCH_STATUS6 Register bits
    namespace sar_touch_status6_bits {
        constexpr uint32_t TOUCH_PAD6_DATA = (22 << 0);  ///< The data of touch pad 6, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD6_DEBOUNCE = (3 << 29);  ///< Touch pad 6 debounce value.
    }

    /// SAR_TOUCH_STATUS7 Register bits
    namespace sar_touch_status7_bits {
        constexpr uint32_t TOUCH_PAD7_DATA = (22 << 0);  ///< The data of touch pad 7, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD7_DEBOUNCE = (3 << 29);  ///< Touch pad 7 debounce value.
    }

    /// SAR_TOUCH_STATUS8 Register bits
    namespace sar_touch_status8_bits {
        constexpr uint32_t TOUCH_PAD8_DATA = (22 << 0);  ///< The data of touch pad 8, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD8_DEBOUNCE = (3 << 29);  ///< Touch pad 8 debounce value.
    }

    /// SAR_TOUCH_STATUS9 Register bits
    namespace sar_touch_status9_bits {
        constexpr uint32_t TOUCH_PAD9_DATA = (22 << 0);  ///< The data of touch pad 9, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD9_DEBOUNCE = (3 << 29);  ///< Touch pad 9 debounce value.
    }

    /// SAR_TOUCH_STATUS10 Register bits
    namespace sar_touch_status10_bits {
        constexpr uint32_t TOUCH_PAD10_DATA = (22 << 0);  ///< The data of touch pad 10, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD10_DEBOUNCE = (3 << 29);  ///< Touch pad 10 debounce value.
    }

    /// SAR_TOUCH_STATUS11 Register bits
    namespace sar_touch_status11_bits {
        constexpr uint32_t TOUCH_PAD11_DATA = (22 << 0);  ///< The data of touch pad 11, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD11_DEBOUNCE = (3 << 29);  ///< Touch pad 11 debounce value.
    }

    /// SAR_TOUCH_STATUS12 Register bits
    namespace sar_touch_status12_bits {
        constexpr uint32_t TOUCH_PAD12_DATA = (22 << 0);  ///< The data of touch pad 12, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD12_DEBOUNCE = (3 << 29);  ///< Touch pad 12 debounce value.
    }

    /// SAR_TOUCH_STATUS13 Register bits
    namespace sar_touch_status13_bits {
        constexpr uint32_t TOUCH_PAD13_DATA = (22 << 0);  ///< The data of touch pad 13, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD13_DEBOUNCE = (3 << 29);  ///< Touch pad 13 debounce value.
    }

    /// SAR_TOUCH_STATUS14 Register bits
    namespace sar_touch_status14_bits {
        constexpr uint32_t TOUCH_PAD14_DATA = (22 << 0);  ///< The data of touch pad 14, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_PAD14_DEBOUNCE = (3 << 29);  ///< Touch pad 14 debounce value.
    }

    /// SAR_TOUCH_STATUS15 Register bits
    namespace sar_touch_status15_bits {
        constexpr uint32_t TOUCH_SLP_DATA = (22 << 0);  ///< The data of touch sleep pad, depending on the setting of SENS_TOUCH_DATA_SEL.
        constexpr uint32_t TOUCH_SLP_DEBOUNCE = (3 << 29);  ///< Touch sleep pad debouce value.
    }

    /// SAR_TOUCH_STATUS16 Register bits
    namespace sar_touch_status16_bits {
        constexpr uint32_t TOUCH_APPROACH_PAD2_CNT = (8 << 0);  ///< Count status of proximity pad 2.
        constexpr uint32_t TOUCH_APPROACH_PAD1_CNT = (8 << 8);  ///< Count status of proximity pad 1.
        constexpr uint32_t TOUCH_APPROACH_PAD0_CNT = (8 << 16);  ///< Count status of proximity pad 0.
        constexpr uint32_t TOUCH_SLP_APPROACH_CNT = (8 << 24);  ///< Count status of sleep pad in proximity mode.
    }

    /// SAR_DAC_CTRL1 Register bits
    namespace sar_dac_ctrl1_bits {
        constexpr uint32_t SW_FSTEP = (16 << 0);  ///< Frequency step for CW generator can be used to adjust the frequency.
        constexpr uint32_t SW_TONE_EN = (1U << 16);  ///< 0: disable CW generator. 1: enable CW generator.
        constexpr uint32_t DEBUG_BIT_SEL = (5 << 17);  ///< DEBUG_BIT_SEL
        constexpr uint32_t DAC_DIG_FORCE = (1U << 22);  ///< 0: DAC1 and DAC2 do not use DMA. 1: DAC1 and DAC2 use DMA.
        constexpr uint32_t DAC_CLK_FORCE_LOW = (1U << 23);  ///< 1: force PDAC_CLK to low
        constexpr uint32_t DAC_CLK_FORCE_HIGH = (1U << 24);  ///< 1: force PDAC_CLK to high
        constexpr uint32_t DAC_CLK_INV = (1U << 25);  ///< 1: invert PDAC_CLK.
        constexpr uint32_t DAC_RESET = (1U << 26);  ///< Reset DAC by software.
        constexpr uint32_t DAC_CLKGATE_EN = (1U << 27);  ///< DAC clock gate enable bit.
    }

    /// SAR_DAC_CTRL2 Register bits
    namespace sar_dac_ctrl2_bits {
        constexpr uint32_t DAC_DC1 = (8 << 0);  ///< DC offset for DAC1 CW generator.
        constexpr uint32_t DAC_DC2 = (8 << 8);  ///< DC offset for DAC2 CW generator.
        constexpr uint32_t DAC_SCALE1 = (2 << 16);  ///< DAC1 scaling. 00: no scale. 01: scale to 1/2. 10: scale to 1/4. 11: scale to 1/8.
        constexpr uint32_t DAC_SCALE2 = (2 << 18);  ///< DAC2 scaling. 00: no scale. 01: scale to 1/2. 10: scale to 1/4. 11: scale to 1/8.
        constexpr uint32_t DAC_INV1 = (2 << 20);  ///< Invert DAC1. 00: do not invert any bits. 01: invert all bits. 10: invert MSB. 11: invert all bits except MSB.
        constexpr uint32_t DAC_INV2 = (2 << 22);  ///< Invert DAC2. 00: do not invert any bits. 01: invert all bits. 10: invert MSB. 11: invert all bits except MSB.
        constexpr uint32_t DAC_CW_EN1 = (1U << 24);  ///< 1: select CW generator as source for PDAC1_DAC. 0: select register RT- CIO_PDAC1_DAC as source for PDAC1_DAC.
        constexpr uint32_t DAC_CW_EN2 = (1U << 25);  ///< 1: select CW generator as source for PDAC2_DAC. 0: select register RT- CIO_PDAC2_DAC as source for PDAC2_DAC.
    }

    /// SAR_COCPU_STATE Register bits
    namespace sar_cocpu_state_bits {
        constexpr uint32_t COCPU_DBG_TRIGGER = (1U << 25);  ///< Trigger ULP-RISCV debug registers
        constexpr uint32_t COCPU_CLK_EN = (1U << 26);  ///< Check ULP-RISCV whether clk on
        constexpr uint32_t COCPU_RESET_N = (1U << 27);  ///< Check ULP-RISCV whether in reset state
        constexpr uint32_t COCPU_EOI = (1U << 28);  ///< Check ULP-RISCV whether in interrupt state
        constexpr uint32_t COCPU_TRAP = (1U << 29);  ///< Check ULP-RISCV whether in trap state
        constexpr uint32_t COCPU_EBREAK = (1U << 30);  ///< Check ULP-RISCV whether in ebreak
    }

    /// SAR_COCPU_INT_RAW Register bits
    namespace sar_cocpu_int_raw_bits {
        constexpr uint32_t COCPU_TOUCH_DONE_INT_RAW = (1U << 0);  ///< TOUCH_DONE_INT interrupt raw bit
        constexpr uint32_t COCPU_TOUCH_INACTIVE_INT_RAW = (1U << 1);  ///< TOUCH_INACTIVE_INT interrupt raw bit
        constexpr uint32_t COCPU_TOUCH_ACTIVE_INT_RAW = (1U << 2);  ///< TOUCH_ACTIVE_INT interrupt raw bit
        constexpr uint32_t COCPU_SARADC1_INT_RAW = (1U << 3);  ///< SARADC1_DONE_INT interrupt raw bit
        constexpr uint32_t COCPU_SARADC2_INT_RAW = (1U << 4);  ///< SARADC2_DONE_INT interrupt raw bit
        constexpr uint32_t COCPU_TSENS_INT_RAW = (1U << 5);  ///< TSENS_DONE_INT interrupt raw bit
        constexpr uint32_t COCPU_START_INT_RAW = (1U << 6);  ///< RISCV_START_INT interrupt raw bit
        constexpr uint32_t COCPU_SW_INT_RAW = (1U << 7);  ///< SW_INT interrupt raw bit
        constexpr uint32_t COCPU_SWD_INT_RAW = (1U << 8);  ///< SWD_INT interrupt raw bit
    }

    /// SAR_COCPU_INT_ENA Register bits
    namespace sar_cocpu_int_ena_bits {
        constexpr uint32_t COCPU_TOUCH_DONE_INT_ENA = (1U << 0);  ///< TOUCH_DONE_INT interrupt enable bit
        constexpr uint32_t COCPU_TOUCH_INACTIVE_INT_ENA = (1U << 1);  ///< TOUCH_INACTIVE_INT interrupt enable bit
        constexpr uint32_t COCPU_TOUCH_ACTIVE_INT_ENA = (1U << 2);  ///< TOUCH_ACTIVE_INT interrupt enable bit
        constexpr uint32_t COCPU_SARADC1_INT_ENA = (1U << 3);  ///< SARADC1_DONE_INT interrupt enable bit
        constexpr uint32_t COCPU_SARADC2_INT_ENA = (1U << 4);  ///< SARADC2_DONE_INT interrupt enable bit
        constexpr uint32_t COCPU_TSENS_INT_ENA = (1U << 5);  ///< TSENS_DONE_INT interrupt enable bit
        constexpr uint32_t COCPU_START_INT_ENA = (1U << 6);  ///< RISCV_START_INT interrupt enable bit
        constexpr uint32_t COCPU_SW_INT_ENA = (1U << 7);  ///< SW_INT interrupt enable bit
        constexpr uint32_t COCPU_SWD_INT_ENA = (1U << 8);  ///< SWD_INT interrupt enable bit
    }

    /// SAR_COCPU_INT_ST Register bits
    namespace sar_cocpu_int_st_bits {
        constexpr uint32_t COCPU_TOUCH_DONE_INT_ST = (1U << 0);  ///< TOUCH_DONE_INT interrupt status bit
        constexpr uint32_t COCPU_TOUCH_INACTIVE_INT_ST = (1U << 1);  ///< TOUCH_INACTIVE_INT interrupt status bit
        constexpr uint32_t COCPU_TOUCH_ACTIVE_INT_ST = (1U << 2);  ///< TOUCH_ACTIVE_INT interrupt status bit
        constexpr uint32_t COCPU_SARADC1_INT_ST = (1U << 3);  ///< SARADC1_DONE_INT interrupt status bit
        constexpr uint32_t COCPU_SARADC2_INT_ST = (1U << 4);  ///< SARADC2_DONE_INT interrupt status bit
        constexpr uint32_t COCPU_TSENS_INT_ST = (1U << 5);  ///< TSENS_DONE_INT interrupt status bit
        constexpr uint32_t COCPU_START_INT_ST = (1U << 6);  ///< RISCV_START_INT interrupt status bit
        constexpr uint32_t COCPU_SW_INT_ST = (1U << 7);  ///< SW_INT interrupt status bit
        constexpr uint32_t COCPU_SWD_INT_ST = (1U << 8);  ///< SWD_INT interrupt status bit
    }

    /// SAR_COCPU_INT_CLR Register bits
    namespace sar_cocpu_int_clr_bits {
        constexpr uint32_t COCPU_TOUCH_DONE_INT_CLR = (1U << 0);  ///< TOUCH_DONE_INT interrupt clear bit
        constexpr uint32_t COCPU_TOUCH_INACTIVE_INT_CLR = (1U << 1);  ///< TOUCH_INACTIVE_INT interrupt clear bit
        constexpr uint32_t COCPU_TOUCH_ACTIVE_INT_CLR = (1U << 2);  ///< TOUCH_ACTIVE_INT interrupt clear bit
        constexpr uint32_t COCPU_SARADC1_INT_CLR = (1U << 3);  ///< SARADC1_DONE_INT interrupt clear bit
        constexpr uint32_t COCPU_SARADC2_INT_CLR = (1U << 4);  ///< SARADC2_DONE_INT interrupt clear bit
        constexpr uint32_t COCPU_TSENS_INT_CLR = (1U << 5);  ///< TSENS_DONE_INT interrupt clear bit
        constexpr uint32_t COCPU_START_INT_CLR = (1U << 6);  ///< RISCV_START_INT interrupt clear bit
        constexpr uint32_t COCPU_SW_INT_CLR = (1U << 7);  ///< SW_INT interrupt clear bit
        constexpr uint32_t COCPU_SWD_INT_CLR = (1U << 8);  ///< SWD_INT interrupt clear bit
    }

    /// SAR_COCPU_DEBUG Register bits
    namespace sar_cocpu_debug_bits {
        constexpr uint32_t COCPU_PC = (13 << 0);  ///< ULP-RISCV Program counter
        constexpr uint32_t COCPU_MEM_VLD = (1U << 13);  ///< ULP-RISCV memory valid output
        constexpr uint32_t COCPU_MEM_RDY = (1U << 14);  ///< ULP-RISCV memory ready input
        constexpr uint32_t COCPU_MEM_WEN = (4 << 15);  ///< ULP-RISCV memory write enable output
        constexpr uint32_t COCPU_MEM_ADDR = (13 << 19);  ///< ULP-RISCV memory address output
    }

    /// SAR_HALL_CTRL Register bits
    namespace sar_hall_ctrl_bits {
        constexpr uint32_t XPD_HALL = (1U << 28);  ///< Power on hall sensor and connect to VP and VN
        constexpr uint32_t XPD_HALL_FORCE = (1U << 29);  ///< 1: XPD HALL is controlled by SW. 0: XPD HALL is controlled by FSM in ULP-coprocessor
        constexpr uint32_t HALL_PHASE = (1U << 30);  ///< Reverse phase of hall sensor
        constexpr uint32_t HALL_PHASE_FORCE = (1U << 31);  ///< 1: HALL PHASE is controlled by SW 0: HALL PHASE is controlled by FSM in ULP-coprocessor
    }

    /// SAR_NOUSE Register bits
    namespace sar_nouse_bits {
        constexpr uint32_t SAR_NOUSE = (32 << 0);  ///< sar nouse
    }

    /// SAR_IO_MUX_CONF Register bits
    namespace sar_io_mux_conf_bits {
        constexpr uint32_t IOMUX_RESET = (1U << 30);  ///< Reset IO MUX by software
        constexpr uint32_t IOMUX_CLK_GATE_EN = (1U << 31);  ///< IO MUX clock gate enable bit
    }

    /// SARDATE Register bits
    namespace sardate_bits {
        constexpr uint32_t SAR_DATE = (28 << 0);  ///< Version Control Register
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x3F403000;
    constexpr uint32_t SPI1_BASE = 0x3F402000;
    constexpr uint32_t SPI2_BASE = 0x3F424000;
    constexpr uint32_t SPI3_BASE = 0x3F425000;
    constexpr uint32_t SPI4_BASE = 0x3F437000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CMD;  ///< Offset: 0x00 - Command control register
        volatile uint32_t ADDR;  ///< Offset: 0x04 - Address value
        volatile uint32_t CTRL;  ///< Offset: 0x08 - SPI control register
        volatile uint32_t CTRL1;  ///< Offset: 0x0C - SPI control register 1
        volatile uint32_t CTRL2;  ///< Offset: 0x10 - SPI control register 2
        volatile uint32_t CLOCK;  ///< Offset: 0x14 - SPI clock control register
        volatile uint32_t USER;  ///< Offset: 0x18 - SPI USER control register
        volatile uint32_t USER1;  ///< Offset: 0x1C - SPI USER control register 1
        volatile uint32_t USER2;  ///< Offset: 0x20 - SPI USER control register 2
        volatile uint32_t MOSI_DLEN;  ///< Offset: 0x24 - MOSI length
        volatile uint32_t MISO_DLEN;  ///< Offset: 0x28 - MISO length
        volatile uint32_t MISC;  ///< Offset: 0x2C - SPI misc register
        volatile uint32_t SLAVE;  ///< Offset: 0x30 - SPI slave control register
        volatile uint32_t SLAVE1;  ///< Offset: 0x34 - SPI slave control register 1
        volatile uint32_t SLV_WRBUF_DLEN;  ///< Offset: 0x38 - SPI slave Wr_BUF interrupt and CONF control register
        volatile uint32_t SLV_RDBUF_DLEN;  ///< Offset: 0x3C - SPI magic error and slave control register
        volatile uint32_t SLV_RD_BYTE;  ///< Offset: 0x40 - SPI interrupt control register
        volatile uint32_t FSM;  ///< Offset: 0x44 - SPI master status and DMA read byte control register
        volatile uint32_t HOLD;  ///< Offset: 0x48 - SPI hold register
        volatile uint32_t DMA_CONF;  ///< Offset: 0x4C - SPI DMA control register
        volatile uint32_t DMA_OUT_LINK;  ///< Offset: 0x50 - SPI DMA TX link configuration
        volatile uint32_t DMA_IN_LINK;  ///< Offset: 0x54 - SPI DMA RX link configuration
        volatile uint32_t DMA_INT_ENA;  ///< Offset: 0x58 - SPI DMA interrupt enable register
        volatile uint32_t DMA_INT_RAW;  ///< Offset: 0x5C - SPI DMA interrupt raw register
        volatile uint32_t DMA_INT_ST;  ///< Offset: 0x60 - SPI DMA interrupt status register
        volatile uint32_t DMA_INT_CLR;  ///< Offset: 0x64 - SPI DMA interrupt clear register
        volatile uint32_t IN_ERR_EOF_DES_ADDR;  ///< Offset: 0x68 - The latest SPI DMA RX descriptor address receiving error
        volatile uint32_t IN_SUC_EOF_DES_ADDR;  ///< Offset: 0x6C - The latest SPI DMA eof RX descriptor address
        volatile uint32_t INLINK_DSCR;  ///< Offset: 0x70 - Current SPI DMA RX descriptor pointer
        volatile uint32_t INLINK_DSCR_BF0;  ///< Offset: 0x74 - Next SPI DMA RX descriptor pointer
        volatile uint32_t INLINK_DSCR_BF1;  ///< Offset: 0x78 - Current SPI DMA RX buffer pointer
        volatile uint32_t OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x7C - The latest SPI DMA eof TX buffer address
        volatile uint32_t OUT_EOF_DES_ADDR;  ///< Offset: 0x80 - The latest SPI DMA eof TX descriptor address
        volatile uint32_t OUTLINK_DSCR;  ///< Offset: 0x84 - Current SPI DMA TX descriptor pointer
        volatile uint32_t OUTLINK_DSCR_BF0;  ///< Offset: 0x88 - Next SPI DMA TX descriptor pointer
        volatile uint32_t OUTLINK_DSCR_BF1;  ///< Offset: 0x8C - Current SPI DMA TX buffer pointer
        volatile uint32_t DMA_OUTSTATUS;  ///< Offset: 0x90 - SPI DMA TX status
        volatile uint32_t DMA_INSTATUS;  ///< Offset: 0x94 - SPI DMA RX status
        volatile uint32_t W0;  ///< Offset: 0x98 - Data buffer 0
        volatile uint32_t W1;  ///< Offset: 0x9C - Data buffer 1
        volatile uint32_t W2;  ///< Offset: 0xA0 - Data buffer 2
        volatile uint32_t W3;  ///< Offset: 0xA4 - Data buffer 3
        volatile uint32_t W4;  ///< Offset: 0xA8 - Data buffer 4
        volatile uint32_t W5;  ///< Offset: 0xAC - Data buffer 5
        volatile uint32_t W6;  ///< Offset: 0xB0 - Data buffer 6
        volatile uint32_t W7;  ///< Offset: 0xB4 - Data buffer 7
        volatile uint32_t W8;  ///< Offset: 0xB8 - Data buffer 8
        volatile uint32_t W9;  ///< Offset: 0xBC - Data buffer 9
        volatile uint32_t W10;  ///< Offset: 0xC0 - Data buffer 10
        volatile uint32_t W11;  ///< Offset: 0xC4 - Data buffer 11
        volatile uint32_t W12;  ///< Offset: 0xC8 - Data buffer 12
        volatile uint32_t W13;  ///< Offset: 0xCC - Data buffer 13
        volatile uint32_t W14;  ///< Offset: 0xD0 - Data buffer 14
        volatile uint32_t W15;  ///< Offset: 0xD4 - Data buffer 15
        volatile uint32_t W16;  ///< Offset: 0xD8 - Data buffer 16
        volatile uint32_t W17;  ///< Offset: 0xDC - Data buffer 17
        volatile uint32_t DIN_MODE;  ///< Offset: 0xE0 - SPI input delay mode configuration
        volatile uint32_t DIN_NUM;  ///< Offset: 0xE4 - SPI input delay number configuration
        volatile uint32_t DOUT_MODE;  ///< Offset: 0xE8 - SPI output delay mode configuration
        volatile uint32_t DOUT_NUM;  ///< Offset: 0xEC - SPI output delay number configuration
        volatile uint32_t LCD_CTRL;  ///< Offset: 0xF0 - LCD frame control register
        volatile uint32_t LCD_CTRL1;  ///< Offset: 0xF4 - LCD frame control1 register
        volatile uint32_t LCD_CTRL2;  ///< Offset: 0xF8 - LCD frame control2 register
        volatile uint32_t LCD_D_MODE;  ///< Offset: 0xFC - LCD delay number
        volatile uint32_t LCD_D_NUM;  ///< Offset: 0x100 - LCD delay mode
        volatile uint32_t REG_DATE;  ///< Offset: 0x3FC - SPI version control
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SPI4 = reinterpret_cast<Registers*>(SPI4_BASE);

    // Bit definitions
    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t CONF_BITLEN = (23 << 0);  ///< Define the spi_clk cycles of SPI_CONF state. Can be configured in CONF state.
        constexpr uint32_t USR = (1U << 24);  ///< User define command enable. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable. Can not be changed by CONF_buf.
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t USR_ADDR_VALUE = (32 << 0);  ///< [31:8]:address to slave, [7:0]:Reserved. Can be configured in CONF state.
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EXT_HOLD_EN = (1U << 2);  ///< Set the bit to hold spi. The bit is combined with SPI_USR_PREP_HOLD,SPI_USR_CMD_HOLD,SPI_USR_ADDR_HOLD,SPI_USR_DUMMY_HOLD,SPI_USR_DIN_HOLD,SPI_USR_DOUT_HOLD and SPI_USR_HOLD_POL. Can be configured in CONF state.
        constexpr uint32_t DUMMY_OUT = (1U << 3);  ///< In the dummy phase the signal level of spi is output by the spi controller. Can be configured in CONF state.
        constexpr uint32_t FADDR_DUAL = (1U << 5);  ///< Apply 2-bit mode during addr phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FADDR_QUAD = (1U << 6);  ///< Apply 4-bit mode during addr phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FADDR_OCT = (1U << 7);  ///< Apply 8-bit mode during addr phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FCMD_DUAL = (1U << 8);  ///< Apply 2-bit mode during command phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FCMD_QUAD = (1U << 9);  ///< Apply 4-bit mode during command phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FCMD_OCT = (1U << 10);  ///< Apply 8-bit mode during command phase 1:enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FREAD_DUAL = (1U << 14);  ///< In the read operations, read-data phase is in 2-bit mode. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FREAD_QUAD = (1U << 15);  ///< In the read operations read-data phase is in 4-bit mode. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t FREAD_OCT = (1U << 16);  ///< In the read operations read-data phase is in 8-bit mode. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low. Can be configured in CONF state.
        constexpr uint32_t D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low. Can be configured in CONF state.
        constexpr uint32_t WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low. Can be configured in CONF state.
        constexpr uint32_t RD_BIT_ORDER = (1U << 25);  ///< In read-data (MISO) phase 1: LSB first 0: MSB first. Can be configured in CONF state.
        constexpr uint32_t WR_BIT_ORDER = (1U << 26);  ///< In command address write-data (MOSI) phases 1: LSB firs 0: MSB first. Can be configured in CONF state.
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t CLK_MODE = (2 << 0);  ///< SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on. Can be configured in CONF state.
        constexpr uint32_t CLK_MODE_13 = (1U << 2);  ///< {CPOL, CPHA},1: support spi clk mode 1 and 3, first edge output data B[0]/B[7]. 0: support spi clk mode 0 and 2, first edge output data B[1]/B[6].
        constexpr uint32_t RSCK_DATA_OUT = (1U << 3);  ///< It saves half a cycle when tsck is the same as rsck. 1: output data at rsck posedge 0: output data at tsck posedge
        constexpr uint32_t W16_17_WR_ENA = (1U << 4);  ///< 1:SPI_BUF16~SPI_BUF17 can be written 0:SPI_BUF16~SPI_BUF17 can not be written. Can be configured in CONF state.
        constexpr uint32_t CS_HOLD_DELAY = (6 << 14);  ///< SPI cs signal is delayed by spi clock cycles. Can be configured in CONF state.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CS_SETUP_TIME = (13 << 0);  ///< (cycles+1) of prepare phase by spi clock this bits are combined with SPI_CS_SETUP bit. Can be configured in CONF state.
        constexpr uint32_t CS_HOLD_TIME = (13 << 13);  ///< delay cycles of cs pin by spi clock this bits are combined with SPI_CS_HOLD bit. Can be configured in CONF state.
        constexpr uint32_t CS_DELAY_MODE = (3 << 26);  ///< spi_cs signal is delayed by spi_clk . 0: zero 1: if SPI_CK_OUT_EDGE or SPI_CK_IDLE_EDGE is set 1 delayed by half cycle else delayed by one cycle 2: if SPI_CK_OUT_EDGE or SPI_CK_IDLE_EDGE is set 1 delayed by one cycle, else delayed by half cycle 3: delayed one cycle. Can be configured in CONF state.
        constexpr uint32_t CS_DELAY_NUM = (2 << 29);  ///< spi_cs signal is delayed by system clock cycles. Can be configured in CONF state.
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLKCNT_L = (6 << 0);  ///< In the master mode it must be equal to SPI_CLKCNT_N. In the slave mode it must be 0. Can be configured in CONF state.
        constexpr uint32_t CLKCNT_H = (6 << 6);  ///< In the master mode it must be floor((SPI_CLKCNT_N+1)/2-1). In the slave mode it must be 0. Can be configured in CONF state.
        constexpr uint32_t CLKCNT_N = (6 << 12);  ///< In the master mode it is the divider of spi_clk. So spi_clk frequency is system/(SPI_CLKDIV_PRE+1)/(SPI_CLKCNT_N+1). Can be configured in CONF state.
        constexpr uint32_t CLKDIV_PRE = (13 << 18);  ///< In the master mode it is pre-divider of spi_clk. Can be configured in CONF state.
        constexpr uint32_t CLK_EQU_SYSCLK = (1U << 31);  ///< In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from system clock. Can be configured in CONF state.
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t DOUTDIN = (1U << 0);  ///< Set the bit to enable full duplex communication. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t QPI_MODE = (1U << 3);  ///< Both for master mode and slave mode. 1: spi controller is in QPI mode. 0: others. Can be configured in CONF state.
        constexpr uint32_t OPI_MODE = (1U << 4);  ///< Just for master mode. 1: spi controller is in OPI mode (all in 8-bit mode). 0: others. Can be configured in CONF state.
        constexpr uint32_t TSCK_I_EDGE = (1U << 5);  ///< In the slave mode, this bit can be used to change the polarity of tsck. 0: tsck = spi_ck_i. 1:tsck = !spi_ck_i.
        constexpr uint32_t CS_HOLD = (1U << 6);  ///< spi cs keep low when spi is in done phase. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t CS_SETUP = (1U << 7);  ///< spi cs is enable when spi is in prepare phase. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t RSCK_I_EDGE = (1U << 8);  ///< In the slave mode, this bit can be used to change the polarity of rsck. 0: rsck = !spi_ck_i. 1:rsck = spi_ck_i.
        constexpr uint32_t CK_OUT_EDGE = (1U << 9);  ///< the bit combined with SPI_DOUT_MODE register to set mosi signal delay mode. Can be configured in CONF state.
        constexpr uint32_t RD_BYTE_ORDER = (1U << 10);  ///< In read-data (MISO) phase 1: big-endian 0: little_endian. Can be configured in CONF state.
        constexpr uint32_t WR_BYTE_ORDER = (1U << 11);  ///< In command address write-data (MOSI) phases 1: big-endian 0: litte_endian. Can be configured in CONF state.
        constexpr uint32_t FWRITE_DUAL = (1U << 12);  ///< In the write operations read-data phase is in 2-bit mode. Can be configured in CONF state.
        constexpr uint32_t FWRITE_QUAD = (1U << 13);  ///< In the write operations read-data phase is in 4-bit mode. Can be configured in CONF state.
        constexpr uint32_t FWRITE_OCT = (1U << 14);  ///< In the write operations read-data phase is in 8-bit mode. Can be configured in CONF state.
        constexpr uint32_t USR_CONF_NXT = (1U << 15);  ///< 1: Enable the DMA CONF phase of next seg-trans operation, which means seg-trans will continue. 0: The seg-trans will end after the current SPI seg-trans or this is not seg-trans mode. Can be configured in CONF state.
        constexpr uint32_t SIO = (1U << 16);  ///< Set the bit to enable 3-line half duplex communication mosi and miso signals share the same pin. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t USR_HOLD_POL = (1U << 17);  ///< It is combined with hold bits to set the polarity of spi hold line 1: spi will be held when spi hold line is high 0: spi will be held when spi hold line is low. Can be configured in CONF state.
        constexpr uint32_t USR_DOUT_HOLD = (1U << 18);  ///< spi is hold at data out state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_DIN_HOLD = (1U << 19);  ///< spi is hold at data in state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_DUMMY_HOLD = (1U << 20);  ///< spi is hold at dummy state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_ADDR_HOLD = (1U << 21);  ///< spi is hold at address state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_CMD_HOLD = (1U << 22);  ///< spi is hold at command state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_PREP_HOLD = (1U << 23);  ///< spi is hold at prepare state the bit are combined with SPI_USR_HOLD_POL bit. Can be configured in CONF state.
        constexpr uint32_t USR_MISO_HIGHPART = (1U << 24);  ///< read-data phase only access to high-part of the buffer SPI_BUF8~SPI_BUF17. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t USR_MOSI_HIGHPART = (1U << 25);  ///< write-data phase only access to high-part of the buffer SPI_BUF8~SPI_BUF17. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t USR_DUMMY_IDLE = (1U << 26);  ///< spi clock is disable in dummy phase when the bit is enable. Can be configured in CONF state.
        constexpr uint32_t USR_MOSI = (1U << 27);  ///< This bit enable the write-data phase of an operation. Can be configured in CONF state.
        constexpr uint32_t USR_MISO = (1U << 28);  ///< This bit enable the read-data phase of an operation. Can be configured in CONF state.
        constexpr uint32_t USR_DUMMY = (1U << 29);  ///< This bit enable the dummy phase of an operation. Can be configured in CONF state.
        constexpr uint32_t USR_ADDR = (1U << 30);  ///< This bit enable the address phase of an operation. Can be configured in CONF state.
        constexpr uint32_t USR_COMMAND = (1U << 31);  ///< This bit enable the command phase of an operation. Can be configured in CONF state.
    }

    /// USER1 Register bits
    namespace user1_bits {
        constexpr uint32_t USR_DUMMY_CYCLELEN = (8 << 0);  ///< The length in spi_clk cycles of dummy phase. The register value shall be (cycle_num-1). Can be configured in CONF state.
        constexpr uint32_t USR_ADDR_BITLEN = (5 << 27);  ///< The length in bits of address phase. The register value shall be (bit_num-1). Can be configured in CONF state.
    }

    /// USER2 Register bits
    namespace user2_bits {
        constexpr uint32_t USR_COMMAND_VALUE = (16 << 0);  ///< The value of command. Can be configured in CONF state.
        constexpr uint32_t USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of command phase. The register value shall be (bit_num-1). Can be configured in CONF state.
    }

    /// MOSI_DLEN Register bits
    namespace mosi_dlen_bits {
        constexpr uint32_t USR_MOSI_DBITLEN = (23 << 0);  ///< The length in bits of write-data. The register value shall be (bit_num-1). Can be configured in CONF state.
    }

    /// MISO_DLEN Register bits
    namespace miso_dlen_bits {
        constexpr uint32_t USR_MISO_DBITLEN = (23 << 0);  ///< The length in bits of read-data. The register value shall be (bit_num-1). Can be configured in CONF state.
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t CS0_DIS = (1U << 0);  ///< SPI CS0 pin enable, 1: disable CS0, 0: SPI_CS0 signal is from/to CS0 pin. Can be configured in CONF state.
        constexpr uint32_t CS1_DIS = (1U << 1);  ///< SPI CS1 pin enable, 1: disable CS1, 0: SPI_CS1 signal is from/to CS1 pin. Can be configured in CONF state.
        constexpr uint32_t CS2_DIS = (1U << 2);  ///< SPI CS2 pin enable, 1: disable CS2, 0: SPI_CS2 signal is from/to CS2 pin. Can be configured in CONF state.
        constexpr uint32_t CS3_DIS = (1U << 3);  ///< SPI CS3 pin enable, 1: disable CS3, 0: SPI_CS3 signal is from/to CS3 pin. Can be configured in CONF state.
        constexpr uint32_t CS4_DIS = (1U << 4);  ///< SPI CS4 pin enable, 1: disable CS4, 0: SPI_CS4 signal is from/to CS4 pin. Can be configured in CONF state.
        constexpr uint32_t CS5_DIS = (1U << 5);  ///< SPI CS5 pin enable, 1: disable CS5, 0: SPI_CS5 signal is from/to CS5 pin. Can be configured in CONF state.
        constexpr uint32_t CK_DIS = (1U << 6);  ///< 1: spi clk out disable, 0: spi clk out enable. Can be configured in CONF state.
        constexpr uint32_t MASTER_CS_POL = (6 << 7);  ///< In the master mode the bits are the polarity of spi cs line, the value is equivalent to spi_cs ^ SPI_MASTER_CS_POL. Can be configured in CONF state.
        constexpr uint32_t CLK_DATA_DTR_EN = (1U << 16);  ///< 1: SPI master DTR mode is applied to SPI clk, data and spi_dqs. 0: SPI master DTR mode is only applied to spi_dqs. This bit should be used with bit 17/18/19.
        constexpr uint32_t DATA_DTR_EN = (1U << 17);  ///< 1: SPI clk and data of SPI_DOUT and SPI_DIN state are in DTR mode, including master 1/2/4/8-bm. 0: SPI clk and data of SPI_DOUT and SPI_DIN state are in STR mode. Can be configured in CONF state.
        constexpr uint32_t ADDR_DTR_EN = (1U << 18);  ///< 1: SPI clk and data of SPI_SEND_ADDR state are in DTR mode, including master 1/2/4/8-bm. 0: SPI clk and data of SPI_SEND_ADDR state are in STR mode. Can be configured in CONF state.
        constexpr uint32_t CMD_DTR_EN = (1U << 19);  ///< 1: SPI clk and data of SPI_SEND_CMD state are in DTR mode, including master 1/2/4/8-bm. 0: SPI clk and data of SPI_SEND_CMD state are in STR mode. Can be configured in CONF state.
        constexpr uint32_t CD_DATA_SET = (1U << 20);  ///< 1: spi_cd = !SPI_CD_IDLE_EDGE when SPI_ST[3:0] is in SPI_DOUT or SPI_DIN state. 0: spi_cd = SPI_CD_IDLE_EDGE. Can be configured in CONF state.
        constexpr uint32_t CD_DUMMY_SET = (1U << 21);  ///< 1: spi_cd = !SPI_CD_IDLE_EDGE when SPI_ST[3:0] is in SPI_DUMMY state. 0: spi_cd = SPI_CD_IDLE_EDGE. Can be configured in CONF state.
        constexpr uint32_t CD_ADDR_SET = (1U << 22);  ///< 1: spi_cd = !SPI_CD_IDLE_EDGE when SPI_ST[3:0] is in SPI_SEND_ADDR state. 0: spi_cd = SPI_CD_IDLE_EDGE. Can be configured in CONF state.
        constexpr uint32_t SLAVE_CS_POL = (1U << 23);  ///< spi slave input cs polarity select. 1: inv 0: not change. Can be configured in CONF state.
        constexpr uint32_t DQS_IDLE_EDGE = (1U << 24);  ///< The default value of spi_dqs. Can be configured in CONF state.
        constexpr uint32_t CD_CMD_SET = (1U << 25);  ///< 1: spi_cd = !SPI_CD_IDLE_EDGE when SPI_ST[3:0] is in SPI_SEND_CMD state. 0: spi_cd = SPI_CD_IDLE_EDGE. Can be configured in CONF state.
        constexpr uint32_t CD_IDLE_EDGE = (1U << 26);  ///< The default value of spi_cd. Can be configured in CONF state.
        constexpr uint32_t CK_IDLE_EDGE = (1U << 29);  ///< 1: spi clk line is high when idle 0: spi clk line is low when idle. Can be configured in CONF state.
        constexpr uint32_t CS_KEEP_ACTIVE = (1U << 30);  ///< spi cs line keep low when the bit is set. Can be configured in CONF state.
        constexpr uint32_t QUAD_DIN_PIN_SWAP = (1U << 31);  ///< 1: spi quad input swap enable 0: spi quad input swap disable. Can be configured in CONF state.
    }

    /// SLAVE Register bits
    namespace slave_bits {
        constexpr uint32_t TRANS_DONE = (1U << 4);  ///< The interrupt raw bit for the completion of any operation in both the master mode and the slave mode. Can not be changed by CONF_buf.
        constexpr uint32_t INT_RD_BUF_DONE_EN = (1U << 5);  ///< SPI_SLV_RD_BUF_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t INT_WR_BUF_DONE_EN = (1U << 6);  ///< SPI_SLV_WR_BUF_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t INT_RD_DMA_DONE_EN = (1U << 7);  ///< SPI_SLV_RD_DMA_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t INT_WR_DMA_DONE_EN = (1U << 8);  ///< SPI_SLV_WR_DMA_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t INT_TRANS_DONE_EN = (1U << 9);  ///< SPI_TRANS_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t INT_DMA_SEG_TRANS_EN = (1U << 10);  ///< SPI_DMA_SEG_TRANS_DONE Interrupt enable. 1: enable 0: disable. Can be configured in CONF state.
        constexpr uint32_t SEG_MAGIC_ERR_INT_EN = (1U << 11);  ///< 1: Enable seg magic value error interrupt. 0: Others. Can be configured in CONF state.
        constexpr uint32_t TRANS_CNT = (4 << 23);  ///< The operations counter in both the master mode and the slave mode.
        constexpr uint32_t TRANS_DONE_AUTO_CLR_EN = (1U << 29);  ///< SPI_TRANS_DONE auto clear enable, clear it 3 apb cycles after the pos edge of SPI_TRANS_DONE. 0:disable. 1: enable. Can be configured in CONF state.
        constexpr uint32_t MODE = (1U << 30);  ///< Set SPI work mode. 1: slave mode 0: master mode.
        constexpr uint32_t SOFT_RESET = (1U << 31);  ///< Software reset enable, reset the spi clock line cs line and data lines. Can be configured in CONF state.
    }

    /// SLAVE1 Register bits
    namespace slave1_bits {
        constexpr uint32_t SLV_ADDR_ERR_CLR = (1U << 10);  ///< 1: Clear SPI_SLV_ADDR_ERR. 0: not valid. Can be changed by CONF_buf.
        constexpr uint32_t SLV_CMD_ERR_CLR = (1U << 11);  ///< 1: Clear SPI_SLV_CMD_ERR. 0: not valid. Can be changed by CONF_buf.
        constexpr uint32_t SLV_NO_QPI_EN = (1U << 12);  ///< 1: spi slave QPI mode is not supported. 0: spi slave QPI mode is supported.
        constexpr uint32_t SLV_ADDR_ERR = (1U << 13);  ///< 1: The address value of the last SPI transfer is not supported by SPI slave. 0: The address value is supported or no address value is received.
        constexpr uint32_t SLV_CMD_ERR = (1U << 14);  ///< 1: The command value of the last SPI transfer is not supported by SPI slave. 0: The command value is supported or no command value is received.
        constexpr uint32_t SLV_WR_DMA_DONE = (1U << 15);  ///< The interrupt raw bit for the completion of dma write operation in the slave mode. Can not be changed by CONF_buf.
        constexpr uint32_t SLV_LAST_COMMAND = (8 << 16);  ///< In the slave mode it is the value of command.
        constexpr uint32_t SLV_LAST_ADDR = (8 << 24);  ///< In the slave mode it is the value of address.
    }

    /// SLV_WRBUF_DLEN Register bits
    namespace slv_wrbuf_dlen_bits {
        constexpr uint32_t SLV_WR_BUF_DONE = (1U << 24);  ///< The interrupt raw bit for the completion of write-buffer operation in the slave mode. Can not be changed by CONF_buf.
        constexpr uint32_t CONF_BASE_BITLEN = (7 << 25);  ///< The basic spi_clk cycles of CONF state. The real cycle length of CONF state, if SPI_USR_CONF is enabled, is SPI_CONF_BASE_BITLEN[6:0] + SPI_CONF_BITLEN[23:0].
    }

    /// SLV_RDBUF_DLEN Register bits
    namespace slv_rdbuf_dlen_bits {
        constexpr uint32_t SLV_DMA_RD_BYTELEN = (20 << 0);  ///< In the slave mode it is the length in bytes for read operations. The register value shall be byte_num.
        constexpr uint32_t SLV_RD_BUF_DONE = (1U << 24);  ///< The interrupt raw bit for the completion of read-buffer operation in the slave mode. Can not be changed by CONF_buf.
        constexpr uint32_t SEG_MAGIC_ERR = (1U << 25);  ///< 1: The recent magic value in CONF buffer is not right in master DMA seg-trans mode. 0: others.
    }

    /// SLV_RD_BYTE Register bits
    namespace slv_rd_byte_bits {
        constexpr uint32_t SLV_DATA_BYTELEN = (20 << 0);  ///< The full-duplex or half-duplex data byte length of the last SPI transfer in slave mode. In half-duplex mode, this value is controlled by bits [23:20].
        constexpr uint32_t SLV_RDDMA_BYTELEN_EN = (1U << 20);  ///< 1: SPI_SLV_DATA_BYTELEN stores data byte length of master-read-slave data length in DMA controlled mode(Rd_DMA). 0: others
        constexpr uint32_t SLV_WRDMA_BYTELEN_EN = (1U << 21);  ///< 1: SPI_SLV_DATA_BYTELEN stores data byte length of master-write-to-slave data length in DMA controlled mode(Wr_DMA). 0: others
        constexpr uint32_t SLV_RDBUF_BYTELEN_EN = (1U << 22);  ///< 1: SPI_SLV_DATA_BYTELEN stores data byte length of master-read-slave data length in CPU controlled mode(Rd_BUF). 0: others
        constexpr uint32_t SLV_WRBUF_BYTELEN_EN = (1U << 23);  ///< 1: SPI_SLV_DATA_BYTELEN stores data byte length of master-write-to-slave data length in CPU controlled mode(Wr_BUF). 0: others
        constexpr uint32_t DMA_SEG_MAGIC_VALUE = (4 << 24);  ///< The magic value of BM table in master DMA seg-trans.
        constexpr uint32_t SLV_RD_DMA_DONE = (1U << 30);  ///< The interrupt raw bit for the completion of Rd-DMA operation in the slave mode. Can not be changed by CONF_buf.
        constexpr uint32_t USR_CONF = (1U << 31);  ///< 1: Enable the DMA CONF phase of current seg-trans operation, which means seg-trans will start. 0: This is not seg-trans mode.
    }

    /// FSM Register bits
    namespace fsm_bits {
        constexpr uint32_t ST = (4 << 0);  ///< The status of spi state machine. 0: idle state, 1: preparation state, 2: send command state, 3: send data state, 4: red data state, 5:write data state, 6: wait state, 7: done state.
        constexpr uint32_t MST_DMA_RD_BYTELEN = (20 << 12);  ///< Define the master DMA read byte length in non seg-conf-trans or seg-conf-trans mode. Invalid when SPI_RX_EOF_EN is 0. Can be configured in CONF state..
    }

    /// HOLD Register bits
    namespace hold_bits {
        constexpr uint32_t INT_HOLD_ENA = (2 << 0);  ///< This register is for two SPI masters to share the same cs clock and data signals. The bits of one SPI are set, if the other SPI is busy, the SPI will be hold. 1(3): hold at idle phase 2: hold at prepare phase. Can be configured in CONF state.
        constexpr uint32_t VAL = (1U << 2);  ///< spi hold output value, which should be used with SPI_HOLD_OUT_EN. Can be configured in CONF state.
        constexpr uint32_t OUT_EN = (1U << 3);  ///< Enable set spi output hold value to spi_hold_reg. It can be used to hold spi state machine with SPI_EXT_HOLD_EN and other usr hold signals. Can be configured in CONF state.
        constexpr uint32_t OUT_TIME = (3 << 4);  ///< set the hold cycles of output spi_hold signal when SPI_HOLD_OUT_EN is enable. Can be configured in CONF state.
        constexpr uint32_t DMA_SEG_TRANS_DONE = (1U << 7);  ///< 1: spi master DMA full-duplex/half-duplex seg-trans ends or slave half-duplex seg-trans ends. And data has been pushed to corresponding memory. 0: seg-trans is not ended or not occurred. Can not be changed by CONF_buf.
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t IN_RST = (1U << 2);  ///< The bit is used to reset in dma fsm and in data fifo pointer.
        constexpr uint32_t OUT_RST = (1U << 3);  ///< The bit is used to reset out dma fsm and out data fifo pointer.
        constexpr uint32_t AHBM_FIFO_RST = (1U << 4);  ///< Reset spi dma ahb master fifo pointer.
        constexpr uint32_t AHBM_RST = (1U << 5);  ///< Reset spi dma ahb master.
        constexpr uint32_t IN_LOOP_TEST = (1U << 6);  ///< Set bit to test in link.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 7);  ///< Set bit to test out link.
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 8);  ///< when the bit is set, DMA continue to use the next inlink node when the length of inlink is 0.
        constexpr uint32_t OUT_EOF_MODE = (1U << 9);  ///< out eof flag generation mode . 1: when dma pop all data from fifo 0:when ahb push all data to fifo.
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 10);  ///< read descriptor use burst mode when read data for memory.
        constexpr uint32_t INDSCR_BURST_EN = (1U << 11);  ///< read descriptor use burst mode when write data to memory.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 12);  ///< spi dma read data from memory in burst mode.
        constexpr uint32_t MEM_TRANS_EN = (1U << 13);  ///< 1: Internal memory data transfer enable bit. Send SPI DMA RX buffer data to SPI DMA TX buffer. 0: Disable this function.
        constexpr uint32_t DMA_RX_STOP = (1U << 14);  ///< spi dma read data stop when in continue tx/rx mode.
        constexpr uint32_t DMA_TX_STOP = (1U << 15);  ///< spi dma write data stop when in continue tx/rx mode.
        constexpr uint32_t DMA_CONTINUE = (1U << 16);  ///< spi dma continue tx/rx data.
        constexpr uint32_t SLV_LAST_SEG_POP_CLR = (1U << 17);  ///< 1: Clear spi_slv_seg_frt_pop_mask. 0 : others
        constexpr uint32_t DMA_SLV_SEG_TRANS_EN = (1U << 18);  ///< Enable dma segment transfer in spi dma half slave mode. 1: enable. 0: disable.
        constexpr uint32_t SLV_RX_SEG_TRANS_CLR_EN = (1U << 19);  ///< 1: spi_dma_infifo_full_vld is cleared by spi slave CMD5. 0: spi_dma_infifo_full_vld is cleared by SPI_TRANS_DONE.
        constexpr uint32_t SLV_TX_SEG_TRANS_CLR_EN = (1U << 20);  ///< 1: spi_dma_outfifo_empty_vld is cleared by spi slave CMD6. 0: spi_dma_outfifo_empty_vld is cleared by SPI_TRANS_DONE.
        constexpr uint32_t RX_EOF_EN = (1U << 21);  ///< 1: SPI_IN_SUC_EOF_INT_RAW is set when the number of dma pushed data bytes is equal to the value of SPI_SLV_DMA_RD_BYTELEN[19:0]/ SPI_MST_DMA_RD_BYTELEN[19:0] in spi dma transition. 0: SPI_IN_SUC_EOF_INT_RAW is set by SPI_TRANS_DONE in non-seg-trans or SPI_DMA_SEG_TRANS_DONE in seg-trans.
        constexpr uint32_t DMA_INFIFO_FULL_CLR = (1U << 22);  ///< 1:Clear spi_dma_infifo_full_vld. 0: Do not control it.
        constexpr uint32_t DMA_OUTFIFO_EMPTY_CLR = (1U << 23);  ///< 1:Clear spi_dma_outfifo_empty_vld. 0: Do not control it.
        constexpr uint32_t EXT_MEM_BK_SIZE = (2 << 26);  ///< Select the external memory block size.
        constexpr uint32_t DMA_SEG_TRANS_CLR = (1U << 28);  ///< 1: End slave seg-trans, which acts as 0x05 command. 2 or more end seg-trans signals will induce error in DMA RX. 0: others. Will be cleared in 1 APB CLK cycles by hardware..
    }

    /// DMA_OUT_LINK Register bits
    namespace dma_out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< The address of the first outlink descriptor.
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< Set the bit to stop to use outlink descriptor.
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< Set the bit to start to use outlink descriptor.
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< Set the bit to mount on new outlink descriptors.
        constexpr uint32_t DMA_TX_ENA = (1U << 31);  ///< spi dma write data status bit.
    }

    /// DMA_IN_LINK Register bits
    namespace dma_in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< The address of the first inlink descriptor.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< when the bit is set, the inlink descriptor returns to the first link node when a packet is error.
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< Set the bit to stop to use inlink descriptor.
        constexpr uint32_t INLINK_START = (1U << 29);  ///< Set the bit to start to use inlink descriptor.
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< Set the bit to mount on new inlink descriptors.
        constexpr uint32_t DMA_RX_ENA = (1U << 31);  ///< SPI DMA read data status bit.
    }

    /// DMA_INT_ENA Register bits
    namespace dma_int_ena_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_ENA = (1U << 0);  ///< The enable bit for lack of enough inlink descriptors. Can be configured in CONF state.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ENA = (1U << 1);  ///< The enable bit for outlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_ENA = (1U << 2);  ///< The enable bit for inlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 3);  ///< The enable bit for completing usage of a inlink descriptor. Can be configured in CONF state.
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 4);  ///< The enable bit for receiving error. Can be configured in CONF state.
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 5);  ///< The enable bit for completing receiving all the packets from host. Can be configured in CONF state.
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 6);  ///< The enable bit for completing usage of a outlink descriptor . Can be configured in CONF state.
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 7);  ///< The enable bit for sending a packet to host done. Can be configured in CONF state.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 8);  ///< The enable bit for sending all the packets to host done. Can be configured in CONF state.
        constexpr uint32_t INFIFO_FULL_ERR_INT_ENA = (1U << 9);  ///< The enable bit for infifo full error interrupt.
        constexpr uint32_t OUTFIFO_EMPTY_ERR_INT_ENA = (1U << 10);  ///< The enable bit for outfifo empty error interrupt.
        constexpr uint32_t SLV_CMD6_INT_ENA = (1U << 11);  ///< The enable bit for SPI slave CMD6 interrupt.
        constexpr uint32_t SLV_CMD7_INT_ENA = (1U << 12);  ///< The enable bit for SPI slave CMD7 interrupt.
        constexpr uint32_t SLV_CMD8_INT_ENA = (1U << 13);  ///< The enable bit for SPI slave CMD8 interrupt.
        constexpr uint32_t SLV_CMD9_INT_ENA = (1U << 14);  ///< The enable bit for SPI slave CMD9 interrupt.
        constexpr uint32_t SLV_CMDA_INT_ENA = (1U << 15);  ///< The enable bit for SPI slave CMDA interrupt.
    }

    /// DMA_INT_RAW Register bits
    namespace dma_int_raw_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_RAW = (1U << 0);  ///< The raw bit for lack of enough inlink descriptors. Can be configured in CONF state.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_RAW = (1U << 1);  ///< The raw bit for outlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_RAW = (1U << 2);  ///< The raw bit for inlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 3);  ///< The raw bit for completing usage of a inlink descriptor. Can be configured in CONF state.
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 4);  ///< The raw bit for receiving error. Can be configured in CONF state.
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 5);  ///< The raw bit for completing receiving all the packets from host. Can be configured in CONF state.
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 6);  ///< The raw bit for completing usage of a outlink descriptor. Can be configured in CONF state.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 7);  ///< The raw bit for sending a packet to host done. Can be configured in CONF state.
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 8);  ///< The raw bit for sending all the packets to host done. Can be configured in CONF state.
        constexpr uint32_t INFIFO_FULL_ERR_INT_RAW = (1U << 9);  ///< 1:SPI_DMA_INFIFO_FULL and spi_push_data_prep are valid, which means that DMA Rx buffer is full but push is valid. 0: Others. Can not be changed by CONF_buf.
        constexpr uint32_t OUTFIFO_EMPTY_ERR_INT_RAW = (1U << 10);  ///< 1:SPI_DMA_OUTFIFO_EMPTY and spi_pop_data_prep are valid, which means that there is no data to pop but pop is valid. 0: Others. Can not be changed by CONF_buf.
        constexpr uint32_t SLV_CMD6_INT_RAW = (1U << 11);  ///< The raw bit for SPI slave CMD6 interrupt.
        constexpr uint32_t SLV_CMD7_INT_RAW = (1U << 12);  ///< The raw bit for SPI slave CMD7 interrupt.
        constexpr uint32_t SLV_CMD8_INT_RAW = (1U << 13);  ///< The raw bit for SPI slave CMD8 interrupt.
        constexpr uint32_t SLV_CMD9_INT_RAW = (1U << 14);  ///< The raw bit for SPI slave CMD9 interrupt.
        constexpr uint32_t SLV_CMDA_INT_RAW = (1U << 15);  ///< The raw bit for SPI slave CMDA interrupt.
    }

    /// DMA_INT_ST Register bits
    namespace dma_int_st_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_ST = (1U << 0);  ///< The status bit for lack of enough inlink descriptors.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ST = (1U << 1);  ///< The status bit for outlink descriptor error.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_ST = (1U << 2);  ///< The status bit for inlink descriptor error.
        constexpr uint32_t IN_DONE_INT_ST = (1U << 3);  ///< The status bit for completing usage of a inlink descriptor.
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 4);  ///< The status bit for receiving error.
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 5);  ///< The status bit for completing receiving all the packets from host.
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 6);  ///< The status bit for completing usage of a outlink descriptor.
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 7);  ///< The status bit for sending a packet to host done.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 8);  ///< The status bit for sending all the packets to host done.
        constexpr uint32_t INFIFO_FULL_ERR_INT_ST = (1U << 9);  ///< The status bit for infifo full error.
        constexpr uint32_t OUTFIFO_EMPTY_ERR_INT_ST = (1U << 10);  ///< The status bit for outfifo empty error.
        constexpr uint32_t SLV_CMD6_INT_ST = (1U << 11);  ///< The status bit for SPI slave CMD6 interrupt.
        constexpr uint32_t SLV_CMD7_INT_ST = (1U << 12);  ///< The status bit for SPI slave CMD7 interrupt.
        constexpr uint32_t SLV_CMD8_INT_ST = (1U << 13);  ///< The status bit for SPI slave CMD8 interrupt.
        constexpr uint32_t SLV_CMD9_INT_ST = (1U << 14);  ///< The status bit for SPI slave CMD9 interrupt.
        constexpr uint32_t SLV_CMDA_INT_ST = (1U << 15);  ///< The status bit for SPI slave CMDA interrupt.
    }

    /// DMA_INT_CLR Register bits
    namespace dma_int_clr_bits {
        constexpr uint32_t INLINK_DSCR_EMPTY_INT_CLR = (1U << 0);  ///< The clear bit for lack of enough inlink descriptors. Can be configured in CONF state.
        constexpr uint32_t OUTLINK_DSCR_ERROR_INT_CLR = (1U << 1);  ///< The clear bit for outlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t INLINK_DSCR_ERROR_INT_CLR = (1U << 2);  ///< The clear bit for inlink descriptor error. Can be configured in CONF state.
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 3);  ///< The clear bit for completing usage of a inlink descriptor. Can be configured in CONF state.
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 4);  ///< The clear bit for receiving error. Can be configured in CONF state.
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 5);  ///< The clear bit for completing receiving all the packets from host. Can be configured in CONF state.
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 6);  ///< The clear bit for completing usage of a outlink descriptor. Can be configured in CONF state.
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 7);  ///< The clear bit for sending a packet to host done. Can be configured in CONF state.
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 8);  ///< The clear bit for sending all the packets to host done. Can be configured in CONF state.
        constexpr uint32_t INFIFO_FULL_ERR_INT_CLR = (1U << 9);  ///< 1: Clear SPI_INFIFO_FULL_ERR_INT_RAW. 0: not valid. Can be changed by CONF_buf.
        constexpr uint32_t OUTFIFO_EMPTY_ERR_INT_CLR = (1U << 10);  ///< 1: Clear SPI_OUTFIFO_EMPTY_ERR_INT_RAW signal. 0: not valid. Can be changed by CONF_buf.
        constexpr uint32_t SLV_CMD6_INT_CLR = (1U << 11);  ///< The clear bit for SPI slave CMD6 interrupt.
        constexpr uint32_t SLV_CMD7_INT_CLR = (1U << 12);  ///< The clear bit for SPI slave CMD7 interrupt.
        constexpr uint32_t SLV_CMD8_INT_CLR = (1U << 13);  ///< The clear bit for SPI slave CMD8 interrupt.
        constexpr uint32_t SLV_CMD9_INT_CLR = (1U << 14);  ///< The clear bit for SPI slave CMD9 interrupt.
        constexpr uint32_t SLV_CMDA_INT_CLR = (1U << 15);  ///< The clear bit for SPI slave CMDA interrupt.
    }

    /// IN_ERR_EOF_DES_ADDR Register bits
    namespace in_err_eof_des_addr_bits {
        constexpr uint32_t DMA_IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< The inlink descriptor address when spi dma produce receiving error.
    }

    /// IN_SUC_EOF_DES_ADDR Register bits
    namespace in_suc_eof_des_addr_bits {
        constexpr uint32_t DMA_IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< The last inlink descriptor address when spi dma produce from_suc_eof.
    }

    /// INLINK_DSCR Register bits
    namespace inlink_dscr_bits {
        constexpr uint32_t DMA_INLINK_DSCR = (32 << 0);  ///< The content of current in descriptor pointer.
    }

    /// INLINK_DSCR_BF0 Register bits
    namespace inlink_dscr_bf0_bits {
        constexpr uint32_t DMA_INLINK_DSCR_BF0 = (32 << 0);  ///< The content of next in descriptor pointer.
    }

    /// INLINK_DSCR_BF1 Register bits
    namespace inlink_dscr_bf1_bits {
        constexpr uint32_t DMA_INLINK_DSCR_BF1 = (32 << 0);  ///< The content of current in descriptor data buffer pointer.
    }

    /// OUT_EOF_BFR_DES_ADDR Register bits
    namespace out_eof_bfr_des_addr_bits {
        constexpr uint32_t DMA_OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< The address of buffer relative to the outlink descriptor that produce eof.
    }

    /// OUT_EOF_DES_ADDR Register bits
    namespace out_eof_des_addr_bits {
        constexpr uint32_t DMA_OUT_EOF_DES_ADDR = (32 << 0);  ///< The last outlink descriptor address when spi dma produce to_eof.
    }

    /// OUTLINK_DSCR Register bits
    namespace outlink_dscr_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR = (32 << 0);  ///< The content of current out descriptor pointer.
    }

    /// OUTLINK_DSCR_BF0 Register bits
    namespace outlink_dscr_bf0_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR_BF0 = (32 << 0);  ///< The content of next out descriptor pointer.
    }

    /// OUTLINK_DSCR_BF1 Register bits
    namespace outlink_dscr_bf1_bits {
        constexpr uint32_t DMA_OUTLINK_DSCR_BF1 = (32 << 0);  ///< The content of current out descriptor data buffer pointer.
    }

    /// DMA_OUTSTATUS Register bits
    namespace dma_outstatus_bits {
        constexpr uint32_t DMA_OUTDSCR_ADDR = (18 << 0);  ///< SPI dma out descriptor address.
        constexpr uint32_t DMA_OUTDSCR_STATE = (2 << 18);  ///< SPI dma out descriptor state.
        constexpr uint32_t DMA_OUT_STATE = (3 << 20);  ///< SPI dma out data state.
        constexpr uint32_t DMA_OUTFIFO_CNT = (7 << 23);  ///< The remains of SPI dma outfifo data.
        constexpr uint32_t DMA_OUTFIFO_FULL = (1U << 30);  ///< SPI dma outfifo is full.
        constexpr uint32_t DMA_OUTFIFO_EMPTY = (1U << 31);  ///< SPI dma outfifo is empty.
    }

    /// DMA_INSTATUS Register bits
    namespace dma_instatus_bits {
        constexpr uint32_t DMA_INDSCR_ADDR = (18 << 0);  ///< SPI dma in descriptor address.
        constexpr uint32_t DMA_INDSCR_STATE = (2 << 18);  ///< SPI dma in descriptor state.
        constexpr uint32_t DMA_IN_STATE = (3 << 20);  ///< SPI dma in data state.
        constexpr uint32_t DMA_INFIFO_CNT = (7 << 23);  ///< The remains of SPI dma infifo data.
        constexpr uint32_t DMA_INFIFO_FULL = (1U << 30);  ///< SPI dma infifo is full.
        constexpr uint32_t DMA_INFIFO_EMPTY = (1U << 31);  ///< SPI dma infifo is empty.
    }

    /// W0 Register bits
    namespace w0_bits {
        constexpr uint32_t BUF0 = (32 << 0);  ///< 32 bits data buffer 0, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W1 Register bits
    namespace w1_bits {
        constexpr uint32_t BUF1 = (32 << 0);  ///< 32 bits data buffer 1, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W2 Register bits
    namespace w2_bits {
        constexpr uint32_t BUF2 = (32 << 0);  ///< 32 bits data buffer 2, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W3 Register bits
    namespace w3_bits {
        constexpr uint32_t BUF3 = (32 << 0);  ///< 32 bits data buffer 3, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W4 Register bits
    namespace w4_bits {
        constexpr uint32_t BUF4 = (32 << 0);  ///< 32 bits data buffer 4, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W5 Register bits
    namespace w5_bits {
        constexpr uint32_t BUF5 = (32 << 0);  ///< 32 bits data buffer 5, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W6 Register bits
    namespace w6_bits {
        constexpr uint32_t BUF6 = (32 << 0);  ///< 32 bits data buffer 6, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W7 Register bits
    namespace w7_bits {
        constexpr uint32_t BUF7 = (32 << 0);  ///< 32 bits data buffer 7, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W8 Register bits
    namespace w8_bits {
        constexpr uint32_t BUF8 = (32 << 0);  ///< 32 bits data buffer 8, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W9 Register bits
    namespace w9_bits {
        constexpr uint32_t BUF9 = (32 << 0);  ///< 32 bits data buffer 9, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W10 Register bits
    namespace w10_bits {
        constexpr uint32_t BUF10 = (32 << 0);  ///< 32 bits data buffer 10, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W11 Register bits
    namespace w11_bits {
        constexpr uint32_t BUF11 = (32 << 0);  ///< 32 bits data buffer 11, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W12 Register bits
    namespace w12_bits {
        constexpr uint32_t BUF12 = (32 << 0);  ///< 32 bits data buffer 12, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W13 Register bits
    namespace w13_bits {
        constexpr uint32_t BUF13 = (32 << 0);  ///< 32 bits data buffer 13, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W14 Register bits
    namespace w14_bits {
        constexpr uint32_t BUF14 = (32 << 0);  ///< 32 bits data buffer 14, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W15 Register bits
    namespace w15_bits {
        constexpr uint32_t BUF15 = (32 << 0);  ///< 32 bits data buffer 15, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W16 Register bits
    namespace w16_bits {
        constexpr uint32_t BUF16 = (32 << 0);  ///< 32 bits data buffer 16, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// W17 Register bits
    namespace w17_bits {
        constexpr uint32_t BUF17 = (32 << 0);  ///< 32 bits data buffer 17, transferred in the unit of byte. Byte addressable in slave half-duplex mode.
    }

    /// DIN_MODE Register bits
    namespace din_mode_bits {
        constexpr uint32_t DIN0_MODE = (3 << 0);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN1_MODE = (3 << 3);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN2_MODE = (3 << 6);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN3_MODE = (3 << 9);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN4_MODE = (3 << 12);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN5_MODE = (3 << 15);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN6_MODE = (3 << 18);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DIN7_MODE = (3 << 21);  ///< the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t TIMING_CLK_ENA = (1U << 24);  ///< 1:enable hclk in spi_timing.v. 0: disable it. Can be configured in CONF state.
    }

    /// DIN_NUM Register bits
    namespace din_num_bits {
        constexpr uint32_t DIN0_NUM = (2 << 0);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN1_NUM = (2 << 2);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN2_NUM = (2 << 4);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN3_NUM = (2 << 6);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN4_NUM = (2 << 8);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN5_NUM = (2 << 10);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN6_NUM = (2 << 12);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DIN7_NUM = (2 << 14);  ///< the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
    }

    /// DOUT_MODE Register bits
    namespace dout_mode_bits {
        constexpr uint32_t DOUT0_MODE = (3 << 0);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT1_MODE = (3 << 3);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT2_MODE = (3 << 6);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT3_MODE = (3 << 9);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT4_MODE = (3 << 12);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT5_MODE = (3 << 15);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT6_MODE = (3 << 18);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DOUT7_MODE = (3 << 21);  ///< the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
    }

    /// DOUT_NUM Register bits
    namespace dout_num_bits {
        constexpr uint32_t DOUT0_NUM = (2 << 0);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT1_NUM = (2 << 2);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT2_NUM = (2 << 4);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT3_NUM = (2 << 6);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT4_NUM = (2 << 8);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT5_NUM = (2 << 10);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT6_NUM = (2 << 12);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t DOUT7_NUM = (2 << 14);  ///< the output signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
    }

    /// LCD_CTRL Register bits
    namespace lcd_ctrl_bits {
        constexpr uint32_t LCD_HB_FRONT = (11 << 0);  ///< It is the horizontal blank front porch of a frame. Can be configured in CONF state.
        constexpr uint32_t LCD_VA_HEIGHT = (10 << 11);  ///< It is the vertical active height of a frame. Can be configured in CONF state.
        constexpr uint32_t LCD_VT_HEIGHT = (10 << 21);  ///< It is the vertical total height of a frame. Can be configured in CONF state.
        constexpr uint32_t LCD_MODE_EN = (1U << 31);  ///< 1: Enable LCD mode output vsync, hsync, de. 0: Disable. Can be configured in CONF state.
    }

    /// LCD_CTRL1 Register bits
    namespace lcd_ctrl1_bits {
        constexpr uint32_t LCD_VB_FRONT = (8 << 0);  ///< It is the vertical blank front porch of a frame. Can be configured in CONF state.
        constexpr uint32_t LCD_HA_WIDTH = (12 << 8);  ///< It is the horizontal active width of a frame. Can be configured in CONF state.
        constexpr uint32_t LCD_HT_WIDTH = (12 << 20);  ///< It is the horizontal total width of a frame. Can be configured in CONF state.
    }

    /// LCD_CTRL2 Register bits
    namespace lcd_ctrl2_bits {
        constexpr uint32_t LCD_VSYNC_WIDTH = (7 << 0);  ///< It is the position of spi_vsync active pulse in a line. Can be configured in CONF state.
        constexpr uint32_t VSYNC_IDLE_POL = (1U << 7);  ///< It is the idle value of spi_vsync. Can be configured in CONF state.
        constexpr uint32_t LCD_HSYNC_WIDTH = (7 << 16);  ///< It is the position of spi_hsync active pulse in a line. Can be configured in CONF state.
        constexpr uint32_t HSYNC_IDLE_POL = (1U << 23);  ///< It is the idle value of spi_hsync. Can be configured in CONF state.
        constexpr uint32_t LCD_HSYNC_POSITION = (8 << 24);  ///< It is the position of spi_hsync active pulse in a line. Can be configured in CONF state.
    }

    /// LCD_D_MODE Register bits
    namespace lcd_d_mode_bits {
        constexpr uint32_t D_DQS_MODE = (3 << 0);  ///< the output spi_dqs is delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t D_CD_MODE = (3 << 3);  ///< the output spi_cd is delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t D_DE_MODE = (3 << 6);  ///< the output spi_de is delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t D_HSYNC_MODE = (3 << 9);  ///< the output spi_hsync is delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t D_VSYNC_MODE = (3 << 12);  ///< the output spi_vsync is delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk. Can be configured in CONF state.
        constexpr uint32_t DE_IDLE_POL = (1U << 15);  ///< It is the idle value of spi_de.
        constexpr uint32_t HS_BLANK_EN = (1U << 16);  ///< 1: The pulse of spi_hsync is out in vertical blanking lines in seg-trans or one trans. 0: spi_hsync pulse is valid only in active region lines in seg-trans.
    }

    /// LCD_D_NUM Register bits
    namespace lcd_d_num_bits {
        constexpr uint32_t D_DQS_NUM = (2 << 0);  ///< the output spi_dqs is delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t D_CD_NUM = (2 << 2);  ///< the output spi_cd is delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t D_DE_NUM = (2 << 4);  ///< the output spi_de is delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t D_HSYNC_NUM = (2 << 6);  ///< the output spi_hsync is delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
        constexpr uint32_t D_VSYNC_NUM = (2 << 8);  ///< the output spi_vsync is delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured in CONF state.
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< SPI register version.
    }

}

// ============================================================================
// SYSCON Peripheral
// ============================================================================

namespace syscon {
    /// Base addresses
    constexpr uint32_t SYSCON_BASE = 0x3F426000;

    /// SYSCON Register structure
    struct Registers {
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x00 - 
        volatile uint32_t TICK_CONF;  ///< Offset: 0x04 - 
        volatile uint32_t CLK_OUT_EN;  ///< Offset: 0x08 - 
        volatile uint32_t HOST_INF_SEL;  ///< Offset: 0x0C - 
        volatile uint32_t EXT_MEM_PMS_LOCK;  ///< Offset: 0x10 - 
        volatile uint32_t FLASH_ACE0_ATTR;  ///< Offset: 0x14 - 
        volatile uint32_t FLASH_ACE1_ATTR;  ///< Offset: 0x18 - 
        volatile uint32_t FLASH_ACE2_ATTR;  ///< Offset: 0x1C - 
        volatile uint32_t FLASH_ACE3_ATTR;  ///< Offset: 0x20 - 
        volatile uint32_t FLASH_ACE0_ADDR;  ///< Offset: 0x24 - 
        volatile uint32_t FLASH_ACE1_ADDR;  ///< Offset: 0x28 - 
        volatile uint32_t FLASH_ACE2_ADDR;  ///< Offset: 0x2C - 
        volatile uint32_t FLASH_ACE3_ADDR;  ///< Offset: 0x30 - 
        volatile uint32_t FLASH_ACE0_SIZE;  ///< Offset: 0x34 - 
        volatile uint32_t FLASH_ACE1_SIZE;  ///< Offset: 0x38 - 
        volatile uint32_t FLASH_ACE2_SIZE;  ///< Offset: 0x3C - 
        volatile uint32_t FLASH_ACE3_SIZE;  ///< Offset: 0x40 - 
        volatile uint32_t SRAM_ACE0_ATTR;  ///< Offset: 0x44 - 
        volatile uint32_t SRAM_ACE1_ATTR;  ///< Offset: 0x48 - 
        volatile uint32_t SRAM_ACE2_ATTR;  ///< Offset: 0x4C - 
        volatile uint32_t SRAM_ACE3_ATTR;  ///< Offset: 0x50 - 
        volatile uint32_t SRAM_ACE0_ADDR;  ///< Offset: 0x54 - 
        volatile uint32_t SRAM_ACE1_ADDR;  ///< Offset: 0x58 - 
        volatile uint32_t SRAM_ACE2_ADDR;  ///< Offset: 0x5C - 
        volatile uint32_t SRAM_ACE3_ADDR;  ///< Offset: 0x60 - 
        volatile uint32_t SRAM_ACE0_SIZE;  ///< Offset: 0x64 - 
        volatile uint32_t SRAM_ACE1_SIZE;  ///< Offset: 0x68 - 
        volatile uint32_t SRAM_ACE2_SIZE;  ///< Offset: 0x6C - 
        volatile uint32_t SRAM_ACE3_SIZE;  ///< Offset: 0x70 - 
        volatile uint32_t SPI_MEM_PMS_CTRL;  ///< Offset: 0x74 - 
        volatile uint32_t SPI_MEM_REJECT_ADDR;  ///< Offset: 0x78 - 
        volatile uint32_t SDIO_CTRL;  ///< Offset: 0x7C - 
        volatile uint32_t REDCY_SIG0;  ///< Offset: 0x80 - 
        volatile uint32_t REDCY_SIG1;  ///< Offset: 0x84 - 
        volatile uint32_t WIFI_BB_CFG;  ///< Offset: 0x88 - 
        volatile uint32_t WIFI_BB_CFG_2;  ///< Offset: 0x8C - 
        volatile uint32_t WIFI_CLK_EN;  ///< Offset: 0x90 - 
        volatile uint32_t WIFI_RST_EN;  ///< Offset: 0x94 - 
        volatile uint32_t FRONT_END_MEM_PD;  ///< Offset: 0x98 - 
        volatile uint32_t DATE;  ///< Offset: 0x3FC - 
    };

    /// Peripheral instances
    inline Registers* SYSCON = reinterpret_cast<Registers*>(SYSCON_BASE);

    // Bit definitions
    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t CLK_320M_EN = (1U << 10);  ///< CLK_320M_EN
        constexpr uint32_t CLK_EN = (1U << 11);  ///< CLK_EN
        constexpr uint32_t RST_TICK_CNT = (1U << 12);  ///< RST_TICK_CNT
    }

    /// TICK_CONF Register bits
    namespace tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< XTAL_TICK_NUM
        constexpr uint32_t CK8M_TICK_NUM = (8 << 8);  ///< CK8M_TICK_NUM
        constexpr uint32_t TICK_ENABLE = (1U << 16);  ///< TICK_ENABLE
    }

    /// CLK_OUT_EN Register bits
    namespace clk_out_en_bits {
        constexpr uint32_t CLK20_OEN = (1U << 0);  ///< CLK20_OEN
        constexpr uint32_t CLK22_OEN = (1U << 1);  ///< CLK22_OEN
        constexpr uint32_t CLK44_OEN = (1U << 2);  ///< CLK44_OEN
        constexpr uint32_t CLK_BB_OEN = (1U << 3);  ///< CLK_BB_OEN
        constexpr uint32_t CLK80_OEN = (1U << 4);  ///< CLK80_OEN
        constexpr uint32_t CLK160_OEN = (1U << 5);  ///< CLK160_OEN
        constexpr uint32_t CLK_320M_OEN = (1U << 6);  ///< CLK_320M_OEN
        constexpr uint32_t CLK_ADC_INF_OEN = (1U << 7);  ///< CLK_ADC_INF_OEN
        constexpr uint32_t CLK_DAC_CPU_OEN = (1U << 8);  ///< CLK_DAC_CPU_OEN
        constexpr uint32_t CLK40X_BB_OEN = (1U << 9);  ///< CLK40X_BB_OEN
        constexpr uint32_t CLK_XTAL_OEN = (1U << 10);  ///< CLK_XTAL_OEN
    }

    /// HOST_INF_SEL Register bits
    namespace host_inf_sel_bits {
        constexpr uint32_t PERI_IO_SWAP = (8 << 0);  ///< PERI_IO_SWAP
    }

    /// EXT_MEM_PMS_LOCK Register bits
    namespace ext_mem_pms_lock_bits {
        constexpr uint32_t EXT_MEM_PMS_LOCK = (1U << 0);  ///< EXT_MEM_PMS_LOCK
    }

    /// FLASH_ACE0_ATTR Register bits
    namespace flash_ace0_attr_bits {
        constexpr uint32_t FLASH_ACE0_ATTR = (3 << 0);  ///< FLASH_ACE0_ATTR
    }

    /// FLASH_ACE1_ATTR Register bits
    namespace flash_ace1_attr_bits {
        constexpr uint32_t FLASH_ACE1_ATTR = (3 << 0);  ///< FLASH_ACE1_ATTR
    }

    /// FLASH_ACE2_ATTR Register bits
    namespace flash_ace2_attr_bits {
        constexpr uint32_t FLASH_ACE2_ATTR = (3 << 0);  ///< FLASH_ACE2_ATTR
    }

    /// FLASH_ACE3_ATTR Register bits
    namespace flash_ace3_attr_bits {
        constexpr uint32_t FLASH_ACE3_ATTR = (3 << 0);  ///< FLASH_ACE3_ATTR
    }

    /// FLASH_ACE0_ADDR Register bits
    namespace flash_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// FLASH_ACE1_ADDR Register bits
    namespace flash_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// FLASH_ACE2_ADDR Register bits
    namespace flash_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// FLASH_ACE3_ADDR Register bits
    namespace flash_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// FLASH_ACE0_SIZE Register bits
    namespace flash_ace0_size_bits {
        constexpr uint32_t FLASH_ACE0_SIZE = (16 << 0);  ///< FLASH_ACE0_SIZE
    }

    /// FLASH_ACE1_SIZE Register bits
    namespace flash_ace1_size_bits {
        constexpr uint32_t FLASH_ACE1_SIZE = (16 << 0);  ///< FLASH_ACE1_SIZE
    }

    /// FLASH_ACE2_SIZE Register bits
    namespace flash_ace2_size_bits {
        constexpr uint32_t FLASH_ACE2_SIZE = (16 << 0);  ///< FLASH_ACE2_SIZE
    }

    /// FLASH_ACE3_SIZE Register bits
    namespace flash_ace3_size_bits {
        constexpr uint32_t FLASH_ACE3_SIZE = (16 << 0);  ///< FLASH_ACE3_SIZE
    }

    /// SRAM_ACE0_ATTR Register bits
    namespace sram_ace0_attr_bits {
        constexpr uint32_t SRAM_ACE0_ATTR = (3 << 0);  ///< SRAM_ACE0_ATTR
    }

    /// SRAM_ACE1_ATTR Register bits
    namespace sram_ace1_attr_bits {
        constexpr uint32_t SRAM_ACE1_ATTR = (3 << 0);  ///< SRAM_ACE1_ATTR
    }

    /// SRAM_ACE2_ATTR Register bits
    namespace sram_ace2_attr_bits {
        constexpr uint32_t SRAM_ACE2_ATTR = (3 << 0);  ///< SRAM_ACE2_ATTR
    }

    /// SRAM_ACE3_ATTR Register bits
    namespace sram_ace3_attr_bits {
        constexpr uint32_t SRAM_ACE3_ATTR = (3 << 0);  ///< SRAM_ACE3_ATTR
    }

    /// SRAM_ACE0_ADDR Register bits
    namespace sram_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// SRAM_ACE1_ADDR Register bits
    namespace sram_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// SRAM_ACE2_ADDR Register bits
    namespace sram_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// SRAM_ACE3_ADDR Register bits
    namespace sram_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< S
    }

    /// SRAM_ACE0_SIZE Register bits
    namespace sram_ace0_size_bits {
        constexpr uint32_t SRAM_ACE0_SIZE = (16 << 0);  ///< SRAM_ACE0_SIZE
    }

    /// SRAM_ACE1_SIZE Register bits
    namespace sram_ace1_size_bits {
        constexpr uint32_t SRAM_ACE1_SIZE = (16 << 0);  ///< SRAM_ACE1_SIZE
    }

    /// SRAM_ACE2_SIZE Register bits
    namespace sram_ace2_size_bits {
        constexpr uint32_t SRAM_ACE2_SIZE = (16 << 0);  ///< SRAM_ACE2_SIZE
    }

    /// SRAM_ACE3_SIZE Register bits
    namespace sram_ace3_size_bits {
        constexpr uint32_t SRAM_ACE3_SIZE = (16 << 0);  ///< SRAM_ACE3_SIZE
    }

    /// SPI_MEM_PMS_CTRL Register bits
    namespace spi_mem_pms_ctrl_bits {
        constexpr uint32_t SPI_MEM_REJECT_INT = (1U << 0);  ///< SPI_MEM_REJECT_INT
        constexpr uint32_t SPI_MEM_REJECT_CLR = (1U << 1);  ///< SPI_MEM_REJECT_CLR
        constexpr uint32_t SPI_MEM_REJECT_CDE = (5 << 2);  ///< SPI_MEM_REJECT_CDE
    }

    /// SPI_MEM_REJECT_ADDR Register bits
    namespace spi_mem_reject_addr_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (32 << 0);  ///< SPI_MEM_REJECT_ADDR
    }

    /// SDIO_CTRL Register bits
    namespace sdio_ctrl_bits {
        constexpr uint32_t SDIO_WIN_ACCESS_EN = (1U << 0);  ///< SDIO_WIN_ACCESS_EN
    }

    /// REDCY_SIG0 Register bits
    namespace redcy_sig0_bits {
        constexpr uint32_t REDCY_SIG0 = (31 << 0);  ///< REDCY_SIG0
        constexpr uint32_t REDCY_ANDOR = (1U << 31);  ///< REDCY_ANDOR
    }

    /// REDCY_SIG1 Register bits
    namespace redcy_sig1_bits {
        constexpr uint32_t REDCY_SIG1 = (31 << 0);  ///< REDCY_SIG1
        constexpr uint32_t REDCY_NANDOR = (1U << 31);  ///< REDCY_NANDOR
    }

    /// WIFI_BB_CFG Register bits
    namespace wifi_bb_cfg_bits {
        constexpr uint32_t WIFI_BB_CFG = (32 << 0);  ///< WIFI_BB_CFG
    }

    /// WIFI_BB_CFG_2 Register bits
    namespace wifi_bb_cfg_2_bits {
        constexpr uint32_t WIFI_BB_CFG_2 = (32 << 0);  ///< WIFI_BB_CFG_2
    }

    /// WIFI_CLK_EN Register bits
    namespace wifi_clk_en_bits {
        constexpr uint32_t WIFI_CLK_EN = (32 << 0);  ///< WIFI_CLK_EN
    }

    /// WIFI_RST_EN Register bits
    namespace wifi_rst_en_bits {
        constexpr uint32_t WIFI_RST = (32 << 0);  ///< WIFI_RST
    }

    /// FRONT_END_MEM_PD Register bits
    namespace front_end_mem_pd_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 0);  ///< AGC_MEM_FORCE_PU
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 1);  ///< AGC_MEM_FORCE_PD
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 2);  ///< PBUS_MEM_FORCE_PU
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 3);  ///< PBUS_MEM_FORCE_PD
        constexpr uint32_t DC_MEM_FORCE_PU = (1U << 4);  ///< DC_MEM_FORCE_PU
        constexpr uint32_t DC_MEM_FORCE_PD = (1U << 5);  ///< DC_MEM_FORCE_PD
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< DATE
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x3F4C0000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t ROM_CTRL_0;  ///< Offset: 0x00 - System ROM configuration register 0
        volatile uint32_t ROM_CTRL_1;  ///< Offset: 0x04 - System ROM configuration register 1
        volatile uint32_t SRAM_CTRL_0;  ///< Offset: 0x08 - System SRAM configuration register 0
        volatile uint32_t SRAM_CTRL_1;  ///< Offset: 0x0C - System SRAM configuration register 1
        volatile uint32_t CPU_PERI_CLK_EN;  ///< Offset: 0x10 - CPU peripheral clock enable register
        volatile uint32_t CPU_PERI_RST_EN;  ///< Offset: 0x14 - CPU peripheral reset register
        volatile uint32_t CPU_PER_CONF;  ///< Offset: 0x18 - CPU peripheral clock configuration register
        volatile uint32_t JTAG_CTRL_0;  ///< Offset: 0x1C - JTAG configuration register 0
        volatile uint32_t JTAG_CTRL_1;  ///< Offset: 0x20 - JTAG configuration register 1
        volatile uint32_t JTAG_CTRL_2;  ///< Offset: 0x24 - JTAG configuration register 2
        volatile uint32_t JTAG_CTRL_3;  ///< Offset: 0x28 - JTAG configuration register 3
        volatile uint32_t JTAG_CTRL_4;  ///< Offset: 0x2C - JTAG configuration register 4
        volatile uint32_t JTAG_CTRL_5;  ///< Offset: 0x30 - JTAG configuration register 5
        volatile uint32_t JTAG_CTRL_6;  ///< Offset: 0x34 - JTAG configuration register 6
        volatile uint32_t JTAG_CTRL_7;  ///< Offset: 0x38 - JTAG configuration register 7
        volatile uint32_t MEM_PD_MASK;  ///< Offset: 0x3C - Memory power-related controlling register (under low-sleep)
        volatile uint32_t PERIP_CLK_EN0;  ///< Offset: 0x40 - System peripheral clock (for hardware accelerators)...
        volatile uint32_t PERIP_CLK_EN1;  ///< Offset: 0x44 - System peripheral clock (for hardware accelerators)...
        volatile uint32_t PERIP_RST_EN0;  ///< Offset: 0x48 - System peripheral (hardware accelerators) reset register 0
        volatile uint32_t PERIP_RST_EN1;  ///< Offset: 0x4C - System peripheral (hardware accelerators) reset register 1
        volatile uint32_t LPCK_DIV_INT;  ///< Offset: 0x50 - Low power clock divider integer register
        volatile uint32_t BT_LPCK_DIV_FRAC;  ///< Offset: 0x54 - Divider fraction configuration register for low-power clock
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x58 - CPU interrupt controlling register 0
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x5C - CPU interrupt controlling register 1
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x60 - CPU interrupt controlling register 2
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x64 - CPU interrupt controlling register 3
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x68 - RSA memory remapping register
        volatile uint32_t BUSTOEXTMEM_ENA;  ///< Offset: 0x6C - EDMA enable register
        volatile uint32_t CACHE_CONTROL;  ///< Offset: 0x70 - Cache control register
        volatile uint32_t EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL;  ///< Offset: 0x74 - External memory encrypt and decrypt controlling register
        volatile uint32_t RTC_FASTMEM_CONFIG;  ///< Offset: 0x78 - RTC fast memory configuration register
        volatile uint32_t RTC_FASTMEM_CRC;  ///< Offset: 0x7C - RTC fast memory CRC controlling register
        volatile uint32_t Redundant_ECO_Ctrl;  ///< Offset: 0x80 - Redundant ECO control register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x84 - Clock gate control register
        volatile uint32_t SRAM_CTRL_2;  ///< Offset: 0x88 - System SRAM configuration register 2
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x8C - SoC clock configuration register
        volatile uint32_t DATE;  ///< Offset: 0xFFC - Version control register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// ROM_CTRL_0 Register bits
    namespace rom_ctrl_0_bits {
        constexpr uint32_t ROM_FO = (2 << 0);  ///< This field is used to force on clock gate of internal ROM.
    }

    /// ROM_CTRL_1 Register bits
    namespace rom_ctrl_1_bits {
        constexpr uint32_t ROM_FORCE_PD = (2 << 0);  ///< This field is used to power down internal ROM.
        constexpr uint32_t ROM_FORCE_PU = (2 << 2);  ///< This field is used to power up internal ROM.
    }

    /// SRAM_CTRL_0 Register bits
    namespace sram_ctrl_0_bits {
        constexpr uint32_t SRAM_FO = (22 << 0);  ///< This field is used to force on clock gate of internal SRAM.
    }

    /// SRAM_CTRL_1 Register bits
    namespace sram_ctrl_1_bits {
        constexpr uint32_t SRAM_FORCE_PD = (22 << 0);  ///< This field is used to power down internal SRAM.
    }

    /// CPU_PERI_CLK_EN Register bits
    namespace cpu_peri_clk_en_bits {
        constexpr uint32_t CLK_EN_DEDICATED_GPIO = (1U << 7);  ///< Set this bit to enable clock of DEDICATED GPIO module.
    }

    /// CPU_PERI_RST_EN Register bits
    namespace cpu_peri_rst_en_bits {
        constexpr uint32_t RST_EN_DEDICATED_GPIO = (1U << 7);  ///< Set this bit to reset DEDICATED GPIO module.
    }

    /// CPU_PER_CONF Register bits
    namespace cpu_per_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< This field is used to select the clock frequency of CPU or CPU period.
        constexpr uint32_t PLL_FREQ_SEL = (1U << 2);  ///< This field is used to select the PLL clock frequency based on CPU period.
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 3);  ///< Set this bit to force on CPU wait mode. In this mode, the clock gate of CPU is turned off until any interrupts happen. This mode could also be force on via WAITI instruction.
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 4);  ///< Sets the number of delay cycles to enter CPU wait mode after a WAITI instruction.
    }

    /// JTAG_CTRL_0 Register bits
    namespace jtag_ctrl_0_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 = (32 << 0);  ///< Stores the 0 to 31 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_1 Register bits
    namespace jtag_ctrl_1_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1 = (32 << 0);  ///< Stores the 32 to 63 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_2 Register bits
    namespace jtag_ctrl_2_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2 = (32 << 0);  ///< Stores the 64 to 95 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_3 Register bits
    namespace jtag_ctrl_3_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3 = (32 << 0);  ///< Stores the 96 to 127 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_4 Register bits
    namespace jtag_ctrl_4_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4 = (32 << 0);  ///< Stores the 128 to 159 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_5 Register bits
    namespace jtag_ctrl_5_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5 = (32 << 0);  ///< Stores the 160 to 191 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_6 Register bits
    namespace jtag_ctrl_6_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6 = (32 << 0);  ///< Stores the 192 to 223 bits of the 256 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// JTAG_CTRL_7 Register bits
    namespace jtag_ctrl_7_bits {
        constexpr uint32_t CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7 = (32 << 0);  ///< Stores the 0 to 224 bits of the 255 bits register used to cancel the temporary disable of eFuse to JTAG.
    }

    /// MEM_PD_MASK Register bits
    namespace mem_pd_mask_bits {
        constexpr uint32_t LSLP_MEM_PD_MASK = (1U << 0);  ///< Set this bit to allow the memory to work as usual when the chip enters the light-sleep state.
    }

    /// PERIP_CLK_EN0 Register bits
    namespace perip_clk_en0_bits {
        constexpr uint32_t TIMERS_CLK_EN = (1U << 0);  ///< Set this bit to enable clock of timers.
        constexpr uint32_t SPI01_CLK_EN = (1U << 1);  ///< Set this bit to enable clock of SPI0 and SPI1.
        constexpr uint32_t UART_CLK_EN = (1U << 2);  ///< Set this bit to enable clock of UART0.
        constexpr uint32_t WDG_CLK_EN = (1U << 3);  ///< Set this bit to enable clock of WDG.
        constexpr uint32_t I2S0_CLK_EN = (1U << 4);  ///< Set this bit to enable clock of I2S0.
        constexpr uint32_t UART1_CLK_EN = (1U << 5);  ///< Set this bit to enable clock of UART1.
        constexpr uint32_t SPI2_CLK_EN = (1U << 6);  ///< Set this bit to enable clock of SPI2.
        constexpr uint32_t I2C_EXT0_CLK_EN = (1U << 7);  ///< Set this bit to enable clock of I2C EXT0.
        constexpr uint32_t UHCI0_CLK_EN = (1U << 8);  ///< Set this bit to enable clock of UHCI0.
        constexpr uint32_t RMT_CLK_EN = (1U << 9);  ///< Set this bit to enable clock of remote controller.
        constexpr uint32_t PCNT_CLK_EN = (1U << 10);  ///< Set this bit to enable clock of pulse count.
        constexpr uint32_t LEDC_CLK_EN = (1U << 11);  ///< Set this bit to enable clock of LED PWM.
        constexpr uint32_t UHCI1_CLK_EN = (1U << 12);  ///< Set this bit to enable clock of UHCI1.
        constexpr uint32_t TIMERGROUP_CLK_EN = (1U << 13);  ///< Set this bit to enable clock of timer group0.
        constexpr uint32_t EFUSE_CLK_EN = (1U << 14);  ///< Set this bit to enable clock of eFuse.
        constexpr uint32_t TIMERGROUP1_CLK_EN = (1U << 15);  ///< Set this bit to enable clock of timer group1.
        constexpr uint32_t SPI3_CLK_EN = (1U << 16);  ///< Set this bit to enable clock of SPI3.
        constexpr uint32_t PWM0_CLK_EN = (1U << 17);  ///< Set this bit to enable clock of PWM0.
        constexpr uint32_t I2C_EXT1_CLK_EN = (1U << 18);  ///< Set this bit to enable clock of I2C EXT1.
        constexpr uint32_t TWAI_CLK_EN = (1U << 19);  ///< Set this bit to enable clock of CAN.
        constexpr uint32_t PWM1_CLK_EN = (1U << 20);  ///< Set this bit to enable clock of PWM1.
        constexpr uint32_t I2S1_CLK_EN = (1U << 21);  ///< Set this bit to enable clock of I2S1.
        constexpr uint32_t SPI2_DMA_CLK_EN = (1U << 22);  ///< Set this bit to enable clock of SPI2 DMA.
        constexpr uint32_t USB_CLK_EN = (1U << 23);  ///< Set this bit to enable clock of USB.
        constexpr uint32_t UART_MEM_CLK_EN = (1U << 24);  ///< Set this bit to enable clock of UART memory.
        constexpr uint32_t PWM2_CLK_EN = (1U << 25);  ///< Set this bit to enable clock of PWM2.
        constexpr uint32_t PWM3_CLK_EN = (1U << 26);  ///< Set this bit to enable clock of PWM3.
        constexpr uint32_t SPI3_DMA_CLK_EN = (1U << 27);  ///< Set this bit to enable clock of SPI3 DMA.
        constexpr uint32_t APB_SARADC_CLK_EN = (1U << 28);  ///< Set this bit to enable clock of SAR ADC.
        constexpr uint32_t SYSTIMER_CLK_EN = (1U << 29);  ///< Set this bit to enable clock of system timer.
        constexpr uint32_t ADC2_ARB_CLK_EN = (1U << 30);  ///< Set this bit to enable clock of aribiter of ADC2.
        constexpr uint32_t SPI4_CLK_EN = (1U << 31);  ///< Set this bit to enable clock of SPI4.
    }

    /// PERIP_CLK_EN1 Register bits
    namespace perip_clk_en1_bits {
        constexpr uint32_t CRYPTO_AES_CLK_EN = (1U << 1);  ///< Set this bit to enable clock of cryptography AES.
        constexpr uint32_t CRYPTO_SHA_CLK_EN = (1U << 2);  ///< Set this bit to enable clock of cryptography SHA.
        constexpr uint32_t CRYPTO_RSA_CLK_EN = (1U << 3);  ///< Set this bit to enable clock of cryptography RSA.
        constexpr uint32_t CRYPTO_DS_CLK_EN = (1U << 4);  ///< Set this bit to enable clock of cryptography Digital Signature.
        constexpr uint32_t CRYPTO_HMAC_CLK_EN = (1U << 5);  ///< Set this bit to enable clock of cryptography HMAC.
        constexpr uint32_t CRYPTO_DMA_CLK_EN = (1U << 6);  ///< Set this bit to enable clock of cryptography DMA.
    }

    /// PERIP_RST_EN0 Register bits
    namespace perip_rst_en0_bits {
        constexpr uint32_t TIMERS_RST = (1U << 0);  ///< Set this bit to reset timers.
        constexpr uint32_t SPI01_RST = (1U << 1);  ///< Set this bit to reset SPI0 and SPI1.
        constexpr uint32_t UART_RST = (1U << 2);  ///< Set this bit to reset UART0.
        constexpr uint32_t WDG_RST = (1U << 3);  ///< Set this bit to reset WDG.
        constexpr uint32_t I2S0_RST = (1U << 4);  ///< Set this bit to reset I2S0.
        constexpr uint32_t UART1_RST = (1U << 5);  ///< Set this bit to reset UART1.
        constexpr uint32_t SPI2_RST = (1U << 6);  ///< Set this bit to reset SPI2.
        constexpr uint32_t I2C_EXT0_RST = (1U << 7);  ///< Set this bit to reset I2C EXT0.
        constexpr uint32_t UHCI0_RST = (1U << 8);  ///< Set this bit to reset UHCI0.
        constexpr uint32_t RMT_RST = (1U << 9);  ///< Set this bit to reset remote controller.
        constexpr uint32_t PCNT_RST = (1U << 10);  ///< Set this bit to reset pulse count.
        constexpr uint32_t LEDC_RST = (1U << 11);  ///< Set this bit to reset LED PWM.
        constexpr uint32_t UHCI1_RST = (1U << 12);  ///< Set this bit to reset UHCI1.
        constexpr uint32_t TIMERGROUP_RST = (1U << 13);  ///< Set this bit to reset timer group0.
        constexpr uint32_t EFUSE_RST = (1U << 14);  ///< Set this bit to reset eFuse.
        constexpr uint32_t TIMERGROUP1_RST = (1U << 15);  ///< Set this bit to reset timer group1.
        constexpr uint32_t SPI3_RST = (1U << 16);  ///< Set this bit to reset SPI3.
        constexpr uint32_t PWM0_RST = (1U << 17);  ///< Set this bit to reset PWM0.
        constexpr uint32_t I2C_EXT1_RST = (1U << 18);  ///< Set this bit to reset I2C EXT1.
        constexpr uint32_t TWAI_RST = (1U << 19);  ///< Set this bit to reset CAN.
        constexpr uint32_t PWM1_RST = (1U << 20);  ///< Set this bit to reset PWM1.
        constexpr uint32_t I2S1_RST = (1U << 21);  ///< Set this bit to reset I2S1.
        constexpr uint32_t SPI2_DMA_RST = (1U << 22);  ///< Set this bit to reset SPI2 DMA.
        constexpr uint32_t USB_RST = (1U << 23);  ///< Set this bit to reset USB.
        constexpr uint32_t UART_MEM_RST = (1U << 24);  ///< Set this bit to reset UART memory.
        constexpr uint32_t PWM2_RST = (1U << 25);  ///< Set this bit to reset PWM2.
        constexpr uint32_t PWM3_RST = (1U << 26);  ///< Set this bit to reset PWM3.
        constexpr uint32_t SPI3_DMA_RST = (1U << 27);  ///< Set this bit to reset SPI3 DMA.
        constexpr uint32_t APB_SARADC_RST = (1U << 28);  ///< Set this bit to reset SAR ADC.
        constexpr uint32_t SYSTIMER_RST = (1U << 29);  ///< Set this bit to reset system timer.
        constexpr uint32_t ADC2_ARB_RST = (1U << 30);  ///< Set this bit to reset aribiter of ADC2.
        constexpr uint32_t SPI4_RST = (1U << 31);  ///< Set this bit to reset SPI4.
    }

    /// PERIP_RST_EN1 Register bits
    namespace perip_rst_en1_bits {
        constexpr uint32_t CRYPTO_AES_RST = (1U << 1);  ///< Set this bit to reset cryptography AES.
        constexpr uint32_t CRYPTO_SHA_RST = (1U << 2);  ///< Set this bit to reset cryptography SHA.
        constexpr uint32_t CRYPTO_RSA_RST = (1U << 3);  ///< Set this bit to reset cryptography RSA.
        constexpr uint32_t CRYPTO_DS_RST = (1U << 4);  ///< Set this bit to reset cryptography digital signature.
        constexpr uint32_t CRYPTO_HMAC_RST = (1U << 5);  ///< Set this bit to reset cryptography HMAC.
        constexpr uint32_t CRYPTO_DMA_RST = (1U << 6);  ///< Set this bit to reset cryptography DMA.
    }

    /// LPCK_DIV_INT Register bits
    namespace lpck_div_int_bits {
        constexpr uint32_t LPCK_DIV_NUM = (12 << 0);  ///< This field is used to set the integer number of the divider value.
    }

    /// BT_LPCK_DIV_FRAC Register bits
    namespace bt_lpck_div_frac_bits {
        constexpr uint32_t LPCLK_SEL_RTC_SLOW = (1U << 24);  ///< Set this bit to select RTC slow clock as the low power clock.
        constexpr uint32_t LPCLK_SEL_8M = (1U << 25);  ///< Set this bit to select 8m clock as the low power clock.
        constexpr uint32_t LPCLK_SEL_XTAL = (1U << 26);  ///< Set this bit to select xtal clock as the low power clock.
        constexpr uint32_t LPCLK_SEL_XTAL32K = (1U << 27);  ///< Set this bit to select xtal32k clock as the low power clock.
        constexpr uint32_t LPCLK_RTC_EN = (1U << 28);  ///< Set this bit to enable the RTC low power clock.
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< Set this bit to generate CPU interrupt 0. This bit needs to be reset by software in the ISR process.
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< Set this bit to generate CPU interrupt 1. This bit needs to be reset by software in the ISR process.
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< Set this bit to generate CPU interrupt 2. This bit needs to be reset by software in the ISR process.
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< Set this bit to generate CPU interrupt 3. This bit needs to be reset by software in the ISR process.
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_PD = (1U << 0);  ///< Set this bit to power down RSA memory. This bit has the lowest priority. When Digital Signature occupies the RSA, this bit is invalid.
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< Set this bit to force power up RSA memory. This bit has the second highest priority.
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 2);  ///< Set this bit to force power down RSA memory. This bit has the highest priority.
    }

    /// BUSTOEXTMEM_ENA Register bits
    namespace bustoextmem_ena_bits {
        constexpr uint32_t BUSTOEXTMEM_ENA = (1U << 0);  ///< Set this bit to enable bus to EDMA.
    }

    /// CACHE_CONTROL Register bits
    namespace cache_control_bits {
        constexpr uint32_t PRO_ICACHE_CLK_ON = (1U << 0);  ///< Set this bit to enable clock of i-cache.
        constexpr uint32_t PRO_DCACHE_CLK_ON = (1U << 1);  ///< Set this bit to enable clock of d-cache.
        constexpr uint32_t PRO_CACHE_RESET = (1U << 2);  ///< Set this bit to reset cache.
    }

    /// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL Register bits
    namespace external_device_encrypt_decrypt_control_bits {
        constexpr uint32_t ENABLE_SPI_MANUAL_ENCRYPT = (1U << 0);  ///< Set this bit to enable Manual Encryption under SPI Boot mode.
        constexpr uint32_t ENABLE_DOWNLOAD_DB_ENCRYPT = (1U << 1);  ///< Set this bit to enable Auto Encryption under Download Boot mode.
        constexpr uint32_t ENABLE_DOWNLOAD_G0CB_DECRYPT = (1U << 2);  ///< Set this bit to enable Auto Decryption under Download Boot mode.
        constexpr uint32_t ENABLE_DOWNLOAD_MANUAL_ENCRYPT = (1U << 3);  ///< Set this bit to enable Manual Encryption under Download Boot mode.
    }

    /// RTC_FASTMEM_CONFIG Register bits
    namespace rtc_fastmem_config_bits {
        constexpr uint32_t RTC_MEM_CRC_START = (1U << 8);  ///< Set this bit to start the CRC of RTC memory.
        constexpr uint32_t RTC_MEM_CRC_ADDR = (11 << 9);  ///< This field is used to set address of RTC memory for CRC.
        constexpr uint32_t RTC_MEM_CRC_LEN = (11 << 20);  ///< This field is used to set length of RTC memory for CRC based on start address.
        constexpr uint32_t RTC_MEM_CRC_FINISH = (1U << 31);  ///< This bit stores the status of RTC memory CRC. High level means finished while low level means not finished.
    }

    /// RTC_FASTMEM_CRC Register bits
    namespace rtc_fastmem_crc_bits {
        constexpr uint32_t RTC_MEM_CRC_RES = (32 << 0);  ///< This field stores the CRC result of RTC memory.
    }

    /// Redundant_ECO_Ctrl Register bits
    namespace redundant_eco_ctrl_bits {
        constexpr uint32_t REDUNDANT_ECO_DRIVE = (1U << 0);  ///< The redundant ECO drive bit to avoid optimization in circuits.
        constexpr uint32_t REDUNDANT_ECO_RESULT = (1U << 1);  ///< The redundant ECO result bit to avoid optimization in circuits.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Set this bit to enable clock of this module.
    }

    /// SRAM_CTRL_2 Register bits
    namespace sram_ctrl_2_bits {
        constexpr uint32_t SRAM_FORCE_PU = (22 << 0);  ///< This field is used to power up internal SRAM.
    }

    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< This field is used to set the count of prescaler of XTAL\_CLK.
        constexpr uint32_t SOC_CLK_SEL = (2 << 10);  ///< This field is used to select SOC clock.
        constexpr uint32_t CLK_XTAL_FREQ = (7 << 12);  ///< This field is used to read XTAL frequency in MHz.
        constexpr uint32_t CLK_DIV_EN = (1U << 19);  ///< Not used, extends from ESP32.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Version control register.
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t SYSTIMER_BASE = 0x3F423000;
    constexpr uint32_t TIMG0_BASE = 0x3F41F000;
    constexpr uint32_t TIMG1_BASE = 0x3F420000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x00 - Configure system timer clock
        volatile uint32_t LOAD;  ///< Offset: 0x04 - Load value to system timer
        volatile uint32_t LOAD_HI;  ///< Offset: 0x08 - High 32 bits to be loaded to system timer
        volatile uint32_t LOAD_LO;  ///< Offset: 0x0C - Low 32 bits to be loaded to system timer
        volatile uint32_t STEP;  ///< Offset: 0x10 - System timer accumulation step
        volatile uint32_t TARGET0_HI;  ///< Offset: 0x14 - System timer target 0, high 32 bits
        volatile uint32_t TARGET0_LO;  ///< Offset: 0x18 - System timer target 0, low 32 bits
        volatile uint32_t TARGET1_HI;  ///< Offset: 0x1C - System timer target 1, high 32 bits
        volatile uint32_t TARGET1_LO;  ///< Offset: 0x20 - System timer target 1, low 32 bits
        volatile uint32_t TARGET2_HI;  ///< Offset: 0x24 - System timer target 2, high 32 bits
        volatile uint32_t TARGET2_LO;  ///< Offset: 0x28 - System timer target 2, low 32 bits
        volatile uint32_t TARGET0_CONF;  ///< Offset: 0x2C - Configure work mode for system timer target 0
        volatile uint32_t TARGET1_CONF;  ///< Offset: 0x30 - Configure work mode for system timer target 1
        volatile uint32_t TARGET2_CONF;  ///< Offset: 0x34 - Configure work mode for system timer target 2
        volatile uint32_t UNIT0_OP;  ///< Offset: 0x38 - Read out system timer value
        volatile uint32_t UNIT0_VALUE_HI;  ///< Offset: 0x3C - System timer value, high 32 bits
        volatile uint32_t UNIT0_VALUE_LO;  ///< Offset: 0x40 - System timer value, low 32 bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x44 - System timer interrupt enable
        volatile uint32_t INT_RAW;  ///< Offset: 0x48 - System timer interrupt raw
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - System timer interrupt clear
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
    };

    /// Peripheral instances
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t CLK_FO = (1U << 0);  ///< System timer clock force enable.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Register clock enable.
    }

    /// LOAD Register bits
    namespace load_bits {
        constexpr uint32_t TIMER_LOAD = (1U << 31);  ///< Set this bit to 1, the value stored in SYSTIMER_TIMER_LOAD_HI and in SYSTIMER_TIMER_LOAD_LO will be loaded to system timer
    }

    /// LOAD_HI Register bits
    namespace load_hi_bits {
        constexpr uint32_t TIMER_LOAD_HI = (32 << 0);  ///< The value to be loaded into system timer, high 32 bits.
    }

    /// LOAD_LO Register bits
    namespace load_lo_bits {
        constexpr uint32_t TIMER_LOAD_LO = (32 << 0);  ///< The value to be loaded into system timer, low 32 bits.
    }

    /// STEP Register bits
    namespace step_bits {
        constexpr uint32_t TIMER_XTAL_STEP = (10 << 0);  ///< Set system timer increment step when using XTAL_CLK.
        constexpr uint32_t TIMER_PLL_STEP = (10 << 10);  ///< Set system timer increment step when using PLL_CLK
    }

    /// TARGET0_HI Register bits
    namespace target0_hi_bits {
        constexpr uint32_t TIMER_TARGET0_HI = (32 << 0);  ///< System timer target 0, high 32 bits.
    }

    /// TARGET0_LO Register bits
    namespace target0_lo_bits {
        constexpr uint32_t TIMER_TARGET0_LO = (32 << 0);  ///< System timer target 0, low 32 bits.
    }

    /// TARGET1_HI Register bits
    namespace target1_hi_bits {
        constexpr uint32_t TIMER_TARGET1_HI = (32 << 0);  ///< System timer target 1, high 32 bits.
    }

    /// TARGET1_LO Register bits
    namespace target1_lo_bits {
        constexpr uint32_t TIMER_TARGET1_LO = (32 << 0);  ///< System timer target 1, low 32 bits.
    }

    /// TARGET2_HI Register bits
    namespace target2_hi_bits {
        constexpr uint32_t TIMER_TARGET2_HI = (32 << 0);  ///< System timer target 2, high 32 bits.
    }

    /// TARGET2_LO Register bits
    namespace target2_lo_bits {
        constexpr uint32_t TIMER_TARGET2_LO = (32 << 0);  ///< System timer target 2, low 32 bits.
    }

    /// TARGET0_CONF Register bits
    namespace target0_conf_bits {
        constexpr uint32_t TARGET0_PERIOD = (30 << 0);  ///< Set alarm period for system timer target 0, only valid in periodic alarms mode.
        constexpr uint32_t TARGET0_PERIOD_MODE = (1U << 30);  ///< Set work mode for system timer target 0. 0: work in a timedelay alarm mode; 1: work in periodic alarms mode.
        constexpr uint32_t TARGET0_WORK_EN = (1U << 31);  ///< System timer target 0 work enable.
    }

    /// TARGET1_CONF Register bits
    namespace target1_conf_bits {
        constexpr uint32_t TARGET1_PERIOD = (30 << 0);  ///< Set alarm period for system timer target 1, only valid in periodic alarms mode.
        constexpr uint32_t TARGET1_PERIOD_MODE = (1U << 30);  ///< Set work mode for system timer target 1. 0: work in a timedelay alarm mode; 1: work in periodic alarms mode.
        constexpr uint32_t TARGET1_WORK_EN = (1U << 31);  ///< System timer target 1 work enable.
    }

    /// TARGET2_CONF Register bits
    namespace target2_conf_bits {
        constexpr uint32_t TARGET2_PERIOD = (30 << 0);  ///< Set alarm period for system timer target 2, only valid in periodic alarms mode.
        constexpr uint32_t TARGET2_PERIOD_MODE = (1U << 30);  ///< Set work mode for system timer target 2. 0: work in a timedelay alarm mode; 1: work in periodic alarms mode.
        constexpr uint32_t TARGET2_WORK_EN = (1U << 31);  ///< System timer target 2 work enable.
    }

    /// UNIT0_OP Register bits
    namespace unit0_op_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_VALID = (1U << 30);  ///< Check if it is valid to read out timer value from registers. 0: Not ready to read timer value from registers; 1: Ready to read timer value from registers
        constexpr uint32_t TIMER_UNIT0_UPDATE = (1U << 31);  ///< Update system timer value to registers.
    }

    /// UNIT0_VALUE_HI Register bits
    namespace unit0_value_hi_bits {
        constexpr uint32_t TIMER_VALUE_HI = (32 << 0);  ///< System timer value, high 32 bits.
    }

    /// UNIT0_VALUE_LO Register bits
    namespace unit0_value_lo_bits {
        constexpr uint32_t TIMER_VALUE_LO = (32 << 0);  ///< System timer value, low 32 bits.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TARGET0_INT_ENA = (1U << 0);  ///< Interrupt enable bit of system timer target 0.
        constexpr uint32_t TARGET1_INT_ENA = (1U << 1);  ///< Interrupt enable bit of system timer target 1.
        constexpr uint32_t TARGET2_INT_ENA = (1U << 2);  ///< Interrupt enable bit of system timer target 2.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t INT0_RAW = (1U << 0);  ///< Interrupt raw bit of system timer target 0.
        constexpr uint32_t INT1_RAW = (1U << 1);  ///< Interrupt raw bit of system timer target 1.
        constexpr uint32_t INT2_RAW = (1U << 2);  ///< Interrupt raw bit of system timer target 2.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TARGET0_INT_CLR = (1U << 0);  ///< Interrupt clear bit of system timer target 0.
        constexpr uint32_t TARGET1_INT_CLR = (1U << 1);  ///< Interrupt clear bit of system timer target 1.
        constexpr uint32_t TARGET2_INT_CLR = (1U << 2);  ///< Interrupt clear bit of system timer target 2.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Version control register
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x3F42B000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t CMD;  ///< Offset: 0x04 - Command Register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - Interrupt Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bus Timing Register 0
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bus Timing Register 1
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - Arbitration Lost Capture Register
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - Error Code Capture Register
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - Error Warning Limit Register
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Receive Error Counter Register
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Transmit Error Counter Register
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12
        volatile uint32_t RX_MESSAGE_CNT;  ///< Offset: 0x74 - Receive Message Counter Register
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock Divider register
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< This bit is used to configure the operating mode of the TWAI Controller. 1: Reset mode; 0: Operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: Listen only mode. In this mode the nodes will only receive messages from the bus, without generating the acknowledge signal nor updating the RX error counter.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: Self test mode. In this mode the TX nodes can perform a successful transmission without receiving the acknowledge signal. This mode is often used to test a single node with the self reception request command.
        constexpr uint32_t RX_FILTER_MODE = (1U << 3);  ///< This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single filter mode.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQ = (1U << 0);  ///< Set the bit to 1 to allow the driving nodes start transmission.
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< Set the bit to 1 to cancel a pending transmission request.
        constexpr uint32_t RELEASE_BUF = (1U << 2);  ///< Set the bit to 1 to release the RX buffer.
        constexpr uint32_t CLR_OVERRUN = (1U << 3);  ///< Set the bit to 1 to clear the data overrun status bit.
        constexpr uint32_t SELF_RX_REQ = (1U << 4);  ///< Self reception request command. Set the bit to 1 to allow a message be transmitted and received simultaneously.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RX_BUF_ST = (1U << 0);  ///< 1: The data in the RX buffer is not empty, with at least one received data packet.
        constexpr uint32_t OVERRUN_ST = (1U << 1);  ///< 1: The RX FIFO is full and data overrun has occurred.
        constexpr uint32_t TX_BUF_ST = (1U << 2);  ///< 1: The TX buffer is empty, the CPU may write a message into it.
        constexpr uint32_t TX_COMPLETE = (1U << 3);  ///< 1: The TWAI controller has successfully received a packet from the bus.
        constexpr uint32_t RX_ST = (1U << 4);  ///< 1: The TWAI Controller is receiving a message from the bus.
        constexpr uint32_t TX_ST = (1U << 5);  ///< 1: The TWAI Controller is transmitting a message to the bus.
        constexpr uint32_t ERR_ST = (1U << 6);  ///< 1: At least one of the RX/TX error counter has reached or exceeded the value set in register TWAI_ERR_WARNING_LIMIT_REG.
        constexpr uint32_t BUS_OFF_ST = (1U << 7);  ///< 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
        constexpr uint32_t MISS_ST = (1U << 8);  ///< This bit reflects whether the data packet in the RX FIFO is complete. 1: The current packet is missing; 0: The current packet is complete
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_INT_ST = (1U << 0);  ///< Receive interrupt. If this bit is set to 1, it indicates there are messages to be handled in the RX FIFO.
        constexpr uint32_t TX_INT_ST = (1U << 1);  ///< Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis- sion is finished and a new transmission is able to execute.
        constexpr uint32_t ERR_WARN_INT_ST = (1U << 2);  ///< Error warning interrupt. If this bit is set to 1, it indicates the error status signal and the bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or from 1 to 0).
        constexpr uint32_t OVERRUN_INT_ST = (1U << 3);  ///< Data overrun interrupt. If this bit is set to 1, it indicates a data overrun interrupt is generated in the RX FIFO.
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< Error passive interrupt. If this bit is set to 1, it indicates the TWAI Controller is switched between error active status and error passive status due to the change of error counters.
        constexpr uint32_t ARB_LOST_INT_ST = (1U << 6);  ///< Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration lost interrupt is generated.
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< Error interrupt. If this bit is set to 1, it indicates an error is detected on the bus.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable receive interrupt.
        constexpr uint32_t TX_INT_ENA = (1U << 1);  ///< Set this bit to 1 to enable transmit interrupt.
        constexpr uint32_t ERR_WARN_INT_ENA = (1U << 2);  ///< Set this bit to 1 to enable error warning interrupt.
        constexpr uint32_t OVERRUN_INT_ENA = (1U << 3);  ///< Set this bit to 1 to enable data overrun interrupt.
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< Set this bit to 1 to enable error passive interrupt.
        constexpr uint32_t ARB_LOST_INT_ENA = (1U << 6);  ///< Set this bit to 1 to enable arbitration lost interrupt.
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< Set this bit to 1 to enable error interrupt.
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (14 << 0);  ///< Baud Rate Prescaler, determines the frequency dividing ratio.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 14);  ///< Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEG1 = (4 << 0);  ///< The width of PBS1.
        constexpr uint32_t TIME_SEG2 = (3 << 4);  ///< The width of PBS2.
        constexpr uint32_t TIME_SAMP = (1U << 7);  ///< The number of sample points. 0: the bus is sampled once; 1: the bus is sampled three times
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARB_LOST_CAP = (5 << 0);  ///< This register contains information about the bit position of lost arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ECC_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors, see Table 181 for details.
        constexpr uint32_t ECC_DIRECTION = (1U << 5);  ///< This register contains information about transmission direction of the node when error occurs. 1: Error occurs when receiving a message; 0: Error occurs when transmitting a message
        constexpr uint32_t ECC_TYPE = (2 << 6);  ///< This register contains information about error types: 00: bit error; 01: form error; 10: stuff error; 11: other type of error
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< Error warning threshold. In the case when any of a error counter value exceeds the threshold, or all the error counter values are below the threshold, an error warning interrupt will be triggered (given the enable signal is valid).
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register, reflects value changes under reception status.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register, reflects value changes under transmission status.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t TX_BYTE_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, it stores the 0th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t TX_BYTE_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, it stores the 1st byte information of the data to be transmitted under operating mode.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t TX_BYTE_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, it stores the 2nd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t TX_BYTE_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, it stores the 3rd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t TX_BYTE_4 = (8 << 0);  ///< In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, it stores the 4th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t TX_BYTE_5 = (8 << 0);  ///< In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, it stores the 5th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t TX_BYTE_6 = (8 << 0);  ///< In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, it stores the 6th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t TX_BYTE_7 = (8 << 0);  ///< In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, it stores the 7th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t TX_BYTE_8 = (8 << 0);  ///< Stored the 8th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t TX_BYTE_9 = (8 << 0);  ///< Stored the 9th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t TX_BYTE_10 = (8 << 0);  ///< Stored the 10th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t TX_BYTE_11 = (8 << 0);  ///< Stored the 11th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t TX_BYTE_12 = (8 << 0);  ///< Stored the 12th byte information of the data to be transmitted under operating mode.
    }

    /// RX_MESSAGE_CNT Register bits
    namespace rx_message_cnt_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< This register reflects the number of messages available within the RX FIFO.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to configure frequency dividing coefficients of the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< This bit can be configured under reset mode. 1: Disable the external CLKOUT pin; 0: Enable the external CLKOUT pin
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x3F400000;
    constexpr uint32_t UART1_BASE = 0x3F410000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t AUTOBAUD;  ///< Offset: 0x18 - Autobaud configuration register
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0;  ///< Offset: 0x20 - Configuration register 0
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t LOWPULSE;  ///< Offset: 0x28 - Autobaud minimum low pulse duration register
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x2C - Autobaud minimum high pulse duration register
        volatile uint32_t RXD_CNT;  ///< Offset: 0x30 - Autobaud edge change count register
        volatile uint32_t FLOW_CONF;  ///< Offset: 0x34 - Software flow control configuration
        volatile uint32_t SLEEP_CONF;  ///< Offset: 0x38 - Sleep mode configuration
        volatile uint32_t SWFC_CONF0;  ///< Offset: 0x3C - Software flow control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x44 - Frame end idle time configuration
        volatile uint32_t RS485_CONF;  ///< Offset: 0x48 - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x4C - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x50 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x54 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x58 - AT escape sequence selection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x5C - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x60 - TX FIFO write and read offset address
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x64 - RX FIFO write and read offset address
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x68 - UART transmitter and receiver status
        volatile uint32_t POSPULSE;  ///< Offset: 0x6C - Autobaud high pulse register
        volatile uint32_t NEGPULSE;  ///< Offset: 0x70 - Autobaud low pulse register
        volatile uint32_t DATE;  ///< Offset: 0x74 - UART version control register
        volatile uint32_t ID;  ///< Offset: 0x78 - UART ID register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when the receiver receives more data than what UART_RXFIFO_FULL_THRHD specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in TX FIFO is less than what UART_TXFIFO_EMPTY_THRHD specifies.
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when the receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when the receiver detects a data frame error.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when the receiver receives more data than the capacity of RX FIFO.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when the receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when the receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when the receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when the receiver takes more time than UART_RX_TOUT_THRHD to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when the receiver receives an XON character and UART_SW_FLOW_CON_EN is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when the receiver receives an XOFF character and UART_SW_FLOW_CON_EN is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when the receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when the transmitter completes sending NULL characters, after all data in TX FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when the transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when the transmitter has sent out all data in FIFO.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when the receiver detects a parity error from the echo of the transmitter in RS485 mode.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when the receiver detects a data frame error from the echo of the transmitter in RS485 mode.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when a collision is detected between the transmitter and the receiver in RS485 mode.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when the receiver detects the configured UART_AT_CMD CHAR.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input RXD edge changes more times than what UART_ACTIVE_THRESHOLD specifies in Light-sleep mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for UART_RXFIFO_FULL_INT when UART_RXFIFO_FULL_INT_ENA is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for UART_TXFIFO_EMPTY_INT when UART_TXFIFO_EMPTY_INT_ENA is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for UART_PARITY_ERR_INT when UART_PARITY_ERR_INT_ENA is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for UART_FRM_ERR_INT when UART_FRM_ERR_INT_ENA is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for UART_RXFIFO_OVF_INT when UART_RXFIFO_OVF_INT_ENA is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for UART_DSR_CHG_INT when UART_DSR_CHG_INT_ENA is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for UART_CTS_CHG_INT when UART_CTS_CHG_INT_ENA is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for UART_BRK_DET_INT when UART_BRK_DET_INT_ENA is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for UART_RXFIFO_TOUT_INT when UART_RXFIFO_TOUT_INT_ENA is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for UART_SW_XON_INT when UART_SW_XON_INT_ENA is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for UART_SW_XOFF_INT when UART_SW_XOFF_INT_ENA is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for UART_GLITCH_DET_INT when UART_GLITCH_DET_INT_ENA is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for UART_TX_BRK_DONE_INT when UART_TX_BRK_DONE_INT_ENA is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the status bit for UART_TX_BRK_IDLE_DONE_INT when UART_TX_BRK_IDLE_DONE_INT_ENA is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for UART_TX_DONE_INT when UART_TX_DONE_INT_ENA is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for UART_RS485_PARITY_ERR_INT when UART_RS485_PARITY_INT_ENA is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for UART_RS485_FRM_ERR_INT when UART_RS485_FRM_ERR_INT_ENA is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for UART_RS485_CLASH_INT when UART_RS485_CLASH_INT_ENA is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for UART_AT_CMD_CHAR_DET_INT when UART_AT_CMD_CHAR_DET_INT_ENA is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for UART_WAKEUP_INT when UART_WAKEUP_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for UART_RXFIFO_FULL_INT.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for UART_TXFIFO_EMPTY_INT.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for UART_PARITY_ERR_INT.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for UART_FRM_ERR_INT.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for UART_RXFIFO_OVF_INT.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for UART_DSR_CHG_INT.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for UART_CTS_CHG_INT.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for UART_BRK_DET_INT.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for UART_RXFIFO_TOUT_INT.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for UART_SW_XON_INT.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for UART_SW_XOFF_INT.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for UART_GLITCH_DET_INT.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for UART_TX_BRK_DONE_INT.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for UART_TX_BRK_IDLE_DONE_INT.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for UART_TX_DONE_INT.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for UART_RS485_PARITY_ERR_INT.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for UART_RS485_PARITY_ERR_INT.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for UART_RS485_CLASH_INT.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for UART_AT_CMD_CHAR_DET_INT.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for UART_WAKEUP_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear UART_THE RXFIFO_FULL_INT interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear UART_TXFIFO_EMPTY_INT interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear UART_PARITY_ERR_INT interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear UART_FRM_ERR_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear UART_UART_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear UART_DSR_CHG_INT interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear UART_CTS_CHG_INT interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear UART_BRK_DET_INT interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear UART_RXFIFO_TOUT_INT interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear UART_SW_XON_INT interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear UART_SW_XOFF_INT interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear UART_GLITCH_DET_INT interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear UART_TX_BRK_DONE_INT interrupt.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear UART_TX_BRK_IDLE_DONE_INT interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear UART_TX_DONE_INT interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear UART_RS485_PARITY_ERR_INT interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear UART_RS485_FRM_ERR_INT interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear UART_RS485_CLASH_INT interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear UART_AT_CMD_CHAR_DET_INT interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear UART_WAKEUP_INT interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (20 << 0);  ///< The integral part of the frequency divisor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The fractional part of the frequency divisor.
    }

    /// AUTOBAUD Register bits
    namespace autobaud_bits {
        constexpr uint32_t EN = (1U << 0);  ///< This is the enable bit for baud rate detection.
        constexpr uint32_t GLITCH_FILT = (8 << 8);  ///< When input pulse width is lower than this value, the pulse is ignored. This register is used in autobaud detection.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (10 << 0);  ///< Stores the number of valid data bytes in RX FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< This register represents the level of the internal UART DSR signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represents the level of the internal UART CTS signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represents the level of the internal UART RXD signal.
        constexpr uint32_t TXFIFO_CNT = (10 << 16);  ///< Stores the number of data bytes in TX FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal UART DTR signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal UART RTS signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal UART TXD signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode. 0: even. 1: odd.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable UART parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data. 0: 5 bits. 1: 6 bits. 2: 7 bits. 3: 8 bits.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit. 1: 1 bit. 2: 1.5 bits. 3: 2 bits.
        constexpr uint32_t SW_RTS = (1U << 6);  ///< This register is used to configure the software RTS signal which is used in software flow control.
        constexpr uint32_t SW_DTR = (1U << 7);  ///< This register is used to configure the software DTR signal which is used in software flow control.
        constexpr uint32_t TXD_BRK = (1U << 8);  ///< Set this bit to enable the transmitter to send NULL characters when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 9);  ///< Set this bit to enable IrDA loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 10);  ///< This is the start enable bit for IrDA transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 11);  ///< 1: The IrDA transmitter's 11th bit is the same as 10th bit. 0: Set IrDA transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 12);  ///< Set this bit to invert the level of IrDA transmitter.
        constexpr uint32_t IRDA_RX_INV = (1U << 13);  ///< Set this bit to invert the level of IrDA receiver.
        constexpr uint32_t LOOPBACK = (1U << 14);  ///< Set this bit to enable UART loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 15);  ///< Set this bit to enable flow control function for the transmitter.
        constexpr uint32_t IRDA_EN = (1U << 16);  ///< Set this bit to enable IrDA protocol.
        constexpr uint32_t RXFIFO_RST = (1U << 17);  ///< Set this bit to reset the UART RX FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 18);  ///< Set this bit to reset the UART TX FIFO.
        constexpr uint32_t RXD_INV = (1U << 19);  ///< Set this bit to invert the level of UART RXD signal.
        constexpr uint32_t CTS_INV = (1U << 20);  ///< Set this bit to invert the level of UART CTS signal.
        constexpr uint32_t DSR_INV = (1U << 21);  ///< Set this bit to invert the level of UART DSR signal.
        constexpr uint32_t TXD_INV = (1U << 22);  ///< Set this bit to invert the level of UART TXD signal.
        constexpr uint32_t RTS_INV = (1U << 23);  ///< Set this bit to invert the level of UART RTS signal.
        constexpr uint32_t DTR_INV = (1U << 24);  ///< Set this bit to invert the level of UART DTR signal.
        constexpr uint32_t CLK_EN = (1U << 25);  ///< 1: Force clock on for registers. 0: Support clock only when application writes registers.
        constexpr uint32_t ERR_WR_MASK = (1U << 26);  ///< 1: The receiver stops storing data into FIFO when data is wrong. 0: The receiver stores the data even if the received data is wrong.
        constexpr uint32_t TICK_REF_ALWAYS_ON = (1U << 27);  ///< This register is used to select the clock. 1: APB_CLK. 0: REF_TICK.
        constexpr uint32_t MEM_CLK_EN = (1U << 28);  ///< The signal to enable UART RAM clock gating. 1: UART RAM powers on, the data of which can be read and written. 0: UART RAM powers down.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (9 << 0);  ///< An UART_RXFIFO_FULL_INT interrupt is generated when the receiver receives more data than this register’s value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (9 << 9);  ///< An UART_TXFIFO_EMPTY_INT interrupt is generated when the number of data bytes in TX FIFO is less than this register's value.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 29);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 30);  ///< This is the flow enable bit for UART receiver. 1: Choose software flow control with configuring sw_rts signal. 0: Disable software flow control.
        constexpr uint32_t RX_TOUT_EN = (1U << 31);  ///< This is the enable bit for UART receiver's timeout function.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (20 << 0);  ///< This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate detection.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (20 << 0);  ///< This register stores the value of the maximum duration time for the high level pulse. It is used in baud rate detection.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of RXD edge change. It is used in baud rate detection. As baud rate registers UART_REG_LOWPULSE_MIN_CNT, UART_REG_HIGHPULSE_MIN_CNT, UART_REG_POSEDGE_MIN_CNT, and UART_REG_NEGEDGE_MIN_CNT always record the minimal value, UART_REG_RXD_EDGE_CNT indicates the statistic number of RXD edge to find out the minimal value for these baud rate registers.
    }

    /// FLOW_CONF Register bits
    namespace flow_conf_bits {
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 0);  ///< Set this bit to enable software flow control. When UART receives flow control characters XON or XOFF, which can be configured by UART_XON_CHAR or UART_XOFF_CHAR respectively, UART_SW_XON_INT or UART_SW_XOFF_INT interrupts can be triggered if enabled.
        constexpr uint32_t XONOFF_DEL = (1U << 1);  ///< Set this bit to remove flow control characters from the received data.
        constexpr uint32_t FORCE_XON = (1U << 2);  ///< Set this bit to force the transmitter to send data.
        constexpr uint32_t FORCE_XOFF = (1U << 3);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 4);  ///< Set this bit to send an XON character. This bit is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 5);  ///< Set this bit to send an XOFF character. This bit is cleared by hardware automatically.
    }

    /// SLEEP_CONF Register bits
    namespace sleep_conf_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The UART is activated from Light-sleep mode when the input RXD edge changes more times than this register's value.
    }

    /// SWFC_CONF0 Register bits
    namespace swfc_conf0_bits {
        constexpr uint32_t XOFF_THRESHOLD = (9 << 0);  ///< When the number of data bytes in RX FIFO is more than this register's value with UART_SW_FLOW_CON_EN set to 1, the transmitter sends an XOFF character.
        constexpr uint32_t XOFF_CHAR = (8 << 9);  ///< This register stores the XOFF flow control character.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (9 << 0);  ///< When the number of data bytes in RX FIFO is less than this register's value with UART_SW_FLOW_CON_EN set to 1, the transmitter sends an XON character.
        constexpr uint32_t XON_CHAR = (8 << 9);  ///< This register stores the XON flow control character.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< A frame end signal is generated when the receiver takes more time to receive one byte data than this register's value, in the unit of bit time (the time it takes to transfer one bit).
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers, in the unit of bit time (the time it takes to transfer one bit).
        constexpr uint32_t TX_BRK_NUM = (8 << 20);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when UART_TXD_BRK is set to 1.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose RS485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable the receiver could receive data when the transmitter is transmitting data in RS485 mode.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1: enable RS485 transmitter to send data when RS485 receiver line is busy. 0: RS485 transmitter should not send data when its receiver is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first AT_CMD is received by the receiver. It will not take the next data received as AT_CMD character when the duration is less than this register's value.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last AT_CMD and the next data. It will not take the previous data as AT_CMD character when the duration is less than this register's value.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the AT_CMD characters. It will not take the data as continuous AT_CMD characters when the duration time is less than this register's value.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of AT_CMD character.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the number of continuous AT_CMD characters received by the receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t RX_SIZE = (3 << 1);  ///< This register is used to configure the amount of RAM allocated for RX FIFO. The default number is 128 bytes.
        constexpr uint32_t TX_SIZE = (3 << 4);  ///< This register is used to configure the amount of RAM allocated for TX FIFO. The default number is 128 bytes.
        constexpr uint32_t RX_FLOW_THRHD = (9 << 7);  ///< This register is used to configure the maximum amount of data bytes that can be received when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 16);  ///< This register is used to configure the threshold time that the receiver takes to receive one byte, in the unit of bit time (the time it takes to transfer one bit). The UART_RXFIFO_TOUT_INT interrupt will be triggered when the receiver takes more time to receive one byte with UART RX_TOUT_EN set to 1.
        constexpr uint32_t MEM_FORCE_PD = (1U << 26);  ///< Set this bit to force power down UART RAM.
        constexpr uint32_t MEM_FORCE_PU = (1U << 27);  ///< Set this bit to force power up UART RAM.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t APB_TX_WADDR = (10 << 0);  ///< This register stores the offset address in TX FIFO when software writes TX FIFO via APB.
        constexpr uint32_t TX_RADDR = (10 << 11);  ///< This register stores the offset address in TX FIFO when TX FSM reads data via Tx_FIFO_Ctrl.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t APB_RX_RADDR = (10 << 0);  ///< This register stores the offset address in RX_FIFO when software reads data from RX FIFO via APB.
        constexpr uint32_t RX_WADDR = (10 << 11);  ///< This register stores the offset address in RX FIFO when Rx_FIFO_Ctrl writes RX FIFO.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of the receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of the transmitter.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (20 << 0);  ///< This register stores the minimal input clock count between two positive edges. It is used in baud rate detection.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (20 << 0);  ///< This register stores the minimal input clock count between two negative edges. It is used in baud rate detection.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version control register.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (32 << 0);  ///< This register is used to configure the UART_ID.
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x3F414000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - UHCI configuration register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t DMA_OUT_STATUS;  ///< Offset: 0x14 - DMA data-output status register
        volatile uint32_t DMA_OUT_PUSH;  ///< Offset: 0x18 - Push control register of TX FIFO
        volatile uint32_t DMA_IN_STATUS;  ///< Offset: 0x1C - UHCI data-input status register
        volatile uint32_t DMA_IN_POP;  ///< Offset: 0x20 - Pop control register of RX FIFO
        volatile uint32_t DMA_OUT_LINK;  ///< Offset: 0x24 - Link descriptor address and control
        volatile uint32_t DMA_IN_LINK;  ///< Offset: 0x28 - Link descriptor address and control
        volatile uint32_t CONF1;  ///< Offset: 0x2C - UHCI configuration register
        volatile uint32_t STATE0;  ///< Offset: 0x30 - UHCI decoder status register
        volatile uint32_t STATE1;  ///< Offset: 0x34 - UHCI encoder status register
        volatile uint32_t DMA_OUT_EOF_DES_ADDR;  ///< Offset: 0x38 - Outlink descriptor address when EOF occurs
        volatile uint32_t DMA_IN_SUC_EOF_DES_ADDR;  ///< Offset: 0x3C - Inlink descriptor address when EOF occurs
        volatile uint32_t DMA_IN_ERR_EOF_DES_ADDR;  ///< Offset: 0x40 - Inlink descriptor address when errors occur
        volatile uint32_t DMA_OUT_EOF_BFR_DES_ADDR;  ///< Offset: 0x44 - Outlink descriptor address before the last transmit descriptor
        volatile uint32_t AHB_TEST;  ///< Offset: 0x48 - AHB test register
        volatile uint32_t DMA_IN_DSCR;  ///< Offset: 0x4C - The third word of the next receive descriptor
        volatile uint32_t DMA_IN_DSCR_BF0;  ///< Offset: 0x50 - The third word of current receive descriptor
        volatile uint32_t DMA_OUT_DSCR;  ///< Offset: 0x58 - The third word of the next transmit descriptor
        volatile uint32_t DMA_OUT_DSCR_BF0;  ///< Offset: 0x5C - The third word of current transmit descriptor
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x64 - Escape character configuration
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x68 - Timeout configuration
        volatile uint32_t RX_HEAD;  ///< Offset: 0x70 - UHCI packet header register
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x74 - UHCI quick_sent configuration register
        volatile uint32_t Q0_WORD0;  ///< Offset: 0x78 - Q0_WORD0 quick_sent register
        volatile uint32_t Q0_WORD1;  ///< Offset: 0x7C - Q0_WORD1 quick_sent register
        volatile uint32_t Q1_WORD0;  ///< Offset: 0x80 - Q1_WORD0 quick_sent register
        volatile uint32_t Q1_WORD1;  ///< Offset: 0x84 - Q1_WORD1 quick_sent register
        volatile uint32_t Q2_WORD0;  ///< Offset: 0x88 - Q2_WORD0 quick_sent register
        volatile uint32_t Q2_WORD1;  ///< Offset: 0x8C - Q2_WORD1 quick_sent register
        volatile uint32_t Q3_WORD0;  ///< Offset: 0x90 - Q3_WORD0 quick_sent register
        volatile uint32_t Q3_WORD1;  ///< Offset: 0x94 - Q3_WORD1 quick_sent register
        volatile uint32_t Q4_WORD0;  ///< Offset: 0x98 - Q4_WORD0 quick_sent register
        volatile uint32_t Q4_WORD1;  ///< Offset: 0x9C - Q4_WORD1 quick_sent register
        volatile uint32_t Q5_WORD0;  ///< Offset: 0xA0 - Q5_WORD0 quick_sent register
        volatile uint32_t Q5_WORD1;  ///< Offset: 0xA4 - Q5_WORD1 quick_sent register
        volatile uint32_t Q6_WORD0;  ///< Offset: 0xA8 - Q6_WORD0 quick_sent register
        volatile uint32_t Q6_WORD1;  ///< Offset: 0xAC - Q6_WORD1 quick_sent register
        volatile uint32_t ESC_CONF0;  ///< Offset: 0xB0 - Escape sequence configuration register 0
        volatile uint32_t ESC_CONF1;  ///< Offset: 0xB4 - Escape sequence configuration register 1
        volatile uint32_t ESC_CONF2;  ///< Offset: 0xB8 - Escape sequence configuration register 2
        volatile uint32_t ESC_CONF3;  ///< Offset: 0xBC - Escape sequence configuration register 3
        volatile uint32_t PKT_THRES;  ///< Offset: 0xC0 - Configure register for packet length
        volatile uint32_t DATE;  ///< Offset: 0xFC - UHCI version control register
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< Set this bit to reset in DMA FSM.
        constexpr uint32_t OUT_RST = (1U << 1);  ///< Set this bit to reset out DMA FSM.
        constexpr uint32_t AHBM_FIFO_RST = (1U << 2);  ///< Set this bit to reset AHB interface cmdFIFO of DMA.
        constexpr uint32_t AHBM_RST = (1U << 3);  ///< Set this bit to reset AHB interface of DMA.
        constexpr uint32_t IN_LOOP_TEST = (1U << 4);  ///< Reserved.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 5);  ///< Reserved.
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 6);  ///< Set this bit to enable automatic outlink writeback when all the data in TX FIFO has been transmitted.
        constexpr uint32_t OUT_NO_RESTART_CLR = (1U << 7);  ///< Reserved.
        constexpr uint32_t OUT_EOF_MODE = (1U << 8);  ///< This register is used to specify the generation mode of UHCI_OUT_EOF_INT interrupt. 1: When DMA has popped all data from FIFO. 0: When AHB has pushed all data to FIFO.
        constexpr uint32_t UART0_CE = (1U << 9);  ///< Set this bit to link up UHCI and UART0.
        constexpr uint32_t UART1_CE = (1U << 10);  ///< Set this bit to link up UHCI and UART1.
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 12);  ///< This register is used to specify DMA transmit descriptor transfer mode. 1: burst mode. 0: byte mode.
        constexpr uint32_t INDSCR_BURST_EN = (1U << 13);  ///< This register is used to specify DMA receive descriptor transfer mode. 1: burst mode. 0: byte mode.
        constexpr uint32_t MEM_TRANS_EN = (1U << 15);  ///< 1: UHCI transmitted data would be write back into DMA INFIFO.
        constexpr uint32_t SEPER_EN = (1U << 16);  ///< Set this bit to separate the data frame using a special character.
        constexpr uint32_t HEAD_EN = (1U << 17);  ///< Set this bit to encode the data packet with a formatting header.
        constexpr uint32_t CRC_REC_EN = (1U << 18);  ///< Set this bit to enable UHCI to receive the 16 bit CRC.
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 19);  ///< If this bit is set to 1, UHCI will end the payload receiving process when UART has been in idle state.
        constexpr uint32_t LEN_EOF_EN = (1U << 20);  ///< If this bit is set to 1, UHCI decoder stops receiving payload data when the number of received data bytes has reached the specified value. The value is payload length indicated by UCHI packet header when UHCI_HEAD_EN is 1 or the value is a configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI decoder stops receiving payload data upon receiving 0xC0.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 21);  ///< Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to the end of the payload.
        constexpr uint32_t CLK_EN = (1U << 22);  ///< 1: Force clock on for registers. 0: Support clock only when application writes registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 23);  ///< If this bit is set to 1, UHCI stops receiving payload data when a NULL frame is received by UART.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< This is the interrupt raw bit for UHCI_RX_START_INT interrupt. The interrupt is triggered when a separator has been sent.
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< This is the interrupt raw bit for UHCI_TX_START_INT interrupt. The interrupt is triggered when DMA detects a separator.
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< This is the interrupt raw bit for UHCI_RX_HUNG_INT interrupt. The interrupt is triggered when DMA takes more time to receive data than the configure value.
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< This is the interrupt raw bit for UHCI_TX_HUNG_INT interrupt. The interrupt is triggered when DMA takes more time to read data from RAM than the configured value.
        constexpr uint32_t IN_DONE_INT_RAW = (1U << 4);  ///< This is the interrupt raw bit for UHCI_IN_DONE_INT interrupt. The interrupt is triggered when an receive descriptor is completed.
        constexpr uint32_t IN_SUC_EOF_INT_RAW = (1U << 5);  ///< This is the interrupt raw bit for UHCI_IN_SUC_EOF_INT interrupt. The interrupt is triggered when a data packet has been received successfully.
        constexpr uint32_t IN_ERR_EOF_INT_RAW = (1U << 6);  ///< This is the interrupt raw bit for UHCI_IN_ERR_EOF_INT interrupt. The interrupt is triggered when there are some errors in EOF in the receive descriptor.
        constexpr uint32_t OUT_DONE_INT_RAW = (1U << 7);  ///< This is the interrupt raw bit for UHCI_OUT_DONE_INT interrupt. The interrupt is triggered when an transmit descriptor is completed.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 8);  ///< This is the interrupt raw bit for UHCI_OUT_EOF_INT interrupt. The interrupt is triggered when the current descriptor's EOF bit is 1.
        constexpr uint32_t IN_DSCR_ERR_INT_RAW = (1U << 9);  ///< This is the interrupt raw bit for UHCI_IN_DSCR_ERR_INT interrupt. The interrupt is triggered when there are some errors in the receive descriptor.
        constexpr uint32_t OUT_DSCR_ERR_INT_RAW = (1U << 10);  ///< This is the interrupt raw bit for UHCI_OUT_DSCR_ERR_INT interrupt. The interrupt is triggered when there are some errors in the transmit descriptor.
        constexpr uint32_t IN_DSCR_EMPTY_INT_RAW = (1U << 11);  ///< This is the interrupt raw bit for UHCI_IN_DSCR_EMPTY_INT interrupt. The interrupt is triggered when there are not enough inlinks for DMA.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_RAW = (1U << 12);  ///< This is the interrupt raw bit for UHCI_OUTLINK_EOF_ERR_INT interrupt. The interrupt is triggered when there are some errors in EOF in the transmit descriptor.
        constexpr uint32_t OUT_TOTAL_EOF_INT_RAW = (1U << 13);  ///< This is the interrupt raw bit for UHCI_OUT_TOTAL_EOF_INT interrupt. The interrupt is triggered when all data in the last buffer address has been sent out.
        constexpr uint32_t SEND_S_REG_Q_INT_RAW = (1U << 14);  ///< This is the interrupt raw bit for UHCI_SEND_S_REG_Q_INT interrupt. The interrupt is triggered when DMA has sent out a short packet using single_send mode.
        constexpr uint32_t SEND_A_REG_Q_INT_RAW = (1U << 15);  ///< This is the interrupt raw bit for UHCI_SEND_A_REG_Q_INT interrupt. The interrupt is triggered when DMA has sent out a short packet using always_send mode.
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_RAW = (1U << 16);  ///< This is the interrupt raw bit for UHCI_DMA_INFIFO_FULL_WM_INT interrupt. The interrupt is triggered when the number of data bytes in DMA RX FIFO has reached the configured threshold value.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< This is the masked interrupt bit for UHCI_RX_START_INT interrupt when UHCI_RX_START_INT_ENA is set to 1.
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< This is the masked interrupt bit for UHCI_TX_START_INT interrupt when UHCI_TX_START_INT_ENA is set to 1.
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< This is the masked interrupt bit for UHCI_RX_HUNG_INT interrupt when UHCI_RX_HUNG_INT_ENA is set to 1.
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< This is the masked interrupt bit for UHCI_TX_HUNG_INT interrupt when UHCI_TX_HUNG_INT_ENA is set to 1.
        constexpr uint32_t IN_DONE_INT_ST = (1U << 4);  ///< This is the masked interrupt bit for UHCI_IN_DONE_INT interrupt when UHCI_IN_DONE_INT_ENA is set to 1.
        constexpr uint32_t IN_SUC_EOF_INT_ST = (1U << 5);  ///< This is the masked interrupt bit for UHCI_IN_SUC_EOF_INT interrupt when UHCI_IN_SUC_EOF_INT_ENA is set to 1.
        constexpr uint32_t IN_ERR_EOF_INT_ST = (1U << 6);  ///< This is the masked interrupt bit for UHCI_IN_ERR_EOF_INT interrupt when UHCI_IN_ERR_EOF_INT_ENA is set to 1.
        constexpr uint32_t OUT_DONE_INT_ST = (1U << 7);  ///< This is the masked interrupt bit for UHCI_OUT_DONE_INT interrupt when UHCI_OUT_DONE_INT_ENA is set to 1.
        constexpr uint32_t OUT_EOF_INT_ST = (1U << 8);  ///< This is the masked interrupt bit for UHCI_OUT_EOF_INT interrupt when UHCI_OUT_EOF_INT_ENA is set to 1.
        constexpr uint32_t IN_DSCR_ERR_INT_ST = (1U << 9);  ///< This is the masked interrupt bit for UHCI_IN_DSCR_ERR_INT interrupt when UHCI_IN_DSCR_ERR_INT is set to 1.
        constexpr uint32_t OUT_DSCR_ERR_INT_ST = (1U << 10);  ///< This is the masked interrupt bit for UHCI_OUT_DSCR_ERR_INT interrupt when UHCI_OUT_DSCR_ERR_INT_ENA is set to 1.
        constexpr uint32_t IN_DSCR_EMPTY_INT_ST = (1U << 11);  ///< This is the masked interrupt bit for UHCI_IN_DSCR_EMPTY_INT interrupt when UHCI_IN_DSCR_EMPTY_INT_ENA is set to 1.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 12);  ///< This is the masked interrupt bit for UHCI_OUTLINK_EOF_ERR_INT interrupt when UHCI_OUTLINK_EOF_ERR_INT_ENA is set to 1.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ST = (1U << 13);  ///< This is the masked interrupt bit for UHCI_OUT_TOTAL_EOF_INT interrupt when UHCI_OUT_TOTAL_EOF_INT_ENA is set to 1.
        constexpr uint32_t SEND_S_REG_Q_INT_ST = (1U << 14);  ///< This is the masked interrupt bit for UHCI_SEND_S_REG_Q_INT interrupt when UHCI_SEND_S_REG_Q_INT_ENA is set to 1.
        constexpr uint32_t SEND_A_REG_Q_INT_ST = (1U << 15);  ///< This is the masked interrupt bit for UHCI_SEND_A_REG_Q_INT interrupt when UHCI_SEND_A_REG_Q_INT_ENA is set to 1.
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ST = (1U << 16);  ///< This is the masked interrupt bit for UHCI_DMA_INFIFO_FULL_WM_INT INTERRUPT when UHCI_DMA_INFIFO_FULL_WM_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< This is the interrupt enable bit for UHCI_RX_START_INT interrupt.
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< This is the interrupt enable bit for UHCI_TX_START_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< This is the interrupt enable bit for UHCI_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< This is the interrupt enable bit for UHCI_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_ENA = (1U << 4);  ///< This is the interrupt enable bit for UHCI_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_ENA = (1U << 5);  ///< This is the interrupt enable bit for UHCI_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_ENA = (1U << 6);  ///< This is the interrupt enable bit for UHCI_IN_ERR_EOF_INT interrupt.
        constexpr uint32_t OUT_DONE_INT_ENA = (1U << 7);  ///< This is the interrupt enable bit for UHCI_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_ENA = (1U << 8);  ///< This is the interrupt enable bit for UHCI_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_ENA = (1U << 9);  ///< This is the interrupt enable bit for UHCI_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_ENA = (1U << 10);  ///< This is the interrupt enable bit for UHCI_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_ENA = (1U << 11);  ///< This is the interrupt enable bit for UHCI_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 12);  ///< This is the interrupt enable bit for UHCI_OUTLINK_EOF_ERR_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_ENA = (1U << 13);  ///< This is the interrupt enable bit for UHCI_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t SEND_S_REG_Q_INT_ENA = (1U << 14);  ///< This is the interrupt enable bit for UHCI_SEND_S_REG_Q_INT interrupt.
        constexpr uint32_t SEND_A_REG_Q_INT_ENA = (1U << 15);  ///< This is the interrupt enable bit for UHCI_SEND_A_REG_Q_INT interrupt.
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ENA = (1U << 16);  ///< This is the interrupt enable bit for UHCI_DMA_INFIFO_FULL_WM_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< Set this bit to clear UHCI_RX_START_INT interrupt.
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< Set this bit to clear UHCI_TX_START_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear UHCI_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear UHCI_TX_HUNG_INT interrupt.
        constexpr uint32_t IN_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear UHCI_IN_DONE_INT interrupt.
        constexpr uint32_t IN_SUC_EOF_INT_CLR = (1U << 5);  ///< Set this bit to clear UHCI_IN_SUC_EOF_INT interrupt.
        constexpr uint32_t IN_ERR_EOF_INT_CLR = (1U << 6);  ///< Set this bit to clear UHCI_IN_ERR_EOF_INT interrupt.
        constexpr uint32_t OUT_DONE_INT_CLR = (1U << 7);  ///< Set this bit to clear UHCI_OUT_DONE_INT interrupt.
        constexpr uint32_t OUT_EOF_INT_CLR = (1U << 8);  ///< Set this bit to clear UHCI_OUT_EOF_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR_INT_CLR = (1U << 9);  ///< Set this bit to clear UHCI_IN_DSCR_ERR_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR_INT_CLR = (1U << 10);  ///< Set this bit to clear UHCI_OUT_DSCR_ERR_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY_INT_CLR = (1U << 11);  ///< Set this bit to clear UHCI_IN_DSCR_EMPTY_INT interrupt.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 12);  ///< Set this bit to clear UHCI_OUTLINK_EOF_ERR_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF_INT_CLR = (1U << 13);  ///< Set this bit to clear UHCI_OUT_TOTAL_EOF_INT interrupt.
        constexpr uint32_t SEND_S_REG_Q_INT_CLR = (1U << 14);  ///< Set this bit to clear UHCI_SEND_S_REG_Q_INT interrupt.
        constexpr uint32_t SEND_A_REG_Q_INT_CLR = (1U << 15);  ///< Set this bit to clear UHCI_SEND_A_REG_Q_INT interrupt.
        constexpr uint32_t DMA_INFIFO_FULL_WM_INT_CLR = (1U << 16);  ///< Set this bit to clear UHCI_DMA_INFIFO_FULL_WM_INT interrupt.
    }

    /// DMA_OUT_STATUS Register bits
    namespace dma_out_status_bits {
        constexpr uint32_t OUT_FULL = (1U << 0);  ///< 1: DMA TX FIFO is full.
        constexpr uint32_t OUT_EMPTY = (1U << 1);  ///< 1: DMA TX FIFO is empty.
    }

    /// DMA_OUT_PUSH Register bits
    namespace dma_out_push_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This is the data that need to be pushed into TX FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 16);  ///< Set this bit to push data into TX FIFO.
    }

    /// DMA_IN_STATUS Register bits
    namespace dma_in_status_bits {
        constexpr uint32_t IN_FULL = (1U << 0);  ///< Data-input FIFO full signal.
        constexpr uint32_t IN_EMPTY = (1U << 1);  ///< Data-input FIFO empty signal.
        constexpr uint32_t RX_ERR_CAUSE = (3 << 4);  ///< This register indicates the error type when DMA has received a packet with error. 3'b001: Checksum error in the HCI packet; 3'b010: Sequence number error in the HCI packet; 3'b011: CRC bit error in the HCI packet; 3'b100: 0xC0 is found but the received HCI packet is not end; 3'b101: 0xC0 is not found when the HCI packet has been received; 3'b110: CRC check error.
    }

    /// DMA_IN_POP Register bits
    namespace dma_in_pop_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from RX FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 16);  ///< Set this bit to pop data from RX FIFO.
    }

    /// DMA_OUT_LINK Register bits
    namespace dma_out_link_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register is used to specify the least significant 20 bits of the first transmit descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 28);  ///< Set this bit to stop dealing with the transmit descriptor.
        constexpr uint32_t OUTLINK_START = (1U << 29);  ///< Set this bit to start a new transmit descriptor.
        constexpr uint32_t OUTLINK_RESTART = (1U << 30);  ///< Set this bit to restart the transmit descriptor from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 31);  ///< 1: the transmit descriptor's FSM is in idle state. 0: the transmit descriptor's FSM is working.
    }

    /// DMA_IN_LINK Register bits
    namespace dma_in_link_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register is used to specify the least significant 20 bits of the first receive descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< This is the enable bit to return to current receive descriptor's address, when there are some errors in current packet.
        constexpr uint32_t INLINK_STOP = (1U << 28);  ///< Set this bit to stop dealing with the receive descriptors.
        constexpr uint32_t INLINK_START = (1U << 29);  ///< Set this bit to start dealing with the receive descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 30);  ///< Set this bit to restart new receive descriptors.
        constexpr uint32_t INLINK_PARK = (1U << 31);  ///< 1: the receive descriptor's FSM is in idle state. 0: the receive descriptor's FSM is working.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< This is the enable bit to check header checksum when UHCI receives a data packet.
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< This is the enable bit to check sequence number when UHCI receives a data packet.
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< Set this bit to support CRC calculation. Data Integrity check present bit in UHCI packet frame should be 1.
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< Set this bit to save the packet header when UHCI receives a data packet.
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< Set this bit to encode the data packet with a checksum.
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< Set this bit to encode the data packet with an acknowledgement when a reliable packet is to be transmit.
        constexpr uint32_t CHECK_OWNER = (1U << 6);  ///< 1: Check the link list descriptor when link list owner is DMA controller; 0: Always check link list descriptor.
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< The UHCI encoder will jump to ST_SW_WAIT status if this register is set to 1.
        constexpr uint32_t SW_START = (1U << 8);  ///< If current UHCI_ENCODE_STATE is ST_SW_WAIT, the UHCI will start to send data packet out when this bit is set to 1.
        constexpr uint32_t DMA_INFIFO_FULL_THRS = (12 << 9);  ///< This field is used to generate the UHCI_DMA_INFIFO_FULL_WM_INT interrupt when the counter value of DMA RX FIFO exceeds the value of the register.
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current receive descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< Reserved.
        constexpr uint32_t IN_STATE = (3 << 20);  ///< Reserved.
        constexpr uint32_t INFIFO_CNT_DEBUG = (5 << 23);  ///< This register stores the number of data bytes in RX FIFO.
        constexpr uint32_t DECODE_STATE = (3 << 28);  ///< UHCI decoder status.
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current transmit descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< Reserved.
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< Reserved.
        constexpr uint32_t OUTFIFO_CNT = (5 << 23);  ///< This register stores the number of data bytes in TX FIFO.
        constexpr uint32_t ENCODE_STATE = (3 << 28);  ///< UHCI encoder status.
    }

    /// DMA_OUT_EOF_DES_ADDR Register bits
    namespace dma_out_eof_des_addr_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the transmit descriptor when the EOF bit in this descriptor is 1.
    }

    /// DMA_IN_SUC_EOF_DES_ADDR Register bits
    namespace dma_in_suc_eof_des_addr_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the receive descriptor when received successful EOF.
    }

    /// DMA_IN_ERR_EOF_DES_ADDR Register bits
    namespace dma_in_err_eof_des_addr_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the receive descriptor when there are some errors in this descriptor.
    }

    /// DMA_OUT_EOF_BFR_DES_ADDR Register bits
    namespace dma_out_eof_bfr_des_addr_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the transmit descriptor before the last transmit descriptor.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< Reserved.
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< Reserved.
    }

    /// DMA_IN_DSCR Register bits
    namespace dma_in_dscr_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< This register stores the third word of the next receive descriptor.
    }

    /// DMA_IN_DSCR_BF0 Register bits
    namespace dma_in_dscr_bf0_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< This register stores the third word of the current receive descriptor.
    }

    /// DMA_OUT_DSCR Register bits
    namespace dma_out_dscr_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< This register stores the third word of the next transmit descriptor.
    }

    /// DMA_OUT_DSCR_BF0 Register bits
    namespace dma_out_dscr_bf0_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< This register stores the third word of the current transmit descriptor.
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< Set this bit to decode character 0xC0 when DMA receives data.
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< Set this bit to decode character 0xDB when DMA receives data.
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< Set this bit to decode flow control character 0x11 when DMA receives data.
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< Set this bit to decode flow control character 0x13 when DMA receives data.
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< Set this bit to replace 0xC0 by special characters when DMA sends data.
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< Set this bit to replace 0xDB by special characters when DMA sends data.
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< Set this bit to replace flow control character 0x11 by special characters when DMA sends data.
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< Set this bit to replace flow control character 0x13 by special characters when DMA sends data.
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< This register stores the timeout value. UHCI produce the UHCI_TX_HUNG_INT interrupt when DMA takes more time to receive data.
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< This register is used to configure the maximum tick count.
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< This is the enable bit for TX FIFO receive timeout.
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< This register stores the timeout value. UHCI produce the UHCI_RX_HUNG_INT interrupt when DMA takes more time to read data from RAM.
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< This register is used to configure the maximum tick count.
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< This is the enable bit for DMA send timeout.
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< This register stores the header of the current received packet.
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< This register is used to specify the single_send mode.
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< Set this bit to enable single_send mode to send short packets.
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< This register is used to specify the always_send mode.
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< Set this bit to enable always_send mode to send short packets.
    }

    /// Q0_WORD0 Register bits
    namespace q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q0_WORD1 Register bits
    namespace q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q1_WORD0 Register bits
    namespace q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q1_WORD1 Register bits
    namespace q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q2_WORD0 Register bits
    namespace q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q2_WORD1 Register bits
    namespace q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q3_WORD0 Register bits
    namespace q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q3_WORD1 Register bits
    namespace q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q4_WORD0 Register bits
    namespace q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q4_WORD1 Register bits
    namespace q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q5_WORD0 Register bits
    namespace q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q5_WORD1 Register bits
    namespace q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q6_WORD0 Register bits
    namespace q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// Q6_WORD1 Register bits
    namespace q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when mode is specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< This register is used to define separators to encode data packets. The default value is 0xC0.
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< This register is used to define the first character of SLIP escape sequence. The default value is 0xDB.
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< This register is used to define the second character of SLIP escape sequence. The default value is 0xDC.
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< This register is used to define a character that need to be encoded. The default value is 0xDB that used as the first character of SLIP escape sequence.
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< This register is used to define the first character of SLIP escape sequence. The default value is 0xDB.
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< This register is used to define the second character of SLIP escape sequence. The default value is 0xDD.
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< This register is used to define a character that need to be encoded. The default value is 0x11 that used as a flow control character.
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< This register is used to define the first character of SLIP escape sequence. The default value is 0xDB.
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< This register is used to define the second character of SLIP escape sequence. The default value is 0xDE.
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< This register is used to define a character that need to be decoded. The default value is 0x13 that used as a flow control character.
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< This register is used to define the first character of SLIP escape sequence. The default value is 0xDB.
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< This register is used to define the second character of SLIP escape sequence. The default value is 0xDF.
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< This register is used to configure the maximum value of the packet length when UHCI_HEAD_EN is 0.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x60080000;
    constexpr uint32_t USB_WRAP_BASE = 0x3F439000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - 
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - 
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - 
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - 
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - 
        volatile uint32_t GINTSTS;  ///< Offset: 0x14 - 
        volatile uint32_t GINTMSK;  ///< Offset: 0x18 - 
        volatile uint32_t GRXSTSR;  ///< Offset: 0x1C - 
        volatile uint32_t GRXSTSP;  ///< Offset: 0x20 - 
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - 
        volatile uint32_t GNPTXFSIZ;  ///< Offset: 0x28 - 
        volatile uint32_t GNPTXSTS;  ///< Offset: 0x2C - 
        volatile uint32_t GSNPSID;  ///< Offset: 0x40 - 
        volatile uint32_t GHWCFG1;  ///< Offset: 0x44 - 
        volatile uint32_t GHWCFG2;  ///< Offset: 0x48 - 
        volatile uint32_t GHWCFG3;  ///< Offset: 0x4C - 
        volatile uint32_t GHWCFG4;  ///< Offset: 0x50 - 
        volatile uint32_t GDFIFOCFG;  ///< Offset: 0x5C - 
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - 
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - 
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - 
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - 
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - 
        volatile uint32_t HCFG;  ///< Offset: 0x400 - 
        volatile uint32_t HFIR;  ///< Offset: 0x404 - 
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - 
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - 
        volatile uint32_t HAINT;  ///< Offset: 0x414 - 
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - 
        volatile uint32_t HFLBADDR;  ///< Offset: 0x41C - 
        volatile uint32_t HPRT;  ///< Offset: 0x440 - 
        volatile uint32_t HCCHAR0;  ///< Offset: 0x500 - 
        volatile uint32_t HCINT0;  ///< Offset: 0x508 - 
        volatile uint32_t HCINTMSK0;  ///< Offset: 0x50C - 
        volatile uint32_t HCTSIZ0;  ///< Offset: 0x510 - 
        volatile uint32_t HCDMA0;  ///< Offset: 0x514 - 
        volatile uint32_t HCDMAB0;  ///< Offset: 0x51C - 
        volatile uint32_t HCCHAR1;  ///< Offset: 0x520 - 
        volatile uint32_t HCINT1;  ///< Offset: 0x528 - 
        volatile uint32_t HCINTMSK1;  ///< Offset: 0x52C - 
        volatile uint32_t HCTSIZ1;  ///< Offset: 0x530 - 
        volatile uint32_t HCDMA1;  ///< Offset: 0x534 - 
        volatile uint32_t HCDMAB1;  ///< Offset: 0x53C - 
        volatile uint32_t HCCHAR2;  ///< Offset: 0x540 - 
        volatile uint32_t HCINT2;  ///< Offset: 0x548 - 
        volatile uint32_t HCINTMSK2;  ///< Offset: 0x54C - 
        volatile uint32_t HCTSIZ2;  ///< Offset: 0x550 - 
        volatile uint32_t HCDMA2;  ///< Offset: 0x554 - 
        volatile uint32_t HCDMAB2;  ///< Offset: 0x55C - 
        volatile uint32_t HCCHAR3;  ///< Offset: 0x560 - 
        volatile uint32_t HCINT3;  ///< Offset: 0x568 - 
        volatile uint32_t HCINTMSK3;  ///< Offset: 0x56C - 
        volatile uint32_t HCTSIZ3;  ///< Offset: 0x570 - 
        volatile uint32_t HCDMA3;  ///< Offset: 0x574 - 
        volatile uint32_t HCDMAB3;  ///< Offset: 0x57C - 
        volatile uint32_t HCCHAR4;  ///< Offset: 0x580 - 
        volatile uint32_t HCINT4;  ///< Offset: 0x588 - 
        volatile uint32_t HCINTMSK4;  ///< Offset: 0x58C - 
        volatile uint32_t HCTSIZ4;  ///< Offset: 0x590 - 
        volatile uint32_t HCDMA4;  ///< Offset: 0x594 - 
        volatile uint32_t HCDMAB4;  ///< Offset: 0x59C - 
        volatile uint32_t HCCHAR5;  ///< Offset: 0x5A0 - 
        volatile uint32_t HCINT5;  ///< Offset: 0x5A8 - 
        volatile uint32_t HCINTMSK5;  ///< Offset: 0x5AC - 
        volatile uint32_t HCTSIZ5;  ///< Offset: 0x5B0 - 
        volatile uint32_t HCDMA5;  ///< Offset: 0x5B4 - 
        volatile uint32_t HCDMAB5;  ///< Offset: 0x5BC - 
        volatile uint32_t HCCHAR6;  ///< Offset: 0x5C0 - 
        volatile uint32_t HCINT6;  ///< Offset: 0x5C8 - 
        volatile uint32_t HCINTMSK6;  ///< Offset: 0x5CC - 
        volatile uint32_t HCTSIZ6;  ///< Offset: 0x5D0 - 
        volatile uint32_t HCDMA6;  ///< Offset: 0x5D4 - 
        volatile uint32_t HCDMAB6;  ///< Offset: 0x5DC - 
        volatile uint32_t HCCHAR7;  ///< Offset: 0x5E0 - 
        volatile uint32_t HCINT7;  ///< Offset: 0x5E8 - 
        volatile uint32_t HCINTMSK7;  ///< Offset: 0x5EC - 
        volatile uint32_t HCTSIZ7;  ///< Offset: 0x5F0 - 
        volatile uint32_t HCDMA7;  ///< Offset: 0x5F4 - 
        volatile uint32_t HCDMAB7;  ///< Offset: 0x5FC - 
        volatile uint32_t DCFG;  ///< Offset: 0x800 - 
        volatile uint32_t DCTL;  ///< Offset: 0x804 - 
        volatile uint32_t DSTS;  ///< Offset: 0x808 - 
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - 
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - 
        volatile uint32_t DAINT;  ///< Offset: 0x818 - 
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - 
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - 
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - 
        volatile uint32_t DTHRCTL;  ///< Offset: 0x830 - 
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - 
        volatile uint32_t DIEPCTL0;  ///< Offset: 0x900 - 
        volatile uint32_t DIEPINT0;  ///< Offset: 0x908 - 
        volatile uint32_t DIEPTSIZ0;  ///< Offset: 0x910 - 
        volatile uint32_t DIEPDMA0;  ///< Offset: 0x914 - 
        volatile uint32_t DTXFSTS0;  ///< Offset: 0x918 - 
        volatile uint32_t DIEPDMAB0;  ///< Offset: 0x91C - 
        volatile uint32_t DIEPCTL1;  ///< Offset: 0x920 - 
        volatile uint32_t DIEPINT1;  ///< Offset: 0x928 - 
        volatile uint32_t DIEPTSIZ1;  ///< Offset: 0x930 - 
        volatile uint32_t DIEPDMA1;  ///< Offset: 0x934 - 
        volatile uint32_t DTXFSTS1;  ///< Offset: 0x938 - 
        volatile uint32_t DIEPDMAB1;  ///< Offset: 0x93C - 
        volatile uint32_t DIEPCTL2;  ///< Offset: 0x940 - 
        volatile uint32_t DIEPINT2;  ///< Offset: 0x948 - 
        volatile uint32_t DIEPTSIZ2;  ///< Offset: 0x950 - 
        volatile uint32_t DIEPDMA2;  ///< Offset: 0x954 - 
        volatile uint32_t DTXFSTS2;  ///< Offset: 0x958 - 
        volatile uint32_t DIEPDMAB2;  ///< Offset: 0x95C - 
        volatile uint32_t DIEPCTL3;  ///< Offset: 0x960 - 
        volatile uint32_t DIEPINT3;  ///< Offset: 0x968 - 
        volatile uint32_t DIEPTSIZ3;  ///< Offset: 0x970 - 
        volatile uint32_t DIEPDMA3;  ///< Offset: 0x974 - 
        volatile uint32_t DTXFSTS3;  ///< Offset: 0x978 - 
        volatile uint32_t DIEPDMAB3;  ///< Offset: 0x97C - 
        volatile uint32_t DIEPCTL4;  ///< Offset: 0x980 - 
        volatile uint32_t DIEPINT4;  ///< Offset: 0x988 - 
        volatile uint32_t DIEPTSIZ4;  ///< Offset: 0x990 - 
        volatile uint32_t DIEPDMA4;  ///< Offset: 0x994 - 
        volatile uint32_t DTXFSTS4;  ///< Offset: 0x998 - 
        volatile uint32_t DIEPDMAB4;  ///< Offset: 0x99C - 
        volatile uint32_t DIEPCTL5;  ///< Offset: 0x9A0 - 
        volatile uint32_t DIEPINT5;  ///< Offset: 0x9A8 - 
        volatile uint32_t DIEPTSIZ5;  ///< Offset: 0x9B0 - 
        volatile uint32_t DIEPDMA5;  ///< Offset: 0x9B4 - 
        volatile uint32_t DTXFSTS5;  ///< Offset: 0x9B8 - 
        volatile uint32_t DIEPDMAB5;  ///< Offset: 0x9BC - 
        volatile uint32_t DIEPCTL6;  ///< Offset: 0x9C0 - 
        volatile uint32_t DIEPINT6;  ///< Offset: 0x9C8 - 
        volatile uint32_t DIEPTSIZ6;  ///< Offset: 0x9D0 - 
        volatile uint32_t DIEPDMA6;  ///< Offset: 0x9D4 - 
        volatile uint32_t DTXFSTS6;  ///< Offset: 0x9D8 - 
        volatile uint32_t DIEPDMAB6;  ///< Offset: 0x9DC - 
        volatile uint32_t DOEPCTL0;  ///< Offset: 0xB00 - 
        volatile uint32_t DOEPINT0;  ///< Offset: 0xB08 - 
        volatile uint32_t DOEPTSIZ0;  ///< Offset: 0xB10 - 
        volatile uint32_t DOEPDMA0;  ///< Offset: 0xB14 - 
        volatile uint32_t DOEPDMAB0;  ///< Offset: 0xB1C - 
        volatile uint32_t DOEPCTL1;  ///< Offset: 0xB20 - 
        volatile uint32_t DOEPINT1;  ///< Offset: 0xB28 - 
        volatile uint32_t DOEPTSIZ1;  ///< Offset: 0xB30 - 
        volatile uint32_t DOEPDMA1;  ///< Offset: 0xB34 - 
        volatile uint32_t DOEPDMAB1;  ///< Offset: 0xB3C - 
        volatile uint32_t DOEPCTL2;  ///< Offset: 0xB40 - 
        volatile uint32_t DOEPINT2;  ///< Offset: 0xB48 - 
        volatile uint32_t DOEPTSIZ2;  ///< Offset: 0xB50 - 
        volatile uint32_t DOEPDMA2;  ///< Offset: 0xB54 - 
        volatile uint32_t DOEPDMAB2;  ///< Offset: 0xB5C - 
        volatile uint32_t DOEPCTL3;  ///< Offset: 0xB60 - 
        volatile uint32_t DOEPINT3;  ///< Offset: 0xB68 - 
        volatile uint32_t DOEPTSIZ3;  ///< Offset: 0xB70 - 
        volatile uint32_t DOEPDMA3;  ///< Offset: 0xB74 - 
        volatile uint32_t DOEPDMAB3;  ///< Offset: 0xB7C - 
        volatile uint32_t DOEPCTL4;  ///< Offset: 0xB80 - 
        volatile uint32_t DOEPINT4;  ///< Offset: 0xB88 - 
        volatile uint32_t DOEPTSIZ4;  ///< Offset: 0xB90 - 
        volatile uint32_t DOEPDMA4;  ///< Offset: 0xB94 - 
        volatile uint32_t DOEPDMAB4;  ///< Offset: 0xB9C - 
        volatile uint32_t DOEPCTL5;  ///< Offset: 0xBA0 - 
        volatile uint32_t DOEPINT5;  ///< Offset: 0xBA8 - 
        volatile uint32_t DOEPTSIZ5;  ///< Offset: 0xBB0 - 
        volatile uint32_t DOEPDMA5;  ///< Offset: 0xBB4 - 
        volatile uint32_t DOEPDMAB5;  ///< Offset: 0xBBC - 
        volatile uint32_t DOEPCTL6;  ///< Offset: 0xBC0 - 
        volatile uint32_t DOEPINT6;  ///< Offset: 0xBC8 - 
        volatile uint32_t DOEPTSIZ6;  ///< Offset: 0xBD0 - 
        volatile uint32_t DOEPDMA6;  ///< Offset: 0xBD4 - 
        volatile uint32_t DOEPDMAB6;  ///< Offset: 0xBDC - 
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - 
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB_WRAP = reinterpret_cast<Registers*>(USB_WRAP_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SESREQSCS = (1U << 0);  ///< SESREQSCS
        constexpr uint32_t SESREQ = (1U << 1);  ///< SESREQ
        constexpr uint32_t VBVALIDOVEN = (1U << 2);  ///< VBVALIDOVEN
        constexpr uint32_t VBVALIDOVVAL = (1U << 3);  ///< VBVALIDOVVAL
        constexpr uint32_t AVALIDOVEN = (1U << 4);  ///< AVALIDOVEN
        constexpr uint32_t AVALIDOVVAL = (1U << 5);  ///< AVALIDOVVAL
        constexpr uint32_t BVALIDOVEN = (1U << 6);  ///< BVALIDOVEN
        constexpr uint32_t BVALIDOVVAL = (1U << 7);  ///< BVALIDOVVAL
        constexpr uint32_t HSTNEGSCS = (1U << 8);  ///< HSTNEGSCS
        constexpr uint32_t HNPREQ = (1U << 9);  ///< HNPREQ
        constexpr uint32_t HSTSETHNPEN = (1U << 10);  ///< HSTSETHNPEN
        constexpr uint32_t DEVHNPEN = (1U << 11);  ///< DEVHNPEN
        constexpr uint32_t EHEN = (1U << 12);  ///< EHEN
        constexpr uint32_t DBNCEFLTRBYPASS = (1U << 15);  ///< DBNCEFLTRBYPASS
        constexpr uint32_t CONIDSTS = (1U << 16);  ///< CONIDSTS
        constexpr uint32_t DBNCTIME = (1U << 17);  ///< DBNCTIME
        constexpr uint32_t ASESVLD = (1U << 18);  ///< ASESVLD
        constexpr uint32_t BSESVLD = (1U << 19);  ///< BSESVLD
        constexpr uint32_t OTGVER = (1U << 20);  ///< OTGVER
        constexpr uint32_t CURMOD = (1U << 21);  ///< CURMOD
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SESENDDET = (1U << 2);  ///< SESENDDET
        constexpr uint32_t SESREQSUCSTSCHNG = (1U << 8);  ///< SESREQSUCSTSCHNG
        constexpr uint32_t HSTNEGSUCSTSCHNG = (1U << 9);  ///< HSTNEGSUCSTSCHNG
        constexpr uint32_t HSTNEGDET = (1U << 17);  ///< HSTNEGDET
        constexpr uint32_t ADEVTOUTCHG = (1U << 18);  ///< ADEVTOUTCHG
        constexpr uint32_t DBNCEDONE = (1U << 19);  ///< DBNCEDONE
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GLBLLNTRMSK = (1U << 0);  ///< GLBLLNTRMSK
        constexpr uint32_t HBSTLEN = (4 << 1);  ///< HBSTLEN
        constexpr uint32_t DMAEN = (1U << 5);  ///< DMAEN
        constexpr uint32_t NPTXFEMPLVL = (1U << 7);  ///< NPTXFEMPLVL
        constexpr uint32_t PTXFEMPLVL = (1U << 8);  ///< PTXFEMPLVL
        constexpr uint32_t REMMEMSUPP = (1U << 21);  ///< REMMEMSUPP
        constexpr uint32_t NOTIALLDMAWRIT = (1U << 22);  ///< NOTIALLDMAWRIT
        constexpr uint32_t AHBSINGLE = (1U << 23);  ///< AHBSINGLE
        constexpr uint32_t INVDESCENDIANESS = (1U << 24);  ///< INVDESCENDIANESS
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOUTCAL = (3 << 0);  ///< TOUTCAL
        constexpr uint32_t PHYIF = (1U << 3);  ///< PHYIF
        constexpr uint32_t ULPI_UTMI_SEL = (1U << 4);  ///< ULPI_UTMI_SEL
        constexpr uint32_t FSINTF = (1U << 5);  ///< FSINTF
        constexpr uint32_t PHYSEL = (1U << 6);  ///< PHYSEL
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRPCAP
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNPCAP
        constexpr uint32_t USBTRDTIM = (4 << 10);  ///< USBTRDTIM
        constexpr uint32_t TERMSELDLPULSE = (1U << 22);  ///< TERMSELDLPULSE
        constexpr uint32_t TXENDDELAY = (1U << 28);  ///< TXENDDELAY
        constexpr uint32_t FORCEHSTMODE = (1U << 29);  ///< FORCEHSTMODE
        constexpr uint32_t FORCEDEVMODE = (1U << 30);  ///< FORCEDEVMODE
        constexpr uint32_t CORRUPTTXPKT = (1U << 31);  ///< CORRUPTTXPKT
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSFTRST = (1U << 0);  ///< CSFTRST
        constexpr uint32_t PIUFSSFTRST = (1U << 1);  ///< PIUFSSFTRST
        constexpr uint32_t FRMCNTRRST = (1U << 2);  ///< FRMCNTRRST
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RXFFLSH
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TXFFLSH
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TXFNUM
        constexpr uint32_t DMAREQ = (1U << 30);  ///< DMAREQ
        constexpr uint32_t AHBIDLE = (1U << 31);  ///< AHBIDLE
    }

    /// GINTSTS Register bits
    namespace gintsts_bits {
        constexpr uint32_t CURMOD_INT = (1U << 0);  ///< CURMOD_INT
        constexpr uint32_t MODEMIS = (1U << 1);  ///< MODEMIS
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOF = (1U << 3);  ///< SOF
        constexpr uint32_t RXFLVI = (1U << 4);  ///< RXFLVI
        constexpr uint32_t NPTXFEMP = (1U << 5);  ///< NPTXFEMP
        constexpr uint32_t GINNAKEFF = (1U << 6);  ///< GINNAKEFF
        constexpr uint32_t GOUTNAKEFF = (1U << 7);  ///< GOUTNAKEFF
        constexpr uint32_t ERLYSUSP = (1U << 10);  ///< ERLYSUSP
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USBSUSP
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDONE = (1U << 13);  ///< ENUMDONE
        constexpr uint32_t ISOOUTDROP = (1U << 14);  ///< ISOOUTDROP
        constexpr uint32_t EOPF = (1U << 15);  ///< EOPF
        constexpr uint32_t EPMIS = (1U << 17);  ///< EPMIS
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t INCOMPISOIN = (1U << 20);  ///< INCOMPISOIN
        constexpr uint32_t INCOMPIP = (1U << 21);  ///< INCOMPIP
        constexpr uint32_t FETSUSP = (1U << 22);  ///< FETSUSP
        constexpr uint32_t RESETDET = (1U << 23);  ///< RESETDET
        constexpr uint32_t PRTLNT = (1U << 24);  ///< PRTLNT
        constexpr uint32_t HCHLNT = (1U << 25);  ///< HCHLNT
        constexpr uint32_t PTXFEMP = (1U << 26);  ///< PTXFEMP
        constexpr uint32_t CONIDSTSCHNG = (1U << 28);  ///< CONIDSTSCHNG
        constexpr uint32_t DISCONNINT = (1U << 29);  ///< DISCONNINT
        constexpr uint32_t SESSREQINT = (1U << 30);  ///< SESSREQINT
        constexpr uint32_t WKUPINT = (1U << 31);  ///< WKUPINT
    }

    /// GINTMSK Register bits
    namespace gintmsk_bits {
        constexpr uint32_t MODEMISMSK = (1U << 1);  ///< MODEMISMSK
        constexpr uint32_t OTGINTMSK = (1U << 2);  ///< OTGINTMSK
        constexpr uint32_t SOFMSK = (1U << 3);  ///< SOFMSK
        constexpr uint32_t RXFLVIMSK = (1U << 4);  ///< RXFLVIMSK
        constexpr uint32_t NPTXFEMPMSK = (1U << 5);  ///< NPTXFEMPMSK
        constexpr uint32_t GINNAKEFFMSK = (1U << 6);  ///< GINNAKEFFMSK
        constexpr uint32_t GOUTNACKEFFMSK = (1U << 7);  ///< GOUTNACKEFFMSK
        constexpr uint32_t ERLYSUSPMSK = (1U << 10);  ///< ERLYSUSPMSK
        constexpr uint32_t USBSUSPMSK = (1U << 11);  ///< USBSUSPMSK
        constexpr uint32_t USBRSTMSK = (1U << 12);  ///< USBRSTMSK
        constexpr uint32_t ENUMDONEMSK = (1U << 13);  ///< ENUMDONEMSK
        constexpr uint32_t ISOOUTDROPMSK = (1U << 14);  ///< ISOOUTDROPMSK
        constexpr uint32_t EOPFMSK = (1U << 15);  ///< EOPFMSK
        constexpr uint32_t EPMISMSK = (1U << 17);  ///< EPMISMSK
        constexpr uint32_t IEPINTMSK = (1U << 18);  ///< IEPINTMSK
        constexpr uint32_t OEPINTMSK = (1U << 19);  ///< OEPINTMSK
        constexpr uint32_t INCOMPISOINMSK = (1U << 20);  ///< INCOMPISOINMSK
        constexpr uint32_t INCOMPIPMSK = (1U << 21);  ///< INCOMPIPMSK
        constexpr uint32_t FETSUSPMSK = (1U << 22);  ///< FETSUSPMSK
        constexpr uint32_t RESETDETMSK = (1U << 23);  ///< RESETDETMSK
        constexpr uint32_t PRTLNTMSK = (1U << 24);  ///< PRTLNTMSK
        constexpr uint32_t HCHINTMSK = (1U << 25);  ///< HCHINTMSK
        constexpr uint32_t PTXFEMPMSK = (1U << 26);  ///< PTXFEMPMSK
        constexpr uint32_t CONIDSTSCHNGMSK = (1U << 28);  ///< CONIDSTSCHNGMSK
        constexpr uint32_t DISCONNINTMSK = (1U << 29);  ///< DISCONNINTMSK
        constexpr uint32_t SESSREQINTMSK = (1U << 30);  ///< SESSREQINTMSK
        constexpr uint32_t WKUPINTMSK = (1U << 31);  ///< WKUPINTMSK
    }

    /// GRXSTSR Register bits
    namespace grxstsr_bits {
        constexpr uint32_t G_CHNUM = (4 << 0);  ///< G_CHNUM
        constexpr uint32_t G_BCNT = (11 << 4);  ///< G_BCNT
        constexpr uint32_t G_DPID = (2 << 15);  ///< G_DPID
        constexpr uint32_t G_PKTSTS = (4 << 17);  ///< G_PKTSTS
        constexpr uint32_t G_FN = (4 << 21);  ///< G_FN
    }

    /// GRXSTSP Register bits
    namespace grxstsp_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FN = (4 << 21);  ///< FN
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RXFDEP = (16 << 0);  ///< RXFDEP
    }

    /// GNPTXFSIZ Register bits
    namespace gnptxfsiz_bits {
        constexpr uint32_t NPTXFSTADDR = (16 << 0);  ///< NPTXFSTADDR
        constexpr uint32_t NPTXFDEP = (16 << 16);  ///< NPTXFDEP
    }

    /// GNPTXSTS Register bits
    namespace gnptxsts_bits {
        constexpr uint32_t NPTXFSPCAVAIL = (16 << 0);  ///< NPTXFSPCAVAIL
        constexpr uint32_t NPTXQSPCAVAIL = (4 << 16);  ///< NPTXQSPCAVAIL
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< NPTXQTOP
    }

    /// GSNPSID Register bits
    namespace gsnpsid_bits {
        constexpr uint32_t SYNOPSYSID = (32 << 0);  ///< SYNOPSYSID
    }

    /// GHWCFG1 Register bits
    namespace ghwcfg1_bits {
        constexpr uint32_t EPDIR = (32 << 0);  ///< EPDIR
    }

    /// GHWCFG2 Register bits
    namespace ghwcfg2_bits {
        constexpr uint32_t OTGMODE = (3 << 0);  ///< OTGMODE
        constexpr uint32_t OTGARCH = (2 << 3);  ///< OTGARCH
        constexpr uint32_t SINGPNT = (1U << 5);  ///< SINGPNT
        constexpr uint32_t HSPHYTYPE = (2 << 6);  ///< HSPHYTYPE
        constexpr uint32_t FSPHYTYPE = (2 << 8);  ///< FSPHYTYPE
        constexpr uint32_t NUMDEVEPS = (4 << 10);  ///< NUMDEVEPS
        constexpr uint32_t NUMHSTCHNL = (4 << 14);  ///< NUMHSTCHNL
        constexpr uint32_t PERIOSUPPORT = (1U << 18);  ///< PERIOSUPPORT
        constexpr uint32_t DYNFIFOSIZING = (1U << 19);  ///< DYNFIFOSIZING
        constexpr uint32_t MULTIPROCINTRPT = (1U << 20);  ///< MULTIPROCINTRPT
        constexpr uint32_t NPTXQDEPTH = (2 << 22);  ///< NPTXQDEPTH
        constexpr uint32_t PTXQDEPTH = (2 << 24);  ///< PTXQDEPTH
        constexpr uint32_t TKNQDEPTH = (5 << 26);  ///< TKNQDEPTH
        constexpr uint32_t OTG_ENABLE_IC_USB = (1U << 31);  ///< OTG_ENABLE_IC_USB
    }

    /// GHWCFG3 Register bits
    namespace ghwcfg3_bits {
        constexpr uint32_t XFERSIZEWIDTH = (4 << 0);  ///< XFERSIZEWIDTH
        constexpr uint32_t PKTSIZEWIDTH = (3 << 4);  ///< PKTSIZEWIDTH
        constexpr uint32_t OTGEN = (1U << 7);  ///< OTGEN
        constexpr uint32_t I2CINTSEL = (1U << 8);  ///< I2CINTSEL
        constexpr uint32_t VNDCTLSUPT = (1U << 9);  ///< VNDCTLSUPT
        constexpr uint32_t OPTFEATURE = (1U << 10);  ///< OPTFEATURE
        constexpr uint32_t RSTTYPE = (1U << 11);  ///< RSTTYPE
        constexpr uint32_t ADPSUPPORT = (1U << 12);  ///< ADPSUPPORT
        constexpr uint32_t HSICMODE = (1U << 13);  ///< HSICMODE
        constexpr uint32_t BCSUPPORT = (1U << 14);  ///< BCSUPPORT
        constexpr uint32_t LPMMODE = (1U << 15);  ///< LPMMODE
        constexpr uint32_t DFIFODEPTH = (16 << 16);  ///< DFIFODEPTH
    }

    /// GHWCFG4 Register bits
    namespace ghwcfg4_bits {
        constexpr uint32_t G_NUMDEVPERIOEPS = (4 << 0);  ///< G_NUMDEVPERIOEPS
        constexpr uint32_t G_PARTIALPWRDN = (1U << 4);  ///< G_PARTIALPWRDN
        constexpr uint32_t G_AHBFREQ = (1U << 5);  ///< G_AHBFREQ
        constexpr uint32_t G_HIBERNATION = (1U << 6);  ///< G_HIBERNATION
        constexpr uint32_t G_EXTENDEDHIBERNATION = (1U << 7);  ///< G_EXTENDEDHIBERNATION
        constexpr uint32_t G_ACGSUPT = (1U << 12);  ///< G_ACGSUPT
        constexpr uint32_t G_ENHANCEDLPMSUPT = (1U << 13);  ///< G_ENHANCEDLPMSUPT
        constexpr uint32_t G_PHYDATAWIDTH = (2 << 14);  ///< G_PHYDATAWIDTH
        constexpr uint32_t G_NUMCTLEPS = (4 << 16);  ///< G_NUMCTLEPS
        constexpr uint32_t G_IDDQFLTR = (1U << 20);  ///< G_IDDQFLTR
        constexpr uint32_t G_VBUSVALIDFLTR = (1U << 21);  ///< G_VBUSVALIDFLTR
        constexpr uint32_t G_AVALIDFLTR = (1U << 22);  ///< G_AVALIDFLTR
        constexpr uint32_t G_BVALIDFLTR = (1U << 23);  ///< G_BVALIDFLTR
        constexpr uint32_t G_SESSENDFLTR = (1U << 24);  ///< G_SESSENDFLTR
        constexpr uint32_t G_DEDFIFOMODE = (1U << 25);  ///< G_DEDFIFOMODE
        constexpr uint32_t G_INEPS = (4 << 26);  ///< G_INEPS
        constexpr uint32_t G_DESCDMAENABLED = (1U << 30);  ///< G_DESCDMAENABLED
        constexpr uint32_t G_DESCDMA = (1U << 31);  ///< G_DESCDMA
    }

    /// GDFIFOCFG Register bits
    namespace gdfifocfg_bits {
        constexpr uint32_t GDFIFOCFG = (16 << 0);  ///< GDFIFOCFG
        constexpr uint32_t EPINFOBASEADDR = (16 << 16);  ///< EPINFOBASEADDR
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTXFSTADDR = (16 << 0);  ///< PTXFSTADDR
        constexpr uint32_t PTXFSIZE = (16 << 16);  ///< PTXFSIZE
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEP1TXFSTADDR = (16 << 0);  ///< INEP1TXFSTADDR
        constexpr uint32_t INEP1TXFDEP = (16 << 16);  ///< INEP1TXFDEP
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEP2TXFSTADDR = (16 << 0);  ///< INEP2TXFSTADDR
        constexpr uint32_t INEP2TXFDEP = (16 << 16);  ///< INEP2TXFDEP
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEP3TXFSTADDR = (16 << 0);  ///< INEP3TXFSTADDR
        constexpr uint32_t INEP3TXFDEP = (16 << 16);  ///< INEP3TXFDEP
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEP4TXFSTADDR = (16 << 0);  ///< INEP4TXFSTADDR
        constexpr uint32_t INEP4TXFDEP = (16 << 16);  ///< INEP4TXFDEP
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t H_FSLSPCLKSEL = (2 << 0);  ///< H_FSLSPCLKSEL
        constexpr uint32_t H_FSLSSUPP = (1U << 2);  ///< H_FSLSSUPP
        constexpr uint32_t H_ENA32KHZS = (1U << 7);  ///< H_ENA32KHZS
        constexpr uint32_t H_DESCDMA = (1U << 23);  ///< H_DESCDMA
        constexpr uint32_t H_FRLISTEN = (2 << 24);  ///< H_FRLISTEN
        constexpr uint32_t H_PERSCHEDENA = (1U << 26);  ///< H_PERSCHEDENA
        constexpr uint32_t H_MODECHTIMEN = (1U << 31);  ///< H_MODECHTIMEN
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FRINT = (16 << 0);  ///< FRINT
        constexpr uint32_t HFIRRLDCTRL = (1U << 16);  ///< HFIRRLDCTRL
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FRNUM = (14 << 0);  ///< FRNUM
        constexpr uint32_t FRREM = (16 << 16);  ///< FRREM
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTXFSPCAVAIL = (16 << 0);  ///< PTXFSPCAVAIL
        constexpr uint32_t PTXQSPCAVAIL = (5 << 16);  ///< PTXQSPCAVAIL
        constexpr uint32_t PTXQTOP = (8 << 24);  ///< PTXQTOP
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (8 << 0);  ///< HAINT
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTMSK = (8 << 0);  ///< HAINTMSK
    }

    /// HFLBADDR Register bits
    namespace hflbaddr_bits {
        constexpr uint32_t HFLBADDR = (32 << 0);  ///< HFLBADDR
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PRTCONNSTS = (1U << 0);  ///< PRTCONNSTS
        constexpr uint32_t PRTCONNDET = (1U << 1);  ///< PRTCONNDET
        constexpr uint32_t PRTENA = (1U << 2);  ///< PRTENA
        constexpr uint32_t PRTENCHNG = (1U << 3);  ///< PRTENCHNG
        constexpr uint32_t PRTOVRCURRACT = (1U << 4);  ///< PRTOVRCURRACT
        constexpr uint32_t PRTOVRCURRCHNG = (1U << 5);  ///< PRTOVRCURRCHNG
        constexpr uint32_t PRTRES = (1U << 6);  ///< PRTRES
        constexpr uint32_t PRTSUSP = (1U << 7);  ///< PRTSUSP
        constexpr uint32_t PRTRST = (1U << 8);  ///< PRTRST
        constexpr uint32_t PRTLNSTS = (2 << 10);  ///< PRTLNSTS
        constexpr uint32_t PRTPWR = (1U << 12);  ///< PRTPWR
        constexpr uint32_t PRTTSTCTL = (4 << 13);  ///< PRTTSTCTL
        constexpr uint32_t PRTSPD = (2 << 17);  ///< PRTSPD
    }

    /// HCCHAR0 Register bits
    namespace hcchar0_bits {
        constexpr uint32_t H_MPS0 = (11 << 0);  ///< H_MPS0
        constexpr uint32_t H_EPNUM0 = (4 << 11);  ///< H_EPNUM0
        constexpr uint32_t H_EPDIR0 = (1U << 15);  ///< H_EPDIR0
        constexpr uint32_t H_LSPDDEV0 = (1U << 17);  ///< H_LSPDDEV0
        constexpr uint32_t H_EPTYPE0 = (2 << 18);  ///< H_EPTYPE0
        constexpr uint32_t H_EC0 = (1U << 21);  ///< H_EC0
        constexpr uint32_t H_DEVADDR0 = (7 << 22);  ///< H_DEVADDR0
        constexpr uint32_t H_ODDFRM0 = (1U << 29);  ///< H_ODDFRM0
        constexpr uint32_t H_CHDIS0 = (1U << 30);  ///< H_CHDIS0
        constexpr uint32_t H_CHENA0 = (1U << 31);  ///< H_CHENA0
    }

    /// HCINT0 Register bits
    namespace hcint0_bits {
        constexpr uint32_t H_XFERCOMPL0 = (1U << 0);  ///< H_XFERCOMPL0
        constexpr uint32_t H_CHHLTD0 = (1U << 1);  ///< H_CHHLTD0
        constexpr uint32_t H_AHBERR0 = (1U << 2);  ///< H_AHBERR0
        constexpr uint32_t H_STALL0 = (1U << 3);  ///< H_STALL0
        constexpr uint32_t H_NACK0 = (1U << 4);  ///< H_NACK0
        constexpr uint32_t H_ACK0 = (1U << 5);  ///< H_ACK0
        constexpr uint32_t H_NYET0 = (1U << 6);  ///< H_NYET0
        constexpr uint32_t H_XACTERR0 = (1U << 7);  ///< H_XACTERR0
        constexpr uint32_t H_BBLERR0 = (1U << 8);  ///< H_BBLERR0
        constexpr uint32_t H_FRMOVRUN0 = (1U << 9);  ///< H_FRMOVRUN0
        constexpr uint32_t H_DATATGLERR0 = (1U << 10);  ///< H_DATATGLERR0
        constexpr uint32_t H_BNAINTR0 = (1U << 11);  ///< H_BNAINTR0
        constexpr uint32_t H_XCS_XACT_ERR0 = (1U << 12);  ///< H_XCS_XACT_ERR0
        constexpr uint32_t H_DESC_LST_ROLLINTR0 = (1U << 13);  ///< H_DESC_LST_ROLLINTR0
    }

    /// HCINTMSK0 Register bits
    namespace hcintmsk0_bits {
        constexpr uint32_t H_XFERCOMPLMSK0 = (1U << 0);  ///< H_XFERCOMPLMSK0
        constexpr uint32_t H_CHHLTDMSK0 = (1U << 1);  ///< H_CHHLTDMSK0
        constexpr uint32_t H_AHBERRMSK0 = (1U << 2);  ///< H_AHBERRMSK0
        constexpr uint32_t H_STALLMSK0 = (1U << 3);  ///< H_STALLMSK0
        constexpr uint32_t H_NAKMSK0 = (1U << 4);  ///< H_NAKMSK0
        constexpr uint32_t H_ACKMSK0 = (1U << 5);  ///< H_ACKMSK0
        constexpr uint32_t H_NYETMSK0 = (1U << 6);  ///< H_NYETMSK0
        constexpr uint32_t H_XACTERRMSK0 = (1U << 7);  ///< H_XACTERRMSK0
        constexpr uint32_t H_BBLERRMSK0 = (1U << 8);  ///< H_BBLERRMSK0
        constexpr uint32_t H_FRMOVRUNMSK0 = (1U << 9);  ///< H_FRMOVRUNMSK0
        constexpr uint32_t H_DATATGLERRMSK0 = (1U << 10);  ///< H_DATATGLERRMSK0
        constexpr uint32_t H_BNAINTRMSK0 = (1U << 11);  ///< H_BNAINTRMSK0
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK0 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK0
    }

    /// HCTSIZ0 Register bits
    namespace hctsiz0_bits {
        constexpr uint32_t H_XFERSIZE0 = (19 << 0);  ///< H_XFERSIZE0
        constexpr uint32_t H_PKTCNT0 = (10 << 19);  ///< H_PKTCNT0
        constexpr uint32_t H_PID0 = (2 << 29);  ///< H_PID0
        constexpr uint32_t H_DOPNG0 = (1U << 31);  ///< H_DOPNG0
    }

    /// HCDMA0 Register bits
    namespace hcdma0_bits {
        constexpr uint32_t H_DMAADDR0 = (32 << 0);  ///< H_DMAADDR0
    }

    /// HCDMAB0 Register bits
    namespace hcdmab0_bits {
        constexpr uint32_t H_HCDMAB0 = (32 << 0);  ///< H_HCDMAB0
    }

    /// HCCHAR1 Register bits
    namespace hcchar1_bits {
        constexpr uint32_t H_MPS1 = (11 << 0);  ///< H_MPS1
        constexpr uint32_t H_EPNUM1 = (4 << 11);  ///< H_EPNUM1
        constexpr uint32_t H_EPDIR1 = (1U << 15);  ///< H_EPDIR1
        constexpr uint32_t H_LSPDDEV1 = (1U << 17);  ///< H_LSPDDEV1
        constexpr uint32_t H_EPTYPE1 = (2 << 18);  ///< H_EPTYPE1
        constexpr uint32_t H_EC1 = (1U << 21);  ///< H_EC1
        constexpr uint32_t H_DEVADDR1 = (7 << 22);  ///< H_DEVADDR1
        constexpr uint32_t H_ODDFRM1 = (1U << 29);  ///< H_ODDFRM1
        constexpr uint32_t H_CHDIS1 = (1U << 30);  ///< H_CHDIS1
        constexpr uint32_t H_CHENA1 = (1U << 31);  ///< H_CHENA1
    }

    /// HCINT1 Register bits
    namespace hcint1_bits {
        constexpr uint32_t H_XFERCOMPL1 = (1U << 0);  ///< H_XFERCOMPL1
        constexpr uint32_t H_CHHLTD1 = (1U << 1);  ///< H_CHHLTD1
        constexpr uint32_t H_AHBERR1 = (1U << 2);  ///< H_AHBERR1
        constexpr uint32_t H_STALL1 = (1U << 3);  ///< H_STALL1
        constexpr uint32_t H_NACK1 = (1U << 4);  ///< H_NACK1
        constexpr uint32_t H_ACK1 = (1U << 5);  ///< H_ACK1
        constexpr uint32_t H_NYET1 = (1U << 6);  ///< H_NYET1
        constexpr uint32_t H_XACTERR1 = (1U << 7);  ///< H_XACTERR1
        constexpr uint32_t H_BBLERR1 = (1U << 8);  ///< H_BBLERR1
        constexpr uint32_t H_FRMOVRUN1 = (1U << 9);  ///< H_FRMOVRUN1
        constexpr uint32_t H_DATATGLERR1 = (1U << 10);  ///< H_DATATGLERR1
        constexpr uint32_t H_BNAINTR1 = (1U << 11);  ///< H_BNAINTR1
        constexpr uint32_t H_XCS_XACT_ERR1 = (1U << 12);  ///< H_XCS_XACT_ERR1
        constexpr uint32_t H_DESC_LST_ROLLINTR1 = (1U << 13);  ///< H_DESC_LST_ROLLINTR1
    }

    /// HCINTMSK1 Register bits
    namespace hcintmsk1_bits {
        constexpr uint32_t H_XFERCOMPLMSK1 = (1U << 0);  ///< H_XFERCOMPLMSK1
        constexpr uint32_t H_CHHLTDMSK1 = (1U << 1);  ///< H_CHHLTDMSK1
        constexpr uint32_t H_AHBERRMSK1 = (1U << 2);  ///< H_AHBERRMSK1
        constexpr uint32_t H_STALLMSK1 = (1U << 3);  ///< H_STALLMSK1
        constexpr uint32_t H_NAKMSK1 = (1U << 4);  ///< H_NAKMSK1
        constexpr uint32_t H_ACKMSK1 = (1U << 5);  ///< H_ACKMSK1
        constexpr uint32_t H_NYETMSK1 = (1U << 6);  ///< H_NYETMSK1
        constexpr uint32_t H_XACTERRMSK1 = (1U << 7);  ///< H_XACTERRMSK1
        constexpr uint32_t H_BBLERRMSK1 = (1U << 8);  ///< H_BBLERRMSK1
        constexpr uint32_t H_FRMOVRUNMSK1 = (1U << 9);  ///< H_FRMOVRUNMSK1
        constexpr uint32_t H_DATATGLERRMSK1 = (1U << 10);  ///< H_DATATGLERRMSK1
        constexpr uint32_t H_BNAINTRMSK1 = (1U << 11);  ///< H_BNAINTRMSK1
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK1 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK1
    }

    /// HCTSIZ1 Register bits
    namespace hctsiz1_bits {
        constexpr uint32_t H_XFERSIZE1 = (19 << 0);  ///< H_XFERSIZE1
        constexpr uint32_t H_PKTCNT1 = (10 << 19);  ///< H_PKTCNT1
        constexpr uint32_t H_PID1 = (2 << 29);  ///< H_PID1
        constexpr uint32_t H_DOPNG1 = (1U << 31);  ///< H_DOPNG1
    }

    /// HCDMA1 Register bits
    namespace hcdma1_bits {
        constexpr uint32_t H_DMAADDR1 = (32 << 0);  ///< H_DMAADDR1
    }

    /// HCDMAB1 Register bits
    namespace hcdmab1_bits {
        constexpr uint32_t H_HCDMAB1 = (32 << 0);  ///< H_HCDMAB1
    }

    /// HCCHAR2 Register bits
    namespace hcchar2_bits {
        constexpr uint32_t H_MPS2 = (11 << 0);  ///< H_MPS2
        constexpr uint32_t H_EPNUM2 = (4 << 11);  ///< H_EPNUM2
        constexpr uint32_t H_EPDIR2 = (1U << 15);  ///< H_EPDIR2
        constexpr uint32_t H_LSPDDEV2 = (1U << 17);  ///< H_LSPDDEV2
        constexpr uint32_t H_EPTYPE2 = (2 << 18);  ///< H_EPTYPE2
        constexpr uint32_t H_EC2 = (1U << 21);  ///< H_EC2
        constexpr uint32_t H_DEVADDR2 = (7 << 22);  ///< H_DEVADDR2
        constexpr uint32_t H_ODDFRM2 = (1U << 29);  ///< H_ODDFRM2
        constexpr uint32_t H_CHDIS2 = (1U << 30);  ///< H_CHDIS2
        constexpr uint32_t H_CHENA2 = (1U << 31);  ///< H_CHENA2
    }

    /// HCINT2 Register bits
    namespace hcint2_bits {
        constexpr uint32_t H_XFERCOMPL2 = (1U << 0);  ///< H_XFERCOMPL2
        constexpr uint32_t H_CHHLTD2 = (1U << 1);  ///< H_CHHLTD2
        constexpr uint32_t H_AHBERR2 = (1U << 2);  ///< H_AHBERR2
        constexpr uint32_t H_STALL2 = (1U << 3);  ///< H_STALL2
        constexpr uint32_t H_NACK2 = (1U << 4);  ///< H_NACK2
        constexpr uint32_t H_ACK2 = (1U << 5);  ///< H_ACK2
        constexpr uint32_t H_NYET2 = (1U << 6);  ///< H_NYET2
        constexpr uint32_t H_XACTERR2 = (1U << 7);  ///< H_XACTERR2
        constexpr uint32_t H_BBLERR2 = (1U << 8);  ///< H_BBLERR2
        constexpr uint32_t H_FRMOVRUN2 = (1U << 9);  ///< H_FRMOVRUN2
        constexpr uint32_t H_DATATGLERR2 = (1U << 10);  ///< H_DATATGLERR2
        constexpr uint32_t H_BNAINTR2 = (1U << 11);  ///< H_BNAINTR2
        constexpr uint32_t H_XCS_XACT_ERR2 = (1U << 12);  ///< H_XCS_XACT_ERR2
        constexpr uint32_t H_DESC_LST_ROLLINTR2 = (1U << 13);  ///< H_DESC_LST_ROLLINTR2
    }

    /// HCINTMSK2 Register bits
    namespace hcintmsk2_bits {
        constexpr uint32_t H_XFERCOMPLMSK2 = (1U << 0);  ///< H_XFERCOMPLMSK2
        constexpr uint32_t H_CHHLTDMSK2 = (1U << 1);  ///< H_CHHLTDMSK2
        constexpr uint32_t H_AHBERRMSK2 = (1U << 2);  ///< H_AHBERRMSK2
        constexpr uint32_t H_STALLMSK2 = (1U << 3);  ///< H_STALLMSK2
        constexpr uint32_t H_NAKMSK2 = (1U << 4);  ///< H_NAKMSK2
        constexpr uint32_t H_ACKMSK2 = (1U << 5);  ///< H_ACKMSK2
        constexpr uint32_t H_NYETMSK2 = (1U << 6);  ///< H_NYETMSK2
        constexpr uint32_t H_XACTERRMSK2 = (1U << 7);  ///< H_XACTERRMSK2
        constexpr uint32_t H_BBLERRMSK2 = (1U << 8);  ///< H_BBLERRMSK2
        constexpr uint32_t H_FRMOVRUNMSK2 = (1U << 9);  ///< H_FRMOVRUNMSK2
        constexpr uint32_t H_DATATGLERRMSK2 = (1U << 10);  ///< H_DATATGLERRMSK2
        constexpr uint32_t H_BNAINTRMSK2 = (1U << 11);  ///< H_BNAINTRMSK2
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK2 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK2
    }

    /// HCTSIZ2 Register bits
    namespace hctsiz2_bits {
        constexpr uint32_t H_XFERSIZE2 = (19 << 0);  ///< H_XFERSIZE2
        constexpr uint32_t H_PKTCNT2 = (10 << 19);  ///< H_PKTCNT2
        constexpr uint32_t H_PID2 = (2 << 29);  ///< H_PID2
        constexpr uint32_t H_DOPNG2 = (1U << 31);  ///< H_DOPNG2
    }

    /// HCDMA2 Register bits
    namespace hcdma2_bits {
        constexpr uint32_t H_DMAADDR2 = (32 << 0);  ///< H_DMAADDR2
    }

    /// HCDMAB2 Register bits
    namespace hcdmab2_bits {
        constexpr uint32_t H_HCDMAB2 = (32 << 0);  ///< H_HCDMAB2
    }

    /// HCCHAR3 Register bits
    namespace hcchar3_bits {
        constexpr uint32_t H_MPS3 = (11 << 0);  ///< H_MPS3
        constexpr uint32_t H_EPNUM3 = (4 << 11);  ///< H_EPNUM3
        constexpr uint32_t H_EPDIR3 = (1U << 15);  ///< H_EPDIR3
        constexpr uint32_t H_LSPDDEV3 = (1U << 17);  ///< H_LSPDDEV3
        constexpr uint32_t H_EPTYPE3 = (2 << 18);  ///< H_EPTYPE3
        constexpr uint32_t H_EC3 = (1U << 21);  ///< H_EC3
        constexpr uint32_t H_DEVADDR3 = (7 << 22);  ///< H_DEVADDR3
        constexpr uint32_t H_ODDFRM3 = (1U << 29);  ///< H_ODDFRM3
        constexpr uint32_t H_CHDIS3 = (1U << 30);  ///< H_CHDIS3
        constexpr uint32_t H_CHENA3 = (1U << 31);  ///< H_CHENA3
    }

    /// HCINT3 Register bits
    namespace hcint3_bits {
        constexpr uint32_t H_XFERCOMPL3 = (1U << 0);  ///< H_XFERCOMPL3
        constexpr uint32_t H_CHHLTD3 = (1U << 1);  ///< H_CHHLTD3
        constexpr uint32_t H_AHBERR3 = (1U << 2);  ///< H_AHBERR3
        constexpr uint32_t H_STALL3 = (1U << 3);  ///< H_STALL3
        constexpr uint32_t H_NACK3 = (1U << 4);  ///< H_NACK3
        constexpr uint32_t H_ACK3 = (1U << 5);  ///< H_ACK3
        constexpr uint32_t H_NYET3 = (1U << 6);  ///< H_NYET3
        constexpr uint32_t H_XACTERR3 = (1U << 7);  ///< H_XACTERR3
        constexpr uint32_t H_BBLERR3 = (1U << 8);  ///< H_BBLERR3
        constexpr uint32_t H_FRMOVRUN3 = (1U << 9);  ///< H_FRMOVRUN3
        constexpr uint32_t H_DATATGLERR3 = (1U << 10);  ///< H_DATATGLERR3
        constexpr uint32_t H_BNAINTR3 = (1U << 11);  ///< H_BNAINTR3
        constexpr uint32_t H_XCS_XACT_ERR3 = (1U << 12);  ///< H_XCS_XACT_ERR3
        constexpr uint32_t H_DESC_LST_ROLLINTR3 = (1U << 13);  ///< H_DESC_LST_ROLLINTR3
    }

    /// HCINTMSK3 Register bits
    namespace hcintmsk3_bits {
        constexpr uint32_t H_XFERCOMPLMSK3 = (1U << 0);  ///< H_XFERCOMPLMSK3
        constexpr uint32_t H_CHHLTDMSK3 = (1U << 1);  ///< H_CHHLTDMSK3
        constexpr uint32_t H_AHBERRMSK3 = (1U << 2);  ///< H_AHBERRMSK3
        constexpr uint32_t H_STALLMSK3 = (1U << 3);  ///< H_STALLMSK3
        constexpr uint32_t H_NAKMSK3 = (1U << 4);  ///< H_NAKMSK3
        constexpr uint32_t H_ACKMSK3 = (1U << 5);  ///< H_ACKMSK3
        constexpr uint32_t H_NYETMSK3 = (1U << 6);  ///< H_NYETMSK3
        constexpr uint32_t H_XACTERRMSK3 = (1U << 7);  ///< H_XACTERRMSK3
        constexpr uint32_t H_BBLERRMSK3 = (1U << 8);  ///< H_BBLERRMSK3
        constexpr uint32_t H_FRMOVRUNMSK3 = (1U << 9);  ///< H_FRMOVRUNMSK3
        constexpr uint32_t H_DATATGLERRMSK3 = (1U << 10);  ///< H_DATATGLERRMSK3
        constexpr uint32_t H_BNAINTRMSK3 = (1U << 11);  ///< H_BNAINTRMSK3
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK3 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK3
    }

    /// HCTSIZ3 Register bits
    namespace hctsiz3_bits {
        constexpr uint32_t H_XFERSIZE3 = (19 << 0);  ///< H_XFERSIZE3
        constexpr uint32_t H_PKTCNT3 = (10 << 19);  ///< H_PKTCNT3
        constexpr uint32_t H_PID3 = (2 << 29);  ///< H_PID3
        constexpr uint32_t H_DOPNG3 = (1U << 31);  ///< H_DOPNG3
    }

    /// HCDMA3 Register bits
    namespace hcdma3_bits {
        constexpr uint32_t H_DMAADDR3 = (32 << 0);  ///< H_DMAADDR3
    }

    /// HCDMAB3 Register bits
    namespace hcdmab3_bits {
        constexpr uint32_t H_HCDMAB3 = (32 << 0);  ///< H_HCDMAB3
    }

    /// HCCHAR4 Register bits
    namespace hcchar4_bits {
        constexpr uint32_t H_MPS4 = (11 << 0);  ///< H_MPS4
        constexpr uint32_t H_EPNUM4 = (4 << 11);  ///< H_EPNUM4
        constexpr uint32_t H_EPDIR4 = (1U << 15);  ///< H_EPDIR4
        constexpr uint32_t H_LSPDDEV4 = (1U << 17);  ///< H_LSPDDEV4
        constexpr uint32_t H_EPTYPE4 = (2 << 18);  ///< H_EPTYPE4
        constexpr uint32_t H_EC4 = (1U << 21);  ///< H_EC4
        constexpr uint32_t H_DEVADDR4 = (7 << 22);  ///< H_DEVADDR4
        constexpr uint32_t H_ODDFRM4 = (1U << 29);  ///< H_ODDFRM4
        constexpr uint32_t H_CHDIS4 = (1U << 30);  ///< H_CHDIS4
        constexpr uint32_t H_CHENA4 = (1U << 31);  ///< H_CHENA4
    }

    /// HCINT4 Register bits
    namespace hcint4_bits {
        constexpr uint32_t H_XFERCOMPL4 = (1U << 0);  ///< H_XFERCOMPL4
        constexpr uint32_t H_CHHLTD4 = (1U << 1);  ///< H_CHHLTD4
        constexpr uint32_t H_AHBERR4 = (1U << 2);  ///< H_AHBERR4
        constexpr uint32_t H_STALL4 = (1U << 3);  ///< H_STALL4
        constexpr uint32_t H_NACK4 = (1U << 4);  ///< H_NACK4
        constexpr uint32_t H_ACK4 = (1U << 5);  ///< H_ACK4
        constexpr uint32_t H_NYET4 = (1U << 6);  ///< H_NYET4
        constexpr uint32_t H_XACTERR4 = (1U << 7);  ///< H_XACTERR4
        constexpr uint32_t H_BBLERR4 = (1U << 8);  ///< H_BBLERR4
        constexpr uint32_t H_FRMOVRUN4 = (1U << 9);  ///< H_FRMOVRUN4
        constexpr uint32_t H_DATATGLERR4 = (1U << 10);  ///< H_DATATGLERR4
        constexpr uint32_t H_BNAINTR4 = (1U << 11);  ///< H_BNAINTR4
        constexpr uint32_t H_XCS_XACT_ERR4 = (1U << 12);  ///< H_XCS_XACT_ERR4
        constexpr uint32_t H_DESC_LST_ROLLINTR4 = (1U << 13);  ///< H_DESC_LST_ROLLINTR4
    }

    /// HCINTMSK4 Register bits
    namespace hcintmsk4_bits {
        constexpr uint32_t H_XFERCOMPLMSK4 = (1U << 0);  ///< H_XFERCOMPLMSK4
        constexpr uint32_t H_CHHLTDMSK4 = (1U << 1);  ///< H_CHHLTDMSK4
        constexpr uint32_t H_AHBERRMSK4 = (1U << 2);  ///< H_AHBERRMSK4
        constexpr uint32_t H_STALLMSK4 = (1U << 3);  ///< H_STALLMSK4
        constexpr uint32_t H_NAKMSK4 = (1U << 4);  ///< H_NAKMSK4
        constexpr uint32_t H_ACKMSK4 = (1U << 5);  ///< H_ACKMSK4
        constexpr uint32_t H_NYETMSK4 = (1U << 6);  ///< H_NYETMSK4
        constexpr uint32_t H_XACTERRMSK4 = (1U << 7);  ///< H_XACTERRMSK4
        constexpr uint32_t H_BBLERRMSK4 = (1U << 8);  ///< H_BBLERRMSK4
        constexpr uint32_t H_FRMOVRUNMSK4 = (1U << 9);  ///< H_FRMOVRUNMSK4
        constexpr uint32_t H_DATATGLERRMSK4 = (1U << 10);  ///< H_DATATGLERRMSK4
        constexpr uint32_t H_BNAINTRMSK4 = (1U << 11);  ///< H_BNAINTRMSK4
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK4 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK4
    }

    /// HCTSIZ4 Register bits
    namespace hctsiz4_bits {
        constexpr uint32_t H_XFERSIZE4 = (19 << 0);  ///< H_XFERSIZE4
        constexpr uint32_t H_PKTCNT4 = (10 << 19);  ///< H_PKTCNT4
        constexpr uint32_t H_PID4 = (2 << 29);  ///< H_PID4
        constexpr uint32_t H_DOPNG4 = (1U << 31);  ///< H_DOPNG4
    }

    /// HCDMA4 Register bits
    namespace hcdma4_bits {
        constexpr uint32_t H_DMAADDR4 = (32 << 0);  ///< H_DMAADDR4
    }

    /// HCDMAB4 Register bits
    namespace hcdmab4_bits {
        constexpr uint32_t H_HCDMAB4 = (32 << 0);  ///< H_HCDMAB4
    }

    /// HCCHAR5 Register bits
    namespace hcchar5_bits {
        constexpr uint32_t H_MPS5 = (11 << 0);  ///< H_MPS5
        constexpr uint32_t H_EPNUM5 = (4 << 11);  ///< H_EPNUM5
        constexpr uint32_t H_EPDIR5 = (1U << 15);  ///< H_EPDIR5
        constexpr uint32_t H_LSPDDEV5 = (1U << 17);  ///< H_LSPDDEV5
        constexpr uint32_t H_EPTYPE5 = (2 << 18);  ///< H_EPTYPE5
        constexpr uint32_t H_EC5 = (1U << 21);  ///< H_EC5
        constexpr uint32_t H_DEVADDR5 = (7 << 22);  ///< H_DEVADDR5
        constexpr uint32_t H_ODDFRM5 = (1U << 29);  ///< H_ODDFRM5
        constexpr uint32_t H_CHDIS5 = (1U << 30);  ///< H_CHDIS5
        constexpr uint32_t H_CHENA5 = (1U << 31);  ///< H_CHENA5
    }

    /// HCINT5 Register bits
    namespace hcint5_bits {
        constexpr uint32_t H_XFERCOMPL5 = (1U << 0);  ///< H_XFERCOMPL5
        constexpr uint32_t H_CHHLTD5 = (1U << 1);  ///< H_CHHLTD5
        constexpr uint32_t H_AHBERR5 = (1U << 2);  ///< H_AHBERR5
        constexpr uint32_t H_STALL5 = (1U << 3);  ///< H_STALL5
        constexpr uint32_t H_NACK5 = (1U << 4);  ///< H_NACK5
        constexpr uint32_t H_ACK5 = (1U << 5);  ///< H_ACK5
        constexpr uint32_t H_NYET5 = (1U << 6);  ///< H_NYET5
        constexpr uint32_t H_XACTERR5 = (1U << 7);  ///< H_XACTERR5
        constexpr uint32_t H_BBLERR5 = (1U << 8);  ///< H_BBLERR5
        constexpr uint32_t H_FRMOVRUN5 = (1U << 9);  ///< H_FRMOVRUN5
        constexpr uint32_t H_DATATGLERR5 = (1U << 10);  ///< H_DATATGLERR5
        constexpr uint32_t H_BNAINTR5 = (1U << 11);  ///< H_BNAINTR5
        constexpr uint32_t H_XCS_XACT_ERR5 = (1U << 12);  ///< H_XCS_XACT_ERR5
        constexpr uint32_t H_DESC_LST_ROLLINTR5 = (1U << 13);  ///< H_DESC_LST_ROLLINTR5
    }

    /// HCINTMSK5 Register bits
    namespace hcintmsk5_bits {
        constexpr uint32_t H_XFERCOMPLMSK5 = (1U << 0);  ///< H_XFERCOMPLMSK5
        constexpr uint32_t H_CHHLTDMSK5 = (1U << 1);  ///< H_CHHLTDMSK5
        constexpr uint32_t H_AHBERRMSK5 = (1U << 2);  ///< H_AHBERRMSK5
        constexpr uint32_t H_STALLMSK5 = (1U << 3);  ///< H_STALLMSK5
        constexpr uint32_t H_NAKMSK5 = (1U << 4);  ///< H_NAKMSK5
        constexpr uint32_t H_ACKMSK5 = (1U << 5);  ///< H_ACKMSK5
        constexpr uint32_t H_NYETMSK5 = (1U << 6);  ///< H_NYETMSK5
        constexpr uint32_t H_XACTERRMSK5 = (1U << 7);  ///< H_XACTERRMSK5
        constexpr uint32_t H_BBLERRMSK5 = (1U << 8);  ///< H_BBLERRMSK5
        constexpr uint32_t H_FRMOVRUNMSK5 = (1U << 9);  ///< H_FRMOVRUNMSK5
        constexpr uint32_t H_DATATGLERRMSK5 = (1U << 10);  ///< H_DATATGLERRMSK5
        constexpr uint32_t H_BNAINTRMSK5 = (1U << 11);  ///< H_BNAINTRMSK5
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK5 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK5
    }

    /// HCTSIZ5 Register bits
    namespace hctsiz5_bits {
        constexpr uint32_t H_XFERSIZE5 = (19 << 0);  ///< H_XFERSIZE5
        constexpr uint32_t H_PKTCNT5 = (10 << 19);  ///< H_PKTCNT5
        constexpr uint32_t H_PID5 = (2 << 29);  ///< H_PID5
        constexpr uint32_t H_DOPNG5 = (1U << 31);  ///< H_DOPNG5
    }

    /// HCDMA5 Register bits
    namespace hcdma5_bits {
        constexpr uint32_t H_DMAADDR5 = (32 << 0);  ///< H_DMAADDR5
    }

    /// HCDMAB5 Register bits
    namespace hcdmab5_bits {
        constexpr uint32_t H_HCDMAB5 = (32 << 0);  ///< H_HCDMAB5
    }

    /// HCCHAR6 Register bits
    namespace hcchar6_bits {
        constexpr uint32_t H_MPS6 = (11 << 0);  ///< H_MPS6
        constexpr uint32_t H_EPNUM6 = (4 << 11);  ///< H_EPNUM6
        constexpr uint32_t H_EPDIR6 = (1U << 15);  ///< H_EPDIR6
        constexpr uint32_t H_LSPDDEV6 = (1U << 17);  ///< H_LSPDDEV6
        constexpr uint32_t H_EPTYPE6 = (2 << 18);  ///< H_EPTYPE6
        constexpr uint32_t H_EC6 = (1U << 21);  ///< H_EC6
        constexpr uint32_t H_DEVADDR6 = (7 << 22);  ///< H_DEVADDR6
        constexpr uint32_t H_ODDFRM6 = (1U << 29);  ///< H_ODDFRM6
        constexpr uint32_t H_CHDIS6 = (1U << 30);  ///< H_CHDIS6
        constexpr uint32_t H_CHENA6 = (1U << 31);  ///< H_CHENA6
    }

    /// HCINT6 Register bits
    namespace hcint6_bits {
        constexpr uint32_t H_XFERCOMPL6 = (1U << 0);  ///< H_XFERCOMPL6
        constexpr uint32_t H_CHHLTD6 = (1U << 1);  ///< H_CHHLTD6
        constexpr uint32_t H_AHBERR6 = (1U << 2);  ///< H_AHBERR6
        constexpr uint32_t H_STALL6 = (1U << 3);  ///< H_STALL6
        constexpr uint32_t H_NACK6 = (1U << 4);  ///< H_NACK6
        constexpr uint32_t H_ACK6 = (1U << 5);  ///< H_ACK6
        constexpr uint32_t H_NYET6 = (1U << 6);  ///< H_NYET6
        constexpr uint32_t H_XACTERR6 = (1U << 7);  ///< H_XACTERR6
        constexpr uint32_t H_BBLERR6 = (1U << 8);  ///< H_BBLERR6
        constexpr uint32_t H_FRMOVRUN6 = (1U << 9);  ///< H_FRMOVRUN6
        constexpr uint32_t H_DATATGLERR6 = (1U << 10);  ///< H_DATATGLERR6
        constexpr uint32_t H_BNAINTR6 = (1U << 11);  ///< H_BNAINTR6
        constexpr uint32_t H_XCS_XACT_ERR6 = (1U << 12);  ///< H_XCS_XACT_ERR6
        constexpr uint32_t H_DESC_LST_ROLLINTR6 = (1U << 13);  ///< H_DESC_LST_ROLLINTR6
    }

    /// HCINTMSK6 Register bits
    namespace hcintmsk6_bits {
        constexpr uint32_t H_XFERCOMPLMSK6 = (1U << 0);  ///< H_XFERCOMPLMSK6
        constexpr uint32_t H_CHHLTDMSK6 = (1U << 1);  ///< H_CHHLTDMSK6
        constexpr uint32_t H_AHBERRMSK6 = (1U << 2);  ///< H_AHBERRMSK6
        constexpr uint32_t H_STALLMSK6 = (1U << 3);  ///< H_STALLMSK6
        constexpr uint32_t H_NAKMSK6 = (1U << 4);  ///< H_NAKMSK6
        constexpr uint32_t H_ACKMSK6 = (1U << 5);  ///< H_ACKMSK6
        constexpr uint32_t H_NYETMSK6 = (1U << 6);  ///< H_NYETMSK6
        constexpr uint32_t H_XACTERRMSK6 = (1U << 7);  ///< H_XACTERRMSK6
        constexpr uint32_t H_BBLERRMSK6 = (1U << 8);  ///< H_BBLERRMSK6
        constexpr uint32_t H_FRMOVRUNMSK6 = (1U << 9);  ///< H_FRMOVRUNMSK6
        constexpr uint32_t H_DATATGLERRMSK6 = (1U << 10);  ///< H_DATATGLERRMSK6
        constexpr uint32_t H_BNAINTRMSK6 = (1U << 11);  ///< H_BNAINTRMSK6
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK6 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK6
    }

    /// HCTSIZ6 Register bits
    namespace hctsiz6_bits {
        constexpr uint32_t H_XFERSIZE6 = (19 << 0);  ///< H_XFERSIZE6
        constexpr uint32_t H_PKTCNT6 = (10 << 19);  ///< H_PKTCNT6
        constexpr uint32_t H_PID6 = (2 << 29);  ///< H_PID6
        constexpr uint32_t H_DOPNG6 = (1U << 31);  ///< H_DOPNG6
    }

    /// HCDMA6 Register bits
    namespace hcdma6_bits {
        constexpr uint32_t H_DMAADDR6 = (32 << 0);  ///< H_DMAADDR6
    }

    /// HCDMAB6 Register bits
    namespace hcdmab6_bits {
        constexpr uint32_t H_HCDMAB6 = (32 << 0);  ///< H_HCDMAB6
    }

    /// HCCHAR7 Register bits
    namespace hcchar7_bits {
        constexpr uint32_t H_MPS7 = (11 << 0);  ///< H_MPS7
        constexpr uint32_t H_EPNUM7 = (4 << 11);  ///< H_EPNUM7
        constexpr uint32_t H_EPDIR7 = (1U << 15);  ///< H_EPDIR7
        constexpr uint32_t H_LSPDDEV7 = (1U << 17);  ///< H_LSPDDEV7
        constexpr uint32_t H_EPTYPE7 = (2 << 18);  ///< H_EPTYPE7
        constexpr uint32_t H_EC7 = (1U << 21);  ///< H_EC7
        constexpr uint32_t H_DEVADDR7 = (7 << 22);  ///< H_DEVADDR7
        constexpr uint32_t H_ODDFRM7 = (1U << 29);  ///< H_ODDFRM7
        constexpr uint32_t H_CHDIS7 = (1U << 30);  ///< H_CHDIS7
        constexpr uint32_t H_CHENA7 = (1U << 31);  ///< H_CHENA7
    }

    /// HCINT7 Register bits
    namespace hcint7_bits {
        constexpr uint32_t H_XFERCOMPL7 = (1U << 0);  ///< H_XFERCOMPL7
        constexpr uint32_t H_CHHLTD7 = (1U << 1);  ///< H_CHHLTD7
        constexpr uint32_t H_AHBERR7 = (1U << 2);  ///< H_AHBERR7
        constexpr uint32_t H_STALL7 = (1U << 3);  ///< H_STALL7
        constexpr uint32_t H_NACK7 = (1U << 4);  ///< H_NACK7
        constexpr uint32_t H_ACK7 = (1U << 5);  ///< H_ACK7
        constexpr uint32_t H_NYET7 = (1U << 6);  ///< H_NYET7
        constexpr uint32_t H_XACTERR7 = (1U << 7);  ///< H_XACTERR7
        constexpr uint32_t H_BBLERR7 = (1U << 8);  ///< H_BBLERR7
        constexpr uint32_t H_FRMOVRUN7 = (1U << 9);  ///< H_FRMOVRUN7
        constexpr uint32_t H_DATATGLERR7 = (1U << 10);  ///< H_DATATGLERR7
        constexpr uint32_t H_BNAINTR7 = (1U << 11);  ///< H_BNAINTR7
        constexpr uint32_t H_XCS_XACT_ERR7 = (1U << 12);  ///< H_XCS_XACT_ERR7
        constexpr uint32_t H_DESC_LST_ROLLINTR7 = (1U << 13);  ///< H_DESC_LST_ROLLINTR7
    }

    /// HCINTMSK7 Register bits
    namespace hcintmsk7_bits {
        constexpr uint32_t H_XFERCOMPLMSK7 = (1U << 0);  ///< H_XFERCOMPLMSK7
        constexpr uint32_t H_CHHLTDMSK7 = (1U << 1);  ///< H_CHHLTDMSK7
        constexpr uint32_t H_AHBERRMSK7 = (1U << 2);  ///< H_AHBERRMSK7
        constexpr uint32_t H_STALLMSK7 = (1U << 3);  ///< H_STALLMSK7
        constexpr uint32_t H_NAKMSK7 = (1U << 4);  ///< H_NAKMSK7
        constexpr uint32_t H_ACKMSK7 = (1U << 5);  ///< H_ACKMSK7
        constexpr uint32_t H_NYETMSK7 = (1U << 6);  ///< H_NYETMSK7
        constexpr uint32_t H_XACTERRMSK7 = (1U << 7);  ///< H_XACTERRMSK7
        constexpr uint32_t H_BBLERRMSK7 = (1U << 8);  ///< H_BBLERRMSK7
        constexpr uint32_t H_FRMOVRUNMSK7 = (1U << 9);  ///< H_FRMOVRUNMSK7
        constexpr uint32_t H_DATATGLERRMSK7 = (1U << 10);  ///< H_DATATGLERRMSK7
        constexpr uint32_t H_BNAINTRMSK7 = (1U << 11);  ///< H_BNAINTRMSK7
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK7 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK7
    }

    /// HCTSIZ7 Register bits
    namespace hctsiz7_bits {
        constexpr uint32_t H_XFERSIZE7 = (19 << 0);  ///< H_XFERSIZE7
        constexpr uint32_t H_PKTCNT7 = (10 << 19);  ///< H_PKTCNT7
        constexpr uint32_t H_PID7 = (2 << 29);  ///< H_PID7
        constexpr uint32_t H_DOPNG7 = (1U << 31);  ///< H_DOPNG7
    }

    /// HCDMA7 Register bits
    namespace hcdma7_bits {
        constexpr uint32_t H_DMAADDR7 = (32 << 0);  ///< H_DMAADDR7
    }

    /// HCDMAB7 Register bits
    namespace hcdmab7_bits {
        constexpr uint32_t H_HCDMAB7 = (32 << 0);  ///< H_HCDMAB7
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t NZSTSOUTHSHK = (1U << 2);  ///< NZSTSOUTHSHK
        constexpr uint32_t ENA32KHZSUSP = (1U << 3);  ///< ENA32KHZSUSP
        constexpr uint32_t DEVADDR = (7 << 4);  ///< DEVADDR
        constexpr uint32_t PERFRLINT = (2 << 11);  ///< PERFRLINT
        constexpr uint32_t ENDEVOUTNAK = (1U << 13);  ///< ENDEVOUTNAK
        constexpr uint32_t XCVRDLY = (1U << 14);  ///< XCVRDLY
        constexpr uint32_t ERRATICINTMSK = (1U << 15);  ///< ERRATICINTMSK
        constexpr uint32_t EPMISCNT = (5 << 18);  ///< EPMISCNT
        constexpr uint32_t DESCDMA = (1U << 23);  ///< DESCDMA
        constexpr uint32_t PERSCHINTVL = (2 << 24);  ///< PERSCHINTVL
        constexpr uint32_t RESVALID = (6 << 26);  ///< RESVALID
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RMTWKUPSIG = (1U << 0);  ///< RMTWKUPSIG
        constexpr uint32_t SFTDISCON = (1U << 1);  ///< SFTDISCON
        constexpr uint32_t GNPINNAKSTS = (1U << 2);  ///< GNPINNAKSTS
        constexpr uint32_t GOUTNAKSTS = (1U << 3);  ///< GOUTNAKSTS
        constexpr uint32_t TSTCTL = (3 << 4);  ///< TSTCTL
        constexpr uint32_t SGNPINNAK = (1U << 7);  ///< SGNPINNAK
        constexpr uint32_t CGNPINNAK = (1U << 8);  ///< CGNPINNAK
        constexpr uint32_t SGOUTNAK = (1U << 9);  ///< SGOUTNAK
        constexpr uint32_t CGOUTNAK = (1U << 10);  ///< CGOUTNAK
        constexpr uint32_t PWRONPRGDONE = (1U << 11);  ///< PWRONPRGDONE
        constexpr uint32_t GMC = (2 << 13);  ///< GMC
        constexpr uint32_t IGNRFRMNUM = (1U << 15);  ///< IGNRFRMNUM
        constexpr uint32_t NAKONBBLE = (1U << 16);  ///< NAKONBBLE
        constexpr uint32_t ENCOUNTONBNA = (1U << 17);  ///< ENCOUNTONBNA
        constexpr uint32_t DEEPSLEEPBESLREJECT = (1U << 18);  ///< DEEPSLEEPBESLREJECT
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SUSPSTS = (1U << 0);  ///< SUSPSTS
        constexpr uint32_t ENUMSPD = (2 << 1);  ///< ENUMSPD
        constexpr uint32_t ERRTICERR = (1U << 3);  ///< ERRTICERR
        constexpr uint32_t SOFFN = (14 << 8);  ///< SOFFN
        constexpr uint32_t DEVLNSTS = (2 << 22);  ///< DEVLNSTS
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t DI_XFERCOMPLMSK = (1U << 0);  ///< DI_XFERCOMPLMSK
        constexpr uint32_t DI_EPDISBLDMSK = (1U << 1);  ///< DI_EPDISBLDMSK
        constexpr uint32_t DI_AHBERMSK = (1U << 2);  ///< DI_AHBERMSK
        constexpr uint32_t TIMEOUTMSK = (1U << 3);  ///< TIMEOUTMSK
        constexpr uint32_t INTKNTXFEMPMSK = (1U << 4);  ///< INTKNTXFEMPMSK
        constexpr uint32_t INTKNEPMISMSK = (1U << 5);  ///< INTKNEPMISMSK
        constexpr uint32_t INEPNAKEFFMSK = (1U << 6);  ///< INEPNAKEFFMSK
        constexpr uint32_t TXFIFOUNDRNMSK = (1U << 8);  ///< TXFIFOUNDRNMSK
        constexpr uint32_t BNAININTRMSK = (1U << 9);  ///< BNAININTRMSK
        constexpr uint32_t DI_NAKMSK = (1U << 13);  ///< DI_NAKMSK
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XFERCOMPLMSK = (1U << 0);  ///< XFERCOMPLMSK
        constexpr uint32_t EPDISBLDMSK = (1U << 1);  ///< EPDISBLDMSK
        constexpr uint32_t AHBERMSK = (1U << 2);  ///< AHBERMSK
        constexpr uint32_t SETUPMSK = (1U << 3);  ///< SETUPMSK
        constexpr uint32_t OUTTKNEPDISMSK = (1U << 4);  ///< OUTTKNEPDISMSK
        constexpr uint32_t STSPHSERCVDMSK = (1U << 5);  ///< STSPHSERCVDMSK
        constexpr uint32_t BACK2BACKSETUP = (1U << 6);  ///< BACK2BACKSETUP
        constexpr uint32_t OUTPKTERRMSK = (1U << 8);  ///< OUTPKTERRMSK
        constexpr uint32_t BNAOUTINTRMSK = (1U << 9);  ///< BNAOUTINTRMSK
        constexpr uint32_t BBLEERRMSK = (1U << 12);  ///< BBLEERRMSK
        constexpr uint32_t NAKMSK = (1U << 13);  ///< NAKMSK
        constexpr uint32_t NYETMSK = (1U << 14);  ///< NYETMSK
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t INEPINT0 = (1U << 0);  ///< INEPINT0
        constexpr uint32_t INEPINT1 = (1U << 1);  ///< INEPINT1
        constexpr uint32_t INEPINT2 = (1U << 2);  ///< INEPINT2
        constexpr uint32_t INEPINT3 = (1U << 3);  ///< INEPINT3
        constexpr uint32_t INEPINT4 = (1U << 4);  ///< INEPINT4
        constexpr uint32_t INEPINT5 = (1U << 5);  ///< INEPINT5
        constexpr uint32_t INEPINT6 = (1U << 6);  ///< INEPINT6
        constexpr uint32_t OUTEPINT0 = (1U << 16);  ///< OUTEPINT0
        constexpr uint32_t OUTEPINT1 = (1U << 17);  ///< OUTEPINT1
        constexpr uint32_t OUTEPINT2 = (1U << 18);  ///< OUTEPINT2
        constexpr uint32_t OUTEPINT3 = (1U << 19);  ///< OUTEPINT3
        constexpr uint32_t OUTEPINT4 = (1U << 20);  ///< OUTEPINT4
        constexpr uint32_t OUTEPINT5 = (1U << 21);  ///< OUTEPINT5
        constexpr uint32_t OUTEPINT6 = (1U << 22);  ///< OUTEPINT6
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t INEPMSK0 = (1U << 0);  ///< INEPMSK0
        constexpr uint32_t INEPMSK1 = (1U << 1);  ///< INEPMSK1
        constexpr uint32_t INEPMSK2 = (1U << 2);  ///< INEPMSK2
        constexpr uint32_t INEPMSK3 = (1U << 3);  ///< INEPMSK3
        constexpr uint32_t INEPMSK4 = (1U << 4);  ///< INEPMSK4
        constexpr uint32_t INEPMSK5 = (1U << 5);  ///< INEPMSK5
        constexpr uint32_t INEPMSK6 = (1U << 6);  ///< INEPMSK6
        constexpr uint32_t OUTEPMSK0 = (1U << 16);  ///< OUTEPMSK0
        constexpr uint32_t OUTEPMSK1 = (1U << 17);  ///< OUTEPMSK1
        constexpr uint32_t OUTEPMSK2 = (1U << 18);  ///< OUTEPMSK2
        constexpr uint32_t OUTEPMSK3 = (1U << 19);  ///< OUTEPMSK3
        constexpr uint32_t OUTEPMSK4 = (1U << 20);  ///< OUTEPMSK4
        constexpr uint32_t OUTEPMSK5 = (1U << 21);  ///< OUTEPMSK5
        constexpr uint32_t OUTEPMSK6 = (1U << 22);  ///< OUTEPMSK6
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t DVBUSDIS = (16 << 0);  ///< DVBUSDIS
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSPULSE = (12 << 0);  ///< DVBUSPULSE
    }

    /// DTHRCTL Register bits
    namespace dthrctl_bits {
        constexpr uint32_t NONISOTHREN = (1U << 0);  ///< NONISOTHREN
        constexpr uint32_t ISOTHREN = (1U << 1);  ///< ISOTHREN
        constexpr uint32_t TXTHRLEN = (9 << 2);  ///< TXTHRLEN
        constexpr uint32_t AHBTHRRATIO = (2 << 11);  ///< AHBTHRRATIO
        constexpr uint32_t RXTHREN = (1U << 16);  ///< RXTHREN
        constexpr uint32_t RXTHRLEN = (9 << 17);  ///< RXTHRLEN
        constexpr uint32_t ARBPRKEN = (1U << 27);  ///< ARBPRKEN
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t D_INEPTXFEMPMSK = (16 << 0);  ///< D_INEPTXFEMPMSK
    }

    /// DIEPCTL0 Register bits
    namespace diepctl0_bits {
        constexpr uint32_t D_MPS0 = (2 << 0);  ///< D_MPS0
        constexpr uint32_t D_USBACTEP0 = (1U << 15);  ///< D_USBACTEP0
        constexpr uint32_t D_NAKSTS0 = (1U << 17);  ///< D_NAKSTS0
        constexpr uint32_t D_EPTYPE0 = (2 << 18);  ///< D_EPTYPE0
        constexpr uint32_t D_STALL0 = (1U << 21);  ///< D_STALL0
        constexpr uint32_t D_TXFNUM0 = (4 << 22);  ///< D_TXFNUM0
        constexpr uint32_t D_CNAK0 = (1U << 26);  ///< D_CNAK0
        constexpr uint32_t DI_SNAK0 = (1U << 27);  ///< DI_SNAK0
        constexpr uint32_t D_EPDIS0 = (1U << 30);  ///< D_EPDIS0
        constexpr uint32_t D_EPENA0 = (1U << 31);  ///< D_EPENA0
    }

    /// DIEPINT0 Register bits
    namespace diepint0_bits {
        constexpr uint32_t D_XFERCOMPL0 = (1U << 0);  ///< D_XFERCOMPL0
        constexpr uint32_t D_EPDISBLD0 = (1U << 1);  ///< D_EPDISBLD0
        constexpr uint32_t D_AHBERR0 = (1U << 2);  ///< D_AHBERR0
        constexpr uint32_t D_TIMEOUT0 = (1U << 3);  ///< D_TIMEOUT0
        constexpr uint32_t D_INTKNTXFEMP0 = (1U << 4);  ///< D_INTKNTXFEMP0
        constexpr uint32_t D_INTKNEPMIS0 = (1U << 5);  ///< D_INTKNEPMIS0
        constexpr uint32_t D_INEPNAKEFF0 = (1U << 6);  ///< D_INEPNAKEFF0
        constexpr uint32_t D_TXFEMP0 = (1U << 7);  ///< D_TXFEMP0
        constexpr uint32_t D_TXFIFOUNDRN0 = (1U << 8);  ///< D_TXFIFOUNDRN0
        constexpr uint32_t D_BNAINTR0 = (1U << 9);  ///< D_BNAINTR0
        constexpr uint32_t D_PKTDRPSTS0 = (1U << 11);  ///< D_PKTDRPSTS0
        constexpr uint32_t D_BBLEERR0 = (1U << 12);  ///< D_BBLEERR0
        constexpr uint32_t D_NAKINTRPT0 = (1U << 13);  ///< D_NAKINTRPT0
        constexpr uint32_t D_NYETINTRPT0 = (1U << 14);  ///< D_NYETINTRPT0
    }

    /// DIEPTSIZ0 Register bits
    namespace dieptsiz0_bits {
        constexpr uint32_t D_XFERSIZE0 = (7 << 0);  ///< D_XFERSIZE0
        constexpr uint32_t D_PKTCNT0 = (2 << 19);  ///< D_PKTCNT0
    }

    /// DIEPDMA0 Register bits
    namespace diepdma0_bits {
        constexpr uint32_t D_DMAADDR0 = (32 << 0);  ///< D_DMAADDR0
    }

    /// DTXFSTS0 Register bits
    namespace dtxfsts0_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL0 = (16 << 0);  ///< D_INEPTXFSPCAVAIL0
    }

    /// DIEPDMAB0 Register bits
    namespace diepdmab0_bits {
        constexpr uint32_t D_DMABUFFERADDR0 = (32 << 0);  ///< D_DMABUFFERADDR0
    }

    /// DIEPCTL1 Register bits
    namespace diepctl1_bits {
        constexpr uint32_t D_MPS1 = (2 << 0);  ///< D_MPS1
        constexpr uint32_t D_USBACTEP1 = (1U << 15);  ///< D_USBACTEP1
        constexpr uint32_t D_NAKSTS1 = (1U << 17);  ///< D_NAKSTS1
        constexpr uint32_t D_EPTYPE1 = (2 << 18);  ///< D_EPTYPE1
        constexpr uint32_t D_STALL1 = (1U << 21);  ///< D_STALL1
        constexpr uint32_t D_TXFNUM1 = (4 << 22);  ///< D_TXFNUM1
        constexpr uint32_t D_CNAK1 = (1U << 26);  ///< D_CNAK1
        constexpr uint32_t DI_SNAK1 = (1U << 27);  ///< DI_SNAK1
        constexpr uint32_t DI_SETD0PID1 = (1U << 28);  ///< DI_SETD0PID1
        constexpr uint32_t DI_SETD1PID1 = (1U << 29);  ///< DI_SETD1PID1
        constexpr uint32_t D_EPDIS1 = (1U << 30);  ///< D_EPDIS1
        constexpr uint32_t D_EPENA1 = (1U << 31);  ///< D_EPENA1
    }

    /// DIEPINT1 Register bits
    namespace diepint1_bits {
        constexpr uint32_t D_XFERCOMPL1 = (1U << 0);  ///< D_XFERCOMPL1
        constexpr uint32_t D_EPDISBLD1 = (1U << 1);  ///< D_EPDISBLD1
        constexpr uint32_t D_AHBERR1 = (1U << 2);  ///< D_AHBERR1
        constexpr uint32_t D_TIMEOUT1 = (1U << 3);  ///< D_TIMEOUT1
        constexpr uint32_t D_INTKNTXFEMP1 = (1U << 4);  ///< D_INTKNTXFEMP1
        constexpr uint32_t D_INTKNEPMIS1 = (1U << 5);  ///< D_INTKNEPMIS1
        constexpr uint32_t D_INEPNAKEFF1 = (1U << 6);  ///< D_INEPNAKEFF1
        constexpr uint32_t D_TXFEMP1 = (1U << 7);  ///< D_TXFEMP1
        constexpr uint32_t D_TXFIFOUNDRN1 = (1U << 8);  ///< D_TXFIFOUNDRN1
        constexpr uint32_t D_BNAINTR1 = (1U << 9);  ///< D_BNAINTR1
        constexpr uint32_t D_PKTDRPSTS1 = (1U << 11);  ///< D_PKTDRPSTS1
        constexpr uint32_t D_BBLEERR1 = (1U << 12);  ///< D_BBLEERR1
        constexpr uint32_t D_NAKINTRPT1 = (1U << 13);  ///< D_NAKINTRPT1
        constexpr uint32_t D_NYETINTRPT1 = (1U << 14);  ///< D_NYETINTRPT1
    }

    /// DIEPTSIZ1 Register bits
    namespace dieptsiz1_bits {
        constexpr uint32_t D_XFERSIZE1 = (7 << 0);  ///< D_XFERSIZE1
        constexpr uint32_t D_PKTCNT1 = (2 << 19);  ///< D_PKTCNT1
    }

    /// DIEPDMA1 Register bits
    namespace diepdma1_bits {
        constexpr uint32_t D_DMAADDR1 = (32 << 0);  ///< D_DMAADDR1
    }

    /// DTXFSTS1 Register bits
    namespace dtxfsts1_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL1 = (16 << 0);  ///< D_INEPTXFSPCAVAIL1
    }

    /// DIEPDMAB1 Register bits
    namespace diepdmab1_bits {
        constexpr uint32_t D_DMABUFFERADDR1 = (32 << 0);  ///< D_DMABUFFERADDR1
    }

    /// DIEPCTL2 Register bits
    namespace diepctl2_bits {
        constexpr uint32_t D_MPS2 = (2 << 0);  ///< D_MPS2
        constexpr uint32_t D_USBACTEP2 = (1U << 15);  ///< D_USBACTEP2
        constexpr uint32_t D_NAKSTS2 = (1U << 17);  ///< D_NAKSTS2
        constexpr uint32_t D_EPTYPE2 = (2 << 18);  ///< D_EPTYPE2
        constexpr uint32_t D_STALL2 = (1U << 21);  ///< D_STALL2
        constexpr uint32_t D_TXFNUM2 = (4 << 22);  ///< D_TXFNUM2
        constexpr uint32_t D_CNAK2 = (1U << 26);  ///< D_CNAK2
        constexpr uint32_t DI_SNAK2 = (1U << 27);  ///< DI_SNAK2
        constexpr uint32_t DI_SETD0PID2 = (1U << 28);  ///< DI_SETD0PID2
        constexpr uint32_t DI_SETD1PID2 = (1U << 29);  ///< DI_SETD1PID2
        constexpr uint32_t D_EPDIS2 = (1U << 30);  ///< D_EPDIS2
        constexpr uint32_t D_EPENA2 = (1U << 31);  ///< D_EPENA2
    }

    /// DIEPINT2 Register bits
    namespace diepint2_bits {
        constexpr uint32_t D_XFERCOMPL2 = (1U << 0);  ///< D_XFERCOMPL2
        constexpr uint32_t D_EPDISBLD2 = (1U << 1);  ///< D_EPDISBLD2
        constexpr uint32_t D_AHBERR2 = (1U << 2);  ///< D_AHBERR2
        constexpr uint32_t D_TIMEOUT2 = (1U << 3);  ///< D_TIMEOUT2
        constexpr uint32_t D_INTKNTXFEMP2 = (1U << 4);  ///< D_INTKNTXFEMP2
        constexpr uint32_t D_INTKNEPMIS2 = (1U << 5);  ///< D_INTKNEPMIS2
        constexpr uint32_t D_INEPNAKEFF2 = (1U << 6);  ///< D_INEPNAKEFF2
        constexpr uint32_t D_TXFEMP2 = (1U << 7);  ///< D_TXFEMP2
        constexpr uint32_t D_TXFIFOUNDRN2 = (1U << 8);  ///< D_TXFIFOUNDRN2
        constexpr uint32_t D_BNAINTR2 = (1U << 9);  ///< D_BNAINTR2
        constexpr uint32_t D_PKTDRPSTS2 = (1U << 11);  ///< D_PKTDRPSTS2
        constexpr uint32_t D_BBLEERR2 = (1U << 12);  ///< D_BBLEERR2
        constexpr uint32_t D_NAKINTRPT2 = (1U << 13);  ///< D_NAKINTRPT2
        constexpr uint32_t D_NYETINTRPT2 = (1U << 14);  ///< D_NYETINTRPT2
    }

    /// DIEPTSIZ2 Register bits
    namespace dieptsiz2_bits {
        constexpr uint32_t D_XFERSIZE2 = (7 << 0);  ///< D_XFERSIZE2
        constexpr uint32_t D_PKTCNT2 = (2 << 19);  ///< D_PKTCNT2
    }

    /// DIEPDMA2 Register bits
    namespace diepdma2_bits {
        constexpr uint32_t D_DMAADDR2 = (32 << 0);  ///< D_DMAADDR2
    }

    /// DTXFSTS2 Register bits
    namespace dtxfsts2_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL2 = (16 << 0);  ///< D_INEPTXFSPCAVAIL2
    }

    /// DIEPDMAB2 Register bits
    namespace diepdmab2_bits {
        constexpr uint32_t D_DMABUFFERADDR2 = (32 << 0);  ///< D_DMABUFFERADDR2
    }

    /// DIEPCTL3 Register bits
    namespace diepctl3_bits {
        constexpr uint32_t DI_MPS3 = (2 << 0);  ///< DI_MPS3
        constexpr uint32_t DI_USBACTEP3 = (1U << 15);  ///< DI_USBACTEP3
        constexpr uint32_t DI_NAKSTS3 = (1U << 17);  ///< DI_NAKSTS3
        constexpr uint32_t DI_EPTYPE3 = (2 << 18);  ///< DI_EPTYPE3
        constexpr uint32_t DI_STALL3 = (1U << 21);  ///< DI_STALL3
        constexpr uint32_t DI_TXFNUM3 = (4 << 22);  ///< DI_TXFNUM3
        constexpr uint32_t DI_CNAK3 = (1U << 26);  ///< DI_CNAK3
        constexpr uint32_t DI_SNAK3 = (1U << 27);  ///< DI_SNAK3
        constexpr uint32_t DI_SETD0PID3 = (1U << 28);  ///< DI_SETD0PID3
        constexpr uint32_t DI_SETD1PID3 = (1U << 29);  ///< DI_SETD1PID3
        constexpr uint32_t DI_EPDIS3 = (1U << 30);  ///< DI_EPDIS3
        constexpr uint32_t DI_EPENA3 = (1U << 31);  ///< DI_EPENA3
    }

    /// DIEPINT3 Register bits
    namespace diepint3_bits {
        constexpr uint32_t D_XFERCOMPL3 = (1U << 0);  ///< D_XFERCOMPL3
        constexpr uint32_t D_EPDISBLD3 = (1U << 1);  ///< D_EPDISBLD3
        constexpr uint32_t D_AHBERR3 = (1U << 2);  ///< D_AHBERR3
        constexpr uint32_t D_TIMEOUT3 = (1U << 3);  ///< D_TIMEOUT3
        constexpr uint32_t D_INTKNTXFEMP3 = (1U << 4);  ///< D_INTKNTXFEMP3
        constexpr uint32_t D_INTKNEPMIS3 = (1U << 5);  ///< D_INTKNEPMIS3
        constexpr uint32_t D_INEPNAKEFF3 = (1U << 6);  ///< D_INEPNAKEFF3
        constexpr uint32_t D_TXFEMP3 = (1U << 7);  ///< D_TXFEMP3
        constexpr uint32_t D_TXFIFOUNDRN3 = (1U << 8);  ///< D_TXFIFOUNDRN3
        constexpr uint32_t D_BNAINTR3 = (1U << 9);  ///< D_BNAINTR3
        constexpr uint32_t D_PKTDRPSTS3 = (1U << 11);  ///< D_PKTDRPSTS3
        constexpr uint32_t D_BBLEERR3 = (1U << 12);  ///< D_BBLEERR3
        constexpr uint32_t D_NAKINTRPT3 = (1U << 13);  ///< D_NAKINTRPT3
        constexpr uint32_t D_NYETINTRPT3 = (1U << 14);  ///< D_NYETINTRPT3
    }

    /// DIEPTSIZ3 Register bits
    namespace dieptsiz3_bits {
        constexpr uint32_t D_XFERSIZE3 = (7 << 0);  ///< D_XFERSIZE3
        constexpr uint32_t D_PKTCNT3 = (2 << 19);  ///< D_PKTCNT3
    }

    /// DIEPDMA3 Register bits
    namespace diepdma3_bits {
        constexpr uint32_t D_DMAADDR3 = (32 << 0);  ///< D_DMAADDR3
    }

    /// DTXFSTS3 Register bits
    namespace dtxfsts3_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL3 = (16 << 0);  ///< D_INEPTXFSPCAVAIL3
    }

    /// DIEPDMAB3 Register bits
    namespace diepdmab3_bits {
        constexpr uint32_t D_DMABUFFERADDR3 = (32 << 0);  ///< D_DMABUFFERADDR3
    }

    /// DIEPCTL4 Register bits
    namespace diepctl4_bits {
        constexpr uint32_t D_MPS4 = (2 << 0);  ///< D_MPS4
        constexpr uint32_t D_USBACTEP4 = (1U << 15);  ///< D_USBACTEP4
        constexpr uint32_t D_NAKSTS4 = (1U << 17);  ///< D_NAKSTS4
        constexpr uint32_t D_EPTYPE4 = (2 << 18);  ///< D_EPTYPE4
        constexpr uint32_t D_STALL4 = (1U << 21);  ///< D_STALL4
        constexpr uint32_t D_TXFNUM4 = (4 << 22);  ///< D_TXFNUM4
        constexpr uint32_t D_CNAK4 = (1U << 26);  ///< D_CNAK4
        constexpr uint32_t DI_SNAK4 = (1U << 27);  ///< DI_SNAK4
        constexpr uint32_t DI_SETD0PID4 = (1U << 28);  ///< DI_SETD0PID4
        constexpr uint32_t DI_SETD1PID4 = (1U << 29);  ///< DI_SETD1PID4
        constexpr uint32_t D_EPDIS4 = (1U << 30);  ///< D_EPDIS4
        constexpr uint32_t D_EPENA4 = (1U << 31);  ///< D_EPENA4
    }

    /// DIEPINT4 Register bits
    namespace diepint4_bits {
        constexpr uint32_t D_XFERCOMPL4 = (1U << 0);  ///< D_XFERCOMPL4
        constexpr uint32_t D_EPDISBLD4 = (1U << 1);  ///< D_EPDISBLD4
        constexpr uint32_t D_AHBERR4 = (1U << 2);  ///< D_AHBERR4
        constexpr uint32_t D_TIMEOUT4 = (1U << 3);  ///< D_TIMEOUT4
        constexpr uint32_t D_INTKNTXFEMP4 = (1U << 4);  ///< D_INTKNTXFEMP4
        constexpr uint32_t D_INTKNEPMIS4 = (1U << 5);  ///< D_INTKNEPMIS4
        constexpr uint32_t D_INEPNAKEFF4 = (1U << 6);  ///< D_INEPNAKEFF4
        constexpr uint32_t D_TXFEMP4 = (1U << 7);  ///< D_TXFEMP4
        constexpr uint32_t D_TXFIFOUNDRN4 = (1U << 8);  ///< D_TXFIFOUNDRN4
        constexpr uint32_t D_BNAINTR4 = (1U << 9);  ///< D_BNAINTR4
        constexpr uint32_t D_PKTDRPSTS4 = (1U << 11);  ///< D_PKTDRPSTS4
        constexpr uint32_t D_BBLEERR4 = (1U << 12);  ///< D_BBLEERR4
        constexpr uint32_t D_NAKINTRPT4 = (1U << 13);  ///< D_NAKINTRPT4
        constexpr uint32_t D_NYETINTRPT4 = (1U << 14);  ///< D_NYETINTRPT4
    }

    /// DIEPTSIZ4 Register bits
    namespace dieptsiz4_bits {
        constexpr uint32_t D_XFERSIZE4 = (7 << 0);  ///< D_XFERSIZE4
        constexpr uint32_t D_PKTCNT4 = (2 << 19);  ///< D_PKTCNT4
    }

    /// DIEPDMA4 Register bits
    namespace diepdma4_bits {
        constexpr uint32_t D_DMAADDR4 = (32 << 0);  ///< D_DMAADDR4
    }

    /// DTXFSTS4 Register bits
    namespace dtxfsts4_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL4 = (16 << 0);  ///< D_INEPTXFSPCAVAIL4
    }

    /// DIEPDMAB4 Register bits
    namespace diepdmab4_bits {
        constexpr uint32_t D_DMABUFFERADDR4 = (32 << 0);  ///< D_DMABUFFERADDR4
    }

    /// DIEPCTL5 Register bits
    namespace diepctl5_bits {
        constexpr uint32_t DI_MPS5 = (2 << 0);  ///< DI_MPS5
        constexpr uint32_t DI_USBACTEP5 = (1U << 15);  ///< DI_USBACTEP5
        constexpr uint32_t DI_NAKSTS5 = (1U << 17);  ///< DI_NAKSTS5
        constexpr uint32_t DI_EPTYPE5 = (2 << 18);  ///< DI_EPTYPE5
        constexpr uint32_t DI_STALL5 = (1U << 21);  ///< DI_STALL5
        constexpr uint32_t DI_TXFNUM5 = (4 << 22);  ///< DI_TXFNUM5
        constexpr uint32_t DI_CNAK5 = (1U << 26);  ///< DI_CNAK5
        constexpr uint32_t DI_SNAK5 = (1U << 27);  ///< DI_SNAK5
        constexpr uint32_t DI_SETD0PID5 = (1U << 28);  ///< DI_SETD0PID5
        constexpr uint32_t DI_SETD1PID5 = (1U << 29);  ///< DI_SETD1PID5
        constexpr uint32_t DI_EPDIS5 = (1U << 30);  ///< DI_EPDIS5
        constexpr uint32_t DI_EPENA5 = (1U << 31);  ///< DI_EPENA5
    }

    /// DIEPINT5 Register bits
    namespace diepint5_bits {
        constexpr uint32_t D_XFERCOMPL5 = (1U << 0);  ///< D_XFERCOMPL5
        constexpr uint32_t D_EPDISBLD5 = (1U << 1);  ///< D_EPDISBLD5
        constexpr uint32_t D_AHBERR5 = (1U << 2);  ///< D_AHBERR5
        constexpr uint32_t D_TIMEOUT5 = (1U << 3);  ///< D_TIMEOUT5
        constexpr uint32_t D_INTKNTXFEMP5 = (1U << 4);  ///< D_INTKNTXFEMP5
        constexpr uint32_t D_INTKNEPMIS5 = (1U << 5);  ///< D_INTKNEPMIS5
        constexpr uint32_t D_INEPNAKEFF5 = (1U << 6);  ///< D_INEPNAKEFF5
        constexpr uint32_t D_TXFEMP5 = (1U << 7);  ///< D_TXFEMP5
        constexpr uint32_t D_TXFIFOUNDRN5 = (1U << 8);  ///< D_TXFIFOUNDRN5
        constexpr uint32_t D_BNAINTR5 = (1U << 9);  ///< D_BNAINTR5
        constexpr uint32_t D_PKTDRPSTS5 = (1U << 11);  ///< D_PKTDRPSTS5
        constexpr uint32_t D_BBLEERR5 = (1U << 12);  ///< D_BBLEERR5
        constexpr uint32_t D_NAKINTRPT5 = (1U << 13);  ///< D_NAKINTRPT5
        constexpr uint32_t D_NYETINTRPT5 = (1U << 14);  ///< D_NYETINTRPT5
    }

    /// DIEPTSIZ5 Register bits
    namespace dieptsiz5_bits {
        constexpr uint32_t D_XFERSIZE5 = (7 << 0);  ///< D_XFERSIZE5
        constexpr uint32_t D_PKTCNT5 = (2 << 19);  ///< D_PKTCNT5
    }

    /// DIEPDMA5 Register bits
    namespace diepdma5_bits {
        constexpr uint32_t D_DMAADDR5 = (32 << 0);  ///< D_DMAADDR5
    }

    /// DTXFSTS5 Register bits
    namespace dtxfsts5_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL5 = (16 << 0);  ///< D_INEPTXFSPCAVAIL5
    }

    /// DIEPDMAB5 Register bits
    namespace diepdmab5_bits {
        constexpr uint32_t D_DMABUFFERADDR5 = (32 << 0);  ///< D_DMABUFFERADDR5
    }

    /// DIEPCTL6 Register bits
    namespace diepctl6_bits {
        constexpr uint32_t D_MPS6 = (2 << 0);  ///< D_MPS6
        constexpr uint32_t D_USBACTEP6 = (1U << 15);  ///< D_USBACTEP6
        constexpr uint32_t D_NAKSTS6 = (1U << 17);  ///< D_NAKSTS6
        constexpr uint32_t D_EPTYPE6 = (2 << 18);  ///< D_EPTYPE6
        constexpr uint32_t D_STALL6 = (1U << 21);  ///< D_STALL6
        constexpr uint32_t D_TXFNUM6 = (4 << 22);  ///< D_TXFNUM6
        constexpr uint32_t D_CNAK6 = (1U << 26);  ///< D_CNAK6
        constexpr uint32_t DI_SNAK6 = (1U << 27);  ///< DI_SNAK6
        constexpr uint32_t DI_SETD0PID6 = (1U << 28);  ///< DI_SETD0PID6
        constexpr uint32_t DI_SETD1PID6 = (1U << 29);  ///< DI_SETD1PID6
        constexpr uint32_t D_EPDIS6 = (1U << 30);  ///< D_EPDIS6
        constexpr uint32_t D_EPENA6 = (1U << 31);  ///< D_EPENA6
    }

    /// DIEPINT6 Register bits
    namespace diepint6_bits {
        constexpr uint32_t D_XFERCOMPL6 = (1U << 0);  ///< D_XFERCOMPL6
        constexpr uint32_t D_EPDISBLD6 = (1U << 1);  ///< D_EPDISBLD6
        constexpr uint32_t D_AHBERR6 = (1U << 2);  ///< D_AHBERR6
        constexpr uint32_t D_TIMEOUT6 = (1U << 3);  ///< D_TIMEOUT6
        constexpr uint32_t D_INTKNTXFEMP6 = (1U << 4);  ///< D_INTKNTXFEMP6
        constexpr uint32_t D_INTKNEPMIS6 = (1U << 5);  ///< D_INTKNEPMIS6
        constexpr uint32_t D_INEPNAKEFF6 = (1U << 6);  ///< D_INEPNAKEFF6
        constexpr uint32_t D_TXFEMP6 = (1U << 7);  ///< D_TXFEMP6
        constexpr uint32_t D_TXFIFOUNDRN6 = (1U << 8);  ///< D_TXFIFOUNDRN6
        constexpr uint32_t D_BNAINTR6 = (1U << 9);  ///< D_BNAINTR6
        constexpr uint32_t D_PKTDRPSTS6 = (1U << 11);  ///< D_PKTDRPSTS6
        constexpr uint32_t D_BBLEERR6 = (1U << 12);  ///< D_BBLEERR6
        constexpr uint32_t D_NAKINTRPT6 = (1U << 13);  ///< D_NAKINTRPT6
        constexpr uint32_t D_NYETINTRPT6 = (1U << 14);  ///< D_NYETINTRPT6
    }

    /// DIEPTSIZ6 Register bits
    namespace dieptsiz6_bits {
        constexpr uint32_t D_XFERSIZE6 = (7 << 0);  ///< D_XFERSIZE6
        constexpr uint32_t D_PKTCNT6 = (2 << 19);  ///< D_PKTCNT6
    }

    /// DIEPDMA6 Register bits
    namespace diepdma6_bits {
        constexpr uint32_t D_DMAADDR6 = (32 << 0);  ///< D_DMAADDR6
    }

    /// DTXFSTS6 Register bits
    namespace dtxfsts6_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL6 = (16 << 0);  ///< D_INEPTXFSPCAVAIL6
    }

    /// DIEPDMAB6 Register bits
    namespace diepdmab6_bits {
        constexpr uint32_t D_DMABUFFERADDR6 = (32 << 0);  ///< D_DMABUFFERADDR6
    }

    /// DOEPCTL0 Register bits
    namespace doepctl0_bits {
        constexpr uint32_t MPS0 = (2 << 0);  ///< MPS0
        constexpr uint32_t USBACTEP0 = (1U << 15);  ///< USBACTEP0
        constexpr uint32_t NAKSTS0 = (1U << 17);  ///< NAKSTS0
        constexpr uint32_t EPTYPE0 = (2 << 18);  ///< EPTYPE0
        constexpr uint32_t SNP0 = (1U << 20);  ///< SNP0
        constexpr uint32_t STALL0 = (1U << 21);  ///< STALL0
        constexpr uint32_t CNAK0 = (1U << 26);  ///< CNAK0
        constexpr uint32_t DO_SNAK0 = (1U << 27);  ///< DO_SNAK0
        constexpr uint32_t EPDIS0 = (1U << 30);  ///< EPDIS0
        constexpr uint32_t EPENA0 = (1U << 31);  ///< EPENA0
    }

    /// DOEPINT0 Register bits
    namespace doepint0_bits {
        constexpr uint32_t XFERCOMPL0 = (1U << 0);  ///< XFERCOMPL0
        constexpr uint32_t EPDISBLD0 = (1U << 1);  ///< EPDISBLD0
        constexpr uint32_t AHBERR0 = (1U << 2);  ///< AHBERR0
        constexpr uint32_t SETUP0 = (1U << 3);  ///< SETUP0
        constexpr uint32_t OUTTKNEPDIS0 = (1U << 4);  ///< OUTTKNEPDIS0
        constexpr uint32_t STSPHSERCVD0 = (1U << 5);  ///< STSPHSERCVD0
        constexpr uint32_t BACK2BACKSETUP0 = (1U << 6);  ///< BACK2BACKSETUP0
        constexpr uint32_t OUTPKTERR0 = (1U << 8);  ///< OUTPKTERR0
        constexpr uint32_t BNAINTR0 = (1U << 9);  ///< BNAINTR0
        constexpr uint32_t PKTDRPSTS0 = (1U << 11);  ///< PKTDRPSTS0
        constexpr uint32_t BBLEERR0 = (1U << 12);  ///< BBLEERR0
        constexpr uint32_t NAKINTRPT0 = (1U << 13);  ///< NAKINTRPT0
        constexpr uint32_t NYEPINTRPT0 = (1U << 14);  ///< NYEPINTRPT0
        constexpr uint32_t STUPPKTRCVD0 = (1U << 15);  ///< STUPPKTRCVD0
    }

    /// DOEPTSIZ0 Register bits
    namespace doeptsiz0_bits {
        constexpr uint32_t XFERSIZE0 = (7 << 0);  ///< XFERSIZE0
        constexpr uint32_t PKTCNT0 = (1U << 19);  ///< PKTCNT0
        constexpr uint32_t SUPCNT0 = (2 << 29);  ///< SUPCNT0
    }

    /// DOEPDMA0 Register bits
    namespace doepdma0_bits {
        constexpr uint32_t DMAADDR0 = (32 << 0);  ///< DMAADDR0
    }

    /// DOEPDMAB0 Register bits
    namespace doepdmab0_bits {
        constexpr uint32_t DMABUFFERADDR0 = (32 << 0);  ///< DMABUFFERADDR0
    }

    /// DOEPCTL1 Register bits
    namespace doepctl1_bits {
        constexpr uint32_t MPS1 = (11 << 0);  ///< MPS1
        constexpr uint32_t USBACTEP1 = (1U << 15);  ///< USBACTEP1
        constexpr uint32_t NAKSTS1 = (1U << 17);  ///< NAKSTS1
        constexpr uint32_t EPTYPE1 = (2 << 18);  ///< EPTYPE1
        constexpr uint32_t SNP1 = (1U << 20);  ///< SNP1
        constexpr uint32_t STALL1 = (1U << 21);  ///< STALL1
        constexpr uint32_t CNAK1 = (1U << 26);  ///< CNAK1
        constexpr uint32_t DO_SNAK1 = (1U << 27);  ///< DO_SNAK1
        constexpr uint32_t DO_SETD0PID1 = (1U << 28);  ///< DO_SETD0PID1
        constexpr uint32_t DO_SETD1PID1 = (1U << 29);  ///< DO_SETD1PID1
        constexpr uint32_t EPDIS1 = (1U << 30);  ///< EPDIS1
        constexpr uint32_t EPENA1 = (1U << 31);  ///< EPENA1
    }

    /// DOEPINT1 Register bits
    namespace doepint1_bits {
        constexpr uint32_t XFERCOMPL1 = (1U << 0);  ///< XFERCOMPL1
        constexpr uint32_t EPDISBLD1 = (1U << 1);  ///< EPDISBLD1
        constexpr uint32_t AHBERR1 = (1U << 2);  ///< AHBERR1
        constexpr uint32_t SETUP1 = (1U << 3);  ///< SETUP1
        constexpr uint32_t OUTTKNEPDIS1 = (1U << 4);  ///< OUTTKNEPDIS1
        constexpr uint32_t STSPHSERCVD1 = (1U << 5);  ///< STSPHSERCVD1
        constexpr uint32_t BACK2BACKSETUP1 = (1U << 6);  ///< BACK2BACKSETUP1
        constexpr uint32_t OUTPKTERR1 = (1U << 8);  ///< OUTPKTERR1
        constexpr uint32_t BNAINTR1 = (1U << 9);  ///< BNAINTR1
        constexpr uint32_t PKTDRPSTS1 = (1U << 11);  ///< PKTDRPSTS1
        constexpr uint32_t BBLEERR1 = (1U << 12);  ///< BBLEERR1
        constexpr uint32_t NAKINTRPT1 = (1U << 13);  ///< NAKINTRPT1
        constexpr uint32_t NYEPINTRPT1 = (1U << 14);  ///< NYEPINTRPT1
        constexpr uint32_t STUPPKTRCVD1 = (1U << 15);  ///< STUPPKTRCVD1
    }

    /// DOEPTSIZ1 Register bits
    namespace doeptsiz1_bits {
        constexpr uint32_t XFERSIZE1 = (7 << 0);  ///< XFERSIZE1
        constexpr uint32_t PKTCNT1 = (1U << 19);  ///< PKTCNT1
        constexpr uint32_t SUPCNT1 = (2 << 29);  ///< SUPCNT1
    }

    /// DOEPDMA1 Register bits
    namespace doepdma1_bits {
        constexpr uint32_t DMAADDR1 = (32 << 0);  ///< DMAADDR1
    }

    /// DOEPDMAB1 Register bits
    namespace doepdmab1_bits {
        constexpr uint32_t DMABUFFERADDR1 = (32 << 0);  ///< DMABUFFERADDR1
    }

    /// DOEPCTL2 Register bits
    namespace doepctl2_bits {
        constexpr uint32_t MPS2 = (11 << 0);  ///< MPS2
        constexpr uint32_t USBACTEP2 = (1U << 15);  ///< USBACTEP2
        constexpr uint32_t NAKSTS2 = (1U << 17);  ///< NAKSTS2
        constexpr uint32_t EPTYPE2 = (2 << 18);  ///< EPTYPE2
        constexpr uint32_t SNP2 = (1U << 20);  ///< SNP2
        constexpr uint32_t STALL2 = (1U << 21);  ///< STALL2
        constexpr uint32_t CNAK2 = (1U << 26);  ///< CNAK2
        constexpr uint32_t DO_SNAK2 = (1U << 27);  ///< DO_SNAK2
        constexpr uint32_t DO_SETD0PID2 = (1U << 28);  ///< DO_SETD0PID2
        constexpr uint32_t DO_SETD1PID2 = (1U << 29);  ///< DO_SETD1PID2
        constexpr uint32_t EPDIS2 = (1U << 30);  ///< EPDIS2
        constexpr uint32_t EPENA2 = (1U << 31);  ///< EPENA2
    }

    /// DOEPINT2 Register bits
    namespace doepint2_bits {
        constexpr uint32_t XFERCOMPL2 = (1U << 0);  ///< XFERCOMPL2
        constexpr uint32_t EPDISBLD2 = (1U << 1);  ///< EPDISBLD2
        constexpr uint32_t AHBERR2 = (1U << 2);  ///< AHBERR2
        constexpr uint32_t SETUP2 = (1U << 3);  ///< SETUP2
        constexpr uint32_t OUTTKNEPDIS2 = (1U << 4);  ///< OUTTKNEPDIS2
        constexpr uint32_t STSPHSERCVD2 = (1U << 5);  ///< STSPHSERCVD2
        constexpr uint32_t BACK2BACKSETUP2 = (1U << 6);  ///< BACK2BACKSETUP2
        constexpr uint32_t OUTPKTERR2 = (1U << 8);  ///< OUTPKTERR2
        constexpr uint32_t BNAINTR2 = (1U << 9);  ///< BNAINTR2
        constexpr uint32_t PKTDRPSTS2 = (1U << 11);  ///< PKTDRPSTS2
        constexpr uint32_t BBLEERR2 = (1U << 12);  ///< BBLEERR2
        constexpr uint32_t NAKINTRPT2 = (1U << 13);  ///< NAKINTRPT2
        constexpr uint32_t NYEPINTRPT2 = (1U << 14);  ///< NYEPINTRPT2
        constexpr uint32_t STUPPKTRCVD2 = (1U << 15);  ///< STUPPKTRCVD2
    }

    /// DOEPTSIZ2 Register bits
    namespace doeptsiz2_bits {
        constexpr uint32_t XFERSIZE2 = (7 << 0);  ///< XFERSIZE2
        constexpr uint32_t PKTCNT2 = (1U << 19);  ///< PKTCNT2
        constexpr uint32_t SUPCNT2 = (2 << 29);  ///< SUPCNT2
    }

    /// DOEPDMA2 Register bits
    namespace doepdma2_bits {
        constexpr uint32_t DMAADDR2 = (32 << 0);  ///< DMAADDR2
    }

    /// DOEPDMAB2 Register bits
    namespace doepdmab2_bits {
        constexpr uint32_t DMABUFFERADDR2 = (32 << 0);  ///< DMABUFFERADDR2
    }

    /// DOEPCTL3 Register bits
    namespace doepctl3_bits {
        constexpr uint32_t MPS3 = (11 << 0);  ///< MPS3
        constexpr uint32_t USBACTEP3 = (1U << 15);  ///< USBACTEP3
        constexpr uint32_t NAKSTS3 = (1U << 17);  ///< NAKSTS3
        constexpr uint32_t EPTYPE3 = (2 << 18);  ///< EPTYPE3
        constexpr uint32_t SNP3 = (1U << 20);  ///< SNP3
        constexpr uint32_t STALL3 = (1U << 21);  ///< STALL3
        constexpr uint32_t CNAK3 = (1U << 26);  ///< CNAK3
        constexpr uint32_t DO_SNAK3 = (1U << 27);  ///< DO_SNAK3
        constexpr uint32_t DO_SETD0PID3 = (1U << 28);  ///< DO_SETD0PID3
        constexpr uint32_t DO_SETD1PID3 = (1U << 29);  ///< DO_SETD1PID3
        constexpr uint32_t EPDIS3 = (1U << 30);  ///< EPDIS3
        constexpr uint32_t EPENA3 = (1U << 31);  ///< EPENA3
    }

    /// DOEPINT3 Register bits
    namespace doepint3_bits {
        constexpr uint32_t XFERCOMPL3 = (1U << 0);  ///< XFERCOMPL3
        constexpr uint32_t EPDISBLD3 = (1U << 1);  ///< EPDISBLD3
        constexpr uint32_t AHBERR3 = (1U << 2);  ///< AHBERR3
        constexpr uint32_t SETUP3 = (1U << 3);  ///< SETUP3
        constexpr uint32_t OUTTKNEPDIS3 = (1U << 4);  ///< OUTTKNEPDIS3
        constexpr uint32_t STSPHSERCVD3 = (1U << 5);  ///< STSPHSERCVD3
        constexpr uint32_t BACK2BACKSETUP3 = (1U << 6);  ///< BACK2BACKSETUP3
        constexpr uint32_t OUTPKTERR3 = (1U << 8);  ///< OUTPKTERR3
        constexpr uint32_t BNAINTR3 = (1U << 9);  ///< BNAINTR3
        constexpr uint32_t PKTDRPSTS3 = (1U << 11);  ///< PKTDRPSTS3
        constexpr uint32_t BBLEERR3 = (1U << 12);  ///< BBLEERR3
        constexpr uint32_t NAKINTRPT3 = (1U << 13);  ///< NAKINTRPT3
        constexpr uint32_t NYEPINTRPT3 = (1U << 14);  ///< NYEPINTRPT3
        constexpr uint32_t STUPPKTRCVD3 = (1U << 15);  ///< STUPPKTRCVD3
    }

    /// DOEPTSIZ3 Register bits
    namespace doeptsiz3_bits {
        constexpr uint32_t XFERSIZE3 = (7 << 0);  ///< XFERSIZE3
        constexpr uint32_t PKTCNT3 = (1U << 19);  ///< PKTCNT3
        constexpr uint32_t SUPCNT3 = (2 << 29);  ///< SUPCNT3
    }

    /// DOEPDMA3 Register bits
    namespace doepdma3_bits {
        constexpr uint32_t DMAADDR3 = (32 << 0);  ///< DMAADDR3
    }

    /// DOEPDMAB3 Register bits
    namespace doepdmab3_bits {
        constexpr uint32_t DMABUFFERADDR3 = (32 << 0);  ///< DMABUFFERADDR3
    }

    /// DOEPCTL4 Register bits
    namespace doepctl4_bits {
        constexpr uint32_t MPS4 = (11 << 0);  ///< MPS4
        constexpr uint32_t USBACTEP4 = (1U << 15);  ///< USBACTEP4
        constexpr uint32_t NAKSTS4 = (1U << 17);  ///< NAKSTS4
        constexpr uint32_t EPTYPE4 = (2 << 18);  ///< EPTYPE4
        constexpr uint32_t SNP4 = (1U << 20);  ///< SNP4
        constexpr uint32_t STALL4 = (1U << 21);  ///< STALL4
        constexpr uint32_t CNAK4 = (1U << 26);  ///< CNAK4
        constexpr uint32_t DO_SNAK4 = (1U << 27);  ///< DO_SNAK4
        constexpr uint32_t DO_SETD0PID4 = (1U << 28);  ///< DO_SETD0PID4
        constexpr uint32_t DO_SETD1PID4 = (1U << 29);  ///< DO_SETD1PID4
        constexpr uint32_t EPDIS4 = (1U << 30);  ///< EPDIS4
        constexpr uint32_t EPENA4 = (1U << 31);  ///< EPENA4
    }

    /// DOEPINT4 Register bits
    namespace doepint4_bits {
        constexpr uint32_t XFERCOMPL4 = (1U << 0);  ///< XFERCOMPL4
        constexpr uint32_t EPDISBLD4 = (1U << 1);  ///< EPDISBLD4
        constexpr uint32_t AHBERR4 = (1U << 2);  ///< AHBERR4
        constexpr uint32_t SETUP4 = (1U << 3);  ///< SETUP4
        constexpr uint32_t OUTTKNEPDIS4 = (1U << 4);  ///< OUTTKNEPDIS4
        constexpr uint32_t STSPHSERCVD4 = (1U << 5);  ///< STSPHSERCVD4
        constexpr uint32_t BACK2BACKSETUP4 = (1U << 6);  ///< BACK2BACKSETUP4
        constexpr uint32_t OUTPKTERR4 = (1U << 8);  ///< OUTPKTERR4
        constexpr uint32_t BNAINTR4 = (1U << 9);  ///< BNAINTR4
        constexpr uint32_t PKTDRPSTS4 = (1U << 11);  ///< PKTDRPSTS4
        constexpr uint32_t BBLEERR4 = (1U << 12);  ///< BBLEERR4
        constexpr uint32_t NAKINTRPT4 = (1U << 13);  ///< NAKINTRPT4
        constexpr uint32_t NYEPINTRPT4 = (1U << 14);  ///< NYEPINTRPT4
        constexpr uint32_t STUPPKTRCVD4 = (1U << 15);  ///< STUPPKTRCVD4
    }

    /// DOEPTSIZ4 Register bits
    namespace doeptsiz4_bits {
        constexpr uint32_t XFERSIZE4 = (7 << 0);  ///< XFERSIZE4
        constexpr uint32_t PKTCNT4 = (1U << 19);  ///< PKTCNT4
        constexpr uint32_t SUPCNT4 = (2 << 29);  ///< SUPCNT4
    }

    /// DOEPDMA4 Register bits
    namespace doepdma4_bits {
        constexpr uint32_t DMAADDR4 = (32 << 0);  ///< DMAADDR4
    }

    /// DOEPDMAB4 Register bits
    namespace doepdmab4_bits {
        constexpr uint32_t DMABUFFERADDR4 = (32 << 0);  ///< DMABUFFERADDR4
    }

    /// DOEPCTL5 Register bits
    namespace doepctl5_bits {
        constexpr uint32_t MPS5 = (11 << 0);  ///< MPS5
        constexpr uint32_t USBACTEP5 = (1U << 15);  ///< USBACTEP5
        constexpr uint32_t NAKSTS5 = (1U << 17);  ///< NAKSTS5
        constexpr uint32_t EPTYPE5 = (2 << 18);  ///< EPTYPE5
        constexpr uint32_t SNP5 = (1U << 20);  ///< SNP5
        constexpr uint32_t STALL5 = (1U << 21);  ///< STALL5
        constexpr uint32_t CNAK5 = (1U << 26);  ///< CNAK5
        constexpr uint32_t DO_SNAK5 = (1U << 27);  ///< DO_SNAK5
        constexpr uint32_t DO_SETD0PID5 = (1U << 28);  ///< DO_SETD0PID5
        constexpr uint32_t DO_SETD1PID5 = (1U << 29);  ///< DO_SETD1PID5
        constexpr uint32_t EPDIS5 = (1U << 30);  ///< EPDIS5
        constexpr uint32_t EPENA5 = (1U << 31);  ///< EPENA5
    }

    /// DOEPINT5 Register bits
    namespace doepint5_bits {
        constexpr uint32_t XFERCOMPL5 = (1U << 0);  ///< XFERCOMPL5
        constexpr uint32_t EPDISBLD5 = (1U << 1);  ///< EPDISBLD5
        constexpr uint32_t AHBERR5 = (1U << 2);  ///< AHBERR5
        constexpr uint32_t SETUP5 = (1U << 3);  ///< SETUP5
        constexpr uint32_t OUTTKNEPDIS5 = (1U << 4);  ///< OUTTKNEPDIS5
        constexpr uint32_t STSPHSERCVD5 = (1U << 5);  ///< STSPHSERCVD5
        constexpr uint32_t BACK2BACKSETUP5 = (1U << 6);  ///< BACK2BACKSETUP5
        constexpr uint32_t OUTPKTERR5 = (1U << 8);  ///< OUTPKTERR5
        constexpr uint32_t BNAINTR5 = (1U << 9);  ///< BNAINTR5
        constexpr uint32_t PKTDRPSTS5 = (1U << 11);  ///< PKTDRPSTS5
        constexpr uint32_t BBLEERR5 = (1U << 12);  ///< BBLEERR5
        constexpr uint32_t NAKINTRPT5 = (1U << 13);  ///< NAKINTRPT5
        constexpr uint32_t NYEPINTRPT5 = (1U << 14);  ///< NYEPINTRPT5
        constexpr uint32_t STUPPKTRCVD5 = (1U << 15);  ///< STUPPKTRCVD5
    }

    /// DOEPTSIZ5 Register bits
    namespace doeptsiz5_bits {
        constexpr uint32_t XFERSIZE5 = (7 << 0);  ///< XFERSIZE5
        constexpr uint32_t PKTCNT5 = (1U << 19);  ///< PKTCNT5
        constexpr uint32_t SUPCNT5 = (2 << 29);  ///< SUPCNT5
    }

    /// DOEPDMA5 Register bits
    namespace doepdma5_bits {
        constexpr uint32_t DMAADDR5 = (32 << 0);  ///< DMAADDR5
    }

    /// DOEPDMAB5 Register bits
    namespace doepdmab5_bits {
        constexpr uint32_t DMABUFFERADDR5 = (32 << 0);  ///< DMABUFFERADDR5
    }

    /// DOEPCTL6 Register bits
    namespace doepctl6_bits {
        constexpr uint32_t MPS6 = (11 << 0);  ///< MPS6
        constexpr uint32_t USBACTEP6 = (1U << 15);  ///< USBACTEP6
        constexpr uint32_t NAKSTS6 = (1U << 17);  ///< NAKSTS6
        constexpr uint32_t EPTYPE6 = (2 << 18);  ///< EPTYPE6
        constexpr uint32_t SNP6 = (1U << 20);  ///< SNP6
        constexpr uint32_t STALL6 = (1U << 21);  ///< STALL6
        constexpr uint32_t CNAK6 = (1U << 26);  ///< CNAK6
        constexpr uint32_t DO_SNAK6 = (1U << 27);  ///< DO_SNAK6
        constexpr uint32_t DO_SETD0PID6 = (1U << 28);  ///< DO_SETD0PID6
        constexpr uint32_t DO_SETD1PID6 = (1U << 29);  ///< DO_SETD1PID6
        constexpr uint32_t EPDIS6 = (1U << 30);  ///< EPDIS6
        constexpr uint32_t EPENA6 = (1U << 31);  ///< EPENA6
    }

    /// DOEPINT6 Register bits
    namespace doepint6_bits {
        constexpr uint32_t XFERCOMPL6 = (1U << 0);  ///< XFERCOMPL6
        constexpr uint32_t EPDISBLD6 = (1U << 1);  ///< EPDISBLD6
        constexpr uint32_t AHBERR6 = (1U << 2);  ///< AHBERR6
        constexpr uint32_t SETUP6 = (1U << 3);  ///< SETUP6
        constexpr uint32_t OUTTKNEPDIS6 = (1U << 4);  ///< OUTTKNEPDIS6
        constexpr uint32_t STSPHSERCVD6 = (1U << 5);  ///< STSPHSERCVD6
        constexpr uint32_t BACK2BACKSETUP6 = (1U << 6);  ///< BACK2BACKSETUP6
        constexpr uint32_t OUTPKTERR6 = (1U << 8);  ///< OUTPKTERR6
        constexpr uint32_t BNAINTR6 = (1U << 9);  ///< BNAINTR6
        constexpr uint32_t PKTDRPSTS6 = (1U << 11);  ///< PKTDRPSTS6
        constexpr uint32_t BBLEERR6 = (1U << 12);  ///< BBLEERR6
        constexpr uint32_t NAKINTRPT6 = (1U << 13);  ///< NAKINTRPT6
        constexpr uint32_t NYEPINTRPT6 = (1U << 14);  ///< NYEPINTRPT6
        constexpr uint32_t STUPPKTRCVD6 = (1U << 15);  ///< STUPPKTRCVD6
    }

    /// DOEPTSIZ6 Register bits
    namespace doeptsiz6_bits {
        constexpr uint32_t XFERSIZE6 = (7 << 0);  ///< XFERSIZE6
        constexpr uint32_t PKTCNT6 = (1U << 19);  ///< PKTCNT6
        constexpr uint32_t SUPCNT6 = (2 << 29);  ///< SUPCNT6
    }

    /// DOEPDMA6 Register bits
    namespace doepdma6_bits {
        constexpr uint32_t DMAADDR6 = (32 << 0);  ///< DMAADDR6
    }

    /// DOEPDMAB6 Register bits
    namespace doepdmab6_bits {
        constexpr uint32_t DMABUFFERADDR6 = (32 << 0);  ///< DMABUFFERADDR6
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t STOPPCLK = (1U << 0);  ///< STOPPCLK
        constexpr uint32_t GATEHCLK = (1U << 1);  ///< GATEHCLK
        constexpr uint32_t PWRCLMP = (1U << 2);  ///< PWRCLMP
        constexpr uint32_t RSTPDWNMODULE = (1U << 3);  ///< RSTPDWNMODULE
        constexpr uint32_t PHYSLEEP = (1U << 6);  ///< PHYSLEEP
        constexpr uint32_t L1SUSPENDED = (1U << 7);  ///< L1SUSPENDED
        constexpr uint32_t RESETAFTERSUSP = (1U << 8);  ///< RESETAFTERSUSP
    }

}


} // namespace alloy::generated::esp32-s2

#endif // ALLOY_GENERATED_ESP32-S2_PERIPHERALS_HPP