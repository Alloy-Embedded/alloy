/// Auto-generated code for ESP32-S3
/// Generated by Alloy Code Generator
/// Source: espressif_esp32s3.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:35
#ifndef ALLOY_GENERATED_ESP32-S3_PERIPHERALS_HPP
#define ALLOY_GENERATED_ESP32-S3_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::esp32-s3 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 5;
    constexpr bool has_apb = true;
    constexpr uint32_t num_apb_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_bb = true;
    constexpr uint32_t num_bb_instances = 1;
    constexpr bool has_assist = true;
    constexpr uint32_t num_assist_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 1;
    constexpr bool has_ds = true;
    constexpr uint32_t num_ds_instances = 1;
    constexpr bool has_efuse = true;
    constexpr uint32_t num_efuse_instances = 1;
    constexpr bool has_extmem = true;
    constexpr uint32_t num_extmem_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 2;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 2;
    constexpr bool has_interrupt = true;
    constexpr uint32_t num_interrupt_instances = 2;
    constexpr bool has_io = true;
    constexpr uint32_t num_io_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_pwm = true;
    constexpr uint32_t num_pwm_instances = 3;
    constexpr bool has_pcnt = true;
    constexpr uint32_t num_pcnt_instances = 1;
    constexpr bool has_peri = true;
    constexpr uint32_t num_peri_instances = 1;
    constexpr bool has_rmt = true;
    constexpr uint32_t num_rmt_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sdhost = true;
    constexpr uint32_t num_sdhost_instances = 1;
    constexpr bool has_sens = true;
    constexpr uint32_t num_sens_instances = 1;
    constexpr bool has_sensitive = true;
    constexpr uint32_t num_sensitive_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_system = true;
    constexpr uint32_t num_system_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 3;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_uhci0 = true;
    constexpr uint32_t num_uhci0_instances = 1;
    constexpr bool has_uhci1 = true;
    constexpr uint32_t num_uhci1_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 3;
    constexpr bool has_wcl = true;
    constexpr uint32_t num_wcl_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct apb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct bb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct assist_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ds_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct efuse_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct extmem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct interrupt_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct io_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwm_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pcnt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct peri_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdhost_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sens_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sensitive_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct system_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct uhci0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct uhci1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct wcl_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 2;
    constexpr uint32_t max_gpio_pins = 32;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x6003A000;
    constexpr uint32_t HMAC_BASE = 0x6003E000;
    constexpr uint32_t RSA_BASE = 0x6003C000;
    constexpr uint32_t SHA_BASE = 0x6003B000;
    constexpr uint32_t XTS_AES_BASE = 0x600CC000;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t KEY_;  ///< Offset: 0x00 - AES key register %s (renamed from KEY_)
        volatile uint32_t TEXT_IN_;  ///< Offset: 0x20 - Source data register %s (renamed from TEXT_IN_)
        volatile uint32_t TEXT_OUT_;  ///< Offset: 0x30 - Result data register %s (renamed from TEXT_OUT_)
        volatile uint32_t MODE;  ///< Offset: 0x40 - AES Mode register
        volatile uint32_t TRIGGER;  ///< Offset: 0x48 - AES trigger register
        volatile uint32_t STATE;  ///< Offset: 0x4C - AES state register
        volatile uint32_t IV_MEM__;  ///< Offset: 0x50 - The memory that stores initialization vector (renamed from IV_MEM__)
        volatile uint32_t H_MEM__;  ///< Offset: 0x60 - The memory that stores GCM hash subkey (renamed from H_MEM__)
        volatile uint32_t J0_MEM__;  ///< Offset: 0x70 - The memory that stores J0 (renamed from J0_MEM__)
        volatile uint32_t T0_MEM__;  ///< Offset: 0x80 - The memory that stores T0 (renamed from T0_MEM__)
        volatile uint32_t DMA_ENABLE;  ///< Offset: 0x90 - AES accelerator working mode register
        volatile uint32_t BLOCK_MODE;  ///< Offset: 0x94 - AES cipher block mode register
        volatile uint32_t BLOCK_NUM;  ///< Offset: 0x98 - AES block number register
        volatile uint32_t INC_SEL;  ///< Offset: 0x9C - Standard incrementing function configure register
        volatile uint32_t AAD_BLOCK_NUM;  ///< Offset: 0xA0 - Additional Authential Data block number register
        volatile uint32_t REMAINDER_BIT_NUM;  ///< Offset: 0xA4 - AES remainder bit number register
        volatile uint32_t CONTINUE_;  ///< Offset: 0xA8 - AES continue register (renamed from CONTINUE_)
        volatile uint32_t INT_CLR;  ///< Offset: 0xAC - AES Interrupt clear register
        volatile uint32_t INT_ENA;  ///< Offset: 0xB0 - DMA-AES Interrupt enable register
        volatile uint32_t DATE;  ///< Offset: 0xB4 - AES version control register
        volatile uint32_t DMA_EXIT;  ///< Offset: 0xB8 - AES-DMA exit config
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* HMAC = reinterpret_cast<Registers*>(HMAC_BASE);
    inline Registers* RSA = reinterpret_cast<Registers*>(RSA_BASE);
    inline Registers* SHA = reinterpret_cast<Registers*>(SHA_BASE);
    inline Registers* XTS_AES = reinterpret_cast<Registers*>(XTS_AES_BASE);

    // Bit definitions
    /// KEY_ Register bits
    namespace key__bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Stores AES keys.
    }

    /// TEXT_IN_ Register bits
    namespace text_in__bits {
        constexpr uint32_t TEXT_IN = (32 << 0);  ///< Stores the source data when the AES accelerator operates in the Typical AES working mode.
    }

    /// TEXT_OUT_ Register bits
    namespace text_out__bits {
        constexpr uint32_t TEXT_OUT = (32 << 0);  ///< Stores the result data when the AES accelerator operates in the Typical AES working mode.
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t MODE = (3 << 0);  ///< Defines the key length and the encryption/decryption of the AES accelerator.
    }

    /// TRIGGER Register bits
    namespace trigger_bits {
        constexpr uint32_t TRIGGER = (1U << 0);  ///< Set this bit to 1 to start AES calculation.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t STATE = (2 << 0);  ///< Stores the working status of the AES accelerator. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
    }

    /// DMA_ENABLE Register bits
    namespace dma_enable_bits {
        constexpr uint32_t DMA_ENABLE = (1U << 0);  ///< Defines the working mode of the AES accelerator. 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
    }

    /// BLOCK_MODE Register bits
    namespace block_mode_bits {
        constexpr uint32_t BLOCK_MODE = (3 << 0);  ///< Defines the block cipher mode of the AES accelerator operating under the DMA-AES working mode. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: reserved, 0x7: reserved.
    }

    /// BLOCK_NUM Register bits
    namespace block_num_bits {
        constexpr uint32_t BLOCK_NUM = (32 << 0);  ///< Stores the Block Number of plaintext or ciphertext when the AES accelerator operates under the DMA-AES working mode.
    }

    /// INC_SEL Register bits
    namespace inc_sel_bits {
        constexpr uint32_t INC_SEL = (1U << 0);  ///< Defines the Standard Incrementing Function for CTR block operation. Set this bit to 0 or 1 to choose INC32 or INC128.
    }

    /// AAD_BLOCK_NUM Register bits
    namespace aad_block_num_bits {
        constexpr uint32_t AAD_BLOCK_NUM = (32 << 0);  ///< Those bits stores the number of AAD block.
    }

    /// REMAINDER_BIT_NUM Register bits
    namespace remainder_bit_num_bits {
        constexpr uint32_t REMAINDER_BIT_NUM = (7 << 0);  ///< Those bits stores the number of remainder bit.
    }

    /// CONTINUE_ Register bits
    namespace continue__bits {
        constexpr uint32_t CONTINUE_ = (1U << 0);  ///< Set this bit to 1 to continue GCM operation. (renamed from CONTINUE_)
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t INT_CLEAR = (1U << 0);  ///< Set this bit to 1 to clear AES interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable AES interrupt and 0 to disable interrupt. This field is only effective for DMA-AES operation.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< This bits stores the version information of AES.
    }

    /// DMA_EXIT Register bits
    namespace dma_exit_bits {
        constexpr uint32_t DMA_EXIT = (1U << 0);  ///< Set this bit to 1 to exit AES operation. This field is only effective for DMA-AES operation.
    }

}

// ============================================================================
// APB Peripheral
// ============================================================================

namespace apb {
    /// Base addresses
    constexpr uint32_t APB_CTRL_BASE = 0x60026000;

    /// APB Register structure
    struct Registers {
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x00 - ******* Description ***********
        volatile uint32_t TICK_CONF;  ///< Offset: 0x04 - ******* Description ***********
        volatile uint32_t CLK_OUT_EN;  ///< Offset: 0x08 - ******* Description ***********
        volatile uint32_t WIFI_BB_CFG;  ///< Offset: 0x0C - ******* Description ***********
        volatile uint32_t WIFI_BB_CFG_2;  ///< Offset: 0x10 - ******* Description ***********
        volatile uint32_t WIFI_CLK_EN;  ///< Offset: 0x14 - ******* Description ***********
        volatile uint32_t WIFI_RST_EN;  ///< Offset: 0x18 - ******* Description ***********
        volatile uint32_t HOST_INF_SEL;  ///< Offset: 0x1C - ******* Description ***********
        volatile uint32_t EXT_MEM_PMS_LOCK;  ///< Offset: 0x20 - ******* Description ***********
        volatile uint32_t EXT_MEM_WRITEBACK_BYPASS;  ///< Offset: 0x24 - ******* Description ***********
        volatile uint32_t FLASH_ACE0_ATTR;  ///< Offset: 0x28 - ******* Description ***********
        volatile uint32_t FLASH_ACE1_ATTR;  ///< Offset: 0x2C - ******* Description ***********
        volatile uint32_t FLASH_ACE2_ATTR;  ///< Offset: 0x30 - ******* Description ***********
        volatile uint32_t FLASH_ACE3_ATTR;  ///< Offset: 0x34 - ******* Description ***********
        volatile uint32_t FLASH_ACE0_ADDR;  ///< Offset: 0x38 - ******* Description ***********
        volatile uint32_t FLASH_ACE1_ADDR;  ///< Offset: 0x3C - ******* Description ***********
        volatile uint32_t FLASH_ACE2_ADDR;  ///< Offset: 0x40 - ******* Description ***********
        volatile uint32_t FLASH_ACE3_ADDR;  ///< Offset: 0x44 - ******* Description ***********
        volatile uint32_t FLASH_ACE0_SIZE;  ///< Offset: 0x48 - ******* Description ***********
        volatile uint32_t FLASH_ACE1_SIZE;  ///< Offset: 0x4C - ******* Description ***********
        volatile uint32_t FLASH_ACE2_SIZE;  ///< Offset: 0x50 - ******* Description ***********
        volatile uint32_t FLASH_ACE3_SIZE;  ///< Offset: 0x54 - ******* Description ***********
        volatile uint32_t SRAM_ACE0_ATTR;  ///< Offset: 0x58 - ******* Description ***********
        volatile uint32_t SRAM_ACE1_ATTR;  ///< Offset: 0x5C - ******* Description ***********
        volatile uint32_t SRAM_ACE2_ATTR;  ///< Offset: 0x60 - ******* Description ***********
        volatile uint32_t SRAM_ACE3_ATTR;  ///< Offset: 0x64 - ******* Description ***********
        volatile uint32_t SRAM_ACE0_ADDR;  ///< Offset: 0x68 - ******* Description ***********
        volatile uint32_t SRAM_ACE1_ADDR;  ///< Offset: 0x6C - ******* Description ***********
        volatile uint32_t SRAM_ACE2_ADDR;  ///< Offset: 0x70 - ******* Description ***********
        volatile uint32_t SRAM_ACE3_ADDR;  ///< Offset: 0x74 - ******* Description ***********
        volatile uint32_t SRAM_ACE0_SIZE;  ///< Offset: 0x78 - ******* Description ***********
        volatile uint32_t SRAM_ACE1_SIZE;  ///< Offset: 0x7C - ******* Description ***********
        volatile uint32_t SRAM_ACE2_SIZE;  ///< Offset: 0x80 - ******* Description ***********
        volatile uint32_t SRAM_ACE3_SIZE;  ///< Offset: 0x84 - ******* Description ***********
        volatile uint32_t SPI_MEM_PMS_CTRL;  ///< Offset: 0x88 - ******* Description ***********
        volatile uint32_t SPI_MEM_REJECT_ADDR;  ///< Offset: 0x8C - ******* Description ***********
        volatile uint32_t SDIO_CTRL;  ///< Offset: 0x90 - ******* Description ***********
        volatile uint32_t REDCY_SIG0;  ///< Offset: 0x94 - ******* Description ***********
        volatile uint32_t REDCY_SIG1;  ///< Offset: 0x98 - ******* Description ***********
        volatile uint32_t FRONT_END_MEM_PD;  ///< Offset: 0x9C - ******* Description ***********
        volatile uint32_t SPI_MEM_ECC_CTRL;  ///< Offset: 0xA0 - ******* Description ***********
        volatile uint32_t CLKGATE_FORCE_ON;  ///< Offset: 0xA8 - ******* Description ***********
        volatile uint32_t MEM_POWER_DOWN;  ///< Offset: 0xAC - ******* Description ***********
        volatile uint32_t MEM_POWER_UP;  ///< Offset: 0xB0 - ******* Description ***********
        volatile uint32_t RETENTION_CTRL;  ///< Offset: 0xB4 - ******* Description ***********
        volatile uint32_t RETENTION_CTRL1;  ///< Offset: 0xB8 - ******* Description ***********
        volatile uint32_t RETENTION_CTRL2;  ///< Offset: 0xBC - ******* Description ***********
        volatile uint32_t RETENTION_CTRL3;  ///< Offset: 0xC0 - ******* Description ***********
        volatile uint32_t RETENTION_CTRL4;  ///< Offset: 0xC4 - ******* Description ***********
        volatile uint32_t RETENTION_CTRL5;  ///< Offset: 0xC8 - ******* Description ***********
        volatile uint32_t DATE;  ///< Offset: 0x3FC - ******* Description ***********
    };

    /// Peripheral instances
    inline Registers* APB_CTRL = reinterpret_cast<Registers*>(APB_CTRL_BASE);

    // Bit definitions
    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< ******* Description ***********
        constexpr uint32_t CLK_320M_EN = (1U << 10);  ///< ******* Description ***********
        constexpr uint32_t CLK_EN = (1U << 11);  ///< ******* Description ***********
        constexpr uint32_t RST_TICK_CNT = (1U << 12);  ///< ******* Description ***********
    }

    /// TICK_CONF Register bits
    namespace tick_conf_bits {
        constexpr uint32_t XTAL_TICK_NUM = (8 << 0);  ///< ******* Description ***********
        constexpr uint32_t CK8M_TICK_NUM = (8 << 8);  ///< ******* Description ***********
        constexpr uint32_t TICK_ENABLE = (1U << 16);  ///< ******* Description ***********
    }

    /// CLK_OUT_EN Register bits
    namespace clk_out_en_bits {
        constexpr uint32_t CLK20_OEN = (1U << 0);  ///< ******* Description ***********
        constexpr uint32_t CLK22_OEN = (1U << 1);  ///< ******* Description ***********
        constexpr uint32_t CLK44_OEN = (1U << 2);  ///< ******* Description ***********
        constexpr uint32_t CLK_BB_OEN = (1U << 3);  ///< ******* Description ***********
        constexpr uint32_t CLK80_OEN = (1U << 4);  ///< ******* Description ***********
        constexpr uint32_t CLK160_OEN = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t CLK_320M_OEN = (1U << 6);  ///< ******* Description ***********
        constexpr uint32_t CLK_ADC_INF_OEN = (1U << 7);  ///< ******* Description ***********
        constexpr uint32_t CLK_DAC_CPU_OEN = (1U << 8);  ///< ******* Description ***********
        constexpr uint32_t CLK40X_BB_OEN = (1U << 9);  ///< ******* Description ***********
        constexpr uint32_t CLK_XTAL_OEN = (1U << 10);  ///< ******* Description ***********
    }

    /// WIFI_BB_CFG Register bits
    namespace wifi_bb_cfg_bits {
        constexpr uint32_t WIFI_BB_CFG = (32 << 0);  ///< ******* Description ***********
    }

    /// WIFI_BB_CFG_2 Register bits
    namespace wifi_bb_cfg_2_bits {
        constexpr uint32_t WIFI_BB_CFG_2 = (32 << 0);  ///< ******* Description ***********
    }

    /// WIFI_CLK_EN Register bits
    namespace wifi_clk_en_bits {
        constexpr uint32_t WIFI_CLK_EN = (32 << 0);  ///< ******* Description ***********
    }

    /// WIFI_RST_EN Register bits
    namespace wifi_rst_en_bits {
        constexpr uint32_t WIFI_RST = (32 << 0);  ///< ******* Description ***********
    }

    /// HOST_INF_SEL Register bits
    namespace host_inf_sel_bits {
        constexpr uint32_t PERI_IO_SWAP = (8 << 0);  ///< ******* Description ***********
    }

    /// EXT_MEM_PMS_LOCK Register bits
    namespace ext_mem_pms_lock_bits {
        constexpr uint32_t EXT_MEM_PMS_LOCK = (1U << 0);  ///< ******* Description ***********
    }

    /// EXT_MEM_WRITEBACK_BYPASS Register bits
    namespace ext_mem_writeback_bypass_bits {
        constexpr uint32_t WRITEBACK_BYPASS = (1U << 0);  ///< Set 1 to bypass cache writeback request to external memory so that spi will not check its attribute.
    }

    /// FLASH_ACE0_ATTR Register bits
    namespace flash_ace0_attr_bits {
        constexpr uint32_t FLASH_ACE0_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE1_ATTR Register bits
    namespace flash_ace1_attr_bits {
        constexpr uint32_t FLASH_ACE1_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE2_ATTR Register bits
    namespace flash_ace2_attr_bits {
        constexpr uint32_t FLASH_ACE2_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE3_ATTR Register bits
    namespace flash_ace3_attr_bits {
        constexpr uint32_t FLASH_ACE3_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE0_ADDR Register bits
    namespace flash_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE1_ADDR Register bits
    namespace flash_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE2_ADDR Register bits
    namespace flash_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE3_ADDR Register bits
    namespace flash_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE0_SIZE Register bits
    namespace flash_ace0_size_bits {
        constexpr uint32_t FLASH_ACE0_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE1_SIZE Register bits
    namespace flash_ace1_size_bits {
        constexpr uint32_t FLASH_ACE1_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE2_SIZE Register bits
    namespace flash_ace2_size_bits {
        constexpr uint32_t FLASH_ACE2_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// FLASH_ACE3_SIZE Register bits
    namespace flash_ace3_size_bits {
        constexpr uint32_t FLASH_ACE3_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE0_ATTR Register bits
    namespace sram_ace0_attr_bits {
        constexpr uint32_t SRAM_ACE0_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE1_ATTR Register bits
    namespace sram_ace1_attr_bits {
        constexpr uint32_t SRAM_ACE1_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE2_ATTR Register bits
    namespace sram_ace2_attr_bits {
        constexpr uint32_t SRAM_ACE2_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE3_ATTR Register bits
    namespace sram_ace3_attr_bits {
        constexpr uint32_t SRAM_ACE3_ATTR = (9 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE0_ADDR Register bits
    namespace sram_ace0_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE1_ADDR Register bits
    namespace sram_ace1_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE2_ADDR Register bits
    namespace sram_ace2_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE3_ADDR Register bits
    namespace sram_ace3_addr_bits {
        constexpr uint32_t S = (32 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE0_SIZE Register bits
    namespace sram_ace0_size_bits {
        constexpr uint32_t SRAM_ACE0_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE1_SIZE Register bits
    namespace sram_ace1_size_bits {
        constexpr uint32_t SRAM_ACE1_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE2_SIZE Register bits
    namespace sram_ace2_size_bits {
        constexpr uint32_t SRAM_ACE2_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// SRAM_ACE3_SIZE Register bits
    namespace sram_ace3_size_bits {
        constexpr uint32_t SRAM_ACE3_SIZE = (16 << 0);  ///< ******* Description ***********
    }

    /// SPI_MEM_PMS_CTRL Register bits
    namespace spi_mem_pms_ctrl_bits {
        constexpr uint32_t SPI_MEM_REJECT_INT = (1U << 0);  ///< ******* Description ***********
        constexpr uint32_t SPI_MEM_REJECT_CLR = (1U << 1);  ///< ******* Description ***********
        constexpr uint32_t SPI_MEM_REJECT_CDE = (5 << 2);  ///< ******* Description ***********
    }

    /// SPI_MEM_REJECT_ADDR Register bits
    namespace spi_mem_reject_addr_bits {
        constexpr uint32_t SPI_MEM_REJECT_ADDR = (32 << 0);  ///< ******* Description ***********
    }

    /// SDIO_CTRL Register bits
    namespace sdio_ctrl_bits {
        constexpr uint32_t SDIO_WIN_ACCESS_EN = (1U << 0);  ///< ******* Description ***********
    }

    /// REDCY_SIG0 Register bits
    namespace redcy_sig0_bits {
        constexpr uint32_t REDCY_SIG0 = (31 << 0);  ///< ******* Description ***********
        constexpr uint32_t REDCY_ANDOR = (1U << 31);  ///< ******* Description ***********
    }

    /// REDCY_SIG1 Register bits
    namespace redcy_sig1_bits {
        constexpr uint32_t REDCY_SIG1 = (31 << 0);  ///< ******* Description ***********
        constexpr uint32_t REDCY_NANDOR = (1U << 31);  ///< ******* Description ***********
    }

    /// FRONT_END_MEM_PD Register bits
    namespace front_end_mem_pd_bits {
        constexpr uint32_t AGC_MEM_FORCE_PU = (1U << 0);  ///< ******* Description ***********
        constexpr uint32_t AGC_MEM_FORCE_PD = (1U << 1);  ///< ******* Description ***********
        constexpr uint32_t PBUS_MEM_FORCE_PU = (1U << 2);  ///< ******* Description ***********
        constexpr uint32_t PBUS_MEM_FORCE_PD = (1U << 3);  ///< ******* Description ***********
        constexpr uint32_t DC_MEM_FORCE_PU = (1U << 4);  ///< ******* Description ***********
        constexpr uint32_t DC_MEM_FORCE_PD = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t FREQ_MEM_FORCE_PU = (1U << 6);  ///< ******* Description ***********
        constexpr uint32_t FREQ_MEM_FORCE_PD = (1U << 7);  ///< ******* Description ***********
    }

    /// SPI_MEM_ECC_CTRL Register bits
    namespace spi_mem_ecc_ctrl_bits {
        constexpr uint32_t FLASH_PAGE_SIZE = (2 << 18);  ///< Set the page size of the used MSPI flash. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        constexpr uint32_t SRAM_PAGE_SIZE = (2 << 20);  ///< Set the page size of the used MSPI external RAM. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
    }

    /// CLKGATE_FORCE_ON Register bits
    namespace clkgate_force_on_bits {
        constexpr uint32_t ROM_CLKGATE_FORCE_ON = (3 << 0);  ///< ******* Description ***********
        constexpr uint32_t SRAM_CLKGATE_FORCE_ON = (11 << 3);  ///< ******* Description ***********
    }

    /// MEM_POWER_DOWN Register bits
    namespace mem_power_down_bits {
        constexpr uint32_t ROM_POWER_DOWN = (3 << 0);  ///< ******* Description ***********
        constexpr uint32_t SRAM_POWER_DOWN = (11 << 3);  ///< ******* Description ***********
    }

    /// MEM_POWER_UP Register bits
    namespace mem_power_up_bits {
        constexpr uint32_t ROM_POWER_UP = (3 << 0);  ///< ******* Description ***********
        constexpr uint32_t SRAM_POWER_UP = (11 << 3);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL Register bits
    namespace retention_ctrl_bits {
        constexpr uint32_t RETENTION_CPU_LINK_ADDR = (27 << 0);  ///< ******* Description ***********
        constexpr uint32_t NOBYPASS_CPU_ISO_RST = (1U << 27);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL1 Register bits
    namespace retention_ctrl1_bits {
        constexpr uint32_t RETENTION_TAG_LINK_ADDR = (27 << 0);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL2 Register bits
    namespace retention_ctrl2_bits {
        constexpr uint32_t RET_ICACHE_SIZE = (8 << 4);  ///< ******* Description ***********
        constexpr uint32_t RET_ICACHE_VLD_SIZE = (8 << 13);  ///< ******* Description ***********
        constexpr uint32_t RET_ICACHE_START_POINT = (8 << 22);  ///< ******* Description ***********
        constexpr uint32_t RET_ICACHE_ENABLE = (1U << 31);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL3 Register bits
    namespace retention_ctrl3_bits {
        constexpr uint32_t RET_DCACHE_SIZE = (9 << 4);  ///< ******* Description ***********
        constexpr uint32_t RET_DCACHE_VLD_SIZE = (9 << 13);  ///< ******* Description ***********
        constexpr uint32_t RET_DCACHE_START_POINT = (9 << 22);  ///< ******* Description ***********
        constexpr uint32_t RET_DCACHE_ENABLE = (1U << 31);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL4 Register bits
    namespace retention_ctrl4_bits {
        constexpr uint32_t RETENTION_INV_CFG = (32 << 0);  ///< ******* Description ***********
    }

    /// RETENTION_CTRL5 Register bits
    namespace retention_ctrl5_bits {
        constexpr uint32_t RETENTION_DISABLE = (1U << 0);  ///< ******* Description ***********
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< Version control
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t APB_SARADC_BASE = 0x60040000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - configure apb saradc controller
        volatile uint32_t CTRL2;  ///< Offset: 0x04 - configure apb saradc controller
        volatile uint32_t FILTER_CTRL1;  ///< Offset: 0x08 - configure saradc filter
        volatile uint32_t FSM_WAIT;  ///< Offset: 0x0C - configure apb saradc fsm
        volatile uint32_t SAR1_STATUS;  ///< Offset: 0x10 - saradc1 status for debug
        volatile uint32_t SAR2_STATUS;  ///< Offset: 0x14 - saradc2 status for debug
        volatile uint32_t SAR1_PATT_TAB1;  ///< Offset: 0x18 - configure apb saradc pattern table
        volatile uint32_t SAR1_PATT_TAB2;  ///< Offset: 0x1C - configure apb saradc pattern table
        volatile uint32_t SAR1_PATT_TAB3;  ///< Offset: 0x20 - configure apb saradc pattern table
        volatile uint32_t SAR1_PATT_TAB4;  ///< Offset: 0x24 - configure apb saradc pattern table
        volatile uint32_t SAR2_PATT_TAB1;  ///< Offset: 0x28 - configure apb saradc pattern table
        volatile uint32_t SAR2_PATT_TAB2;  ///< Offset: 0x2C - configure apb saradc pattern table
        volatile uint32_t SAR2_PATT_TAB3;  ///< Offset: 0x30 - configure apb saradc pattern table
        volatile uint32_t SAR2_PATT_TAB4;  ///< Offset: 0x34 - configure apb saradc pattern table
        volatile uint32_t ARB_CTRL;  ///< Offset: 0x38 - configure apb saradc arbit
        volatile uint32_t FILTER_CTRL0;  ///< Offset: 0x3C - configure apb saradc arbit
        volatile uint32_t APB_SARADC1_DATA_STATUS;  ///< Offset: 0x40 - get apb saradc sample data
        volatile uint32_t THRES0_CTRL;  ///< Offset: 0x44 - configure apb saradc thres monitor
        volatile uint32_t THRES1_CTRL;  ///< Offset: 0x48 - configure apb saradc thres monitor
        volatile uint32_t THRES_CTRL;  ///< Offset: 0x58 - configure thres monitor enable
        volatile uint32_t INT_ENA;  ///< Offset: 0x5C - enable interrupt
        volatile uint32_t INT_RAW;  ///< Offset: 0x60 - raw of interrupt
        volatile uint32_t INT_ST;  ///< Offset: 0x64 - state of interrupt
        volatile uint32_t INT_CLR;  ///< Offset: 0x68 - clear interrupt
        volatile uint32_t DMA_CONF;  ///< Offset: 0x6C - configure apb saradc dma
        volatile uint32_t CLKM_CONF;  ///< Offset: 0x70 - configure apb saradc clock
        volatile uint32_t APB_SARADC2_DATA_STATUS;  ///< Offset: 0x78 - get apb saradc2 sample data
        volatile uint32_t APB_CTRL_DATE;  ///< Offset: 0x3FC - version
    };

    /// Peripheral instances
    inline Registers* APB_SARADC = reinterpret_cast<Registers*>(APB_SARADC_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t SARADC_START_FORCE = (1U << 0);  ///< enable start saradc by sw
        constexpr uint32_t SARADC_START = (1U << 1);  ///< start saradc by sw
        constexpr uint32_t SARADC_WORK_MODE = (2 << 3);  ///< 0: single mode, 1: double mode, 2: alternate mode
        constexpr uint32_t SARADC_SAR_SEL = (1U << 5);  ///< 0: SAR1, 1: SAR2, only work for single SAR mode
        constexpr uint32_t SARADC_SAR_CLK_GATED = (1U << 6);  ///< enable SAR CLK gate when saradc idle
        constexpr uint32_t SARADC_SAR_CLK_DIV = (8 << 7);  ///< SAR clock divider
        constexpr uint32_t SARADC_SAR1_PATT_LEN = (4 << 15);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR2_PATT_LEN = (4 << 19);  ///< 0 ~ 15 means length 1 ~ 16
        constexpr uint32_t SARADC_SAR1_PATT_P_CLEAR = (1U << 23);  ///< clear the pointer of pattern table for DIG ADC1 CTRL
        constexpr uint32_t SARADC_SAR2_PATT_P_CLEAR = (1U << 24);  ///< clear the pointer of pattern table for DIG ADC2 CTRL
        constexpr uint32_t SARADC_DATA_SAR_SEL = (1U << 25);  ///< 1: sar_sel will be coded by the MSB of the 16-bit output data, in this case the resolution should not be larger than 11 bits.
        constexpr uint32_t SARADC_DATA_TO_I2S = (1U << 26);  ///< 1: I2S input data is from SAR ADC (for DMA), 0: I2S input data is from GPIO matrix
        constexpr uint32_t SARADC_XPD_SAR_FORCE = (2 << 27);  ///< force option to xpd sar blocks
        constexpr uint32_t SARADC_WAIT_ARB_CYCLE = (2 << 30);  ///< wait arbit signal stable after sar_done
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t SARADC_MEAS_NUM_LIMIT = (1U << 0);  ///< enable apb saradc limit the sample num
        constexpr uint32_t SARADC_MAX_MEAS_NUM = (8 << 1);  ///< max conversion number
        constexpr uint32_t SARADC_SAR1_INV = (1U << 9);  ///< 1: data to DIG ADC1 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_SAR2_INV = (1U << 10);  ///< 1: data to DIG ADC2 CTRL is inverted, otherwise not
        constexpr uint32_t SARADC_TIMER_SEL = (1U << 11);  ///< 1: select saradc timer 0: i2s_ws trigger
        constexpr uint32_t SARADC_TIMER_TARGET = (12 << 12);  ///< to set saradc timer target
        constexpr uint32_t SARADC_TIMER_EN = (1U << 24);  ///< to enable saradc timer trigger
    }

    /// FILTER_CTRL1 Register bits
    namespace filter_ctrl1_bits {
        constexpr uint32_t FILTER_FACTOR1 = (3 << 26);  ///< apb saradc factor1
        constexpr uint32_t FILTER_FACTOR0 = (3 << 29);  ///< apb saradc factor0
    }

    /// FSM_WAIT Register bits
    namespace fsm_wait_bits {
        constexpr uint32_t SARADC_XPD_WAIT = (8 << 0);  ///< the cycle which saradc controller in xpd state
        constexpr uint32_t SARADC_RSTB_WAIT = (8 << 8);  ///< the cycle which saradc controller in rst state
        constexpr uint32_t SARADC_STANDBY_WAIT = (8 << 16);  ///< the cycle which saradc controller in standby state
    }

    /// SAR1_STATUS Register bits
    namespace sar1_status_bits {
        constexpr uint32_t SARADC_SAR1_STATUS = (32 << 0);  ///< saradc1 status
    }

    /// SAR2_STATUS Register bits
    namespace sar2_status_bits {
        constexpr uint32_t SARADC_SAR2_STATUS = (32 << 0);  ///< saradc2 status
    }

    /// SAR1_PATT_TAB1 Register bits
    namespace sar1_patt_tab1_bits {
        constexpr uint32_t SARADC_SAR1_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 1 (each item 6bit)
    }

    /// SAR1_PATT_TAB2 Register bits
    namespace sar1_patt_tab2_bits {
        constexpr uint32_t SARADC_SAR1_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 1 (each item 6bit)
    }

    /// SAR1_PATT_TAB3 Register bits
    namespace sar1_patt_tab3_bits {
        constexpr uint32_t SARADC_SAR1_PATT_TAB3 = (24 << 0);  ///< Item 8 ~ 11 for pattern table 1 (each item 6bit)
    }

    /// SAR1_PATT_TAB4 Register bits
    namespace sar1_patt_tab4_bits {
        constexpr uint32_t SARADC_SAR1_PATT_TAB4 = (24 << 0);  ///< Item 12 ~ 15 for pattern table 1 (each item 6bit)
    }

    /// SAR2_PATT_TAB1 Register bits
    namespace sar2_patt_tab1_bits {
        constexpr uint32_t SARADC_SAR2_PATT_TAB1 = (24 << 0);  ///< item 0 ~ 3 for pattern table 2 (each item 6bit)
    }

    /// SAR2_PATT_TAB2 Register bits
    namespace sar2_patt_tab2_bits {
        constexpr uint32_t SARADC_SAR2_PATT_TAB2 = (24 << 0);  ///< Item 4 ~ 7 for pattern table 2 (each item 6bit)
    }

    /// SAR2_PATT_TAB3 Register bits
    namespace sar2_patt_tab3_bits {
        constexpr uint32_t SARADC_SAR2_PATT_TAB3 = (24 << 0);  ///< Item 8 ~ 11 for pattern table 2 (each item 6bit)
    }

    /// SAR2_PATT_TAB4 Register bits
    namespace sar2_patt_tab4_bits {
        constexpr uint32_t SARADC_SAR2_PATT_TAB4 = (24 << 0);  ///< Item 12 ~ 15 for pattern table 2 (each item 6bit)
    }

    /// ARB_CTRL Register bits
    namespace arb_ctrl_bits {
        constexpr uint32_t ADC_ARB_APB_FORCE = (1U << 2);  ///< adc2 arbiter force to enableapb controller
        constexpr uint32_t ADC_ARB_RTC_FORCE = (1U << 3);  ///< adc2 arbiter force to enable rtc controller
        constexpr uint32_t ADC_ARB_WIFI_FORCE = (1U << 4);  ///< adc2 arbiter force to enable wifi controller
        constexpr uint32_t ADC_ARB_GRANT_FORCE = (1U << 5);  ///< adc2 arbiter force grant
        constexpr uint32_t ADC_ARB_APB_PRIORITY = (2 << 6);  ///< Set adc2 arbiterapb priority
        constexpr uint32_t ADC_ARB_RTC_PRIORITY = (2 << 8);  ///< Set adc2 arbiter rtc priority
        constexpr uint32_t ADC_ARB_WIFI_PRIORITY = (2 << 10);  ///< Set adc2 arbiter wifi priority
        constexpr uint32_t ADC_ARB_FIX_PRIORITY = (1U << 12);  ///< adc2 arbiter uses fixed priority
    }

    /// FILTER_CTRL0 Register bits
    namespace filter_ctrl0_bits {
        constexpr uint32_t FILTER_CHANNEL1 = (5 << 14);  ///< configure the filter1 channel
        constexpr uint32_t FILTER_CHANNEL0 = (5 << 19);  ///< configure the filter0 channel
        constexpr uint32_t FILTER_RESET = (1U << 31);  ///< enable apb_adc1_filter
    }

    /// APB_SARADC1_DATA_STATUS Register bits
    namespace apb_saradc1_data_status_bits {
        constexpr uint32_t APB_SARADC1_DATA = (17 << 0);  ///< apbsaradc sample data
    }

    /// THRES0_CTRL Register bits
    namespace thres0_ctrl_bits {
        constexpr uint32_t THRES0_CHANNEL = (5 << 0);  ///< configure which channel thres0 monitor
        constexpr uint32_t THRES0_HIGH = (13 << 5);  ///< thres0 monitor high thres
        constexpr uint32_t THRES0_LOW = (13 << 18);  ///< thres0 monitor low thres
    }

    /// THRES1_CTRL Register bits
    namespace thres1_ctrl_bits {
        constexpr uint32_t THRES1_CHANNEL = (5 << 0);  ///< configure which channel thres0 monitor
        constexpr uint32_t THRES1_HIGH = (13 << 5);  ///< thres1 monitor high thres
        constexpr uint32_t THRES1_LOW = (13 << 18);  ///< thres1 monitor low thres
    }

    /// THRES_CTRL Register bits
    namespace thres_ctrl_bits {
        constexpr uint32_t THRES_ALL_EN = (1U << 27);  ///< enable thres0 to monitor all channel
        constexpr uint32_t THRES3_EN = (1U << 28);  ///< no public
        constexpr uint32_t THRES2_EN = (1U << 29);  ///< no public
        constexpr uint32_t THRES1_EN = (1U << 30);  ///< enable thres1
        constexpr uint32_t THRES0_EN = (1U << 31);  ///< enable thres0
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t THRES1_LOW_INT_ENA = (1U << 26);  ///< interrupt of thres1 low
        constexpr uint32_t THRES0_LOW_INT_ENA = (1U << 27);  ///< interrupt of thres0 low
        constexpr uint32_t THRES1_HIGH_INT_ENA = (1U << 28);  ///< interrupt of thres1 high
        constexpr uint32_t THRES0_HIGH_INT_ENA = (1U << 29);  ///< interrupt of thres0 high
        constexpr uint32_t APB_SARADC2_DONE_INT_ENA = (1U << 30);  ///< interrupt of sar2 done
        constexpr uint32_t APB_SARADC1_DONE_INT_ENA = (1U << 31);  ///< interrupt of sar1 done
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t THRES1_LOW_INT_RAW = (1U << 26);  ///< interrupt of thres1 low
        constexpr uint32_t THRES0_LOW_INT_RAW = (1U << 27);  ///< interrupt of thres0 low
        constexpr uint32_t THRES1_HIGH_INT_RAW = (1U << 28);  ///< interrupt of thres1 high
        constexpr uint32_t THRES0_HIGH_INT_RAW = (1U << 29);  ///< interrupt of thres0 high
        constexpr uint32_t APB_SARADC2_DONE_INT_RAW = (1U << 30);  ///< interrupt of sar2 done
        constexpr uint32_t APB_SARADC1_DONE_INT_RAW = (1U << 31);  ///< interrupt of sar1 done
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t THRES1_LOW_INT_ST = (1U << 26);  ///< interrupt of thres1 low
        constexpr uint32_t THRES0_LOW_INT_ST = (1U << 27);  ///< interrupt of thres0 low
        constexpr uint32_t THRES1_HIGH_INT_ST = (1U << 28);  ///< interrupt of thres1 high
        constexpr uint32_t THRES0_HIGH_INT_ST = (1U << 29);  ///< interrupt of thres0 high
        constexpr uint32_t APB_SARADC2_DONE_INT_ST = (1U << 30);  ///< interrupt of sar2 done
        constexpr uint32_t APB_SARADC1_DONE_INT_ST = (1U << 31);  ///< interrupt of sar1 done
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t THRES1_LOW_INT_CLR = (1U << 26);  ///< interrupt of thres1 low
        constexpr uint32_t THRES0_LOW_INT_CLR = (1U << 27);  ///< interrupt of thres0 low
        constexpr uint32_t THRES1_HIGH_INT_CLR = (1U << 28);  ///< interrupt of thres1 high
        constexpr uint32_t THRES0_HIGH_INT_CLR = (1U << 29);  ///< interrupt of thres0 high
        constexpr uint32_t APB_SARADC2_DONE_INT_CLR = (1U << 30);  ///< interrupt of sar2 done
        constexpr uint32_t APB_SARADC1_DONE_INT_CLR = (1U << 31);  ///< interrupt of sar1 done
    }

    /// DMA_CONF Register bits
    namespace dma_conf_bits {
        constexpr uint32_t APB_ADC_EOF_NUM = (16 << 0);  ///< the dma_in_suc_eof gen when sample cnt = spi_eof_num
        constexpr uint32_t APB_ADC_RESET_FSM = (1U << 30);  ///< reset_apb_adc_state
        constexpr uint32_t APB_ADC_TRANS = (1U << 31);  ///< enable apb_adc use spi_dma
    }

    /// CLKM_CONF Register bits
    namespace clkm_conf_bits {
        constexpr uint32_t CLKM_DIV_NUM = (8 << 0);  ///< Integral clock divider value
        constexpr uint32_t CLKM_DIV_B = (6 << 8);  ///< Fractional clock divider numerator value
        constexpr uint32_t CLKM_DIV_A = (6 << 14);  ///< Fractional clock divider denominator value
        constexpr uint32_t CLK_EN = (1U << 20);  ///< no public
        constexpr uint32_t CLK_SEL = (2 << 21);  ///< Set this bit to enable clk_apll
    }

    /// APB_SARADC2_DATA_STATUS Register bits
    namespace apb_saradc2_data_status_bits {
        constexpr uint32_t APB_SARADC2_DATA = (17 << 0);  ///< apb saradc2 sample data
    }

    /// APB_CTRL_DATE Register bits
    namespace apb_ctrl_date_bits {
        constexpr uint32_t APB_CTRL_DATE = (32 << 0);  ///< version
    }

}

// ============================================================================
// BB Peripheral
// ============================================================================

namespace bb {
    /// Base addresses
    constexpr uint32_t BB_BASE = 0x6001D000;

    /// BB Register structure
    struct Registers {
        volatile uint32_t BBPD_CTRL;  ///< Offset: 0x54 - Baseband control register
    };

    /// Peripheral instances
    inline Registers* BB = reinterpret_cast<Registers*>(BB_BASE);

    // Bit definitions
    /// BBPD_CTRL Register bits
    namespace bbpd_ctrl_bits {
        constexpr uint32_t DC_EST_FORCE_PD = (1U << 0);  ///< DC_EST_FORCE_PD
        constexpr uint32_t DC_EST_FORCE_PU = (1U << 1);  ///< DC_EST_FORCE_PU
        constexpr uint32_t FFT_FORCE_PD = (1U << 2);  ///< FFT_FORCE_PD
        constexpr uint32_t FFT_FORCE_PU = (1U << 3);  ///< FFT_FORCE_PU
    }

}

// ============================================================================
// ASSIST Peripheral
// ============================================================================

namespace assist {
    /// Base addresses
    constexpr uint32_t ASSIST_DEBUG_BASE = 0x600CE000;

    /// ASSIST Register structure
    struct Registers {
        volatile uint32_t CORE_0_MONTR_ENA;  ///< Offset: 0x00 - core0 monitor enable configuration register
        volatile uint32_t CORE_0_INTR_RAW;  ///< Offset: 0x04 - core0 monitor interrupt status register
        volatile uint32_t CORE_0_INTR_ENA;  ///< Offset: 0x08 - core0 monitor interrupt enable register
        volatile uint32_t CORE_0_INTR_CLR;  ///< Offset: 0x0C - core0 monitor interrupt clr register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MIN;  ///< Offset: 0x10 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_0_MAX;  ///< Offset: 0x14 - core0 dram0 region0 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MIN;  ///< Offset: 0x18 - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_DRAM0_1_MAX;  ///< Offset: 0x1C - core0 dram0 region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MIN;  ///< Offset: 0x20 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_0_MAX;  ///< Offset: 0x24 - core0 PIF region0 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MIN;  ///< Offset: 0x28 - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_PIF_1_MAX;  ///< Offset: 0x2C - core0 PIF region1 addr configuration register
        volatile uint32_t CORE_0_AREA_SP;  ///< Offset: 0x30 - core0 area sp status register
        volatile uint32_t CORE_0_AREA_PC;  ///< Offset: 0x34 - core0 area pc status register
        volatile uint32_t CORE_0_SP_UNSTABLE;  ///< Offset: 0x38 - core0 sp unstable configuration register
        volatile uint32_t CORE_0_SP_MIN;  ///< Offset: 0x3C - core0 sp region configuration regsiter
        volatile uint32_t CORE_0_SP_MAX;  ///< Offset: 0x40 - core0 sp region configuration regsiter
        volatile uint32_t CORE_0_SP_PC;  ///< Offset: 0x44 - core0 sp pc status register
        volatile uint32_t CORE_0_RCD_PDEBUGENABLE;  ///< Offset: 0x48 - core0 pdebug configuration register
        volatile uint32_t CORE_0_RCD_RECORDING;  ///< Offset: 0x4C - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGINST;  ///< Offset: 0x50 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGSTATUS;  ///< Offset: 0x54 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGDATA;  ///< Offset: 0x58 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGPC;  ///< Offset: 0x5C - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGLS0STAT;  ///< Offset: 0x60 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGLS0ADDR;  ///< Offset: 0x64 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_PDEBUGLS0DATA;  ///< Offset: 0x68 - core0 pdebug status register
        volatile uint32_t CORE_0_RCD_SP;  ///< Offset: 0x6C - core0 pdebug status register
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x70 - core0 bus busy status regsiter
        volatile uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x74 - core0 bus busy status regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x78 - core0 bus busy status regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x7C - core0 bus busy status regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0x80 - core0 bus busy status regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0x84 - core0 bus busy status regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_4;  ///< Offset: 0x88 - core0 bus busy configuration regsiter
        volatile uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_5;  ///< Offset: 0x8C - core0 bus busy configuration regsiter
        volatile uint32_t CORE_1_MONTR_ENA;  ///< Offset: 0x90 - Core1 monitor enable configuration register
        volatile uint32_t CORE_1_INTR_RAW;  ///< Offset: 0x94 - Core1 monitor interrupt status register
        volatile uint32_t CORE_1_INTR_ENA;  ///< Offset: 0x98 - Core1 monitor interrupt enable register
        volatile uint32_t CORE_1_INTR_CLR;  ///< Offset: 0x9C - Core1 monitor interrupt clr register
        volatile uint32_t CORE_1_AREA_DRAM0_0_MIN;  ///< Offset: 0xA0 - Core1 dram0 region0 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_0_MAX;  ///< Offset: 0xA4 - Core1 dram0 region0 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_1_MIN;  ///< Offset: 0xA8 - Core1 dram0 region1 addr configuration register
        volatile uint32_t CORE_1_AREA_DRAM0_1_MAX;  ///< Offset: 0xAC - Core1 dram0 region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_0_MIN;  ///< Offset: 0xB0 - Core1 PIF region0 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_0_MAX;  ///< Offset: 0xB4 - Core1 PIF region0 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_1_MIN;  ///< Offset: 0xB8 - Core1 PIF region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PIF_1_MAX;  ///< Offset: 0xBC - Core1 PIF region1 addr configuration register
        volatile uint32_t CORE_1_AREA_PC;  ///< Offset: 0xC0 - Core1 area sp status register
        volatile uint32_t CORE_1_AREA_SP;  ///< Offset: 0xC4 - Core1 area pc status register
        volatile uint32_t CORE_1_SP_UNSTABLE;  ///< Offset: 0xC8 - Core1 sp unstable configuration register
        volatile uint32_t CORE_1_SP_MIN;  ///< Offset: 0xCC - Core1 sp region configuration regsiter
        volatile uint32_t CORE_1_SP_MAX;  ///< Offset: 0xD0 - Core1 sp region configuration regsiter
        volatile uint32_t CORE_1_SP_PC;  ///< Offset: 0xD4 - Core1 sp pc status register
        volatile uint32_t CORE_1_RCD_PDEBUGENABLE;  ///< Offset: 0xD8 - Core1 pdebug configuration register
        volatile uint32_t CORE_1_RCD_RECORDING;  ///< Offset: 0xDC - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGINST;  ///< Offset: 0xE0 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGSTATUS;  ///< Offset: 0xE4 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGDATA;  ///< Offset: 0xE8 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGPC;  ///< Offset: 0xEC - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGLS0STAT;  ///< Offset: 0xF0 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGLS0ADDR;  ///< Offset: 0xF4 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_PDEBUGLS0DATA;  ///< Offset: 0xF8 - Core1 pdebug status register
        volatile uint32_t CORE_1_RCD_SP;  ///< Offset: 0xFC - Core1 pdebug status register
        volatile uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x100 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x104 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x108 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x10C - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_2;  ///< Offset: 0x110 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_3;  ///< Offset: 0x114 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_4;  ///< Offset: 0x118 - Core1 bus busy status regsiter
        volatile uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_5;  ///< Offset: 0x11C - Core1 bus busy status regsiter
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0;  ///< Offset: 0x120 - bus busy configuration register
        volatile uint32_t CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1;  ///< Offset: 0x124 - bus busy configuration register
        volatile uint32_t LOG_SETTING;  ///< Offset: 0x128 - log set register
        volatile uint32_t LOG_DATA_0;  ///< Offset: 0x12C - log check data register
        volatile uint32_t LOG_DATA_1;  ///< Offset: 0x130 - log check data register
        volatile uint32_t LOG_DATA_2;  ///< Offset: 0x134 - log check data register
        volatile uint32_t LOG_DATA_3;  ///< Offset: 0x138 - log check data register
        volatile uint32_t LOG_DATA_MASK;  ///< Offset: 0x13C - log check data mask register
        volatile uint32_t LOG_MIN;  ///< Offset: 0x140 - log check region configuration register
        volatile uint32_t LOG_MAX;  ///< Offset: 0x144 - log check region configuration register
        volatile uint32_t LOG_MEM_START;  ///< Offset: 0x148 - log mem region configuration register
        volatile uint32_t LOG_MEM_END;  ///< Offset: 0x14C - log mem region configuration register
        volatile uint32_t LOG_MEM_WRITING_ADDR;  ///< Offset: 0x150 - log mem addr status register
        volatile uint32_t LOG_MEM_FULL_FLAG;  ///< Offset: 0x154 - log mem status register
        volatile uint32_t DATE;  ///< Offset: 0x1FC - version register
    };

    /// Peripheral instances
    inline Registers* ASSIST_DEBUG = reinterpret_cast<Registers*>(ASSIST_DEBUG_BASE);

    // Bit definitions
    /// CORE_0_MONTR_ENA Register bits
    namespace core_0_montr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< Core0 dram0 area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< Core0 dram0 area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< Core0 dram0 area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< Core0 dram0 area1 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_ENA = (1U << 4);  ///< Core0 PIF area0 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_ENA = (1U << 5);  ///< Core0 PIF area0 write monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_ENA = (1U << 6);  ///< Core0 PIF area1 read monitor enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_ENA = (1U << 7);  ///< Core0 PIF area1 write monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_ENA = (1U << 8);  ///< Core0 stackpoint overflow monitor enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_ENA = (1U << 9);  ///< Core0 stackpoint underflow monitor enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< IBUS busy monitor enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< DBUS busy monitor enbale
    }

    /// CORE_0_INTR_RAW Register bits
    namespace core_0_intr_raw_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_RAW = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_RAW = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_RAW = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt status
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_RAW = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MIN_RAW = (1U << 8);  ///< Core0 stackpoint overflow monitor interrupt status
        constexpr uint32_t CORE_0_SP_SPILL_MAX_RAW = (1U << 9);  ///< Core0 stackpoint underflow monitor interrupt status
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< IBUS busy monitor interrupt status
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< DBUS busy monitor initerrupt status
    }

    /// CORE_0_INTR_ENA Register bits
    namespace core_0_intr_ena_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_INTR_ENA = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_INTR_ENA = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_INTR_ENA = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_INTR_ENA = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_INTR_ENA = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_INTR_ENA = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_INTR_ENA = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt enable
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_INTR_ENA = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MIN_INTR_ENA = (1U << 8);  ///< Core0 stackpoint overflow monitor interrupt enable
        constexpr uint32_t CORE_0_SP_SPILL_MAX_INTR_ENA = (1U << 9);  ///< Core0 stackpoint underflow monitor interrupt enable
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 10);  ///< IBUS busy monitor interrupt enable
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 11);  ///< DBUS busy monitor interrupt enbale
    }

    /// CORE_0_INTR_CLR Register bits
    namespace core_0_intr_clr_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< Core0 dram0 area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< Core0 dram0 area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< Core0 dram0 area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< Core0 dram0 area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_RD_CLR = (1U << 4);  ///< Core0 PIF area0 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_0_WR_CLR = (1U << 5);  ///< Core0 PIF area0 write monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_RD_CLR = (1U << 6);  ///< Core0 PIF area1 read monitor interrupt clr
        constexpr uint32_t CORE_0_AREA_PIF_1_WR_CLR = (1U << 7);  ///< Core0 PIF area1 write monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MIN_CLR = (1U << 8);  ///< Core0 stackpoint overflow monitor interrupt clr
        constexpr uint32_t CORE_0_SP_SPILL_MAX_CLR = (1U << 9);  ///< Core0 stackpoint underflow monitor interrupt clr
        constexpr uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< IBUS busy monitor interrupt clr
        constexpr uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< DBUS busy monitor interrupt clr
    }

    /// CORE_0_AREA_DRAM0_0_MIN Register bits
    namespace core_0_area_dram0_0_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MIN = (32 << 0);  ///< Core0 dram0 region0 start addr
    }

    /// CORE_0_AREA_DRAM0_0_MAX Register bits
    namespace core_0_area_dram0_0_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_0_MAX = (32 << 0);  ///< Core0 dram0 region0 end addr
    }

    /// CORE_0_AREA_DRAM0_1_MIN Register bits
    namespace core_0_area_dram0_1_min_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MIN = (32 << 0);  ///< Core0 dram0 region1 start addr
    }

    /// CORE_0_AREA_DRAM0_1_MAX Register bits
    namespace core_0_area_dram0_1_max_bits {
        constexpr uint32_t CORE_0_AREA_DRAM0_1_MAX = (32 << 0);  ///< Core0 dram0 region1 end addr
    }

    /// CORE_0_AREA_PIF_0_MIN Register bits
    namespace core_0_area_pif_0_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MIN = (32 << 0);  ///< Core0 PIF region0 start addr
    }

    /// CORE_0_AREA_PIF_0_MAX Register bits
    namespace core_0_area_pif_0_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_0_MAX = (32 << 0);  ///< Core0 PIF region0 end addr
    }

    /// CORE_0_AREA_PIF_1_MIN Register bits
    namespace core_0_area_pif_1_min_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MIN = (32 << 0);  ///< Core0 PIF region1 start addr
    }

    /// CORE_0_AREA_PIF_1_MAX Register bits
    namespace core_0_area_pif_1_max_bits {
        constexpr uint32_t CORE_0_AREA_PIF_1_MAX = (32 << 0);  ///< Core0 PIF region1 end addr
    }

    /// CORE_0_AREA_SP Register bits
    namespace core_0_area_sp_bits {
        constexpr uint32_t CORE_0_AREA_SP = (32 << 0);  ///< the stackpointer when first touch region monitor interrupt
    }

    /// CORE_0_AREA_PC Register bits
    namespace core_0_area_pc_bits {
        constexpr uint32_t CORE_0_AREA_PC = (32 << 0);  ///< the PC when first touch region monitor interrupt
    }

    /// CORE_0_SP_UNSTABLE Register bits
    namespace core_0_sp_unstable_bits {
        constexpr uint32_t CORE_0_SP_UNSTABLE = (8 << 0);  ///< unstable period when window change,during this period no check stackpointer
    }

    /// CORE_0_SP_MIN Register bits
    namespace core_0_sp_min_bits {
        constexpr uint32_t CORE_0_SP_MIN = (32 << 0);  ///< stack min value
    }

    /// CORE_0_SP_MAX Register bits
    namespace core_0_sp_max_bits {
        constexpr uint32_t CORE_0_SP_MAX = (32 << 0);  ///< stack max value
    }

    /// CORE_0_SP_PC Register bits
    namespace core_0_sp_pc_bits {
        constexpr uint32_t CORE_0_SP_PC = (32 << 0);  ///< the PC when first touch stack monitor interrupt
    }

    /// CORE_0_RCD_PDEBUGENABLE Register bits
    namespace core_0_rcd_pdebugenable_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGENABLE = (1U << 0);  ///< Core0 Pdebugenable,set 1 to open core0 Pdebug interface,then can get core0 PC
    }

    /// CORE_0_RCD_RECORDING Register bits
    namespace core_0_rcd_recording_bits {
        constexpr uint32_t CORE_0_RCD_RECORDING = (1U << 0);  ///< Pdebug record enable,set 1 to record core0 pdebug interface signal
    }

    /// CORE_0_RCD_PDEBUGINST Register bits
    namespace core_0_rcd_pdebuginst_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGINST = (32 << 0);  ///< core0 pdebuginst
    }

    /// CORE_0_RCD_PDEBUGSTATUS Register bits
    namespace core_0_rcd_pdebugstatus_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGSTATUS = (8 << 0);  ///< core0 pdebugstatus
    }

    /// CORE_0_RCD_PDEBUGDATA Register bits
    namespace core_0_rcd_pdebugdata_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGDATA = (32 << 0);  ///< core0_pdebugdata
    }

    /// CORE_0_RCD_PDEBUGPC Register bits
    namespace core_0_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGPC = (32 << 0);  ///< core0_pdebugPC
    }

    /// CORE_0_RCD_PDEBUGLS0STAT Register bits
    namespace core_0_rcd_pdebugls0stat_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGLS0STAT = (32 << 0);  ///< core0_pdebug_s0stat
    }

    /// CORE_0_RCD_PDEBUGLS0ADDR Register bits
    namespace core_0_rcd_pdebugls0addr_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGLS0ADDR = (32 << 0);  ///< core0_pdebug_s0addr
    }

    /// CORE_0_RCD_PDEBUGLS0DATA Register bits
    namespace core_0_rcd_pdebugls0data_bits {
        constexpr uint32_t CORE_0_RCD_PDEBUGLS0DATA = (32 << 0);  ///< core0_pdebug_s0data
    }

    /// CORE_0_RCD_SP Register bits
    namespace core_0_rcd_sp_bits {
        constexpr uint32_t CORE_0_RCD_SP = (32 << 0);  ///< core0_stack pointer
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< The first iram0's addr[25:2] status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< The first iram0's wr status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< The first iram0's loadstore status when trigger IRAM busy interrupt
    }

    /// CORE_0_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< The second iram0's addr[25:2] status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_0_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< The second iram0's wr status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< The second iram0's loadstore status when trigger IRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_0 = (22 << 0);  ///< The first dram0's addr[25:4] status when trigger DRAM busy interrupt
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_0 = (1U << 22);  ///< The first dram0's wr status when trigger DRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_0 = (16 << 0);  ///< The first dram0's byteen status when trigger DRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_0_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< The first dram0's PC status when trigger DRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_0_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_ADDR_1 = (22 << 0);  ///< The second dram0's addr[25:4] status when trigger DRAM busy interrupt
        constexpr uint32_t CORE_0_DRAM0_RECORDING_WR_1 = (1U << 22);  ///< The second dram0's wr status when trigger DRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_4 Register bits
    namespace core_0_dram0_exception_monitor_4_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_1 = (16 << 0);  ///< The second dram0's byteen status when trigger DRAM busy interrupt
    }

    /// CORE_0_DRAM0_EXCEPTION_MONITOR_5 Register bits
    namespace core_0_dram0_exception_monitor_5_bits {
        constexpr uint32_t CORE_0_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< The second dram0's PC status when trigger DRAM busy interrupt
    }

    /// CORE_1_MONTR_ENA Register bits
    namespace core_1_montr_ena_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_ENA = (1U << 0);  ///< Core1 dram0 area0 read monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_ENA = (1U << 1);  ///< Core1 dram0 area0 write monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_ENA = (1U << 2);  ///< Core1 dram0 area1 read monitor enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_ENA = (1U << 3);  ///< Core1 dram0 area1 write monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_ENA = (1U << 4);  ///< Core1 PIF area0 read monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_ENA = (1U << 5);  ///< Core1 PIF area0 write monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_ENA = (1U << 6);  ///< Core1 PIF area1 read monitor enable
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_ENA = (1U << 7);  ///< Core1 PIF area1 write monitor enable
        constexpr uint32_t CORE_1_SP_SPILL_MIN_ENA = (1U << 8);  ///< Core1 stackpoint overflow monitor enable
        constexpr uint32_t CORE_1_SP_SPILL_MAX_ENA = (1U << 9);  ///< Core1 stackpoint underflow monitor enable
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_ENA = (1U << 10);  ///< IBUS busy monitor enable
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_ENA = (1U << 11);  ///< DBUS busy monitor enbale
    }

    /// CORE_1_INTR_RAW Register bits
    namespace core_1_intr_raw_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_RAW = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_RAW = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_RAW = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_RAW = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_RAW = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_RAW = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_RAW = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt status
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_RAW = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt status
        constexpr uint32_t CORE_1_SP_SPILL_MIN_RAW = (1U << 8);  ///< Core1 stackpoint overflow monitor interrupt status
        constexpr uint32_t CORE_1_SP_SPILL_MAX_RAW = (1U << 9);  ///< Core1 stackpoint underflow monitor interrupt status
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_RAW = (1U << 10);  ///< IBUS busy monitor interrupt status
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_RAW = (1U << 11);  ///< DBUS busy monitor initerrupt status
    }

    /// CORE_1_INTR_ENA Register bits
    namespace core_1_intr_ena_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_INTR_ENA = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_INTR_ENA = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_INTR_ENA = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_INTR_ENA = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_INTR_ENA = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_INTR_ENA = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_INTR_ENA = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt enable
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_INTR_ENA = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt enable
        constexpr uint32_t CORE_1_SP_SPILL_MIN_INTR_ENA = (1U << 8);  ///< Core1 stackpoint overflow monitor interrupt enable
        constexpr uint32_t CORE_1_SP_SPILL_MAX_INTR_ENA = (1U << 9);  ///< Core1 stackpoint underflow monitor interrupt enable
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 10);  ///< IBUS busy monitor interrupt enable
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_INTR_ENA = (1U << 11);  ///< DBUS busy monitor interrupt enbale
    }

    /// CORE_1_INTR_CLR Register bits
    namespace core_1_intr_clr_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_RD_CLR = (1U << 0);  ///< Core1 dram0 area0 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_0_WR_CLR = (1U << 1);  ///< Core1 dram0 area0 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_1_RD_CLR = (1U << 2);  ///< Core1 dram0 area1 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_DRAM0_1_WR_CLR = (1U << 3);  ///< Core1 dram0 area1 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_0_RD_CLR = (1U << 4);  ///< Core1 PIF area0 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_0_WR_CLR = (1U << 5);  ///< Core1 PIF area0 write monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_1_RD_CLR = (1U << 6);  ///< Core1 PIF area1 read monitor interrupt clr
        constexpr uint32_t CORE_1_AREA_PIF_1_WR_CLR = (1U << 7);  ///< Core1 PIF area1 write monitor interrupt clr
        constexpr uint32_t CORE_1_SP_SPILL_MIN_CLR = (1U << 8);  ///< Core1 stackpoint overflow monitor interrupt clr
        constexpr uint32_t CORE_1_SP_SPILL_MAX_CLR = (1U << 9);  ///< Core1 stackpoint underflow monitor interrupt clr
        constexpr uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_CLR = (1U << 10);  ///< IBUS busy monitor interrupt clr
        constexpr uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_CLR = (1U << 11);  ///< DBUS busy monitor interrupt clr
    }

    /// CORE_1_AREA_DRAM0_0_MIN Register bits
    namespace core_1_area_dram0_0_min_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_MIN = (32 << 0);  ///< Core1 dram0 region0 start addr
    }

    /// CORE_1_AREA_DRAM0_0_MAX Register bits
    namespace core_1_area_dram0_0_max_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_0_MAX = (32 << 0);  ///< Core1 dram0 region0 end addr
    }

    /// CORE_1_AREA_DRAM0_1_MIN Register bits
    namespace core_1_area_dram0_1_min_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_1_MIN = (32 << 0);  ///< Core1 dram0 region1 start addr
    }

    /// CORE_1_AREA_DRAM0_1_MAX Register bits
    namespace core_1_area_dram0_1_max_bits {
        constexpr uint32_t CORE_1_AREA_DRAM0_1_MAX = (32 << 0);  ///< Core1 dram0 region1 end addr
    }

    /// CORE_1_AREA_PIF_0_MIN Register bits
    namespace core_1_area_pif_0_min_bits {
        constexpr uint32_t CORE_1_AREA_PIF_0_MIN = (32 << 0);  ///< Core1 PIF region0 start addr
    }

    /// CORE_1_AREA_PIF_0_MAX Register bits
    namespace core_1_area_pif_0_max_bits {
        constexpr uint32_t CORE_1_AREA_PIF_0_MAX = (32 << 0);  ///< Core1 PIF region0 end addr
    }

    /// CORE_1_AREA_PIF_1_MIN Register bits
    namespace core_1_area_pif_1_min_bits {
        constexpr uint32_t CORE_1_AREA_PIF_1_MIN = (32 << 0);  ///< Core1 PIF region1 start addr
    }

    /// CORE_1_AREA_PIF_1_MAX Register bits
    namespace core_1_area_pif_1_max_bits {
        constexpr uint32_t CORE_1_AREA_PIF_1_MAX = (32 << 0);  ///< Core1 PIF region1 end addr
    }

    /// CORE_1_AREA_PC Register bits
    namespace core_1_area_pc_bits {
        constexpr uint32_t CORE_1_AREA_PC = (32 << 0);  ///< the stackpointer when first touch region monitor interrupt
    }

    /// CORE_1_AREA_SP Register bits
    namespace core_1_area_sp_bits {
        constexpr uint32_t CORE_1_AREA_SP = (32 << 0);  ///< the PC when first touch region monitor interrupt
    }

    /// CORE_1_SP_UNSTABLE Register bits
    namespace core_1_sp_unstable_bits {
        constexpr uint32_t CORE_1_SP_UNSTABLE = (8 << 0);  ///< unstable period when window change,during this period no check stackpointer
    }

    /// CORE_1_SP_MIN Register bits
    namespace core_1_sp_min_bits {
        constexpr uint32_t CORE_1_SP_MIN = (32 << 0);  ///< stack min value
    }

    /// CORE_1_SP_MAX Register bits
    namespace core_1_sp_max_bits {
        constexpr uint32_t CORE_1_SP_MAX = (32 << 0);  ///< stack max value
    }

    /// CORE_1_SP_PC Register bits
    namespace core_1_sp_pc_bits {
        constexpr uint32_t CORE_1_SP_PC = (32 << 0);  ///< the PC when first touch stack monitor interrupt
    }

    /// CORE_1_RCD_PDEBUGENABLE Register bits
    namespace core_1_rcd_pdebugenable_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGENABLE = (1U << 0);  ///< Core1 Pdebugenable,set 1 to open Core1 Pdebug interface, then can get Core1 PC
    }

    /// CORE_1_RCD_RECORDING Register bits
    namespace core_1_rcd_recording_bits {
        constexpr uint32_t CORE_1_RCD_RECORDING = (1U << 0);  ///< Pdebug record enable,set 1 to record Core1 pdebug interface signal
    }

    /// CORE_1_RCD_PDEBUGINST Register bits
    namespace core_1_rcd_pdebuginst_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGINST = (32 << 0);  ///< Core1 pdebuginst
    }

    /// CORE_1_RCD_PDEBUGSTATUS Register bits
    namespace core_1_rcd_pdebugstatus_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGSTATUS = (8 << 0);  ///< Core1 pdebugstatus
    }

    /// CORE_1_RCD_PDEBUGDATA Register bits
    namespace core_1_rcd_pdebugdata_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGDATA = (32 << 0);  ///< Core1_pdebugdata
    }

    /// CORE_1_RCD_PDEBUGPC Register bits
    namespace core_1_rcd_pdebugpc_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGPC = (32 << 0);  ///< Core1_pdebugPC
    }

    /// CORE_1_RCD_PDEBUGLS0STAT Register bits
    namespace core_1_rcd_pdebugls0stat_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGLS0STAT = (32 << 0);  ///< Core1_pdebug_s0stat
    }

    /// CORE_1_RCD_PDEBUGLS0ADDR Register bits
    namespace core_1_rcd_pdebugls0addr_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGLS0ADDR = (32 << 0);  ///< Core1_pdebug_s0addr
    }

    /// CORE_1_RCD_PDEBUGLS0DATA Register bits
    namespace core_1_rcd_pdebugls0data_bits {
        constexpr uint32_t CORE_1_RCD_PDEBUGLS0DATA = (32 << 0);  ///< Core1_pdebug_s0data
    }

    /// CORE_1_RCD_SP Register bits
    namespace core_1_rcd_sp_bits {
        constexpr uint32_t CORE_1_RCD_SP = (32 << 0);  ///< Core1_stack pointer
    }

    /// CORE_1_IRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_1_iram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_1_IRAM0_RECORDING_ADDR_0 = (24 << 0);  ///< The first iram0's addr[25:2] status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_1_IRAM0_RECORDING_WR_0 = (1U << 24);  ///< The first iram0's wr status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_0 = (1U << 25);  ///< The first iram0's loadstore status when trigger IRAM busy interrupt
    }

    /// CORE_1_IRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_1_iram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_1_IRAM0_RECORDING_ADDR_1 = (24 << 0);  ///< The second iram0's addr[25:2] status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_1_IRAM0_RECORDING_WR_1 = (1U << 24);  ///< The second iram0's wr status when trigger IRAM busy interrupt
        constexpr uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_1 = (1U << 25);  ///< The second iram0's loadstore status when trigger IRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_1_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_ADDR_0 = (22 << 0);  ///< The first dram0's addr[25:4] status when trigger DRAM busy interrupt
        constexpr uint32_t CORE_1_DRAM0_RECORDING_WR_0 = (1U << 22);  ///< The first dram0's wr status when trigger DRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_1_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_0 = (16 << 0);  ///< The first dram0's byteen status when trigger DRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_2 Register bits
    namespace core_1_dram0_exception_monitor_2_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_PC_0 = (32 << 0);  ///< The first dram0's PC status when trigger DRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_3 Register bits
    namespace core_1_dram0_exception_monitor_3_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_ADDR_1 = (22 << 0);  ///< The second dram0's addr[25:4] status when trigger DRAM busy interrupt
        constexpr uint32_t CORE_1_DRAM0_RECORDING_WR_1 = (1U << 22);  ///< The second dram0's wr status when trigger DRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_4 Register bits
    namespace core_1_dram0_exception_monitor_4_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_1 = (16 << 0);  ///< The second dram0's byteen status when trigger DRAM busy interrupt
    }

    /// CORE_1_DRAM0_EXCEPTION_MONITOR_5 Register bits
    namespace core_1_dram0_exception_monitor_5_bits {
        constexpr uint32_t CORE_1_DRAM0_RECORDING_PC_1 = (32 << 0);  ///< The second dram0's PC status when trigger DRAM busy interrupt
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 Register bits
    namespace core_x_iram0_dram0_exception_monitor_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 = (20 << 0);  ///< busy monitor window cycle
    }

    /// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 Register bits
    namespace core_x_iram0_dram0_exception_monitor_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 = (20 << 0);  ///< non busy cycle,for example: when cycle=100 and cycle=10,it means that in 100 cycle, if busy access success time less than 10, it will trigger interrutpt
    }

    /// LOG_SETTING Register bits
    namespace log_setting_bits {
        constexpr uint32_t LOG_ENA = (3 << 0);  ///< bus moniter enable: [0]Core1,[1]core1,[2]dma
        constexpr uint32_t LOG_MODE = (3 << 3);  ///< check_mode:0:write,1:word,2:halword,3:byte,4:doubleword,5:4word
        constexpr uint32_t LOG_MEM_LOOP_ENABLE = (1U << 6);  ///< mem_loop enable,1 means that loop write
    }

    /// LOG_DATA_0 Register bits
    namespace log_data_0_bits {
        constexpr uint32_t LOG_DATA_0 = (32 << 0);  ///< check data0
    }

    /// LOG_DATA_1 Register bits
    namespace log_data_1_bits {
        constexpr uint32_t LOG_DATA_1 = (32 << 0);  ///< check data1
    }

    /// LOG_DATA_2 Register bits
    namespace log_data_2_bits {
        constexpr uint32_t LOG_DATA_2 = (32 << 0);  ///< check data2
    }

    /// LOG_DATA_3 Register bits
    namespace log_data_3_bits {
        constexpr uint32_t LOG_DATA_3 = (32 << 0);  ///< check data3
    }

    /// LOG_DATA_MASK Register bits
    namespace log_data_mask_bits {
        constexpr uint32_t LOG_DATA_SIZE = (16 << 0);  ///< data mask
    }

    /// LOG_MIN Register bits
    namespace log_min_bits {
        constexpr uint32_t LOG_MIN = (32 << 0);  ///< check region min addr
    }

    /// LOG_MAX Register bits
    namespace log_max_bits {
        constexpr uint32_t LOG_MAX = (32 << 0);  ///< check region max addr
    }

    /// LOG_MEM_START Register bits
    namespace log_mem_start_bits {
        constexpr uint32_t LOG_MEM_START = (32 << 0);  ///< mem start addr
    }

    /// LOG_MEM_END Register bits
    namespace log_mem_end_bits {
        constexpr uint32_t LOG_MEM_END = (32 << 0);  ///< mem end addr
    }

    /// LOG_MEM_WRITING_ADDR Register bits
    namespace log_mem_writing_addr_bits {
        constexpr uint32_t LOG_MEM_WRITING_ADDR = (32 << 0);  ///< mem current addr, it means next writing addr
    }

    /// LOG_MEM_FULL_FLAG Register bits
    namespace log_mem_full_flag_bits {
        constexpr uint32_t LOG_MEM_FULL_FLAG = (1U << 0);  ///< when it's 1,show that mem write loop morte than one time.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x6003F000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t IN_CONF0_CH;  ///< Offset: 0x00 - Configure 0 register of Rx channel 0 (renamed from IN_CONF0_CH)
        volatile uint32_t IN_CONF1_CH;  ///< Offset: 0x04 - Configure 1 register of Rx channel 0 (renamed from IN_CONF1_CH)
        volatile uint32_t IN_INT_RAW_CH;  ///< Offset: 0x08 - Raw status interrupt of Rx channel 0 (renamed from IN_INT_RAW_CH)
        volatile uint32_t IN_INT_ST_CH;  ///< Offset: 0x0C - Masked interrupt of Rx channel 0 (renamed from IN_INT_ST_CH)
        volatile uint32_t IN_INT_ENA_CH;  ///< Offset: 0x10 - Interrupt enable bits of Rx channel 0 (renamed from IN_INT_ENA_CH)
        volatile uint32_t IN_INT_CLR_CH;  ///< Offset: 0x14 - Interrupt clear bits of Rx channel 0 (renamed from IN_INT_CLR_CH)
        volatile uint32_t INFIFO_STATUS_CH;  ///< Offset: 0x18 - Receive FIFO status of Rx channel 0 (renamed from INFIFO_STATUS_CH)
        volatile uint32_t IN_POP_CH;  ///< Offset: 0x1C - Pop control register of Rx channel 0 (renamed from IN_POP_CH)
        volatile uint32_t IN_LINK_CH;  ///< Offset: 0x20 - Link descriptor configure and control register of Rx channel 0 (renamed from IN_LINK_CH)
        volatile uint32_t IN_STATE_CH;  ///< Offset: 0x24 - Receive status of Rx channel 0 (renamed from IN_STATE_CH)
        volatile uint32_t IN_SUC_EOF_DES_ADDR_CH;  ///< Offset: 0x28 - Inlink descriptor address when EOF occurs of Rx channel 0 (renamed from IN_SUC_EOF_DES_ADDR_CH)
        volatile uint32_t IN_ERR_EOF_DES_ADDR_CH;  ///< Offset: 0x2C - Inlink descriptor address when errors occur of Rx channel 0 (renamed from IN_ERR_EOF_DES_ADDR_CH)
        volatile uint32_t IN_DSCR_CH;  ///< Offset: 0x30 - Current inlink descriptor address of Rx channel 0 (renamed from IN_DSCR_CH)
        volatile uint32_t IN_DSCR_BF0_CH;  ///< Offset: 0x34 - The last inlink descriptor address of Rx channel 0 (renamed from IN_DSCR_BF0_CH)
        volatile uint32_t IN_DSCR_BF1_CH;  ///< Offset: 0x38 - The second-to-last inlink descriptor address of Rx channel 0 (renamed from IN_DSCR_BF1_CH)
        volatile uint32_t IN_WIGHT_CH;  ///< Offset: 0x3C - Weight register of Rx channel 0 (renamed from IN_WIGHT_CH)
        volatile uint32_t IN_PRI_CH;  ///< Offset: 0x44 - Priority register of Rx channel 0 (renamed from IN_PRI_CH)
        volatile uint32_t IN_PERI_SEL_CH;  ///< Offset: 0x48 - Peripheral selection of Rx channel 0 (renamed from IN_PERI_SEL_CH)
        volatile uint32_t OUT_CONF0_CH;  ///< Offset: 0x60 - Configure 0 register of Tx channel 0 (renamed from OUT_CONF0_CH)
        volatile uint32_t OUT_CONF1_CH;  ///< Offset: 0x64 - Configure 1 register of Tx channel 0 (renamed from OUT_CONF1_CH)
        volatile uint32_t OUT_INT_RAW_CH;  ///< Offset: 0x68 - Raw status interrupt of Tx channel 0 (renamed from OUT_INT_RAW_CH)
        volatile uint32_t OUT_INT_ST_CH;  ///< Offset: 0x6C - Masked interrupt of Tx channel 0 (renamed from OUT_INT_ST_CH)
        volatile uint32_t OUT_INT_ENA_CH;  ///< Offset: 0x70 - Interrupt enable bits of Tx channel 0 (renamed from OUT_INT_ENA_CH)
        volatile uint32_t OUT_INT_CLR_CH;  ///< Offset: 0x74 - Interrupt clear bits of Tx channel 0 (renamed from OUT_INT_CLR_CH)
        volatile uint32_t OUTFIFO_STATUS_CH;  ///< Offset: 0x78 - Transmit FIFO status of Tx channel 0 (renamed from OUTFIFO_STATUS_CH)
        volatile uint32_t OUT_PUSH_CH;  ///< Offset: 0x7C - Push control register of Rx channel 0 (renamed from OUT_PUSH_CH)
        volatile uint32_t OUT_LINK_CH;  ///< Offset: 0x80 - Link descriptor configure and control register of Tx channel 0 (renamed from OUT_LINK_CH)
        volatile uint32_t OUT_STATE_CH;  ///< Offset: 0x84 - Transmit status of Tx channel 0 (renamed from OUT_STATE_CH)
        volatile uint32_t OUT_EOF_DES_ADDR_CH;  ///< Offset: 0x88 - Outlink descriptor address when EOF occurs of Tx channel 0 (renamed from OUT_EOF_DES_ADDR_CH)
        volatile uint32_t OUT_EOF_BFR_DES_ADDR_CH;  ///< Offset: 0x8C - The last outlink descriptor address when EOF occurs of... (renamed from OUT_EOF_BFR_DES_ADDR_CH)
        volatile uint32_t OUT_DSCR_CH;  ///< Offset: 0x90 - Current inlink descriptor address of Tx channel 0 (renamed from OUT_DSCR_CH)
        volatile uint32_t OUT_DSCR_BF0_CH;  ///< Offset: 0x94 - The last inlink descriptor address of Tx channel 0 (renamed from OUT_DSCR_BF0_CH)
        volatile uint32_t OUT_DSCR_BF1_CH;  ///< Offset: 0x98 - The second-to-last inlink descriptor address of Tx channel 0 (renamed from OUT_DSCR_BF1_CH)
        volatile uint32_t OUT_WIGHT_CH;  ///< Offset: 0x9C - Weight register of Rx channel 0 (renamed from OUT_WIGHT_CH)
        volatile uint32_t OUT_PRI_CH;  ///< Offset: 0xA4 - Priority register of Tx channel 0. (renamed from OUT_PRI_CH)
        volatile uint32_t OUT_PERI_SEL_CH;  ///< Offset: 0xA8 - Peripheral selection of Tx channel 0 (renamed from OUT_PERI_SEL_CH)
        volatile uint32_t AHB_TEST;  ///< Offset: 0x3C0 - reserved
        volatile uint32_t PD_CONF;  ///< Offset: 0x3C4 - reserved
        volatile uint32_t MISC_CONF;  ///< Offset: 0x3C8 - MISC register
        volatile uint32_t IN_SRAM_SIZE_CH;  ///< Offset: 0x3CC - Receive L2 FIFO depth of Rx channel 0 (renamed from IN_SRAM_SIZE_CH)
        volatile uint32_t OUT_SRAM_SIZE_CH;  ///< Offset: 0x3D0 - Transmit L2 FIFO depth of Tx channel 0 (renamed from OUT_SRAM_SIZE_CH)
        volatile uint32_t EXTMEM_REJECT_ADDR;  ///< Offset: 0x3F4 - Reject address accessing external RAM
        volatile uint32_t EXTMEM_REJECT_ST;  ///< Offset: 0x3F8 - Reject status accessing external RAM
        volatile uint32_t EXTMEM_REJECT_INT_RAW;  ///< Offset: 0x3FC - Raw interrupt status of external RAM permission
        volatile uint32_t EXTMEM_REJECT_INT_ST;  ///< Offset: 0x400 - Masked interrupt status of external RAM permission
        volatile uint32_t EXTMEM_REJECT_INT_ENA;  ///< Offset: 0x404 - Interrupt enable bits of external RAM permission
        volatile uint32_t EXTMEM_REJECT_INT_CLR;  ///< Offset: 0x408 - Interrupt clear bits of external RAM permission
        volatile uint32_t DATE;  ///< Offset: 0x40C - Version control register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);

    // Bit definitions
    /// IN_CONF0_CH Register bits
    namespace in_conf0_ch_bits {
        constexpr uint32_t IN_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
        constexpr uint32_t IN_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t INDSCR_BURST_EN = (1U << 2);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t IN_DATA_BURST_EN = (1U << 3);  ///< Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
        constexpr uint32_t MEM_TRANS_EN = (1U << 4);  ///< Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
    }

    /// IN_CONF1_CH Register bits
    namespace in_conf1_ch_bits {
        constexpr uint32_t DMA_INFIFO_FULL_THRS = (12 << 0);  ///< This register is used to generate the INFIFO_FULL_WM_INT interrupt when Rx channel 0 received byte number in Rx FIFO is up to the value of the register.
        constexpr uint32_t IN_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
        constexpr uint32_t IN_EXT_MEM_BK_SIZE = (2 << 13);  ///< Block size of Rx channel 0 when DMA access external SRAM. 0: 16 bytes 1: 32 bytes 2/3:reserved
    }

    /// IN_INT_RAW_CH Register bits
    namespace in_int_raw_ch_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0, the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals, this raw interrupt is reserved.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The raw interrupt bit turns to high level when detecting inlink descriptor error, including owner error, the second and third word error of inlink descriptor for Rx channel 0.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed, but there is no more inlink for Rx channel 0.
        constexpr uint32_t INFIFO_FULL_WM = (1U << 5);  ///< The raw interrupt bit turns to high level when received data byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0 in Rx FIFO of channel 0.
        constexpr uint32_t INFIFO_OVF_L1 = (1U << 6);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF_L1 = (1U << 7);  ///< This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
        constexpr uint32_t INFIFO_OVF_L3 = (1U << 8);  ///< This raw interrupt bit turns to high level when level 3 fifo of Rx channel 0 is overflow.
        constexpr uint32_t INFIFO_UDF_L3 = (1U << 9);  ///< This raw interrupt bit turns to high level when level 3 fifo of Rx channel 0 is underflow.
    }

    /// IN_INT_ST_CH Register bits
    namespace in_int_st_ch_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_FULL_WM = (1U << 5);  ///< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L1 = (1U << 6);  ///< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L1 = (1U << 7);  ///< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L3 = (1U << 8);  ///< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L3 = (1U << 9);  ///< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.
    }

    /// IN_INT_ENA_CH Register bits
    namespace in_int_ena_ch_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< The interrupt enable bit for the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t INFIFO_FULL_WM = (1U << 5);  ///< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L1 = (1U << 6);  ///< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L1 = (1U << 7);  ///< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L3 = (1U << 8);  ///< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L3 = (1U << 9);  ///< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.
    }

    /// IN_INT_CLR_CH Register bits
    namespace in_int_clr_ch_bits {
        constexpr uint32_t IN_DONE = (1U << 0);  ///< Set this bit to clear the IN_DONE_CH_INT interrupt.
        constexpr uint32_t IN_SUC_EOF = (1U << 1);  ///< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
        constexpr uint32_t IN_ERR_EOF = (1U << 2);  ///< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_ERR = (1U << 3);  ///< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t IN_DSCR_EMPTY = (1U << 4);  ///< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
        constexpr uint32_t DMA_INFIFO_FULL_WM = (1U << 5);  ///< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L1 = (1U << 6);  ///< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L1 = (1U << 7);  ///< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t INFIFO_OVF_L3 = (1U << 8);  ///< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t INFIFO_UDF_L3 = (1U << 9);  ///< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.
    }

    /// INFIFO_STATUS_CH Register bits
    namespace infifo_status_ch_bits {
        constexpr uint32_t INFIFO_FULL_L1 = (1U << 0);  ///< L1 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY_L1 = (1U << 1);  ///< L1 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_FULL_L2 = (1U << 2);  ///< L2 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY_L2 = (1U << 3);  ///< L2 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_FULL_L3 = (1U << 4);  ///< L3 Rx FIFO full signal for Rx channel 0.
        constexpr uint32_t INFIFO_EMPTY_L3 = (1U << 5);  ///< L3 Rx FIFO empty signal for Rx channel 0.
        constexpr uint32_t INFIFO_CNT_L1 = (6 << 6);  ///< The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
        constexpr uint32_t INFIFO_CNT_L2 = (7 << 12);  ///< The register stores the byte number of the data in L2 Rx FIFO for Rx channel 0.
        constexpr uint32_t INFIFO_CNT_L3 = (5 << 19);  ///< The register stores the byte number of the data in L3 Rx FIFO for Rx channel 0.
        constexpr uint32_t IN_REMAIN_UNDER_1B_L3 = (1U << 24);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_2B_L3 = (1U << 25);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_3B_L3 = (1U << 26);  ///< reserved
        constexpr uint32_t IN_REMAIN_UNDER_4B_L3 = (1U << 27);  ///< reserved
        constexpr uint32_t IN_BUF_HUNGRY = (1U << 28);  ///< reserved
    }

    /// IN_POP_CH Register bits
    namespace in_pop_ch_bits {
        constexpr uint32_t INFIFO_RDATA = (12 << 0);  ///< This register stores the data popping from DMA FIFO.
        constexpr uint32_t INFIFO_POP = (1U << 12);  ///< Set this bit to pop data from DMA FIFO.
    }

    /// IN_LINK_CH Register bits
    namespace in_link_ch_bits {
        constexpr uint32_t INLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first inlink descriptor's address.
        constexpr uint32_t INLINK_AUTO_RET = (1U << 20);  ///< Set this bit to return to current inlink descriptor's address, when there are some errors in current receiving data.
        constexpr uint32_t INLINK_STOP = (1U << 21);  ///< Set this bit to stop dealing with the inlink descriptors.
        constexpr uint32_t INLINK_START = (1U << 22);  ///< Set this bit to start dealing with the inlink descriptors.
        constexpr uint32_t INLINK_RESTART = (1U << 23);  ///< Set this bit to mount a new inlink descriptor.
        constexpr uint32_t INLINK_PARK = (1U << 24);  ///< 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM is working.
    }

    /// IN_STATE_CH Register bits
    namespace in_state_ch_bits {
        constexpr uint32_t INLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current inlink descriptor's address.
        constexpr uint32_t IN_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t IN_STATE = (3 << 20);  ///< reserved
    }

    /// IN_SUC_EOF_DES_ADDR_CH Register bits
    namespace in_suc_eof_des_addr_ch_bits {
        constexpr uint32_t IN_SUC_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// IN_ERR_EOF_DES_ADDR_CH Register bits
    namespace in_err_eof_des_addr_ch_bits {
        constexpr uint32_t IN_ERR_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
    }

    /// IN_DSCR_CH Register bits
    namespace in_dscr_ch_bits {
        constexpr uint32_t INLINK_DSCR = (32 << 0);  ///< The address of the current inlink descriptor x.
    }

    /// IN_DSCR_BF0_CH Register bits
    namespace in_dscr_bf0_ch_bits {
        constexpr uint32_t INLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last inlink descriptor x-1.
    }

    /// IN_DSCR_BF1_CH Register bits
    namespace in_dscr_bf1_ch_bits {
        constexpr uint32_t INLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// IN_WIGHT_CH Register bits
    namespace in_wight_ch_bits {
        constexpr uint32_t RX_WEIGHT = (4 << 8);  ///< The weight of Rx channel 0.
    }

    /// IN_PRI_CH Register bits
    namespace in_pri_ch_bits {
        constexpr uint32_t RX_PRI = (4 << 0);  ///< The priority of Rx channel 0. The larger of the value, the higher of the priority.
    }

    /// IN_PERI_SEL_CH Register bits
    namespace in_peri_sel_ch_bits {
        constexpr uint32_t PERI_IN_SEL = (6 << 0);  ///< This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM. 6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.
    }

    /// OUT_CONF0_CH Register bits
    namespace out_conf0_ch_bits {
        constexpr uint32_t OUT_RST = (1U << 0);  ///< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.
        constexpr uint32_t OUT_LOOP_TEST = (1U << 1);  ///< reserved
        constexpr uint32_t OUT_AUTO_WRBACK = (1U << 2);  ///< Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
        constexpr uint32_t OUT_EOF_MODE = (1U << 3);  ///< EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 0 is generated when data need to transmit has been popped from FIFO in DMA
        constexpr uint32_t OUTDSCR_BURST_EN = (1U << 4);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 reading link descriptor when accessing internal SRAM.
        constexpr uint32_t OUT_DATA_BURST_EN = (1U << 5);  ///< Set this bit to 1 to enable INCR burst transfer for Tx channel 0 transmitting data when accessing internal SRAM.
    }

    /// OUT_CONF1_CH Register bits
    namespace out_conf1_ch_bits {
        constexpr uint32_t OUT_CHECK_OWNER = (1U << 12);  ///< Set this bit to enable checking the owner attribute of the link descriptor.
        constexpr uint32_t OUT_EXT_MEM_BK_SIZE = (2 << 13);  ///< Block size of Tx channel 0 when DMA access external SRAM. 0: 16 bytes 1: 32 bytes 2/3:reserved
    }

    /// OUT_INT_RAW_CH Register bits
    namespace out_int_raw_ch_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The raw interrupt bit turns to high level when detecting outlink descriptor error, including owner error, the second and third word error of outlink descriptor for Tx channel 0.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
        constexpr uint32_t OUTFIFO_OVF_L1 = (1U << 4);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF_L1 = (1U << 5);  ///< This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
        constexpr uint32_t OUTFIFO_OVF_L3 = (1U << 6);  ///< This raw interrupt bit turns to high level when level 3 fifo of Tx channel 0 is overflow.
        constexpr uint32_t OUTFIFO_UDF_L3 = (1U << 7);  ///< This raw interrupt bit turns to high level when level 3 fifo of Tx channel 0 is underflow.
    }

    /// OUT_INT_ST_CH Register bits
    namespace out_int_st_ch_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L1 = (1U << 4);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L1 = (1U << 5);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L3 = (1U << 6);  ///< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L3 = (1U << 7);  ///< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.
    }

    /// OUT_INT_ENA_CH Register bits
    namespace out_int_ena_ch_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L1 = (1U << 4);  ///< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L1 = (1U << 5);  ///< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L3 = (1U << 6);  ///< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L3 = (1U << 7);  ///< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.
    }

    /// OUT_INT_CLR_CH Register bits
    namespace out_int_clr_ch_bits {
        constexpr uint32_t OUT_DONE = (1U << 0);  ///< Set this bit to clear the OUT_DONE_CH_INT interrupt.
        constexpr uint32_t OUT_EOF = (1U << 1);  ///< Set this bit to clear the OUT_EOF_CH_INT interrupt.
        constexpr uint32_t OUT_DSCR_ERR = (1U << 2);  ///< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
        constexpr uint32_t OUT_TOTAL_EOF = (1U << 3);  ///< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L1 = (1U << 4);  ///< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L1 = (1U << 5);  ///< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_OVF_L3 = (1U << 6);  ///< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.
        constexpr uint32_t OUTFIFO_UDF_L3 = (1U << 7);  ///< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.
    }

    /// OUTFIFO_STATUS_CH Register bits
    namespace outfifo_status_ch_bits {
        constexpr uint32_t OUTFIFO_FULL_L1 = (1U << 0);  ///< L1 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY_L1 = (1U << 1);  ///< L1 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_FULL_L2 = (1U << 2);  ///< L2 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY_L2 = (1U << 3);  ///< L2 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_FULL_L3 = (1U << 4);  ///< L3 Tx FIFO full signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_EMPTY_L3 = (1U << 5);  ///< L3 Tx FIFO empty signal for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT_L1 = (5 << 6);  ///< The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT_L2 = (7 << 11);  ///< The register stores the byte number of the data in L2 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUTFIFO_CNT_L3 = (5 << 18);  ///< The register stores the byte number of the data in L3 Tx FIFO for Tx channel 0.
        constexpr uint32_t OUT_REMAIN_UNDER_1B_L3 = (1U << 23);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_2B_L3 = (1U << 24);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_3B_L3 = (1U << 25);  ///< reserved
        constexpr uint32_t OUT_REMAIN_UNDER_4B_L3 = (1U << 26);  ///< reserved
    }

    /// OUT_PUSH_CH Register bits
    namespace out_push_ch_bits {
        constexpr uint32_t OUTFIFO_WDATA = (9 << 0);  ///< This register stores the data that need to be pushed into DMA FIFO.
        constexpr uint32_t OUTFIFO_PUSH = (1U << 9);  ///< Set this bit to push data into DMA FIFO.
    }

    /// OUT_LINK_CH Register bits
    namespace out_link_ch_bits {
        constexpr uint32_t OUTLINK_ADDR = (20 << 0);  ///< This register stores the 20 least significant bits of the first outlink descriptor's address.
        constexpr uint32_t OUTLINK_STOP = (1U << 20);  ///< Set this bit to stop dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_START = (1U << 21);  ///< Set this bit to start dealing with the outlink descriptors.
        constexpr uint32_t OUTLINK_RESTART = (1U << 22);  ///< Set this bit to restart a new outlink from the last address.
        constexpr uint32_t OUTLINK_PARK = (1U << 23);  ///< 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's FSM is working.
    }

    /// OUT_STATE_CH Register bits
    namespace out_state_ch_bits {
        constexpr uint32_t OUTLINK_DSCR_ADDR = (18 << 0);  ///< This register stores the current outlink descriptor's address.
        constexpr uint32_t OUT_DSCR_STATE = (2 << 18);  ///< reserved
        constexpr uint32_t OUT_STATE = (3 << 20);  ///< reserved
    }

    /// OUT_EOF_DES_ADDR_CH Register bits
    namespace out_eof_des_addr_ch_bits {
        constexpr uint32_t OUT_EOF_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
    }

    /// OUT_EOF_BFR_DES_ADDR_CH Register bits
    namespace out_eof_bfr_des_addr_ch_bits {
        constexpr uint32_t OUT_EOF_BFR_DES_ADDR = (32 << 0);  ///< This register stores the address of the outlink descriptor before the last outlink descriptor.
    }

    /// OUT_DSCR_CH Register bits
    namespace out_dscr_ch_bits {
        constexpr uint32_t OUTLINK_DSCR = (32 << 0);  ///< The address of the current outlink descriptor y.
    }

    /// OUT_DSCR_BF0_CH Register bits
    namespace out_dscr_bf0_ch_bits {
        constexpr uint32_t OUTLINK_DSCR_BF0 = (32 << 0);  ///< The address of the last outlink descriptor y-1.
    }

    /// OUT_DSCR_BF1_CH Register bits
    namespace out_dscr_bf1_ch_bits {
        constexpr uint32_t OUTLINK_DSCR_BF1 = (32 << 0);  ///< The address of the second-to-last inlink descriptor x-2.
    }

    /// OUT_WIGHT_CH Register bits
    namespace out_wight_ch_bits {
        constexpr uint32_t TX_WEIGHT = (4 << 8);  ///< The weight of Tx channel 0.
    }

    /// OUT_PRI_CH Register bits
    namespace out_pri_ch_bits {
        constexpr uint32_t TX_PRI = (4 << 0);  ///< The priority of Tx channel 0. The larger of the value, the higher of the priority.
    }

    /// OUT_PERI_SEL_CH Register bits
    namespace out_peri_sel_ch_bits {
        constexpr uint32_t PERI_OUT_SEL = (6 << 0);  ///< This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM. 6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.
    }

    /// AHB_TEST Register bits
    namespace ahb_test_bits {
        constexpr uint32_t AHB_TESTMODE = (3 << 0);  ///< reserved
        constexpr uint32_t AHB_TESTADDR = (2 << 4);  ///< reserved
    }

    /// PD_CONF Register bits
    namespace pd_conf_bits {
        constexpr uint32_t DMA_RAM_FORCE_PD = (1U << 4);  ///< Set this bit to force power down DMA internal memory.
        constexpr uint32_t DMA_RAM_FORCE_PU = (1U << 5);  ///< Set this bit to force power up DMA internal memory
        constexpr uint32_t DMA_RAM_CLK_FO = (1U << 6);  ///< 1: Force to open the clock and bypass the gate-clock when accessing the RAM in DMA. 0: A gate-clock will be used when accessing the RAM in DMA.
    }

    /// MISC_CONF Register bits
    namespace misc_conf_bits {
        constexpr uint32_t AHBM_RST_INTER = (1U << 0);  ///< Set this bit, then clear this bit to reset the internal ahb FSM.
        constexpr uint32_t AHBM_RST_EXTER = (1U << 1);  ///< Set this bit, then clear this bit to reset the external ahb FSM.
        constexpr uint32_t ARB_PRI_DIS = (1U << 2);  ///< Set this bit to disable priority arbitration function.
        constexpr uint32_t CLK_EN = (1U << 4);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// IN_SRAM_SIZE_CH Register bits
    namespace in_sram_size_ch_bits {
        constexpr uint32_t IN_SIZE = (7 << 0);  ///< This register is used to configure the size of L2 Tx FIFO for Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40 bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes. 8: 80 bytes.
    }

    /// OUT_SRAM_SIZE_CH Register bits
    namespace out_sram_size_ch_bits {
        constexpr uint32_t OUT_SIZE = (7 << 0);  ///< This register is used to configure the size of L2 Tx FIFO for Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40 bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes. 8: 80 bytes.
    }

    /// EXTMEM_REJECT_ADDR Register bits
    namespace extmem_reject_addr_bits {
        constexpr uint32_t EXTMEM_REJECT_ADDR = (32 << 0);  ///< This register store the first address rejected by permission control when accessing external RAM.
    }

    /// EXTMEM_REJECT_ST Register bits
    namespace extmem_reject_st_bits {
        constexpr uint32_t EXTMEM_REJECT_ATRR = (2 << 0);  ///< The reject accessing. Bit 0: if this bit is 1, the rejected accessing is READ. Bit 1: if this bit is 1, the rejected accessing is WRITE.
        constexpr uint32_t EXTMEM_REJECT_CHANNEL_NUM = (4 << 2);  ///< The register indicate the reject accessing from which channel.
        constexpr uint32_t EXTMEM_REJECT_PERI_NUM = (6 << 6);  ///< This register indicate reject accessing from which peripheral.
    }

    /// EXTMEM_REJECT_INT_RAW Register bits
    namespace extmem_reject_int_raw_bits {
        constexpr uint32_t EXTMEM_REJECT_INT_RAW = (1U << 0);  ///< The raw interrupt bit turns to high level when accessing external RAM is rejected by permission control.
    }

    /// EXTMEM_REJECT_INT_ST Register bits
    namespace extmem_reject_int_st_bits {
        constexpr uint32_t EXTMEM_REJECT_INT_ST = (1U << 0);  ///< The raw interrupt status bit for the EXTMEM_REJECT_INT interrupt.
    }

    /// EXTMEM_REJECT_INT_ENA Register bits
    namespace extmem_reject_int_ena_bits {
        constexpr uint32_t EXTMEM_REJECT_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the EXTMEM_REJECT_INT interrupt.
    }

    /// EXTMEM_REJECT_INT_CLR Register bits
    namespace extmem_reject_int_clr_bits {
        constexpr uint32_t EXTMEM_REJECT_INT_CLR = (1U << 0);  ///< Set this bit to clear the EXTMEM_REJECT_INT interrupt.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< register version.
    }

}

// ============================================================================
// DS Peripheral
// ============================================================================

namespace ds {
    /// Base addresses
    constexpr uint32_t DS_BASE = 0x6003D000;

    /// DS Register structure
    struct Registers {
        volatile uint32_t C_MEM__;  ///< Offset: 0x00 - Memory C (renamed from C_MEM__)
        volatile uint32_t IV_;  ///< Offset: 0x630 - IV block data (renamed from IV_)
        volatile uint32_t X_MEM__;  ///< Offset: 0x800 - Memory X (renamed from X_MEM__)
        volatile uint32_t Z_MEM__;  ///< Offset: 0xA00 - Memory Z (renamed from Z_MEM__)
        volatile uint32_t SET_START;  ///< Offset: 0xE00 - Activates the DS peripheral
        volatile uint32_t SET_ME;  ///< Offset: 0xE04 - Starts DS operation
        volatile uint32_t SET_FINISH;  ///< Offset: 0xE08 - Ends DS operation
        volatile uint32_t QUERY_BUSY;  ///< Offset: 0xE0C - Status of the DS perihperal
        volatile uint32_t QUERY_KEY_WRONG;  ///< Offset: 0xE10 - Checks the reason why DS_KEY is not ready
        volatile uint32_t QUERY_CHECK;  ///< Offset: 0xE14 - Queries DS check result
        volatile uint32_t DATE;  ///< Offset: 0xE20 - DS version control register
    };

    /// Peripheral instances
    inline Registers* DS = reinterpret_cast<Registers*>(DS_BASE);

    // Bit definitions
    /// IV_ Register bits
    namespace iv__bits {
        constexpr uint32_t IV = (32 << 0);  ///< Stores IV block data
    }

    /// SET_START Register bits
    namespace set_start_bits {
        constexpr uint32_t SET_START = (1U << 0);  ///< Write 1 to this register to active the DS peripheral
    }

    /// SET_ME Register bits
    namespace set_me_bits {
        constexpr uint32_t SET_ME = (1U << 0);  ///< Write 1 to this register to start DS operation.
    }

    /// SET_FINISH Register bits
    namespace set_finish_bits {
        constexpr uint32_t SET_FINISH = (1U << 0);  ///< Write 1 to this register to end DS operation.
    }

    /// QUERY_BUSY Register bits
    namespace query_busy_bits {
        constexpr uint32_t QUERY_BUSY = (1U << 0);  ///< Stores the status of the DS peripheral. 1: The DS peripheral is busy. 0: The DS peripheral is idle.
    }

    /// QUERY_KEY_WRONG Register bits
    namespace query_key_wrong_bits {
        constexpr uint32_t QUERY_KEY_WRONG = (4 << 0);  ///< 1-15: HMAC was activated, but the DS peripheral did not successfully receive the DS_KEY from the HMAC peripheral. (The biggest value is 15). 0: HMAC is not activated.
    }

    /// QUERY_CHECK Register bits
    namespace query_check_bits {
        constexpr uint32_t MD_ERROR = (1U << 0);  ///< MD checkout result. 1: The MD check fails. 0: The MD check passes.
        constexpr uint32_t PADDING_BAD = (1U << 1);  ///< padding checkout result. 1: The padding check fails. 0: The padding check passes.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (30 << 0);  ///< ds version information
    }

}

// ============================================================================
// EFUSE Peripheral
// ============================================================================

namespace efuse {
    /// Base addresses
    constexpr uint32_t EFUSE_BASE = 0x60007000;

    /// EFUSE Register structure
    struct Registers {
        volatile uint32_t PGM_DATA0;  ///< Offset: 0x00 - Register 0 that stores data to be programmed.
        volatile uint32_t PGM_DATA1;  ///< Offset: 0x04 - Register 1 that stores data to be programmed.
        volatile uint32_t PGM_DATA2;  ///< Offset: 0x08 - Register 2 that stores data to be programmed.
        volatile uint32_t PGM_DATA3;  ///< Offset: 0x0C - Register 3 that stores data to be programmed.
        volatile uint32_t PGM_DATA4;  ///< Offset: 0x10 - Register 4 that stores data to be programmed.
        volatile uint32_t PGM_DATA5;  ///< Offset: 0x14 - Register 5 that stores data to be programmed.
        volatile uint32_t PGM_DATA6;  ///< Offset: 0x18 - Register 6 that stores data to be programmed.
        volatile uint32_t PGM_DATA7;  ///< Offset: 0x1C - Register 7 that stores data to be programmed.
        volatile uint32_t PGM_CHECK_VALUE0;  ///< Offset: 0x20 - Register 0 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE1;  ///< Offset: 0x24 - Register 1 that stores the RS code to be programmed.
        volatile uint32_t PGM_CHECK_VALUE2;  ///< Offset: 0x28 - Register 2 that stores the RS code to be programmed.
        volatile uint32_t RD_WR_DIS;  ///< Offset: 0x2C - BLOCK0 data register 0.
        volatile uint32_t RD_REPEAT_DATA0;  ///< Offset: 0x30 - BLOCK0 data register 1.
        volatile uint32_t RD_REPEAT_DATA1;  ///< Offset: 0x34 - BLOCK0 data register 2.
        volatile uint32_t RD_REPEAT_DATA2;  ///< Offset: 0x38 - BLOCK0 data register 3.
        volatile uint32_t RD_REPEAT_DATA3;  ///< Offset: 0x3C - BLOCK0 data register 4.
        volatile uint32_t RD_REPEAT_DATA4;  ///< Offset: 0x40 - BLOCK0 data register 5.
        volatile uint32_t RD_MAC_SPI_SYS_0;  ///< Offset: 0x44 - BLOCK1 data register 0.
        volatile uint32_t RD_MAC_SPI_SYS_1;  ///< Offset: 0x48 - BLOCK1 data register 1.
        volatile uint32_t RD_MAC_SPI_SYS_2;  ///< Offset: 0x4C - BLOCK1 data register 2.
        volatile uint32_t RD_MAC_SPI_SYS_3;  ///< Offset: 0x50 - BLOCK1 data register 3.
        volatile uint32_t RD_MAC_SPI_SYS_4;  ///< Offset: 0x54 - BLOCK1 data register 4.
        volatile uint32_t RD_MAC_SPI_SYS_5;  ///< Offset: 0x58 - BLOCK1 data register 5.
        volatile uint32_t RD_SYS_PART1_DATA0;  ///< Offset: 0x5C - Register 0 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA1;  ///< Offset: 0x60 - Register 1 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA2;  ///< Offset: 0x64 - Register 2 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA3;  ///< Offset: 0x68 - Register 3 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA4;  ///< Offset: 0x6C - Register 4 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA5;  ///< Offset: 0x70 - Register 5 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA6;  ///< Offset: 0x74 - Register 6 of BLOCK2 (system).
        volatile uint32_t RD_SYS_PART1_DATA7;  ///< Offset: 0x78 - Register 7 of BLOCK2 (system).
        volatile uint32_t RD_USR_DATA0;  ///< Offset: 0x7C - Register 0 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA1;  ///< Offset: 0x80 - Register 1 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA2;  ///< Offset: 0x84 - Register 2 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA3;  ///< Offset: 0x88 - Register 3 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA4;  ///< Offset: 0x8C - Register 4 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA5;  ///< Offset: 0x90 - Register 5 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA6;  ///< Offset: 0x94 - Register 6 of BLOCK3 (user).
        volatile uint32_t RD_USR_DATA7;  ///< Offset: 0x98 - Register 7 of BLOCK3 (user).
        volatile uint32_t RD_KEY0_DATA0;  ///< Offset: 0x9C - Register 0 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA1;  ///< Offset: 0xA0 - Register 1 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA2;  ///< Offset: 0xA4 - Register 2 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA3;  ///< Offset: 0xA8 - Register 3 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA4;  ///< Offset: 0xAC - Register 4 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA5;  ///< Offset: 0xB0 - Register 5 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA6;  ///< Offset: 0xB4 - Register 6 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY0_DATA7;  ///< Offset: 0xB8 - Register 7 of BLOCK4 (KEY0).
        volatile uint32_t RD_KEY1_DATA0;  ///< Offset: 0xBC - Register 0 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA1;  ///< Offset: 0xC0 - Register 1 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA2;  ///< Offset: 0xC4 - Register 2 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA3;  ///< Offset: 0xC8 - Register 3 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA4;  ///< Offset: 0xCC - Register 4 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA5;  ///< Offset: 0xD0 - Register 5 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA6;  ///< Offset: 0xD4 - Register 6 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY1_DATA7;  ///< Offset: 0xD8 - Register 7 of BLOCK5 (KEY1).
        volatile uint32_t RD_KEY2_DATA0;  ///< Offset: 0xDC - Register 0 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA1;  ///< Offset: 0xE0 - Register 1 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA2;  ///< Offset: 0xE4 - Register 2 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA3;  ///< Offset: 0xE8 - Register 3 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA4;  ///< Offset: 0xEC - Register 4 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA5;  ///< Offset: 0xF0 - Register 5 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA6;  ///< Offset: 0xF4 - Register 6 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY2_DATA7;  ///< Offset: 0xF8 - Register 7 of BLOCK6 (KEY2).
        volatile uint32_t RD_KEY3_DATA0;  ///< Offset: 0xFC - Register 0 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA1;  ///< Offset: 0x100 - Register 1 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA2;  ///< Offset: 0x104 - Register 2 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA3;  ///< Offset: 0x108 - Register 3 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA4;  ///< Offset: 0x10C - Register 4 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA5;  ///< Offset: 0x110 - Register 5 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA6;  ///< Offset: 0x114 - Register 6 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY3_DATA7;  ///< Offset: 0x118 - Register 7 of BLOCK7 (KEY3).
        volatile uint32_t RD_KEY4_DATA0;  ///< Offset: 0x11C - Register 0 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA1;  ///< Offset: 0x120 - Register 1 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA2;  ///< Offset: 0x124 - Register 2 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA3;  ///< Offset: 0x128 - Register 3 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA4;  ///< Offset: 0x12C - Register 4 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA5;  ///< Offset: 0x130 - Register 5 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA6;  ///< Offset: 0x134 - Register 6 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY4_DATA7;  ///< Offset: 0x138 - Register 7 of BLOCK8 (KEY4).
        volatile uint32_t RD_KEY5_DATA0;  ///< Offset: 0x13C - Register 0 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA1;  ///< Offset: 0x140 - Register 1 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA2;  ///< Offset: 0x144 - Register 2 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA3;  ///< Offset: 0x148 - Register 3 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA4;  ///< Offset: 0x14C - Register 4 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA5;  ///< Offset: 0x150 - Register 5 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA6;  ///< Offset: 0x154 - Register 6 of BLOCK9 (KEY5).
        volatile uint32_t RD_KEY5_DATA7;  ///< Offset: 0x158 - Register 7 of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA0;  ///< Offset: 0x15C - Register 0 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA1;  ///< Offset: 0x160 - Register 1 of BLOCK9 (KEY5).
        volatile uint32_t RD_SYS_PART2_DATA2;  ///< Offset: 0x164 - Register 2 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA3;  ///< Offset: 0x168 - Register 3 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA4;  ///< Offset: 0x16C - Register 4 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA5;  ///< Offset: 0x170 - Register 5 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA6;  ///< Offset: 0x174 - Register 6 of BLOCK10 (system).
        volatile uint32_t RD_SYS_PART2_DATA7;  ///< Offset: 0x178 - Register 7 of BLOCK10 (system).
        volatile uint32_t RD_REPEAT_ERR0;  ///< Offset: 0x17C - Programming error record register 0 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR1;  ///< Offset: 0x180 - Programming error record register 1 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR2;  ///< Offset: 0x184 - Programming error record register 2 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR3;  ///< Offset: 0x188 - Programming error record register 3 of BLOCK0.
        volatile uint32_t RD_REPEAT_ERR4;  ///< Offset: 0x190 - Programming error record register 4 of BLOCK0.
        volatile uint32_t RD_RS_ERR0;  ///< Offset: 0x1C0 - Programming error record register 0 of BLOCK1-10.
        volatile uint32_t RD_RS_ERR1;  ///< Offset: 0x1C4 - Programming error record register 1 of BLOCK1-10.
        volatile uint32_t CLK;  ///< Offset: 0x1C8 - eFuse clcok configuration register.
        volatile uint32_t CONF;  ///< Offset: 0x1CC - eFuse operation mode configuraiton register
        volatile uint32_t STATUS;  ///< Offset: 0x1D0 - eFuse status register.
        volatile uint32_t CMD;  ///< Offset: 0x1D4 - eFuse command register.
        volatile uint32_t INT_RAW;  ///< Offset: 0x1D8 - eFuse raw interrupt register.
        volatile uint32_t INT_ST;  ///< Offset: 0x1DC - eFuse interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x1E0 - eFuse interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x1E4 - eFuse interrupt clear register.
        volatile uint32_t DAC_CONF;  ///< Offset: 0x1E8 - Controls the eFuse programming voltage.
        volatile uint32_t RD_TIM_CONF;  ///< Offset: 0x1EC - Configures read timing parameters.
        volatile uint32_t WR_TIM_CONF1;  ///< Offset: 0x1F4 - Configurarion register 1 of eFuse programming timing parameters.
        volatile uint32_t WR_TIM_CONF2;  ///< Offset: 0x1F8 - Configurarion register 2 of eFuse programming timing parameters.
        volatile uint32_t DATE;  ///< Offset: 0x1FC - eFuse version register.
    };

    /// Peripheral instances
    inline Registers* EFUSE = reinterpret_cast<Registers*>(EFUSE_BASE);

    // Bit definitions
    /// PGM_DATA0 Register bits
    namespace pgm_data0_bits {
        constexpr uint32_t PGM_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit data to be programmed.
    }

    /// PGM_DATA1 Register bits
    namespace pgm_data1_bits {
        constexpr uint32_t PGM_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit data to be programmed.
    }

    /// PGM_DATA2 Register bits
    namespace pgm_data2_bits {
        constexpr uint32_t PGM_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit data to be programmed.
    }

    /// PGM_DATA3 Register bits
    namespace pgm_data3_bits {
        constexpr uint32_t PGM_DATA_3 = (32 << 0);  ///< The content of the 3rd 32-bit data to be programmed.
    }

    /// PGM_DATA4 Register bits
    namespace pgm_data4_bits {
        constexpr uint32_t PGM_DATA_4 = (32 << 0);  ///< The content of the 4th 32-bit data to be programmed.
    }

    /// PGM_DATA5 Register bits
    namespace pgm_data5_bits {
        constexpr uint32_t PGM_DATA_5 = (32 << 0);  ///< The content of the 5th 32-bit data to be programmed.
    }

    /// PGM_DATA6 Register bits
    namespace pgm_data6_bits {
        constexpr uint32_t PGM_DATA_6 = (32 << 0);  ///< The content of the 6th 32-bit data to be programmed.
    }

    /// PGM_DATA7 Register bits
    namespace pgm_data7_bits {
        constexpr uint32_t PGM_DATA_7 = (32 << 0);  ///< The content of the 7th 32-bit data to be programmed.
    }

    /// PGM_CHECK_VALUE0 Register bits
    namespace pgm_check_value0_bits {
        constexpr uint32_t PGM_RS_DATA_0 = (32 << 0);  ///< The content of the 0th 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE1 Register bits
    namespace pgm_check_value1_bits {
        constexpr uint32_t PGM_RS_DATA_1 = (32 << 0);  ///< The content of the 1st 32-bit RS code to be programmed.
    }

    /// PGM_CHECK_VALUE2 Register bits
    namespace pgm_check_value2_bits {
        constexpr uint32_t PGM_RS_DATA_2 = (32 << 0);  ///< The content of the 2nd 32-bit RS code to be programmed.
    }

    /// RD_WR_DIS Register bits
    namespace rd_wr_dis_bits {
        constexpr uint32_t WR_DIS = (32 << 0);  ///< Disable programming of individual eFuses.
    }

    /// RD_REPEAT_DATA0 Register bits
    namespace rd_repeat_data0_bits {
        constexpr uint32_t RD_DIS = (7 << 0);  ///< Set this bit to disable reading from BlOCK4-10.
        constexpr uint32_t DIS_RTC_RAM_BOOT = (1U << 7);  ///< Set this bit to disable boot from RTC RAM.
        constexpr uint32_t DIS_ICACHE = (1U << 8);  ///< Set this bit to disable Icache.
        constexpr uint32_t DIS_DCACHE = (1U << 9);  ///< Set this bit to disable Dcache.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE = (1U << 10);  ///< Set this bit to disable Icache in download mode (boot_mode[3:0] is 0, 1, 2, 3, 6, 7).
        constexpr uint32_t DIS_DOWNLOAD_DCACHE = (1U << 11);  ///< Set this bit to disable Dcache in download mode ( boot_mode[3:0] is 0, 1, 2, 3, 6, 7).
        constexpr uint32_t DIS_FORCE_DOWNLOAD = (1U << 12);  ///< Set this bit to disable the function that forces chip into download mode.
        constexpr uint32_t DIS_USB = (1U << 13);  ///< Set this bit to disable USB function.
        constexpr uint32_t DIS_CAN = (1U << 14);  ///< Set this bit to disable CAN function.
        constexpr uint32_t DIS_APP_CPU = (1U << 15);  ///< Disable app cpu.
        constexpr uint32_t SOFT_DIS_JTAG = (3 << 16);  ///< Set these bits to disable JTAG in the soft way (odd number 1 means disable ). JTAG can be enabled in HMAC module.
        constexpr uint32_t DIS_PAD_JTAG = (1U << 19);  ///< Set this bit to disable JTAG in the hard way. JTAG is disabled permanently.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT = (1U << 20);  ///< Set this bit to disable flash encryption when in download boot modes.
        constexpr uint32_t USB_DREFH = (2 << 21);  ///< Controls single-end input threshold vrefh, 1.76 V to 2 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_DREFL = (2 << 23);  ///< Controls single-end input threshold vrefl, 0.8 V to 1.04 V with step of 80 mV, stored in eFuse.
        constexpr uint32_t USB_EXCHG_PINS = (1U << 25);  ///< Set this bit to exchange USB D+ and D- pins.
        constexpr uint32_t EXT_PHY_ENABLE = (1U << 26);  ///< Set this bit to enable external PHY.
        constexpr uint32_t BTLC_GPIO_ENABLE = (2 << 27);  ///< Bluetooth GPIO signal output security level control.
        constexpr uint32_t VDD_SPI_MODECURLIM = (1U << 29);  ///< SPI regulator switches current limit mode.
        constexpr uint32_t VDD_SPI_DREFH = (2 << 30);  ///< SPI regulator high voltage reference.
    }

    /// RD_REPEAT_DATA1 Register bits
    namespace rd_repeat_data1_bits {
        constexpr uint32_t VDD_SPI_DREFM = (2 << 0);  ///< SPI regulator medium voltage reference.
        constexpr uint32_t VDD_SPI_DREFL = (2 << 2);  ///< SPI regulator low voltage reference.
        constexpr uint32_t VDD_SPI_XPD = (1U << 4);  ///< SPI regulator power up signal.
        constexpr uint32_t VDD_SPI_TIEH = (1U << 5);  ///< SPI regulator output is short connected to VDD3P3_RTC_IO.
        constexpr uint32_t VDD_SPI_FORCE = (1U << 6);  ///< Set this bit and force to use the configuration of eFuse to configure VDD_SPI.
        constexpr uint32_t VDD_SPI_EN_INIT = (1U << 7);  ///< Set SPI regulator to 0 to configure init[1:0]=0.
        constexpr uint32_t VDD_SPI_ENCURLIM = (1U << 8);  ///< Set SPI regulator to 1 to enable output current limit.
        constexpr uint32_t VDD_SPI_DCURLIM = (3 << 9);  ///< Tunes the current limit threshold of SPI regulator when tieh=0, about 800 mA/(8+d).
        constexpr uint32_t VDD_SPI_INIT = (2 << 12);  ///< Adds resistor from LDO output to ground. 0: no resistance 1: 6 K 2: 4 K 3: 2 K.
        constexpr uint32_t VDD_SPI_DCAP = (2 << 14);  ///< Prevents SPI regulator from overshoot.
        constexpr uint32_t WDT_DELAY_SEL = (2 << 16);  ///< Selects RTC watchdog timeout threshold, in unit of slow clock cycle. 0: 40000. 1: 80000. 2: 160000. 3:320000.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT = (3 << 18);  ///< Set this bit to enable SPI boot encrypt/decrypt. Odd number of 1: enable. even number of 1: disable.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0 = (1U << 21);  ///< Set this bit to enable revoking first secure boot key.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1 = (1U << 22);  ///< Set this bit to enable revoking second secure boot key.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2 = (1U << 23);  ///< Set this bit to enable revoking third secure boot key.
        constexpr uint32_t KEY_PURPOSE_0 = (4 << 24);  ///< Purpose of Key0.
        constexpr uint32_t KEY_PURPOSE_1 = (4 << 28);  ///< Purpose of Key1.
    }

    /// RD_REPEAT_DATA2 Register bits
    namespace rd_repeat_data2_bits {
        constexpr uint32_t KEY_PURPOSE_2 = (4 << 0);  ///< Purpose of Key2.
        constexpr uint32_t KEY_PURPOSE_3 = (4 << 4);  ///< Purpose of Key3.
        constexpr uint32_t KEY_PURPOSE_4 = (4 << 8);  ///< Purpose of Key4.
        constexpr uint32_t KEY_PURPOSE_5 = (4 << 12);  ///< Purpose of Key5.
        constexpr uint32_t RPT4_RESERVED0 = (4 << 16);  ///< Reserved (used for four backups method).
        constexpr uint32_t SECURE_BOOT_EN = (1U << 20);  ///< Set this bit to enable secure boot.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE = (1U << 21);  ///< Set this bit to enable revoking aggressive secure boot.
        constexpr uint32_t DIS_USB_JTAG = (1U << 22);  ///< Set this bit to disable function of usb switch to jtag in module of usb device.
        constexpr uint32_t DIS_USB_DEVICE = (1U << 23);  ///< Set this bit to disable usb device.
        constexpr uint32_t STRAP_JTAG_SEL = (1U << 24);  ///< Set this bit to enable selection between usb_to_jtag and pad_to_jtag through strapping gpio10 when both reg_dis_usb_jtag and reg_dis_pad_jtag are equal to 0.
        constexpr uint32_t USB_PHY_SEL = (1U << 25);  ///< This bit is used to switch internal PHY and external PHY for USB OTG and USB Device. 0: internal PHY is assigned to USB Device while external PHY is assigned to USB OTG. 1: internal PHY is assigned to USB OTG while external PHY is assigned to USB Device.
        constexpr uint32_t POWER_GLITCH_DSENSE = (2 << 26);  ///< Sample delay configuration of power glitch.
        constexpr uint32_t FLASH_TPUW = (4 << 28);  ///< Configures flash waiting time after power-up, in unit of ms. If the value is less than 15, the waiting time is the configurable value. Otherwise, the waiting time is twice the configurable value.
    }

    /// RD_REPEAT_DATA3 Register bits
    namespace rd_repeat_data3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE = (1U << 0);  ///< Set this bit to disable download mode (boot_mode[3:0] = 0, 1, 2, 3, 6, 7).
        constexpr uint32_t DIS_LEGACY_SPI_BOOT = (1U << 1);  ///< Set this bit to disable Legacy SPI boot mode (boot_mode[3:0] = 4).
        constexpr uint32_t UART_PRINT_CHANNEL = (1U << 2);  ///< Selectes the default UART print channel. 0: UART0. 1: UART1.
        constexpr uint32_t FLASH_ECC_MODE = (1U << 3);  ///< Set ECC mode in ROM, 0: ROM would Enable Flash ECC 16to18 byte mode. 1:ROM would use 16to17 byte mode.
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE = (1U << 4);  ///< Set this bit to disable UART download mode through USB.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD = (1U << 5);  ///< Set this bit to enable secure UART download mode.
        constexpr uint32_t UART_PRINT_CONTROL = (2 << 6);  ///< Set the default UARTboot message output mode. 00: Enabled. 01: Enabled when GPIO8 is low at reset. 10: Enabled when GPIO8 is high at reset. 11:disabled.
        constexpr uint32_t PIN_POWER_SELECTION = (1U << 8);  ///< GPIO33-GPIO37 power supply selection in ROM code. 0: VDD3P3_CPU. 1: VDD_SPI.
        constexpr uint32_t FLASH_TYPE = (1U << 9);  ///< Set the maximum lines of SPI flash. 0: four lines. 1: eight lines.
        constexpr uint32_t FLASH_PAGE_SIZE = (2 << 10);  ///< Set Flash page size.
        constexpr uint32_t FLASH_ECC_EN = (1U << 12);  ///< Set 1 to enable ECC for flash boot.
        constexpr uint32_t FORCE_SEND_RESUME = (1U << 13);  ///< Set this bit to force ROM code to send a resume command during SPI boot.
        constexpr uint32_t SECURE_VERSION = (16 << 14);  ///< Secure version (used by ESP-IDF anti-rollback feature).
        constexpr uint32_t POWERGLITCH_EN = (1U << 30);  ///< Set this bit to enable power glitch function.
        constexpr uint32_t RPT4_RESERVED1 = (1U << 31);  ///< Reserved (used for four backups method).
    }

    /// RD_REPEAT_DATA4 Register bits
    namespace rd_repeat_data4_bits {
        constexpr uint32_t RPT4_RESERVED2 = (24 << 0);  ///< Reserved (used for four backups method).
    }

    /// RD_MAC_SPI_SYS_0 Register bits
    namespace rd_mac_spi_sys_0_bits {
        constexpr uint32_t MAC_0 = (32 << 0);  ///< Stores the low 32 bits of MAC address.
    }

    /// RD_MAC_SPI_SYS_1 Register bits
    namespace rd_mac_spi_sys_1_bits {
        constexpr uint32_t MAC_1 = (16 << 0);  ///< Stores the high 16 bits of MAC address.
        constexpr uint32_t SPI_PAD_CONF_0 = (16 << 16);  ///< Stores the zeroth part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_2 Register bits
    namespace rd_mac_spi_sys_2_bits {
        constexpr uint32_t SPI_PAD_CONF_1 = (32 << 0);  ///< Stores the first part of SPI_PAD_CONF.
    }

    /// RD_MAC_SPI_SYS_3 Register bits
    namespace rd_mac_spi_sys_3_bits {
        constexpr uint32_t SPI_PAD_CONF_2 = (18 << 0);  ///< Stores the second part of SPI_PAD_CONF.
        constexpr uint32_t SYS_DATA_PART0_0 = (14 << 18);  ///< Stores the fist 14 bits of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_4 Register bits
    namespace rd_mac_spi_sys_4_bits {
        constexpr uint32_t SYS_DATA_PART0_1 = (32 << 0);  ///< Stores the fist 32 bits of the zeroth part of system data.
    }

    /// RD_MAC_SPI_SYS_5 Register bits
    namespace rd_mac_spi_sys_5_bits {
        constexpr uint32_t SYS_DATA_PART0_2 = (32 << 0);  ///< Stores the second 32 bits of the zeroth part of system data.
    }

    /// RD_SYS_PART1_DATA0 Register bits
    namespace rd_sys_part1_data0_bits {
        constexpr uint32_t SYS_DATA_PART1_0 = (32 << 0);  ///< Stores the zeroth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA1 Register bits
    namespace rd_sys_part1_data1_bits {
        constexpr uint32_t SYS_DATA_PART1_1 = (32 << 0);  ///< Stores the first 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA2 Register bits
    namespace rd_sys_part1_data2_bits {
        constexpr uint32_t SYS_DATA_PART1_2 = (32 << 0);  ///< Stores the second 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA3 Register bits
    namespace rd_sys_part1_data3_bits {
        constexpr uint32_t SYS_DATA_PART1_3 = (32 << 0);  ///< Stores the third 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA4 Register bits
    namespace rd_sys_part1_data4_bits {
        constexpr uint32_t SYS_DATA_PART1_4 = (32 << 0);  ///< Stores the fourth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA5 Register bits
    namespace rd_sys_part1_data5_bits {
        constexpr uint32_t SYS_DATA_PART1_5 = (32 << 0);  ///< Stores the fifth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA6 Register bits
    namespace rd_sys_part1_data6_bits {
        constexpr uint32_t SYS_DATA_PART1_6 = (32 << 0);  ///< Stores the sixth 32 bits of the first part of system data.
    }

    /// RD_SYS_PART1_DATA7 Register bits
    namespace rd_sys_part1_data7_bits {
        constexpr uint32_t SYS_DATA_PART1_7 = (32 << 0);  ///< Stores the seventh 32 bits of the first part of system data.
    }

    /// RD_USR_DATA0 Register bits
    namespace rd_usr_data0_bits {
        constexpr uint32_t USR_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA1 Register bits
    namespace rd_usr_data1_bits {
        constexpr uint32_t USR_DATA1 = (32 << 0);  ///< Stores the first 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA2 Register bits
    namespace rd_usr_data2_bits {
        constexpr uint32_t USR_DATA2 = (32 << 0);  ///< Stores the second 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA3 Register bits
    namespace rd_usr_data3_bits {
        constexpr uint32_t USR_DATA3 = (32 << 0);  ///< Stores the third 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA4 Register bits
    namespace rd_usr_data4_bits {
        constexpr uint32_t USR_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA5 Register bits
    namespace rd_usr_data5_bits {
        constexpr uint32_t USR_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA6 Register bits
    namespace rd_usr_data6_bits {
        constexpr uint32_t USR_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of BLOCK3 (user).
    }

    /// RD_USR_DATA7 Register bits
    namespace rd_usr_data7_bits {
        constexpr uint32_t USR_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of BLOCK3 (user).
    }

    /// RD_KEY0_DATA0 Register bits
    namespace rd_key0_data0_bits {
        constexpr uint32_t KEY0_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA1 Register bits
    namespace rd_key0_data1_bits {
        constexpr uint32_t KEY0_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY0.
    }

    /// RD_KEY0_DATA2 Register bits
    namespace rd_key0_data2_bits {
        constexpr uint32_t KEY0_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY0.
    }

    /// RD_KEY0_DATA3 Register bits
    namespace rd_key0_data3_bits {
        constexpr uint32_t KEY0_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY0.
    }

    /// RD_KEY0_DATA4 Register bits
    namespace rd_key0_data4_bits {
        constexpr uint32_t KEY0_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA5 Register bits
    namespace rd_key0_data5_bits {
        constexpr uint32_t KEY0_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA6 Register bits
    namespace rd_key0_data6_bits {
        constexpr uint32_t KEY0_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY0.
    }

    /// RD_KEY0_DATA7 Register bits
    namespace rd_key0_data7_bits {
        constexpr uint32_t KEY0_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY0.
    }

    /// RD_KEY1_DATA0 Register bits
    namespace rd_key1_data0_bits {
        constexpr uint32_t KEY1_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA1 Register bits
    namespace rd_key1_data1_bits {
        constexpr uint32_t KEY1_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY1.
    }

    /// RD_KEY1_DATA2 Register bits
    namespace rd_key1_data2_bits {
        constexpr uint32_t KEY1_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY1.
    }

    /// RD_KEY1_DATA3 Register bits
    namespace rd_key1_data3_bits {
        constexpr uint32_t KEY1_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY1.
    }

    /// RD_KEY1_DATA4 Register bits
    namespace rd_key1_data4_bits {
        constexpr uint32_t KEY1_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA5 Register bits
    namespace rd_key1_data5_bits {
        constexpr uint32_t KEY1_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA6 Register bits
    namespace rd_key1_data6_bits {
        constexpr uint32_t KEY1_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY1.
    }

    /// RD_KEY1_DATA7 Register bits
    namespace rd_key1_data7_bits {
        constexpr uint32_t KEY1_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY1.
    }

    /// RD_KEY2_DATA0 Register bits
    namespace rd_key2_data0_bits {
        constexpr uint32_t KEY2_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA1 Register bits
    namespace rd_key2_data1_bits {
        constexpr uint32_t KEY2_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY2.
    }

    /// RD_KEY2_DATA2 Register bits
    namespace rd_key2_data2_bits {
        constexpr uint32_t KEY2_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY2.
    }

    /// RD_KEY2_DATA3 Register bits
    namespace rd_key2_data3_bits {
        constexpr uint32_t KEY2_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY2.
    }

    /// RD_KEY2_DATA4 Register bits
    namespace rd_key2_data4_bits {
        constexpr uint32_t KEY2_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA5 Register bits
    namespace rd_key2_data5_bits {
        constexpr uint32_t KEY2_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA6 Register bits
    namespace rd_key2_data6_bits {
        constexpr uint32_t KEY2_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY2.
    }

    /// RD_KEY2_DATA7 Register bits
    namespace rd_key2_data7_bits {
        constexpr uint32_t KEY2_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY2.
    }

    /// RD_KEY3_DATA0 Register bits
    namespace rd_key3_data0_bits {
        constexpr uint32_t KEY3_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA1 Register bits
    namespace rd_key3_data1_bits {
        constexpr uint32_t KEY3_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY3.
    }

    /// RD_KEY3_DATA2 Register bits
    namespace rd_key3_data2_bits {
        constexpr uint32_t KEY3_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY3.
    }

    /// RD_KEY3_DATA3 Register bits
    namespace rd_key3_data3_bits {
        constexpr uint32_t KEY3_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY3.
    }

    /// RD_KEY3_DATA4 Register bits
    namespace rd_key3_data4_bits {
        constexpr uint32_t KEY3_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA5 Register bits
    namespace rd_key3_data5_bits {
        constexpr uint32_t KEY3_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA6 Register bits
    namespace rd_key3_data6_bits {
        constexpr uint32_t KEY3_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY3.
    }

    /// RD_KEY3_DATA7 Register bits
    namespace rd_key3_data7_bits {
        constexpr uint32_t KEY3_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY3.
    }

    /// RD_KEY4_DATA0 Register bits
    namespace rd_key4_data0_bits {
        constexpr uint32_t KEY4_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA1 Register bits
    namespace rd_key4_data1_bits {
        constexpr uint32_t KEY4_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY4.
    }

    /// RD_KEY4_DATA2 Register bits
    namespace rd_key4_data2_bits {
        constexpr uint32_t KEY4_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY4.
    }

    /// RD_KEY4_DATA3 Register bits
    namespace rd_key4_data3_bits {
        constexpr uint32_t KEY4_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY4.
    }

    /// RD_KEY4_DATA4 Register bits
    namespace rd_key4_data4_bits {
        constexpr uint32_t KEY4_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA5 Register bits
    namespace rd_key4_data5_bits {
        constexpr uint32_t KEY4_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA6 Register bits
    namespace rd_key4_data6_bits {
        constexpr uint32_t KEY4_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY4.
    }

    /// RD_KEY4_DATA7 Register bits
    namespace rd_key4_data7_bits {
        constexpr uint32_t KEY4_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY4.
    }

    /// RD_KEY5_DATA0 Register bits
    namespace rd_key5_data0_bits {
        constexpr uint32_t KEY5_DATA0 = (32 << 0);  ///< Stores the zeroth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA1 Register bits
    namespace rd_key5_data1_bits {
        constexpr uint32_t KEY5_DATA1 = (32 << 0);  ///< Stores the first 32 bits of KEY5.
    }

    /// RD_KEY5_DATA2 Register bits
    namespace rd_key5_data2_bits {
        constexpr uint32_t KEY5_DATA2 = (32 << 0);  ///< Stores the second 32 bits of KEY5.
    }

    /// RD_KEY5_DATA3 Register bits
    namespace rd_key5_data3_bits {
        constexpr uint32_t KEY5_DATA3 = (32 << 0);  ///< Stores the third 32 bits of KEY5.
    }

    /// RD_KEY5_DATA4 Register bits
    namespace rd_key5_data4_bits {
        constexpr uint32_t KEY5_DATA4 = (32 << 0);  ///< Stores the fourth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA5 Register bits
    namespace rd_key5_data5_bits {
        constexpr uint32_t KEY5_DATA5 = (32 << 0);  ///< Stores the fifth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA6 Register bits
    namespace rd_key5_data6_bits {
        constexpr uint32_t KEY5_DATA6 = (32 << 0);  ///< Stores the sixth 32 bits of KEY5.
    }

    /// RD_KEY5_DATA7 Register bits
    namespace rd_key5_data7_bits {
        constexpr uint32_t KEY5_DATA7 = (32 << 0);  ///< Stores the seventh 32 bits of KEY5.
    }

    /// RD_SYS_PART2_DATA0 Register bits
    namespace rd_sys_part2_data0_bits {
        constexpr uint32_t SYS_DATA_PART2_0 = (32 << 0);  ///< Stores the 0th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA1 Register bits
    namespace rd_sys_part2_data1_bits {
        constexpr uint32_t SYS_DATA_PART2_1 = (32 << 0);  ///< Stores the 1st 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA2 Register bits
    namespace rd_sys_part2_data2_bits {
        constexpr uint32_t SYS_DATA_PART2_2 = (32 << 0);  ///< Stores the 2nd 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA3 Register bits
    namespace rd_sys_part2_data3_bits {
        constexpr uint32_t SYS_DATA_PART2_3 = (32 << 0);  ///< Stores the 3rd 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA4 Register bits
    namespace rd_sys_part2_data4_bits {
        constexpr uint32_t SYS_DATA_PART2_4 = (32 << 0);  ///< Stores the 4th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA5 Register bits
    namespace rd_sys_part2_data5_bits {
        constexpr uint32_t SYS_DATA_PART2_5 = (32 << 0);  ///< Stores the 5th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA6 Register bits
    namespace rd_sys_part2_data6_bits {
        constexpr uint32_t SYS_DATA_PART2_6 = (32 << 0);  ///< Stores the 6th 32 bits of the 2nd part of system data.
    }

    /// RD_SYS_PART2_DATA7 Register bits
    namespace rd_sys_part2_data7_bits {
        constexpr uint32_t SYS_DATA_PART2_7 = (32 << 0);  ///< Stores the 7th 32 bits of the 2nd part of system data.
    }

    /// RD_REPEAT_ERR0 Register bits
    namespace rd_repeat_err0_bits {
        constexpr uint32_t RD_DIS_ERR = (7 << 0);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_RTC_RAM_BOOT_ERR = (1U << 7);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_ICACHE_ERR = (1U << 8);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_DCACHE_ERR = (1U << 9);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_ICACHE_ERR = (1U << 10);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_DCACHE_ERR = (1U << 11);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_FORCE_DOWNLOAD_ERR = (1U << 12);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_ERR = (1U << 13);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_CAN_ERR = (1U << 14);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_APP_CPU_ERR = (1U << 15);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SOFT_DIS_JTAG_ERR = (3 << 16);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_PAD_JTAG_ERR = (1U << 19);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = (1U << 20);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t USB_DREFH_ERR = (2 << 21);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t USB_DREFL_ERR = (2 << 23);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t USB_EXCHG_PINS_ERR = (1U << 25);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t EXT_PHY_ENABLE_ERR = (1U << 26);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t BTLC_GPIO_ENABLE_ERR = (2 << 27);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_MODECURLIM_ERR = (1U << 29);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_DREFH_ERR = (2 << 30);  ///< If any bits in this filed are 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR1 Register bits
    namespace rd_repeat_err1_bits {
        constexpr uint32_t VDD_SPI_DREFM_ERR = (2 << 0);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_DREFL_ERR = (2 << 2);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_XPD_ERR = (1U << 4);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_TIEH_ERR = (1U << 5);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_FORCE_ERR = (1U << 6);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_EN_INIT_ERR = (1U << 7);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_ENCURLIM_ERR = (1U << 8);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_DCURLIM_ERR = (3 << 9);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_INIT_ERR = (2 << 12);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t VDD_SPI_DCAP_ERR = (2 << 14);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t WDT_DELAY_SEL_ERR = (2 << 16);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SPI_BOOT_CRYPT_CNT_ERR = (3 << 18);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE0_ERR = (1U << 21);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE1_ERR = (1U << 22);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_KEY_REVOKE2_ERR = (1U << 23);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_0_ERR = (4 << 24);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_1_ERR = (4 << 28);  ///< If any bits in this filed are 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR2 Register bits
    namespace rd_repeat_err2_bits {
        constexpr uint32_t KEY_PURPOSE_2_ERR = (4 << 0);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_3_ERR = (4 << 4);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_4_ERR = (4 << 8);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t KEY_PURPOSE_5_ERR = (4 << 12);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED0_ERR = (4 << 16);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_EN_ERR = (1U << 20);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = (1U << 21);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_JTAG_ERR = (1U << 22);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_DEVICE_ERR = (1U << 23);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t STRAP_JTAG_SEL_ERR = (1U << 24);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t USB_PHY_SEL_ERR = (1U << 25);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t POWER_GLITCH_DSENSE_ERR = (2 << 26);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FLASH_TPUW_ERR = (4 << 28);  ///< If any bits in this filed are 1, then it indicates a programming error.
    }

    /// RD_REPEAT_ERR3 Register bits
    namespace rd_repeat_err3_bits {
        constexpr uint32_t DIS_DOWNLOAD_MODE_ERR = (1U << 0);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_LEGACY_SPI_BOOT_ERR = (1U << 1);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t UART_PRINT_CHANNEL_ERR = (1U << 2);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FLASH_ECC_MODE_ERR = (1U << 3);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t DIS_USB_DOWNLOAD_MODE_ERR = (1U << 4);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t ENABLE_SECURITY_DOWNLOAD_ERR = (1U << 5);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t UART_PRINT_CONTROL_ERR = (2 << 6);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t PIN_POWER_SELECTION_ERR = (1U << 8);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FLASH_TYPE_ERR = (1U << 9);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FLASH_PAGE_SIZE_ERR = (2 << 10);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FLASH_ECC_EN_ERR = (1U << 12);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t FORCE_SEND_RESUME_ERR = (1U << 13);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t SECURE_VERSION_ERR = (16 << 14);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t POWERGLITCH_EN_ERR = (1U << 30);  ///< If any bits in this filed are 1, then it indicates a programming error.
        constexpr uint32_t RPT4_RESERVED1_ERR = (1U << 31);  ///< Reserved.
    }

    /// RD_REPEAT_ERR4 Register bits
    namespace rd_repeat_err4_bits {
        constexpr uint32_t RPT4_RESERVED2_ERR = (24 << 0);  ///< If any bits in this filed are 1, then it indicates a programming error.
    }

    /// RD_RS_ERR0 Register bits
    namespace rd_rs_err0_bits {
        constexpr uint32_t MAC_SPI_8M_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t MAC_SPI_8M_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART1_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART1_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t USR_DATA_ERR_NUM = (3 << 8);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t USR_DATA_FAIL = (1U << 11);  ///< 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t KEY0_ERR_NUM = (3 << 12);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY0_FAIL = (1U << 15);  ///< 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY1_ERR_NUM = (3 << 16);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY1_FAIL = (1U << 19);  ///< 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY2_ERR_NUM = (3 << 20);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY2_FAIL = (1U << 23);  ///< 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY3_ERR_NUM = (3 << 24);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY3_FAIL = (1U << 27);  ///< 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
        constexpr uint32_t KEY4_ERR_NUM = (3 << 28);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY4_FAIL = (1U << 31);  ///< 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
    }

    /// RD_RS_ERR1 Register bits
    namespace rd_rs_err1_bits {
        constexpr uint32_t KEY5_ERR_NUM = (3 << 0);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t KEY5_FAIL = (1U << 3);  ///< 0: Means no failure and that the data of KEY5 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
        constexpr uint32_t SYS_PART2_ERR_NUM = (3 << 4);  ///< The value of this signal means the number of error bytes.
        constexpr uint32_t SYS_PART2_FAIL = (1U << 7);  ///< 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
    }

    /// CLK Register bits
    namespace clk_bits {
        constexpr uint32_t EFUSE_MEM_FORCE_PD = (1U << 0);  ///< Set this bit to force eFuse SRAM into power-saving mode.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit and force to activate clock signal of eFuse SRAM.
        constexpr uint32_t EFUSE_MEM_FORCE_PU = (1U << 2);  ///< Set this bit to force eFuse SRAM into working mode.
        constexpr uint32_t EN = (1U << 16);  ///< Set this bit and force to enable clock signal of eFuse memory.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t OP_CODE = (16 << 0);  ///< 0x5A5A: Operate programming command 0x5AA5: Operate read command.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t STATE = (4 << 0);  ///< Indicates the state of the eFuse state machine.
        constexpr uint32_t OTP_LOAD_SW = (1U << 4);  ///< The value of OTP_LOAD_SW.
        constexpr uint32_t OTP_VDDQ_C_SYNC2 = (1U << 5);  ///< The value of OTP_VDDQ_C_SYNC2.
        constexpr uint32_t OTP_STROBE_SW = (1U << 6);  ///< The value of OTP_STROBE_SW.
        constexpr uint32_t OTP_CSB_SW = (1U << 7);  ///< The value of OTP_CSB_SW.
        constexpr uint32_t OTP_PGENB_SW = (1U << 8);  ///< The value of OTP_PGENB_SW.
        constexpr uint32_t OTP_VDDQ_IS_SW = (1U << 9);  ///< The value of OTP_VDDQ_IS_SW.
        constexpr uint32_t REPEAT_ERR_CNT = (8 << 10);  ///< Indicates the number of error bits during programming BLOCK0.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t READ_CMD = (1U << 0);  ///< Set this bit to send read command.
        constexpr uint32_t PGM_CMD = (1U << 1);  ///< Set this bit to send programming command.
        constexpr uint32_t BLK_NUM = (4 << 2);  ///< The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t READ_DONE_INT_RAW = (1U << 0);  ///< The raw bit signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_RAW = (1U << 1);  ///< The raw bit signal for pgm_done interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t READ_DONE_INT_ST = (1U << 0);  ///< The status signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ST = (1U << 1);  ///< The status signal for pgm_done interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t READ_DONE_INT_ENA = (1U << 0);  ///< The enable signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_ENA = (1U << 1);  ///< The enable signal for pgm_done interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t READ_DONE_INT_CLR = (1U << 0);  ///< The clear signal for read_done interrupt.
        constexpr uint32_t PGM_DONE_INT_CLR = (1U << 1);  ///< The clear signal for pgm_done interrupt.
    }

    /// DAC_CONF Register bits
    namespace dac_conf_bits {
        constexpr uint32_t DAC_CLK_DIV = (8 << 0);  ///< Controls the division factor of the rising clock of the programming voltage.
        constexpr uint32_t DAC_CLK_PAD_SEL = (1U << 8);  ///< Don't care.
        constexpr uint32_t DAC_NUM = (8 << 9);  ///< Controls the rising period of the programming voltage.
        constexpr uint32_t OE_CLR = (1U << 17);  ///< Reduces the power supply of the programming voltage.
    }

    /// RD_TIM_CONF Register bits
    namespace rd_tim_conf_bits {
        constexpr uint32_t READ_INIT_NUM = (8 << 24);  ///< Configures the initial read time of eFuse.
    }

    /// WR_TIM_CONF1 Register bits
    namespace wr_tim_conf1_bits {
        constexpr uint32_t PWR_ON_NUM = (16 << 8);  ///< Configures the power up time for VDDQ.
    }

    /// WR_TIM_CONF2 Register bits
    namespace wr_tim_conf2_bits {
        constexpr uint32_t PWR_OFF_NUM = (16 << 0);  ///< Configures the power outage time for VDDQ.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Stores eFuse version.
    }

}

// ============================================================================
// EXTMEM Peripheral
// ============================================================================

namespace extmem {
    /// Base addresses
    constexpr uint32_t EXTMEM_BASE = 0x600C4000;

    /// EXTMEM Register structure
    struct Registers {
        volatile uint32_t DCACHE_CTRL;  ///< Offset: 0x00 - ******* Description ***********
        volatile uint32_t DCACHE_CTRL1;  ///< Offset: 0x04 - ******* Description ***********
        volatile uint32_t DCACHE_TAG_POWER_CTRL;  ///< Offset: 0x08 - ******* Description ***********
        volatile uint32_t DCACHE_PRELOCK_CTRL;  ///< Offset: 0x0C - ******* Description ***********
        volatile uint32_t DCACHE_PRELOCK_SCT0_ADDR;  ///< Offset: 0x10 - ******* Description ***********
        volatile uint32_t DCACHE_PRELOCK_SCT1_ADDR;  ///< Offset: 0x14 - ******* Description ***********
        volatile uint32_t DCACHE_PRELOCK_SCT_SIZE;  ///< Offset: 0x18 - ******* Description ***********
        volatile uint32_t DCACHE_LOCK_CTRL;  ///< Offset: 0x1C - ******* Description ***********
        volatile uint32_t DCACHE_LOCK_ADDR;  ///< Offset: 0x20 - ******* Description ***********
        volatile uint32_t DCACHE_LOCK_SIZE;  ///< Offset: 0x24 - ******* Description ***********
        volatile uint32_t DCACHE_SYNC_CTRL;  ///< Offset: 0x28 - ******* Description ***********
        volatile uint32_t DCACHE_SYNC_ADDR;  ///< Offset: 0x2C - ******* Description ***********
        volatile uint32_t DCACHE_SYNC_SIZE;  ///< Offset: 0x30 - ******* Description ***********
        volatile uint32_t DCACHE_OCCUPY_CTRL;  ///< Offset: 0x34 - ******* Description ***********
        volatile uint32_t DCACHE_OCCUPY_ADDR;  ///< Offset: 0x38 - ******* Description ***********
        volatile uint32_t DCACHE_OCCUPY_SIZE;  ///< Offset: 0x3C - ******* Description ***********
        volatile uint32_t DCACHE_PRELOAD_CTRL;  ///< Offset: 0x40 - ******* Description ***********
        volatile uint32_t DCACHE_PRELOAD_ADDR;  ///< Offset: 0x44 - ******* Description ***********
        volatile uint32_t DCACHE_PRELOAD_SIZE;  ///< Offset: 0x48 - ******* Description ***********
        volatile uint32_t DCACHE_AUTOLOAD_CTRL;  ///< Offset: 0x4C - ******* Description ***********
        volatile uint32_t DCACHE_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0x50 - ******* Description ***********
        volatile uint32_t DCACHE_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0x54 - ******* Description ***********
        volatile uint32_t DCACHE_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0x58 - ******* Description ***********
        volatile uint32_t DCACHE_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0x5C - ******* Description ***********
        volatile uint32_t ICACHE_CTRL;  ///< Offset: 0x60 - ******* Description ***********
        volatile uint32_t ICACHE_CTRL1;  ///< Offset: 0x64 - ******* Description ***********
        volatile uint32_t ICACHE_TAG_POWER_CTRL;  ///< Offset: 0x68 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOCK_CTRL;  ///< Offset: 0x6C - ******* Description ***********
        volatile uint32_t ICACHE_PRELOCK_SCT0_ADDR;  ///< Offset: 0x70 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOCK_SCT1_ADDR;  ///< Offset: 0x74 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOCK_SCT_SIZE;  ///< Offset: 0x78 - ******* Description ***********
        volatile uint32_t ICACHE_LOCK_CTRL;  ///< Offset: 0x7C - ******* Description ***********
        volatile uint32_t ICACHE_LOCK_ADDR;  ///< Offset: 0x80 - ******* Description ***********
        volatile uint32_t ICACHE_LOCK_SIZE;  ///< Offset: 0x84 - ******* Description ***********
        volatile uint32_t ICACHE_SYNC_CTRL;  ///< Offset: 0x88 - ******* Description ***********
        volatile uint32_t ICACHE_SYNC_ADDR;  ///< Offset: 0x8C - ******* Description ***********
        volatile uint32_t ICACHE_SYNC_SIZE;  ///< Offset: 0x90 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOAD_CTRL;  ///< Offset: 0x94 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOAD_ADDR;  ///< Offset: 0x98 - ******* Description ***********
        volatile uint32_t ICACHE_PRELOAD_SIZE;  ///< Offset: 0x9C - ******* Description ***********
        volatile uint32_t ICACHE_AUTOLOAD_CTRL;  ///< Offset: 0xA0 - ******* Description ***********
        volatile uint32_t ICACHE_AUTOLOAD_SCT0_ADDR;  ///< Offset: 0xA4 - ******* Description ***********
        volatile uint32_t ICACHE_AUTOLOAD_SCT0_SIZE;  ///< Offset: 0xA8 - ******* Description ***********
        volatile uint32_t ICACHE_AUTOLOAD_SCT1_ADDR;  ///< Offset: 0xAC - ******* Description ***********
        volatile uint32_t ICACHE_AUTOLOAD_SCT1_SIZE;  ///< Offset: 0xB0 - ******* Description ***********
        volatile uint32_t IBUS_TO_FLASH_START_VADDR;  ///< Offset: 0xB4 - ******* Description ***********
        volatile uint32_t IBUS_TO_FLASH_END_VADDR;  ///< Offset: 0xB8 - ******* Description ***********
        volatile uint32_t DBUS_TO_FLASH_START_VADDR;  ///< Offset: 0xBC - ******* Description ***********
        volatile uint32_t DBUS_TO_FLASH_END_VADDR;  ///< Offset: 0xC0 - ******* Description ***********
        volatile uint32_t CACHE_ACS_CNT_CLR;  ///< Offset: 0xC4 - ******* Description ***********
        volatile uint32_t IBUS_ACS_MISS_CNT;  ///< Offset: 0xC8 - ******* Description ***********
        volatile uint32_t IBUS_ACS_CNT;  ///< Offset: 0xCC - ******* Description ***********
        volatile uint32_t DBUS_ACS_FLASH_MISS_CNT;  ///< Offset: 0xD0 - ******* Description ***********
        volatile uint32_t DBUS_ACS_SPIRAM_MISS_CNT;  ///< Offset: 0xD4 - ******* Description ***********
        volatile uint32_t DBUS_ACS_CNT;  ///< Offset: 0xD8 - ******* Description ***********
        volatile uint32_t CACHE_ILG_INT_ENA;  ///< Offset: 0xDC - ******* Description ***********
        volatile uint32_t CACHE_ILG_INT_CLR;  ///< Offset: 0xE0 - ******* Description ***********
        volatile uint32_t CACHE_ILG_INT_ST;  ///< Offset: 0xE4 - ******* Description ***********
        volatile uint32_t CORE0_ACS_CACHE_INT_ENA;  ///< Offset: 0xE8 - ******* Description ***********
        volatile uint32_t CORE0_ACS_CACHE_INT_CLR;  ///< Offset: 0xEC - ******* Description ***********
        volatile uint32_t CORE0_ACS_CACHE_INT_ST;  ///< Offset: 0xF0 - ******* Description ***********
        volatile uint32_t CORE1_ACS_CACHE_INT_ENA;  ///< Offset: 0xF4 - ******* Description ***********
        volatile uint32_t CORE1_ACS_CACHE_INT_CLR;  ///< Offset: 0xF8 - ******* Description ***********
        volatile uint32_t CORE1_ACS_CACHE_INT_ST;  ///< Offset: 0xFC - ******* Description ***********
        volatile uint32_t CORE0_DBUS_REJECT_ST;  ///< Offset: 0x100 - ******* Description ***********
        volatile uint32_t CORE0_DBUS_REJECT_VADDR;  ///< Offset: 0x104 - ******* Description ***********
        volatile uint32_t CORE0_IBUS_REJECT_ST;  ///< Offset: 0x108 - ******* Description ***********
        volatile uint32_t CORE0_IBUS_REJECT_VADDR;  ///< Offset: 0x10C - ******* Description ***********
        volatile uint32_t CORE1_DBUS_REJECT_ST;  ///< Offset: 0x110 - ******* Description ***********
        volatile uint32_t CORE1_DBUS_REJECT_VADDR;  ///< Offset: 0x114 - ******* Description ***********
        volatile uint32_t CORE1_IBUS_REJECT_ST;  ///< Offset: 0x118 - ******* Description ***********
        volatile uint32_t CORE1_IBUS_REJECT_VADDR;  ///< Offset: 0x11C - ******* Description ***********
        volatile uint32_t CACHE_MMU_FAULT_CONTENT;  ///< Offset: 0x120 - ******* Description ***********
        volatile uint32_t CACHE_MMU_FAULT_VADDR;  ///< Offset: 0x124 - ******* Description ***********
        volatile uint32_t CACHE_WRAP_AROUND_CTRL;  ///< Offset: 0x128 - ******* Description ***********
        volatile uint32_t CACHE_MMU_POWER_CTRL;  ///< Offset: 0x12C - ******* Description ***********
        volatile uint32_t CACHE_STATE;  ///< Offset: 0x130 - ******* Description ***********
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE;  ///< Offset: 0x134 - ******* Description ***********
        volatile uint32_t CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON;  ///< Offset: 0x138 - ******* Description ***********
        volatile uint32_t CACHE_BRIDGE_ARBITER_CTRL;  ///< Offset: 0x13C - ******* Description ***********
        volatile uint32_t CACHE_PRELOAD_INT_CTRL;  ///< Offset: 0x140 - ******* Description ***********
        volatile uint32_t CACHE_SYNC_INT_CTRL;  ///< Offset: 0x144 - ******* Description ***********
        volatile uint32_t CACHE_MMU_OWNER;  ///< Offset: 0x148 - ******* Description ***********
        volatile uint32_t CACHE_CONF_MISC;  ///< Offset: 0x14C - ******* Description ***********
        volatile uint32_t DCACHE_FREEZE;  ///< Offset: 0x150 - ******* Description ***********
        volatile uint32_t ICACHE_FREEZE;  ///< Offset: 0x154 - ******* Description ***********
        volatile uint32_t ICACHE_ATOMIC_OPERATE_ENA;  ///< Offset: 0x158 - ******* Description ***********
        volatile uint32_t DCACHE_ATOMIC_OPERATE_ENA;  ///< Offset: 0x15C - ******* Description ***********
        volatile uint32_t CACHE_REQUEST;  ///< Offset: 0x160 - ******* Description ***********
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x164 - ******* Description ***********
        volatile uint32_t CACHE_TAG_OBJECT_CTRL;  ///< Offset: 0x180 - ******* Description ***********
        volatile uint32_t CACHE_TAG_WAY_OBJECT;  ///< Offset: 0x184 - ******* Description ***********
        volatile uint32_t CACHE_VADDR;  ///< Offset: 0x188 - ******* Description ***********
        volatile uint32_t CACHE_TAG_CONTENT;  ///< Offset: 0x18C - ******* Description ***********
        volatile uint32_t DATE;  ///< Offset: 0x3FC - ******* Description ***********
    };

    /// Peripheral instances
    inline Registers* EXTMEM = reinterpret_cast<Registers*>(EXTMEM_BASE);

    // Bit definitions
    /// DCACHE_CTRL Register bits
    namespace dcache_ctrl_bits {
        constexpr uint32_t DCACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
        constexpr uint32_t DCACHE_SIZE_MODE = (1U << 2);  ///< The bit is used to configure cache memory size.0: 32KB, 1: 64KB
        constexpr uint32_t DCACHE_BLOCKSIZE_MODE = (2 << 3);  ///< The bit is used to configure cache block size.0: 16 bytes, 1: 32 bytes,2: 64 bytes
    }

    /// DCACHE_CTRL1 Register bits
    namespace dcache_ctrl1_bits {
        constexpr uint32_t DCACHE_SHUT_CORE0_BUS = (1U << 0);  ///< The bit is used to disable core0 dbus, 0: enable, 1: disable
        constexpr uint32_t DCACHE_SHUT_CORE1_BUS = (1U << 1);  ///< The bit is used to disable core1 dbus, 0: enable, 1: disable
    }

    /// DCACHE_TAG_POWER_CTRL Register bits
    namespace dcache_tag_power_ctrl_bits {
        constexpr uint32_t DCACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of dcache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t DCACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power dcache tag memory down, 0: follow rtc_lslp_pd, 1: power down
        constexpr uint32_t DCACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power dcache tag memory up, 0: follow rtc_lslp_pd, 1: power up
    }

    /// DCACHE_PRELOCK_CTRL Register bits
    namespace dcache_prelock_ctrl_bits {
        constexpr uint32_t DCACHE_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function.
        constexpr uint32_t DCACHE_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function.
    }

    /// DCACHE_PRELOCK_SCT0_ADDR Register bits
    namespace dcache_prelock_sct0_addr_bits {
        constexpr uint32_t DCACHE_PRELOCK_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the first start virtual address of data prelock, which is combined with DCACHE_PRELOCK_SCT0_SIZE_REG
    }

    /// DCACHE_PRELOCK_SCT1_ADDR Register bits
    namespace dcache_prelock_sct1_addr_bits {
        constexpr uint32_t DCACHE_PRELOCK_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the second start virtual address of data prelock, which is combined with DCACHE_PRELOCK_SCT1_SIZE_REG
    }

    /// DCACHE_PRELOCK_SCT_SIZE Register bits
    namespace dcache_prelock_sct_size_bits {
        constexpr uint32_t DCACHE_PRELOCK_SCT1_SIZE = (16 << 0);  ///< The bits are used to configure the second length of data locking, which is combined with DCACHE_PRELOCK_SCT1_ADDR_REG
        constexpr uint32_t DCACHE_PRELOCK_SCT0_SIZE = (16 << 16);  ///< The bits are used to configure the first length of data locking, which is combined with DCACHE_PRELOCK_SCT0_ADDR_REG
    }

    /// DCACHE_LOCK_CTRL Register bits
    namespace dcache_lock_ctrl_bits {
        constexpr uint32_t DCACHE_LOCK_ENA = (1U << 0);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done.
        constexpr uint32_t DCACHE_UNLOCK_ENA = (1U << 1);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done.
        constexpr uint32_t DCACHE_LOCK_DONE = (1U << 2);  ///< The bit is used to indicate unlock/lock operation is finished.
    }

    /// DCACHE_LOCK_ADDR Register bits
    namespace dcache_lock_addr_bits {
        constexpr uint32_t DCACHE_LOCK_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for lock operations. It should be combined with DCACHE_LOCK_SIZE_REG.
    }

    /// DCACHE_LOCK_SIZE Register bits
    namespace dcache_lock_size_bits {
        constexpr uint32_t DCACHE_LOCK_SIZE = (16 << 0);  ///< The bits are used to configure the length for lock operations. The bits are the counts of cache block. It should be combined with DCACHE_LOCK_ADDR_REG.
    }

    /// DCACHE_SYNC_CTRL Register bits
    namespace dcache_sync_ctrl_bits {
        constexpr uint32_t DCACHE_INVALIDATE_ENA = (1U << 0);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t DCACHE_WRITEBACK_ENA = (1U << 1);  ///< The bit is used to enable writeback operation. It will be cleared by hardware after writeback operation done.
        constexpr uint32_t DCACHE_CLEAN_ENA = (1U << 2);  ///< The bit is used to enable clean operation. It will be cleared by hardware after clean operation done.
        constexpr uint32_t DCACHE_SYNC_DONE = (1U << 3);  ///< The bit is used to indicate clean/writeback/invalidate operation is finished.
    }

    /// DCACHE_SYNC_ADDR Register bits
    namespace dcache_sync_addr_bits {
        constexpr uint32_t DCACHE_SYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for clean operations. It should be combined with DCACHE_SYNC_SIZE_REG.
    }

    /// DCACHE_SYNC_SIZE Register bits
    namespace dcache_sync_size_bits {
        constexpr uint32_t DCACHE_SYNC_SIZE = (23 << 0);  ///< The bits are used to configure the length for sync operations. The bits are the counts of cache block. It should be combined with DCACHE_SYNC_ADDR_REG.
    }

    /// DCACHE_OCCUPY_CTRL Register bits
    namespace dcache_occupy_ctrl_bits {
        constexpr uint32_t DCACHE_OCCUPY_ENA = (1U << 0);  ///< The bit is used to enable occupy operation. It will be cleared by hardware after issuing Auot-Invalidate Operation.
        constexpr uint32_t DCACHE_OCCUPY_DONE = (1U << 1);  ///< The bit is used to indicate occupy operation is finished.
    }

    /// DCACHE_OCCUPY_ADDR Register bits
    namespace dcache_occupy_addr_bits {
        constexpr uint32_t DCACHE_OCCUPY_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for occupy operation. It should be combined with DCACHE_OCCUPY_SIZE_REG.
    }

    /// DCACHE_OCCUPY_SIZE Register bits
    namespace dcache_occupy_size_bits {
        constexpr uint32_t DCACHE_OCCUPY_SIZE = (16 << 0);  ///< The bits are used to configure the length for occupy operation. The bits are the counts of cache block. It should be combined with DCACHE_OCCUPY_ADDR_REG.
    }

    /// DCACHE_PRELOAD_CTRL Register bits
    namespace dcache_preload_ctrl_bits {
        constexpr uint32_t DCACHE_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation. It will be cleared by hardware after preload operation done.
        constexpr uint32_t DCACHE_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate preload operation is finished.
        constexpr uint32_t DCACHE_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 1: descending, 0: ascending.
    }

    /// DCACHE_PRELOAD_ADDR Register bits
    namespace dcache_preload_addr_bits {
        constexpr uint32_t DCACHE_PRELOAD_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for preload operation. It should be combined with DCACHE_PRELOAD_SIZE_REG.
    }

    /// DCACHE_PRELOAD_SIZE Register bits
    namespace dcache_preload_size_bits {
        constexpr uint32_t DCACHE_PRELOAD_SIZE = (16 << 0);  ///< The bits are used to configure the length for preload operation. The bits are the counts of cache block. It should be combined with DCACHE_PRELOAD_ADDR_REG..
    }

    /// DCACHE_AUTOLOAD_CTRL Register bits
    namespace dcache_autoload_ctrl_bits {
        constexpr uint32_t DCACHE_AUTOLOAD_SCT0_ENA = (1U << 0);  ///< The bits are used to enable the first section for autoload operation.
        constexpr uint32_t DCACHE_AUTOLOAD_SCT1_ENA = (1U << 1);  ///< The bits are used to enable the second section for autoload operation.
        constexpr uint32_t DCACHE_AUTOLOAD_ENA = (1U << 2);  ///< The bit is used to enable and disable autoload operation. It is combined with dcache_autoload_done. 1: enable, 0: disable.
        constexpr uint32_t DCACHE_AUTOLOAD_DONE = (1U << 3);  ///< The bit is used to indicate autoload operation is finished.
        constexpr uint32_t DCACHE_AUTOLOAD_ORDER = (1U << 4);  ///< The bits are used to configure the direction of autoload. 1: descending, 0: ascending.
        constexpr uint32_t DCACHE_AUTOLOAD_RQST = (2 << 5);  ///< The bits are used to configure trigger conditions for autoload. 0/3: cache miss, 1: cache hit, 2: both cache miss and hit.
        constexpr uint32_t DCACHE_AUTOLOAD_SIZE = (2 << 7);  ///< The bits are used to configure the numbers of the cache block for the issuing autoload operation.
        constexpr uint32_t DCACHE_AUTOLOAD_BUFFER_CLEAR = (1U << 9);  ///< The bit is used to clear autoload buffer in dcache.
    }

    /// DCACHE_AUTOLOAD_SCT0_ADDR Register bits
    namespace dcache_autoload_sct0_addr_bits {
        constexpr uint32_t DCACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the first section for autoload operation. It should be combined with dcache_autoload_sct0_ena.
    }

    /// DCACHE_AUTOLOAD_SCT0_SIZE Register bits
    namespace dcache_autoload_sct0_size_bits {
        constexpr uint32_t DCACHE_AUTOLOAD_SCT0_SIZE = (27 << 0);  ///< The bits are used to configure the length of the first section for autoload operation. It should be combined with dcache_autoload_sct0_ena.
    }

    /// DCACHE_AUTOLOAD_SCT1_ADDR Register bits
    namespace dcache_autoload_sct1_addr_bits {
        constexpr uint32_t DCACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the second section for autoload operation. It should be combined with dcache_autoload_sct1_ena.
    }

    /// DCACHE_AUTOLOAD_SCT1_SIZE Register bits
    namespace dcache_autoload_sct1_size_bits {
        constexpr uint32_t DCACHE_AUTOLOAD_SCT1_SIZE = (27 << 0);  ///< The bits are used to configure the length of the second section for autoload operation. It should be combined with dcache_autoload_sct1_ena.
    }

    /// ICACHE_CTRL Register bits
    namespace icache_ctrl_bits {
        constexpr uint32_t ICACHE_ENABLE = (1U << 0);  ///< The bit is used to activate the data cache. 0: disable, 1: enable
        constexpr uint32_t ICACHE_WAY_MODE = (1U << 1);  ///< The bit is used to configure cache way mode.0: 4-way, 1: 8-way
        constexpr uint32_t ICACHE_SIZE_MODE = (1U << 2);  ///< The bit is used to configure cache memory size.0: 16KB, 1: 32KB
        constexpr uint32_t ICACHE_BLOCKSIZE_MODE = (1U << 3);  ///< The bit is used to configure cache block size.0: 16 bytes, 1: 32 bytes
    }

    /// ICACHE_CTRL1 Register bits
    namespace icache_ctrl1_bits {
        constexpr uint32_t ICACHE_SHUT_CORE0_BUS = (1U << 0);  ///< The bit is used to disable core0 ibus, 0: enable, 1: disable
        constexpr uint32_t ICACHE_SHUT_CORE1_BUS = (1U << 1);  ///< The bit is used to disable core1 ibus, 0: enable, 1: disable
    }

    /// ICACHE_TAG_POWER_CTRL Register bits
    namespace icache_tag_power_ctrl_bits {
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to close clock gating of icache tag memory. 1: close gating, 0: open clock gating.
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power down
        constexpr uint32_t ICACHE_TAG_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power icache tag memory up, 0: follow rtc_lslp, 1: power up
    }

    /// ICACHE_PRELOCK_CTRL Register bits
    namespace icache_prelock_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT0_EN = (1U << 0);  ///< The bit is used to enable the first section of prelock function.
        constexpr uint32_t ICACHE_PRELOCK_SCT1_EN = (1U << 1);  ///< The bit is used to enable the second section of prelock function.
    }

    /// ICACHE_PRELOCK_SCT0_ADDR Register bits
    namespace icache_prelock_sct0_addr_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the first start virtual address of data prelock, which is combined with ICACHE_PRELOCK_SCT0_SIZE_REG
    }

    /// ICACHE_PRELOCK_SCT1_ADDR Register bits
    namespace icache_prelock_sct1_addr_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the second start virtual address of data prelock, which is combined with ICACHE_PRELOCK_SCT1_SIZE_REG
    }

    /// ICACHE_PRELOCK_SCT_SIZE Register bits
    namespace icache_prelock_sct_size_bits {
        constexpr uint32_t ICACHE_PRELOCK_SCT1_SIZE = (16 << 0);  ///< The bits are used to configure the second length of data locking, which is combined with ICACHE_PRELOCK_SCT1_ADDR_REG
        constexpr uint32_t ICACHE_PRELOCK_SCT0_SIZE = (16 << 16);  ///< The bits are used to configure the first length of data locking, which is combined with ICACHE_PRELOCK_SCT0_ADDR_REG
    }

    /// ICACHE_LOCK_CTRL Register bits
    namespace icache_lock_ctrl_bits {
        constexpr uint32_t ICACHE_LOCK_ENA = (1U << 0);  ///< The bit is used to enable lock operation. It will be cleared by hardware after lock operation done.
        constexpr uint32_t ICACHE_UNLOCK_ENA = (1U << 1);  ///< The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done.
        constexpr uint32_t ICACHE_LOCK_DONE = (1U << 2);  ///< The bit is used to indicate unlock/lock operation is finished.
    }

    /// ICACHE_LOCK_ADDR Register bits
    namespace icache_lock_addr_bits {
        constexpr uint32_t ICACHE_LOCK_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for lock operations. It should be combined with ICACHE_LOCK_SIZE_REG.
    }

    /// ICACHE_LOCK_SIZE Register bits
    namespace icache_lock_size_bits {
        constexpr uint32_t ICACHE_LOCK_SIZE = (16 << 0);  ///< The bits are used to configure the length for lock operations. The bits are the counts of cache block. It should be combined with ICACHE_LOCK_ADDR_REG.
    }

    /// ICACHE_SYNC_CTRL Register bits
    namespace icache_sync_ctrl_bits {
        constexpr uint32_t ICACHE_INVALIDATE_ENA = (1U << 0);  ///< The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done.
        constexpr uint32_t ICACHE_SYNC_DONE = (1U << 1);  ///< The bit is used to indicate invalidate operation is finished.
    }

    /// ICACHE_SYNC_ADDR Register bits
    namespace icache_sync_addr_bits {
        constexpr uint32_t ICACHE_SYNC_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for clean operations. It should be combined with ICACHE_SYNC_SIZE_REG.
    }

    /// ICACHE_SYNC_SIZE Register bits
    namespace icache_sync_size_bits {
        constexpr uint32_t ICACHE_SYNC_SIZE = (23 << 0);  ///< The bits are used to configure the length for sync operations. The bits are the counts of cache block. It should be combined with ICACHE_SYNC_ADDR_REG.
    }

    /// ICACHE_PRELOAD_CTRL Register bits
    namespace icache_preload_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOAD_ENA = (1U << 0);  ///< The bit is used to enable preload operation. It will be cleared by hardware after preload operation done.
        constexpr uint32_t ICACHE_PRELOAD_DONE = (1U << 1);  ///< The bit is used to indicate preload operation is finished.
        constexpr uint32_t ICACHE_PRELOAD_ORDER = (1U << 2);  ///< The bit is used to configure the direction of preload operation. 1: descending, 0: ascending.
    }

    /// ICACHE_PRELOAD_ADDR Register bits
    namespace icache_preload_addr_bits {
        constexpr uint32_t ICACHE_PRELOAD_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address for preload operation. It should be combined with ICACHE_PRELOAD_SIZE_REG.
    }

    /// ICACHE_PRELOAD_SIZE Register bits
    namespace icache_preload_size_bits {
        constexpr uint32_t ICACHE_PRELOAD_SIZE = (16 << 0);  ///< The bits are used to configure the length for preload operation. The bits are the counts of cache block. It should be combined with ICACHE_PRELOAD_ADDR_REG..
    }

    /// ICACHE_AUTOLOAD_CTRL Register bits
    namespace icache_autoload_ctrl_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_ENA = (1U << 0);  ///< The bits are used to enable the first section for autoload operation.
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_ENA = (1U << 1);  ///< The bits are used to enable the second section for autoload operation.
        constexpr uint32_t ICACHE_AUTOLOAD_ENA = (1U << 2);  ///< The bit is used to enable and disable autoload operation. It is combined with icache_autoload_done. 1: enable, 0: disable.
        constexpr uint32_t ICACHE_AUTOLOAD_DONE = (1U << 3);  ///< The bit is used to indicate autoload operation is finished.
        constexpr uint32_t ICACHE_AUTOLOAD_ORDER = (1U << 4);  ///< The bits are used to configure the direction of autoload. 1: descending, 0: ascending.
        constexpr uint32_t ICACHE_AUTOLOAD_RQST = (2 << 5);  ///< The bits are used to configure trigger conditions for autoload. 0/3: cache miss, 1: cache hit, 2: both cache miss and hit.
        constexpr uint32_t ICACHE_AUTOLOAD_SIZE = (2 << 7);  ///< The bits are used to configure the numbers of the cache block for the issuing autoload operation.
        constexpr uint32_t ICACHE_AUTOLOAD_BUFFER_CLEAR = (1U << 9);  ///< The bit is used to clear autoload buffer in icache.
    }

    /// ICACHE_AUTOLOAD_SCT0_ADDR Register bits
    namespace icache_autoload_sct0_addr_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the first section for autoload operation. It should be combined with icache_autoload_sct0_ena.
    }

    /// ICACHE_AUTOLOAD_SCT0_SIZE Register bits
    namespace icache_autoload_sct0_size_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT0_SIZE = (27 << 0);  ///< The bits are used to configure the length of the first section for autoload operation. It should be combined with icache_autoload_sct0_ena.
    }

    /// ICACHE_AUTOLOAD_SCT1_ADDR Register bits
    namespace icache_autoload_sct1_addr_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_ADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of the second section for autoload operation. It should be combined with icache_autoload_sct1_ena.
    }

    /// ICACHE_AUTOLOAD_SCT1_SIZE Register bits
    namespace icache_autoload_sct1_size_bits {
        constexpr uint32_t ICACHE_AUTOLOAD_SCT1_SIZE = (27 << 0);  ///< The bits are used to configure the length of the second section for autoload operation. It should be combined with icache_autoload_sct1_ena.
    }

    /// IBUS_TO_FLASH_START_VADDR Register bits
    namespace ibus_to_flash_start_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// IBUS_TO_FLASH_END_VADDR Register bits
    namespace ibus_to_flash_end_vaddr_bits {
        constexpr uint32_t IBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of ibus to access flash. The register is used to give constraints to ibus access counter.
    }

    /// DBUS_TO_FLASH_START_VADDR Register bits
    namespace dbus_to_flash_start_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_START_VADDR = (32 << 0);  ///< The bits are used to configure the start virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// DBUS_TO_FLASH_END_VADDR Register bits
    namespace dbus_to_flash_end_vaddr_bits {
        constexpr uint32_t DBUS_TO_FLASH_END_VADDR = (32 << 0);  ///< The bits are used to configure the end virtual address of dbus to access flash. The register is used to give constraints to dbus access counter.
    }

    /// CACHE_ACS_CNT_CLR Register bits
    namespace cache_acs_cnt_clr_bits {
        constexpr uint32_t DCACHE_ACS_CNT_CLR = (1U << 0);  ///< The bit is used to clear dcache counter.
        constexpr uint32_t ICACHE_ACS_CNT_CLR = (1U << 1);  ///< The bit is used to clear icache counter.
    }

    /// IBUS_ACS_MISS_CNT Register bits
    namespace ibus_acs_miss_cnt_bits {
        constexpr uint32_t IBUS_ACS_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by ibus access flash/spiram.
    }

    /// IBUS_ACS_CNT Register bits
    namespace ibus_acs_cnt_bits {
        constexpr uint32_t IBUS_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of ibus access flash/spiram through icache.
    }

    /// DBUS_ACS_FLASH_MISS_CNT Register bits
    namespace dbus_acs_flash_miss_cnt_bits {
        constexpr uint32_t DBUS_ACS_FLASH_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus access flash.
    }

    /// DBUS_ACS_SPIRAM_MISS_CNT Register bits
    namespace dbus_acs_spiram_miss_cnt_bits {
        constexpr uint32_t DBUS_ACS_SPIRAM_MISS_CNT = (32 << 0);  ///< The bits are used to count the number of the cache miss caused by dbus access spiram.
    }

    /// DBUS_ACS_CNT Register bits
    namespace dbus_acs_cnt_bits {
        constexpr uint32_t DBUS_ACS_CNT = (32 << 0);  ///< The bits are used to count the number of dbus access flash/spiram through dcache.
    }

    /// CACHE_ILG_INT_ENA Register bits
    namespace cache_ilg_int_ena_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_SYNC_OP_FAULT_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by sync configurations fault.
        constexpr uint32_t DCACHE_PRELOAD_OP_FAULT_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by dcache trying to write flash.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_ENA = (1U << 5);  ///< The bit is used to enable interrupt by mmu entry fault.
        constexpr uint32_t DCACHE_OCCUPY_EXC_INT_ENA = (1U << 6);  ///< The bit is used to enable interrupt by dcache trying to replace a line whose blocks all have been occupied by occupy-mode.
        constexpr uint32_t IBUS_CNT_OVF_INT_ENA = (1U << 7);  ///< The bit is used to enable interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_ENA = (1U << 8);  ///< The bit is used to enable interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_CLR Register bits
    namespace cache_ilg_int_clr_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_SYNC_OP_FAULT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by sync configurations fault.
        constexpr uint32_t DCACHE_PRELOAD_OP_FAULT_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by dcache trying to write flash.
        constexpr uint32_t MMU_ENTRY_FAULT_INT_CLR = (1U << 5);  ///< The bit is used to clear interrupt by mmu entry fault.
        constexpr uint32_t DCACHE_OCCUPY_EXC_INT_CLR = (1U << 6);  ///< The bit is used to clear interrupt by dcache trying to replace a line whose blocks all have been occupied by occupy-mode.
        constexpr uint32_t IBUS_CNT_OVF_INT_CLR = (1U << 7);  ///< The bit is used to clear interrupt by ibus counter overflow.
        constexpr uint32_t DBUS_CNT_OVF_INT_CLR = (1U << 8);  ///< The bit is used to clear interrupt by dbus counter overflow.
    }

    /// CACHE_ILG_INT_ST Register bits
    namespace cache_ilg_int_st_bits {
        constexpr uint32_t ICACHE_SYNC_OP_FAULT_ST = (1U << 0);  ///< The bit is used to indicate interrupt by sync configurations fault.
        constexpr uint32_t ICACHE_PRELOAD_OP_FAULT_ST = (1U << 1);  ///< The bit is used to indicate interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_SYNC_OP_FAULT_ST = (1U << 2);  ///< The bit is used to indicate interrupt by sync configurations fault.
        constexpr uint32_t DCACHE_PRELOAD_OP_FAULT_ST = (1U << 3);  ///< The bit is used to indicate interrupt by preload configurations fault.
        constexpr uint32_t DCACHE_WRITE_FLASH_ST = (1U << 4);  ///< The bit is used to indicate interrupt by dcache trying to write flash.
        constexpr uint32_t MMU_ENTRY_FAULT_ST = (1U << 5);  ///< The bit is used to indicate interrupt by mmu entry fault.
        constexpr uint32_t DCACHE_OCCUPY_EXC_ST = (1U << 6);  ///< The bit is used to indicate interrupt by dcache trying to replace a line whose blocks all have been occupied by occupy-mode.
        constexpr uint32_t IBUS_ACS_CNT_OVF_ST = (1U << 7);  ///< The bit is used to indicate interrupt by ibus access flash/spiram counter overflow.
        constexpr uint32_t IBUS_ACS_MISS_CNT_OVF_ST = (1U << 8);  ///< The bit is used to indicate interrupt by ibus access flash/spiram miss counter overflow.
        constexpr uint32_t DBUS_ACS_CNT_OVF_ST = (1U << 9);  ///< The bit is used to indicate interrupt by dbus access flash/spiram counter overflow.
        constexpr uint32_t DBUS_ACS_FLASH_MISS_CNT_OVF_ST = (1U << 10);  ///< The bit is used to indicate interrupt by dbus access flash miss counter overflow.
        constexpr uint32_t DBUS_ACS_SPIRAM_MISS_CNT_OVF_ST = (1U << 11);  ///< The bit is used to indicate interrupt by dbus access spiram miss counter overflow.
    }

    /// CORE0_ACS_CACHE_INT_ENA Register bits
    namespace core0_acs_cache_int_ena_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding ibus is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_DC_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by cpu access dcache while the corresponding dbus is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by authentication fail.
    }

    /// CORE0_ACS_CACHE_INT_CLR Register bits
    namespace core0_acs_cache_int_clr_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_IC_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_IC_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_DC_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by cpu access dcache while the corresponding dbus is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by authentication fail.
    }

    /// CORE0_ACS_CACHE_INT_ST Register bits
    namespace core0_acs_cache_int_st_bits {
        constexpr uint32_t CORE0_IBUS_ACS_MSK_ICACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access icache while the core0_ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE0_IBUS_WR_ICACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by ibus trying to write icache
        constexpr uint32_t CORE0_IBUS_REJECT_ST = (1U << 2);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE0_DBUS_ACS_MSK_DCACHE_ST = (1U << 3);  ///< The bit is used to indicate interrupt by cpu access dcache while the core0_dbus is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t CORE0_DBUS_REJECT_ST = (1U << 4);  ///< The bit is used to indicate interrupt by authentication fail.
    }

    /// CORE1_ACS_CACHE_INT_ENA Register bits
    namespace core1_acs_cache_int_ena_bits {
        constexpr uint32_t CORE1_IBUS_ACS_MSK_IC_INT_ENA = (1U << 0);  ///< The bit is used to enable interrupt by cpu access icache while the corresponding ibus is disabled which include speculative access.
        constexpr uint32_t CORE1_IBUS_WR_IC_INT_ENA = (1U << 1);  ///< The bit is used to enable interrupt by ibus trying to write icache
        constexpr uint32_t CORE1_IBUS_REJECT_INT_ENA = (1U << 2);  ///< The bit is used to enable interrupt by authentication fail.
        constexpr uint32_t CORE1_DBUS_ACS_MSK_DC_INT_ENA = (1U << 3);  ///< The bit is used to enable interrupt by cpu access dcache while the corresponding dbus is disabled which include speculative access.
        constexpr uint32_t CORE1_DBUS_REJECT_INT_ENA = (1U << 4);  ///< The bit is used to enable interrupt by authentication fail.
    }

    /// CORE1_ACS_CACHE_INT_CLR Register bits
    namespace core1_acs_cache_int_clr_bits {
        constexpr uint32_t CORE1_IBUS_ACS_MSK_IC_INT_CLR = (1U << 0);  ///< The bit is used to clear interrupt by cpu access icache while the corresponding ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE1_IBUS_WR_IC_INT_CLR = (1U << 1);  ///< The bit is used to clear interrupt by ibus trying to write icache
        constexpr uint32_t CORE1_IBUS_REJECT_INT_CLR = (1U << 2);  ///< The bit is used to clear interrupt by authentication fail.
        constexpr uint32_t CORE1_DBUS_ACS_MSK_DC_INT_CLR = (1U << 3);  ///< The bit is used to clear interrupt by cpu access dcache while the corresponding dbus is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t CORE1_DBUS_REJECT_INT_CLR = (1U << 4);  ///< The bit is used to clear interrupt by authentication fail.
    }

    /// CORE1_ACS_CACHE_INT_ST Register bits
    namespace core1_acs_cache_int_st_bits {
        constexpr uint32_t CORE1_IBUS_ACS_MSK_ICACHE_ST = (1U << 0);  ///< The bit is used to indicate interrupt by cpu access icache while the core1_ibus is disabled or icache is disabled which include speculative access.
        constexpr uint32_t CORE1_IBUS_WR_ICACHE_ST = (1U << 1);  ///< The bit is used to indicate interrupt by ibus trying to write icache
        constexpr uint32_t CORE1_IBUS_REJECT_ST = (1U << 2);  ///< The bit is used to indicate interrupt by authentication fail.
        constexpr uint32_t CORE1_DBUS_ACS_MSK_DCACHE_ST = (1U << 3);  ///< The bit is used to indicate interrupt by cpu access dcache while the core1_dbus is disabled or dcache is disabled which include speculative access.
        constexpr uint32_t CORE1_DBUS_REJECT_ST = (1U << 4);  ///< The bit is used to indicate interrupt by authentication fail.
    }

    /// CORE0_DBUS_REJECT_ST Register bits
    namespace core0_dbus_reject_st_bits {
        constexpr uint32_t CORE0_DBUS_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE0_DBUS_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access dbus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE0_DBUS_WORLD = (1U << 6);  ///< The bit is used to indicate the world of CPU access dbus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_DBUS_REJECT_VADDR Register bits
    namespace core0_dbus_reject_vaddr_bits {
        constexpr uint32_t CORE0_DBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access dbus when authentication fail.
    }

    /// CORE0_IBUS_REJECT_ST Register bits
    namespace core0_ibus_reject_st_bits {
        constexpr uint32_t CORE0_IBUS_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE0_IBUS_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access ibus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able
        constexpr uint32_t CORE0_IBUS_WORLD = (1U << 6);  ///< The bit is used to indicate the world of CPU access ibus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE0_IBUS_REJECT_VADDR Register bits
    namespace core0_ibus_reject_vaddr_bits {
        constexpr uint32_t CORE0_IBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access ibus when authentication fail.
    }

    /// CORE1_DBUS_REJECT_ST Register bits
    namespace core1_dbus_reject_st_bits {
        constexpr uint32_t CORE1_DBUS_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE1_DBUS_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access dbus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE1_DBUS_WORLD = (1U << 6);  ///< The bit is used to indicate the world of CPU access dbus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE1_DBUS_REJECT_VADDR Register bits
    namespace core1_dbus_reject_vaddr_bits {
        constexpr uint32_t CORE1_DBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access dbus when authentication fail.
    }

    /// CORE1_IBUS_REJECT_ST Register bits
    namespace core1_ibus_reject_st_bits {
        constexpr uint32_t CORE1_IBUS_TAG_ATTR = (3 << 0);  ///< The bits are used to indicate the attribute of data from external memory when authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4: write-able.
        constexpr uint32_t CORE1_IBUS_ATTR = (3 << 3);  ///< The bits are used to indicate the attribute of CPU access ibus when authentication fail. 0: invalidate, 1: execute-able, 2: read-able
        constexpr uint32_t CORE1_IBUS_WORLD = (1U << 6);  ///< The bit is used to indicate the world of CPU access ibus when authentication fail. 0: WORLD0, 1: WORLD1
    }

    /// CORE1_IBUS_REJECT_VADDR Register bits
    namespace core1_ibus_reject_vaddr_bits {
        constexpr uint32_t CORE1_IBUS_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address of CPU access ibus when authentication fail.
    }

    /// CACHE_MMU_FAULT_CONTENT Register bits
    namespace cache_mmu_fault_content_bits {
        constexpr uint32_t CACHE_MMU_FAULT_CONTENT = (16 << 0);  ///< The bits are used to indicate the content of mmu entry which cause mmu fault..
        constexpr uint32_t CACHE_MMU_FAULT_CODE = (4 << 16);  ///< The right-most 3 bits are used to indicate the operations which cause mmu fault occurrence. 0: default, 1: cpu miss, 2: preload miss, 3: writeback, 4: cpu miss evict recovery address, 5: load miss evict recovery address, 6: external dma tx, 7: external dma rx. The most significant bit is used to indicate this operation occurs in which one icache.
    }

    /// CACHE_MMU_FAULT_VADDR Register bits
    namespace cache_mmu_fault_vaddr_bits {
        constexpr uint32_t CACHE_MMU_FAULT_VADDR = (32 << 0);  ///< The bits are used to indicate the virtual address which cause mmu fault..
    }

    /// CACHE_WRAP_AROUND_CTRL Register bits
    namespace cache_wrap_around_ctrl_bits {
        constexpr uint32_t CACHE_FLASH_WRAP_AROUND = (1U << 0);  ///< The bit is used to enable wrap around mode when read data from flash.
        constexpr uint32_t CACHE_SRAM_RD_WRAP_AROUND = (1U << 1);  ///< The bit is used to enable wrap around mode when read data from spiram.
    }

    /// CACHE_MMU_POWER_CTRL Register bits
    namespace cache_mmu_power_ctrl_bits {
        constexpr uint32_t CACHE_MMU_MEM_FORCE_ON = (1U << 0);  ///< The bit is used to enable clock gating to save power when access mmu memory, 0: enable, 1: disable
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PD = (1U << 1);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power down
        constexpr uint32_t CACHE_MMU_MEM_FORCE_PU = (1U << 2);  ///< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power up
    }

    /// CACHE_STATE Register bits
    namespace cache_state_bits {
        constexpr uint32_t ICACHE_STATE = (12 << 0);  ///< The bit is used to indicate whether icache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
        constexpr uint32_t DCACHE_STATE = (12 << 12);  ///< The bit is used to indicate whether dcache main fsm is in idle state or not. 1: in idle state, 0: not in idle state
    }

    /// CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE Register bits
    namespace cache_encrypt_decrypt_record_disable_bits {
        constexpr uint32_t RECORD_DISABLE_DB_ENCRYPT = (1U << 0);  ///< Reserved
        constexpr uint32_t RECORD_DISABLE_G0CB_DECRYPT = (1U << 1);  ///< Reserved
    }

    /// CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON Register bits
    namespace cache_encrypt_decrypt_clk_force_on_bits {
        constexpr uint32_t CLK_FORCE_ON_MANUAL_CRYPT = (1U << 0);  ///< The bit is used to close clock gating of manual crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_AUTO_CRYPT = (1U << 1);  ///< The bit is used to close clock gating of automatic crypt clock. 1: close gating, 0: open clock gating.
        constexpr uint32_t CLK_FORCE_ON_CRYPT = (1U << 2);  ///< The bit is used to close clock gating of external memory encrypt and decrypt clock. 1: close gating, 0: open clock gating.
    }

    /// CACHE_BRIDGE_ARBITER_CTRL Register bits
    namespace cache_bridge_arbiter_ctrl_bits {
        constexpr uint32_t ALLOC_WB_HOLD_ARBITER = (1U << 0);  ///< Reserved
    }

    /// CACHE_PRELOAD_INT_CTRL Register bits
    namespace cache_preload_int_ctrl_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache pre-load done.
        constexpr uint32_t ICACHE_PRELOAD_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache pre-load done.
        constexpr uint32_t DCACHE_PRELOAD_INT_ST = (1U << 3);  ///< The bit is used to indicate the interrupt by dcache pre-load done.
        constexpr uint32_t DCACHE_PRELOAD_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt by dcache pre-load done.
        constexpr uint32_t DCACHE_PRELOAD_INT_CLR = (1U << 5);  ///< The bit is used to clear the interrupt by dcache pre-load done.
    }

    /// CACHE_SYNC_INT_CTRL Register bits
    namespace cache_sync_int_ctrl_bits {
        constexpr uint32_t ICACHE_SYNC_INT_ST = (1U << 0);  ///< The bit is used to indicate the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_ENA = (1U << 1);  ///< The bit is used to enable the interrupt by icache sync done.
        constexpr uint32_t ICACHE_SYNC_INT_CLR = (1U << 2);  ///< The bit is used to clear the interrupt by icache sync done.
        constexpr uint32_t DCACHE_SYNC_INT_ST = (1U << 3);  ///< The bit is used to indicate the interrupt by dcache sync done.
        constexpr uint32_t DCACHE_SYNC_INT_ENA = (1U << 4);  ///< The bit is used to enable the interrupt by dcache sync done.
        constexpr uint32_t DCACHE_SYNC_INT_CLR = (1U << 5);  ///< The bit is used to clear the interrupt by dcache sync done.
    }

    /// CACHE_MMU_OWNER Register bits
    namespace cache_mmu_owner_bits {
        constexpr uint32_t CACHE_MMU_OWNER = (24 << 0);  ///< The bits are used to specify the owner of MMU.bit0: icache, bit1: dcache, bit2: dma, bit3: reserved.
    }

    /// CACHE_CONF_MISC Register bits
    namespace cache_conf_misc_bits {
        constexpr uint32_t CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT = (1U << 0);  ///< The bit is used to disable checking mmu entry fault by preload operation.
        constexpr uint32_t CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT = (1U << 1);  ///< The bit is used to disable checking mmu entry fault by sync operation.
        constexpr uint32_t CACHE_TRACE_ENA = (1U << 2);  ///< The bit is used to enable cache trace function.
    }

    /// DCACHE_FREEZE Register bits
    namespace dcache_freeze_bits {
        constexpr uint32_t ENA = (1U << 0);  ///< The bit is used to enable dcache freeze mode
        constexpr uint32_t MODE = (1U << 1);  ///< The bit is used to configure freeze mode, 0: assert busy if CPU miss 1: assert hit if CPU miss
        constexpr uint32_t DONE = (1U << 2);  ///< The bit is used to indicate dcache freeze success
    }

    /// ICACHE_FREEZE Register bits
    namespace icache_freeze_bits {
        constexpr uint32_t ENA = (1U << 0);  ///< The bit is used to enable icache freeze mode
        constexpr uint32_t MODE = (1U << 1);  ///< The bit is used to configure freeze mode, 0: assert busy if CPU miss 1: assert hit if CPU miss
        constexpr uint32_t DONE = (1U << 2);  ///< The bit is used to indicate icache freeze success
    }

    /// ICACHE_ATOMIC_OPERATE_ENA Register bits
    namespace icache_atomic_operate_ena_bits {
        constexpr uint32_t ICACHE_ATOMIC_OPERATE_ENA = (1U << 0);  ///< The bit is used to activate icache atomic operation protection. In this case, sync/lock operation can not interrupt miss-work. This feature does not work during invalidateAll operation.
    }

    /// DCACHE_ATOMIC_OPERATE_ENA Register bits
    namespace dcache_atomic_operate_ena_bits {
        constexpr uint32_t DCACHE_ATOMIC_OPERATE_ENA = (1U << 0);  ///< The bit is used to activate dcache atomic operation protection. In this case, sync/lock/occupy operation can not interrupt miss-work. This feature does not work during invalidateAll operation.
    }

    /// CACHE_REQUEST Register bits
    namespace cache_request_bits {
        constexpr uint32_t BYPASS = (1U << 0);  ///< The bit is used to disable request recording which could cause performance issue
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Reserved
    }

    /// CACHE_TAG_OBJECT_CTRL Register bits
    namespace cache_tag_object_ctrl_bits {
        constexpr uint32_t ICACHE_TAG_OBJECT = (1U << 0);  ///< Set this bit to set icache tag memory as object. This bit should be onehot with the others fields inside this register.
        constexpr uint32_t DCACHE_TAG_OBJECT = (1U << 1);  ///< Set this bit to set dcache tag memory as object. This bit should be onehot with the others fields inside this register.
    }

    /// CACHE_TAG_WAY_OBJECT Register bits
    namespace cache_tag_way_object_bits {
        constexpr uint32_t CACHE_TAG_WAY_OBJECT = (3 << 0);  ///< Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, .., 7: way7.
    }

    /// CACHE_VADDR Register bits
    namespace cache_vaddr_bits {
        constexpr uint32_t CACHE_VADDR = (32 << 0);  ///< Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
    }

    /// CACHE_TAG_CONTENT Register bits
    namespace cache_tag_content_bits {
        constexpr uint32_t CACHE_TAG_CONTENT = (32 << 0);  ///< This is a constant place where we can write data to or read data from the tag memory on the specified cache.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version information.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIO_BASE = 0x60004000;
    constexpr uint32_t GPIO_SD_BASE = 0x60004F00;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t BT_SELECT;  ///< Offset: 0x00 - GPIO bit select register
        volatile uint32_t OUT;  ///< Offset: 0x04 - GPIO output register for GPIO0-31
        volatile uint32_t OUT_W1TS;  ///< Offset: 0x08 - GPIO output set register for GPIO0-31
        volatile uint32_t OUT_W1TC;  ///< Offset: 0x0C - GPIO output clear register for GPIO0-31
        volatile uint32_t OUT1;  ///< Offset: 0x10 - GPIO output register for GPIO32-53
        volatile uint32_t OUT1_W1TS;  ///< Offset: 0x14 - GPIO output set register for GPIO32-53
        volatile uint32_t OUT1_W1TC;  ///< Offset: 0x18 - GPIO output clear register for GPIO32-53
        volatile uint32_t SDIO_SELECT;  ///< Offset: 0x1C - GPIO sdio select register
        volatile uint32_t ENABLE;  ///< Offset: 0x20 - GPIO output enable register for GPIO0-31
        volatile uint32_t ENABLE_W1TS;  ///< Offset: 0x24 - GPIO output enable set register for GPIO0-31
        volatile uint32_t ENABLE_W1TC;  ///< Offset: 0x28 - GPIO output enable clear register for GPIO0-31
        volatile uint32_t ENABLE1;  ///< Offset: 0x2C - GPIO output enable register for GPIO32-53
        volatile uint32_t ENABLE1_W1TS;  ///< Offset: 0x30 - GPIO output enable set register for GPIO32-53
        volatile uint32_t ENABLE1_W1TC;  ///< Offset: 0x34 - GPIO output enable clear register for GPIO32-53
        volatile uint32_t STRAP;  ///< Offset: 0x38 - pad strapping register
        volatile uint32_t IN;  ///< Offset: 0x3C - GPIO input register for GPIO0-31
        volatile uint32_t IN1;  ///< Offset: 0x40 - GPIO input register for GPIO32-53
        volatile uint32_t STATUS;  ///< Offset: 0x44 - GPIO interrupt status register for GPIO0-31
        volatile uint32_t STATUS_W1TS;  ///< Offset: 0x48 - GPIO interrupt status set register for GPIO0-31
        volatile uint32_t STATUS_W1TC;  ///< Offset: 0x4C - GPIO interrupt status clear register for GPIO0-31
        volatile uint32_t STATUS1;  ///< Offset: 0x50 - GPIO interrupt status register for GPIO32-53
        volatile uint32_t STATUS1_W1TS;  ///< Offset: 0x54 - GPIO interrupt status set register for GPIO32-53
        volatile uint32_t STATUS1_W1TC;  ///< Offset: 0x58 - GPIO interrupt status clear register for GPIO32-53
        volatile uint32_t PCPU_INT;  ///< Offset: 0x5C - GPIO PRO_CPU interrupt status register for GPIO0-31
        volatile uint32_t PCPU_NMI_INT;  ///< Offset: 0x60 - GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
        volatile uint32_t CPUSDIO_INT;  ///< Offset: 0x64 - GPIO CPUSDIO interrupt status register for GPIO0-31
        volatile uint32_t PCPU_INT1;  ///< Offset: 0x68 - GPIO PRO_CPU interrupt status register for GPIO32-53
        volatile uint32_t PCPU_NMI_INT1;  ///< Offset: 0x6C - GPIO PRO_CPU(not shielded) interrupt status register for...
        volatile uint32_t CPUSDIO_INT1;  ///< Offset: 0x70 - GPIO CPUSDIO interrupt status register for GPIO32-53
        volatile uint32_t PIN;  ///< Offset: 0x74 - GPIO pin configuration register (renamed from PIN)
        volatile uint32_t STATUS_NEXT;  ///< Offset: 0x14C - GPIO interrupt source register for GPIO0-31
        volatile uint32_t STATUS_NEXT1;  ///< Offset: 0x150 - GPIO interrupt source register for GPIO32-53
        volatile uint32_t FUNC_IN_SEL_CFG;  ///< Offset: 0x154 - GPIO input function configuration register (renamed from FUNC_IN_SEL_CFG)
        volatile uint32_t FUNC_OUT_SEL_CFG;  ///< Offset: 0x554 - GPIO output function select register (renamed from FUNC_OUT_SEL_CFG)
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x62C - GPIO clock gate register
        volatile uint32_t REG_DATE;  ///< Offset: 0x6FC - GPIO version register
    };

    /// Peripheral instances
    inline Registers* GPIO = reinterpret_cast<Registers*>(GPIO_BASE);
    inline Registers* GPIO_SD = reinterpret_cast<Registers*>(GPIO_SD_BASE);

    // Bit definitions
    /// BT_SELECT Register bits
    namespace bt_select_bits {
        constexpr uint32_t BT_SEL = (32 << 0);  ///< GPIO bit select register
    }

    /// OUT Register bits
    namespace out_bits {
        constexpr uint32_t DATA_ORIG = (32 << 0);  ///< GPIO output register for GPIO0-31
    }

    /// OUT_W1TS Register bits
    namespace out_w1ts_bits {
        constexpr uint32_t OUT_W1TS = (32 << 0);  ///< GPIO output set register for GPIO0-31
    }

    /// OUT_W1TC Register bits
    namespace out_w1tc_bits {
        constexpr uint32_t OUT_W1TC = (32 << 0);  ///< GPIO output clear register for GPIO0-31
    }

    /// OUT1 Register bits
    namespace out1_bits {
        constexpr uint32_t DATA_ORIG = (22 << 0);  ///< GPIO output register for GPIO32-53
    }

    /// OUT1_W1TS Register bits
    namespace out1_w1ts_bits {
        constexpr uint32_t OUT1_W1TS = (22 << 0);  ///< GPIO output set register for GPIO32-53
    }

    /// OUT1_W1TC Register bits
    namespace out1_w1tc_bits {
        constexpr uint32_t OUT1_W1TC = (22 << 0);  ///< GPIO output clear register for GPIO32-53
    }

    /// SDIO_SELECT Register bits
    namespace sdio_select_bits {
        constexpr uint32_t SDIO_SEL = (8 << 0);  ///< GPIO sdio select register
    }

    /// ENABLE Register bits
    namespace enable_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< GPIO output enable register for GPIO0-31
    }

    /// ENABLE_W1TS Register bits
    namespace enable_w1ts_bits {
        constexpr uint32_t ENABLE_W1TS = (32 << 0);  ///< GPIO output enable set register for GPIO0-31
    }

    /// ENABLE_W1TC Register bits
    namespace enable_w1tc_bits {
        constexpr uint32_t ENABLE_W1TC = (32 << 0);  ///< GPIO output enable clear register for GPIO0-31
    }

    /// ENABLE1 Register bits
    namespace enable1_bits {
        constexpr uint32_t DATA = (22 << 0);  ///< GPIO output enable register for GPIO32-53
    }

    /// ENABLE1_W1TS Register bits
    namespace enable1_w1ts_bits {
        constexpr uint32_t ENABLE1_W1TS = (22 << 0);  ///< GPIO output enable set register for GPIO32-53
    }

    /// ENABLE1_W1TC Register bits
    namespace enable1_w1tc_bits {
        constexpr uint32_t ENABLE1_W1TC = (22 << 0);  ///< GPIO output enable clear register for GPIO32-53
    }

    /// STRAP Register bits
    namespace strap_bits {
        constexpr uint32_t STRAPPING = (16 << 0);  ///< pad strapping register
    }

    /// IN Register bits
    namespace in_bits {
        constexpr uint32_t DATA_NEXT = (32 << 0);  ///< GPIO input register for GPIO0-31
    }

    /// IN1 Register bits
    namespace in1_bits {
        constexpr uint32_t DATA_NEXT = (22 << 0);  ///< GPIO input register for GPIO32-53
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t INTERRUPT = (32 << 0);  ///< GPIO interrupt status register for GPIO0-31
    }

    /// STATUS_W1TS Register bits
    namespace status_w1ts_bits {
        constexpr uint32_t STATUS_W1TS = (32 << 0);  ///< GPIO interrupt status set register for GPIO0-31
    }

    /// STATUS_W1TC Register bits
    namespace status_w1tc_bits {
        constexpr uint32_t STATUS_W1TC = (32 << 0);  ///< GPIO interrupt status clear register for GPIO0-31
    }

    /// STATUS1 Register bits
    namespace status1_bits {
        constexpr uint32_t INTERRUPT = (22 << 0);  ///< GPIO interrupt status register for GPIO32-53
    }

    /// STATUS1_W1TS Register bits
    namespace status1_w1ts_bits {
        constexpr uint32_t STATUS1_W1TS = (22 << 0);  ///< GPIO interrupt status set register for GPIO32-53
    }

    /// STATUS1_W1TC Register bits
    namespace status1_w1tc_bits {
        constexpr uint32_t STATUS1_W1TC = (22 << 0);  ///< GPIO interrupt status clear register for GPIO32-53
    }

    /// PCPU_INT Register bits
    namespace pcpu_int_bits {
        constexpr uint32_t PROCPU_INT = (32 << 0);  ///< GPIO PRO_CPU interrupt status register for GPIO0-31
    }

    /// PCPU_NMI_INT Register bits
    namespace pcpu_nmi_int_bits {
        constexpr uint32_t PROCPU_NMI_INT = (32 << 0);  ///< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
    }

    /// CPUSDIO_INT Register bits
    namespace cpusdio_int_bits {
        constexpr uint32_t SDIO_INT = (32 << 0);  ///< GPIO CPUSDIO interrupt status register for GPIO0-31
    }

    /// PCPU_INT1 Register bits
    namespace pcpu_int1_bits {
        constexpr uint32_t PROCPU_INT1 = (22 << 0);  ///< GPIO PRO_CPU interrupt status register for GPIO32-53
    }

    /// PCPU_NMI_INT1 Register bits
    namespace pcpu_nmi_int1_bits {
        constexpr uint32_t PROCPU_NMI_INT1 = (22 << 0);  ///< GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-53
    }

    /// CPUSDIO_INT1 Register bits
    namespace cpusdio_int1_bits {
        constexpr uint32_t SDIO_INT1 = (22 << 0);  ///< GPIO CPUSDIO interrupt status register for GPIO32-53
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t SYNC2_BYPASS = (2 << 0);  ///< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t PAD_DRIVER = (1U << 2);  ///< set this bit to select pad driver. 1:open-drain. 0:normal.
        constexpr uint32_t SYNC1_BYPASS = (2 << 3);  ///< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
        constexpr uint32_t INT_TYPE = (3 << 7);  ///< set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
        constexpr uint32_t WAKEUP_ENABLE = (1U << 10);  ///< set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
        constexpr uint32_t CONFIG = (2 << 11);  ///< reserved
        constexpr uint32_t INT_ENA = (5 << 13);  ///< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
    }

    /// STATUS_NEXT Register bits
    namespace status_next_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT = (32 << 0);  ///< GPIO interrupt source register for GPIO0-31
    }

    /// STATUS_NEXT1 Register bits
    namespace status_next1_bits {
        constexpr uint32_t STATUS_INTERRUPT_NEXT1 = (22 << 0);  ///< GPIO interrupt source register for GPIO32-53
    }

    /// FUNC_IN_SEL_CFG Register bits
    namespace func_in_sel_cfg_bits {
        constexpr uint32_t IN_SEL = (6 << 0);  ///< set this value: s=0-53: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
        constexpr uint32_t IN_INV_SEL = (1U << 6);  ///< set this bit to invert input signal. 1:invert. 0:not invert.
        constexpr uint32_t SEL = (1U << 7);  ///< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
    }

    /// FUNC_OUT_SEL_CFG Register bits
    namespace func_out_sel_cfg_bits {
        constexpr uint32_t OUT_SEL = (9 << 0);  ///< The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-255: output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals GPIO_OUT_REG[n].
        constexpr uint32_t INV_SEL = (1U << 9);  ///< set this bit to invert output signal.1:invert.0:not invert.
        constexpr uint32_t OEN_SEL = (1U << 10);  ///< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
        constexpr uint32_t OEN_INV_SEL = (1U << 11);  ///< set this bit to invert output enable signal.1:invert.0:not invert.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< set this bit to enable GPIO clock gate
    }

    /// REG_DATE Register bits
    namespace reg_date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x60013000;
    constexpr uint32_t I2C1_BASE = 0x60027000;
    constexpr uint32_t RTC_I2C_BASE = 0x60008C00;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SCL_LOW_PERIOD;  ///< Offset: 0x00 - Configures the low level width of the SCL Clock
        volatile uint32_t CTR;  ///< Offset: 0x04 - Transmission setting
        volatile uint32_t SR;  ///< Offset: 0x08 - Describe I2C work status.
        volatile uint32_t TO;  ///< Offset: 0x0C - Setting time out control for receiving data.
        volatile uint32_t SLAVE_ADDR;  ///< Offset: 0x10 - Local slave address setting
        volatile uint32_t FIFO_ST;  ///< Offset: 0x14 - FIFO status register.
        volatile uint32_t FIFO_CONF;  ///< Offset: 0x18 - FIFO configuration register.
        volatile uint32_t DATA;  ///< Offset: 0x1C - Rx FIFO read data.
        volatile uint32_t INT_RAW;  ///< Offset: 0x20 - Raw interrupt status
        volatile uint32_t INT_CLR;  ///< Offset: 0x24 - Interrupt clear bits
        volatile uint32_t INT_ENA;  ///< Offset: 0x28 - Interrupt enable bits
        volatile uint32_t INT_STATUS;  ///< Offset: 0x2C - Status of captured I2C communication events
        volatile uint32_t SDA_HOLD;  ///< Offset: 0x30 - Configures the hold time after a negative SCL edge.
        volatile uint32_t SDA_SAMPLE;  ///< Offset: 0x34 - Configures the sample time after a positive SCL edge.
        volatile uint32_t SCL_HIGH_PERIOD;  ///< Offset: 0x38 - Configures the high level width of SCL
        volatile uint32_t SCL_START_HOLD;  ///< Offset: 0x40 - Configures the delay between the SDA and SCL negative...
        volatile uint32_t SCL_RSTART_SETUP;  ///< Offset: 0x44 - Configures the delay between the positive edge of SCL...
        volatile uint32_t SCL_STOP_HOLD;  ///< Offset: 0x48 - Configures the delay after the SCL clock edge for a stop...
        volatile uint32_t SCL_STOP_SETUP;  ///< Offset: 0x4C - Configures the delay between the SDA and SCL positive...
        volatile uint32_t FILTER_CFG;  ///< Offset: 0x50 - SCL and SDA filter configuration register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x54 - I2C CLK configuration register
        volatile uint32_t COMD;  ///< Offset: 0x58 - I2C command register %s (renamed from COMD)
        volatile uint32_t SCL_ST_TIME_OUT;  ///< Offset: 0x78 - SCL status time out register
        volatile uint32_t SCL_MAIN_ST_TIME_OUT;  ///< Offset: 0x7C - SCL main status time out register
        volatile uint32_t SCL_SP_CONF;  ///< Offset: 0x80 - Power configuration register
        volatile uint32_t SCL_STRETCH_CONF;  ///< Offset: 0x84 - Set SCL stretch of I2C slave
        volatile uint32_t DATE;  ///< Offset: 0xF8 - Version register
        volatile uint32_t TXFIFO_START_ADDR;  ///< Offset: 0x100 - I2C TXFIFO base address register
        volatile uint32_t RXFIFO_START_ADDR;  ///< Offset: 0x180 - I2C RXFIFO base address register
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* RTC_I2C = reinterpret_cast<Registers*>(RTC_I2C_BASE);

    // Bit definitions
    /// SCL_LOW_PERIOD Register bits
    namespace scl_low_period_bits {
        constexpr uint32_t SCL_LOW_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
    }

    /// CTR Register bits
    namespace ctr_bits {
        constexpr uint32_t SDA_FORCE_OUT = (1U << 0);  ///< 0: direct output; 1: open drain output.
        constexpr uint32_t SCL_FORCE_OUT = (1U << 1);  ///< 0: direct output; 1: open drain output.
        constexpr uint32_t SAMPLE_SCL_LEVEL = (1U << 2);  ///< This register is used to select the sample mode. 1: sample SDA data on the SCL low level. 0: sample SDA data on the SCL high level.
        constexpr uint32_t RX_FULL_ACK_LEVEL = (1U << 3);  ///< This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        constexpr uint32_t MS_MODE = (1U << 4);  ///< Set this bit to configure the module as an I2C Master. Clear this bit to configure the module as an I2C Slave.
        constexpr uint32_t TRANS_START = (1U << 5);  ///< Set this bit to start sending the data in txfifo.
        constexpr uint32_t TX_LSB_FIRST = (1U << 6);  ///< This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit; 0: send data from the most significant bit.
        constexpr uint32_t RX_LSB_FIRST = (1U << 7);  ///< This bit is used to control the storage mode for received data. 1: receive data from the least significant bit; 0: receive data from the most significant bit.
        constexpr uint32_t CLK_EN = (1U << 8);  ///< Reserved
        constexpr uint32_t ARBITRATION_EN = (1U << 9);  ///< This is the enable bit for arbitration_lost.
        constexpr uint32_t FSM_RST = (1U << 10);  ///< This register is used to reset the scl FMS.
        constexpr uint32_t CONF_UPGATE = (1U << 11);  ///< synchronization bit
        constexpr uint32_t SLV_TX_AUTO_START_EN = (1U << 12);  ///< This is the enable bit for slave to send data automatically
        constexpr uint32_t ADDR_10BIT_RW_CHECK_EN = (1U << 13);  ///< This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
        constexpr uint32_t ADDR_BROADCASTING_EN = (1U << 14);  ///< This is the enable bit to support the 7bit general call function.
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RESP_REC = (1U << 0);  ///< The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        constexpr uint32_t SLAVE_RW = (1U << 1);  ///< When in slave mode, 1: master reads from slave; 0: master writes to slave.
        constexpr uint32_t ARB_LOST = (1U << 3);  ///< When the I2C controller loses control of SCL line, this register changes to 1.
        constexpr uint32_t BUS_BUSY = (1U << 4);  ///< 1: the I2C bus is busy transferring data; 0: the I2C bus is in idle state.
        constexpr uint32_t SLAVE_ADDRESSED = (1U << 5);  ///< When configured as an I2C Slave, and the address sent by the master is equal to the address of the slave, then this bit will be of high level.
        constexpr uint32_t RXFIFO_CNT = (6 << 8);  ///< This field represents the amount of data needed to be sent.
        constexpr uint32_t STRETCH_CAUSE = (2 << 14);  ///< The cause of stretching SCL low in slave mode. 0: stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
        constexpr uint32_t TXFIFO_CNT = (6 << 18);  ///< This field stores the amount of received data in RAM.
        constexpr uint32_t SCL_MAIN_STATE_LAST = (3 << 24);  ///< This field indicates the states of the I2C module state machine. 0: Idle; 1: Address shift; 2: ACK address; 3: Rx data; 4: Tx data; 5: Send ACK; 6: Wait ACK
        constexpr uint32_t SCL_STATE_LAST = (3 << 28);  ///< This field indicates the states of the state machine used to produce SCL. 0: Idle; 1: Start; 2: Negative edge; 3: Low; 4: Positive edge; 5: High; 6: Stop
    }

    /// TO Register bits
    namespace to_bits {
        constexpr uint32_t TIME_OUT_VALUE = (5 << 0);  ///< This register is used to configure the timeout for receiving a data bit in APB clock cycles.
        constexpr uint32_t TIME_OUT_EN = (1U << 5);  ///< This is the enable bit for time out control.
    }

    /// SLAVE_ADDR Register bits
    namespace slave_addr_bits {
        constexpr uint32_t SLAVE_ADDR = (15 << 0);  ///< When configured as an I2C Slave, this field is used to configure the slave address.
        constexpr uint32_t ADDR_10BIT_EN = (1U << 31);  ///< This field is used to enable the slave 10-bit addressing mode in master mode.
    }

    /// FIFO_ST Register bits
    namespace fifo_st_bits {
        constexpr uint32_t RXFIFO_RADDR = (5 << 0);  ///< This is the offset address of the APB reading from rxfifo
        constexpr uint32_t RXFIFO_WADDR = (5 << 5);  ///< This is the offset address of i2c module receiving data and writing to rxfifo.
        constexpr uint32_t TXFIFO_RADDR = (5 << 10);  ///< This is the offset address of i2c module reading from txfifo.
        constexpr uint32_t TXFIFO_WADDR = (5 << 15);  ///< This is the offset address of APB bus writing to txfifo.
        constexpr uint32_t SLAVE_RW_POINT = (8 << 22);  ///< The received data in I2C slave mode.
    }

    /// FIFO_CONF Register bits
    namespace fifo_conf_bits {
        constexpr uint32_t RXFIFO_WM_THRHD = (5 << 0);  ///< The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
        constexpr uint32_t TXFIFO_WM_THRHD = (5 << 5);  ///< The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
        constexpr uint32_t NONFIFO_EN = (1U << 10);  ///< Set this bit to enable APB nonfifo access.
        constexpr uint32_t FIFO_ADDR_CFG_EN = (1U << 11);  ///< When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
        constexpr uint32_t RX_FIFO_RST = (1U << 12);  ///< Set this bit to reset rx-fifo.
        constexpr uint32_t TX_FIFO_RST = (1U << 13);  ///< Set this bit to reset tx-fifo.
        constexpr uint32_t FIFO_PRT_EN = (1U << 14);  ///< The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t FIFO_RDATA = (8 << 0);  ///< The value of rx FIFO read data.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_WM_INT_RAW = (1U << 0);  ///< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_RAW = (1U << 1);  ///< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 2);  ///< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_RAW = (1U << 3);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_RAW = (1U << 4);  ///< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_RAW = (1U << 5);  ///< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_RAW = (1U << 6);  ///< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_RAW = (1U << 7);  ///< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_RAW = (1U << 8);  ///< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_RAW = (1U << 9);  ///< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_RAW = (1U << 10);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_RAW = (1U << 11);  ///< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_RAW = (1U << 12);  ///< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_RAW = (1U << 13);  ///< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_RAW = (1U << 14);  ///< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_RAW = (1U << 15);  ///< The raw interrupt bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_RAW = (1U << 16);  ///< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_RAW = (1U << 17);  ///< The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_WM_INT_CLR = (1U << 0);  ///< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_CLR = (1U << 1);  ///< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_CLR = (1U << 3);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_CLR = (1U << 4);  ///< Set this bit to clear the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_CLR = (1U << 5);  ///< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_CLR = (1U << 6);  ///< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_CLR = (1U << 7);  ///< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_CLR = (1U << 9);  ///< Set this bit to clear the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_CLR = (1U << 10);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_CLR = (1U << 11);  ///< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_CLR = (1U << 12);  ///< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_CLR = (1U << 13);  ///< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_CLR = (1U << 14);  ///< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_CLR = (1U << 15);  ///< Set this bit to clear I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_CLR = (1U << 16);  ///< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_CLR = (1U << 17);  ///< Set this bit for I2C_GENARAL_CALL_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_WM_INT_ENA = (1U << 0);  ///< The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ENA = (1U << 1);  ///< The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ENA = (1U << 6);  ///< The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ENA = (1U << 10);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ENA = (1U << 11);  ///< The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ENA = (1U << 12);  ///< The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ENA = (1U << 13);  ///< The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ENA = (1U << 14);  ///< The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ENA = (1U << 15);  ///< The interrupt enable bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ENA = (1U << 16);  ///< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_ENA = (1U << 17);  ///< The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t RXFIFO_WM_INT_ST = (1U << 0);  ///< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        constexpr uint32_t TXFIFO_WM_INT_ST = (1U << 1);  ///< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 2);  ///< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        constexpr uint32_t END_DETECT_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t BYTE_TRANS_DONE_INT_ST = (1U << 4);  ///< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        constexpr uint32_t ARBITRATION_LOST_INT_ST = (1U << 5);  ///< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        constexpr uint32_t MST_TXFIFO_UDF_INT_ST = (1U << 6);  ///< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TRANS_COMPLETE_INT_ST = (1U << 7);  ///< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        constexpr uint32_t TIME_OUT_INT_ST = (1U << 8);  ///< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        constexpr uint32_t TRANS_START_INT_ST = (1U << 9);  ///< The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        constexpr uint32_t NACK_INT_ST = (1U << 10);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t TXFIFO_OVF_INT_ST = (1U << 11);  ///< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        constexpr uint32_t RXFIFO_UDF_INT_ST = (1U << 12);  ///< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        constexpr uint32_t SCL_ST_TO_INT_ST = (1U << 13);  ///< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        constexpr uint32_t SCL_MAIN_ST_TO_INT_ST = (1U << 14);  ///< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        constexpr uint32_t DET_START_INT_ST = (1U << 15);  ///< The masked interrupt status bit for I2C_DET_START_INT interrupt.
        constexpr uint32_t SLAVE_STRETCH_INT_ST = (1U << 16);  ///< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        constexpr uint32_t GENERAL_CALL_INT_ST = (1U << 17);  ///< The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
    }

    /// SDA_HOLD Register bits
    namespace sda_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time to hold the data after the negative edge of SCL, in I2C module clock cycles.
    }

    /// SDA_SAMPLE Register bits
    namespace sda_sample_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
    }

    /// SCL_HIGH_PERIOD Register bits
    namespace scl_high_period_bits {
        constexpr uint32_t SCL_HIGH_PERIOD = (9 << 0);  ///< This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
        constexpr uint32_t SCL_WAIT_HIGH_PERIOD = (7 << 9);  ///< This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
    }

    /// SCL_START_HOLD Register bits
    namespace scl_start_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the negative edge of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
    }

    /// SCL_RSTART_SETUP Register bits
    namespace scl_rstart_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
    }

    /// SCL_STOP_HOLD Register bits
    namespace scl_stop_hold_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the delay after the STOP condition, in I2C module clock cycles.
    }

    /// SCL_STOP_SETUP Register bits
    namespace scl_stop_setup_bits {
        constexpr uint32_t TIME = (9 << 0);  ///< This register is used to configure the time between the positive edge of SCL and the positive edge of SDA, in I2C module clock cycles.
    }

    /// FILTER_CFG Register bits
    namespace filter_cfg_bits {
        constexpr uint32_t SCL_FILTER_THRES = (4 << 0);  ///< When a pulse on the SCL input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SDA_FILTER_THRES = (4 << 4);  ///< When a pulse on the SDA input has smaller width than this register value in I2C module clock cycles, the I2C controller will ignore that pulse.
        constexpr uint32_t SCL_FILTER_EN = (1U << 8);  ///< This is the filter enable bit for SCL.
        constexpr uint32_t SDA_FILTER_EN = (1U << 9);  ///< This is the filter enable bit for SDA.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_NUM = (8 << 0);  ///< the integral part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_A = (6 << 8);  ///< the numerator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_DIV_B = (6 << 14);  ///< the denominator of the fractional part of the fractional divisor for i2c module
        constexpr uint32_t SCLK_SEL = (1U << 20);  ///< The clock selection for i2c module:0-XTAL;1-CLK_8MHz.
        constexpr uint32_t SCLK_ACTIVE = (1U << 21);  ///< The clock switch for i2c module
    }

    /// COMD Register bits
    namespace comd_bits {
        constexpr uint32_t COMMAND = (14 << 0);  ///< This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. Byte_num represents the number of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for more Information.
        constexpr uint32_t COMMAND_DONE = (1U << 31);  ///< When command 0 is done in I2C Master mode, this bit changes to high level.
    }

    /// SCL_ST_TIME_OUT Register bits
    namespace scl_st_time_out_bits {
        constexpr uint32_t SCL_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_FSM state unchanged period. It should be o more than 23
    }

    /// SCL_MAIN_ST_TIME_OUT Register bits
    namespace scl_main_st_time_out_bits {
        constexpr uint32_t SCL_MAIN_ST_TO_I2C = (5 << 0);  ///< The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
    }

    /// SCL_SP_CONF Register bits
    namespace scl_sp_conf_bits {
        constexpr uint32_t SCL_RST_SLV_EN = (1U << 0);  ///< When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        constexpr uint32_t SCL_RST_SLV_NUM = (5 << 1);  ///< Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        constexpr uint32_t SCL_PD_EN = (1U << 6);  ///< The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        constexpr uint32_t SDA_PD_EN = (1U << 7);  ///< The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
    }

    /// SCL_STRETCH_CONF Register bits
    namespace scl_stretch_conf_bits {
        constexpr uint32_t STRETCH_PROTECT_NUM = (10 << 0);  ///< Configure the period of I2C slave stretching SCL line.
        constexpr uint32_t SLAVE_SCL_STRETCH_EN = (1U << 10);  ///< The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
        constexpr uint32_t SLAVE_SCL_STRETCH_CLR = (1U << 11);  ///< Set this bit to clear the I2C slave SCL stretch function.
        constexpr uint32_t SLAVE_BYTE_ACK_CTL_EN = (1U << 12);  ///< The enable bit for slave to control ACK level function.
        constexpr uint32_t SLAVE_BYTE_ACK_LVL = (1U << 13);  ///< Set the ACK level when slave controlling ACK level function enables.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the the version register.
    }

    /// TXFIFO_START_ADDR Register bits
    namespace txfifo_start_addr_bits {
        constexpr uint32_t TXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C txfifo first address.
    }

    /// RXFIFO_START_ADDR Register bits
    namespace rxfifo_start_addr_bits {
        constexpr uint32_t RXFIFO_START_ADDR = (32 << 0);  ///< This is the I2C rxfifo first address.
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x6000F000;
    constexpr uint32_t I2S1_BASE = 0x6002D000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - I2S interrupt raw register, valid in level.
        volatile uint32_t INT_ST;  ///< Offset: 0x10 - I2S interrupt status register.
        volatile uint32_t INT_ENA;  ///< Offset: 0x14 - I2S interrupt enable register.
        volatile uint32_t INT_CLR;  ///< Offset: 0x18 - I2S interrupt clear register.
        volatile uint32_t RX_CONF;  ///< Offset: 0x20 - I2S RX configure register
        volatile uint32_t TX_CONF;  ///< Offset: 0x24 - I2S TX configure register
        volatile uint32_t RX_CONF1;  ///< Offset: 0x28 - I2S RX configure register 1
        volatile uint32_t TX_CONF1;  ///< Offset: 0x2C - I2S TX configure register 1
        volatile uint32_t RX_CLKM_CONF;  ///< Offset: 0x30 - I2S RX clock configure register
        volatile uint32_t TX_CLKM_CONF;  ///< Offset: 0x34 - I2S TX clock configure register
        volatile uint32_t RX_CLKM_DIV_CONF;  ///< Offset: 0x38 - I2S RX module clock divider configure register
        volatile uint32_t TX_CLKM_DIV_CONF;  ///< Offset: 0x3C - I2S TX module clock divider configure register
        volatile uint32_t TX_PCM2PDM_CONF;  ///< Offset: 0x40 - I2S TX PCM2PDM configuration register
        volatile uint32_t TX_PCM2PDM_CONF1;  ///< Offset: 0x44 - I2S TX PCM2PDM configuration register
        volatile uint32_t RX_TDM_CTRL;  ///< Offset: 0x50 - I2S TX TDM mode control register
        volatile uint32_t TX_TDM_CTRL;  ///< Offset: 0x54 - I2S TX TDM mode control register
        volatile uint32_t RX_TIMING;  ///< Offset: 0x58 - I2S RX timing control register
        volatile uint32_t TX_TIMING;  ///< Offset: 0x5C - I2S TX timing control register
        volatile uint32_t LC_HUNG_CONF;  ///< Offset: 0x60 - I2S HUNG configure register.
        volatile uint32_t RXEOF_NUM;  ///< Offset: 0x64 - I2S RX data number control register.
        volatile uint32_t CONF_SIGLE_DATA;  ///< Offset: 0x68 - I2S signal data register
        volatile uint32_t STATE;  ///< Offset: 0x6C - I2S TX status register
        volatile uint32_t DATE;  ///< Offset: 0x80 - Version control register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);
    inline Registers* I2S1 = reinterpret_cast<Registers*>(I2S1_BASE);

    // Bit definitions
    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_DONE_INT_RAW = (1U << 0);  ///< The raw interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 1);  ///< The raw interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< The raw interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< The raw interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_DONE_INT_ST = (1U << 0);  ///< The masked interrupt status bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ST = (1U << 1);  ///< The masked interrupt status bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< The masked interrupt status bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< The masked interrupt status bit for the i2s_tx_hung_int interrupt
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_DONE_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the i2s_tx_hung_int interrupt
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_DONE_INT_CLR = (1U << 0);  ///< Set this bit to clear the i2s_rx_done_int interrupt
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 1);  ///< Set this bit to clear the i2s_tx_done_int interrupt
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear the i2s_rx_hung_int interrupt
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear the i2s_tx_hung_int interrupt
    }

    /// RX_CONF Register bits
    namespace rx_conf_bits {
        constexpr uint32_t RX_RESET = (1U << 0);  ///< Set this bit to reset receiver
        constexpr uint32_t RX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Rx AFIFO
        constexpr uint32_t RX_START = (1U << 2);  ///< Set this bit to start receiving data
        constexpr uint32_t RX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave receiver mode
        constexpr uint32_t RX_MONO = (1U << 5);  ///< Set this bit to enable receiver in mono mode
        constexpr uint32_t RX_BIG_ENDIAN = (1U << 7);  ///< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t RX_UPDATE = (1U << 8);  ///< Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t RX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
        constexpr uint32_t RX_PCM_CONF = (2 << 10);  ///< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t RX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for received data.
        constexpr uint32_t RX_STOP_MODE = (2 << 13);  ///< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
        constexpr uint32_t RX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
        constexpr uint32_t RX_24_FILL_EN = (1U << 16);  ///< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
        constexpr uint32_t RX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when receiving left channel data, and WS is 1in right channel. 1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
        constexpr uint32_t RX_BIT_ORDER = (1U << 18);  ///< I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
        constexpr uint32_t RX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Rx mode . 0: Disable.
        constexpr uint32_t RX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Rx mode . 0: Disable.
        constexpr uint32_t RX_PDM2PCM_EN = (1U << 21);  ///< 1: Enable PDM2PCM RX mode. 0: DIsable.
        constexpr uint32_t RX_PDM_SINC_DSR_16_EN = (1U << 22);  ///< Configure the down sampling rate of PDM RX filter group1 module. 1: The down sampling rate is 128. 0: down sampling rate is 64.
    }

    /// TX_CONF Register bits
    namespace tx_conf_bits {
        constexpr uint32_t TX_RESET = (1U << 0);  ///< Set this bit to reset transmitter
        constexpr uint32_t TX_FIFO_RESET = (1U << 1);  ///< Set this bit to reset Tx AFIFO
        constexpr uint32_t TX_START = (1U << 2);  ///< Set this bit to start transmitting data
        constexpr uint32_t TX_SLAVE_MOD = (1U << 3);  ///< Set this bit to enable slave transmitter mode
        constexpr uint32_t TX_MONO = (1U << 5);  ///< Set this bit to enable transmitter in mono mode
        constexpr uint32_t TX_CHAN_EQUAL = (1U << 6);  ///< 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
        constexpr uint32_t TX_BIG_ENDIAN = (1U << 7);  ///< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
        constexpr uint32_t TX_UPDATE = (1U << 8);  ///< Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
        constexpr uint32_t TX_MONO_FST_VLD = (1U << 9);  ///< 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
        constexpr uint32_t TX_PCM_CONF = (2 << 10);  ///< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
        constexpr uint32_t TX_PCM_BYPASS = (1U << 12);  ///< Set this bit to bypass Compress/Decompress module for transmitted data.
        constexpr uint32_t TX_STOP_EN = (1U << 13);  ///< Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
        constexpr uint32_t TX_LEFT_ALIGN = (1U << 15);  ///< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
        constexpr uint32_t TX_24_FILL_EN = (1U << 16);  ///< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
        constexpr uint32_t TX_WS_IDLE_POL = (1U << 17);  ///< 0: WS should be 0 when sending left channel data, and WS is 1in right channel. 1: WS should be 1 when sending left channel data, and WS is 0in right channel.
        constexpr uint32_t TX_BIT_ORDER = (1U << 18);  ///< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
        constexpr uint32_t TX_TDM_EN = (1U << 19);  ///< 1: Enable I2S TDM Tx mode . 0: Disable.
        constexpr uint32_t TX_PDM_EN = (1U << 20);  ///< 1: Enable I2S PDM Tx mode . 0: Disable.
        constexpr uint32_t TX_CHAN_MOD = (3 << 24);  ///< I2S transmitter channel mode configuration bits.
        constexpr uint32_t SIG_LOOPBACK = (1U << 27);  ///< Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
    }

    /// RX_CONF1 Register bits
    namespace rx_conf1_bits {
        constexpr uint32_t RX_TDM_WS_WIDTH = (7 << 0);  ///< The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0] +1) * T_bck
        constexpr uint32_t RX_BCK_DIV_NUM = (6 << 7);  ///< Bit clock configuration bits in receiver mode.
        constexpr uint32_t RX_BITS_MOD = (5 << 13);  ///< Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t RX_HALF_SAMPLE_BITS = (6 << 18);  ///< I2S Rx half sample bits -1.
        constexpr uint32_t RX_TDM_CHAN_BITS = (5 << 24);  ///< The Rx bit number for each channel minus 1in TDM mode.
        constexpr uint32_t RX_MSB_SHIFT = (1U << 29);  ///< Set this bit to enable receiver in Phillips standard mode
    }

    /// TX_CONF1 Register bits
    namespace tx_conf1_bits {
        constexpr uint32_t TX_TDM_WS_WIDTH = (7 << 0);  ///< The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0] +1) * T_bck
        constexpr uint32_t TX_BCK_DIV_NUM = (6 << 7);  ///< Bit clock configuration bits in transmitter mode.
        constexpr uint32_t TX_BITS_MOD = (5 << 13);  ///< Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
        constexpr uint32_t TX_HALF_SAMPLE_BITS = (6 << 18);  ///< I2S Tx half sample bits -1.
        constexpr uint32_t TX_TDM_CHAN_BITS = (5 << 24);  ///< The Tx bit number for each channel minus 1in TDM mode.
        constexpr uint32_t TX_MSB_SHIFT = (1U << 29);  ///< Set this bit to enable transmitter in Phillips standard mode
        constexpr uint32_t TX_BCK_NO_DLY = (1U << 30);  ///< 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
    }

    /// RX_CLKM_CONF Register bits
    namespace rx_clkm_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S clock divider value
        constexpr uint32_t RX_CLK_ACTIVE = (1U << 26);  ///< I2S Rx module clock enable signal.
        constexpr uint32_t RX_CLK_SEL = (2 << 27);  ///< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t MCLK_SEL = (1U << 29);  ///< 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module clock as I2S_MCLK_OUT.
    }

    /// TX_CLKM_CONF Register bits
    namespace tx_clkm_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_NUM = (8 << 0);  ///< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div. So the average combination will be: for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
        constexpr uint32_t TX_CLK_ACTIVE = (1U << 26);  ///< I2S Tx module clock enable signal.
        constexpr uint32_t TX_CLK_SEL = (2 << 27);  ///< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
        constexpr uint32_t CLK_EN = (1U << 29);  ///< Set this bit to enable clk gate
    }

    /// RX_CLKM_DIV_CONF Register bits
    namespace rx_clkm_div_conf_bits {
        constexpr uint32_t RX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t RX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t RX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t RX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
    }

    /// TX_CLKM_DIV_CONF Register bits
    namespace tx_clkm_div_conf_bits {
        constexpr uint32_t TX_CLKM_DIV_Z = (9 << 0);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
        constexpr uint32_t TX_CLKM_DIV_Y = (9 << 9);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
        constexpr uint32_t TX_CLKM_DIV_X = (9 << 18);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
        constexpr uint32_t TX_CLKM_DIV_YN1 = (1U << 27);  ///< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
    }

    /// TX_PCM2PDM_CONF Register bits
    namespace tx_pcm2pdm_conf_bits {
        constexpr uint32_t TX_PDM_HP_BYPASS = (1U << 0);  ///< I2S TX PDM bypass hp filter or not. The option has been removed.
        constexpr uint32_t TX_PDM_SINC_OSR2 = (4 << 1);  ///< I2S TX PDM OSR2 value
        constexpr uint32_t TX_PDM_PRESCALE = (8 << 5);  ///< I2S TX PDM prescale for sigmadelta
        constexpr uint32_t TX_PDM_HP_IN_SHIFT = (2 << 13);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_LP_IN_SHIFT = (2 << 15);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SINC_IN_SHIFT = (2 << 17);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_IN_SHIFT = (2 << 19);  ///< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER2 = (1U << 21);  ///< I2S TX PDM sigmadelta dither2 value
        constexpr uint32_t TX_PDM_SIGMADELTA_DITHER = (1U << 22);  ///< I2S TX PDM sigmadelta dither value
        constexpr uint32_t TX_PDM_DAC_2OUT_EN = (1U << 23);  ///< I2S TX PDM dac mode enable
        constexpr uint32_t TX_PDM_DAC_MODE_EN = (1U << 24);  ///< I2S TX PDM dac 2channel enable
        constexpr uint32_t PCM2PDM_CONV_EN = (1U << 25);  ///< I2S TX PDM Converter enable
    }

    /// TX_PCM2PDM_CONF1 Register bits
    namespace tx_pcm2pdm_conf1_bits {
        constexpr uint32_t TX_PDM_FP = (10 << 0);  ///< I2S TX PDM Fp
        constexpr uint32_t TX_PDM_FS = (10 << 10);  ///< I2S TX PDM Fs
        constexpr uint32_t TX_IIR_HP_MULT12_5 = (3 << 20);  ///< The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
        constexpr uint32_t TX_IIR_HP_MULT12_0 = (3 << 23);  ///< The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
    }

    /// RX_TDM_CTRL Register bits
    namespace rx_tdm_ctrl_bits {
        constexpr uint32_t RX_TDM_PDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_PDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data input of I2S RX TDM channel 10. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data input of I2S RX TDM channel 11. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data input of I2S RX TDM channel 12. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data input of I2S RX TDM channel 13. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data input of I2S RX TDM channel 14. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data input of I2S RX TDM channel 15. 0: Disable, just input 0 in this channel.
        constexpr uint32_t RX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
    }

    /// TX_TDM_CTRL Register bits
    namespace tx_tdm_ctrl_bits {
        constexpr uint32_t TX_TDM_CHAN0_EN = (1U << 0);  ///< 1: Enable the valid data output of I2S TX TDM channel 0. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN1_EN = (1U << 1);  ///< 1: Enable the valid data output of I2S TX TDM channel 1. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN2_EN = (1U << 2);  ///< 1: Enable the valid data output of I2S TX TDM channel 2. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN3_EN = (1U << 3);  ///< 1: Enable the valid data output of I2S TX TDM channel 3. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN4_EN = (1U << 4);  ///< 1: Enable the valid data output of I2S TX TDM channel 4. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN5_EN = (1U << 5);  ///< 1: Enable the valid data output of I2S TX TDM channel 5. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN6_EN = (1U << 6);  ///< 1: Enable the valid data output of I2S TX TDM channel 6. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN7_EN = (1U << 7);  ///< 1: Enable the valid data output of I2S TX TDM channel 7. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN8_EN = (1U << 8);  ///< 1: Enable the valid data output of I2S TX TDM channel 8. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN9_EN = (1U << 9);  ///< 1: Enable the valid data output of I2S TX TDM channel 9. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN10_EN = (1U << 10);  ///< 1: Enable the valid data output of I2S TX TDM channel 10. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN11_EN = (1U << 11);  ///< 1: Enable the valid data output of I2S TX TDM channel 11. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN12_EN = (1U << 12);  ///< 1: Enable the valid data output of I2S TX TDM channel 12. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN13_EN = (1U << 13);  ///< 1: Enable the valid data output of I2S TX TDM channel 13. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN14_EN = (1U << 14);  ///< 1: Enable the valid data output of I2S TX TDM channel 14. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_CHAN15_EN = (1U << 15);  ///< 1: Enable the valid data output of I2S TX TDM channel 15. 0: Disable, just output 0 in this channel.
        constexpr uint32_t TX_TDM_TOT_CHAN_NUM = (4 << 16);  ///< The total channel number of I2S TX TDM mode.
        constexpr uint32_t TX_TDM_SKIP_MSK_EN = (1U << 20);  ///< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1) channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
    }

    /// RX_TIMING Register bits
    namespace rx_timing_bits {
        constexpr uint32_t RX_SD_IN_DM = (2 << 0);  ///< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD1_IN_DM = (2 << 4);  ///< The delay mode of I2S Rx SD1 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD2_IN_DM = (2 << 8);  ///< The delay mode of I2S Rx SD2 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_SD3_IN_DM = (2 << 12);  ///< The delay mode of I2S Rx SD3 input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t RX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// TX_TIMING Register bits
    namespace tx_timing_bits {
        constexpr uint32_t TX_SD_OUT_DM = (2 << 0);  ///< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_SD1_OUT_DM = (2 << 4);  ///< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_OUT_DM = (2 << 16);  ///< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_OUT_DM = (2 << 20);  ///< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_WS_IN_DM = (2 << 24);  ///< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
        constexpr uint32_t TX_BCK_IN_DM = (2 << 28);  ///< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge. 2: delay by neg edge. 3: not used.
    }

    /// LC_HUNG_CONF Register bits
    namespace lc_hung_conf_bits {
        constexpr uint32_t LC_FIFO_TIMEOUT = (8 << 0);  ///< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
        constexpr uint32_t LC_FIFO_TIMEOUT_SHIFT = (3 << 8);  ///< The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
        constexpr uint32_t LC_FIFO_TIMEOUT_ENA = (1U << 11);  ///< The enable bit for FIFO timeout
    }

    /// RXEOF_NUM Register bits
    namespace rxeof_num_bits {
        constexpr uint32_t RX_EOF_NUM = (12 << 0);  ///< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
    }

    /// CONF_SIGLE_DATA Register bits
    namespace conf_sigle_data_bits {
        constexpr uint32_t SINGLE_DATA = (32 << 0);  ///< The configured constant channel data to be sent out.
    }

    /// STATE Register bits
    namespace state_bits {
        constexpr uint32_t TX_IDLE = (1U << 0);  ///< 1: i2s_tx is idle state. 0: i2s_tx is working.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< I2S version control register
    }

}

// ============================================================================
// INTERRUPT Peripheral
// ============================================================================

namespace interrupt {
    /// Base addresses
    constexpr uint32_t INTERRUPT_CORE0_BASE = 0x600C2000;
    constexpr uint32_t INTERRUPT_CORE1_BASE = 0x600C2000;

    /// INTERRUPT Register structure
    struct Registers {
        volatile uint32_t PRO_MAC_INTR_MAP;  ///< Offset: 0x00 - mac interrupt configuration register
        volatile uint32_t MAC_NMI_MAP;  ///< Offset: 0x04 - mac_nmi interrupt configuration register
        volatile uint32_t PWR_INTR_MAP;  ///< Offset: 0x08 - pwr interrupt configuration register
        volatile uint32_t BB_INT_MAP;  ///< Offset: 0x0C - bb interrupt configuration register
        volatile uint32_t BT_MAC_INT_MAP;  ///< Offset: 0x10 - bb_mac interrupt configuration register
        volatile uint32_t BT_BB_INT_MAP;  ///< Offset: 0x14 - bt_bb interrupt configuration register
        volatile uint32_t BT_BB_NMI_MAP;  ///< Offset: 0x18 - bt_bb_nmi interrupt configuration register
        volatile uint32_t RWBT_IRQ_MAP;  ///< Offset: 0x1C - rwbt_irq interrupt configuration register
        volatile uint32_t RWBLE_IRQ_MAP;  ///< Offset: 0x20 - rwble_irq interrupt configuration register
        volatile uint32_t RWBT_NMI_MAP;  ///< Offset: 0x24 - rwbt_nmi interrupt configuration register
        volatile uint32_t RWBLE_NMI_MAP;  ///< Offset: 0x28 - rwble_nmi interrupt configuration register
        volatile uint32_t I2C_MST_INT_MAP;  ///< Offset: 0x2C - i2c_mst interrupt configuration register
        volatile uint32_t SLC0_INTR_MAP;  ///< Offset: 0x30 - slc0 interrupt configuration register
        volatile uint32_t SLC1_INTR_MAP;  ///< Offset: 0x34 - slc1 interrupt configuration register
        volatile uint32_t UHCI0_INTR_MAP;  ///< Offset: 0x38 - uhci0 interrupt configuration register
        volatile uint32_t UHCI1_INTR_MAP;  ///< Offset: 0x3C - uhci1 interrupt configuration register
        volatile uint32_t GPIO_INTERRUPT_PRO_MAP;  ///< Offset: 0x40 - gpio_interrupt_pro interrupt configuration register
        volatile uint32_t GPIO_INTERRUPT_PRO_NMI_MAP;  ///< Offset: 0x44 - gpio_interrupt_pro_nmi interrupt configuration register
        volatile uint32_t GPIO_INTERRUPT_APP_MAP;  ///< Offset: 0x48 - gpio_interrupt_app interrupt configuration register
        volatile uint32_t GPIO_INTERRUPT_APP_NMI_MAP;  ///< Offset: 0x4C - gpio_interrupt_app_nmi interrupt configuration register
        volatile uint32_t SPI_INTR_1_MAP;  ///< Offset: 0x50 - spi_intr_1 interrupt configuration register
        volatile uint32_t SPI_INTR_2_MAP;  ///< Offset: 0x54 - spi_intr_2 interrupt configuration register
        volatile uint32_t SPI_INTR_3_MAP;  ///< Offset: 0x58 - spi_intr_3 interrupt configuration register
        volatile uint32_t SPI_INTR_4_MAP;  ///< Offset: 0x5C - spi_intr_4 interrupt configuration register
        volatile uint32_t LCD_CAM_INT_MAP;  ///< Offset: 0x60 - lcd_cam interrupt configuration register
        volatile uint32_t I2S0_INT_MAP;  ///< Offset: 0x64 - i2s0 interrupt configuration register
        volatile uint32_t I2S1_INT_MAP;  ///< Offset: 0x68 - i2s1 interrupt configuration register
        volatile uint32_t UART_INTR_MAP;  ///< Offset: 0x6C - uart interrupt configuration register
        volatile uint32_t UART1_INTR_MAP;  ///< Offset: 0x70 - uart1 interrupt configuration register
        volatile uint32_t UART2_INTR_MAP;  ///< Offset: 0x74 - uart2 interrupt configuration register
        volatile uint32_t SDIO_HOST_INTERRUPT_MAP;  ///< Offset: 0x78 - sdio_host interrupt configuration register
        volatile uint32_t PWM0_INTR_MAP;  ///< Offset: 0x7C - pwm0 interrupt configuration register
        volatile uint32_t PWM1_INTR_MAP;  ///< Offset: 0x80 - pwm1 interrupt configuration register
        volatile uint32_t PWM2_INTR_MAP;  ///< Offset: 0x84 - pwm2 interrupt configuration register
        volatile uint32_t PWM3_INTR_MAP;  ///< Offset: 0x88 - pwm3 interrupt configuration register
        volatile uint32_t LEDC_INT_MAP;  ///< Offset: 0x8C - ledc interrupt configuration register
        volatile uint32_t EFUSE_INT_MAP;  ///< Offset: 0x90 - efuse interrupt configuration register
        volatile uint32_t CAN_INT_MAP;  ///< Offset: 0x94 - can interrupt configuration register
        volatile uint32_t USB_INTR_MAP;  ///< Offset: 0x98 - usb interrupt configuration register
        volatile uint32_t RTC_CORE_INTR_MAP;  ///< Offset: 0x9C - rtc_core interrupt configuration register
        volatile uint32_t RMT_INTR_MAP;  ///< Offset: 0xA0 - rmt interrupt configuration register
        volatile uint32_t PCNT_INTR_MAP;  ///< Offset: 0xA4 - pcnt interrupt configuration register
        volatile uint32_t I2C_EXT0_INTR_MAP;  ///< Offset: 0xA8 - i2c_ext0 interrupt configuration register
        volatile uint32_t I2C_EXT1_INTR_MAP;  ///< Offset: 0xAC - i2c_ext1 interrupt configuration register
        volatile uint32_t SPI2_DMA_INT_MAP;  ///< Offset: 0xB0 - spi2_dma interrupt configuration register
        volatile uint32_t SPI3_DMA_INT_MAP;  ///< Offset: 0xB4 - spi3_dma interrupt configuration register
        volatile uint32_t SPI4_DMA_INT_MAP;  ///< Offset: 0xB8 - spi4_dma interrupt configuration register
        volatile uint32_t WDG_INT_MAP;  ///< Offset: 0xBC - wdg interrupt configuration register
        volatile uint32_t TIMER_INT1_MAP;  ///< Offset: 0xC0 - timer_int1 interrupt configuration register
        volatile uint32_t TIMER_INT2_MAP;  ///< Offset: 0xC4 - timer_int2 interrupt configuration register
        volatile uint32_t TG_T0_INT_MAP;  ///< Offset: 0xC8 - tg_t0 interrupt configuration register
        volatile uint32_t TG_T1_INT_MAP;  ///< Offset: 0xCC - tg_t1 interrupt configuration register
        volatile uint32_t TG_WDT_INT_MAP;  ///< Offset: 0xD0 - tg_wdt interrupt configuration register
        volatile uint32_t TG1_T0_INT_MAP;  ///< Offset: 0xD4 - tg1_t0 interrupt configuration register
        volatile uint32_t TG1_T1_INT_MAP;  ///< Offset: 0xD8 - tg1_t1 interrupt configuration register
        volatile uint32_t TG1_WDT_INT_MAP;  ///< Offset: 0xDC - tg1_wdt interrupt configuration register
        volatile uint32_t CACHE_IA_INT_MAP;  ///< Offset: 0xE0 - cache_ia interrupt configuration register
        volatile uint32_t SYSTIMER_TARGET0_INT_MAP;  ///< Offset: 0xE4 - systimer_target0 interrupt configuration register
        volatile uint32_t SYSTIMER_TARGET1_INT_MAP;  ///< Offset: 0xE8 - systimer_target1 interrupt configuration register
        volatile uint32_t SYSTIMER_TARGET2_INT_MAP;  ///< Offset: 0xEC - systimer_target2 interrupt configuration register
        volatile uint32_t SPI_MEM_REJECT_INTR_MAP;  ///< Offset: 0xF0 - spi_mem_reject interrupt configuration register
        volatile uint32_t DCACHE_PRELOAD_INT_MAP;  ///< Offset: 0xF4 - dcache_prelaod interrupt configuration register
        volatile uint32_t ICACHE_PRELOAD_INT_MAP;  ///< Offset: 0xF8 - icache_preload interrupt configuration register
        volatile uint32_t DCACHE_SYNC_INT_MAP;  ///< Offset: 0xFC - dcache_sync interrupt configuration register
        volatile uint32_t ICACHE_SYNC_INT_MAP;  ///< Offset: 0x100 - icache_sync interrupt configuration register
        volatile uint32_t APB_ADC_INT_MAP;  ///< Offset: 0x104 - apb_adc interrupt configuration register
        volatile uint32_t DMA_IN_CH0_INT_MAP;  ///< Offset: 0x108 - dma_in_ch0 interrupt configuration register
        volatile uint32_t DMA_IN_CH1_INT_MAP;  ///< Offset: 0x10C - dma_in_ch1 interrupt configuration register
        volatile uint32_t DMA_IN_CH2_INT_MAP;  ///< Offset: 0x110 - dma_in_ch2 interrupt configuration register
        volatile uint32_t DMA_IN_CH3_INT_MAP;  ///< Offset: 0x114 - dma_in_ch3 interrupt configuration register
        volatile uint32_t DMA_IN_CH4_INT_MAP;  ///< Offset: 0x118 - dma_in_ch4 interrupt configuration register
        volatile uint32_t DMA_OUT_CH0_INT_MAP;  ///< Offset: 0x11C - dma_out_ch0 interrupt configuration register
        volatile uint32_t DMA_OUT_CH1_INT_MAP;  ///< Offset: 0x120 - dma_out_ch1 interrupt configuration register
        volatile uint32_t DMA_OUT_CH2_INT_MAP;  ///< Offset: 0x124 - dma_out_ch2 interrupt configuration register
        volatile uint32_t DMA_OUT_CH3_INT_MAP;  ///< Offset: 0x128 - dma_out_ch3 interrupt configuration register
        volatile uint32_t DMA_OUT_CH4_INT_MAP;  ///< Offset: 0x12C - dma_out_ch4 interrupt configuration register
        volatile uint32_t RSA_INT_MAP;  ///< Offset: 0x130 - rsa interrupt configuration register
        volatile uint32_t AES_INT_MAP;  ///< Offset: 0x134 - aes interrupt configuration register
        volatile uint32_t SHA_INT_MAP;  ///< Offset: 0x138 - sha interrupt configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_0_MAP;  ///< Offset: 0x13C - cpu_intr_from_cpu_0 interrupt configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_1_MAP;  ///< Offset: 0x140 - cpu_intr_from_cpu_1 interrupt configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_2_MAP;  ///< Offset: 0x144 - cpu_intr_from_cpu_2 interrupt configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_3_MAP;  ///< Offset: 0x148 - cpu_intr_from_cpu_3 interrupt configuration register
        volatile uint32_t ASSIST_DEBUG_INTR_MAP;  ///< Offset: 0x14C - assist_debug interrupt configuration register
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x150 - dma_pms_monitor_violatile interrupt configuration register
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x154 - core0_IRam0_pms_monitor_violatile interrupt...
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x158 - core0_DRam0_pms_monitor_violatile interrupt...
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x15C - core0_PIF_pms_monitor_violatile interrupt configuration register
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;  ///< Offset: 0x160 - core0_PIF_pms_monitor_violatile_size interrupt...
        volatile uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x164 - core1_IRam0_pms_monitor_violatile interrupt...
        volatile uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x168 - core1_DRam0_pms_monitor_violatile interrupt...
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;  ///< Offset: 0x16C - core1_PIF_pms_monitor_violatile interrupt configuration register
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;  ///< Offset: 0x170 - core1_PIF_pms_monitor_violatile_size interrupt...
        volatile uint32_t BACKUP_PMS_VIOLATE_INTR_MAP;  ///< Offset: 0x174 - backup_pms_monitor_violatile interrupt configuration register
        volatile uint32_t CACHE_CORE0_ACS_INT_MAP;  ///< Offset: 0x178 - cache_core0_acs interrupt configuration register
        volatile uint32_t CACHE_CORE1_ACS_INT_MAP;  ///< Offset: 0x17C - cache_core1_acs interrupt configuration register
        volatile uint32_t USB_DEVICE_INT_MAP;  ///< Offset: 0x180 - usb_device interrupt configuration register
        volatile uint32_t PERI_BACKUP_INT_MAP;  ///< Offset: 0x184 - peri_backup interrupt configuration register
        volatile uint32_t DMA_EXTMEM_REJECT_INT_MAP;  ///< Offset: 0x188 - dma_extmem_reject interrupt configuration register
        volatile uint32_t PRO_INTR_STATUS_0;  ///< Offset: 0x18C - interrupt status register
        volatile uint32_t PRO_INTR_STATUS_1;  ///< Offset: 0x190 - interrupt status register
        volatile uint32_t PRO_INTR_STATUS_2;  ///< Offset: 0x194 - interrupt status register
        volatile uint32_t PRO_INTR_STATUS_3;  ///< Offset: 0x198 - interrupt status register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x19C - clock gate register
        volatile uint32_t DATE;  ///< Offset: 0x7FC - version register
    };

    /// Peripheral instances
    inline Registers* INTERRUPT_CORE0 = reinterpret_cast<Registers*>(INTERRUPT_CORE0_BASE);
    inline Registers* INTERRUPT_CORE1 = reinterpret_cast<Registers*>(INTERRUPT_CORE1_BASE);

    // Bit definitions
    /// PRO_MAC_INTR_MAP Register bits
    namespace pro_mac_intr_map_bits {
        constexpr uint32_t MAC_INTR_MAP = (5 << 0);  ///< this register used to map mac interrupt to one of core0's external interrupt
    }

    /// MAC_NMI_MAP Register bits
    namespace mac_nmi_map_bits {
        constexpr uint32_t MAC_NMI_MAP = (5 << 0);  ///< this register used to map_nmi interrupt to one of core0's external interrupt
    }

    /// PWR_INTR_MAP Register bits
    namespace pwr_intr_map_bits {
        constexpr uint32_t PWR_INTR_MAP = (5 << 0);  ///< this register used to map pwr interrupt to one of core0's external interrupt
    }

    /// BB_INT_MAP Register bits
    namespace bb_int_map_bits {
        constexpr uint32_t BB_INT_MAP = (5 << 0);  ///< this register used to map bb interrupt to one of core0's external interrupt
    }

    /// BT_MAC_INT_MAP Register bits
    namespace bt_mac_int_map_bits {
        constexpr uint32_t BT_MAC_INT_MAP = (5 << 0);  ///< this register used to map bb_mac interrupt to one of core0's external interrupt
    }

    /// BT_BB_INT_MAP Register bits
    namespace bt_bb_int_map_bits {
        constexpr uint32_t BT_BB_INT_MAP = (5 << 0);  ///< this register used to map bt_bb interrupt to one of core0's external interrupt
    }

    /// BT_BB_NMI_MAP Register bits
    namespace bt_bb_nmi_map_bits {
        constexpr uint32_t BT_BB_NMI_MAP = (5 << 0);  ///< this register used to map bb_bt_nmi interrupt to one of core0's external interrupt
    }

    /// RWBT_IRQ_MAP Register bits
    namespace rwbt_irq_map_bits {
        constexpr uint32_t RWBT_IRQ_MAP = (5 << 0);  ///< this register used to map rwbt_irq interrupt to one of core0's external interrupt
    }

    /// RWBLE_IRQ_MAP Register bits
    namespace rwble_irq_map_bits {
        constexpr uint32_t RWBLE_IRQ_MAP = (5 << 0);  ///< this register used to map rwble_irq interrupt to one of core0's external interrupt
    }

    /// RWBT_NMI_MAP Register bits
    namespace rwbt_nmi_map_bits {
        constexpr uint32_t RWBT_NMI_MAP = (5 << 0);  ///< this register used to map mac rwbt_nmi to one of core0's external interrupt
    }

    /// RWBLE_NMI_MAP Register bits
    namespace rwble_nmi_map_bits {
        constexpr uint32_t RWBLE_NMI_MAP = (5 << 0);  ///< this register used to map rwble_nmi interrupt to one of core0's external interrupt
    }

    /// I2C_MST_INT_MAP Register bits
    namespace i2c_mst_int_map_bits {
        constexpr uint32_t I2C_MST_INT_MAP = (5 << 0);  ///< this register used to map i2c_mst interrupt to one of core0's external interrupt
    }

    /// SLC0_INTR_MAP Register bits
    namespace slc0_intr_map_bits {
        constexpr uint32_t SLC0_INTR_MAP = (5 << 0);  ///< this register used to map slc0 interrupt to one of core0's external interrupt
    }

    /// SLC1_INTR_MAP Register bits
    namespace slc1_intr_map_bits {
        constexpr uint32_t SLC1_INTR_MAP = (5 << 0);  ///< this register used to map slc1 interrupt to one of core0's external interrupt
    }

    /// UHCI0_INTR_MAP Register bits
    namespace uhci0_intr_map_bits {
        constexpr uint32_t UHCI0_INTR_MAP = (5 << 0);  ///< this register used to map uhci0 interrupt to one of core0's external interrupt
    }

    /// UHCI1_INTR_MAP Register bits
    namespace uhci1_intr_map_bits {
        constexpr uint32_t UHCI1_INTR_MAP = (5 << 0);  ///< this register used to map uhci1 interrupt to one of core0's external interrupt
    }

    /// GPIO_INTERRUPT_PRO_MAP Register bits
    namespace gpio_interrupt_pro_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_MAP = (5 << 0);  ///< this register used to map gpio_interrupt_pro interrupt to one of core0's external interrupt
    }

    /// GPIO_INTERRUPT_PRO_NMI_MAP Register bits
    namespace gpio_interrupt_pro_nmi_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_PRO_NMI_MAP = (5 << 0);  ///< this register used to map gpio_interrupt_pro_nmi interrupt to one of core0's external interrupt
    }

    /// GPIO_INTERRUPT_APP_MAP Register bits
    namespace gpio_interrupt_app_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_APP_MAP = (5 << 0);  ///< this register used to map gpio_interrupt_app interrupt to one of core0's external interrupt
    }

    /// GPIO_INTERRUPT_APP_NMI_MAP Register bits
    namespace gpio_interrupt_app_nmi_map_bits {
        constexpr uint32_t GPIO_INTERRUPT_APP_NMI_MAP = (5 << 0);  ///< this register used to map gpio_interrupt_app_nmi interrupt to one of core0's external interrupt
    }

    /// SPI_INTR_1_MAP Register bits
    namespace spi_intr_1_map_bits {
        constexpr uint32_t SPI_INTR_1_MAP = (5 << 0);  ///< this register used to map spi_intr_1 interrupt to one of core0's external interrupt
    }

    /// SPI_INTR_2_MAP Register bits
    namespace spi_intr_2_map_bits {
        constexpr uint32_t SPI_INTR_2_MAP = (5 << 0);  ///< this register used to map spi_intr_2 interrupt to one of core0's external interrupt
    }

    /// SPI_INTR_3_MAP Register bits
    namespace spi_intr_3_map_bits {
        constexpr uint32_t SPI_INTR_3_MAP = (5 << 0);  ///< this register used to map spi_intr_3 interrupt to one of core0's external interrupt
    }

    /// SPI_INTR_4_MAP Register bits
    namespace spi_intr_4_map_bits {
        constexpr uint32_t SPI_INTR_4_MAP = (5 << 0);  ///< this register used to map spi_intr_4 interrupt to one of core0's external interrupt
    }

    /// LCD_CAM_INT_MAP Register bits
    namespace lcd_cam_int_map_bits {
        constexpr uint32_t LCD_CAM_INT_MAP = (5 << 0);  ///< this register used to map lcd_cam interrupt to one of core0's external interrupt
    }

    /// I2S0_INT_MAP Register bits
    namespace i2s0_int_map_bits {
        constexpr uint32_t I2S0_INT_MAP = (5 << 0);  ///< this register used to map i2s0 interrupt to one of core0's external interrupt
    }

    /// I2S1_INT_MAP Register bits
    namespace i2s1_int_map_bits {
        constexpr uint32_t I2S1_INT_MAP = (5 << 0);  ///< this register used to map i2s1 interrupt to one of core0's external interrupt
    }

    /// UART_INTR_MAP Register bits
    namespace uart_intr_map_bits {
        constexpr uint32_t UART_INTR_MAP = (5 << 0);  ///< this register used to map uart interrupt to one of core0's external interrupt
    }

    /// UART1_INTR_MAP Register bits
    namespace uart1_intr_map_bits {
        constexpr uint32_t UART1_INTR_MAP = (5 << 0);  ///< this register used to map uart1 interrupt to one of core0's external interrupt
    }

    /// UART2_INTR_MAP Register bits
    namespace uart2_intr_map_bits {
        constexpr uint32_t UART2_INTR_MAP = (5 << 0);  ///< this register used to map uart2 interrupt to one of core0's external interrupt
    }

    /// SDIO_HOST_INTERRUPT_MAP Register bits
    namespace sdio_host_interrupt_map_bits {
        constexpr uint32_t SDIO_HOST_INTERRUPT_MAP = (5 << 0);  ///< this register used to map sdio_host interrupt to one of core0's external interrupt
    }

    /// PWM0_INTR_MAP Register bits
    namespace pwm0_intr_map_bits {
        constexpr uint32_t PWM0_INTR_MAP = (5 << 0);  ///< this register used to map pwm0 interrupt to one of core0's external interrupt
    }

    /// PWM1_INTR_MAP Register bits
    namespace pwm1_intr_map_bits {
        constexpr uint32_t PWM1_INTR_MAP = (5 << 0);  ///< this register used to map pwm1 interrupt to one of core0's external interrupt
    }

    /// PWM2_INTR_MAP Register bits
    namespace pwm2_intr_map_bits {
        constexpr uint32_t PWM2_INTR_MAP = (5 << 0);  ///< this register used to map pwm2 interrupt to one of core0's external interrupt
    }

    /// PWM3_INTR_MAP Register bits
    namespace pwm3_intr_map_bits {
        constexpr uint32_t PWM3_INTR_MAP = (5 << 0);  ///< this register used to map pwm3 interrupt to one of core0's external interrupt
    }

    /// LEDC_INT_MAP Register bits
    namespace ledc_int_map_bits {
        constexpr uint32_t LEDC_INT_MAP = (5 << 0);  ///< this register used to map ledc interrupt to one of core0's external interrupt
    }

    /// EFUSE_INT_MAP Register bits
    namespace efuse_int_map_bits {
        constexpr uint32_t EFUSE_INT_MAP = (5 << 0);  ///< this register used to map efuse interrupt to one of core0's external interrupt
    }

    /// CAN_INT_MAP Register bits
    namespace can_int_map_bits {
        constexpr uint32_t CAN_INT_MAP = (5 << 0);  ///< this register used to map can interrupt to one of core0's external interrupt
    }

    /// USB_INTR_MAP Register bits
    namespace usb_intr_map_bits {
        constexpr uint32_t USB_INTR_MAP = (5 << 0);  ///< this register used to map usb interrupt to one of core0's external interrupt
    }

    /// RTC_CORE_INTR_MAP Register bits
    namespace rtc_core_intr_map_bits {
        constexpr uint32_t RTC_CORE_INTR_MAP = (5 << 0);  ///< this register used to map rtc_core interrupt to one of core0's external interrupt
    }

    /// RMT_INTR_MAP Register bits
    namespace rmt_intr_map_bits {
        constexpr uint32_t RMT_INTR_MAP = (5 << 0);  ///< this register used to map rmt interrupt to one of core0's external interrupt
    }

    /// PCNT_INTR_MAP Register bits
    namespace pcnt_intr_map_bits {
        constexpr uint32_t PCNT_INTR_MAP = (5 << 0);  ///< this register used to map pcnt interrupt to one of core0's external interrupt
    }

    /// I2C_EXT0_INTR_MAP Register bits
    namespace i2c_ext0_intr_map_bits {
        constexpr uint32_t I2C_EXT0_INTR_MAP = (5 << 0);  ///< this register used to map i2c_ext0 interrupt to one of core0's external interrupt
    }

    /// I2C_EXT1_INTR_MAP Register bits
    namespace i2c_ext1_intr_map_bits {
        constexpr uint32_t I2C_EXT1_INTR_MAP = (5 << 0);  ///< this register used to map i2c_ext1 interrupt to one of core0's external interrupt
    }

    /// SPI2_DMA_INT_MAP Register bits
    namespace spi2_dma_int_map_bits {
        constexpr uint32_t SPI2_DMA_INT_MAP = (5 << 0);  ///< this register used to map spi2_dma interrupt to one of core0's external interrupt
    }

    /// SPI3_DMA_INT_MAP Register bits
    namespace spi3_dma_int_map_bits {
        constexpr uint32_t SPI3_DMA_INT_MAP = (5 << 0);  ///< this register used to map spi3_dma interrupt to one of core0's external interrupt
    }

    /// SPI4_DMA_INT_MAP Register bits
    namespace spi4_dma_int_map_bits {
        constexpr uint32_t SPI4_DMA_INT_MAP = (5 << 0);  ///< this register used to map spi4_dma interrupt to one of core0's external interrupt
    }

    /// WDG_INT_MAP Register bits
    namespace wdg_int_map_bits {
        constexpr uint32_t WDG_INT_MAP = (5 << 0);  ///< this register used to map wdg interrupt to one of core0's external interrupt
    }

    /// TIMER_INT1_MAP Register bits
    namespace timer_int1_map_bits {
        constexpr uint32_t TIMER_INT1_MAP = (5 << 0);  ///< this register used to map timer_int1 interrupt to one of core0's external interrupt
    }

    /// TIMER_INT2_MAP Register bits
    namespace timer_int2_map_bits {
        constexpr uint32_t TIMER_INT2_MAP = (5 << 0);  ///< this register used to map timer_int2 interrupt to one of core0's external interrupt
    }

    /// TG_T0_INT_MAP Register bits
    namespace tg_t0_int_map_bits {
        constexpr uint32_t TG_T0_INT_MAP = (5 << 0);  ///< this register used to map tg_t0 interrupt to one of core0's external interrupt
    }

    /// TG_T1_INT_MAP Register bits
    namespace tg_t1_int_map_bits {
        constexpr uint32_t TG_T1_INT_MAP = (5 << 0);  ///< this register used to map tg_t1 interrupt to one of core0's external interrupt
    }

    /// TG_WDT_INT_MAP Register bits
    namespace tg_wdt_int_map_bits {
        constexpr uint32_t TG_WDT_INT_MAP = (5 << 0);  ///< this register used to map rg_wdt interrupt to one of core0's external interrupt
    }

    /// TG1_T0_INT_MAP Register bits
    namespace tg1_t0_int_map_bits {
        constexpr uint32_t TG1_T0_INT_MAP = (5 << 0);  ///< this register used to map tg1_t0 interrupt to one of core0's external interrupt
    }

    /// TG1_T1_INT_MAP Register bits
    namespace tg1_t1_int_map_bits {
        constexpr uint32_t TG1_T1_INT_MAP = (5 << 0);  ///< this register used to map tg1_t1 interrupt to one of core0's external interrupt
    }

    /// TG1_WDT_INT_MAP Register bits
    namespace tg1_wdt_int_map_bits {
        constexpr uint32_t TG1_WDT_INT_MAP = (5 << 0);  ///< this register used to map tg1_wdt interrupt to one of core0's external interrupt
    }

    /// CACHE_IA_INT_MAP Register bits
    namespace cache_ia_int_map_bits {
        constexpr uint32_t CACHE_IA_INT_MAP = (5 << 0);  ///< this register used to map cache_ia interrupt to one of core0's external interrupt
    }

    /// SYSTIMER_TARGET0_INT_MAP Register bits
    namespace systimer_target0_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET0_INT_MAP = (5 << 0);  ///< this register used to map systimer_target0 interrupt to one of core0's external interrupt
    }

    /// SYSTIMER_TARGET1_INT_MAP Register bits
    namespace systimer_target1_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET1_INT_MAP = (5 << 0);  ///< this register used to map systimer_target1 interrupt to one of core0's external interrupt
    }

    /// SYSTIMER_TARGET2_INT_MAP Register bits
    namespace systimer_target2_int_map_bits {
        constexpr uint32_t SYSTIMER_TARGET2_INT_MAP = (5 << 0);  ///< this register used to map systimer_target2 interrupt to one of core0's external interrupt
    }

    /// SPI_MEM_REJECT_INTR_MAP Register bits
    namespace spi_mem_reject_intr_map_bits {
        constexpr uint32_t SPI_MEM_REJECT_INTR_MAP = (5 << 0);  ///< this register used to map spi_mem_reject interrupt to one of core0's external interrupt
    }

    /// DCACHE_PRELOAD_INT_MAP Register bits
    namespace dcache_preload_int_map_bits {
        constexpr uint32_t DCACHE_PRELOAD_INT_MAP = (5 << 0);  ///< this register used to map dcache_prelaod interrupt to one of core0's external interrupt
    }

    /// ICACHE_PRELOAD_INT_MAP Register bits
    namespace icache_preload_int_map_bits {
        constexpr uint32_t ICACHE_PRELOAD_INT_MAP = (5 << 0);  ///< this register used to map icache_preload interrupt to one of core0's external interrupt
    }

    /// DCACHE_SYNC_INT_MAP Register bits
    namespace dcache_sync_int_map_bits {
        constexpr uint32_t DCACHE_SYNC_INT_MAP = (5 << 0);  ///< this register used to map dcache_sync interrupt to one of core0's external interrupt
    }

    /// ICACHE_SYNC_INT_MAP Register bits
    namespace icache_sync_int_map_bits {
        constexpr uint32_t ICACHE_SYNC_INT_MAP = (5 << 0);  ///< this register used to map icache_sync interrupt to one of core0's external interrupt
    }

    /// APB_ADC_INT_MAP Register bits
    namespace apb_adc_int_map_bits {
        constexpr uint32_t APB_ADC_INT_MAP = (5 << 0);  ///< this register used to map apb_adc interrupt to one of core0's external interrupt
    }

    /// DMA_IN_CH0_INT_MAP Register bits
    namespace dma_in_ch0_int_map_bits {
        constexpr uint32_t DMA_IN_CH0_INT_MAP = (5 << 0);  ///< this register used to map dma_in_ch0 interrupt to one of core0's external interrupt
    }

    /// DMA_IN_CH1_INT_MAP Register bits
    namespace dma_in_ch1_int_map_bits {
        constexpr uint32_t DMA_IN_CH1_INT_MAP = (5 << 0);  ///< this register used to map dma_in_ch1 interrupt to one of core0's external interrupt
    }

    /// DMA_IN_CH2_INT_MAP Register bits
    namespace dma_in_ch2_int_map_bits {
        constexpr uint32_t DMA_IN_CH2_INT_MAP = (5 << 0);  ///< this register used to map dma_in_ch2 interrupt to one of core0's external interrupt
    }

    /// DMA_IN_CH3_INT_MAP Register bits
    namespace dma_in_ch3_int_map_bits {
        constexpr uint32_t DMA_IN_CH3_INT_MAP = (5 << 0);  ///< this register used to map dma_in_ch3 interrupt to one of core0's external interrupt
    }

    /// DMA_IN_CH4_INT_MAP Register bits
    namespace dma_in_ch4_int_map_bits {
        constexpr uint32_t DMA_IN_CH4_INT_MAP = (5 << 0);  ///< this register used to map dma_in_ch4 interrupt to one of core0's external interrupt
    }

    /// DMA_OUT_CH0_INT_MAP Register bits
    namespace dma_out_ch0_int_map_bits {
        constexpr uint32_t DMA_OUT_CH0_INT_MAP = (5 << 0);  ///< this register used to map dma_out_ch0 interrupt to one of core0's external interrupt
    }

    /// DMA_OUT_CH1_INT_MAP Register bits
    namespace dma_out_ch1_int_map_bits {
        constexpr uint32_t DMA_OUT_CH1_INT_MAP = (5 << 0);  ///< this register used to map dma_out_ch1 interrupt to one of core0's external interrupt
    }

    /// DMA_OUT_CH2_INT_MAP Register bits
    namespace dma_out_ch2_int_map_bits {
        constexpr uint32_t DMA_OUT_CH2_INT_MAP = (5 << 0);  ///< this register used to map dma_out_ch2 interrupt to one of core0's external interrupt
    }

    /// DMA_OUT_CH3_INT_MAP Register bits
    namespace dma_out_ch3_int_map_bits {
        constexpr uint32_t DMA_OUT_CH3_INT_MAP = (5 << 0);  ///< this register used to map dma_out_ch3 interrupt to one of core0's external interrupt
    }

    /// DMA_OUT_CH4_INT_MAP Register bits
    namespace dma_out_ch4_int_map_bits {
        constexpr uint32_t DMA_OUT_CH4_INT_MAP = (5 << 0);  ///< this register used to map dma_out_ch4 interrupt to one of core0's external interrupt
    }

    /// RSA_INT_MAP Register bits
    namespace rsa_int_map_bits {
        constexpr uint32_t RSA_INT_MAP = (5 << 0);  ///< this register used to map rsa interrupt to one of core0's external interrupt
    }

    /// AES_INT_MAP Register bits
    namespace aes_int_map_bits {
        constexpr uint32_t AES_INT_MAP = (5 << 0);  ///< this register used to map aes interrupt to one of core0's external interrupt
    }

    /// SHA_INT_MAP Register bits
    namespace sha_int_map_bits {
        constexpr uint32_t SHA_INT_MAP = (5 << 0);  ///< this register used to map sha interrupt to one of core0's external interrupt
    }

    /// CPU_INTR_FROM_CPU_0_MAP Register bits
    namespace cpu_intr_from_cpu_0_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0_MAP = (5 << 0);  ///< this register used to map cpu_intr_from_cpu_0 interrupt to one of core0's external interrupt
    }

    /// CPU_INTR_FROM_CPU_1_MAP Register bits
    namespace cpu_intr_from_cpu_1_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1_MAP = (5 << 0);  ///< this register used to map cpu_intr_from_cpu_1 interrupt to one of core0's external interrupt
    }

    /// CPU_INTR_FROM_CPU_2_MAP Register bits
    namespace cpu_intr_from_cpu_2_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2_MAP = (5 << 0);  ///< this register used to map cpu_intr_from_cpu_2 interrupt to one of core0's external interrupt
    }

    /// CPU_INTR_FROM_CPU_3_MAP Register bits
    namespace cpu_intr_from_cpu_3_map_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3_MAP = (5 << 0);  ///< this register used to map cpu_intr_from_cpu_3 interrupt to one of core0's external interrupt
    }

    /// ASSIST_DEBUG_INTR_MAP Register bits
    namespace assist_debug_intr_map_bits {
        constexpr uint32_t ASSIST_DEBUG_INTR_MAP = (5 << 0);  ///< this register used to map assist_debug interrupt to one of core0's external interrupt
    }

    /// DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace dma_apbperi_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map dma_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_iram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core0_IRam0_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_dram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core0_DRam0_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_0_pif_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core0_PIF_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP Register bits
    namespace core_0_pif_pms_monitor_violate_size_intr_map_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP = (5 << 0);  ///< this register used to map core0_PIF_pms_monitor_violatile_size interrupt to one of core0's external interrupt
    }

    /// CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_1_iram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core1_IRam0_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_1_dram0_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core1_DRam0_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP Register bits
    namespace core_1_pif_pms_monitor_violate_intr_map_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map core1_PIF_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP Register bits
    namespace core_1_pif_pms_monitor_violate_size_intr_map_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP = (5 << 0);  ///< this register used to map core1_PIF_pms_monitor_violatile_size interrupt to one of core0's external interrupt
    }

    /// BACKUP_PMS_VIOLATE_INTR_MAP Register bits
    namespace backup_pms_violate_intr_map_bits {
        constexpr uint32_t BACKUP_PMS_VIOLATE_INTR_MAP = (5 << 0);  ///< this register used to map backup_pms_monitor_violatile interrupt to one of core0's external interrupt
    }

    /// CACHE_CORE0_ACS_INT_MAP Register bits
    namespace cache_core0_acs_int_map_bits {
        constexpr uint32_t CACHE_CORE0_ACS_INT_MAP = (5 << 0);  ///< this register used to map cache_core0_acs interrupt to one of core0's external interrupt
    }

    /// CACHE_CORE1_ACS_INT_MAP Register bits
    namespace cache_core1_acs_int_map_bits {
        constexpr uint32_t CACHE_CORE1_ACS_INT_MAP = (5 << 0);  ///< this register used to map cache_core1_acs interrupt to one of core0's external interrupt
    }

    /// USB_DEVICE_INT_MAP Register bits
    namespace usb_device_int_map_bits {
        constexpr uint32_t USB_DEVICE_INT_MAP = (5 << 0);  ///< this register used to map usb_device interrupt to one of core0's external interrupt
    }

    /// PERI_BACKUP_INT_MAP Register bits
    namespace peri_backup_int_map_bits {
        constexpr uint32_t PERI_BACKUP_INT_MAP = (5 << 0);  ///< this register used to map peri_backup interrupt to one of core0's external interrupt
    }

    /// DMA_EXTMEM_REJECT_INT_MAP Register bits
    namespace dma_extmem_reject_int_map_bits {
        constexpr uint32_t DMA_EXTMEM_REJECT_INT_MAP = (5 << 0);  ///< this register used to map dma_extmem_reject interrupt to one of core0's external interrupt
    }

    /// PRO_INTR_STATUS_0 Register bits
    namespace pro_intr_status_0_bits {
        constexpr uint32_t INTR_STATUS_0 = (32 << 0);  ///< this register store the status of the first 32 interrupt source
    }

    /// PRO_INTR_STATUS_1 Register bits
    namespace pro_intr_status_1_bits {
        constexpr uint32_t INTR_STATUS_1 = (32 << 0);  ///< this register store the status of the first 32 interrupt source
    }

    /// PRO_INTR_STATUS_2 Register bits
    namespace pro_intr_status_2_bits {
        constexpr uint32_t INTR_STATUS_2 = (32 << 0);  ///< this register store the status of the first 32 interrupt source
    }

    /// PRO_INTR_STATUS_3 Register bits
    namespace pro_intr_status_3_bits {
        constexpr uint32_t INTR_STATUS_3 = (32 << 0);  ///< this register store the status of the first 32 interrupt source
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< this register uesd to control clock-gating interupt martrix
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t INTERRUPT_REG_DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// IO Peripheral
// ============================================================================

namespace io {
    /// Base addresses
    constexpr uint32_t IO_MUX_BASE = 0x60009000;

    /// IO Register structure
    struct Registers {
        volatile uint32_t PIN_CTRL;  ///< Offset: 0x00 - Clock Output Configuration Register
        volatile uint32_t GPIO;  ///< Offset: 0x04 - IO MUX Configure Register for pad GPIO0 (renamed from GPIO)
        volatile uint32_t DATE;  ///< Offset: 0xFC - IO MUX Version Control Register
    };

    /// Peripheral instances
    inline Registers* IO_MUX = reinterpret_cast<Registers*>(IO_MUX_BASE);

    // Bit definitions
    /// PIN_CTRL Register bits
    namespace pin_ctrl_bits {
        constexpr uint32_t CLK_OUT1 = (4 << 0);  ///< If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT2 = (4 << 4);  ///< If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
        constexpr uint32_t CLK_OUT3 = (4 << 8);  ///< If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
    }

    /// GPIO Register bits
    namespace gpio_bits {
        constexpr uint32_t MCU_OE = (1U << 0);  ///< Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
        constexpr uint32_t SLP_SEL = (1U << 1);  ///< Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
        constexpr uint32_t MCU_WPD = (1U << 2);  ///< Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t MCU_WPU = (1U << 3);  ///< Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t MCU_IE = (1U << 4);  ///< Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_WPD = (1U << 7);  ///< Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-down disabled.
        constexpr uint32_t FUN_WPU = (1U << 8);  ///< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled.
        constexpr uint32_t FUN_IE = (1U << 9);  ///< Input enable of the pad. 1: input enabled; 0: input disabled.
        constexpr uint32_t FUN_DRV = (2 << 10);  ///< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
        constexpr uint32_t MCU_SEL = (3 << 12);  ///< Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function 2; etc.
        constexpr uint32_t FILTER_EN = (1U << 15);  ///< Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t REG_DATE = (28 << 0);  ///< Version control register
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_CAM_BASE = 0x60041000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t LCD_CLOCK;  ///< Offset: 0x00 - LCD clock register
        volatile uint32_t CAM_CTRL;  ///< Offset: 0x04 - Camera configuration register
        volatile uint32_t CAM_CTRL1;  ///< Offset: 0x08 - Camera configuration register
        volatile uint32_t CAM_RGB_YUV;  ///< Offset: 0x0C - Camera configuration register
        volatile uint32_t LCD_RGB_YUV;  ///< Offset: 0x10 - LCD configuration register
        volatile uint32_t LCD_USER;  ///< Offset: 0x14 - LCD configuration register
        volatile uint32_t LCD_MISC;  ///< Offset: 0x18 - LCD configuration register
        volatile uint32_t LCD_CTRL;  ///< Offset: 0x1C - LCD configuration register
        volatile uint32_t LCD_CTRL1;  ///< Offset: 0x20 - LCD configuration register
        volatile uint32_t LCD_CTRL2;  ///< Offset: 0x24 - LCD configuration register
        volatile uint32_t LCD_CMD_VAL;  ///< Offset: 0x28 - LCD configuration register
        volatile uint32_t LCD_DLY_MODE;  ///< Offset: 0x30 - LCD configuration register
        volatile uint32_t LCD_DATA_DOUT_MODE;  ///< Offset: 0x38 - LCD configuration register
        volatile uint32_t LC_DMA_INT_ENA;  ///< Offset: 0x64 - LCD_camera DMA inturrupt enable register
        volatile uint32_t LC_DMA_INT_RAW;  ///< Offset: 0x68 - LCD_camera DMA raw inturrupt status register
        volatile uint32_t LC_DMA_INT_ST;  ///< Offset: 0x6C - LCD_camera DMA masked inturrupt status register
        volatile uint32_t LC_DMA_INT_CLR;  ///< Offset: 0x70 - LCD_camera DMA inturrupt clear register
        volatile uint32_t LC_REG_DATE;  ///< Offset: 0xFC - Version register
    };

    /// Peripheral instances
    inline Registers* LCD_CAM = reinterpret_cast<Registers*>(LCD_CAM_BASE);

    // Bit definitions
    /// LCD_CLOCK Register bits
    namespace lcd_clock_bits {
        constexpr uint32_t LCD_CLKCNT_N = (6 << 0);  ///< f_LCD_PCLK = f_LCD_CLK / (reg_clkcnt_N + 1) when reg_clk_equ_sysclk is 0.
        constexpr uint32_t LCD_CLK_EQU_SYSCLK = (1U << 6);  ///< 1: f_LCD_PCLK = f_LCD_CLK. 0: f_LCD_PCLK = f_LCD_CLK / (reg_clkcnt_N + 1).
        constexpr uint32_t LCD_CK_IDLE_EDGE = (1U << 7);  ///< 1: LCD_PCLK line is high when idle 0: LCD_PCLK line is low when idle.
        constexpr uint32_t LCD_CK_OUT_EDGE = (1U << 8);  ///< 1: LCD_PCLK high in first half clock cycle. 0: LCD_PCLK low in first half clock cycle.
        constexpr uint32_t LCD_CLKM_DIV_NUM = (8 << 9);  ///< Integral LCD clock divider value
        constexpr uint32_t LCD_CLKM_DIV_B = (6 << 17);  ///< Fractional clock divider numerator value
        constexpr uint32_t LCD_CLKM_DIV_A = (6 << 23);  ///< Fractional clock divider denominator value
        constexpr uint32_t LCD_CLK_SEL = (2 << 29);  ///< Select LCD module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: no clock.
        constexpr uint32_t CLK_EN = (1U << 31);  ///< Set this bit to enable clk gate
    }

    /// CAM_CTRL Register bits
    namespace cam_ctrl_bits {
        constexpr uint32_t CAM_STOP_EN = (1U << 0);  ///< Camera stop enable signal, 1: camera stops when DMA Rx FIFO is full. 0: Not stop.
        constexpr uint32_t CAM_VSYNC_FILTER_THRES = (3 << 1);  ///< Filter threshold value for CAM_VSYNC signal.
        constexpr uint32_t CAM_UPDATE = (1U << 4);  ///< 1: Update Camera registers, will be cleared by hardware. 0 : Not care.
        constexpr uint32_t CAM_BYTE_ORDER = (1U << 5);  ///< 1: Change data bit order, change CAM_DATA_in[7:0] to CAM_DATA_in[0:7] in one byte mode, and bits[15:0] to bits[0:15] in two byte mode. 0: Not change.
        constexpr uint32_t CAM_BIT_ORDER = (1U << 6);  ///< 1: invert data byte order, only valid in 2 byte mode. 0: Not change.
        constexpr uint32_t CAM_LINE_INT_EN = (1U << 7);  ///< 1: Enable to generate CAM_HS_INT. 0: Disable.
        constexpr uint32_t CAM_VS_EOF_EN = (1U << 8);  ///< 1: CAM_VSYNC to generate in_suc_eof. 0: in_suc_eof is controlled by reg_cam_rec_data_cyclelen.
        constexpr uint32_t CAM_CLKM_DIV_NUM = (8 << 9);  ///< Integral Camera clock divider value
        constexpr uint32_t CAM_CLKM_DIV_B = (6 << 17);  ///< Fractional clock divider numerator value
        constexpr uint32_t CAM_CLKM_DIV_A = (6 << 23);  ///< Fractional clock divider denominator value
        constexpr uint32_t CAM_CLK_SEL = (2 << 29);  ///< Select Camera module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: no clock.
    }

    /// CAM_CTRL1 Register bits
    namespace cam_ctrl1_bits {
        constexpr uint32_t CAM_REC_DATA_BYTELEN = (16 << 0);  ///< Camera receive data byte length minus 1 to set DMA in_suc_eof_int.
        constexpr uint32_t CAM_LINE_INT_NUM = (6 << 16);  ///< The line number minus 1 to generate cam_hs_int.
        constexpr uint32_t CAM_CLK_INV = (1U << 22);  ///< 1: Invert the input signal CAM_PCLK. 0: Not invert.
        constexpr uint32_t CAM_VSYNC_FILTER_EN = (1U << 23);  ///< 1: Enable CAM_VSYNC filter function. 0: bypass.
        constexpr uint32_t CAM_2BYTE_EN = (1U << 24);  ///< 1: The bit number of input data is 9~16. 0: The bit number of input data is 0~8.
        constexpr uint32_t CAM_DE_INV = (1U << 25);  ///< CAM_DE invert enable signal, valid in high level.
        constexpr uint32_t CAM_HSYNC_INV = (1U << 26);  ///< CAM_HSYNC invert enable signal, valid in high level.
        constexpr uint32_t CAM_VSYNC_INV = (1U << 27);  ///< CAM_VSYNC invert enable signal, valid in high level.
        constexpr uint32_t CAM_VH_DE_MODE_EN = (1U << 28);  ///< 1: Input control signals are CAM_DE CAM_HSYNC and CAM_VSYNC is 1. 0: Input control signals are CAM_DE and CAM_VSYNC. CAM_HSYNC and CAM_DE are all 1 the the same time.
        constexpr uint32_t CAM_START = (1U << 29);  ///< Camera module start signal.
        constexpr uint32_t CAM_RESET = (1U << 30);  ///< Camera module reset signal.
        constexpr uint32_t CAM_AFIFO_RESET = (1U << 31);  ///< Camera AFIFO reset signal.
    }

    /// CAM_RGB_YUV Register bits
    namespace cam_rgb_yuv_bits {
        constexpr uint32_t CAM_CONV_8BITS_DATA_INV = (1U << 21);  ///< 1:invert every two 8bits input data. 2. disabled.
        constexpr uint32_t CAM_CONV_YUV2YUV_MODE = (2 << 22);  ///< 0: to yuv422. 1: to yuv420. 2: to yuv411. 3: disabled. To enable yuv2yuv mode, trans_mode must be set to 1.
        constexpr uint32_t CAM_CONV_YUV_MODE = (2 << 24);  ///< 0: yuv422. 1: yuv420. 2: yuv411. When in yuv2yuv mode, yuv_mode decides the yuv mode of Data_in
        constexpr uint32_t CAM_CONV_PROTOCOL_MODE = (1U << 26);  ///< 0:BT601. 1:BT709.
        constexpr uint32_t CAM_CONV_DATA_OUT_MODE = (1U << 27);  ///< LIMIT or FULL mode of Data out. 0: limit. 1: full
        constexpr uint32_t CAM_CONV_DATA_IN_MODE = (1U << 28);  ///< LIMIT or FULL mode of Data in. 0: limit. 1: full
        constexpr uint32_t CAM_CONV_MODE_8BITS_ON = (1U << 29);  ///< 0: 16bits mode. 1: 8bits mode.
        constexpr uint32_t CAM_CONV_TRANS_MODE = (1U << 30);  ///< 0: YUV to RGB. 1: RGB to YUV.
        constexpr uint32_t CAM_CONV_BYPASS = (1U << 31);  ///< 0: Bypass converter. 1: Enable converter.
    }

    /// LCD_RGB_YUV Register bits
    namespace lcd_rgb_yuv_bits {
        constexpr uint32_t LCD_CONV_8BITS_DATA_INV = (1U << 20);  ///< 1:invert every two 8bits input data. 2. disabled.
        constexpr uint32_t LCD_CONV_TXTORX = (1U << 21);  ///< 0: txtorx mode off. 1: txtorx mode on.
        constexpr uint32_t LCD_CONV_YUV2YUV_MODE = (2 << 22);  ///< 0: to yuv422. 1: to yuv420. 2: to yuv411. 3: disabled. To enable yuv2yuv mode, trans_mode must be set to 1.
        constexpr uint32_t LCD_CONV_YUV_MODE = (2 << 24);  ///< 0: yuv422. 1: yuv420. 2: yuv411. When in yuv2yuv mode, yuv_mode decides the yuv mode of Data_in
        constexpr uint32_t LCD_CONV_PROTOCOL_MODE = (1U << 26);  ///< 0:BT601. 1:BT709.
        constexpr uint32_t LCD_CONV_DATA_OUT_MODE = (1U << 27);  ///< LIMIT or FULL mode of Data out. 0: limit. 1: full
        constexpr uint32_t LCD_CONV_DATA_IN_MODE = (1U << 28);  ///< LIMIT or FULL mode of Data in. 0: limit. 1: full
        constexpr uint32_t LCD_CONV_MODE_8BITS_ON = (1U << 29);  ///< 0: 16bits mode. 1: 8bits mode.
        constexpr uint32_t LCD_CONV_TRANS_MODE = (1U << 30);  ///< 0: YUV to RGB. 1: RGB to YUV.
        constexpr uint32_t LCD_CONV_BYPASS = (1U << 31);  ///< 0: Bypass converter. 1: Enable converter.
    }

    /// LCD_USER Register bits
    namespace lcd_user_bits {
        constexpr uint32_t LCD_DOUT_CYCLELEN = (13 << 0);  ///< The output data cycles minus 1 of LCD module.
        constexpr uint32_t LCD_ALWAYS_OUT_EN = (1U << 13);  ///< LCD always output when LCD is in LCD_DOUT state, unless reg_lcd_start is cleared or reg_lcd_reset is set.
        constexpr uint32_t LCD_8BITS_ORDER = (1U << 19);  ///< 1: invert every two data byte, valid in 1 byte mode. 0: Not change.
        constexpr uint32_t LCD_UPDATE = (1U << 20);  ///< 1: Update LCD registers, will be cleared by hardware. 0 : Not care.
        constexpr uint32_t LCD_BIT_ORDER = (1U << 21);  ///< 1: Change data bit order, change LCD_DATA_out[7:0] to LCD_DATA_out[0:7] in one byte mode, and bits[15:0] to bits[0:15] in two byte mode. 0: Not change.
        constexpr uint32_t LCD_BYTE_ORDER = (1U << 22);  ///< 1: invert data byte order, only valid in 2 byte mode. 0: Not change.
        constexpr uint32_t LCD_2BYTE_EN = (1U << 23);  ///< 1: The bit number of output LCD data is 9~16. 0: The bit number of output LCD data is 0~8.
        constexpr uint32_t LCD_DOUT = (1U << 24);  ///< 1: Be able to send data out in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_DUMMY = (1U << 25);  ///< 1: Enable DUMMY phase in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_CMD = (1U << 26);  ///< 1: Be able to send command in LCD sequence when LCD starts. 0: Disable.
        constexpr uint32_t LCD_START = (1U << 27);  ///< LCD start sending data enable signal, valid in high level.
        constexpr uint32_t LCD_RESET = (1U << 28);  ///< The value of command.
        constexpr uint32_t LCD_DUMMY_CYCLELEN = (2 << 29);  ///< The dummy cycle length minus 1.
        constexpr uint32_t LCD_CMD_2_CYCLE_EN = (1U << 31);  ///< The cycle length of command phase. 1: 2 cycles. 0: 1 cycle.
    }

    /// LCD_MISC Register bits
    namespace lcd_misc_bits {
        constexpr uint32_t LCD_AFIFO_THRESHOLD_NUM = (5 << 1);  ///< The awfull threshold number of lcd_afifo.
        constexpr uint32_t LCD_VFK_CYCLELEN = (6 << 6);  ///< The setup cycle length minus 1 in LCD non-RGB mode.
        constexpr uint32_t LCD_VBK_CYCLELEN = (13 << 12);  ///< The vertical back blank region cycle length minus 1 in LCD RGB mode, or the hold time cycle length in LCD non-RGB mode.
        constexpr uint32_t LCD_NEXT_FRAME_EN = (1U << 25);  ///< 1: Send the next frame data when the current frame is sent out. 0: LCD stops when the current frame is sent out.
        constexpr uint32_t LCD_BK_EN = (1U << 26);  ///< 1: Enable blank region when LCD sends data out. 0: No blank region.
        constexpr uint32_t LCD_AFIFO_RESET = (1U << 27);  ///< LCD AFIFO reset signal.
        constexpr uint32_t LCD_CD_DATA_SET = (1U << 28);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_DOUT state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_DUMMY_SET = (1U << 29);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_DUMMY state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_CMD_SET = (1U << 30);  ///< 1: LCD_CD = !reg_cd_idle_edge when lcd_st[2:0] is in LCD_CMD state. 0: LCD_CD = reg_cd_idle_edge.
        constexpr uint32_t LCD_CD_IDLE_EDGE = (1U << 31);  ///< The default value of LCD_CD.
    }

    /// LCD_CTRL Register bits
    namespace lcd_ctrl_bits {
        constexpr uint32_t LCD_HB_FRONT = (11 << 0);  ///< It is the horizontal blank front porch of a frame.
        constexpr uint32_t LCD_VA_HEIGHT = (10 << 11);  ///< It is the vertical active height of a frame.
        constexpr uint32_t LCD_VT_HEIGHT = (10 << 21);  ///< It is the vertical total height of a frame.
        constexpr uint32_t LCD_RGB_MODE_EN = (1U << 31);  ///< 1: Enable reg mode input vsync, hsync, de. 0: Disable.
    }

    /// LCD_CTRL1 Register bits
    namespace lcd_ctrl1_bits {
        constexpr uint32_t LCD_VB_FRONT = (8 << 0);  ///< It is the vertical blank front porch of a frame.
        constexpr uint32_t LCD_HA_WIDTH = (12 << 8);  ///< It is the horizontal active width of a frame.
        constexpr uint32_t LCD_HT_WIDTH = (12 << 20);  ///< It is the horizontal total width of a frame.
    }

    /// LCD_CTRL2 Register bits
    namespace lcd_ctrl2_bits {
        constexpr uint32_t LCD_VSYNC_WIDTH = (7 << 0);  ///< It is the position of LCD_VSYNC active pulse in a line.
        constexpr uint32_t LCD_VSYNC_IDLE_POL = (1U << 7);  ///< It is the idle value of LCD_VSYNC.
        constexpr uint32_t LCD_DE_IDLE_POL = (1U << 8);  ///< It is the idle value of LCD_DE.
        constexpr uint32_t LCD_HS_BLANK_EN = (1U << 9);  ///< 1: The pulse of LCD_HSYNC is out in vertical blanking lines RGB mode. 0: LCD_HSYNC pulse is valid only in active region lines in RGB mode.
        constexpr uint32_t LCD_HSYNC_WIDTH = (7 << 16);  ///< It is the position of LCD_HSYNC active pulse in a line.
        constexpr uint32_t LCD_HSYNC_IDLE_POL = (1U << 23);  ///< It is the idle value of LCD_HSYNC.
        constexpr uint32_t LCD_HSYNC_POSITION = (8 << 24);  ///< It is the position of LCD_HSYNC active pulse in a line.
    }

    /// LCD_CMD_VAL Register bits
    namespace lcd_cmd_val_bits {
        constexpr uint32_t LCD_CMD_VALUE = (32 << 0);  ///< The LCD write command value.
    }

    /// LCD_DLY_MODE Register bits
    namespace lcd_dly_mode_bits {
        constexpr uint32_t LCD_CD_MODE = (2 << 0);  ///< The output LCD_CD is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_DE_MODE = (2 << 2);  ///< The output LCD_DE is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_HSYNC_MODE = (2 << 4);  ///< The output LCD_HSYNC is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t LCD_VSYNC_MODE = (2 << 6);  ///< The output LCD_VSYNC is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
    }

    /// LCD_DATA_DOUT_MODE Register bits
    namespace lcd_data_dout_mode_bits {
        constexpr uint32_t DOUT0_MODE = (2 << 0);  ///< The output data bit 0 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT1_MODE = (2 << 2);  ///< The output data bit 2 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT2_MODE = (2 << 4);  ///< The output data bit 4 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT3_MODE = (2 << 6);  ///< The output data bit 6 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT4_MODE = (2 << 8);  ///< The output data bit 8 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT5_MODE = (2 << 10);  ///< The output data bit 10 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT6_MODE = (2 << 12);  ///< The output data bit 12 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT7_MODE = (2 << 14);  ///< The output data bit 14 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT8_MODE = (2 << 16);  ///< The output data bit 16 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT9_MODE = (2 << 18);  ///< The output data bit 18 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT10_MODE = (2 << 20);  ///< The output data bit 20 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT11_MODE = (2 << 22);  ///< The output data bit 22 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT12_MODE = (2 << 24);  ///< The output data bit 24 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT13_MODE = (2 << 26);  ///< The output data bit 26 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT14_MODE = (2 << 28);  ///< The output data bit 28 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
        constexpr uint32_t DOUT15_MODE = (2 << 30);  ///< The output data bit 30 is delayed by module clock LCD_CLK. 0: output without delayed. 1: delay by the positive edge of LCD_CLK. 2: delay by the negative edge of LCD_CLK.
    }

    /// LC_DMA_INT_ENA Register bits
    namespace lc_dma_int_ena_bits {
        constexpr uint32_t LCD_VSYNC_INT_ENA = (1U << 0);  ///< The enable bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_ENA = (1U << 1);  ///< The enable bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_ENA = (1U << 2);  ///< The enable bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_ENA = (1U << 3);  ///< The enable bit for Camera line interrupt.
    }

    /// LC_DMA_INT_RAW Register bits
    namespace lc_dma_int_raw_bits {
        constexpr uint32_t LCD_VSYNC_INT_RAW = (1U << 0);  ///< The raw bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_RAW = (1U << 1);  ///< The raw bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_RAW = (1U << 2);  ///< The raw bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_RAW = (1U << 3);  ///< The raw bit for Camera line interrupt.
    }

    /// LC_DMA_INT_ST Register bits
    namespace lc_dma_int_st_bits {
        constexpr uint32_t LCD_VSYNC_INT_ST = (1U << 0);  ///< The status bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_ST = (1U << 1);  ///< The status bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_ST = (1U << 2);  ///< The status bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_ST = (1U << 3);  ///< The status bit for Camera transfer end interrupt.
    }

    /// LC_DMA_INT_CLR Register bits
    namespace lc_dma_int_clr_bits {
        constexpr uint32_t LCD_VSYNC_INT_CLR = (1U << 0);  ///< The clear bit for LCD frame end interrupt.
        constexpr uint32_t LCD_TRANS_DONE_INT_CLR = (1U << 1);  ///< The clear bit for lcd transfer end interrupt.
        constexpr uint32_t CAM_VSYNC_INT_CLR = (1U << 2);  ///< The clear bit for Camera frame end interrupt.
        constexpr uint32_t CAM_HS_INT_CLR = (1U << 3);  ///< The clear bit for Camera line interrupt.
    }

    /// LC_REG_DATE Register bits
    namespace lc_reg_date_bits {
        constexpr uint32_t LC_DATE = (28 << 0);  ///< LCD_CAM version control register
    }

}

// ============================================================================
// PWM Peripheral
// ============================================================================

namespace pwm {
    /// Base addresses
    constexpr uint32_t LEDC_BASE = 0x60019000;
    constexpr uint32_t MCPWM0_BASE = 0x6001E000;
    constexpr uint32_t MCPWM1_BASE = 0x6002C000;

    /// PWM Register structure
    struct Registers {
        volatile uint32_t CH_CONF0;  ///< Offset: 0x00 - Configuration register 0 for channel %s (renamed from CH_CONF0)
        volatile uint32_t CH_HPOINT;  ///< Offset: 0x04 - High point register for channel %s (renamed from CH_HPOINT)
        volatile uint32_t CH_DUTY;  ///< Offset: 0x08 - Initial duty cycle for channel %s (renamed from CH_DUTY)
        volatile uint32_t CH_CONF1;  ///< Offset: 0x0C - Configuration register 1 for channel %s (renamed from CH_CONF1)
        volatile uint32_t CH_DUTY_R;  ///< Offset: 0x10 - Current duty cycle for channel %s (renamed from CH_DUTY_R)
        volatile uint32_t TIMER_CONF;  ///< Offset: 0xA0 - Timer %s configuration (renamed from TIMER_CONF)
        volatile uint32_t TIMER_VALUE;  ///< Offset: 0xA4 - Timer %s current counter value (renamed from TIMER_VALUE)
        volatile uint32_t INT_RAW;  ///< Offset: 0xC0 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0xC4 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0xC8 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0xCC - Interrupt clear bits
        volatile uint32_t CONF;  ///< Offset: 0xD0 - Global ledc configuration register
        volatile uint32_t DATE;  ///< Offset: 0xFC - Version control register
    };

    /// Peripheral instances
    inline Registers* LEDC = reinterpret_cast<Registers*>(LEDC_BASE);
    inline Registers* MCPWM0 = reinterpret_cast<Registers*>(MCPWM0_BASE);
    inline Registers* MCPWM1 = reinterpret_cast<Registers*>(MCPWM1_BASE);

    // Bit definitions
    /// CH_CONF0 Register bits
    namespace ch_conf0_bits {
        constexpr uint32_t TIMER_SEL = (2 << 0);  ///< This field is used to select one of timers for channel %s. 0: select timer0 1: select timer1 2: select timer2 3: select timer3
        constexpr uint32_t SIG_OUT_EN = (1U << 2);  ///< Set this bit to enable signal output on channel %s.
        constexpr uint32_t IDLE_LV = (1U << 3);  ///< This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
        constexpr uint32_t PARA_UP = (1U << 4);  ///< This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
        constexpr uint32_t OVF_NUM = (10 << 5);  ///< This register is used to configure the maximum times of overflow minus 1. The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
        constexpr uint32_t OVF_CNT_EN = (1U << 15);  ///< This bit is used to enable the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET = (1U << 16);  ///< Set this bit to reset the ovf_cnt of channel %s.
        constexpr uint32_t OVF_CNT_RESET_ST = (1U << 17);  ///< This is the status bit of LEDC_OVF_CNT_RESET_CH%s.
    }

    /// CH_HPOINT Register bits
    namespace ch_hpoint_bits {
        constexpr uint32_t HPOINT = (14 << 0);  ///< The output value changes to high when the selected timers has reached the value specified by this register.
    }

    /// CH_DUTY Register bits
    namespace ch_duty_bits {
        constexpr uint32_t DUTY = (19 << 0);  ///< This register is used to change the output duty by controlling the Lpoint. The output value turns to low when the selected timers has reached the Lpoint.
    }

    /// CH_CONF1 Register bits
    namespace ch_conf1_bits {
        constexpr uint32_t DUTY_SCALE = (10 << 0);  ///< This register is used to configure the changing step scale of duty on channel %s.
        constexpr uint32_t DUTY_CYCLE = (10 << 10);  ///< The duty will change every LEDC_DUTY_CYCLE_CH%s on channel %s.
        constexpr uint32_t DUTY_NUM = (10 << 20);  ///< This register is used to control the number of times the duty cycle will be changed.
        constexpr uint32_t DUTY_INC = (1U << 30);  ///< This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase; 0: Decrease.
        constexpr uint32_t DUTY_START = (1U << 31);  ///< Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
    }

    /// CH_DUTY_R Register bits
    namespace ch_duty_r_bits {
        constexpr uint32_t DUTY_R = (19 << 0);  ///< This register stores the current duty of output signal on channel %s.
    }

    /// TIMER_CONF Register bits
    namespace timer_conf_bits {
        constexpr uint32_t DUTY_RES = (4 << 0);  ///< This register is used to control the range of the counter in timer %s.
        constexpr uint32_t CLK_DIV = (18 << 4);  ///< This register is used to configure the divisor for the divider in timer %s. The least significant eight bits represent the fractional part.
        constexpr uint32_t PAUSE = (1U << 22);  ///< This bit is used to suspend the counter in timer %s.
        constexpr uint32_t RST = (1U << 23);  ///< This bit is used to reset timer %s. The counter will show 0 after reset.
        constexpr uint32_t TICK_SEL = (1U << 24);  ///< This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate. 1'h0: SLOW_CLK 1'h1: REF_TICK
        constexpr uint32_t PARA_UP = (1U << 25);  ///< Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
    }

    /// TIMER_VALUE Register bits
    namespace timer_value_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< This register stores the current counter value of timer %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TIMER0_OVF_INT_RAW = (1U << 0);  ///< Triggered when the timer0 has reached its maximum counter value.
        constexpr uint32_t TIMER1_OVF_INT_RAW = (1U << 1);  ///< Triggered when the timer1 has reached its maximum counter value.
        constexpr uint32_t TIMER2_OVF_INT_RAW = (1U << 2);  ///< Triggered when the timer2 has reached its maximum counter value.
        constexpr uint32_t TIMER3_OVF_INT_RAW = (1U << 3);  ///< Triggered when the timer3 has reached its maximum counter value.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_RAW = (1U << 4);  ///< Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_RAW = (1U << 5);  ///< Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_RAW = (1U << 6);  ///< Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_RAW = (1U << 7);  ///< Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_RAW = (1U << 8);  ///< Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_RAW = (1U << 9);  ///< Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_RAW = (1U << 10);  ///< Interrupt raw bit for channel 6. Triggered when the gradual change of duty has finished.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_RAW = (1U << 11);  ///< Interrupt raw bit for channel 7. Triggered when the gradual change of duty has finished.
        constexpr uint32_t OVF_CNT_CH0_INT_RAW = (1U << 12);  ///< Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
        constexpr uint32_t OVF_CNT_CH1_INT_RAW = (1U << 13);  ///< Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
        constexpr uint32_t OVF_CNT_CH2_INT_RAW = (1U << 14);  ///< Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
        constexpr uint32_t OVF_CNT_CH3_INT_RAW = (1U << 15);  ///< Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
        constexpr uint32_t OVF_CNT_CH4_INT_RAW = (1U << 16);  ///< Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
        constexpr uint32_t OVF_CNT_CH5_INT_RAW = (1U << 17);  ///< Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
        constexpr uint32_t OVF_CNT_CH6_INT_RAW = (1U << 18);  ///< Interrupt raw bit for channel 6. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH6.
        constexpr uint32_t OVF_CNT_CH7_INT_RAW = (1U << 19);  ///< Interrupt raw bit for channel 7. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH7.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TIMER0_OVF_INT_ST = (1U << 0);  ///< This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER1_OVF_INT_ST = (1U << 1);  ///< This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER2_OVF_INT_ST = (1U << 2);  ///< This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
        constexpr uint32_t TIMER3_OVF_INT_ST = (1U << 3);  ///< This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ST = (1U << 4);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ST = (1U << 5);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ST = (1U << 6);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ST = (1U << 7);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ST = (1U << 8);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ST = (1U << 9);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ST = (1U << 10);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH6_INT interrupt when LEDC_DUTY_CHNG_END_CH6_INT_ENAIS set to 1.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ST = (1U << 11);  ///< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH7_INT interrupt when LEDC_DUTY_CHNG_END_CH7_INT_ENAIS set to 1.
        constexpr uint32_t OVF_CNT_CH0_INT_ST = (1U << 12);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH1_INT_ST = (1U << 13);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH2_INT_ST = (1U << 14);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH3_INT_ST = (1U << 15);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH4_INT_ST = (1U << 16);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH5_INT_ST = (1U << 17);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH6_INT_ST = (1U << 18);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH6_INT interrupt when LEDC_OVF_CNT_CH6_INT_ENA is set to 1.
        constexpr uint32_t OVF_CNT_CH7_INT_ST = (1U << 19);  ///< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH7_INT interrupt when LEDC_OVF_CNT_CH7_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TIMER0_OVF_INT_ENA = (1U << 0);  ///< The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_ENA = (1U << 1);  ///< The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_ENA = (1U << 2);  ///< The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_ENA = (1U << 3);  ///< The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_ENA = (1U << 4);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_ENA = (1U << 5);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_ENA = (1U << 6);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_ENA = (1U << 7);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_ENA = (1U << 8);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_ENA = (1U << 9);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_ENA = (1U << 10);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH6_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_ENA = (1U << 11);  ///< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH7_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_ENA = (1U << 12);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_ENA = (1U << 13);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_ENA = (1U << 14);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_ENA = (1U << 15);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_ENA = (1U << 16);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_ENA = (1U << 17);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH6_INT_ENA = (1U << 18);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH6_INT interrupt.
        constexpr uint32_t OVF_CNT_CH7_INT_ENA = (1U << 19);  ///< The interrupt enable bit for the LEDC_OVF_CNT_CH7_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TIMER0_OVF_INT_CLR = (1U << 0);  ///< Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
        constexpr uint32_t TIMER1_OVF_INT_CLR = (1U << 1);  ///< Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
        constexpr uint32_t TIMER2_OVF_INT_CLR = (1U << 2);  ///< Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
        constexpr uint32_t TIMER3_OVF_INT_CLR = (1U << 3);  ///< Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH0_INT_CLR = (1U << 4);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH1_INT_CLR = (1U << 5);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH2_INT_CLR = (1U << 6);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH3_INT_CLR = (1U << 7);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH4_INT_CLR = (1U << 8);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH5_INT_CLR = (1U << 9);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH6_INT_CLR = (1U << 10);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH6_INT interrupt.
        constexpr uint32_t DUTY_CHNG_END_CH7_INT_CLR = (1U << 11);  ///< Set this bit to clear the LEDC_DUTY_CHNG_END_CH7_INT interrupt.
        constexpr uint32_t OVF_CNT_CH0_INT_CLR = (1U << 12);  ///< Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
        constexpr uint32_t OVF_CNT_CH1_INT_CLR = (1U << 13);  ///< Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
        constexpr uint32_t OVF_CNT_CH2_INT_CLR = (1U << 14);  ///< Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
        constexpr uint32_t OVF_CNT_CH3_INT_CLR = (1U << 15);  ///< Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
        constexpr uint32_t OVF_CNT_CH4_INT_CLR = (1U << 16);  ///< Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
        constexpr uint32_t OVF_CNT_CH5_INT_CLR = (1U << 17);  ///< Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
        constexpr uint32_t OVF_CNT_CH6_INT_CLR = (1U << 18);  ///< Set this bit to clear the LEDC_OVF_CNT_CH6_INT interrupt.
        constexpr uint32_t OVF_CNT_CH7_INT_CLR = (1U << 19);  ///< Set this bit to clear the LEDC_OVF_CNT_CH7_INT interrupt.
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t APB_CLK_SEL = (2 << 0);  ///< This bit is used to select clock source for the 4 timers . 2'd1: APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK
        constexpr uint32_t CLK_EN = (1U << 31);  ///< This bit is used to control clock. 1'b1: Force clock on for register. 1'h0: Support clock only when application writes registers.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// PCNT Peripheral
// ============================================================================

namespace pcnt {
    /// Base addresses
    constexpr uint32_t PCNT_BASE = 0x60017000;

    /// PCNT Register structure
    struct Registers {
        volatile uint32_t U_CONF0;  ///< Offset: 0x00 - Configuration register 0 for unit %s (renamed from U_CONF0)
        volatile uint32_t U_CONF1;  ///< Offset: 0x04 - Configuration register 1 for unit %s (renamed from U_CONF1)
        volatile uint32_t U_CONF2;  ///< Offset: 0x08 - Configuration register 2 for unit %s (renamed from U_CONF2)
        volatile uint32_t U_CNT;  ///< Offset: 0x30 - Counter value for unit %s (renamed from U_CNT)
        volatile uint32_t INT_RAW;  ///< Offset: 0x40 - Interrupt raw status register
        volatile uint32_t INT_ST;  ///< Offset: 0x44 - Interrupt status register
        volatile uint32_t INT_ENA;  ///< Offset: 0x48 - Interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0x4C - Interrupt clear register
        volatile uint32_t U_STATUS;  ///< Offset: 0x50 - PNCT UNIT%s status register (renamed from U_STATUS)
        volatile uint32_t CTRL;  ///< Offset: 0x60 - Control register for all counters
        volatile uint32_t DATE;  ///< Offset: 0xFC - PCNT version control register
    };

    /// Peripheral instances
    inline Registers* PCNT = reinterpret_cast<Registers*>(PCNT_BASE);

    // Bit definitions
    /// U_CONF0 Register bits
    namespace u_conf0_bits {
        constexpr uint32_t FILTER_THRES = (10 << 0);  ///< This sets the maximum threshold, in APB_CLK cycles, for the filter. Any pulses with width less than this will be ignored when the filter is enabled.
        constexpr uint32_t FILTER_EN = (1U << 10);  ///< This is the enable bit for unit %s's input filter.
        constexpr uint32_t THR_ZERO_EN = (1U << 11);  ///< This is the enable bit for unit %s's zero comparator.
        constexpr uint32_t THR_H_LIM_EN = (1U << 12);  ///< This is the enable bit for unit %s's thr_h_lim comparator.
        constexpr uint32_t THR_L_LIM_EN = (1U << 13);  ///< This is the enable bit for unit %s's thr_l_lim comparator.
        constexpr uint32_t THR_THRES0_EN = (1U << 14);  ///< This is the enable bit for unit %s's thres0 comparator.
        constexpr uint32_t THR_THRES1_EN = (1U << 15);  ///< This is the enable bit for unit %s's thres1 comparator.
        constexpr uint32_t CH0_NEG_MODE = (2 << 16);  ///< This register sets the behavior when the signal input of channel 0 detects a negative edge. 1: Increase the counter;2: Decrease the counter;0, 3: No effect on counter
        constexpr uint32_t CH0_POS_MODE = (2 << 18);  ///< This register sets the behavior when the signal input of channel 0 detects a positive edge. 1: Increase the counter;2: Decrease the counter;0, 3: No effect on counter
        constexpr uint32_t CH0_HCTRL_MODE = (2 << 20);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification;1: Invert behavior (increase -> decrease, decrease -> increase);2, 3: Inhibit counter modification
        constexpr uint32_t CH0_LCTRL_MODE = (2 << 22);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification;1: Invert behavior (increase -> decrease, decrease -> increase);2, 3: Inhibit counter modification
        constexpr uint32_t CH1_NEG_MODE = (2 << 24);  ///< This register sets the behavior when the signal input of channel 1 detects a negative edge. 1: Increment the counter;2: Decrement the counter;0, 3: No effect on counter
        constexpr uint32_t CH1_POS_MODE = (2 << 26);  ///< This register sets the behavior when the signal input of channel 1 detects a positive edge. 1: Increment the counter;2: Decrement the counter;0, 3: No effect on counter
        constexpr uint32_t CH1_HCTRL_MODE = (2 << 28);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high. 0: No modification;1: Invert behavior (increase -> decrease, decrease -> increase);2, 3: Inhibit counter modification
        constexpr uint32_t CH1_LCTRL_MODE = (2 << 30);  ///< This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low. 0: No modification;1: Invert behavior (increase -> decrease, decrease -> increase);2, 3: Inhibit counter modification
    }

    /// U_CONF1 Register bits
    namespace u_conf1_bits {
        constexpr uint32_t CNT_THRES0 = (16 << 0);  ///< This register is used to configure the thres0 value for unit %s.
        constexpr uint32_t CNT_THRES1 = (16 << 16);  ///< This register is used to configure the thres1 value for unit %s.
    }

    /// U_CONF2 Register bits
    namespace u_conf2_bits {
        constexpr uint32_t CNT_H_LIM = (16 << 0);  ///< This register is used to configure the thr_h_lim value for unit %s.
        constexpr uint32_t CNT_L_LIM = (16 << 16);  ///< This register is used to configure the thr_l_lim value for unit %s.
    }

    /// U_CNT Register bits
    namespace u_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< This register stores the current pulse count value for unit %s.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CNT_THR_EVENT_U0 = (1U << 0);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U1 = (1U << 1);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U2 = (1U << 2);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
        constexpr uint32_t CNT_THR_EVENT_U3 = (1U << 3);  ///< Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
    }

    /// U_STATUS Register bits
    namespace u_status_bits {
        constexpr uint32_t ZERO_MODE = (2 << 0);  ///< The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
        constexpr uint32_t THRES1 = (1U << 2);  ///< The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
        constexpr uint32_t THRES0 = (1U << 3);  ///< The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
        constexpr uint32_t L_LIM = (1U << 4);  ///< The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
        constexpr uint32_t H_LIM = (1U << 5);  ///< The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
        constexpr uint32_t ZERO = (1U << 6);  ///< The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CNT_RST_U0 = (1U << 0);  ///< Set this bit to clear unit 0's counter.
        constexpr uint32_t CNT_PAUSE_U0 = (1U << 1);  ///< Set this bit to freeze unit 0's counter.
        constexpr uint32_t CNT_RST_U1 = (1U << 2);  ///< Set this bit to clear unit 1's counter.
        constexpr uint32_t CNT_PAUSE_U1 = (1U << 3);  ///< Set this bit to freeze unit 1's counter.
        constexpr uint32_t CNT_RST_U2 = (1U << 4);  ///< Set this bit to clear unit 2's counter.
        constexpr uint32_t CNT_PAUSE_U2 = (1U << 5);  ///< Set this bit to freeze unit 2's counter.
        constexpr uint32_t CNT_RST_U3 = (1U << 6);  ///< Set this bit to clear unit 3's counter.
        constexpr uint32_t CNT_PAUSE_U3 = (1U << 7);  ///< Set this bit to freeze unit 3's counter.
        constexpr uint32_t CLK_EN = (1U << 16);  ///< The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the PCNT version control register.
    }

}

// ============================================================================
// PERI Peripheral
// ============================================================================

namespace peri {
    /// Base addresses
    constexpr uint32_t PERI_BACKUP_BASE = 0x6002A000;

    /// PERI Register structure
    struct Registers {
        volatile uint32_t CONFIG;  ///< Offset: 0x00 - x
        volatile uint32_t APB_ADDR;  ///< Offset: 0x04 - x
        volatile uint32_t MEM_ADDR;  ///< Offset: 0x08 - x
        volatile uint32_t REG_MAP0;  ///< Offset: 0x0C - x
        volatile uint32_t REG_MAP1;  ///< Offset: 0x10 - x
        volatile uint32_t REG_MAP2;  ///< Offset: 0x14 - x
        volatile uint32_t REG_MAP3;  ///< Offset: 0x18 - x
        volatile uint32_t INT_RAW;  ///< Offset: 0x1C - x
        volatile uint32_t INT_ST;  ///< Offset: 0x20 - x
        volatile uint32_t INT_ENA;  ///< Offset: 0x24 - x
        volatile uint32_t INT_CLR;  ///< Offset: 0x28 - x
        volatile uint32_t DATE;  ///< Offset: 0xFC - x
    };

    /// Peripheral instances
    inline Registers* PERI_BACKUP = reinterpret_cast<Registers*>(PERI_BACKUP_BASE);

    // Bit definitions
    /// CONFIG Register bits
    namespace config_bits {
        constexpr uint32_t FLOW_ERR = (3 << 0);  ///< x
        constexpr uint32_t ADDR_MAP_MODE = (1U << 3);  ///< x
        constexpr uint32_t BURST_LIMIT = (5 << 4);  ///< x
        constexpr uint32_t TOUT_THRES = (10 << 9);  ///< x
        constexpr uint32_t SIZE = (10 << 19);  ///< x
        constexpr uint32_t START = (1U << 29);  ///< x
        constexpr uint32_t TO_MEM = (1U << 30);  ///< x
        constexpr uint32_t ENA = (1U << 31);  ///< x
    }

    /// APB_ADDR Register bits
    namespace apb_addr_bits {
        constexpr uint32_t APB_START_ADDR = (32 << 0);  ///< x
    }

    /// MEM_ADDR Register bits
    namespace mem_addr_bits {
        constexpr uint32_t MEM_START_ADDR = (32 << 0);  ///< x
    }

    /// REG_MAP0 Register bits
    namespace reg_map0_bits {
        constexpr uint32_t MAP0 = (32 << 0);  ///< x
    }

    /// REG_MAP1 Register bits
    namespace reg_map1_bits {
        constexpr uint32_t MAP1 = (32 << 0);  ///< x
    }

    /// REG_MAP2 Register bits
    namespace reg_map2_bits {
        constexpr uint32_t MAP2 = (32 << 0);  ///< x
    }

    /// REG_MAP3 Register bits
    namespace reg_map3_bits {
        constexpr uint32_t MAP3 = (32 << 0);  ///< x
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t DONE_INT_RAW = (1U << 0);  ///< x
        constexpr uint32_t ERR_INT_RAW = (1U << 1);  ///< x
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t DONE_INT_ST = (1U << 0);  ///< x
        constexpr uint32_t ERR_INT_ST = (1U << 1);  ///< x
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t DONE_INT_ENA = (1U << 0);  ///< x
        constexpr uint32_t ERR_INT_ENA = (1U << 1);  ///< x
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t DONE_INT_CLR = (1U << 0);  ///< x
        constexpr uint32_t ERR_INT_CLR = (1U << 1);  ///< x
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< x
        constexpr uint32_t CLK_EN = (1U << 31);  ///< register file clk gating
    }

}

// ============================================================================
// RMT Peripheral
// ============================================================================

namespace rmt {
    /// Base addresses
    constexpr uint32_t RMT_BASE = 0x60016000;

    /// RMT Register structure
    struct Registers {
        volatile uint32_t CHDATA;  ///< Offset: 0x00 - The read and write data register for CHANNEL%s by apb... (renamed from CHDATA)
        volatile uint32_t CH_TX_CONF0;  ///< Offset: 0x20 - Channel %s configure register 0 (renamed from CH_TX_CONF0)
        volatile uint32_t CH_RX_CONF0;  ///< Offset: 0x30 - Channel %s configure register 0 (renamed from CH_RX_CONF0)
        volatile uint32_t CH_RX_CONF1;  ///< Offset: 0x34 - Channel %s configure register 1 (renamed from CH_RX_CONF1)
        volatile uint32_t CH_TX_STATUS;  ///< Offset: 0x50 - Channel %s status register (renamed from CH_TX_STATUS)
        volatile uint32_t CH_RX_STATUS;  ///< Offset: 0x60 - Channel %s status register (renamed from CH_RX_STATUS)
        volatile uint32_t INT_RAW;  ///< Offset: 0x70 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x74 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x78 - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x7C - Interrupt clear bits
        volatile uint32_t CHCARRIER_DUTY;  ///< Offset: 0x80 - Channel %s duty cycle configuration register (renamed from CHCARRIER_DUTY)
        volatile uint32_t CH_RX_CARRIER_RM;  ///< Offset: 0x90 - Channel %s carrier remove register (renamed from CH_RX_CARRIER_RM)
        volatile uint32_t CH_TX_LIM;  ///< Offset: 0xA0 - Channel %s Tx event configuration register (renamed from CH_TX_LIM)
        volatile uint32_t CH_RX_LIM;  ///< Offset: 0xB0 - Channel %s Rx event configuration register (renamed from CH_RX_LIM)
        volatile uint32_t SYS_CONF;  ///< Offset: 0xC0 - RMT apb configuration register
        volatile uint32_t TX_SIM;  ///< Offset: 0xC4 - RMT TX synchronous register
        volatile uint32_t REF_CNT_RST;  ///< Offset: 0xC8 - RMT clock divider reset register
        volatile uint32_t DATE;  ///< Offset: 0xCC - RMT version register
    };

    /// Peripheral instances
    inline Registers* RMT = reinterpret_cast<Registers*>(RMT_BASE);

    // Bit definitions
    /// CHDATA Register bits
    namespace chdata_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Read and write data for channel %s via APB FIFO.
    }

    /// CH_TX_CONF0 Register bits
    namespace ch_tx_conf0_bits {
        constexpr uint32_t TX_START = (1U << 0);  ///< Set this bit to start sending data on CHANNEL%s.
        constexpr uint32_t MEM_RD_RST = (1U << 1);  ///< Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t TX_CONTI_MODE = (1U << 3);  ///< Set this bit to restart transmission from the first data to the last data in CHANNEL%s.
        constexpr uint32_t MEM_TX_WRAP_EN = (1U << 4);  ///< This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
        constexpr uint32_t IDLE_OUT_LV = (1U << 5);  ///< This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
        constexpr uint32_t IDLE_OUT_EN = (1U << 6);  ///< This is the output enable-control bit for CHANNEL%s in IDLE state.
        constexpr uint32_t TX_STOP = (1U << 7);  ///< Set this bit to stop the transmitter of CHANNEL%s sending data out.
        constexpr uint32_t DIV_CNT = (8 << 8);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t MEM_SIZE = (4 << 16);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EFF_EN = (1U << 20);  ///< 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
        constexpr uint32_t CARRIER_EN = (1U << 21);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 22);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s. 1'h0: add carrier wave on low level. 1'h1: add carrier wave on high level.
        constexpr uint32_t AFIFO_RST = (1U << 23);  ///< Reserved
        constexpr uint32_t CONF_UPDATE = (1U << 24);  ///< synchronization bit for CHANNEL%s
    }

    /// CH_RX_CONF0 Register bits
    namespace ch_rx_conf0_bits {
        constexpr uint32_t DIV_CNT = (8 << 0);  ///< This register is used to configure the divider for clock of CHANNEL%s.
        constexpr uint32_t IDLE_THRES = (15 << 8);  ///< When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
        constexpr uint32_t MEM_SIZE = (4 << 24);  ///< This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        constexpr uint32_t CARRIER_EN = (1U << 28);  ///< This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        constexpr uint32_t CARRIER_OUT_LV = (1U << 29);  ///< This bit is used to configure the position of carrier wave for CHANNEL%s. 1'h0: add carrier wave on low level. 1'h1: add carrier wave on high level.
    }

    /// CH_RX_CONF1 Register bits
    namespace ch_rx_conf1_bits {
        constexpr uint32_t RX_EN = (1U << 0);  ///< Set this bit to enable receiver to receive data on CHANNEL%s.
        constexpr uint32_t MEM_WR_RST = (1U << 1);  ///< Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
        constexpr uint32_t APB_MEM_RST = (1U << 2);  ///< Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        constexpr uint32_t MEM_OWNER = (1U << 3);  ///< This register marks the ownership of CHANNEL%s's ram block. 1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
        constexpr uint32_t RX_FILTER_EN = (1U << 4);  ///< This is the receive filter's enable bit for CHANNEL%s.
        constexpr uint32_t RX_FILTER_THRES = (8 << 5);  ///< Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
        constexpr uint32_t MEM_RX_WRAP_EN = (1U << 13);  ///< This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
        constexpr uint32_t AFIFO_RST = (1U << 14);  ///< Reserved
        constexpr uint32_t CONF_UPDATE = (1U << 15);  ///< synchronization bit for CHANNEL%s
    }

    /// CH_TX_STATUS Register bits
    namespace ch_tx_status_bits {
        constexpr uint32_t MEM_RADDR_EX = (10 << 0);  ///< This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
        constexpr uint32_t APB_MEM_WADDR = (10 << 11);  ///< This register records the memory address offset when writes RAM over APB bus.
        constexpr uint32_t STATE = (3 << 22);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_EMPTY = (1U << 25);  ///< This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
        constexpr uint32_t APB_MEM_WR_ERR = (1U << 26);  ///< This status bit will be set if the offset address out of memory size when writes via APB bus.
    }

    /// CH_RX_STATUS Register bits
    namespace ch_rx_status_bits {
        constexpr uint32_t MEM_WADDR_EX = (10 << 0);  ///< This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
        constexpr uint32_t APB_MEM_RADDR = (10 << 11);  ///< This register records the memory address offset when reads RAM over APB bus.
        constexpr uint32_t STATE = (3 << 22);  ///< This register records the FSM status of CHANNEL%s.
        constexpr uint32_t MEM_OWNER_ERR = (1U << 25);  ///< This status bit will be set when the ownership of memory block is wrong.
        constexpr uint32_t MEM_FULL = (1U << 26);  ///< This status bit will be set if the receiver receives more data than the memory size.
        constexpr uint32_t APB_MEM_RD_ERR = (1U << 27);  ///< This status bit will be set if the offset address out of memory size when reads via APB bus.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmission done. (renamed from CH_TX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< The interrupt raw bit for CHANNEL%s. Triggered when error occurs. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value. (renamed from CH_TX_LOOP)
        constexpr uint32_t CH_RX_END = (1U << 16);  ///< The interrupt raw bit for CHANNEL4. Triggered when reception done. (renamed from CH_RX_END)
        constexpr uint32_t CH_RX_ERR = (1U << 20);  ///< The interrupt raw bit for CHANNEL4. Triggered when error occurs. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 24);  ///< The interrupt raw bit for CHANNEL4. Triggered when receiver receive more data than configured value. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL = (1U << 28);  ///< The interrupt raw bit for CHANNEL3. Triggered when dma accessing CHANNEL3 fails.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL = (1U << 29);  ///< The interrupt raw bit for CHANNEL7. Triggered when dma accessing CHANNEL7 fails.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< The masked interrupt status bit for CH%s_TX_END_INT. (renamed from CH_TX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< The masked interrupt status bit for CH%s_ERR_INT. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< The masked interrupt status bit for CH%s_TX_THR_EVENT_INT. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< The masked interrupt status bit for CH%s_TX_LOOP_INT. (renamed from CH_TX_LOOP)
        constexpr uint32_t CH_RX_END = (1U << 16);  ///< The masked interrupt status bit for CH4_RX_END_INT. (renamed from CH_RX_END)
        constexpr uint32_t CH_RX_ERR = (1U << 20);  ///< The masked interrupt status bit for CH4_ERR_INT. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 24);  ///< The masked interrupt status bit for CH4_RX_THR_EVENT_INT. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL = (1U << 28);  ///< The masked interrupt status bit for CH3_DMA_ACCESS_FAIL_INT.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL = (1U << 29);  ///< The masked interrupt status bit for CH7_DMA_ACCESS_FAIL_INT.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< The interrupt enable bit for CH%s_TX_END_INT. (renamed from CH_TX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< The interrupt enable bit for CH%s_ERR_INT. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< The interrupt enable bit for CH%s_TX_THR_EVENT_INT. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< The interrupt enable bit for CH%s_TX_LOOP_INT. (renamed from CH_TX_LOOP)
        constexpr uint32_t CH_RX_END = (1U << 16);  ///< The interrupt enable bit for CH4_RX_END_INT. (renamed from CH_RX_END)
        constexpr uint32_t CH_RX_ERR = (1U << 20);  ///< The interrupt enable bit for CH4_ERR_INT. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 24);  ///< The interrupt enable bit for CH4_RX_THR_EVENT_INT. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL = (1U << 28);  ///< The interrupt enable bit for CH3_DMA_ACCESS_FAIL_INT.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL = (1U << 29);  ///< The interrupt enable bit for CH7_DMA_ACCESS_FAIL_INT.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t CH_TX_END = (1U << 0);  ///< Set this bit to clear theCH%s_TX_END_INT interrupt. (renamed from CH_TX_END)
        constexpr uint32_t CH_TX_ERR = (1U << 4);  ///< Set this bit to clear theCH%s_ERR_INT interrupt. (renamed from CH_TX_ERR)
        constexpr uint32_t CH_TX_THR_EVENT = (1U << 8);  ///< Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt. (renamed from CH_TX_THR_EVENT)
        constexpr uint32_t CH_TX_LOOP = (1U << 12);  ///< Set this bit to clear theCH%s_TX_LOOP_INT interrupt. (renamed from CH_TX_LOOP)
        constexpr uint32_t CH_RX_END = (1U << 16);  ///< Set this bit to clear theCH4_RX_END_INT interrupt. (renamed from CH_RX_END)
        constexpr uint32_t CH_RX_ERR = (1U << 20);  ///< Set this bit to clear theCH4_ERR_INT interrupt. (renamed from CH_RX_ERR)
        constexpr uint32_t CH_RX_THR_EVENT = (1U << 24);  ///< Set this bit to clear theCH4_RX_THR_EVENT_INT interrupt. (renamed from CH_RX_THR_EVENT)
        constexpr uint32_t TX_CH3_DMA_ACCESS_FAIL = (1U << 28);  ///< Set this bit to clear the CH3_DMA_ACCESS_FAIL_INT interrupt.
        constexpr uint32_t RX_CH7_DMA_ACCESS_FAIL = (1U << 29);  ///< Set this bit to clear the CH7_DMA_ACCESS_FAIL_INT interrupt.
    }

    /// CHCARRIER_DUTY Register bits
    namespace chcarrier_duty_bits {
        constexpr uint32_t CARRIER_LOW = (16 << 0);  ///< This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
        constexpr uint32_t CARRIER_HIGH = (16 << 16);  ///< This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
    }

    /// CH_RX_CARRIER_RM Register bits
    namespace ch_rx_carrier_rm_bits {
        constexpr uint32_t CARRIER_LOW_THRES = (16 << 0);  ///< The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
        constexpr uint32_t CARRIER_HIGH_THRES = (16 << 16);  ///< The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
    }

    /// CH_TX_LIM Register bits
    namespace ch_tx_lim_bits {
        constexpr uint32_t TX_LIM = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can send out.
        constexpr uint32_t TX_LOOP_NUM = (10 << 9);  ///< This register is used to configure the maximum loop count when tx_conti_mode is valid.
        constexpr uint32_t TX_LOOP_CNT_EN = (1U << 19);  ///< This register is the enabled bit for loop count.
        constexpr uint32_t LOOP_COUNT_RESET = (1U << 20);  ///< This register is used to reset the loop count when tx_conti_mode is valid.
        constexpr uint32_t LOOP_STOP_EN = (1U << 21);  ///< This bit is used to enable the loop send stop function after the loop counter counts to loop number for CHANNEL%s.
    }

    /// CH_RX_LIM Register bits
    namespace ch_rx_lim_bits {
        constexpr uint32_t RX_LIM_CH4 = (9 << 0);  ///< This register is used to configure the maximum entries that CHANNEL%s can receive.
    }

    /// SYS_CONF Register bits
    namespace sys_conf_bits {
        constexpr uint32_t APB_FIFO_MASK = (1U << 0);  ///< 1'h1: access memory directly. 1'h0: access memory by FIFO.
        constexpr uint32_t MEM_CLK_FORCE_ON = (1U << 1);  ///< Set this bit to enable the clock for RMT memory.
        constexpr uint32_t MEM_FORCE_PD = (1U << 2);  ///< Set this bit to power down RMT memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 3);  ///< 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 4);  ///< the integral part of the fractional divisor
        constexpr uint32_t SCLK_DIV_A = (6 << 12);  ///< the numerator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_DIV_B = (6 << 18);  ///< the denominator of the fractional part of the fractional divisor
        constexpr uint32_t SCLK_SEL = (2 << 24);  ///< choose the clock source of rmt_sclk. 1:CLK_80Mhz;2:CLK_8MHz; 2:XTAL
        constexpr uint32_t SCLK_ACTIVE = (1U << 26);  ///< rmt_sclk switch
        constexpr uint32_t CLK_EN = (1U << 31);  ///< RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
    }

    /// TX_SIM Register bits
    namespace tx_sim_bits {
        constexpr uint32_t CH0 = (1U << 0);  ///< Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH1 = (1U << 1);  ///< Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH2 = (1U << 2);  ///< Set this bit to enable CHANNEL2 to start sending data synchronously with other enabled channels.
        constexpr uint32_t CH3 = (1U << 3);  ///< Set this bit to enable CHANNEL3 to start sending data synchronously with other enabled channels.
        constexpr uint32_t EN = (1U << 4);  ///< This register is used to enable multiple of channels to start sending data synchronously.
    }

    /// REF_CNT_RST Register bits
    namespace ref_cnt_rst_bits {
        constexpr uint32_t CH = (1U << 0);  ///< This register is used to reset the clock divider of CHANNEL%s. (renamed from CH)
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< This is the version register.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x60034F6C;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x110 - Random number data
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_CNTL_BASE = 0x60008000;
    constexpr uint32_t RTC_IO_BASE = 0x60008400;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t OPTIONS0;  ///< Offset: 0x00 - RTC common configure register
        volatile uint32_t SLP_TIMER0;  ///< Offset: 0x04 - configure min sleep time
        volatile uint32_t SLP_TIMER1;  ///< Offset: 0x08 - configure sleep time hi
        volatile uint32_t TIME_UPDATE;  ///< Offset: 0x0C - update rtc main timer
        volatile uint32_t TIME_LOW0;  ///< Offset: 0x10 - read rtc_main timer low bits
        volatile uint32_t TIME_HIGH0;  ///< Offset: 0x14 - read rtc_main timer high bits
        volatile uint32_t STATE0;  ///< Offset: 0x18 - configure chip sleep
        volatile uint32_t TIMER1;  ///< Offset: 0x1C - rtc state wait time
        volatile uint32_t TIMER2;  ///< Offset: 0x20 - rtc monitor state delay time
        volatile uint32_t TIMER3;  ///< Offset: 0x24 - No public
        volatile uint32_t TIMER4;  ///< Offset: 0x28 - No public
        volatile uint32_t TIMER5;  ///< Offset: 0x2C - configure min sleep time
        volatile uint32_t TIMER6;  ///< Offset: 0x30 - No public
        volatile uint32_t ANA_CONF;  ///< Offset: 0x34 - analog configure register
        volatile uint32_t RESET_STATE;  ///< Offset: 0x38 - get reset state
        volatile uint32_t WAKEUP_STATE;  ///< Offset: 0x3C - configure wakeup state
        volatile uint32_t INT_ENA_RTC;  ///< Offset: 0x40 - configure rtc interrupt register
        volatile uint32_t INT_RAW_RTC;  ///< Offset: 0x44 - rtc interrupt register
        volatile uint32_t INT_ST_RTC;  ///< Offset: 0x48 - rtc interrupt register
        volatile uint32_t INT_CLR_RTC;  ///< Offset: 0x4C - rtc interrupt register
        volatile uint32_t STORE0;  ///< Offset: 0x50 - Reserved register
        volatile uint32_t STORE1;  ///< Offset: 0x54 - Reserved register
        volatile uint32_t STORE2;  ///< Offset: 0x58 - Reserved register
        volatile uint32_t STORE3;  ///< Offset: 0x5C - Reserved register
        volatile uint32_t EXT_XTL_CONF;  ///< Offset: 0x60 - Reserved register
        volatile uint32_t EXT_WAKEUP_CONF;  ///< Offset: 0x64 - ext wakeup configure
        volatile uint32_t SLP_REJECT_CONF;  ///< Offset: 0x68 - reject sleep register
        volatile uint32_t CPU_PERIOD_CONF;  ///< Offset: 0x6C - conigure cpu freq
        volatile uint32_t SDIO_ACT_CONF;  ///< Offset: 0x70 - No public
        volatile uint32_t CLK_CONF;  ///< Offset: 0x74 - configure clock register
        volatile uint32_t SLOW_CLK_CONF;  ///< Offset: 0x78 - configure slow clk
        volatile uint32_t SDIO_CONF;  ///< Offset: 0x7C - configure flash power
        volatile uint32_t BIAS_CONF;  ///< Offset: 0x80 - No public
        volatile uint32_t RTC;  ///< Offset: 0x84 - configure rtc regulator
        volatile uint32_t PWC;  ///< Offset: 0x88 - configure rtc power
        volatile uint32_t REGULATOR_DRV_CTRL;  ///< Offset: 0x8C - No public
        volatile uint32_t DIG_PWC;  ///< Offset: 0x90 - configure digital power
        volatile uint32_t DIG_ISO;  ///< Offset: 0x94 - congigure digital power isolation
        volatile uint32_t WDTCONFIG0;  ///< Offset: 0x98 - configure rtc watch dog
        volatile uint32_t WDTCONFIG1;  ///< Offset: 0x9C - stage0 hold time
        volatile uint32_t WDTCONFIG2;  ///< Offset: 0xA0 - stage1 hold time
        volatile uint32_t WDTCONFIG3;  ///< Offset: 0xA4 - stage2 hold time
        volatile uint32_t WDTCONFIG4;  ///< Offset: 0xA8 - stage3 hold time
        volatile uint32_t WDTFEED;  ///< Offset: 0xAC - rtc wdt feed
        volatile uint32_t WDTWPROTECT;  ///< Offset: 0xB0 - configure rtc watch dog
        volatile uint32_t SWD_CONF;  ///< Offset: 0xB4 - congfigure super watch dog
        volatile uint32_t SWD_WPROTECT;  ///< Offset: 0xB8 - super watch dog key
        volatile uint32_t SW_CPU_STALL;  ///< Offset: 0xBC - configure cpu stall by sw
        volatile uint32_t STORE4;  ///< Offset: 0xC0 - reserved register
        volatile uint32_t STORE5;  ///< Offset: 0xC4 - reserved register
        volatile uint32_t STORE6;  ///< Offset: 0xC8 - reserved register
        volatile uint32_t STORE7;  ///< Offset: 0xCC - reserved register
        volatile uint32_t LOW_POWER_ST;  ///< Offset: 0xD0 - reserved register
        volatile uint32_t DIAG0;  ///< Offset: 0xD4 - No public
        volatile uint32_t PAD_HOLD;  ///< Offset: 0xD8 - rtc pad hold configure
        volatile uint32_t DIG_PAD_HOLD;  ///< Offset: 0xDC - configure digtal pad hold
        volatile uint32_t EXT_WAKEUP1;  ///< Offset: 0xE0 - configure ext1 wakeup
        volatile uint32_t EXT_WAKEUP1_STATUS;  ///< Offset: 0xE4 - check ext wakeup1 status
        volatile uint32_t BROWN_OUT;  ///< Offset: 0xE8 - congfigure brownout
        volatile uint32_t TIME_LOW1;  ///< Offset: 0xEC - RTC timer low 32 bits
        volatile uint32_t TIME_HIGH1;  ///< Offset: 0xF0 - RTC timer high 16 bits
        volatile uint32_t XTAL32K_CLK_FACTOR;  ///< Offset: 0xF4 - xtal 32k watch dog backup clock factor
        volatile uint32_t XTAL32K_CONF;  ///< Offset: 0xF8 - configure xtal32k
        volatile uint32_t ULP_CP_TIMER;  ///< Offset: 0xFC - configure ulp
        volatile uint32_t ULP_CP_CTRL;  ///< Offset: 0x100 - configure ulp
        volatile uint32_t COCPU_CTRL;  ///< Offset: 0x104 - configure ulp-riscv
        volatile uint32_t TOUCH_CTRL1;  ///< Offset: 0x108 - configure touch controller
        volatile uint32_t TOUCH_CTRL2;  ///< Offset: 0x10C - configure touch controller
        volatile uint32_t TOUCH_SCAN_CTRL;  ///< Offset: 0x110 - configure touch controller
        volatile uint32_t TOUCH_SLP_THRES;  ///< Offset: 0x114 - configure touch controller
        volatile uint32_t TOUCH_APPROACH;  ///< Offset: 0x118 - configure touch controller
        volatile uint32_t TOUCH_FILTER_CTRL;  ///< Offset: 0x11C - configure touch controller
        volatile uint32_t USB_CONF;  ///< Offset: 0x120 - usb configure
        volatile uint32_t TOUCH_TIMEOUT_CTRL;  ///< Offset: 0x124 - configure touch controller
        volatile uint32_t SLP_REJECT_CAUSE;  ///< Offset: 0x128 - get reject casue
        volatile uint32_t OPTION1;  ///< Offset: 0x12C - rtc common configure
        volatile uint32_t SLP_WAKEUP_CAUSE;  ///< Offset: 0x130 - get wakeup cause
        volatile uint32_t ULP_CP_TIMER_1;  ///< Offset: 0x134 - configure ulp sleep time
        volatile uint32_t INT_ENA_RTC_W1TS;  ///< Offset: 0x138 - oneset rtc interrupt
        volatile uint32_t INT_ENA_RTC_W1TC;  ///< Offset: 0x13C - oneset clr rtc interrupt enable
        volatile uint32_t RETENTION_CTRL;  ///< Offset: 0x140 - configure retention
        volatile uint32_t PG_CTRL;  ///< Offset: 0x144 - configure power glitch
        volatile uint32_t FIB_SEL;  ///< Offset: 0x148 - No public
        volatile uint32_t TOUCH_DAC;  ///< Offset: 0x14C - configure touch dac
        volatile uint32_t TOUCH_DAC1;  ///< Offset: 0x150 - configure touch dac
        volatile uint32_t COCPU_DISABLE;  ///< Offset: 0x154 - configure ulp diable
        volatile uint32_t DATE;  ///< Offset: 0x1FC - version register
    };

    /// Peripheral instances
    inline Registers* RTC_CNTL = reinterpret_cast<Registers*>(RTC_CNTL_BASE);
    inline Registers* RTC_IO = reinterpret_cast<Registers*>(RTC_IO_BASE);

    // Bit definitions
    /// OPTIONS0 Register bits
    namespace options0_bits {
        constexpr uint32_t SW_STALL_APPCPU_C0 = (2 << 0);  ///< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
        constexpr uint32_t SW_STALL_PROCPU_C0 = (2 << 2);  ///< {reg_sw_stall_procpu_c1[5:0], reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall PRO CPU
        constexpr uint32_t SW_APPCPU_RST = (1U << 4);  ///< APP CPU SW reset
        constexpr uint32_t SW_PROCPU_RST = (1U << 5);  ///< PRO CPU SW reset
        constexpr uint32_t BB_I2C_FORCE_PD = (1U << 6);  ///< BB_I2C force power down
        constexpr uint32_t BB_I2C_FORCE_PU = (1U << 7);  ///< BB_I2C force power up
        constexpr uint32_t BBPLL_I2C_FORCE_PD = (1U << 8);  ///< BB_PLL _I2C force power down
        constexpr uint32_t BBPLL_I2C_FORCE_PU = (1U << 9);  ///< BB_PLL_I2C force power up
        constexpr uint32_t BBPLL_FORCE_PD = (1U << 10);  ///< BB_PLL force power down
        constexpr uint32_t BBPLL_FORCE_PU = (1U << 11);  ///< BB_PLL force power up
        constexpr uint32_t XTL_FORCE_PD = (1U << 12);  ///< crystall force power down
        constexpr uint32_t XTL_FORCE_PU = (1U << 13);  ///< crystall force power up
        constexpr uint32_t XTL_EN_WAIT = (4 << 14);  ///< wait bias_sleep and current source wakeup
        constexpr uint32_t XTL_FORCE_ISO = (1U << 23);  ///< No public
        constexpr uint32_t PLL_FORCE_ISO = (1U << 24);  ///< No public
        constexpr uint32_t ANALOG_FORCE_ISO = (1U << 25);  ///< No public
        constexpr uint32_t XTL_FORCE_NOISO = (1U << 26);  ///< No public
        constexpr uint32_t PLL_FORCE_NOISO = (1U << 27);  ///< No public
        constexpr uint32_t ANALOG_FORCE_NOISO = (1U << 28);  ///< No public
        constexpr uint32_t DG_WRAP_FORCE_RST = (1U << 29);  ///< digital wrap force reset in deep sleep
        constexpr uint32_t DG_WRAP_FORCE_NORST = (1U << 30);  ///< digital core force no reset in deep sleep
        constexpr uint32_t SW_SYS_RST = (1U << 31);  ///< SW system reset
    }

    /// SLP_TIMER0 Register bits
    namespace slp_timer0_bits {
        constexpr uint32_t SLP_VAL_LO = (32 << 0);  ///< RTC sleep timer low 32 bits
    }

    /// SLP_TIMER1 Register bits
    namespace slp_timer1_bits {
        constexpr uint32_t SLP_VAL_HI = (16 << 0);  ///< RTC sleep timer high 16 bits
        constexpr uint32_t MAIN_TIMER_ALARM_EN = (1U << 16);  ///< timer alarm enable bit
    }

    /// TIME_UPDATE Register bits
    namespace time_update_bits {
        constexpr uint32_t TIMER_SYS_STALL = (1U << 27);  ///< Enable to record system stall time
        constexpr uint32_t TIMER_XTL_OFF = (1U << 28);  ///< Enable to record 40M XTAL OFF time
        constexpr uint32_t TIMER_SYS_RST = (1U << 29);  ///< enable to record system reset time
        constexpr uint32_t TIME_UPDATE = (1U << 31);  ///< Set 1: to update register with RTC timer
    }

    /// TIME_LOW0 Register bits
    namespace time_low0_bits {
        constexpr uint32_t TIMER_VALUE0_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH0 Register bits
    namespace time_high0_bits {
        constexpr uint32_t TIMER_VALUE0_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t SW_CPU_INT = (1U << 0);  ///< rtc software interrupt to main cpu
        constexpr uint32_t SLP_REJECT_CAUSE_CLR = (1U << 1);  ///< clear rtc sleep reject cause
        constexpr uint32_t APB2RTC_BRIDGE_SEL = (1U << 22);  ///< 1: APB to RTC using bridge, 0: APB to RTC using sync
        constexpr uint32_t SDIO_ACTIVE_IND = (1U << 28);  ///< SDIO active indication
        constexpr uint32_t SLP_WAKEUP = (1U << 29);  ///< leep wakeup bit
        constexpr uint32_t SLP_REJECT = (1U << 30);  ///< leep reject bit
        constexpr uint32_t SLEEP_EN = (1U << 31);  ///< sleep enable bit
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t CPU_STALL_EN = (1U << 0);  ///< CPU stall enable bit
        constexpr uint32_t CPU_STALL_WAIT = (5 << 1);  ///< CPU stall wait cycles in fast_clk_rtc
        constexpr uint32_t CK8M_WAIT = (8 << 6);  ///< CK8M wait cycles in slow_clk_rtc
        constexpr uint32_t XTL_BUF_WAIT = (10 << 14);  ///< XTAL wait cycles in slow_clk_rtc
        constexpr uint32_t PLL_BUF_WAIT = (8 << 24);  ///< PLL wait cycles in slow_clk_rtc
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t ULPCP_TOUCH_START_WAIT = (9 << 15);  ///< wait cycles in slow_clk_rtc before ULP-coprocessor / touch controller start to work
        constexpr uint32_t MIN_TIME_CK8M_OFF = (8 << 24);  ///< minimal cycles in slow_clk_rtc for CK8M in power down state
    }

    /// TIMER3 Register bits
    namespace timer3_bits {
        constexpr uint32_t WIFI_WAIT_TIMER = (9 << 0);  ///< No public
        constexpr uint32_t WIFI_POWERUP_TIMER = (7 << 9);  ///< No public
        constexpr uint32_t BT_WAIT_TIMER = (9 << 16);  ///< No public
        constexpr uint32_t BT_POWERUP_TIMER = (7 << 25);  ///< No public
    }

    /// TIMER4 Register bits
    namespace timer4_bits {
        constexpr uint32_t WAIT_TIMER = (9 << 0);  ///< No public
        constexpr uint32_t POWERUP_TIMER = (7 << 9);  ///< No public
        constexpr uint32_t DG_WRAP_WAIT_TIMER = (9 << 16);  ///< No public
        constexpr uint32_t DG_WRAP_POWERUP_TIMER = (7 << 25);  ///< No public
    }

    /// TIMER5 Register bits
    namespace timer5_bits {
        constexpr uint32_t MIN_SLP_VAL = (8 << 8);  ///< minimal sleep cycles in slow_clk_rtc
    }

    /// TIMER6 Register bits
    namespace timer6_bits {
        constexpr uint32_t CPU_TOP_WAIT_TIMER = (9 << 0);  ///< No public
        constexpr uint32_t CPU_TOP_POWERUP_TIMER = (7 << 9);  ///< No public
        constexpr uint32_t DG_PERI_WAIT_TIMER = (9 << 16);  ///< No public
        constexpr uint32_t DG_PERI_POWERUP_TIMER = (7 << 25);  ///< No public
    }

    /// ANA_CONF Register bits
    namespace ana_conf_bits {
        constexpr uint32_t I2C_RESET_POR_FORCE_PD = (1U << 18);  ///< force down I2C_RESET_POR
        constexpr uint32_t I2C_RESET_POR_FORCE_PU = (1U << 19);  ///< force on I2C_RESET_POR
        constexpr uint32_t GLITCH_RST_EN = (1U << 20);  ///< enable clk glitch
        constexpr uint32_t SAR_I2C_PU = (1U << 22);  ///< PLLA force power up
        constexpr uint32_t ANALOG_TOP_ISO_SLEEP = (1U << 23);  ///< PLLA force power down
        constexpr uint32_t ANALOG_TOP_ISO_MONITOR = (1U << 24);  ///< PLLA force power up
        constexpr uint32_t BBPLL_CAL_SLP_START = (1U << 25);  ///< start BBPLL calibration during sleep
        constexpr uint32_t PVTMON_PU = (1U << 26);  ///< 1: PVTMON power up, otherwise power down
        constexpr uint32_t TXRF_I2C_PU = (1U << 27);  ///< 1: TXRF_I2C power up, otherwise power down
        constexpr uint32_t RFRX_PBUS_PU = (1U << 28);  ///< 1: RFRX_PBUS power up, otherwise power down
        constexpr uint32_t CKGEN_I2C_PU = (1U << 30);  ///< 1: CKGEN_I2C power up, otherwise power down
        constexpr uint32_t PLL_I2C_PU = (1U << 31);  ///< power on pll i2c
    }

    /// RESET_STATE Register bits
    namespace reset_state_bits {
        constexpr uint32_t RESET_CAUSE_PROCPU = (6 << 0);  ///< reset cause of PRO CPU
        constexpr uint32_t RESET_CAUSE_APPCPU = (6 << 6);  ///< reset cause of APP CPU
        constexpr uint32_t APPCPU_STAT_VECTOR_SEL = (1U << 12);  ///< APP CPU state vector sel
        constexpr uint32_t PROCPU_STAT_VECTOR_SEL = (1U << 13);  ///< PRO CPU state vector sel
        constexpr uint32_t RESET_FLAG_PROCPU = (1U << 14);  ///< PRO CPU reset_flag
        constexpr uint32_t RESET_FLAG_APPCPU = (1U << 15);  ///< APP CPU reset flag
        constexpr uint32_t RESET_FLAG_PROCPU_CLR = (1U << 16);  ///< clear PRO CPU reset_flag
        constexpr uint32_t RESET_FLAG_APPCPU_CLR = (1U << 17);  ///< clear APP CPU reset flag
        constexpr uint32_t APPCPU_OCD_HALT_ON_RESET = (1U << 18);  ///< APPCPU OcdHaltOnReset
        constexpr uint32_t PROCPU_OCD_HALT_ON_RESET = (1U << 19);  ///< PROCPU OcdHaltOnReset
        constexpr uint32_t RESET_FLAG_JTAG_PROCPU = (1U << 20);  ///< jtag reset flag
        constexpr uint32_t RESET_FLAG_JTAG_APPCPU = (1U << 21);  ///< jtag reset flag
        constexpr uint32_t RESET_FLAG_JTAG_PROCPU_CLR = (1U << 22);  ///< clear jtag reset flag
        constexpr uint32_t RESET_FLAG_JTAG_APPCPU_CLR = (1U << 23);  ///< clear jtag reset flag
        constexpr uint32_t APP_DRESET_MASK = (1U << 24);  ///< bypass cpu1 dreset
        constexpr uint32_t PRO_DRESET_MASK = (1U << 25);  ///< bypass cpu0 dreset
    }

    /// WAKEUP_STATE Register bits
    namespace wakeup_state_bits {
        constexpr uint32_t WAKEUP_ENA = (17 << 15);  ///< wakeup enable bitmap
    }

    /// INT_ENA_RTC Register bits
    namespace int_ena_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t SDIO_IDLE_INT_ENA = (1U << 2);  ///< enable SDIO idle interrupt
        constexpr uint32_t WDT_INT_ENA = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t TOUCH_SCAN_DONE_INT_ENA = (1U << 4);  ///< enable touch scan done interrupt
        constexpr uint32_t ULP_CP_INT_ENA = (1U << 5);  ///< enable ULP-coprocessor interrupt
        constexpr uint32_t TOUCH_DONE_INT_ENA = (1U << 6);  ///< enable touch done interrupt
        constexpr uint32_t TOUCH_ACTIVE_INT_ENA = (1U << 7);  ///< enable touch active interrupt
        constexpr uint32_t TOUCH_INACTIVE_INT_ENA = (1U << 8);  ///< enable touch inactive interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SARADC1_INT_ENA = (1U << 11);  ///< enable saradc1 interrupt
        constexpr uint32_t TSENS_INT_ENA = (1U << 12);  ///< enable tsens interrupt
        constexpr uint32_t COCPU_INT_ENA = (1U << 13);  ///< enable riscV cocpu interrupt
        constexpr uint32_t SARADC2_INT_ENA = (1U << 14);  ///< enable saradc2 interrupt
        constexpr uint32_t SWD_INT_ENA = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t XTAL32K_DEAD_INT_ENA = (1U << 16);  ///< enable xtal32k_dead interrupt
        constexpr uint32_t COCPU_TRAP_INT_ENA = (1U << 17);  ///< enable cocpu trap interrupt
        constexpr uint32_t TOUCH_TIMEOUT_INT_ENA = (1U << 18);  ///< enable touch timeout interrupt
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 19);  ///< enbale gitch det interrupt
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA = (1U << 20);  ///< touch approach mode loop interrupt
    }

    /// INT_RAW_RTC Register bits
    namespace int_raw_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_RAW = (1U << 0);  ///< sleep wakeup interrupt raw
        constexpr uint32_t SLP_REJECT_INT_RAW = (1U << 1);  ///< sleep reject interrupt raw
        constexpr uint32_t SDIO_IDLE_INT_RAW = (1U << 2);  ///< SDIO idle interrupt raw
        constexpr uint32_t WDT_INT_RAW = (1U << 3);  ///< RTC WDT interrupt raw
        constexpr uint32_t TOUCH_SCAN_DONE_INT_RAW = (1U << 4);  ///< enable touch scan done interrupt raw
        constexpr uint32_t ULP_CP_INT_RAW = (1U << 5);  ///< ULP-coprocessor interrupt raw
        constexpr uint32_t TOUCH_DONE_INT_RAW = (1U << 6);  ///< touch interrupt raw
        constexpr uint32_t TOUCH_ACTIVE_INT_RAW = (1U << 7);  ///< touch active interrupt raw
        constexpr uint32_t TOUCH_INACTIVE_INT_RAW = (1U << 8);  ///< touch inactive interrupt raw
        constexpr uint32_t BROWN_OUT_INT_RAW = (1U << 9);  ///< brown out interrupt raw
        constexpr uint32_t MAIN_TIMER_INT_RAW = (1U << 10);  ///< RTC main timer interrupt raw
        constexpr uint32_t SARADC1_INT_RAW = (1U << 11);  ///< saradc1 interrupt raw
        constexpr uint32_t TSENS_INT_RAW = (1U << 12);  ///< tsens interrupt raw
        constexpr uint32_t COCPU_INT_RAW = (1U << 13);  ///< riscV cocpu interrupt raw
        constexpr uint32_t SARADC2_INT_RAW = (1U << 14);  ///< saradc2 interrupt raw
        constexpr uint32_t SWD_INT_RAW = (1U << 15);  ///< super watch dog interrupt raw
        constexpr uint32_t XTAL32K_DEAD_INT_RAW = (1U << 16);  ///< xtal32k dead detection interrupt raw
        constexpr uint32_t COCPU_TRAP_INT_RAW = (1U << 17);  ///< cocpu trap interrupt raw
        constexpr uint32_t TOUCH_TIMEOUT_INT_RAW = (1U << 18);  ///< touch timeout interrupt raw
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 19);  ///< glitch_det_interrupt_raw
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_RAW = (1U << 20);  ///< touch approach mode loop interrupt raw
    }

    /// INT_ST_RTC Register bits
    namespace int_st_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ST = (1U << 0);  ///< sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_ST = (1U << 1);  ///< sleep reject interrupt state
        constexpr uint32_t SDIO_IDLE_INT_ST = (1U << 2);  ///< SDIO idle interrupt state
        constexpr uint32_t WDT_INT_ST = (1U << 3);  ///< RTC WDT interrupt state
        constexpr uint32_t TOUCH_SCAN_DONE_INT_ST = (1U << 4);  ///< enable touch scan done interrupt raw
        constexpr uint32_t ULP_CP_INT_ST = (1U << 5);  ///< ULP-coprocessor interrupt state
        constexpr uint32_t TOUCH_DONE_INT_ST = (1U << 6);  ///< touch done interrupt state
        constexpr uint32_t TOUCH_ACTIVE_INT_ST = (1U << 7);  ///< touch active interrupt state
        constexpr uint32_t TOUCH_INACTIVE_INT_ST = (1U << 8);  ///< touch inactive interrupt state
        constexpr uint32_t BROWN_OUT_INT_ST = (1U << 9);  ///< brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_ST = (1U << 10);  ///< RTC main timer interrupt state
        constexpr uint32_t SARADC1_INT_ST = (1U << 11);  ///< saradc1 interrupt state
        constexpr uint32_t TSENS_INT_ST = (1U << 12);  ///< tsens interrupt state
        constexpr uint32_t COCPU_INT_ST = (1U << 13);  ///< riscV cocpu interrupt state
        constexpr uint32_t SARADC2_INT_ST = (1U << 14);  ///< saradc2 interrupt state
        constexpr uint32_t SWD_INT_ST = (1U << 15);  ///< super watch dog interrupt state
        constexpr uint32_t XTAL32K_DEAD_INT_ST = (1U << 16);  ///< xtal32k dead detection interrupt state
        constexpr uint32_t COCPU_TRAP_INT_ST = (1U << 17);  ///< cocpu trap interrupt state
        constexpr uint32_t TOUCH_TIMEOUT_INT_ST = (1U << 18);  ///< Touch timeout interrupt state
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 19);  ///< glitch_det_interrupt state
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ST = (1U << 20);  ///< touch approach mode loop interrupt state
    }

    /// INT_CLR_RTC Register bits
    namespace int_clr_rtc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_CLR = (1U << 0);  ///< Clear sleep wakeup interrupt state
        constexpr uint32_t SLP_REJECT_INT_CLR = (1U << 1);  ///< Clear sleep reject interrupt state
        constexpr uint32_t SDIO_IDLE_INT_CLR = (1U << 2);  ///< Clear SDIO idle interrupt state
        constexpr uint32_t WDT_INT_CLR = (1U << 3);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t TOUCH_SCAN_DONE_INT_CLR = (1U << 4);  ///< clear touch scan done interrupt raw
        constexpr uint32_t ULP_CP_INT_CLR = (1U << 5);  ///< Clear ULP-coprocessor interrupt state
        constexpr uint32_t TOUCH_DONE_INT_CLR = (1U << 6);  ///< Clear touch done interrupt state
        constexpr uint32_t TOUCH_ACTIVE_INT_CLR = (1U << 7);  ///< Clear touch active interrupt state
        constexpr uint32_t TOUCH_INACTIVE_INT_CLR = (1U << 8);  ///< Clear touch inactive interrupt state
        constexpr uint32_t BROWN_OUT_INT_CLR = (1U << 9);  ///< Clear brown out interrupt state
        constexpr uint32_t MAIN_TIMER_INT_CLR = (1U << 10);  ///< Clear RTC main timer interrupt state
        constexpr uint32_t SARADC1_INT_CLR = (1U << 11);  ///< Clear saradc1 interrupt state
        constexpr uint32_t TSENS_INT_CLR = (1U << 12);  ///< Clear tsens interrupt state
        constexpr uint32_t COCPU_INT_CLR = (1U << 13);  ///< Clear riscV cocpu interrupt state
        constexpr uint32_t SARADC2_INT_CLR = (1U << 14);  ///< Clear saradc2 interrupt state
        constexpr uint32_t SWD_INT_CLR = (1U << 15);  ///< Clear super watch dog interrupt state
        constexpr uint32_t XTAL32K_DEAD_INT_CLR = (1U << 16);  ///< Clear RTC WDT interrupt state
        constexpr uint32_t COCPU_TRAP_INT_CLR = (1U << 17);  ///< Clear cocpu trap interrupt state
        constexpr uint32_t TOUCH_TIMEOUT_INT_CLR = (1U << 18);  ///< Clear touch timeout interrupt state
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 19);  ///< Clear glitch det interrupt state
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_CLR = (1U << 20);  ///< cleartouch approach mode loop interrupt state
    }

    /// STORE0 Register bits
    namespace store0_bits {
        constexpr uint32_t SCRATCH0 = (32 << 0);  ///< Reserved register
    }

    /// STORE1 Register bits
    namespace store1_bits {
        constexpr uint32_t SCRATCH1 = (32 << 0);  ///< Reserved register
    }

    /// STORE2 Register bits
    namespace store2_bits {
        constexpr uint32_t SCRATCH2 = (32 << 0);  ///< Reserved register
    }

    /// STORE3 Register bits
    namespace store3_bits {
        constexpr uint32_t SCRATCH3 = (32 << 0);  ///< Reserved register
    }

    /// EXT_XTL_CONF Register bits
    namespace ext_xtl_conf_bits {
        constexpr uint32_t XTAL32K_WDT_EN = (1U << 0);  ///< xtal 32k watch dog enable
        constexpr uint32_t XTAL32K_WDT_CLK_FO = (1U << 1);  ///< xtal 32k watch dog clock force on
        constexpr uint32_t XTAL32K_WDT_RESET = (1U << 2);  ///< xtal 32k watch dog sw reset
        constexpr uint32_t XTAL32K_EXT_CLK_FO = (1U << 3);  ///< xtal 32k external xtal clock force on
        constexpr uint32_t XTAL32K_AUTO_BACKUP = (1U << 4);  ///< xtal 32k switch to back up clock when xtal is dead
        constexpr uint32_t XTAL32K_AUTO_RESTART = (1U << 5);  ///< xtal 32k restart xtal when xtal is dead
        constexpr uint32_t XTAL32K_AUTO_RETURN = (1U << 6);  ///< xtal 32k switch back xtal when xtal is restarted
        constexpr uint32_t XTAL32K_XPD_FORCE = (1U << 7);  ///< Xtal 32k xpd control by sw or fsm
        constexpr uint32_t ENCKINIT_XTAL_32K = (1U << 8);  ///< apply an internal clock to help xtal 32k to start
        constexpr uint32_t DBUF_XTAL_32K = (1U << 9);  ///< 0: single-end buffer 1: differential buffer
        constexpr uint32_t DGM_XTAL_32K = (3 << 10);  ///< xtal_32k gm control
        constexpr uint32_t DRES_XTAL_32K = (3 << 13);  ///< DRES_XTAL_32K
        constexpr uint32_t XPD_XTAL_32K = (1U << 16);  ///< XPD_XTAL_32K
        constexpr uint32_t DAC_XTAL_32K = (3 << 17);  ///< DAC_XTAL_32K
        constexpr uint32_t WDT_STATE = (3 << 20);  ///< state of 32k_wdt
        constexpr uint32_t XTAL32K_GPIO_SEL = (1U << 23);  ///< XTAL_32K sel. 0: external XTAL_32K, 1: CLK from RTC pad X32P_C
        constexpr uint32_t XTL_EXT_CTR_LV = (1U << 30);  ///< 0: power down XTAL at high level, 1: power down XTAL at low level
        constexpr uint32_t XTL_EXT_CTR_EN = (1U << 31);  ///< Reserved register
    }

    /// EXT_WAKEUP_CONF Register bits
    namespace ext_wakeup_conf_bits {
        constexpr uint32_t GPIO_WAKEUP_FILTER = (1U << 29);  ///< enable filter for gpio wakeup event
        constexpr uint32_t EXT_WAKEUP0_LV = (1U << 30);  ///< 0: external wakeup at low level, 1: external wakeup at high level
        constexpr uint32_t EXT_WAKEUP1_LV = (1U << 31);  ///< 0: external wakeup at low level, 1: external wakeup at high level
    }

    /// SLP_REJECT_CONF Register bits
    namespace slp_reject_conf_bits {
        constexpr uint32_t SLEEP_REJECT_ENA = (18 << 12);  ///< sleep reject enable
        constexpr uint32_t LIGHT_SLP_REJECT_EN = (1U << 30);  ///< enable reject for light sleep
        constexpr uint32_t DEEP_SLP_REJECT_EN = (1U << 31);  ///< enable reject for deep sleep
    }

    /// CPU_PERIOD_CONF Register bits
    namespace cpu_period_conf_bits {
        constexpr uint32_t CPUSEL_CONF = (1U << 29);  ///< CPU sel option
        constexpr uint32_t CPUPERIOD_SEL = (2 << 30);  ///< conigure cpu freq
    }

    /// SDIO_ACT_CONF Register bits
    namespace sdio_act_conf_bits {
        constexpr uint32_t SDIO_ACT_DNUM = (10 << 22);  ///< No public
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t EFUSE_CLK_FORCE_GATING = (1U << 1);  ///< force efuse clk gating
        constexpr uint32_t EFUSE_CLK_FORCE_NOGATING = (1U << 2);  ///< force efuse clk nogating
        constexpr uint32_t CK8M_DIV_SEL_VLD = (1U << 3);  ///< used to sync reg_ck8m_div_sel bus. Clear vld before set reg_ck8m_div_sel, then set vld to actually switch the clk
        constexpr uint32_t CK8M_DIV = (2 << 4);  ///< CK8M_D256_OUT divider. 00: div128, 01: div256, 10: div512, 11: div1024.
        constexpr uint32_t ENB_CK8M = (1U << 6);  ///< disable CK8M and CK8M_D256_OUT
        constexpr uint32_t ENB_CK8M_DIV = (1U << 7);  ///< 1: CK8M_D256_OUT is actually CK8M, 0: CK8M_D256_OUT is CK8M divided by 256
        constexpr uint32_t DIG_XTAL32K_EN = (1U << 8);  ///< enable CK_XTAL_32K for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_D256_EN = (1U << 9);  ///< enable CK8M_D256_OUT for digital core (no relationship with RTC core)
        constexpr uint32_t DIG_CLK8M_EN = (1U << 10);  ///< enable CK8M for digital core (no relationship with RTC core)
        constexpr uint32_t CK8M_DIV_SEL = (3 << 12);  ///< divider = reg_ck8m_div_sel + 1
        constexpr uint32_t XTAL_FORCE_NOGATING = (1U << 15);  ///< XTAL force no gating during sleep
        constexpr uint32_t CK8M_FORCE_NOGATING = (1U << 16);  ///< CK8M force no gating during sleep
        constexpr uint32_t CK8M_DFREQ = (8 << 17);  ///< CK8M_DFREQ
        constexpr uint32_t CK8M_FORCE_PD = (1U << 25);  ///< CK8M force power down
        constexpr uint32_t CK8M_FORCE_PU = (1U << 26);  ///< CK8M force power up
        constexpr uint32_t XTAL_GLOBAL_FORCE_GATING = (1U << 27);  ///< force global xtal gating
        constexpr uint32_t XTAL_GLOBAL_FORCE_NOGATING = (1U << 28);  ///< force global xtal no gating
        constexpr uint32_t FAST_CLK_RTC_SEL = (1U << 29);  ///< fast_clk_rtc sel. 0: XTAL div 4, 1: CK8M
        constexpr uint32_t ANA_CLK_RTC_SEL = (2 << 30);  ///< select slow clock
    }

    /// SLOW_CLK_CONF Register bits
    namespace slow_clk_conf_bits {
        constexpr uint32_t ANA_CLK_DIV_VLD = (1U << 22);  ///< used to sync div bus. clear vld before set reg_rtc_ana_clk_div, then set vld to actually switch the clk
        constexpr uint32_t ANA_CLK_DIV = (8 << 23);  ///< rtc clk div
        constexpr uint32_t SLOW_CLK_NEXT_EDGE = (1U << 31);  ///< No public
    }

    /// SDIO_CONF Register bits
    namespace sdio_conf_bits {
        constexpr uint32_t SDIO_TIMER_TARGET = (8 << 0);  ///< timer count to apply reg_sdio_dcap after sdio power on
        constexpr uint32_t SDIO_DTHDRV = (2 << 9);  ///< Tieh = 1 mode drive ability. Initially set to 0 to limit charge current, set to 3 after several us.
        constexpr uint32_t SDIO_DCAP = (2 << 11);  ///< ability to prevent LDO from overshoot
        constexpr uint32_t SDIO_INITI = (2 << 13);  ///< add resistor from ldo output to ground. 0: no res, 1: 6k,2:4k,3:2k
        constexpr uint32_t SDIO_EN_INITI = (1U << 15);  ///< 0 to set init[1:0]=0
        constexpr uint32_t SDIO_DCURLIM = (3 << 16);  ///< tune current limit threshold when tieh = 0. About 800mA/(8+d)
        constexpr uint32_t SDIO_MODECURLIM = (1U << 19);  ///< select current limit mode
        constexpr uint32_t SDIO_ENCURLIM = (1U << 20);  ///< enable current limit
        constexpr uint32_t SDIO_REG_PD_EN = (1U << 21);  ///< power down SDIO_REG in sleep. Only active when reg_sdio_force = 0
        constexpr uint32_t SDIO_FORCE = (1U << 22);  ///< 1: use SW option to control SDIO_REG, 0: use state machine
        constexpr uint32_t SDIO_TIEH = (1U << 23);  ///< SW option for SDIO_TIEH. Only active when reg_sdio_force = 1
        constexpr uint32_t REG1P8_READY = (1U << 24);  ///< read only register for REG1P8_READY
        constexpr uint32_t DREFL_SDIO = (2 << 25);  ///< SW option for DREFL_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFM_SDIO = (2 << 27);  ///< SW option for DREFM_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t DREFH_SDIO = (2 << 29);  ///< SW option for DREFH_SDIO. Only active when reg_sdio_force = 1
        constexpr uint32_t XPD_SDIO = (1U << 31);  ///< power on flash regulator
    }

    /// BIAS_CONF Register bits
    namespace bias_conf_bits {
        constexpr uint32_t BIAS_BUF_IDLE = (1U << 10);  ///< No public
        constexpr uint32_t BIAS_BUF_WAKE = (1U << 11);  ///< No public
        constexpr uint32_t BIAS_BUF_DEEP_SLP = (1U << 12);  ///< No public
        constexpr uint32_t BIAS_BUF_MONITOR = (1U << 13);  ///< No public
        constexpr uint32_t PD_CUR_DEEP_SLP = (1U << 14);  ///< xpd cur when rtc in sleep_state
        constexpr uint32_t PD_CUR_MONITOR = (1U << 15);  ///< xpd cur when rtc in monitor state
        constexpr uint32_t BIAS_SLEEP_DEEP_SLP = (1U << 16);  ///< bias_sleep when rtc in sleep_state
        constexpr uint32_t BIAS_SLEEP_MONITOR = (1U << 17);  ///< bias_sleep when rtc in monitor state
        constexpr uint32_t DBG_ATTEN_DEEP_SLP = (4 << 18);  ///< DBG_ATTEN when rtc in sleep state
        constexpr uint32_t DBG_ATTEN_MONITOR = (4 << 22);  ///< DBG_ATTEN when rtc in monitor state
        constexpr uint32_t DBG_ATTEN_WAKEUP = (4 << 26);  ///< No public
    }

    /// RTC Register bits
    namespace rtc_bits {
        constexpr uint32_t DIG_REG_CAL_EN = (1U << 7);  ///< enable dig regulator cali
        constexpr uint32_t SCK_DCAP = (8 << 14);  ///< SCK_DCAP
        constexpr uint32_t DBOOST_FORCE_PD = (1U << 28);  ///< RTC_DBOOST force power down
        constexpr uint32_t DBOOST_FORCE_PU = (1U << 29);  ///< RTC_DBOOST force power up
        constexpr uint32_t REGULATOR_FORCE_PD = (1U << 30);  ///< RTC_REG force power down (for RTC_REG power down means decrease the voltage to 0.8v or lower )
        constexpr uint32_t REGULATOR_FORCE_PU = (1U << 31);  ///< RTC_REG force power on (for RTC_REG power down means decrease the voltage to 0.8v or lower )
    }

    /// PWC Register bits
    namespace pwc_bits {
        constexpr uint32_t FASTMEM_FORCE_NOISO = (1U << 0);  ///< Fast RTC memory force no ISO
        constexpr uint32_t FASTMEM_FORCE_ISO = (1U << 1);  ///< Fast RTC memory force ISO
        constexpr uint32_t SLOWMEM_FORCE_NOISO = (1U << 2);  ///< RTC memory force no ISO
        constexpr uint32_t SLOWMEM_FORCE_ISO = (1U << 3);  ///< RTC memory force ISO
        constexpr uint32_t FORCE_ISO = (1U << 4);  ///< rtc_peri force ISO
        constexpr uint32_t FORCE_NOISO = (1U << 5);  ///< rtc_peri force no ISO
        constexpr uint32_t FASTMEM_FOLW_CPU = (1U << 6);  ///< 1: Fast RTC memory PD following CPU, 0: fast RTC memory PD following RTC state machine
        constexpr uint32_t FASTMEM_FORCE_LPD = (1U << 7);  ///< Fast RTC memory force PD
        constexpr uint32_t FASTMEM_FORCE_LPU = (1U << 8);  ///< Fast RTC memory force no PD
        constexpr uint32_t SLOWMEM_FOLW_CPU = (1U << 9);  ///< 1: RTC memory PD following CPU, 0: RTC memory PD following RTC state machine
        constexpr uint32_t SLOWMEM_FORCE_LPD = (1U << 10);  ///< RTC memory force PD
        constexpr uint32_t SLOWMEM_FORCE_LPU = (1U << 11);  ///< RTC memory force no PD
        constexpr uint32_t FORCE_PD = (1U << 18);  ///< rtc_peri force power down
        constexpr uint32_t FORCE_PU = (1U << 19);  ///< rtc_peri force power up
        constexpr uint32_t PD_EN = (1U << 20);  ///< enable power down rtc_peri in sleep
        constexpr uint32_t PAD_FORCE_HOLD = (1U << 21);  ///< rtc pad force hold
    }

    /// REGULATOR_DRV_CTRL Register bits
    namespace regulator_drv_ctrl_bits {
        constexpr uint32_t REGULATOR_DRV_B_MONITOR = (6 << 0);  ///< No public
        constexpr uint32_t REGULATOR_DRV_B_SLP = (6 << 6);  ///< No public
        constexpr uint32_t DG_VDD_DRV_B_SLP = (8 << 12);  ///< No public
        constexpr uint32_t DG_VDD_DRV_B_MONITOR = (8 << 20);  ///< No public
    }

    /// DIG_PWC Register bits
    namespace dig_pwc_bits {
        constexpr uint32_t LSLP_MEM_FORCE_PD = (1U << 3);  ///< memories in digital core force PD in sleep
        constexpr uint32_t LSLP_MEM_FORCE_PU = (1U << 4);  ///< memories in digital core force no PD in sleep
        constexpr uint32_t BT_FORCE_PD = (1U << 11);  ///< internal SRAM 2 force power down
        constexpr uint32_t BT_FORCE_PU = (1U << 12);  ///< internal SRAM 2 force power up
        constexpr uint32_t DG_PERI_FORCE_PD = (1U << 13);  ///< internal SRAM 3 force power down
        constexpr uint32_t DG_PERI_FORCE_PU = (1U << 14);  ///< internal SRAM 3 force power up
        constexpr uint32_t WIFI_FORCE_PD = (1U << 17);  ///< wifi force power down
        constexpr uint32_t WIFI_FORCE_PU = (1U << 18);  ///< wifi force power up
        constexpr uint32_t DG_WRAP_FORCE_PD = (1U << 19);  ///< digital core force power down
        constexpr uint32_t DG_WRAP_FORCE_PU = (1U << 20);  ///< digital core force power up
        constexpr uint32_t CPU_TOP_FORCE_PD = (1U << 21);  ///< digital dcdc force power down
        constexpr uint32_t CPU_TOP_FORCE_PU = (1U << 22);  ///< digital dcdc force power up
        constexpr uint32_t BT_PD_EN = (1U << 27);  ///< enable power down internal SRAM 2 in sleep
        constexpr uint32_t DG_PERI_PD_EN = (1U << 28);  ///< enable power down internal SRAM 3 in sleep
        constexpr uint32_t CPU_TOP_PD_EN = (1U << 29);  ///< enable power down internal SRAM 4 in sleep
        constexpr uint32_t WIFI_PD_EN = (1U << 30);  ///< enable power down wifi in sleep
        constexpr uint32_t DG_WRAP_PD_EN = (1U << 31);  ///< enable power down all digital logic
    }

    /// DIG_ISO Register bits
    namespace dig_iso_bits {
        constexpr uint32_t FORCE_OFF = (1U << 7);  ///< No public
        constexpr uint32_t FORCE_ON = (1U << 8);  ///< No public
        constexpr uint32_t DG_PAD_AUTOHOLD = (1U << 9);  ///< read only register to indicate digital pad auto-hold status
        constexpr uint32_t CLR_DG_PAD_AUTOHOLD = (1U << 10);  ///< wtite only register to clear digital pad auto-hold
        constexpr uint32_t DG_PAD_AUTOHOLD_EN = (1U << 11);  ///< digital pad enable auto-hold
        constexpr uint32_t DG_PAD_FORCE_NOISO = (1U << 12);  ///< digital pad force no ISO
        constexpr uint32_t DG_PAD_FORCE_ISO = (1U << 13);  ///< digital pad force ISO
        constexpr uint32_t DG_PAD_FORCE_UNHOLD = (1U << 14);  ///< digital pad force un-hold
        constexpr uint32_t DG_PAD_FORCE_HOLD = (1U << 15);  ///< digital pad force hold
        constexpr uint32_t BT_FORCE_ISO = (1U << 22);  ///< internal SRAM 2 force ISO
        constexpr uint32_t BT_FORCE_NOISO = (1U << 23);  ///< internal SRAM 2 force no ISO
        constexpr uint32_t DG_PERI_FORCE_ISO = (1U << 24);  ///< internal SRAM 3 force ISO
        constexpr uint32_t DG_PERI_FORCE_NOISO = (1U << 25);  ///< internal SRAM 3 force no ISO
        constexpr uint32_t CPU_TOP_FORCE_ISO = (1U << 26);  ///< internal SRAM 4 force ISO
        constexpr uint32_t CPU_TOP_FORCE_NOISO = (1U << 27);  ///< internal SRAM 4 force no ISO
        constexpr uint32_t WIFI_FORCE_ISO = (1U << 28);  ///< wifi force ISO
        constexpr uint32_t WIFI_FORCE_NOISO = (1U << 29);  ///< wifi force no ISO
        constexpr uint32_t DG_WRAP_FORCE_ISO = (1U << 30);  ///< digital core force ISO
        constexpr uint32_t DG_WRAP_FORCE_NOISO = (1U << 31);  ///< digita core force no ISO
    }

    /// WDTCONFIG0 Register bits
    namespace wdtconfig0_bits {
        constexpr uint32_t WDT_CHIP_RESET_WIDTH = (8 << 0);  ///< chip reset siginal pulse width
        constexpr uint32_t WDT_CHIP_RESET_EN = (1U << 8);  ///< wdt reset whole chip enable
        constexpr uint32_t WDT_PAUSE_IN_SLP = (1U << 9);  ///< pause WDT in sleep
        constexpr uint32_t WDT_APPCPU_RESET_EN = (1U << 10);  ///< enable WDT reset APP CPU
        constexpr uint32_t WDT_PROCPU_RESET_EN = (1U << 11);  ///< enable WDT reset PRO CPU
        constexpr uint32_t WDT_FLASHBOOT_MOD_EN = (1U << 12);  ///< enable WDT in flash boot
        constexpr uint32_t WDT_SYS_RESET_LENGTH = (3 << 13);  ///< system reset counter length
        constexpr uint32_t WDT_CPU_RESET_LENGTH = (3 << 16);  ///< CPU reset counter length
        constexpr uint32_t WDT_STG3 = (3 << 19);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG2 = (3 << 22);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG1 = (3 << 25);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_STG0 = (3 << 28);  ///< 1: interrupt stage en 2: CPU reset stage en 3: system reset stage en 4: RTC reset stage en
        constexpr uint32_t WDT_EN = (1U << 31);  ///< enable rtc watch dog
    }

    /// WDTCONFIG1 Register bits
    namespace wdtconfig1_bits {
        constexpr uint32_t WDT_STG0_HOLD = (32 << 0);  ///< stage0 hold time
    }

    /// WDTCONFIG2 Register bits
    namespace wdtconfig2_bits {
        constexpr uint32_t WDT_STG1_HOLD = (32 << 0);  ///< stage1 hold time
    }

    /// WDTCONFIG3 Register bits
    namespace wdtconfig3_bits {
        constexpr uint32_t WDT_STG2_HOLD = (32 << 0);  ///< stage2 hold time
    }

    /// WDTCONFIG4 Register bits
    namespace wdtconfig4_bits {
        constexpr uint32_t WDT_STG3_HOLD = (32 << 0);  ///< stage3 hold time
    }

    /// WDTFEED Register bits
    namespace wdtfeed_bits {
        constexpr uint32_t WDT_FEED = (1U << 31);  ///< rtc wdt feed
    }

    /// WDTWPROTECT Register bits
    namespace wdtwprotect_bits {
        constexpr uint32_t WDT_WKEY = (32 << 0);  ///< rtc watch dog key
    }

    /// SWD_CONF Register bits
    namespace swd_conf_bits {
        constexpr uint32_t SWD_RESET_FLAG = (1U << 0);  ///< swd reset flag
        constexpr uint32_t SWD_FEED_INT = (1U << 1);  ///< swd interrupt for feeding
        constexpr uint32_t SWD_BYPASS_RST = (1U << 17);  ///< bypass super watch dog reset
        constexpr uint32_t SWD_SIGNAL_WIDTH = (10 << 18);  ///< adjust signal width send to swd
        constexpr uint32_t SWD_RST_FLAG_CLR = (1U << 28);  ///< reset swd reset flag
        constexpr uint32_t SWD_FEED = (1U << 29);  ///< Sw feed swd
        constexpr uint32_t SWD_DISABLE = (1U << 30);  ///< disabel SWD
        constexpr uint32_t SWD_AUTO_FEED_EN = (1U << 31);  ///< automatically feed swd when int comes
    }

    /// SWD_WPROTECT Register bits
    namespace swd_wprotect_bits {
        constexpr uint32_t SWD_WKEY = (32 << 0);  ///< super watch dog key
    }

    /// SW_CPU_STALL Register bits
    namespace sw_cpu_stall_bits {
        constexpr uint32_t SW_STALL_APPCPU_C1 = (6 << 20);  ///< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
        constexpr uint32_t SW_STALL_PROCPU_C1 = (6 << 26);  ///< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall APP CPU
    }

    /// STORE4 Register bits
    namespace store4_bits {
        constexpr uint32_t SCRATCH4 = (32 << 0);  ///< reserved register
    }

    /// STORE5 Register bits
    namespace store5_bits {
        constexpr uint32_t SCRATCH5 = (32 << 0);  ///< reserved register
    }

    /// STORE6 Register bits
    namespace store6_bits {
        constexpr uint32_t SCRATCH6 = (32 << 0);  ///< reserved register
    }

    /// STORE7 Register bits
    namespace store7_bits {
        constexpr uint32_t SCRATCH7 = (32 << 0);  ///< reserved register
    }

    /// LOW_POWER_ST Register bits
    namespace low_power_st_bits {
        constexpr uint32_t XPD_ROM0 = (1U << 0);  ///< rom0 power down
        constexpr uint32_t XPD_DIG_DCDC = (1U << 2);  ///< External DCDC power down
        constexpr uint32_t PERI_ISO = (1U << 3);  ///< rtc peripheral iso
        constexpr uint32_t XPD_RTC_PERI = (1U << 4);  ///< rtc peripheral power down
        constexpr uint32_t WIFI_ISO = (1U << 5);  ///< wifi iso
        constexpr uint32_t XPD_WIFI = (1U << 6);  ///< wifi wrap power down
        constexpr uint32_t DIG_ISO = (1U << 7);  ///< digital wrap iso
        constexpr uint32_t XPD_DIG = (1U << 8);  ///< digital wrap power down
        constexpr uint32_t TOUCH_STATE_START = (1U << 9);  ///< touch should start to work
        constexpr uint32_t TOUCH_STATE_SWITCH = (1U << 10);  ///< touch is about to working. Switch rtc main state
        constexpr uint32_t TOUCH_STATE_SLP = (1U << 11);  ///< touch is in sleep state
        constexpr uint32_t TOUCH_STATE_DONE = (1U << 12);  ///< touch is done
        constexpr uint32_t COCPU_STATE_START = (1U << 13);  ///< ulp/cocpu should start to work
        constexpr uint32_t COCPU_STATE_SWITCH = (1U << 14);  ///< ulp/cocpu is about to working. Switch rtc main state
        constexpr uint32_t COCPU_STATE_SLP = (1U << 15);  ///< ulp/cocpu is in sleep state
        constexpr uint32_t COCPU_STATE_DONE = (1U << 16);  ///< ulp/cocpu is done
        constexpr uint32_t MAIN_STATE_XTAL_ISO = (1U << 17);  ///< no use any more
        constexpr uint32_t MAIN_STATE_PLL_ON = (1U << 18);  ///< rtc main state machine is in states that pll should be running
        constexpr uint32_t RDY_FOR_WAKEUP = (1U << 19);  ///< rtc is ready to receive wake up trigger from wake up source
        constexpr uint32_t MAIN_STATE_WAIT_END = (1U << 20);  ///< rtc main state machine has been waited for some cycles
        constexpr uint32_t IN_WAKEUP_STATE = (1U << 21);  ///< rtc main state machine is in the states of wakeup process
        constexpr uint32_t IN_LOW_POWER_STATE = (1U << 22);  ///< rtc main state machine is in the states of low power
        constexpr uint32_t MAIN_STATE_IN_WAIT_8M = (1U << 23);  ///< rtc main state machine is in wait 8m state
        constexpr uint32_t MAIN_STATE_IN_WAIT_PLL = (1U << 24);  ///< rtc main state machine is in wait pll state
        constexpr uint32_t MAIN_STATE_IN_WAIT_XTL = (1U << 25);  ///< rtc main state machine is in wait xtal state
        constexpr uint32_t MAIN_STATE_IN_SLP = (1U << 26);  ///< rtc main state machine is in sleep state
        constexpr uint32_t MAIN_STATE_IN_IDLE = (1U << 27);  ///< rtc main state machine is in idle state
        constexpr uint32_t MAIN_STATE = (4 << 28);  ///< rtc main state machine status
    }

    /// DIAG0 Register bits
    namespace diag0_bits {
        constexpr uint32_t LOW_POWER_DIAG1 = (32 << 0);  ///< No public
    }

    /// PAD_HOLD Register bits
    namespace pad_hold_bits {
        constexpr uint32_t TOUCH_PAD0_HOLD = (1U << 0);  ///< hold rtc pad0
        constexpr uint32_t TOUCH_PAD1_HOLD = (1U << 1);  ///< hold rtc pad-1
        constexpr uint32_t TOUCH_PAD2_HOLD = (1U << 2);  ///< hold rtc pad-2
        constexpr uint32_t TOUCH_PAD3_HOLD = (1U << 3);  ///< hold rtc pad-3
        constexpr uint32_t TOUCH_PAD4_HOLD = (1U << 4);  ///< hold rtc pad-4
        constexpr uint32_t TOUCH_PAD5_HOLD = (1U << 5);  ///< hold rtc pad-5
        constexpr uint32_t TOUCH_PAD6_HOLD = (1U << 6);  ///< hold rtc pad-6
        constexpr uint32_t TOUCH_PAD7_HOLD = (1U << 7);  ///< hold rtc pad-7
        constexpr uint32_t TOUCH_PAD8_HOLD = (1U << 8);  ///< hold rtc pad-8
        constexpr uint32_t TOUCH_PAD9_HOLD = (1U << 9);  ///< hold rtc pad-9
        constexpr uint32_t TOUCH_PAD10_HOLD = (1U << 10);  ///< hold rtc pad-10
        constexpr uint32_t TOUCH_PAD11_HOLD = (1U << 11);  ///< hold rtc pad-11
        constexpr uint32_t TOUCH_PAD12_HOLD = (1U << 12);  ///< hold rtc pad-12
        constexpr uint32_t TOUCH_PAD13_HOLD = (1U << 13);  ///< hold rtc pad-13
        constexpr uint32_t TOUCH_PAD14_HOLD = (1U << 14);  ///< hold rtc pad-14
        constexpr uint32_t X32P_HOLD = (1U << 15);  ///< hold rtc pad-15
        constexpr uint32_t X32N_HOLD = (1U << 16);  ///< hold rtc pad-16
        constexpr uint32_t PDAC1_HOLD = (1U << 17);  ///< hold rtc pad-17
        constexpr uint32_t PDAC2_HOLD = (1U << 18);  ///< hold rtc pad-18
        constexpr uint32_t PAD19_HOLD = (1U << 19);  ///< hold rtc pad-19
        constexpr uint32_t PAD20_HOLD = (1U << 20);  ///< hold rtc pad-20
        constexpr uint32_t PAD21_HOLD = (1U << 21);  ///< hold rtc pad-21
    }

    /// DIG_PAD_HOLD Register bits
    namespace dig_pad_hold_bits {
        constexpr uint32_t DIG_PAD_HOLD = (32 << 0);  ///< configure digtal pad hold
    }

    /// EXT_WAKEUP1 Register bits
    namespace ext_wakeup1_bits {
        constexpr uint32_t EXT_WAKEUP1_SEL = (22 << 0);  ///< Bitmap to select RTC pads for ext wakeup1
        constexpr uint32_t EXT_WAKEUP1_STATUS_CLR = (1U << 22);  ///< clear ext wakeup1 status
    }

    /// EXT_WAKEUP1_STATUS Register bits
    namespace ext_wakeup1_status_bits {
        constexpr uint32_t EXT_WAKEUP1_STATUS = (22 << 0);  ///< ext wakeup1 status
    }

    /// BROWN_OUT Register bits
    namespace brown_out_bits {
        constexpr uint32_t BROWN_OUT_INT_WAIT = (10 << 4);  ///< brown out interrupt wait cycles
        constexpr uint32_t BROWN_OUT_CLOSE_FLASH_ENA = (1U << 14);  ///< enable close flash when brown out happens
        constexpr uint32_t BROWN_OUT_PD_RF_ENA = (1U << 15);  ///< enable power down RF when brown out happens
        constexpr uint32_t BROWN_OUT_RST_WAIT = (10 << 16);  ///< brown out reset wait cycles
        constexpr uint32_t BROWN_OUT_RST_ENA = (1U << 26);  ///< enable brown out reset
        constexpr uint32_t BROWN_OUT_RST_SEL = (1U << 27);  ///< 1: 4-pos reset, 0: sys_reset
        constexpr uint32_t BROWN_OUT_ANA_RST_EN = (1U << 28);  ///< enable brown out reset en
        constexpr uint32_t BROWN_OUT_CNT_CLR = (1U << 29);  ///< clear brown out counter
        constexpr uint32_t BROWN_OUT_ENA = (1U << 30);  ///< enable brown out
        constexpr uint32_t DET = (1U << 31);  ///< get brown out detect
    }

    /// TIME_LOW1 Register bits
    namespace time_low1_bits {
        constexpr uint32_t TIMER_VALUE1_LOW = (32 << 0);  ///< RTC timer low 32 bits
    }

    /// TIME_HIGH1 Register bits
    namespace time_high1_bits {
        constexpr uint32_t TIMER_VALUE1_HIGH = (16 << 0);  ///< RTC timer high 16 bits
    }

    /// XTAL32K_CLK_FACTOR Register bits
    namespace xtal32k_clk_factor_bits {
        constexpr uint32_t XTAL32K_CLK_FACTOR = (32 << 0);  ///< xtal 32k watch dog backup clock factor
    }

    /// XTAL32K_CONF Register bits
    namespace xtal32k_conf_bits {
        constexpr uint32_t XTAL32K_RETURN_WAIT = (4 << 0);  ///< cycles to wait to return noral xtal 32k
        constexpr uint32_t XTAL32K_RESTART_WAIT = (16 << 4);  ///< cycles to wait to repower on xtal 32k
        constexpr uint32_t XTAL32K_WDT_TIMEOUT = (8 << 20);  ///< If no clock detected for this amount of time 32k is regarded as dead
        constexpr uint32_t XTAL32K_STABLE_THRES = (4 << 28);  ///< if restarted xtal32k period is smaller than this, it is regarded as stable
    }

    /// ULP_CP_TIMER Register bits
    namespace ulp_cp_timer_bits {
        constexpr uint32_t ULP_CP_PC_INIT = (11 << 0);  ///< ULP-coprocessor PC initial address
        constexpr uint32_t ULP_CP_GPIO_WAKEUP_ENA = (1U << 29);  ///< ULP-coprocessor wakeup by GPIO enable
        constexpr uint32_t ULP_CP_GPIO_WAKEUP_CLR = (1U << 30);  ///< ULP-coprocessor wakeup by GPIO state clear
        constexpr uint32_t ULP_CP_SLP_TIMER_EN = (1U << 31);  ///< ULP-coprocessor timer enable bit
    }

    /// ULP_CP_CTRL Register bits
    namespace ulp_cp_ctrl_bits {
        constexpr uint32_t ULP_CP_MEM_ADDR_INIT = (11 << 0);  ///< No public
        constexpr uint32_t ULP_CP_MEM_ADDR_SIZE = (11 << 11);  ///< No public
        constexpr uint32_t ULP_CP_MEM_OFFST_CLR = (1U << 22);  ///< No public
        constexpr uint32_t ULP_CP_CLK_FO = (1U << 28);  ///< ulp coprocessor clk force on
        constexpr uint32_t ULP_CP_RESET = (1U << 29);  ///< ulp coprocessor clk software reset
        constexpr uint32_t ULP_CP_FORCE_START_TOP = (1U << 30);  ///< 1: ULP-coprocessor is started by SW
        constexpr uint32_t ULP_CP_START_TOP = (1U << 31);  ///< Write 1 to start ULP-coprocessor
    }

    /// COCPU_CTRL Register bits
    namespace cocpu_ctrl_bits {
        constexpr uint32_t COCPU_CLK_FO = (1U << 0);  ///< cocpu clk force on
        constexpr uint32_t COCPU_START_2_RESET_DIS = (6 << 1);  ///< time from start cocpu to pull down reset
        constexpr uint32_t COCPU_START_2_INTR_EN = (6 << 7);  ///< time from start cocpu to give start interrupt
        constexpr uint32_t COCPU_SHUT = (1U << 13);  ///< to shut cocpu
        constexpr uint32_t COCPU_SHUT_2_CLK_DIS = (8 << 14);  ///< time from shut cocpu to disable clk
        constexpr uint32_t COCPU_SHUT_RESET_EN = (1U << 22);  ///< to reset cocpu
        constexpr uint32_t COCPU_SEL = (1U << 23);  ///< 1: old ULP 0: new riscV
        constexpr uint32_t COCPU_DONE_FORCE = (1U << 24);  ///< 1: select riscv done 0: select ulp done
        constexpr uint32_t COCPU_DONE = (1U << 25);  ///< done signal used by riscv to control timer.
        constexpr uint32_t COCPU_SW_INT_TRIGGER = (1U << 26);  ///< trigger cocpu register interrupt
        constexpr uint32_t COCPU_CLKGATE_EN = (1U << 27);  ///< open ulp-riscv clk gate
    }

    /// TOUCH_CTRL1 Register bits
    namespace touch_ctrl1_bits {
        constexpr uint32_t TOUCH_SLEEP_CYCLES = (16 << 0);  ///< sleep cycles for timer
        constexpr uint32_t TOUCH_MEAS_NUM = (16 << 16);  ///< the meas length (in 8MHz)
    }

    /// TOUCH_CTRL2 Register bits
    namespace touch_ctrl2_bits {
        constexpr uint32_t TOUCH_DRANGE = (2 << 2);  ///< TOUCH_DRANGE
        constexpr uint32_t TOUCH_DREFL = (2 << 4);  ///< TOUCH_DREFL
        constexpr uint32_t TOUCH_DREFH = (2 << 6);  ///< TOUCH_DREFH
        constexpr uint32_t TOUCH_XPD_BIAS = (1U << 8);  ///< TOUCH_XPD_BIAS
        constexpr uint32_t TOUCH_REFC = (3 << 9);  ///< TOUCH pad0 reference cap
        constexpr uint32_t TOUCH_DBIAS = (1U << 12);  ///< 1:use self bias 0:use bandgap bias
        constexpr uint32_t TOUCH_SLP_TIMER_EN = (1U << 13);  ///< touch timer enable bit
        constexpr uint32_t TOUCH_START_FSM_EN = (1U << 14);  ///< 1: TOUCH_START & TOUCH_XPD is controlled by touch fsm
        constexpr uint32_t TOUCH_START_EN = (1U << 15);  ///< 1: start touch fsm
        constexpr uint32_t TOUCH_START_FORCE = (1U << 16);  ///< 1: to start touch fsm by SW
        constexpr uint32_t TOUCH_XPD_WAIT = (8 << 17);  ///< the waiting cycles (in 8MHz) between TOUCH_START and TOUCH_XPD
        constexpr uint32_t TOUCH_SLP_CYC_DIV = (2 << 25);  ///< when a touch pad is active sleep cycle could be divided by this number
        constexpr uint32_t TOUCH_TIMER_FORCE_DONE = (2 << 27);  ///< force touch timer done
        constexpr uint32_t TOUCH_RESET = (1U << 29);  ///< reset upgrade touch
        constexpr uint32_t TOUCH_CLK_FO = (1U << 30);  ///< touch clock force on
        constexpr uint32_t TOUCH_CLKGATE_EN = (1U << 31);  ///< touch clock enable
    }

    /// TOUCH_SCAN_CTRL Register bits
    namespace touch_scan_ctrl_bits {
        constexpr uint32_t TOUCH_DENOISE_RES = (2 << 0);  ///< De-noise resolution: 12/10/8/4 bit
        constexpr uint32_t TOUCH_DENOISE_EN = (1U << 2);  ///< touch pad0 will be used to de-noise
        constexpr uint32_t TOUCH_INACTIVE_CONNECTION = (1U << 8);  ///< inactive touch pads connect to 1: gnd 0: HighZ
        constexpr uint32_t TOUCH_SHIELD_PAD_EN = (1U << 9);  ///< touch pad14 will be used as shield
        constexpr uint32_t TOUCH_SCAN_PAD_MAP = (15 << 10);  ///< touch scan mode pad enable map
        constexpr uint32_t TOUCH_BUFDRV = (3 << 25);  ///< touch7 buffer driver strength
        constexpr uint32_t TOUCH_OUT_RING = (4 << 28);  ///< select out ring pad
    }

    /// TOUCH_SLP_THRES Register bits
    namespace touch_slp_thres_bits {
        constexpr uint32_t TOUCH_SLP_TH = (22 << 0);  ///< the threshold for sleep touch pad
        constexpr uint32_t TOUCH_SLP_APPROACH_EN = (1U << 26);  ///< sleep pad approach function enable
        constexpr uint32_t TOUCH_SLP_PAD = (5 << 27);  ///< configure which pad as slp pad
    }

    /// TOUCH_APPROACH Register bits
    namespace touch_approach_bits {
        constexpr uint32_t TOUCH_SLP_CHANNEL_CLR = (1U << 23);  ///< clear touch slp channel
        constexpr uint32_t TOUCH_APPROACH_MEAS_TIME = (8 << 24);  ///< approach pads total meas times
    }

    /// TOUCH_FILTER_CTRL Register bits
    namespace touch_filter_ctrl_bits {
        constexpr uint32_t TOUCH_BYPASS_NEG_NOISE_THRES = (1U << 7);  ///< bypass neg noise thres
        constexpr uint32_t TOUCH_BYPASS_NOISE_THRES = (1U << 8);  ///< bypaas noise thres
        constexpr uint32_t TOUCH_SMOOTH_LVL = (2 << 9);  ///< smooth filter factor
        constexpr uint32_t TOUCH_JITTER_STEP = (4 << 11);  ///< touch jitter step
        constexpr uint32_t TOUCH_NEG_NOISE_LIMIT = (4 << 15);  ///< negative threshold counter limit
        constexpr uint32_t TOUCH_NEG_NOISE_THRES = (2 << 19);  ///< neg noise thres
        constexpr uint32_t TOUCH_NOISE_THRES = (2 << 21);  ///< noise thres
        constexpr uint32_t TOUCH_HYSTERESIS = (2 << 23);  ///< hysteresis
        constexpr uint32_t TOUCH_DEBOUNCE = (3 << 25);  ///< debounce counter
        constexpr uint32_t TOUCH_FILTER_MODE = (3 << 28);  ///< 0: IIR ? 1: IIR ? 2: IIR 1/8 3: Jitter
        constexpr uint32_t TOUCH_FILTER_EN = (1U << 31);  ///< touch filter enable
    }

    /// USB_CONF Register bits
    namespace usb_conf_bits {
        constexpr uint32_t USB_VREFH = (2 << 0);  ///< reg_usb_vrefh
        constexpr uint32_t USB_VREFL = (2 << 2);  ///< reg_usb_vrefl
        constexpr uint32_t USB_VREF_OVERRIDE = (1U << 4);  ///< reg_usb_vref_override
        constexpr uint32_t USB_PAD_PULL_OVERRIDE = (1U << 5);  ///< reg_usb_pad_pull_override
        constexpr uint32_t USB_DP_PULLUP = (1U << 6);  ///< reg_usb_dp_pullup
        constexpr uint32_t USB_DP_PULLDOWN = (1U << 7);  ///< reg_usb_dp_pulldown
        constexpr uint32_t USB_DM_PULLUP = (1U << 8);  ///< reg_usb_dm_pullup
        constexpr uint32_t USB_DM_PULLDOWN = (1U << 9);  ///< reg_usb_dm_pulldown
        constexpr uint32_t USB_PULLUP_VALUE = (1U << 10);  ///< reg_usb_pullup_value
        constexpr uint32_t USB_PAD_ENABLE_OVERRIDE = (1U << 11);  ///< reg_usb_pad_enable_override
        constexpr uint32_t USB_PAD_ENABLE = (1U << 12);  ///< reg_usb_pad_enable
        constexpr uint32_t USB_TXM = (1U << 13);  ///< reg_usb_txm
        constexpr uint32_t USB_TXP = (1U << 14);  ///< reg_usb_txp
        constexpr uint32_t USB_TX_EN = (1U << 15);  ///< reg_usb_tx_en
        constexpr uint32_t USB_TX_EN_OVERRIDE = (1U << 16);  ///< reg_usb_tx_en_override
        constexpr uint32_t USB_RESET_DISABLE = (1U << 17);  ///< reg_usb_reset_disable
        constexpr uint32_t IO_MUX_RESET_DISABLE = (1U << 18);  ///< reg_io_mux_reset_disable
        constexpr uint32_t SW_USB_PHY_SEL = (1U << 19);  ///< reg_sw_usb_phy_sel
        constexpr uint32_t SW_HW_USB_PHY_SEL = (1U << 20);  ///< reg_sw_hw_usb_phy_sel
    }

    /// TOUCH_TIMEOUT_CTRL Register bits
    namespace touch_timeout_ctrl_bits {
        constexpr uint32_t TOUCH_TIMEOUT_NUM = (22 << 0);  ///< configure touch timerout time
        constexpr uint32_t TOUCH_TIMEOUT_EN = (1U << 22);  ///< enable touch timerout
    }

    /// SLP_REJECT_CAUSE Register bits
    namespace slp_reject_cause_bits {
        constexpr uint32_t REJECT_CAUSE = (18 << 0);  ///< sleep reject cause
    }

    /// OPTION1 Register bits
    namespace option1_bits {
        constexpr uint32_t FORCE_DOWNLOAD_BOOT = (1U << 0);  ///< force chip entry download boot by sw
    }

    /// SLP_WAKEUP_CAUSE Register bits
    namespace slp_wakeup_cause_bits {
        constexpr uint32_t WAKEUP_CAUSE = (17 << 0);  ///< sleep wakeup cause
    }

    /// ULP_CP_TIMER_1 Register bits
    namespace ulp_cp_timer_1_bits {
        constexpr uint32_t ULP_CP_TIMER_SLP_CYCLE = (24 << 8);  ///< sleep cycles for ULP-coprocessor timer
    }

    /// INT_ENA_RTC_W1TS Register bits
    namespace int_ena_rtc_w1ts_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TS = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TS = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t SDIO_IDLE_INT_ENA_W1TS = (1U << 2);  ///< enable SDIO idle interrupt
        constexpr uint32_t WDT_INT_ENA_W1TS = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t TOUCH_SCAN_DONE_INT_ENA_W1TS = (1U << 4);  ///< enable touch scan done interrupt
        constexpr uint32_t ULP_CP_INT_ENA_W1TS = (1U << 5);  ///< enable ULP-coprocessor interrupt
        constexpr uint32_t TOUCH_DONE_INT_ENA_W1TS = (1U << 6);  ///< enable touch done interrupt
        constexpr uint32_t TOUCH_ACTIVE_INT_ENA_W1TS = (1U << 7);  ///< enable touch active interrupt
        constexpr uint32_t TOUCH_INACTIVE_INT_ENA_W1TS = (1U << 8);  ///< enable touch inactive interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TS = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TS = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SARADC1_INT_ENA_W1TS = (1U << 11);  ///< enable saradc1 interrupt
        constexpr uint32_t TSENS_INT_ENA_W1TS = (1U << 12);  ///< enable tsens interrupt
        constexpr uint32_t COCPU_INT_ENA_W1TS = (1U << 13);  ///< enable riscV cocpu interrupt
        constexpr uint32_t SARADC2_INT_ENA_W1TS = (1U << 14);  ///< enable saradc2 interrupt
        constexpr uint32_t SWD_INT_ENA_W1TS = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t XTAL32K_DEAD_INT_ENA_W1TS = (1U << 16);  ///< enable xtal32k_dead interrupt
        constexpr uint32_t COCPU_TRAP_INT_ENA_W1TS = (1U << 17);  ///< enable cocpu trap interrupt
        constexpr uint32_t TOUCH_TIMEOUT_INT_ENA_W1TS = (1U << 18);  ///< enable touch timeout interrupt
        constexpr uint32_t GLITCH_DET_INT_ENA_W1TS = (1U << 19);  ///< enbale gitch det interrupt
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TS = (1U << 20);  ///< enbale touch approach_loop done interrupt
    }

    /// INT_ENA_RTC_W1TC Register bits
    namespace int_ena_rtc_w1tc_bits {
        constexpr uint32_t SLP_WAKEUP_INT_ENA_W1TC = (1U << 0);  ///< enable sleep wakeup interrupt
        constexpr uint32_t SLP_REJECT_INT_ENA_W1TC = (1U << 1);  ///< enable sleep reject interrupt
        constexpr uint32_t SDIO_IDLE_INT_ENA_W1TC = (1U << 2);  ///< enable SDIO idle interrupt
        constexpr uint32_t WDT_INT_ENA_W1TC = (1U << 3);  ///< enable RTC WDT interrupt
        constexpr uint32_t TOUCH_SCAN_DONE_INT_ENA_W1TC = (1U << 4);  ///< enable touch scan done interrupt
        constexpr uint32_t ULP_CP_INT_ENA_W1TC = (1U << 5);  ///< enable ULP-coprocessor interrupt
        constexpr uint32_t TOUCH_DONE_INT_ENA_W1TC = (1U << 6);  ///< enable touch done interrupt
        constexpr uint32_t TOUCH_ACTIVE_INT_ENA_W1TC = (1U << 7);  ///< enable touch active interrupt
        constexpr uint32_t TOUCH_INACTIVE_INT_ENA_W1TC = (1U << 8);  ///< enable touch inactive interrupt
        constexpr uint32_t BROWN_OUT_INT_ENA_W1TC = (1U << 9);  ///< enable brown out interrupt
        constexpr uint32_t MAIN_TIMER_INT_ENA_W1TC = (1U << 10);  ///< enable RTC main timer interrupt
        constexpr uint32_t SARADC1_INT_ENA_W1TC = (1U << 11);  ///< enable saradc1 interrupt
        constexpr uint32_t TSENS_INT_ENA_W1TC = (1U << 12);  ///< enable tsens interrupt
        constexpr uint32_t COCPU_INT_ENA_W1TC = (1U << 13);  ///< enable riscV cocpu interrupt
        constexpr uint32_t SARADC2_INT_ENA_W1TC = (1U << 14);  ///< enable saradc2 interrupt
        constexpr uint32_t SWD_INT_ENA_W1TC = (1U << 15);  ///< enable super watch dog interrupt
        constexpr uint32_t XTAL32K_DEAD_INT_ENA_W1TC = (1U << 16);  ///< enable xtal32k_dead interrupt
        constexpr uint32_t COCPU_TRAP_INT_ENA_W1TC = (1U << 17);  ///< enable cocpu trap interrupt
        constexpr uint32_t TOUCH_TIMEOUT_INT_ENA_W1TC = (1U << 18);  ///< enable touch timeout interrupt
        constexpr uint32_t GLITCH_DET_INT_ENA_W1TC = (1U << 19);  ///< enbale gitch det interrupt
        constexpr uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TC = (1U << 20);  ///< enbale touch approach_loop done interrupt
    }

    /// RETENTION_CTRL Register bits
    namespace retention_ctrl_bits {
        constexpr uint32_t RETENTION_TAG_MODE = (4 << 10);  ///< No public
        constexpr uint32_t RETENTION_TARGET = (2 << 14);  ///< congfigure retention target cpu and/or tag
        constexpr uint32_t RETENTION_CLK_SEL = (1U << 16);  ///< No public
        constexpr uint32_t RETENTION_DONE_WAIT = (3 << 17);  ///< wait retention done cycle
        constexpr uint32_t RETENTION_CLKOFF_WAIT = (4 << 20);  ///< wait clk off cycle
        constexpr uint32_t RETENTION_EN = (1U << 24);  ///< enable retention
        constexpr uint32_t RETENTION_WAIT = (7 << 25);  ///< wait cycles for rention operation
    }

    /// PG_CTRL Register bits
    namespace pg_ctrl_bits {
        constexpr uint32_t POWER_GLITCH_DSENSE = (2 << 26);  ///< GLITCH_DSENSE
        constexpr uint32_t POWER_GLITCH_FORCE_PD = (1U << 28);  ///< force power glitch disable
        constexpr uint32_t POWER_GLITCH_FORCE_PU = (1U << 29);  ///< force power glitch enable
        constexpr uint32_t POWER_GLITCH_EFUSE_SEL = (1U << 30);  ///< select use analog fib signal
        constexpr uint32_t POWER_GLITCH_EN = (1U << 31);  ///< enable power glitch
    }

    /// FIB_SEL Register bits
    namespace fib_sel_bits {
        constexpr uint32_t FIB_SEL = (3 << 0);  ///< No public
    }

    /// TOUCH_DAC Register bits
    namespace touch_dac_bits {
        constexpr uint32_t TOUCH_PAD9_DAC = (3 << 2);  ///< configure touch pad dac9
        constexpr uint32_t TOUCH_PAD8_DAC = (3 << 5);  ///< configure touch pad dac8
        constexpr uint32_t TOUCH_PAD7_DAC = (3 << 8);  ///< configure touch pad dac7
        constexpr uint32_t TOUCH_PAD6_DAC = (3 << 11);  ///< configure touch pad dac6
        constexpr uint32_t TOUCH_PAD5_DAC = (3 << 14);  ///< configure touch pad dac5
        constexpr uint32_t TOUCH_PAD4_DAC = (3 << 17);  ///< configure touch pad dac4
        constexpr uint32_t TOUCH_PAD3_DAC = (3 << 20);  ///< configure touch pad dac3
        constexpr uint32_t TOUCH_PAD2_DAC = (3 << 23);  ///< configure touch pad dac2
        constexpr uint32_t TOUCH_PAD1_DAC = (3 << 26);  ///< configure touch pad dac1
        constexpr uint32_t TOUCH_PAD0_DAC = (3 << 29);  ///< configure touch pad dac0
    }

    /// TOUCH_DAC1 Register bits
    namespace touch_dac1_bits {
        constexpr uint32_t TOUCH_PAD14_DAC = (3 << 17);  ///< configure touch pad dac14
        constexpr uint32_t TOUCH_PAD13_DAC = (3 << 20);  ///< configure touch pad dac13
        constexpr uint32_t TOUCH_PAD12_DAC = (3 << 23);  ///< configure touch pad dac12
        constexpr uint32_t TOUCH_PAD11_DAC = (3 << 26);  ///< configure touch pad dac11
        constexpr uint32_t TOUCH_PAD10_DAC = (3 << 29);  ///< configure touch pad dac10
    }

    /// COCPU_DISABLE Register bits
    namespace cocpu_disable_bits {
        constexpr uint32_t DISABLE_RTC_CPU = (1U << 31);  ///< configure ulp diable
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// SDHOST Peripheral
// ============================================================================

namespace sdhost {
    /// Base addresses
    constexpr uint32_t SDHOST_BASE = 0x60028000;

    /// SDHOST Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLKDIV;  ///< Offset: 0x08 - Clock divider configuration register
        volatile uint32_t CLKSRC;  ///< Offset: 0x0C - Clock source selection register
        volatile uint32_t CLKENA;  ///< Offset: 0x10 - Clock enable register
        volatile uint32_t TMOUT;  ///< Offset: 0x14 - Data and response timeout configuration register
        volatile uint32_t CTYPE;  ///< Offset: 0x18 - Card bus width configuration register
        volatile uint32_t BLKSIZ;  ///< Offset: 0x1C - Card data block size configuration register
        volatile uint32_t BYTCNT;  ///< Offset: 0x20 - Data transfer length configuration register
        volatile uint32_t INTMASK;  ///< Offset: 0x24 - SDIO interrupt mask register
        volatile uint32_t CMDARG;  ///< Offset: 0x28 - Command argument data register
        volatile uint32_t CMD;  ///< Offset: 0x2C - Command and boot configuration register
        volatile uint32_t RESP0;  ///< Offset: 0x30 - Response data register
        volatile uint32_t RESP1;  ///< Offset: 0x34 - Long response data register
        volatile uint32_t RESP2;  ///< Offset: 0x38 - Long response data register
        volatile uint32_t RESP3;  ///< Offset: 0x3C - Long response data register
        volatile uint32_t MINTSTS;  ///< Offset: 0x40 - Masked interrupt status register
        volatile uint32_t RINTSTS;  ///< Offset: 0x44 - Raw interrupt status register
        volatile uint32_t STATUS;  ///< Offset: 0x48 - SD/MMC status register
        volatile uint32_t FIFOTH;  ///< Offset: 0x4C - FIFO configuration register
        volatile uint32_t CDETECT;  ///< Offset: 0x50 - Card detect register
        volatile uint32_t WRTPRT;  ///< Offset: 0x54 - Card write protection (WP) status register
        volatile uint32_t TCBCNT;  ///< Offset: 0x5C - Transferred byte count register
        volatile uint32_t TBBCNT;  ///< Offset: 0x60 - Transferred byte count register
        volatile uint32_t DEBNCE;  ///< Offset: 0x64 - Debounce filter time configuration register
        volatile uint32_t USRID;  ///< Offset: 0x68 - User ID (scratchpad) register
        volatile uint32_t VERID;  ///< Offset: 0x6C - Version ID (scratchpad) register
        volatile uint32_t HCON;  ///< Offset: 0x70 - Hardware feature register
        volatile uint32_t UHS;  ///< Offset: 0x74 - UHS-1 register
        volatile uint32_t RST_N;  ///< Offset: 0x78 - Card reset register
        volatile uint32_t BMOD;  ///< Offset: 0x80 - Burst mode transfer configuration register
        volatile uint32_t PLDMND;  ///< Offset: 0x84 - Poll demand configuration register
        volatile uint32_t DBADDR;  ///< Offset: 0x88 - Descriptor base address register
        volatile uint32_t IDSTS;  ///< Offset: 0x8C - IDMAC status register
        volatile uint32_t IDINTEN;  ///< Offset: 0x90 - IDMAC interrupt enable register
        volatile uint32_t DSCADDR;  ///< Offset: 0x94 - Host descriptor address pointer
        volatile uint32_t BUFADDR;  ///< Offset: 0x98 - Host buffer address pointer register
        volatile uint32_t CARDTHRCTL;  ///< Offset: 0x100 - Card Threshold Control register
        volatile uint32_t EMMCDDR;  ///< Offset: 0x10C - eMMC DDR register
        volatile uint32_t ENSHIFT;  ///< Offset: 0x110 - Enable Phase Shift register
        volatile uint32_t BUFFIFO;  ///< Offset: 0x200 - CPU write and read transmit data by FIFO
        volatile uint32_t CLK_EDGE_SEL;  ///< Offset: 0x800 - SDIO control register.
    };

    /// Peripheral instances
    inline Registers* SDHOST = reinterpret_cast<Registers*>(SDHOST_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t CONTROLLER_RESET = (1U << 0);  ///< To reset controller, firmware should set this bit. This bit is auto-cleared after two AHB and two sdhost_cclk_in clock cycles.
        constexpr uint32_t FIFO_RESET = (1U << 1);  ///< To reset FIFO, firmware should set bit to 1. This bit is auto-cleared after completion of reset operation. Note: FIFO pointers will be out of reset after 2 cycles of system clocks in addition to synchronization delay (2 cycles of card clock), after the fifo_reset is cleared.
        constexpr uint32_t DMA_RESET = (1U << 2);  ///< To reset DMA interface, firmware should set bit to 1. This bit is auto-cleared after two AHB clocks.
        constexpr uint32_t INT_ENABLE = (1U << 4);  ///< Global interrupt enable/disable bit. 0: Disable; 1: Enable.
        constexpr uint32_t READ_WAIT = (1U << 6);  ///< For sending read-wait to SDIO cards.
        constexpr uint32_t SEND_IRQ_RESPONSE = (1U << 7);  ///< Bit automatically clears once response is sent. To wait for MMC card interrupts, host issues CMD40 and waits for interrupt response from MMC card(s). In the meantime, if host wants SD/MMC to exit waiting for interrupt state, it can set this bit, at which time SD/MMC command state-machine sends CMD40 response on bus and returns to idle state.
        constexpr uint32_t ABORT_READ_DATA = (1U << 8);  ///< After a suspend-command is issued during a read-operation, software polls the card to find when the suspend-event occurred. Once the suspend-event has occurred, software sets the bit which will reset the data state machine that is waiting for the next block of data. This bit is automatically cleared once the data state machine is reset to idle.
        constexpr uint32_t SEND_CCSD = (1U << 9);  ///< When set, SD/MMC sends CCSD to the CE-ATA device. Software sets this bit only if the current command is expecting CCS (that is, RW_BLK), and if interrupts are enabled for the CE-ATA device. Once the CCSD pattern is sent to the device, SD/MMC automatically clears the SDHOST_SEND_CCSD bit. It also sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG register, and generates an interrupt for the host, in case the Command Done interrupt is not masked. NOTE: Once the SDHOST_SEND_CCSD bit is set, it takes two card clock cycles to drive the CCSD on the CMD line. Due to this, within the boundary conditions the CCSD may be sent to the CE-ATA device, even if the device has signalled CCS.
        constexpr uint32_t SEND_AUTO_STOP_CCSD = (1U << 10);  ///< Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits together; SDHOST_SEND_AUTO_STOP_CCSD should not be set independently of send_ccsd. When set, SD/MMC automatically sends an internally-generated STOP command (CMD12) to the CE-ATA device. After sending this internally-generated STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG is set and an interrupt is generated for the host, in case the ACD interrupt is not masked. After sending the Command Completion Signal Disable (CCSD), SD/MMC automatically clears the SDHOST_SEND_AUTO_STOP_CCSD bit.
        constexpr uint32_t CEATA_DEVICE_INTERRUPT_STATUS = (1U << 11);  ///< Software should appropriately write to this bit after the power-on reset or any other reset to the CE-ATA device. After reset, the CE-ATA device's interrupt is usually disabled (nIEN = 1). If the host enables the CE-ATA device's interrupt, then software should set this bit.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLK_DIVIDER0 = (8 << 0);  ///< Clock divider0 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER1 = (8 << 8);  ///< Clock divider1 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER2 = (8 << 16);  ///< Clock divider2 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
        constexpr uint32_t CLK_DIVIDER3 = (8 << 24);  ///< Clock divider3 value. Clock divisor is 2*n, where n = 0 bypasses the divider (divisor of 1). For example, a value of 1 means divided by 2*1 = 2, a value of 0xFF means divided by 2*255 = 510, and so on.
    }

    /// CLKSRC Register bits
    namespace clksrc_bits {
        constexpr uint32_t CLKSRC = (4 << 0);  ///< Clock divider source for two SD cards is supported. Each card has two bits assigned to it. For example, bit[1:0] are assigned for card 0, bit[3:2] are assigned for card 1. Card 0 maps and internally routes clock divider[0:3] outputs to cclk_out[1:0] pins, depending on bit value. 00 : Clock divider 0; 01 : Clock divider 1; 10 : Clock divider 2; 11 : Clock divider 3.
    }

    /// CLKENA Register bits
    namespace clkena_bits {
        constexpr uint32_t CCLK_ENABLE = (2 << 0);  ///< Clock-enable control for two SD card clocks and one MMC card clock is supported. One bit per card. 0: Clock disabled; 1: Clock enabled.
        constexpr uint32_t LP_ENABLE = (2 << 16);  ///< Disable clock when the card is in IDLE state. One bit per card. 0: clock disabled; 1: clock enabled.
    }

    /// TMOUT Register bits
    namespace tmout_bits {
        constexpr uint32_t RESPONSE_TIMEOUT = (8 << 0);  ///< Response timeout value. Value is specified in terms of number of card output clocks, i.e., sdhost_cclk_out.
        constexpr uint32_t DATA_TIMEOUT = (24 << 8);  ///< Value for card data read timeout. This value is also used for data starvation by host timeout. The timeout counter is started only after the card clock is stopped. This value is specified in number of card output clocks, i.e. sdhost_cclk_out of the selected card. NOTE: The software timer should be used if the timeout value is in the order of 100 ms. In this case, read data timeout interrupt needs to be disabled.
    }

    /// CTYPE Register bits
    namespace ctype_bits {
        constexpr uint32_t CARD_WIDTH4 = (2 << 0);  ///< One bit per card indicates if card is 1-bit or 4-bit mode. 0: 1-bit mode; 1: 4-bit mode. Bit[1:0] correspond to card[1:0] respectively.
        constexpr uint32_t CARD_WIDTH8 = (2 << 16);  ///< One bit per card indicates if card is in 8-bit mode. 0: Non 8-bit mode; 1: 8-bit mode. Bit[17:16] correspond to card[1:0] respectively.
    }

    /// BLKSIZ Register bits
    namespace blksiz_bits {
        constexpr uint32_t BLOCK_SIZE = (16 << 0);  ///< Block size.
    }

    /// BYTCNT Register bits
    namespace bytcnt_bits {
        constexpr uint32_t BYTE_COUNT = (32 << 0);  ///< Number of bytes to be transferred, should be an integral multiple of Block Size for block transfers. For data transfers of undefined byte lengths, byte count should be set to 0. When byte count is set to 0, it is the responsibility of host to explicitly send stop/abort command to terminate data transfer.
    }

    /// INTMASK Register bits
    namespace intmask_bits {
        constexpr uint32_t INT_MASK = (16 << 0);  ///< These bits used to mask unwanted interrupts. A value of 0 masks interrupt, and a value of 1 enables the interrupt. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): Rx Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation-by-host timeout; Bit 9 (DRTO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INT_MASK = (2 << 16);  ///< SDIO interrupt mask, one bit for each card. Bit[17:16] correspond to card[15:0] respectively. When masked, SDIO interrupt detection for that card is disabled. 0 masks an interrupt, and 1 enables an interrupt.
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Value indicates command argument to be passed to the card.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t INDEX = (6 << 0);  ///< Command index.
        constexpr uint32_t RESPONSE_EXPECT = (1U << 6);  ///< 0: No response expected from card; 1: Response expected from card.
        constexpr uint32_t RESPONSE_LENGTH = (1U << 7);  ///< 0: Short response expected from card; 1: Long response expected from card.
        constexpr uint32_t CHECK_RESPONSE_CRC = (1U << 8);  ///< 0: Do not check; 1: Check response CRC. Some of command responses do not return valid CRC bits. Software should disable CRC checks for those commands in order to disable CRC checking by controller.
        constexpr uint32_t DATA_EXPECTED = (1U << 9);  ///< 0: No data transfer expected; 1: Data transfer expected.
        constexpr uint32_t READ_WRITE = (1U << 10);  ///< 0: Read from card; 1: Write to card. Don't care if no data is expected from card.
        constexpr uint32_t TRANSFER_MODE = (1U << 11);  ///< 0: Block data transfer command; 1: Stream data transfer command. Don't care if no data expected.
        constexpr uint32_t SEND_AUTO_STOP = (1U << 12);  ///< 0: No stop command is sent at the end of data transfer; 1: Send stop command at the end of data transfer.
        constexpr uint32_t WAIT_PRVDATA_COMPLETE = (1U << 13);  ///< 0: Send command at once, even if previous data transfer has not completed; 1: Wait for previous data transfer to complete before sending Command. The SDHOST_WAIT_PRVDATA_COMPLETE] = 0 option is typically used to query status of card during data transfer or to stop current data transfer. SDHOST_CARD_NUMBERr should be same as in previous command.
        constexpr uint32_t STOP_ABORT_CMD = (1U << 14);  ///< 0: Neither stop nor abort command can stop current data transfer. If abort is sent to function-number currently selected or not in data-transfer mode, then bit should be set to 0; 1: Stop or abort command intended to stop current data transfer in progress. When open-ended or predefined data transfer is in progress, and host issues stop or abort command to stop data transfer, bit should be set so that command/data state-machines of CIU can return correctly to idle state.
        constexpr uint32_t SEND_INITIALIZATION = (1U << 15);  ///< 0: Do not send initialization sequence (80 clocks of 1) before sending this command; 1: Send initialization sequence before sending this command. After powered on, 80 clocks must be sent to card for initialization before sending any commands to card. Bit should be set while sending first command to card so that controller will initialize clocks before sending command to card.
        constexpr uint32_t CARD_NUMBER = (5 << 16);  ///< Card number in use. Represents physical slot number of card being accessed. In SD-only mode, up to two cards are supported.
        constexpr uint32_t UPDATE_CLOCK_REGISTERS_ONLY = (1U << 21);  ///< 0: Normal command sequence; 1: Do not send commands, just update clock register value into card clock domain. Following register values are transferred into card clock domain: CLKDIV, CLRSRC, and CLKENA. Changes card clocks (change frequency, truncate off or on, and set low-frequency mode). This is provided in order to change clock frequency or stop clock without having to send command to cards. During normal command sequence, when sdhost_update_clock_registers_only = 0, following control registers are transferred from BIU to CIU: CMD, CMDARG, TMOUT, CTYPE, BLKSIZ, and BYTCNT. CIU uses new register values for new command sequence to card(s). When bit is set, there are no Command Done interrupts because no command is sent to SD_MMC_CEATA cards.
        constexpr uint32_t READ_CEATA_DEVICE = (1U << 22);  ///< Read access flag. 0: Host is not performing read access (RW_REG or RW_BLK)towards CE-ATA device; 1: Host is performing read access (RW_REG or RW_BLK) towards CE-ATA device. Software should set this bit to indicate that CE-ATA device is being accessed for read transfer. This bit is used to disable read data timeout indication while performing CE-ATA read transfers. Maximum value of I/O transmission delay can be no less than 10 seconds. SD/MMC should not indicate read data timeout while waiting for data from CE-ATA device.
        constexpr uint32_t CCS_EXPECTED = (1U << 23);  ///< Expected Command Completion Signal (CCS) configuration. 0: Interrupts are not enabled in CE-ATA device (nIEN = 1 in ATA control register), or command does not expect CCS from device; 1: Interrupts are enabled in CE-ATA device (nIEN = 0), and RW_BLK command expects command completion signal from CE-ATA device. If the command expects Command Completion Signal (CCS) from the CE-ATA device, the software should set this control bit. SD/MMC sets Data Transfer Over (DTO) bit in RINTSTS register and generates interrupt to host if Data Transfer Over interrupt is not masked.
        constexpr uint32_t USE_HOLE = (1U << 29);  ///< Use Hold Register. 0: CMD and DATA sent to card bypassing HOLD Register; 1: CMD and DATA sent to card through the HOLD Register.
        constexpr uint32_t START_CMD = (1U << 31);  ///< Start command. Once command is served by the CIU, this bit is automatically cleared. When this bit is set, host should not attempt to write to any command registers. If a write is attempted, hardware lock error is set in raw interrupt register. Once command is sent and a response is received from SD_MMC_CEATA cards, Command Done bit is set in the raw interrupt Register.
    }

    /// RESP0 Register bits
    namespace resp0_bits {
        constexpr uint32_t RESPONSE0 = (32 << 0);  ///< Bit[31:0] of response.
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t RESPONSE1 = (32 << 0);  ///< Bit[63:32] of long response.
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t RESPONSE2 = (32 << 0);  ///< Bit[95:64] of long response.
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t RESPONSE3 = (32 << 0);  ///< Bit[127:96] of long response.
    }

    /// MINTSTS Register bits
    namespace mintsts_bits {
        constexpr uint32_t INT_STATUS_MSK = (16 << 0);  ///< Interrupt enabled only if corresponding bit in interrupt mask register is set. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_MSK = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. SDIO interrupt for card is enabled only if corresponding sdhost_sdio_int_mask bit is set in Interrupt mask register (Setting mask bit enables interrupt).
    }

    /// RINTSTS Register bits
    namespace rintsts_bits {
        constexpr uint32_t INT_STATUS_RAW = (16 << 0);  ///< Setting a bit clears the corresponding interrupt and writing 0 has no effect. Bits are logged regardless of interrupt mask status. Bit 15 (EBE): End-bit error/no CRC error; Bit 14 (ACD): Auto command done; Bit 13 (SBE/BCI): RX Start Bit Error; Bit 12 (HLE): Hardware locked write error; Bit 11 (FRUN): FIFO underrun/overrun error; Bit 10 (HTO): Data starvation by host timeout (HTO); Bit 9 (DTRO): Data read timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO data request; Bit 3 (DTO): Data transfer over; Bit 2 (CD): Command done; Bit 1 (RE): Response error; Bit 0 (CD): Card detect.
        constexpr uint32_t SDIO_INTERRUPT_RAW = (2 << 16);  ///< Interrupt from SDIO card, one bit for each card. Bit[17:16] correspond to card1 and card0, respectively. Setting a bit clears the corresponding interrupt bit and writing 0 has no effect. 0: No SDIO interrupt from card; 1: SDIO interrupt from card.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t FIFO_RX_WATERMARK = (1U << 0);  ///< FIFO reached Receive watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_TX_WATERMARK = (1U << 1);  ///< FIFO reached Transmit watermark level, not qualified with data transfer.
        constexpr uint32_t FIFO_EMPTY = (1U << 2);  ///< FIFO is empty status.
        constexpr uint32_t FIFO_FULL = (1U << 3);  ///< FIFO is full status.
        constexpr uint32_t COMMAND_FSM_STATES = (4 << 4);  ///< Command FSM states. 0: Idle; 1: Send init sequence; 2: Send cmd start bit; 3: Send cmd tx bit; 4: Send cmd index + arg; 5: Send cmd crc7; 6: Send cmd end bit; 7: Receive resp start bit; 8: Receive resp IRQ response; 9: Receive resp tx bit; 10: Receive resp cmd idx; 11: Receive resp data; 12: Receive resp crc7; 13: Receive resp end bit; 14: Cmd path wait NCC; 15: Wait, cmd-to-response turnaround.
        constexpr uint32_t DATA_3_STATUS = (1U << 8);  ///< Raw selected sdhost_card_data[3], checks whether card is present. 0: card not present; 1: card present.
        constexpr uint32_t DATA_BUSY = (1U << 9);  ///< Inverted version of raw selected sdhost_card_data[0]. 0: Card data not busy; 1: Card data busy.
        constexpr uint32_t DATA_STATE_MC_BUSY = (1U << 10);  ///< Data transmit or receive state-machine is busy.
        constexpr uint32_t RESPONSE_INDEX = (6 << 11);  ///< Index of previous response, including any auto-stop sent by core.
        constexpr uint32_t FIFO_COUNT = (13 << 17);  ///< FIFO count, number of filled locations in FIFO.
    }

    /// FIFOTH Register bits
    namespace fifoth_bits {
        constexpr uint32_t TX_WMARK = (12 << 0);  ///< FIFO threshold watermark level when transmitting data to card. When FIFO data count is less than or equal to this number, DMA/FIFO request is raised. If Interrupt is enabled, then interrupt occurs. During end of packet, request or interrupt is generated, regardless of threshold programming.In non-DMA mode, when transmit FIFO threshold (TXDR) interrupt is enabled, then interrupt is generated instead of DMA request. During end of packet, on last interrupt, host is responsible for filling FIFO with only required remaining bytes (not before FIFO is full or after CIU completes data transfers, because FIFO may not be empty). In DMA mode, at end of packet, if last transfer is less than burst size, DMA controller does single cycles until required bytes are transferred.
        constexpr uint32_t RX_WMARK = (11 << 16);  ///< FIFO threshold watermark level when receiving data to card.When FIFO data count reaches greater than this number , DMA/FIFO request is raised. During end of packet, request is generated regardless of threshold programming in order to complete any remaining data.In non-DMA mode, when receiver FIFO threshold (RXDR) interrupt is enabled, then interrupt is generated instead of DMA request.During end of packet, interrupt is not generated if threshold programming is larger than any remaining data. It is responsibility of host to read remaining bytes on seeing Data Transfer Done interrupt.In DMA mode, at end of packet, even if remaining bytes are less than threshold, DMA request does single transfers to flush out any remaining bytes before Data Transfer Done interrupt is set.
        constexpr uint32_t DMA_MULTIPLE_TRANSACTION_SIZE = (3 << 28);  ///< Burst size of multiple transaction, should be programmed same as DMA controller multiple-transaction-size SDHOST_SRC/DEST_MSIZE. 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer.
    }

    /// CDETECT Register bits
    namespace cdetect_bits {
        constexpr uint32_t CARD_DETECT_N = (2 << 0);  ///< Value on sdhost_card_detect_n input ports (1 bit per card), read-only bits. 0 represents presence of card. Only NUM_CARDS number of bits are implemented.
    }

    /// WRTPRT Register bits
    namespace wrtprt_bits {
        constexpr uint32_t WRITE_PROTECT = (2 << 0);  ///< Value on sdhost_card_write_prt input ports (1 bit per card). 1 represents write protection. Only NUM_CARDS number of bits are implemented.
    }

    /// TCBCNT Register bits
    namespace tcbcnt_bits {
        constexpr uint32_t TCBCNT = (32 << 0);  ///< Number of bytes transferred by CIU unit to card.
    }

    /// TBBCNT Register bits
    namespace tbbcnt_bits {
        constexpr uint32_t TBBCNT = (32 << 0);  ///< Number of bytes transferred between Host/DMA memory and BIU FIFO.
    }

    /// DEBNCE Register bits
    namespace debnce_bits {
        constexpr uint32_t DEBOUNCE_COUNT = (24 << 0);  ///< Number of host clocks (clk) used by debounce filter logic. The typical debounce time is 5 \verb+~+ 25 ms to prevent the card instability when the card is inserted or removed.
    }

    /// USRID Register bits
    namespace usrid_bits {
        constexpr uint32_t USRID = (32 << 0);  ///< User identification register, value set by user. Can also be used as a scratchpad register by user.
    }

    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSIONID = (32 << 0);  ///< Hardware version register. Can also be read by fireware.
    }

    /// HCON Register bits
    namespace hcon_bits {
        constexpr uint32_t CARD_TYPE = (1U << 0);  ///< Hardware support SDIO and MMC.
        constexpr uint32_t CARD_NUM = (5 << 1);  ///< Support card number is 2.
        constexpr uint32_t BUS_TYPE = (1U << 6);  ///< Register config is APB bus.
        constexpr uint32_t DATA_WIDTH = (3 << 7);  ///< Regisger data widht is 32.
        constexpr uint32_t ADDR_WIDTH = (6 << 10);  ///< Register address width is 32.
        constexpr uint32_t DMA_WIDTH = (3 << 18);  ///< DMA data witdth is 32.
        constexpr uint32_t RAM_INDISE = (1U << 21);  ///< Inside RAM in SDMMC module.
        constexpr uint32_t HOLD = (1U << 22);  ///< Have a hold regiser in data path .
        constexpr uint32_t NUM_CLK_DIV = (2 << 24);  ///< Have 4 clk divider in design .
    }

    /// UHS Register bits
    namespace uhs_bits {
        constexpr uint32_t DDR = (2 << 16);  ///< DDR mode selecton,1 bit for each card. 0-Non-DDR mdoe. 1-DDR mdoe.
    }

    /// RST_N Register bits
    namespace rst_n_bits {
        constexpr uint32_t CARD_RESET = (2 << 0);  ///< Hardware reset. 1: Active mode; 0: Reset. These bits cause the cards to enter pre-idle state, which requires them to be re-initialized. SDHOST_RST_CARD_RESET[0] should be set to 1'b0 to reset card0, SDHOST_RST_CARD_RESET[1] should be set to 1'b0 to reset card1.
    }

    /// BMOD Register bits
    namespace bmod_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset. When set, the DMA Controller resets all its internal registers. It is automatically cleared after one clock cycle.
        constexpr uint32_t FB = (1U << 1);  ///< Fixed Burst. Controls whether the AHB Master interface performs fixed burst transfers or not. When set, the AHB will use only SINGLE, INCR4, INCR8 or INCR16 during start of normal burst transfers. When reset, the AHB will use SINGLE and INCR burst transfer operations.
        constexpr uint32_t DE = (1U << 7);  ///< IDMAC Enable. When set, the IDMAC is enabled.
        constexpr uint32_t PBL = (3 << 8);  ///< Programmable Burst Length. These bits indicate the maximum number of beats to be performed in one IDMAC???Internal DMA Control???transaction. The IDMAC will always attempt to burst as specified in PBL each time it starts a burst transfer on the host bus. The permissible values are 1, 4, 8, 16, 32, 64, 128 and 256. This value is the mirror of MSIZE of FIFOTH register. In order to change this value, write the required value to FIFOTH register. This is an encode value as follows: 000: 1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer; 011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte transfer; 110: 128-byte transfer; 111: 256-byte transfer. PBL is a read-only value and is applicable only for data access, it does not apply to descriptor access.
    }

    /// PLDMND Register bits
    namespace pldmnd_bits {
        constexpr uint32_t PD = (32 << 0);  ///< Poll Demand. If the OWNER bit of a descriptor is not set, the FSM goes to the Suspend state. The host needs to write any value into this register for the IDMAC FSM to resume normal descriptor fetch operation. This is a write only .
    }

    /// DBADDR Register bits
    namespace dbaddr_bits {
        constexpr uint32_t DBADDR = (32 << 0);  ///< Start of Descriptor List. Contains the base address of the First Descriptor. The LSB bits [1:0] are ignored and taken as all-zero by the IDMAC internally. Hence these LSB bits may be treated as read-only.
    }

    /// IDSTS Register bits
    namespace idsts_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt. Indicates that data transmission is finished for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt. Indicates the completion of data reception for a descriptor. Writing 1 clears this bit.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Interrupt. Indicates that a Bus Error occurred (IDSTS[12:10]) . When this bit is set, the DMA disables all its bus accesses. Writing 1 clears this bit.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. This bit is set when the descriptor is unavailable due to OWNER bit = 0 (DES0[31] = 0). Writing 1 clears this bit.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error Summary. Indicates the status of the transaction to/from the card, also present in RINTSTS. Indicates the logical OR of the following bits: EBE : End Bit Error; RTO : Response Timeout/Boot Ack Timeout; RCRC : Response CRC; SBE : Start Bit Error; DRTO : Data Read Timeout/BDS timeout; DCRC : Data CRC for Receive; RE : Response Error. Writing 1 clears this bit. The abort condition of the IDMAC depends on the setting of this CES bit. If the CES bit is enabled, then the IDMAC aborts on a response error.
        constexpr uint32_t NIS = (1U << 8);  ///< Normal Interrupt Summary. Logical OR of the following: IDSTS[0] : Transmit Interrupt, IDSTS[1] : Receive Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes NIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t AIS = (1U << 9);  ///< Abnormal Interrupt Summary. Logical OR of the following: IDSTS[2] : Fatal Bus Interrupt, IDSTS[4] : DU bit Interrupt. Only unmasked bits affect this bit. This is a sticky bit and must be cleared each time a corresponding bit that causes AIS to be set is cleared. Writing 1 clears this bit.
        constexpr uint32_t FBE_CODE = (3 << 10);  ///< Fatal Bus Error Code. Indicates the type of error that caused a Bus Error. Valid only when the Fatal Bus Error bit IDSTS[2] is set. This field does not generate an interrupt. 001: Host Abort received during transmission; 010: Host Abort received during reception; Others: Reserved.
        constexpr uint32_t FSM = (4 << 13);  ///< DMAC FSM present state. 0: DMA_IDLE (idle state); 1: DMA_SUSPEND (suspend state); 2: DESC_RD (descriptor reading state); 3: DESC_CHK (descriptor checking state); 4: DMA_RD_REQ_WAIT (read-data request waiting state); 5: DMA_WR_REQ_WAIT (write-data request waiting state); 6: DMA_RD (data-read state); 7: DMA_WR (data-write state); 8: DESC_CLOSE (descriptor close state).
    }

    /// IDINTEN Register bits
    namespace idinten_bits {
        constexpr uint32_t TI = (1U << 0);  ///< Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable, Transmit Interrupt is enabled. When reset, Transmit Interrupt is disabled.
        constexpr uint32_t RI = (1U << 1);  ///< Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive Interrupt is enabled. When reset, Receive Interrupt is disabled.
        constexpr uint32_t FBE = (1U << 2);  ///< Fatal Bus Error Enable. When set with Abnormal Interrupt Summary Enable, the Fatal Bus Error Interrupt is enabled. When reset, Fatal Bus Error Enable Interrupt is disabled.
        constexpr uint32_t DU = (1U << 4);  ///< Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary Enable, the DU interrupt is enabled.
        constexpr uint32_t CES = (1U << 5);  ///< Card Error summary Interrupt Enable. When set, it enables the Card Interrupt summary.
        constexpr uint32_t NI = (1U << 8);  ///< Normal Interrupt Summary Enable. When set, a normal interrupt is enabled. When reset, a normal interrupt is disabled. This bit enables the following bits: IDINTEN[0]: Transmit Interrupt; IDINTEN[1]: Receive Interrupt.
        constexpr uint32_t AI = (1U << 9);  ///< Abnormal Interrupt Summary Enable. When set, an abnormal interrupt is enabled. This bit enables the following bits: IDINTEN[2]: Fatal Bus Error Interrupt; IDINTEN[4]: DU Interrupt.
    }

    /// DSCADDR Register bits
    namespace dscaddr_bits {
        constexpr uint32_t DSCADDR = (32 << 0);  ///< Host Descriptor Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the start address of the current descriptor read by the IDMAC.
    }

    /// BUFADDR Register bits
    namespace bufaddr_bits {
        constexpr uint32_t BUFADDR = (32 << 0);  ///< Host Buffer Address Pointer, updated by IDMAC during operation and cleared on reset. This register points to the current Data Buffer Address being accessed by the IDMAC.
    }

    /// CARDTHRCTL Register bits
    namespace cardthrctl_bits {
        constexpr uint32_t CARDRDTHREN = (1U << 0);  ///< Card read threshold enable. 1'b0-Card read threshold disabled. 1'b1-Card read threshold enabled.
        constexpr uint32_t CARDCLRINTEN = (1U << 1);  ///< Busy clear interrupt generation: 1'b0-Busy clear interrypt disabled. 1'b1-Busy clear interrypt enabled.
        constexpr uint32_t CARDWRTHREN = (1U << 2);  ///< Applicable when HS400 mode is enabled. 1'b0-Card write Threshold disabled. 1'b1-Card write Threshold enabled.
        constexpr uint32_t CARDTHRESHOLD = (16 << 16);  ///< The inside FIFO size is 512,This register is applicable when SDHOST_CARDERTHREN_REG is set to 1 or SDHOST_CARDRDTHREN_REG set to 1.
    }

    /// EMMCDDR Register bits
    namespace emmcddr_bits {
        constexpr uint32_t HALFSTARTBIT = (2 << 0);  ///< Control for start bit detection mechanism duration of start bit.Each bit refers to one slot.Set this bit to 1 for eMMC4.5 and above,set to 0 for SD applications.For eMMC4.5,start bit can be: 1'b0-Full cycle. 1'b1-less than one full cycle.
        constexpr uint32_t HS400_MODE = (1U << 31);  ///< Set 1 to enable HS400 mode.
    }

    /// ENSHIFT Register bits
    namespace enshift_bits {
        constexpr uint32_t ENABLE_SHIFT = (4 << 0);  ///< Control for the amount of phase shift provided on the default enables in the design.Two bits assigned for each card. 2'b00-Default phase shift. 2'b01-Enables shifted to next immediate positive edge. 2'b10-Enables shifted to next immediate negative edge. 2'b11-Reserved.
    }

    /// BUFFIFO Register bits
    namespace buffifo_bits {
        constexpr uint32_t BUFFIFO = (32 << 0);  ///< CPU write and read transmit data by FIFO. This register points to the current Data FIFO .
    }

    /// CLK_EDGE_SEL Register bits
    namespace clk_edge_sel_bits {
        constexpr uint32_t CCLKIN_EDGE_DRV_SEL = (3 << 0);  ///< It's used to select the clock phase of the output signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SAM_SEL = (3 << 3);  ///< It's used to select the clock phase of the input signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLKIN_EDGE_SLF_SEL = (3 << 6);  ///< It's used to select the clock phase of the internal signal from phase 0, phase 90, phase 180, phase 270.
        constexpr uint32_t CCLLKIN_EDGE_H = (4 << 9);  ///< The high level of the divider clock. The value should be smaller than CCLKIN_EDGE_L.
        constexpr uint32_t CCLLKIN_EDGE_L = (4 << 13);  ///< The low level of the divider clock. The value should be larger than CCLKIN_EDGE_H.
        constexpr uint32_t CCLLKIN_EDGE_N = (4 << 17);  ///< The clock division of cclk_in.
        constexpr uint32_t ESDIO_MODE = (1U << 21);  ///< Enable esdio mode.
        constexpr uint32_t ESD_MODE = (1U << 22);  ///< Enable esd mode.
        constexpr uint32_t CCLK_EN = (1U << 23);  ///< Sdio clock enable.
    }

}

// ============================================================================
// SENS Peripheral
// ============================================================================

namespace sens {
    /// Base addresses
    constexpr uint32_t SENS_BASE = 0x60008800;

    /// SENS Register structure
    struct Registers {
        volatile uint32_t SAR_READER1_CTRL;  ///< Offset: 0x00 - configure saradc1 reader
        volatile uint32_t SAR_READER1_STATUS;  ///< Offset: 0x04 - get saradc1 reader controller status
        volatile uint32_t SAR_MEAS1_CTRL1;  ///< Offset: 0x08 - no public
        volatile uint32_t SAR_MEAS1_CTRL2;  ///< Offset: 0x0C - configure saradc1 controller
        volatile uint32_t SAR_MEAS1_MUX;  ///< Offset: 0x10 - configure saradc1 controller
        volatile uint32_t SAR_ATTEN1;  ///< Offset: 0x14 - configure saradc1 controller
        volatile uint32_t SAR_AMP_CTRL1;  ///< Offset: 0x18 - no public
        volatile uint32_t SAR_AMP_CTRL2;  ///< Offset: 0x1C - no public
        volatile uint32_t SAR_AMP_CTRL3;  ///< Offset: 0x20 - no public
        volatile uint32_t SAR_READER2_CTRL;  ///< Offset: 0x24 - configure saradc2 reader
        volatile uint32_t SAR_READER2_STATUS;  ///< Offset: 0x28 - get saradc1 reader controller status
        volatile uint32_t SAR_MEAS2_CTRL1;  ///< Offset: 0x2C - configure saradc2 controller
        volatile uint32_t SAR_MEAS2_CTRL2;  ///< Offset: 0x30 - configure saradc2 controller
        volatile uint32_t SAR_MEAS2_MUX;  ///< Offset: 0x34 - configure saradc2 controller
        volatile uint32_t SAR_ATTEN2;  ///< Offset: 0x38 - configure saradc2 controller
        volatile uint32_t SAR_POWER_XPD_SAR;  ///< Offset: 0x3C - configure power of saradc
        volatile uint32_t SAR_SLAVE_ADDR1;  ///< Offset: 0x40 - configure i2c slave address
        volatile uint32_t SAR_SLAVE_ADDR2;  ///< Offset: 0x44 - configure i2c slave address
        volatile uint32_t SAR_SLAVE_ADDR3;  ///< Offset: 0x48 - configure i2c slave address
        volatile uint32_t SAR_SLAVE_ADDR4;  ///< Offset: 0x4C - configure i2c slave address
        volatile uint32_t SAR_TSENS_CTRL;  ///< Offset: 0x50 - configure tsens controller
        volatile uint32_t SAR_TSENS_CTRL2;  ///< Offset: 0x54 - configure tsens controller
        volatile uint32_t SAR_I2C_CTRL;  ///< Offset: 0x58 - configure rtc i2c controller by sw
        volatile uint32_t SAR_TOUCH_CONF;  ///< Offset: 0x5C - configure touch controller
        volatile uint32_t SAR_TOUCH_DENOISE;  ///< Offset: 0x60 - configure touch controller
        volatile uint32_t SAR_TOUCH_THRES1;  ///< Offset: 0x64 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES2;  ///< Offset: 0x68 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES3;  ///< Offset: 0x6C - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES4;  ///< Offset: 0x70 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES5;  ///< Offset: 0x74 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES6;  ///< Offset: 0x78 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES7;  ///< Offset: 0x7C - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES8;  ///< Offset: 0x80 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES9;  ///< Offset: 0x84 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES10;  ///< Offset: 0x88 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES11;  ///< Offset: 0x8C - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES12;  ///< Offset: 0x90 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES13;  ///< Offset: 0x94 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_THRES14;  ///< Offset: 0x98 - configure touch thres of touch pad
        volatile uint32_t SAR_TOUCH_CHN_ST;  ///< Offset: 0x9C - Get touch channel status
        volatile uint32_t SAR_TOUCH_STATUS0;  ///< Offset: 0xA0 - get touch scan status
        volatile uint32_t SAR_TOUCH_STATUS1;  ///< Offset: 0xA4 - touch channel status of touch pad 1
        volatile uint32_t SAR_TOUCH_STATUS2;  ///< Offset: 0xA8 - touch channel status of touch pad 2
        volatile uint32_t SAR_TOUCH_STATUS3;  ///< Offset: 0xAC - touch channel status of touch pad 3
        volatile uint32_t SAR_TOUCH_STATUS4;  ///< Offset: 0xB0 - touch channel status of touch pad 4
        volatile uint32_t SAR_TOUCH_STATUS5;  ///< Offset: 0xB4 - touch channel status of touch pad 5
        volatile uint32_t SAR_TOUCH_STATUS6;  ///< Offset: 0xB8 - touch channel status of touch pad 6
        volatile uint32_t SAR_TOUCH_STATUS7;  ///< Offset: 0xBC - touch channel status of touch pad 7
        volatile uint32_t SAR_TOUCH_STATUS8;  ///< Offset: 0xC0 - touch channel status of touch pad 8
        volatile uint32_t SAR_TOUCH_STATUS9;  ///< Offset: 0xC4 - touch channel status of touch pad 9
        volatile uint32_t SAR_TOUCH_STATUS10;  ///< Offset: 0xC8 - touch channel status of touch pad 10
        volatile uint32_t SAR_TOUCH_STATUS11;  ///< Offset: 0xCC - touch channel status of touch pad 11
        volatile uint32_t SAR_TOUCH_STATUS12;  ///< Offset: 0xD0 - touch channel status of touch pad 12
        volatile uint32_t SAR_TOUCH_STATUS13;  ///< Offset: 0xD4 - touch channel status of touch pad 13
        volatile uint32_t SAR_TOUCH_STATUS14;  ///< Offset: 0xD8 - touch channel status of touch pad 14
        volatile uint32_t SAR_TOUCH_STATUS15;  ///< Offset: 0xDC - touch channel status of sleep pad
        volatile uint32_t SAR_TOUCH_STATUS16;  ///< Offset: 0xE0 - touch channel status of approach mode
        volatile uint32_t SAR_COCPU_STATE;  ///< Offset: 0xE4 - get cocpu status
        volatile uint32_t SAR_COCPU_INT_RAW;  ///< Offset: 0xE8 - the interrupt raw of ulp
        volatile uint32_t SAR_COCPU_INT_ENA;  ///< Offset: 0xEC - the interrupt enable of ulp
        volatile uint32_t SAR_COCPU_INT_ST;  ///< Offset: 0xF0 - the interrupt state of ulp
        volatile uint32_t SAR_COCPU_INT_CLR;  ///< Offset: 0xF4 - the interrupt clear of ulp
        volatile uint32_t SAR_COCPU_DEBUG;  ///< Offset: 0xF8 - Ulp-riscv debug signal
        volatile uint32_t SAR_HALL_CTRL;  ///< Offset: 0xFC - no public
        volatile uint32_t SAR_NOUSE;  ///< Offset: 0x100 - no public
        volatile uint32_t SAR_PERI_CLK_GATE_CONF;  ///< Offset: 0x104 - the peri clock gate of rtc peri
        volatile uint32_t SAR_PERI_RESET_CONF;  ///< Offset: 0x108 - the peri reset of rtc peri
        volatile uint32_t SAR_COCPU_INT_ENA_W1TS;  ///< Offset: 0x10C - the interrupt enable of ulp
        volatile uint32_t SAR_COCPU_INT_ENA_W1TC;  ///< Offset: 0x110 - the interrupt enable clear of ulp
        volatile uint32_t SAR_DEBUG_CONF;  ///< Offset: 0x114 - rtc peri debug configure
        volatile uint32_t SAR_SARDATE;  ///< Offset: 0x1FC - version
    };

    /// Peripheral instances
    inline Registers* SENS = reinterpret_cast<Registers*>(SENS_BASE);

    // Bit definitions
    /// SAR_READER1_CTRL Register bits
    namespace sar_reader1_ctrl_bits {
        constexpr uint32_t SAR_SAR1_CLK_DIV = (8 << 0);  ///< clock divider
        constexpr uint32_t SAR_SAR1_CLK_GATED = (1U << 18);  ///< no public
        constexpr uint32_t SAR_SAR1_SAMPLE_NUM = (8 << 19);  ///< no public
        constexpr uint32_t SAR_SAR1_DATA_INV = (1U << 28);  ///< Invert SAR ADC1 data
        constexpr uint32_t SAR_SAR1_INT_EN = (1U << 29);  ///< enable saradc1 to send out interrupt
    }

    /// SAR_READER1_STATUS Register bits
    namespace sar_reader1_status_bits {
        constexpr uint32_t SAR_SAR1_READER_STATUS = (32 << 0);  ///< get saradc1 reader controller status
    }

    /// SAR_MEAS1_CTRL1 Register bits
    namespace sar_meas1_ctrl1_bits {
        constexpr uint32_t FORCE_XPD_AMP = (2 << 24);  ///< no public
        constexpr uint32_t AMP_RST_FB_FORCE = (2 << 26);  ///< no public
        constexpr uint32_t AMP_SHORT_REF_FORCE = (2 << 28);  ///< no public
        constexpr uint32_t AMP_SHORT_REF_GND_FORCE = (2 << 30);  ///< no public
    }

    /// SAR_MEAS1_CTRL2 Register bits
    namespace sar_meas1_ctrl2_bits {
        constexpr uint32_t MEAS1_DATA_SAR = (16 << 0);  ///< SAR ADC1 data
        constexpr uint32_t MEAS1_DONE_SAR = (1U << 16);  ///< SAR ADC1 conversion done indication
        constexpr uint32_t MEAS1_START_SAR = (1U << 17);  ///< SAR ADC1 controller (in RTC) starts conversion
        constexpr uint32_t MEAS1_START_FORCE = (1U << 18);  ///< 1: SAR ADC1 controller (in RTC) is started by SW
        constexpr uint32_t SAR1_EN_PAD = (12 << 19);  ///< SAR ADC1 pad enable bitmap
        constexpr uint32_t SAR1_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC1 pad enable bitmap is controlled by SW
    }

    /// SAR_MEAS1_MUX Register bits
    namespace sar_meas1_mux_bits {
        constexpr uint32_t SAR1_DIG_FORCE = (1U << 31);  ///< 1: SAR ADC1 controlled by DIG ADC1 CTRL
    }

    /// SAR_ATTEN1 Register bits
    namespace sar_atten1_bits {
        constexpr uint32_t SAR1_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad
    }

    /// SAR_AMP_CTRL1 Register bits
    namespace sar_amp_ctrl1_bits {
        constexpr uint32_t SAR_AMP_WAIT1 = (16 << 0);  ///< no public
        constexpr uint32_t SAR_AMP_WAIT2 = (16 << 16);  ///< no public
    }

    /// SAR_AMP_CTRL2 Register bits
    namespace sar_amp_ctrl2_bits {
        constexpr uint32_t SAR_SAR1_DAC_XPD_FSM_IDLE = (1U << 0);  ///< no public
        constexpr uint32_t SAR_XPD_SAR_AMP_FSM_IDLE = (1U << 1);  ///< no public
        constexpr uint32_t SAR_AMP_RST_FB_FSM_IDLE = (1U << 2);  ///< no public
        constexpr uint32_t SAR_AMP_SHORT_REF_FSM_IDLE = (1U << 3);  ///< no public
        constexpr uint32_t SAR_AMP_SHORT_REF_GND_FSM_IDLE = (1U << 4);  ///< no public
        constexpr uint32_t SAR_XPD_SAR_FSM_IDLE = (1U << 5);  ///< no public
        constexpr uint32_t SAR_RSTB_FSM_IDLE = (1U << 6);  ///< no public
        constexpr uint32_t SAR_AMP_WAIT3 = (16 << 16);  ///< no public
    }

    /// SAR_AMP_CTRL3 Register bits
    namespace sar_amp_ctrl3_bits {
        constexpr uint32_t SAR1_DAC_XPD_FSM = (4 << 0);  ///< no public
        constexpr uint32_t XPD_SAR_AMP_FSM = (4 << 4);  ///< no public
        constexpr uint32_t AMP_RST_FB_FSM = (4 << 8);  ///< no public
        constexpr uint32_t AMP_SHORT_REF_FSM = (4 << 12);  ///< no public
        constexpr uint32_t AMP_SHORT_REF_GND_FSM = (4 << 16);  ///< no public
        constexpr uint32_t XPD_SAR_FSM = (4 << 20);  ///< no public
        constexpr uint32_t RSTB_FSM = (4 << 24);  ///< no public
    }

    /// SAR_READER2_CTRL Register bits
    namespace sar_reader2_ctrl_bits {
        constexpr uint32_t SAR_SAR2_CLK_DIV = (8 << 0);  ///< clock divider
        constexpr uint32_t SAR_SAR2_WAIT_ARB_CYCLE = (2 << 16);  ///< wait arbit stable after sar_done
        constexpr uint32_t SAR_SAR2_CLK_GATED = (1U << 18);  ///< ******* Description ***********
        constexpr uint32_t SAR_SAR2_SAMPLE_NUM = (8 << 19);  ///< ******* Description ***********
        constexpr uint32_t SAR_SAR2_DATA_INV = (1U << 29);  ///< Invert SAR ADC2 data
        constexpr uint32_t SAR_SAR2_INT_EN = (1U << 30);  ///< enable saradc2 to send out interrupt
    }

    /// SAR_READER2_STATUS Register bits
    namespace sar_reader2_status_bits {
        constexpr uint32_t SAR_SAR2_READER_STATUS = (32 << 0);  ///< get saradc1 reader controller status
    }

    /// SAR_MEAS2_CTRL1 Register bits
    namespace sar_meas2_ctrl1_bits {
        constexpr uint32_t SAR_SAR2_CNTL_STATE = (3 << 0);  ///< saradc2_cntl_fsm
        constexpr uint32_t SAR_SAR2_PWDET_CAL_EN = (1U << 3);  ///< rtc control pwdet enable
        constexpr uint32_t SAR_SAR2_PKDET_CAL_EN = (1U << 4);  ///< rtc control pkdet enable
        constexpr uint32_t SAR_SAR2_EN_TEST = (1U << 5);  ///< SAR2_EN_TEST
        constexpr uint32_t SAR_SAR2_RSTB_FORCE = (2 << 6);  ///< no public
        constexpr uint32_t SAR_SAR2_STANDBY_WAIT = (8 << 8);  ///< no public
        constexpr uint32_t SAR_SAR2_RSTB_WAIT = (8 << 16);  ///< no public
        constexpr uint32_t SAR_SAR2_XPD_WAIT = (8 << 24);  ///< no public
    }

    /// SAR_MEAS2_CTRL2 Register bits
    namespace sar_meas2_ctrl2_bits {
        constexpr uint32_t MEAS2_DATA_SAR = (16 << 0);  ///< SAR ADC2 data
        constexpr uint32_t MEAS2_DONE_SAR = (1U << 16);  ///< SAR ADC2 conversion done indication
        constexpr uint32_t MEAS2_START_SAR = (1U << 17);  ///< SAR ADC2 controller (in RTC) starts conversion
        constexpr uint32_t MEAS2_START_FORCE = (1U << 18);  ///< 1: SAR ADC2 controller (in RTC) is started by SW
        constexpr uint32_t SAR2_EN_PAD = (12 << 19);  ///< SAR ADC2 pad enable bitmap
        constexpr uint32_t SAR2_EN_PAD_FORCE = (1U << 31);  ///< 1: SAR ADC2 pad enable bitmap is controlled by SW
    }

    /// SAR_MEAS2_MUX Register bits
    namespace sar_meas2_mux_bits {
        constexpr uint32_t SAR2_PWDET_CCT = (3 << 28);  ///< SAR2_PWDET_CCT
        constexpr uint32_t SAR2_RTC_FORCE = (1U << 31);  ///< in sleep, force to use rtc to control ADC
    }

    /// SAR_ATTEN2 Register bits
    namespace sar_atten2_bits {
        constexpr uint32_t SAR2_ATTEN = (32 << 0);  ///< 2-bit attenuation for each pad
    }

    /// SAR_POWER_XPD_SAR Register bits
    namespace sar_power_xpd_sar_bits {
        constexpr uint32_t FORCE_XPD_SAR = (2 << 29);  ///< force power on/off saradc
        constexpr uint32_t SARCLK_EN = (1U << 31);  ///< no public
    }

    /// SAR_SLAVE_ADDR1 Register bits
    namespace sar_slave_addr1_bits {
        constexpr uint32_t SAR_I2C_SLAVE_ADDR1 = (11 << 0);  ///< configure i2c slave address1
        constexpr uint32_t SAR_I2C_SLAVE_ADDR0 = (11 << 11);  ///< configure i2c slave address0
        constexpr uint32_t SAR_SARADC_MEAS_STATUS = (8 << 22);  ///< no public
    }

    /// SAR_SLAVE_ADDR2 Register bits
    namespace sar_slave_addr2_bits {
        constexpr uint32_t SAR_I2C_SLAVE_ADDR3 = (11 << 0);  ///< configure i2c slave address3
        constexpr uint32_t SAR_I2C_SLAVE_ADDR2 = (11 << 11);  ///< configure i2c slave address2
    }

    /// SAR_SLAVE_ADDR3 Register bits
    namespace sar_slave_addr3_bits {
        constexpr uint32_t SAR_I2C_SLAVE_ADDR5 = (11 << 0);  ///< configure i2c slave address5
        constexpr uint32_t SAR_I2C_SLAVE_ADDR4 = (11 << 11);  ///< configure i2c slave address4
    }

    /// SAR_SLAVE_ADDR4 Register bits
    namespace sar_slave_addr4_bits {
        constexpr uint32_t SAR_I2C_SLAVE_ADDR7 = (11 << 0);  ///< configure i2c slave address7
        constexpr uint32_t SAR_I2C_SLAVE_ADDR6 = (11 << 11);  ///< configure i2c slave address6
    }

    /// SAR_TSENS_CTRL Register bits
    namespace sar_tsens_ctrl_bits {
        constexpr uint32_t SAR_TSENS_OUT = (8 << 0);  ///< temperature sensor data out
        constexpr uint32_t SAR_TSENS_READY = (1U << 8);  ///< indicate temperature sensor out ready
        constexpr uint32_t SAR_TSENS_INT_EN = (1U << 12);  ///< enable temperature sensor to send out interrupt
        constexpr uint32_t SAR_TSENS_IN_INV = (1U << 13);  ///< invert temperature sensor data
        constexpr uint32_t SAR_TSENS_CLK_DIV = (8 << 14);  ///< temperature sensor clock divider
        constexpr uint32_t SAR_TSENS_POWER_UP = (1U << 22);  ///< temperature sensor power up
        constexpr uint32_t SAR_TSENS_POWER_UP_FORCE = (1U << 23);  ///< 1: dump out & power up controlled by SW 0: by FSM
        constexpr uint32_t SAR_TSENS_DUMP_OUT = (1U << 24);  ///< temperature sensor dump out only active when reg_tsens_power_up_force = 1
    }

    /// SAR_TSENS_CTRL2 Register bits
    namespace sar_tsens_ctrl2_bits {
        constexpr uint32_t SAR_TSENS_XPD_WAIT = (12 << 0);  ///< no public
        constexpr uint32_t SAR_TSENS_XPD_FORCE = (2 << 12);  ///< no public
        constexpr uint32_t SAR_TSENS_CLK_INV = (1U << 14);  ///< no public
    }

    /// SAR_I2C_CTRL Register bits
    namespace sar_i2c_ctrl_bits {
        constexpr uint32_t SAR_I2C_CTRL = (28 << 0);  ///< I2C control data only active when reg_sar_i2c_start_force = 1
        constexpr uint32_t SAR_I2C_START = (1U << 28);  ///< start I2C only active when reg_sar_i2c_start_force = 1
        constexpr uint32_t SAR_I2C_START_FORCE = (1U << 29);  ///< 1: I2C started by SW 0: I2C started by FSM
    }

    /// SAR_TOUCH_CONF Register bits
    namespace sar_touch_conf_bits {
        constexpr uint32_t SAR_TOUCH_OUTEN = (15 << 0);  ///< touch controller output enable
        constexpr uint32_t SAR_TOUCH_STATUS_CLR = (1U << 15);  ///< clear all touch active status
        constexpr uint32_t SAR_TOUCH_DATA_SEL = (2 << 16);  ///< 3: smooth data 2: baseline 1,0: raw_data
        constexpr uint32_t SAR_TOUCH_DENOISE_END = (1U << 18);  ///< touch_denoise_done
        constexpr uint32_t SAR_TOUCH_UNIT_END = (1U << 19);  ///< touch_unit_done
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD2 = (4 << 20);  ///< indicate which pad is approach pad2
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD1 = (4 << 24);  ///< indicate which pad is approach pad1
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD0 = (4 << 28);  ///< indicate which pad is approach pad0
    }

    /// SAR_TOUCH_DENOISE Register bits
    namespace sar_touch_denoise_bits {
        constexpr uint32_t DATA = (22 << 0);  ///< configure touch controller
    }

    /// SAR_TOUCH_THRES1 Register bits
    namespace sar_touch_thres1_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH1 = (22 << 0);  ///< Finger threshold for touch pad 1
    }

    /// SAR_TOUCH_THRES2 Register bits
    namespace sar_touch_thres2_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH2 = (22 << 0);  ///< Finger threshold for touch pad 2
    }

    /// SAR_TOUCH_THRES3 Register bits
    namespace sar_touch_thres3_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH3 = (22 << 0);  ///< Finger threshold for touch pad 3
    }

    /// SAR_TOUCH_THRES4 Register bits
    namespace sar_touch_thres4_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH4 = (22 << 0);  ///< Finger threshold for touch pad 4
    }

    /// SAR_TOUCH_THRES5 Register bits
    namespace sar_touch_thres5_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH5 = (22 << 0);  ///< Finger threshold for touch pad 5
    }

    /// SAR_TOUCH_THRES6 Register bits
    namespace sar_touch_thres6_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH6 = (22 << 0);  ///< Finger threshold for touch pad 6
    }

    /// SAR_TOUCH_THRES7 Register bits
    namespace sar_touch_thres7_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH7 = (22 << 0);  ///< Finger threshold for touch pad 7
    }

    /// SAR_TOUCH_THRES8 Register bits
    namespace sar_touch_thres8_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH8 = (22 << 0);  ///< Finger threshold for touch pad 8
    }

    /// SAR_TOUCH_THRES9 Register bits
    namespace sar_touch_thres9_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH9 = (22 << 0);  ///< Finger threshold for touch pad 9
    }

    /// SAR_TOUCH_THRES10 Register bits
    namespace sar_touch_thres10_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH10 = (22 << 0);  ///< Finger threshold for touch pad 10
    }

    /// SAR_TOUCH_THRES11 Register bits
    namespace sar_touch_thres11_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH11 = (22 << 0);  ///< Finger threshold for touch pad 11
    }

    /// SAR_TOUCH_THRES12 Register bits
    namespace sar_touch_thres12_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH12 = (22 << 0);  ///< Finger threshold for touch pad 12
    }

    /// SAR_TOUCH_THRES13 Register bits
    namespace sar_touch_thres13_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH13 = (22 << 0);  ///< Finger threshold for touch pad 13
    }

    /// SAR_TOUCH_THRES14 Register bits
    namespace sar_touch_thres14_bits {
        constexpr uint32_t SAR_TOUCH_OUT_TH14 = (22 << 0);  ///< Finger threshold for touch pad 14
    }

    /// SAR_TOUCH_CHN_ST Register bits
    namespace sar_touch_chn_st_bits {
        constexpr uint32_t SAR_TOUCH_PAD_ACTIVE = (15 << 0);  ///< touch active status
        constexpr uint32_t SAR_TOUCH_CHANNEL_CLR = (15 << 15);  ///< Clear touch channel
        constexpr uint32_t SAR_TOUCH_MEAS_DONE = (1U << 31);  ///< get touch meas done
    }

    /// SAR_TOUCH_STATUS0 Register bits
    namespace sar_touch_status0_bits {
        constexpr uint32_t SAR_TOUCH_SCAN_CURR = (4 << 22);  ///< current sample channel
    }

    /// SAR_TOUCH_STATUS1 Register bits
    namespace sar_touch_status1_bits {
        constexpr uint32_t SAR_TOUCH_PAD1_DATA = (22 << 0);  ///< touch data debounce of touch pad 1
        constexpr uint32_t SAR_TOUCH_PAD1_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 1
    }

    /// SAR_TOUCH_STATUS2 Register bits
    namespace sar_touch_status2_bits {
        constexpr uint32_t SAR_TOUCH_PAD2_DATA = (22 << 0);  ///< touch data debounce of touch pad 2
        constexpr uint32_t SAR_TOUCH_PAD2_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 2
    }

    /// SAR_TOUCH_STATUS3 Register bits
    namespace sar_touch_status3_bits {
        constexpr uint32_t SAR_TOUCH_PAD3_DATA = (22 << 0);  ///< touch data debounce of touch pad 3
        constexpr uint32_t SAR_TOUCH_PAD3_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 3
    }

    /// SAR_TOUCH_STATUS4 Register bits
    namespace sar_touch_status4_bits {
        constexpr uint32_t SAR_TOUCH_PAD4_DATA = (22 << 0);  ///< touch data debounce of touch pad 4
        constexpr uint32_t SAR_TOUCH_PAD4_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 4
    }

    /// SAR_TOUCH_STATUS5 Register bits
    namespace sar_touch_status5_bits {
        constexpr uint32_t SAR_TOUCH_PAD5_DATA = (22 << 0);  ///< touch data debounce of touch pad 5
        constexpr uint32_t SAR_TOUCH_PAD5_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 5
    }

    /// SAR_TOUCH_STATUS6 Register bits
    namespace sar_touch_status6_bits {
        constexpr uint32_t SAR_TOUCH_PAD6_DATA = (22 << 0);  ///< touch data debounce of touch pad 6
        constexpr uint32_t SAR_TOUCH_PAD6_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 6
    }

    /// SAR_TOUCH_STATUS7 Register bits
    namespace sar_touch_status7_bits {
        constexpr uint32_t SAR_TOUCH_PAD7_DATA = (22 << 0);  ///< touch data debounce of touch pad 7
        constexpr uint32_t SAR_TOUCH_PAD7_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 7
    }

    /// SAR_TOUCH_STATUS8 Register bits
    namespace sar_touch_status8_bits {
        constexpr uint32_t SAR_TOUCH_PAD8_DATA = (22 << 0);  ///< touch data debounce of touch pad 8
        constexpr uint32_t SAR_TOUCH_PAD8_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 8
    }

    /// SAR_TOUCH_STATUS9 Register bits
    namespace sar_touch_status9_bits {
        constexpr uint32_t SAR_TOUCH_PAD9_DATA = (22 << 0);  ///< touch data debounce of touch pad 9
        constexpr uint32_t SAR_TOUCH_PAD9_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 9
    }

    /// SAR_TOUCH_STATUS10 Register bits
    namespace sar_touch_status10_bits {
        constexpr uint32_t SAR_TOUCH_PAD10_DATA = (22 << 0);  ///< touch data debounce of touch pad 10
        constexpr uint32_t SAR_TOUCH_PAD10_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 10
    }

    /// SAR_TOUCH_STATUS11 Register bits
    namespace sar_touch_status11_bits {
        constexpr uint32_t SAR_TOUCH_PAD11_DATA = (22 << 0);  ///< touch data debounce of touch pad 11
        constexpr uint32_t SAR_TOUCH_PAD11_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 11
    }

    /// SAR_TOUCH_STATUS12 Register bits
    namespace sar_touch_status12_bits {
        constexpr uint32_t SAR_TOUCH_PAD12_DATA = (22 << 0);  ///< touch data debounce of touch pad 12
        constexpr uint32_t SAR_TOUCH_PAD12_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 12
    }

    /// SAR_TOUCH_STATUS13 Register bits
    namespace sar_touch_status13_bits {
        constexpr uint32_t SAR_TOUCH_PAD13_DATA = (22 << 0);  ///< touch data debounce of touch pad 13
        constexpr uint32_t SAR_TOUCH_PAD13_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 13
    }

    /// SAR_TOUCH_STATUS14 Register bits
    namespace sar_touch_status14_bits {
        constexpr uint32_t SAR_TOUCH_PAD14_DATA = (22 << 0);  ///< touch data debounce of touch pad 14
        constexpr uint32_t SAR_TOUCH_PAD14_DEBOUNCE = (3 << 29);  ///< touch current debounce of touch pad 14
    }

    /// SAR_TOUCH_STATUS15 Register bits
    namespace sar_touch_status15_bits {
        constexpr uint32_t SAR_TOUCH_SLP_DATA = (22 << 0);  ///< touch data debounce of sleep pad
        constexpr uint32_t SAR_TOUCH_SLP_DEBOUNCE = (3 << 29);  ///< touch current debounce of sleep pad
    }

    /// SAR_TOUCH_STATUS16 Register bits
    namespace sar_touch_status16_bits {
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD2_CNT = (8 << 0);  ///< touch current approach count of approach pad2
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD1_CNT = (8 << 8);  ///< touch current approach count of approach pad1
        constexpr uint32_t SAR_TOUCH_APPROACH_PAD0_CNT = (8 << 16);  ///< touch current approach count of approach pad0
        constexpr uint32_t SAR_TOUCH_SLP_APPROACH_CNT = (8 << 24);  ///< touch current approach count of slp pad
    }

    /// SAR_COCPU_STATE Register bits
    namespace sar_cocpu_state_bits {
        constexpr uint32_t SAR_COCPU_DBG_TRIGGER = (1U << 25);  ///< trigger cocpu debug registers
        constexpr uint32_t SAR_COCPU_CLK_EN_ST = (1U << 26);  ///< check cocpu whether clk on
        constexpr uint32_t SAR_COCPU_RESET_N = (1U << 27);  ///< check cocpu whether in reset state
        constexpr uint32_t SAR_COCPU_EOI = (1U << 28);  ///< check cocpu whether in interrupt state
        constexpr uint32_t SAR_COCPU_TRAP = (1U << 29);  ///< check cocpu whether in trap state
        constexpr uint32_t SAR_COCPU_EBREAK = (1U << 30);  ///< check cocpu whether in ebreak
    }

    /// SAR_COCPU_INT_RAW Register bits
    namespace sar_cocpu_int_raw_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_RAW = (1U << 0);  ///< int from touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_RAW = (1U << 1);  ///< int from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_RAW = (1U << 2);  ///< int from touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_RAW = (1U << 3);  ///< int from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_RAW = (1U << 4);  ///< int from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_RAW = (1U << 5);  ///< int from tsens
        constexpr uint32_t SAR_COCPU_START_INT_RAW = (1U << 6);  ///< int from start
        constexpr uint32_t SAR_COCPU_SW_INT_RAW = (1U << 7);  ///< int from software
        constexpr uint32_t SAR_COCPU_SWD_INT_RAW = (1U << 8);  ///< int from super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_RAW = (1U << 9);  ///< int from timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_RAW = (1U << 10);  ///< int from approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_RAW = (1U << 11);  ///< int from touch scan done
    }

    /// SAR_COCPU_INT_ENA Register bits
    namespace sar_cocpu_int_ena_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA = (1U << 0);  ///< int enable of touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA = (1U << 1);  ///< int enable of from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA = (1U << 2);  ///< int enable of touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_ENA = (1U << 3);  ///< int enable of from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_ENA = (1U << 4);  ///< int enable of from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_ENA = (1U << 5);  ///< int enable of tsens
        constexpr uint32_t SAR_COCPU_START_INT_ENA = (1U << 6);  ///< int enable of start
        constexpr uint32_t SAR_COCPU_SW_INT_ENA = (1U << 7);  ///< int enable of software
        constexpr uint32_t SAR_COCPU_SWD_INT_ENA = (1U << 8);  ///< int enable of super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA = (1U << 9);  ///< int enable of timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA = (1U << 10);  ///< int enable of approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA = (1U << 11);  ///< int enable of touch scan done
    }

    /// SAR_COCPU_INT_ST Register bits
    namespace sar_cocpu_int_st_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_ST = (1U << 0);  ///< int state of touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ST = (1U << 1);  ///< int state of from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ST = (1U << 2);  ///< int state of touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_ST = (1U << 3);  ///< int state of from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_ST = (1U << 4);  ///< int state of from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_ST = (1U << 5);  ///< int state of tsens
        constexpr uint32_t SAR_COCPU_START_INT_ST = (1U << 6);  ///< int state of start
        constexpr uint32_t SAR_COCPU_SW_INT_ST = (1U << 7);  ///< int state of software
        constexpr uint32_t SAR_COCPU_SWD_INT_ST = (1U << 8);  ///< int state of super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ST = (1U << 9);  ///< int state of timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ST = (1U << 10);  ///< int state of approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ST = (1U << 11);  ///< int state of touch scan done
    }

    /// SAR_COCPU_INT_CLR Register bits
    namespace sar_cocpu_int_clr_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_CLR = (1U << 0);  ///< int clear of touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_CLR = (1U << 1);  ///< int clear of from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_CLR = (1U << 2);  ///< int clear of touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_CLR = (1U << 3);  ///< int clear of from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_CLR = (1U << 4);  ///< int clear of from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_CLR = (1U << 5);  ///< int clear of tsens
        constexpr uint32_t SAR_COCPU_START_INT_CLR = (1U << 6);  ///< int clear of start
        constexpr uint32_t SAR_COCPU_SW_INT_CLR = (1U << 7);  ///< int clear of software
        constexpr uint32_t SAR_COCPU_SWD_INT_CLR = (1U << 8);  ///< int clear of super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_CLR = (1U << 9);  ///< int clear of timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_CLR = (1U << 10);  ///< int clear of approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_CLR = (1U << 11);  ///< int clear of touch scan done
    }

    /// SAR_COCPU_DEBUG Register bits
    namespace sar_cocpu_debug_bits {
        constexpr uint32_t SAR_COCPU_PC = (13 << 0);  ///< cocpu Program counter
        constexpr uint32_t SAR_COCPU_MEM_VLD = (1U << 13);  ///< cocpu mem valid output
        constexpr uint32_t SAR_COCPU_MEM_RDY = (1U << 14);  ///< cocpu mem ready input
        constexpr uint32_t SAR_COCPU_MEM_WEN = (4 << 15);  ///< cocpu mem write enable output
        constexpr uint32_t SAR_COCPU_MEM_ADDR = (13 << 19);  ///< cocpu mem address output
    }

    /// SAR_HALL_CTRL Register bits
    namespace sar_hall_ctrl_bits {
        constexpr uint32_t XPD_HALL = (1U << 28);  ///< Power on hall sensor and connect to VP and VN
        constexpr uint32_t XPD_HALL_FORCE = (1U << 29);  ///< 1: XPD HALL is controlled by SW. 0: XPD HALL is controlled by FSM in ULP-coprocessor
        constexpr uint32_t HALL_PHASE = (1U << 30);  ///< Reverse phase of hall sensor
        constexpr uint32_t HALL_PHASE_FORCE = (1U << 31);  ///< 1: HALL PHASE is controlled by SW 0: HALL PHASE is controlled by FSM in ULP-coprocessor
    }

    /// SAR_NOUSE Register bits
    namespace sar_nouse_bits {
        constexpr uint32_t SAR_NOUSE = (32 << 0);  ///< no public
    }

    /// SAR_PERI_CLK_GATE_CONF Register bits
    namespace sar_peri_clk_gate_conf_bits {
        constexpr uint32_t RTC_I2C_CLK_EN = (1U << 27);  ///< enable rtc i2c clock
        constexpr uint32_t TSENS_CLK_EN = (1U << 29);  ///< enable tsens clock
        constexpr uint32_t SARADC_CLK_EN = (1U << 30);  ///< enbale saradc clock
        constexpr uint32_t IOMUX_CLK_EN = (1U << 31);  ///< enable io_mux clock
    }

    /// SAR_PERI_RESET_CONF Register bits
    namespace sar_peri_reset_conf_bits {
        constexpr uint32_t SAR_COCPU_RESET = (1U << 25);  ///< enable ulp-riscv reset
        constexpr uint32_t SAR_RTC_I2C_RESET = (1U << 27);  ///< Reserved.
        constexpr uint32_t SAR_TSENS_RESET = (1U << 29);  ///< enbale saradc reset
        constexpr uint32_t SAR_SARADC_RESET = (1U << 30);  ///< enable io_mux reset
    }

    /// SAR_COCPU_INT_ENA_W1TS Register bits
    namespace sar_cocpu_int_ena_w1ts_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA_W1TS = (1U << 0);  ///< int enable of touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA_W1TS = (1U << 1);  ///< int enable of from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA_W1TS = (1U << 2);  ///< int enable of touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_ENA_W1TS = (1U << 3);  ///< int enable of from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_ENA_W1TS = (1U << 4);  ///< int enable of from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_ENA_W1TS = (1U << 5);  ///< int enable of tsens
        constexpr uint32_t SAR_COCPU_START_INT_ENA_W1TS = (1U << 6);  ///< int enable of start
        constexpr uint32_t SAR_COCPU_SW_INT_ENA_W1TS = (1U << 7);  ///< int enable of software
        constexpr uint32_t SAR_COCPU_SWD_INT_ENA_W1TS = (1U << 8);  ///< int enable of super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA_W1TS = (1U << 9);  ///< int enable of timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TS = (1U << 10);  ///< int enable of approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA_W1TS = (1U << 11);  ///< int enable of touch scan done
    }

    /// SAR_COCPU_INT_ENA_W1TC Register bits
    namespace sar_cocpu_int_ena_w1tc_bits {
        constexpr uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA_W1TC = (1U << 0);  ///< Clear int enable of touch done
        constexpr uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA_W1TC = (1U << 1);  ///< Clear int enable of from touch inactive
        constexpr uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA_W1TC = (1U << 2);  ///< Clear int enable of touch active
        constexpr uint32_t SAR_COCPU_SARADC1_INT_ENA_W1TC = (1U << 3);  ///< Clear int enable of from saradc1
        constexpr uint32_t SAR_COCPU_SARADC2_INT_ENA_W1TC = (1U << 4);  ///< Clear int enable of from saradc2
        constexpr uint32_t SAR_COCPU_TSENS_INT_ENA_W1TC = (1U << 5);  ///< Clear int enable of tsens
        constexpr uint32_t SAR_COCPU_START_INT_ENA_W1TC = (1U << 6);  ///< Clear int enable of start
        constexpr uint32_t SAR_COCPU_SW_INT_ENA_W1TC = (1U << 7);  ///< Clear int enable of software
        constexpr uint32_t SAR_COCPU_SWD_INT_ENA_W1TC = (1U << 8);  ///< Clear int enable of super watch dog
        constexpr uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA_W1TC = (1U << 9);  ///< Clear int enable of timeout done
        constexpr uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TC = (1U << 10);  ///< Clear int enable of approach loop done
        constexpr uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA_W1TC = (1U << 11);  ///< Clear int enable of touch scan done
    }

    /// SAR_DEBUG_CONF Register bits
    namespace sar_debug_conf_bits {
        constexpr uint32_t SAR_DEBUG_BIT_SEL = (5 << 0);  ///< no public
    }

    /// SAR_SARDATE Register bits
    namespace sar_sardate_bits {
        constexpr uint32_t SAR_DATE = (28 << 0);  ///< version
    }

}

// ============================================================================
// SENSITIVE Peripheral
// ============================================================================

namespace sensitive {
    /// Base addresses
    constexpr uint32_t SENSITIVE_BASE = 0x600C1000;

    /// SENSITIVE Register structure
    struct Registers {
        volatile uint32_t CACHE_DATAARRAY_CONNECT_0;  ///< Offset: 0x00 - Cache data array configuration register 0.
        volatile uint32_t CACHE_DATAARRAY_CONNECT_1;  ///< Offset: 0x04 - Cache data array configuration register 1.
        volatile uint32_t APB_PERIPHERAL_ACCESS_0;  ///< Offset: 0x08 - APB peripheral configuration register 0.
        volatile uint32_t APB_PERIPHERAL_ACCESS_1;  ///< Offset: 0x0C - APB peripheral configuration register 1.
        volatile uint32_t INTERNAL_SRAM_USAGE_0;  ///< Offset: 0x10 - Internal SRAM configuration register 0.
        volatile uint32_t INTERNAL_SRAM_USAGE_1;  ///< Offset: 0x14 - Internal SRAM configuration register 1.
        volatile uint32_t INTERNAL_SRAM_USAGE_2;  ///< Offset: 0x18 - Internal SRAM configuration register 2.
        volatile uint32_t INTERNAL_SRAM_USAGE_3;  ///< Offset: 0x1C - Internal SRAM configuration register 3.
        volatile uint32_t INTERNAL_SRAM_USAGE_4;  ///< Offset: 0x20 - Internal SRAM configuration register 4.
        volatile uint32_t RETENTION_DISABLE;  ///< Offset: 0x24 - Retention configuration register.
        volatile uint32_t CACHE_TAG_ACCESS_0;  ///< Offset: 0x28 - Cache tag configuration register 0.
        volatile uint32_t CACHE_TAG_ACCESS_1;  ///< Offset: 0x2C - Cache tag configuration register 1.
        volatile uint32_t CACHE_MMU_ACCESS_0;  ///< Offset: 0x30 - Cache MMU configuration register 0.
        volatile uint32_t CACHE_MMU_ACCESS_1;  ///< Offset: 0x34 - Cache MMU configuration register 1.
        volatile uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_0;  ///< Offset: 0x38 - spi2 dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_1;  ///< Offset: 0x3C - spi2 dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_0;  ///< Offset: 0x40 - spi3 dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_1;  ///< Offset: 0x44 - spi3 dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_0;  ///< Offset: 0x48 - uhci0 dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_1;  ///< Offset: 0x4C - uhci0 dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_0;  ///< Offset: 0x50 - i2s0 dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_1;  ///< Offset: 0x54 - i2s0 dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_0;  ///< Offset: 0x58 - i2s1 dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_1;  ///< Offset: 0x5C - i2s1 dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_0;  ///< Offset: 0x60 - mac dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_1;  ///< Offset: 0x64 - mac dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0;  ///< Offset: 0x68 - backup dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1;  ///< Offset: 0x6C - backup dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_0;  ///< Offset: 0x70 - aes dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_1;  ///< Offset: 0x74 - aes dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_0;  ///< Offset: 0x78 - sha dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_1;  ///< Offset: 0x7C - sha dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0;  ///< Offset: 0x80 - adc_dac dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1;  ///< Offset: 0x84 - adc_dac dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_0;  ///< Offset: 0x88 - rmt dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_1;  ///< Offset: 0x8C - rmt dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_0;  ///< Offset: 0x90 - lcd_cam dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_1;  ///< Offset: 0x94 - lcd_cam dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_0;  ///< Offset: 0x98 - usb dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_1;  ///< Offset: 0x9C - usb dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_0;  ///< Offset: 0xA0 - lc dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_1;  ///< Offset: 0xA4 - lc dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_0;  ///< Offset: 0xA8 - sdio dma permission configuration register 0.
        volatile uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_1;  ///< Offset: 0xAC - sdio dma permission configuration register 1.
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_0;  ///< Offset: 0xB0 - dma permission monitor configuration register 0.
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_1;  ///< Offset: 0xB4 - dma permission monitor configuration register 1.
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_2;  ///< Offset: 0xB8 - dma permission monitor configuration register 2.
        volatile uint32_t DMA_APBPERI_PMS_MONITOR_3;  ///< Offset: 0xBC - dma permission monitor configuration register 3.
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0;  ///< Offset: 0xC0 - sram split line configuration register 0
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1;  ///< Offset: 0xC4 - sram split line configuration register 1
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2;  ///< Offset: 0xC8 - sram split line configuration register 1
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3;  ///< Offset: 0xCC - sram split line configuration register 1
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4;  ///< Offset: 0xD0 - sram split line configuration register 1
        volatile uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5;  ///< Offset: 0xD4 - sram split line configuration register 1
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_0;  ///< Offset: 0xD8 - corex iram0 permission configuration register 0
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_1;  ///< Offset: 0xDC - corex iram0 permission configuration register 0
        volatile uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_2;  ///< Offset: 0xE0 - corex iram0 permission configuration register 1
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_0;  ///< Offset: 0xE4 - core0 iram0 permission monitor configuration register 0
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_1;  ///< Offset: 0xE8 - core0 iram0 permission monitor configuration register 1
        volatile uint32_t CORE_0_IRAM0_PMS_MONITOR_2;  ///< Offset: 0xEC - core0 iram0 permission monitor configuration register 2
        volatile uint32_t CORE_1_IRAM0_PMS_MONITOR_0;  ///< Offset: 0xF0 - core1 iram0 permission monitor configuration register 0
        volatile uint32_t CORE_1_IRAM0_PMS_MONITOR_1;  ///< Offset: 0xF4 - core1 iram0 permission monitor configuration register 1
        volatile uint32_t CORE_1_IRAM0_PMS_MONITOR_2;  ///< Offset: 0xF8 - core1 iram0 permission monitor configuration register 2
        volatile uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_0;  ///< Offset: 0xFC - corex dram0 permission configuration register 0
        volatile uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_1;  ///< Offset: 0x100 - corex dram0 permission configuration register 1
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_0;  ///< Offset: 0x104 - core0 dram0 permission monitor configuration register 0
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_1;  ///< Offset: 0x108 - core0 dram0 permission monitor configuration register 1
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_2;  ///< Offset: 0x10C - core0 dram0 permission monitor configuration register 2.
        volatile uint32_t CORE_0_DRAM0_PMS_MONITOR_3;  ///< Offset: 0x110 - core0 dram0 permission monitor configuration register 3.
        volatile uint32_t CORE_1_DRAM0_PMS_MONITOR_0;  ///< Offset: 0x114 - core1 dram0 permission monitor configuration register 0
        volatile uint32_t CORE_1_DRAM0_PMS_MONITOR_1;  ///< Offset: 0x118 - core1 dram0 permission monitor configuration register 1
        volatile uint32_t CORE_1_DRAM0_PMS_MONITOR_2;  ///< Offset: 0x11C - core1 dram0 permission monitor configuration register 2.
        volatile uint32_t CORE_1_DRAM0_PMS_MONITOR_3;  ///< Offset: 0x120 - core1 dram0 permission monitor configuration register 3.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_0;  ///< Offset: 0x124 - Core0 access peripherals permission configuration register 0.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_1;  ///< Offset: 0x128 - Core0 access peripherals permission configuration register 1.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_2;  ///< Offset: 0x12C - Core0 access peripherals permission configuration register 2.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_3;  ///< Offset: 0x130 - Core0 access peripherals permission configuration register 3.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_4;  ///< Offset: 0x134 - Core0 access peripherals permission configuration register 4.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_5;  ///< Offset: 0x138 - Core0 access peripherals permission configuration register 5.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_6;  ///< Offset: 0x13C - Core0 access peripherals permission configuration register 6.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_7;  ///< Offset: 0x140 - Core0 access peripherals permission configuration register 7.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_8;  ///< Offset: 0x144 - Core0 access peripherals permission configuration register 8.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_9;  ///< Offset: 0x148 - Core0 access peripherals permission configuration register 9.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_10;  ///< Offset: 0x14C - Core0 access peripherals permission configuration register 10.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_11;  ///< Offset: 0x150 - Core0 access peripherals permission configuration register 11.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_12;  ///< Offset: 0x154 - Core0 access peripherals permission configuration register 12.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_13;  ///< Offset: 0x158 - Core0 access peripherals permission configuration register 13.
        volatile uint32_t CORE_0_PIF_PMS_CONSTRAIN_14;  ///< Offset: 0x15C - Core0 access peripherals permission configuration register 14.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_0;  ///< Offset: 0x160 - Core0 region permission register 0.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_1;  ///< Offset: 0x164 - Core0 region permission register 1.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_2;  ///< Offset: 0x168 - Core0 region permission register 2.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_3;  ///< Offset: 0x16C - Core0 region permission register 3.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_4;  ///< Offset: 0x170 - Core0 region permission register 4.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_5;  ///< Offset: 0x174 - Core0 region permission register 5.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_6;  ///< Offset: 0x178 - Core0 region permission register 6.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_7;  ///< Offset: 0x17C - Core0 region permission register 7.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_8;  ///< Offset: 0x180 - Core0 region permission register 8.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_9;  ///< Offset: 0x184 - Core0 region permission register 9.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_10;  ///< Offset: 0x188 - Core0 region permission register 10.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_11;  ///< Offset: 0x18C - Core0 region permission register 11.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_12;  ///< Offset: 0x190 - Core0 region permission register 12.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_13;  ///< Offset: 0x194 - Core0 region permission register 13.
        volatile uint32_t CORE_0_REGION_PMS_CONSTRAIN_14;  ///< Offset: 0x198 - Core0 region permission register 14.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_0;  ///< Offset: 0x19C - Core0 permission report register 0.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_1;  ///< Offset: 0x1A0 - Core0 permission report register 1.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_2;  ///< Offset: 0x1A4 - Core0 permission report register 2.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_3;  ///< Offset: 0x1A8 - Core0 permission report register 3.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_4;  ///< Offset: 0x1AC - Core0 permission report register 4.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_5;  ///< Offset: 0x1B0 - Core0 permission report register 5.
        volatile uint32_t CORE_0_PIF_PMS_MONITOR_6;  ///< Offset: 0x1B4 - Core0 permission report register 6.
        volatile uint32_t CORE_0_VECBASE_OVERRIDE_LOCK;  ///< Offset: 0x1B8 - core0 vecbase override configuration register 0
        volatile uint32_t CORE_0_VECBASE_OVERRIDE_0;  ///< Offset: 0x1BC - core0 vecbase override configuration register 0
        volatile uint32_t CORE_0_VECBASE_OVERRIDE_1;  ///< Offset: 0x1C0 - core0 vecbase override configuration register 1
        volatile uint32_t CORE_0_VECBASE_OVERRIDE_2;  ///< Offset: 0x1C4 - core0 vecbase override configuration register 1
        volatile uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_0;  ///< Offset: 0x1C8 - core0 toomanyexception override configuration register 0.
        volatile uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_1;  ///< Offset: 0x1CC - core0 toomanyexception override configuration register 1.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_0;  ///< Offset: 0x1D0 - Core1 access peripherals permission configuration register 0.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_1;  ///< Offset: 0x1D4 - Core1 access peripherals permission configuration register 1.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_2;  ///< Offset: 0x1D8 - Core1 access peripherals permission configuration register 2.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_3;  ///< Offset: 0x1DC - Core1 access peripherals permission configuration register 3.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_4;  ///< Offset: 0x1E0 - Core1 access peripherals permission configuration register 4.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_5;  ///< Offset: 0x1E4 - Core1 access peripherals permission configuration register 5.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_6;  ///< Offset: 0x1E8 - Core1 access peripherals permission configuration register 6.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_7;  ///< Offset: 0x1EC - Core1 access peripherals permission configuration register 7.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_8;  ///< Offset: 0x1F0 - Core1 access peripherals permission configuration register 8.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_9;  ///< Offset: 0x1F4 - Core1 access peripherals permission configuration register 9.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_10;  ///< Offset: 0x1F8 - core1 access peripherals permission configuration register 10.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_11;  ///< Offset: 0x1FC - core1 access peripherals permission configuration register 11.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_12;  ///< Offset: 0x200 - core1 access peripherals permission configuration register 12.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_13;  ///< Offset: 0x204 - core1 access peripherals permission configuration register 13.
        volatile uint32_t CORE_1_PIF_PMS_CONSTRAIN_14;  ///< Offset: 0x208 - core1 access peripherals permission configuration register 14.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_0;  ///< Offset: 0x20C - core1 region permission register 0.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_1;  ///< Offset: 0x210 - core1 region permission register 1.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_2;  ///< Offset: 0x214 - core1 region permission register 2.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_3;  ///< Offset: 0x218 - core1 region permission register 3.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_4;  ///< Offset: 0x21C - core1 region permission register 4.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_5;  ///< Offset: 0x220 - core1 region permission register 5.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_6;  ///< Offset: 0x224 - core1 region permission register 6.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_7;  ///< Offset: 0x228 - core1 region permission register 7.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_8;  ///< Offset: 0x22C - core1 region permission register 8.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_9;  ///< Offset: 0x230 - core1 region permission register 9.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_10;  ///< Offset: 0x234 - core1 region permission register 10.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_11;  ///< Offset: 0x238 - core1 region permission register 11.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_12;  ///< Offset: 0x23C - core1 region permission register 12.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_13;  ///< Offset: 0x240 - core1 region permission register 13.
        volatile uint32_t CORE_1_REGION_PMS_CONSTRAIN_14;  ///< Offset: 0x244 - core1 region permission register 14.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_0;  ///< Offset: 0x248 - core1 permission report register 0.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_1;  ///< Offset: 0x24C - core1 permission report register 1.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_2;  ///< Offset: 0x250 - core1 permission report register 2.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_3;  ///< Offset: 0x254 - core1 permission report register 3.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_4;  ///< Offset: 0x258 - core1 permission report register 4.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_5;  ///< Offset: 0x25C - core1 permission report register 5.
        volatile uint32_t CORE_1_PIF_PMS_MONITOR_6;  ///< Offset: 0x260 - core1 permission report register 6.
        volatile uint32_t CORE_1_VECBASE_OVERRIDE_LOCK;  ///< Offset: 0x264 - core1 vecbase override configuration register 0
        volatile uint32_t CORE_1_VECBASE_OVERRIDE_0;  ///< Offset: 0x268 - core1 vecbase override configuration register 0
        volatile uint32_t CORE_1_VECBASE_OVERRIDE_1;  ///< Offset: 0x26C - core1 vecbase override configuration register 1
        volatile uint32_t CORE_1_VECBASE_OVERRIDE_2;  ///< Offset: 0x270 - core1 vecbase override configuration register 1
        volatile uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_0;  ///< Offset: 0x274 - core1 toomanyexception override configuration register 0.
        volatile uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_1;  ///< Offset: 0x278 - core1 toomanyexception override configuration register 1.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_0;  ///< Offset: 0x27C - BackUp access peripherals permission configuration register 0.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_1;  ///< Offset: 0x280 - BackUp access peripherals permission configuration register 1.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_2;  ///< Offset: 0x284 - BackUp access peripherals permission configuration register 2.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_3;  ///< Offset: 0x288 - BackUp access peripherals permission configuration register 3.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_4;  ///< Offset: 0x28C - BackUp access peripherals permission configuration register 4.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_5;  ///< Offset: 0x290 - BackUp access peripherals permission configuration register 5.
        volatile uint32_t BACKUP_BUS_PMS_CONSTRAIN_6;  ///< Offset: 0x294 - BackUp access peripherals permission configuration register 6.
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_0;  ///< Offset: 0x298 - BackUp permission report register 0.
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_1;  ///< Offset: 0x29C - BackUp permission report register 1.
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_2;  ///< Offset: 0x2A0 - BackUp permission report register 2.
        volatile uint32_t BACKUP_BUS_PMS_MONITOR_3;  ///< Offset: 0x2A4 - BackUp permission report register 3.
        volatile uint32_t EDMA_BOUNDARY_LOCK;  ///< Offset: 0x2A8 - EDMA boundary lock register.
        volatile uint32_t EDMA_BOUNDARY_0;  ///< Offset: 0x2AC - EDMA boundary 0 configuration
        volatile uint32_t EDMA_BOUNDARY_1;  ///< Offset: 0x2B0 - EDMA boundary 1 configuration
        volatile uint32_t EDMA_BOUNDARY_2;  ///< Offset: 0x2B4 - EDMA boundary 2 configuration
        volatile uint32_t EDMA_PMS_SPI2_LOCK;  ///< Offset: 0x2B8 - EDMA-SPI2 permission lock register.
        volatile uint32_t EDMA_PMS_SPI2;  ///< Offset: 0x2BC - EDMA-SPI2 permission control register.
        volatile uint32_t EDMA_PMS_SPI3_LOCK;  ///< Offset: 0x2C0 - EDMA-SPI3 permission lock register.
        volatile uint32_t EDMA_PMS_SPI3;  ///< Offset: 0x2C4 - EDMA-SPI3 permission control register.
        volatile uint32_t EDMA_PMS_UHCI0_LOCK;  ///< Offset: 0x2C8 - EDMA-UHCI0 permission lock register.
        volatile uint32_t EDMA_PMS_UHCI0;  ///< Offset: 0x2CC - EDMA-UHCI0 permission control register.
        volatile uint32_t EDMA_PMS_I2S0_LOCK;  ///< Offset: 0x2D0 - EDMA-I2S0 permission lock register.
        volatile uint32_t EDMA_PMS_I2S0;  ///< Offset: 0x2D4 - EDMA-I2S0 permission control register.
        volatile uint32_t EDMA_PMS_I2S1_LOCK;  ///< Offset: 0x2D8 - EDMA-I2S1 permission lock register.
        volatile uint32_t EDMA_PMS_I2S1;  ///< Offset: 0x2DC - EDMA-I2S1 permission control register.
        volatile uint32_t EDMA_PMS_LCD_CAM_LOCK;  ///< Offset: 0x2E0 - EDMA-LCD/CAM permission lock register.
        volatile uint32_t EDMA_PMS_LCD_CAM;  ///< Offset: 0x2E4 - EDMA-LCD/CAM permission control register.
        volatile uint32_t EDMA_PMS_AES_LOCK;  ///< Offset: 0x2E8 - EDMA-AES permission lock register.
        volatile uint32_t EDMA_PMS_AES;  ///< Offset: 0x2EC - EDMA-AES permission control register.
        volatile uint32_t EDMA_PMS_SHA_LOCK;  ///< Offset: 0x2F0 - EDMA-SHA permission lock register.
        volatile uint32_t EDMA_PMS_SHA;  ///< Offset: 0x2F4 - EDMA-SHA permission control register.
        volatile uint32_t EDMA_PMS_ADC_DAC_LOCK;  ///< Offset: 0x2F8 - EDMA-ADC/DAC permission lock register.
        volatile uint32_t EDMA_PMS_ADC_DAC;  ///< Offset: 0x2FC - EDMA-ADC/DAC permission control register.
        volatile uint32_t EDMA_PMS_RMT_LOCK;  ///< Offset: 0x300 - EDMA-RMT permission lock register.
        volatile uint32_t EDMA_PMS_RMT;  ///< Offset: 0x304 - EDMA-RMT permission control register.
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x308 - Sensitive module clock gate configuration register.
        volatile uint32_t RTC_PMS;  ///< Offset: 0x30C - RTC coprocessor permission register.
        volatile uint32_t DATE;  ///< Offset: 0xFFC - Sensitive version register.
    };

    /// Peripheral instances
    inline Registers* SENSITIVE = reinterpret_cast<Registers*>(SENSITIVE_BASE);

    // Bit definitions
    /// CACHE_DATAARRAY_CONNECT_0 Register bits
    namespace cache_dataarray_connect_0_bits {
        constexpr uint32_t CACHE_DATAARRAY_CONNECT_LOCK = (1U << 0);  ///< Set 1 to lock cache data array registers.
    }

    /// CACHE_DATAARRAY_CONNECT_1 Register bits
    namespace cache_dataarray_connect_1_bits {
        constexpr uint32_t CACHE_DATAARRAY_CONNECT_FLATTEN = (8 << 0);  ///< Cache data array connection configuration.
    }

    /// APB_PERIPHERAL_ACCESS_0 Register bits
    namespace apb_peripheral_access_0_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_LOCK = (1U << 0);  ///< Set 1 to lock APB peripheral Configuration Register.
    }

    /// APB_PERIPHERAL_ACCESS_1 Register bits
    namespace apb_peripheral_access_1_bits {
        constexpr uint32_t APB_PERIPHERAL_ACCESS_SPLIT_BURST = (1U << 0);  ///< Set 1 to support split function for AHB access to APB peripherals.
    }

    /// INTERNAL_SRAM_USAGE_0 Register bits
    namespace internal_sram_usage_0_bits {
        constexpr uint32_t INTERNAL_SRAM_USAGE_LOCK = (1U << 0);  ///< Set 1 to lock internal SRAM Configuration Register.
    }

    /// INTERNAL_SRAM_USAGE_1 Register bits
    namespace internal_sram_usage_1_bits {
        constexpr uint32_t INTERNAL_SRAM_ICACHE_USAGE = (2 << 0);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by icache.
        constexpr uint32_t INTERNAL_SRAM_DCACHE_USAGE = (2 << 2);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by dcache.
        constexpr uint32_t INTERNAL_SRAM_CPU_USAGE = (7 << 4);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by cpu.
    }

    /// INTERNAL_SRAM_USAGE_2 Register bits
    namespace internal_sram_usage_2_bits {
        constexpr uint32_t INTERNAL_SRAM_CORE0_TRACE_USAGE = (7 << 0);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by core0 trace bus.
        constexpr uint32_t INTERNAL_SRAM_CORE1_TRACE_USAGE = (7 << 7);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by core1 trace bus.
        constexpr uint32_t INTERNAL_SRAM_CORE0_TRACE_ALLOC = (2 << 14);  ///< Which internal SRAM bank (16KB) of 64KB can be accessed by core0 trace bus.
        constexpr uint32_t INTERNAL_SRAM_CORE1_TRACE_ALLOC = (2 << 16);  ///< Which internal SRAM bank (16KB) of 64KB can be accessed by core1 trace bus.
    }

    /// INTERNAL_SRAM_USAGE_3 Register bits
    namespace internal_sram_usage_3_bits {
        constexpr uint32_t INTERNAL_SRAM_MAC_DUMP_USAGE = (4 << 0);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by mac dump.
    }

    /// INTERNAL_SRAM_USAGE_4 Register bits
    namespace internal_sram_usage_4_bits {
        constexpr uint32_t INTERNAL_SRAM_LOG_USAGE = (7 << 0);  ///< Set 1 to someone bit means corresponding internal SRAM level can be accessed by log bus.
    }

    /// RETENTION_DISABLE Register bits
    namespace retention_disable_bits {
        constexpr uint32_t RETENTION_DISABLE = (1U << 0);  ///< Set 1 to disable retention function and lock disable state.
    }

    /// CACHE_TAG_ACCESS_0 Register bits
    namespace cache_tag_access_0_bits {
        constexpr uint32_t CACHE_TAG_ACCESS_LOCK = (1U << 0);  ///< Set 1 to lock cache tag Configuration Register.
    }

    /// CACHE_TAG_ACCESS_1 Register bits
    namespace cache_tag_access_1_bits {
        constexpr uint32_t PRO_I_TAG_RD_ACS = (1U << 0);  ///< Set 1 to enable Icache read access tag memory.
        constexpr uint32_t PRO_I_TAG_WR_ACS = (1U << 1);  ///< Set 1 to enable Icache wrtie access tag memory.
        constexpr uint32_t PRO_D_TAG_RD_ACS = (1U << 2);  ///< Set 1 to enable Dcache read access tag memory.
        constexpr uint32_t PRO_D_TAG_WR_ACS = (1U << 3);  ///< Set 1 to enable Dcache wrtie access tag memory.
    }

    /// CACHE_MMU_ACCESS_0 Register bits
    namespace cache_mmu_access_0_bits {
        constexpr uint32_t CACHE_MMU_ACCESS_LOCK = (1U << 0);  ///< Set 1 to lock cache MMU registers.
    }

    /// CACHE_MMU_ACCESS_1 Register bits
    namespace cache_mmu_access_1_bits {
        constexpr uint32_t PRO_MMU_RD_ACS = (1U << 0);  ///< Set 1 to enable read access MMU memory.
        constexpr uint32_t PRO_MMU_WR_ACS = (1U << 1);  ///< Set 1 to enable write access MMU memory.
    }

    /// DMA_APBPERI_SPI2_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_spi2_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock spi2 dma permission Configuration Register.
    }

    /// DMA_APBPERI_SPI2_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_spi2_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< spi2's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< spi2's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< spi2's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< spi2's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< spi2's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< spi2's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_SPI3_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_spi3_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock spi3 dma permission Configuration Register.
    }

    /// DMA_APBPERI_SPI3_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_spi3_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< spi3's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< spi3's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< spi3's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< spi3's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< spi3's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< spi3's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_UHCI0_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_uhci0_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock uhci0 dma permission Configuration Register.
    }

    /// DMA_APBPERI_UHCI0_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_uhci0_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< uhci0's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< uhci0's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< uhci0's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< uhci0's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< uhci0's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< uhci0's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_I2S0_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_i2s0_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock i2s0 dma permission Configuration Register.
    }

    /// DMA_APBPERI_I2S0_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_i2s0_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< i2s0's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< i2s0's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< i2s0's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< i2s0's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< i2s0's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< i2s0's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_I2S1_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_i2s1_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock i2s1 dma permission Configuration Register.
    }

    /// DMA_APBPERI_I2S1_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_i2s1_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< i2s1's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< i2s1's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< i2s1's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< i2s1's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< i2s1's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< i2s1's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_MAC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_mac_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock mac dma permission Configuration Register.
    }

    /// DMA_APBPERI_MAC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_mac_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< mac's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< mac's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< mac's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< mac's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< mac's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< mac's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_backup_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock backup dma permission Configuration Register.
    }

    /// DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_backup_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< backup's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< backup's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< backup's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< backup's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< backup's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< backup's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_AES_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_aes_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock aes dma permission Configuration Register.
    }

    /// DMA_APBPERI_AES_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_aes_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< aes's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< aes's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< aes's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< aes's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< aes's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< aes's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_SHA_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_sha_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock sha dma permission Configuration Register.
    }

    /// DMA_APBPERI_SHA_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_sha_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< sha's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< sha's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< sha's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< sha's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< sha's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< sha's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_adc_dac_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock adc_dac dma permission Configuration Register.
    }

    /// DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_adc_dac_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< adc_dac's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< adc_dac's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< adc_dac's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< adc_dac's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< adc_dac's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< adc_dac's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_RMT_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_rmt_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock rmt dma permission Configuration Register.
    }

    /// DMA_APBPERI_RMT_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_rmt_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< rmt's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< rmt's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< rmt's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< rmt's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< rmt's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< rmt's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_lcd_cam_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock lcd_cam dma permission Configuration Register.
    }

    /// DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_lcd_cam_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< lcd_cam's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< lcd_cam's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< lcd_cam's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< lcd_cam's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< lcd_cam's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< lcd_cam's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_USB_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_usb_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock usb dma permission Configuration Register.
    }

    /// DMA_APBPERI_USB_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_usb_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< usb's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< usb's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< usb's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< usb's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< usb's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< usb's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_LC_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_lc_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock lc dma permission Configuration Register.
    }

    /// DMA_APBPERI_LC_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_lc_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< lc's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< lc's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< lc's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< lc's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< lc's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< lc's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_SDIO_PMS_CONSTRAIN_0 Register bits
    namespace dma_apbperi_sdio_pms_constrain_0_bits {
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock sdio dma permission Configuration Register.
    }

    /// DMA_APBPERI_SDIO_PMS_CONSTRAIN_1 Register bits
    namespace dma_apbperi_sdio_pms_constrain_1_bits {
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_0 = (2 << 0);  ///< sdio's permission(store,load) in data region0 of SRAM
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_1 = (2 << 2);  ///< sdio's permission(store,load) in data region1 of SRAM
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_2 = (2 << 4);  ///< sdio's permission(store,load) in data region2 of SRAM
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_3 = (2 << 6);  ///< sdio's permission(store,load) in data region3 of SRAM
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< sdio's permission(store,load) in dcache data sram block0
        constexpr uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< sdio's permission(store,load) in dcache data sram block1
    }

    /// DMA_APBPERI_PMS_MONITOR_0 Register bits
    namespace dma_apbperi_pms_monitor_0_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock dma permission monitor Configuration Register.
    }

    /// DMA_APBPERI_PMS_MONITOR_1 Register bits
    namespace dma_apbperi_pms_monitor_1_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear dma_pms_monitor_violate interrupt
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable dma pms monitor, if dma access violated permission, will trigger interrupt.
    }

    /// DMA_APBPERI_PMS_MONITOR_2 Register bits
    namespace dma_apbperi_pms_monitor_2_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< recorded dma's interrupt status when dma access violated permission
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 1);  ///< recorded dma's world status when dma access violated permission
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_ADDR = (22 << 3);  ///< recorded dma's address bit[25:4] status when dma access violated permission, real address is 0x3c00_0000+addr*16
    }

    /// DMA_APBPERI_PMS_MONITOR_3 Register bits
    namespace dma_apbperi_pms_monitor_3_bits {
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 0);  ///< recorded dma's write status when dma access violated permission, 1(write), 0(read)
        constexpr uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_BYTEEN = (16 << 1);  ///< recorded dma's byte enable status when dma access violated permission
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_0_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock sram split configuration register
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_1_bits {
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_0 = (2 << 0);  ///< category0 of core_x_iram0_dram_dma_line, if the splitaddress in block0 of SRAM, configured as 0x10, else if the splitaddress below block0 of SRAM, configured as 0x11, else if splitaddress higher than block0 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_1 = (2 << 2);  ///< category1 of core_x_iram0_dram_dma_line, if the splitaddress in block1 of SRAM, configured as 0x10, else if the splitaddress below block1 of SRAM, configured as 0x11, else if splitaddress higher than block1 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_2 = (2 << 4);  ///< category2 of core_x_iram0_dram_dma_line, if the splitaddress in block2 of SRAM, configured as 0x10, else if the splitaddress below block2 of SRAM, configured as 0x11, else if splitaddress higher than block2 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_3 = (2 << 6);  ///< category3 of core_x_iram0_dram_dma_line, if the splitaddress in block3 of SRAM, configured as 0x10, else if the splitaddress below block3 of SRAM, configured as 0x11, else if splitaddress higher than block3 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_4 = (2 << 8);  ///< category4 of core_x_iram0_dram_dma_line, if the splitaddress in block4 of SRAM, configured as 0x10, else if the splitaddress below block4 of SRAM, configured as 0x11, else if splitaddress higher than block4 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_5 = (2 << 10);  ///< category5 of core_x_iram0_dram_dma_line, if the splitaddress in block5 of SRAM, configured as 0x10, else if the splitaddress below block5 of SRAM, configured as 0x11, else if splitaddress higher than block5 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_6 = (2 << 12);  ///< category6 of core_x_iram0_dram_dma_line, if the splitaddress in block6 of SRAM, configured as 0x10, else if the splitaddress below block6 of SRAM, configured as 0x11, else if splitaddress higher than block6 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR = (8 << 14);  ///< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit of actual address
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_2_bits {
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_0 = (2 << 0);  ///< category0 of core_x_iram0_dram_dma_line, if the splitaddress in block0 of SRAM, configured as 0x10, else if the splitaddress below block0 of SRAM, configured as 0x11, else if splitaddress higher than block0 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_1 = (2 << 2);  ///< category1 of core_x_iram0_dram_dma_line, if the splitaddress in block1 of SRAM, configured as 0x10, else if the splitaddress below block1 of SRAM, configured as 0x11, else if splitaddress higher than block1 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_2 = (2 << 4);  ///< category2 of core_x_iram0_dram_dma_line, if the splitaddress in block2 of SRAM, configured as 0x10, else if the splitaddress below block2 of SRAM, configured as 0x11, else if splitaddress higher than block2 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_3 = (2 << 6);  ///< category3 of core_x_iram0_dram_dma_line, if the splitaddress in block3 of SRAM, configured as 0x10, else if the splitaddress below block3 of SRAM, configured as 0x11, else if splitaddress higher than block3 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_4 = (2 << 8);  ///< category4 of core_x_iram0_dram_dma_line, if the splitaddress in block4 of SRAM, configured as 0x10, else if the splitaddress below block4 of SRAM, configured as 0x11, else if splitaddress higher than block4 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_5 = (2 << 10);  ///< category5 of core_x_iram0_dram_dma_line, if the splitaddress in block5 of SRAM, configured as 0x10, else if the splitaddress below block5 of SRAM, configured as 0x11, else if splitaddress higher than block5 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_6 = (2 << 12);  ///< category6 of core_x_iram0_dram_dma_line, if the splitaddress in block6 of SRAM, configured as 0x10, else if the splitaddress below block6 of SRAM, configured as 0x11, else if splitaddress higher than block6 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_0_SPLITADDR = (8 << 14);  ///< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit of actual address
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_3_bits {
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_0 = (2 << 0);  ///< category0 of core_x_iram0_dram_dma_line, if the splitaddress in block0 of SRAM, configured as 0x10, else if the splitaddress below block0 of SRAM, configured as 0x11, else if splitaddress higher than block0 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_1 = (2 << 2);  ///< category1 of core_x_iram0_dram_dma_line, if the splitaddress in block1 of SRAM, configured as 0x10, else if the splitaddress below block1 of SRAM, configured as 0x11, else if splitaddress higher than block1 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_2 = (2 << 4);  ///< category2 of core_x_iram0_dram_dma_line, if the splitaddress in block2 of SRAM, configured as 0x10, else if the splitaddress below block2 of SRAM, configured as 0x11, else if splitaddress higher than block2 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_3 = (2 << 6);  ///< category3 of core_x_iram0_dram_dma_line, if the splitaddress in block3 of SRAM, configured as 0x10, else if the splitaddress below block3 of SRAM, configured as 0x11, else if splitaddress higher than block3 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_4 = (2 << 8);  ///< category4 of core_x_iram0_dram_dma_line, if the splitaddress in block4 of SRAM, configured as 0x10, else if the splitaddress below block4 of SRAM, configured as 0x11, else if splitaddress higher than block4 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_5 = (2 << 10);  ///< category5 of core_x_iram0_dram_dma_line, if the splitaddress in block5 of SRAM, configured as 0x10, else if the splitaddress below block5 of SRAM, configured as 0x11, else if splitaddress higher than block5 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_6 = (2 << 12);  ///< category6 of core_x_iram0_dram_dma_line, if the splitaddress in block6 of SRAM, configured as 0x10, else if the splitaddress below block6 of SRAM, configured as 0x11, else if splitaddress higher than block6 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_IRAM0_SRAM_LINE_1_SPLITADDR = (8 << 14);  ///< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit of actual address
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_4_bits {
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_0 = (2 << 0);  ///< category0 of core_x_iram0_dram_dma_line, if the splitaddress in block0 of SRAM, configured as 0x10, else if the splitaddress below block0 of SRAM, configured as 0x11, else if splitaddress higher than block0 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_1 = (2 << 2);  ///< category1 of core_x_iram0_dram_dma_line, if the splitaddress in block1 of SRAM, configured as 0x10, else if the splitaddress below block1 of SRAM, configured as 0x11, else if splitaddress higher than block1 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_2 = (2 << 4);  ///< category2 of core_x_iram0_dram_dma_line, if the splitaddress in block2 of SRAM, configured as 0x10, else if the splitaddress below block2 of SRAM, configured as 0x11, else if splitaddress higher than block2 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_3 = (2 << 6);  ///< category3 of core_x_iram0_dram_dma_line, if the splitaddress in block3 of SRAM, configured as 0x10, else if the splitaddress below block3 of SRAM, configured as 0x11, else if splitaddress higher than block3 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_4 = (2 << 8);  ///< category4 of core_x_iram0_dram_dma_line, if the splitaddress in block4 of SRAM, configured as 0x10, else if the splitaddress below block4 of SRAM, configured as 0x11, else if splitaddress higher than block4 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_5 = (2 << 10);  ///< category5 of core_x_iram0_dram_dma_line, if the splitaddress in block5 of SRAM, configured as 0x10, else if the splitaddress below block5 of SRAM, configured as 0x11, else if splitaddress higher than block5 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_6 = (2 << 12);  ///< category6 of core_x_iram0_dram_dma_line, if the splitaddress in block6 of SRAM, configured as 0x10, else if the splitaddress below block6 of SRAM, configured as 0x11, else if splitaddress higher than block6 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR = (8 << 14);  ///< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit of actual address
    }

    /// CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5 Register bits
    namespace core_x_iram0_dram0_dma_split_line_constrain_5_bits {
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_0 = (2 << 0);  ///< category0 of core_x_iram0_dram_dma_line, if the splitaddress in block0 of SRAM, configured as 0x10, else if the splitaddress below block0 of SRAM, configured as 0x11, else if splitaddress higher than block0 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_1 = (2 << 2);  ///< category1 of core_x_iram0_dram_dma_line, if the splitaddress in block1 of SRAM, configured as 0x10, else if the splitaddress below block1 of SRAM, configured as 0x11, else if splitaddress higher than block1 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_2 = (2 << 4);  ///< category2 of core_x_iram0_dram_dma_line, if the splitaddress in block2 of SRAM, configured as 0x10, else if the splitaddress below block2 of SRAM, configured as 0x11, else if splitaddress higher than block2 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_3 = (2 << 6);  ///< category3 of core_x_iram0_dram_dma_line, if the splitaddress in block3 of SRAM, configured as 0x10, else if the splitaddress below block3 of SRAM, configured as 0x11, else if splitaddress higher than block3 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_4 = (2 << 8);  ///< category4 of core_x_iram0_dram_dma_line, if the splitaddress in block4 of SRAM, configured as 0x10, else if the splitaddress below block4 of SRAM, configured as 0x11, else if splitaddress higher than block4 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_5 = (2 << 10);  ///< category5 of core_x_iram0_dram_dma_line, if the splitaddress in block5 of SRAM, configured as 0x10, else if the splitaddress below block5 of SRAM, configured as 0x11, else if splitaddress higher than block5 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_6 = (2 << 12);  ///< category6 of core_x_iram0_dram_dma_line, if the splitaddress in block6 of SRAM, configured as 0x10, else if the splitaddress below block6 of SRAM, configured as 0x11, else if splitaddress higher than block6 of SRAM, configured as 0x00
        constexpr uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_SPLITADDR = (8 << 14);  ///< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit of actual address
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_0 Register bits
    namespace core_x_iram0_pms_constrain_0_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock corex iram0 permission configuration register
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_1 Register bits
    namespace core_x_iram0_pms_constrain_1_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (3 << 0);  ///< core0/core1's permission of instruction region0 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (3 << 3);  ///< core0/core1's permission of instruction region1 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (3 << 6);  ///< core0/core1's permission of instruction region2 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (3 << 9);  ///< core0/core1's permission of instruction region3 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0 = (3 << 12);  ///< core0/core1's permission of icache data sram block0 in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_1 = (3 << 15);  ///< core0/core1's permission of icache data sram block1 in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS = (3 << 18);  ///< core0/core1's permission of rom in world1
    }

    /// CORE_X_IRAM0_PMS_CONSTRAIN_2 Register bits
    namespace core_x_iram0_pms_constrain_2_bits {
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (3 << 0);  ///< core0/core1's permission of instruction region0 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (3 << 3);  ///< core0/core1's permission of instruction region1 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (3 << 6);  ///< core0/core1's permission of instruction region2 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (3 << 9);  ///< core0/core1's permission of instruction region3 of SRAM in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0 = (3 << 12);  ///< core0/core1's permission of icache data sram block0 in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1 = (3 << 15);  ///< core0/core1's permission of icache data sram block1 in world1
        constexpr uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS = (3 << 18);  ///< core0/core1's permission of rom in world1
    }

    /// CORE_0_IRAM0_PMS_MONITOR_0 Register bits
    namespace core_0_iram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core0 iram0 permission monitor register
    }

    /// CORE_0_IRAM0_PMS_MONITOR_1 Register bits
    namespace core_0_iram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear core0 iram0 permission violated interrupt
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable core0 iram0 permission monitor, when core0_iram violated permission, will trigger interrupt
    }

    /// CORE_0_IRAM0_PMS_MONITOR_2 Register bits
    namespace core_0_iram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< recorded core0 iram0 pms monitor interrupt status.
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 1);  ///< recorded core0 iram0 wr status, only if loadstore is 1 have meaning, 1(store), 0(load).
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE = (1U << 2);  ///< recorded core0 iram0 loadstore status, indicated the type of operation, 0(fetch), 1(load/store).
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 3);  ///< recorded core0 iram0 world status, 0x01 means world0, 0x10 means world1.
        constexpr uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (24 << 5);  ///< recorded core0 iram0 address [25:2] status when core0 iram0 violated permission, the real address is 0x40000000+addr*4
    }

    /// CORE_1_IRAM0_PMS_MONITOR_0 Register bits
    namespace core_1_iram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core1 iram0 permission monitor register
    }

    /// CORE_1_IRAM0_PMS_MONITOR_1 Register bits
    namespace core_1_iram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear core1 iram0 permission violated interrupt
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable core1 iram0 permission monitor, when core1_iram violated permission, will trigger interrupt
    }

    /// CORE_1_IRAM0_PMS_MONITOR_2 Register bits
    namespace core_1_iram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< recorded core1 iram0 pms monitor interrupt status.
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 1);  ///< recorded core1 iram0 wr status, only if loadstore is 1 have meaning, 1(store), 0(load).
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE = (1U << 2);  ///< recorded core1 iram0 loadstore status, indicated the type of operation, 0(fetch), 1(load/store).
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 3);  ///< recorded core1 iram0 world status, 0x01 means world0, 0x10 means world1.
        constexpr uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (24 << 5);  ///< recorded core1 iram0 address [25:2] status when core1 iram0 violated permission, the real address is 0x40000000+addr*4
    }

    /// CORE_X_DRAM0_PMS_CONSTRAIN_0 Register bits
    namespace core_x_dram0_pms_constrain_0_bits {
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock corex dram0 permission configuration register
    }

    /// CORE_X_DRAM0_PMS_CONSTRAIN_1 Register bits
    namespace core_x_dram0_pms_constrain_1_bits {
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 = (2 << 0);  ///< core0/core1's permission of data region0 of SRAM in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 = (2 << 2);  ///< core0/core1's permission of data region1 of SRAM in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 = (2 << 4);  ///< core0/core1's permission of data region2 of SRAM in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 = (2 << 6);  ///< core0/core1's permission of data region3 of SRAM in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0 = (2 << 8);  ///< core0/core1's permission of dcache data sram block0 in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1 = (2 << 10);  ///< core0/core1's permission of dcache data sram block1 in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 = (2 << 12);  ///< core0/core1's permission of data region0 of SRAM in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 = (2 << 14);  ///< core0/core1's permission of data region1 of SRAM in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 = (2 << 16);  ///< core0/core1's permission of data region2 of SRAM in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 = (2 << 18);  ///< core0/core1's permission of data region3 of SRAM in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0 = (2 << 20);  ///< core0/core1's permission of dcache data sram block0 in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_1 = (2 << 22);  ///< core0/core1's permission of dcache data sram block1 in world1.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS = (2 << 24);  ///< core0/core1's permission(sotre,load) of rom in world0.
        constexpr uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS = (2 << 26);  ///< core0/core1's permission(sotre,load) of rom in world1.
    }

    /// CORE_0_DRAM0_PMS_MONITOR_0 Register bits
    namespace core_0_dram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core0 dram0 permission monitor configuration register.
    }

    /// CORE_0_DRAM0_PMS_MONITOR_1 Register bits
    namespace core_0_dram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear core0 dram0 permission monior interrupt.
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable core0 dram0 permission monitor interrupt.
    }

    /// CORE_0_DRAM0_PMS_MONITOR_2 Register bits
    namespace core_0_dram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< recorded core0 dram0 permission monitor interrupt status.
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK = (1U << 1);  ///< recorded core0 dram0 lock status, 1 means s32c1i access.
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 2);  ///< recorded core0 dram0 world status, 0x1 means world0, 0x2 means world1.
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (22 << 4);  ///< recorded core0 dram0 address[25:4] status when core0 dram0 violated permission,the real address is 0x3c000000+addr*16
    }

    /// CORE_0_DRAM0_PMS_MONITOR_3 Register bits
    namespace core_0_dram0_pms_monitor_3_bits {
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 0);  ///< recorded core0 dram0 wr status, 1 means store, 0 means load.
        constexpr uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN = (16 << 1);  ///< recorded core0 dram0 byteen status.
    }

    /// CORE_1_DRAM0_PMS_MONITOR_0 Register bits
    namespace core_1_dram0_pms_monitor_0_bits {
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core1 dram0 permission monitor configuration register.
    }

    /// CORE_1_DRAM0_PMS_MONITOR_1 Register bits
    namespace core_1_dram0_pms_monitor_1_bits {
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear core1 dram0 permission monior interrupt.
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable core1 dram0 permission monitor interrupt.
    }

    /// CORE_1_DRAM0_PMS_MONITOR_2 Register bits
    namespace core_1_dram0_pms_monitor_2_bits {
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< recorded core1 dram0 permission monitor interrupt status.
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK = (1U << 1);  ///< recorded core1 dram0 lock status, 1 means s32c1i access.
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD = (2 << 2);  ///< recorded core1 dram0 world status, 0x1 means world0, 0x2 means world1.
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR = (22 << 4);  ///< recorded core1 dram0 address[25:4] status when core1 dram0 violated permission,the real address is 0x3c000000+addr*16
    }

    /// CORE_1_DRAM0_PMS_MONITOR_3 Register bits
    namespace core_1_dram0_pms_monitor_3_bits {
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR = (1U << 0);  ///< recorded core1 dram0 wr status, 1 means store, 0 means load.
        constexpr uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN = (16 << 1);  ///< recorded core1 dram0 byteen status.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_0 Register bits
    namespace core_0_pif_pms_constrain_0_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock core0 access peripherals permission Configuration Register.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_1 Register bits
    namespace core_0_pif_pms_constrain_1_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART = (2 << 0);  ///< Core0 access uart permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1 = (2 << 2);  ///< Core0 access g0spi_1 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0 = (2 << 4);  ///< Core0 access g0spi_0 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_GPIO = (2 << 6);  ///< Core0 access gpio permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE2 = (2 << 8);  ///< Core0 access fe2 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE = (2 << 10);  ///< Core0 access fe permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RTC = (2 << 14);  ///< Core0 access rtc permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX = (2 << 16);  ///< Core0 access io_mux permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_HINF = (2 << 20);  ///< Core0 access hinf permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_MISC = (2 << 24);  ///< Core0 access misc permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C = (2 << 26);  ///< Core0 access i2c permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S0 = (2 << 28);  ///< Core0 access i2s0 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART1 = (2 << 30);  ///< Core0 access uart1 permission in world0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_2 Register bits
    namespace core_0_pif_pms_constrain_2_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT = (2 << 0);  ///< Core0 access bt permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0 = (2 << 4);  ///< Core0 access i2c_ext0 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0 = (2 << 6);  ///< Core0 access uhci0 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SLCHOST = (2 << 8);  ///< Core0 access slchost permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RMT = (2 << 10);  ///< Core0 access rmt permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PCNT = (2 << 12);  ///< Core0 access pcnt permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SLC = (2 << 14);  ///< Core0 access slc permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LEDC = (2 << 16);  ///< Core0 access ledc permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BACKUP = (2 << 18);  ///< Core0 access backup permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BB = (2 << 22);  ///< Core0 access bb permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWM0 = (2 << 24);  ///< Core0 access pwm0 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP = (2 << 26);  ///< Core0 access timergroup permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1 = (2 << 28);  ///< Core0 access timergroup1 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER = (2 << 30);  ///< Core0 access systimer permission in world0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_3 Register bits
    namespace core_0_pif_pms_constrain_3_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2 = (2 << 0);  ///< Core0 access spi_2 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_3 = (2 << 2);  ///< Core0 access spi_3 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL = (2 << 4);  ///< Core0 access apb_ctrl permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT1 = (2 << 6);  ///< Core0 access i2c_ext1 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SDIO_HOST = (2 << 8);  ///< Core0 access sdio_host permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CAN = (2 << 10);  ///< Core0 access can permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWM1 = (2 << 12);  ///< Core0 access pwm1 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S1 = (2 << 14);  ///< Core0 access i2s1 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART2 = (2 << 16);  ///< Core0 access uart2 permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RWBT = (2 << 22);  ///< Core0 access rwbt permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC = (2 << 26);  ///< Core0 access wifimac permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWR = (2 << 28);  ///< Core0 access pwr permission in world0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_4 Register bits
    namespace core_0_pif_pms_constrain_4_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE = (2 << 0);  ///< Core0 access usb_device permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP = (2 << 2);  ///< Core0 access usb_wrap permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI = (2 << 4);  ///< Core0 access crypto_peri permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA = (2 << 6);  ///< Core0 access crypto_dma permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC = (2 << 8);  ///< Core0 access apb_adc permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LCD_CAM = (2 << 10);  ///< Core0 access lcd_cam permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR = (2 << 12);  ///< Core0 access bt_pwr permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB = (2 << 14);  ///< Core0 access usb permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM = (2 << 16);  ///< Core0 access system permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE = (2 << 18);  ///< Core0 access sensitive permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT = (2 << 20);  ///< Core0 access interrupt permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY = (2 << 22);  ///< Core0 access dma_copy permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG = (2 << 24);  ///< Core0 access cache_config permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_AD = (2 << 26);  ///< Core0 access ad permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DIO = (2 << 28);  ///< Core0 access dio permission in world0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER = (2 << 30);  ///< Core0 access world_controller permission in world0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_5 Register bits
    namespace core_0_pif_pms_constrain_5_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART = (2 << 0);  ///< Core0 access uart permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1 = (2 << 2);  ///< Core0 access g0spi_1 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0 = (2 << 4);  ///< Core0 access g0spi_0 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_GPIO = (2 << 6);  ///< Core0 access gpio permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE2 = (2 << 8);  ///< Core0 access fe2 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE = (2 << 10);  ///< Core0 access fe permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RTC = (2 << 14);  ///< Core0 access rtc permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX = (2 << 16);  ///< Core0 access io_mux permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_HINF = (2 << 20);  ///< Core0 access hinf permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_MISC = (2 << 24);  ///< Core0 access misc permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C = (2 << 26);  ///< Core0 access i2c permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S0 = (2 << 28);  ///< Core0 access i2s0 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART1 = (2 << 30);  ///< Core0 access uart1 permission in world1.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_6 Register bits
    namespace core_0_pif_pms_constrain_6_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT = (2 << 0);  ///< Core0 access bt permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0 = (2 << 4);  ///< Core0 access i2c_ext0 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0 = (2 << 6);  ///< Core0 access uhci0 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SLCHOST = (2 << 8);  ///< Core0 access slchost permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RMT = (2 << 10);  ///< Core0 access rmt permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PCNT = (2 << 12);  ///< Core0 access pcnt permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SLC = (2 << 14);  ///< Core0 access slc permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LEDC = (2 << 16);  ///< Core0 access ledc permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BACKUP = (2 << 18);  ///< Core0 access backup permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BB = (2 << 22);  ///< Core0 access bb permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWM0 = (2 << 24);  ///< Core0 access pwm0 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP = (2 << 26);  ///< Core0 access timergroup permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1 = (2 << 28);  ///< Core0 access timergroup1 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER = (2 << 30);  ///< Core0 access systimer permission in world1.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_7 Register bits
    namespace core_0_pif_pms_constrain_7_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2 = (2 << 0);  ///< Core0 access spi_2 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_3 = (2 << 2);  ///< Core0 access spi_3 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL = (2 << 4);  ///< Core0 access apb_ctrl permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT1 = (2 << 6);  ///< Core0 access i2c_ext1 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SDIO_HOST = (2 << 8);  ///< Core0 access sdio_host permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CAN = (2 << 10);  ///< Core0 access can permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWM1 = (2 << 12);  ///< Core0 access pwm1 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S1 = (2 << 14);  ///< Core0 access i2s1 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART2 = (2 << 16);  ///< Core0 access uart2 permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RWBT = (2 << 22);  ///< Core0 access rwbt permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC = (2 << 26);  ///< Core0 access wifimac permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWR = (2 << 28);  ///< Core0 access pwr permission in world1.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_8 Register bits
    namespace core_0_pif_pms_constrain_8_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE = (2 << 0);  ///< Core0 access usb_device permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP = (2 << 2);  ///< Core0 access usb_wrap permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI = (2 << 4);  ///< Core0 access crypto_peri permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA = (2 << 6);  ///< Core0 access crypto_dma permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC = (2 << 8);  ///< Core0 access apb_adc permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LCD_CAM = (2 << 10);  ///< Core0 access lcd_cam permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR = (2 << 12);  ///< Core0 access bt_pwr permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB = (2 << 14);  ///< Core0 access usb permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM = (2 << 16);  ///< Core0 access system permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE = (2 << 18);  ///< Core0 access sensitive permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT = (2 << 20);  ///< Core0 access interrupt permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY = (2 << 22);  ///< Core0 access dma_copy permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG = (2 << 24);  ///< Core0 access cache_config permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_AD = (2 << 26);  ///< Core0 access ad permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DIO = (2 << 28);  ///< Core0 access dio permission in world1.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER = (2 << 30);  ///< Core0 access world_controller permission in world1.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_9 Register bits
    namespace core_0_pif_pms_constrain_9_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCFast memory split address in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCFast memory split address in world 1 for core0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_10 Register bits
    namespace core_0_pif_pms_constrain_10_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L = (3 << 0);  ///< RTCFast memory low region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H = (3 << 3);  ///< RTCFast memory high region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L = (3 << 6);  ///< RTCFast memory low region permission in world 1 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H = (3 << 9);  ///< RTCFast memory high region permission in world 1 for core0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_11 Register bits
    namespace core_0_pif_pms_constrain_11_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCSlow_0 memory split address in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCSlow_0 memory split address in world 1 for core0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_12 Register bits
    namespace core_0_pif_pms_constrain_12_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_L = (3 << 0);  ///< RTCSlow_0 memory low region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_H = (3 << 3);  ///< RTCSlow_0 memory high region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_L = (3 << 6);  ///< RTCSlow_0 memory low region permission in world 1 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_H = (3 << 9);  ///< RTCSlow_0 memory high region permission in world 1 for core0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_13 Register bits
    namespace core_0_pif_pms_constrain_13_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCSlow_1 memory split address in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCSlow_1 memory split address in world 1 for core0.
    }

    /// CORE_0_PIF_PMS_CONSTRAIN_14 Register bits
    namespace core_0_pif_pms_constrain_14_bits {
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_L = (3 << 0);  ///< RTCSlow_1 memory low region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_H = (3 << 3);  ///< RTCSlow_1 memory high region permission in world 0 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_L = (3 << 6);  ///< RTCSlow_1 memory low region permission in world 1 for core0.
        constexpr uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_H = (3 << 9);  ///< RTCSlow_1 memory high region permission in world 1 for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_0 Register bits
    namespace core_0_region_pms_constrain_0_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock core0 region permission registers.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_1 Register bits
    namespace core_0_region_pms_constrain_1_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_0 = (2 << 0);  ///< Region 0 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_1 = (2 << 2);  ///< Region 1 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_2 = (2 << 4);  ///< Region 2 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_3 = (2 << 6);  ///< Region 3 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_4 = (2 << 8);  ///< Region 4 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_5 = (2 << 10);  ///< Region 5 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_6 = (2 << 12);  ///< Region 6 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_7 = (2 << 14);  ///< Region 7 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_8 = (2 << 16);  ///< Region 8 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_9 = (2 << 18);  ///< Region 9 permission in world 0 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_10 = (2 << 20);  ///< Region 10 permission in world 0 for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_2 Register bits
    namespace core_0_region_pms_constrain_2_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_0 = (2 << 0);  ///< Region 0 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_1 = (2 << 2);  ///< Region 1 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_2 = (2 << 4);  ///< Region 2 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_3 = (2 << 6);  ///< Region 3 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_4 = (2 << 8);  ///< Region 4 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_5 = (2 << 10);  ///< Region 5 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_6 = (2 << 12);  ///< Region 6 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_7 = (2 << 14);  ///< Region 7 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_8 = (2 << 16);  ///< Region 8 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_9 = (2 << 18);  ///< Region 9 permission in world 1 for core0.
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_10 = (2 << 20);  ///< Region 10 permission in world 1 for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_3 Register bits
    namespace core_0_region_pms_constrain_3_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_0 = (30 << 0);  ///< Region 0 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_4 Register bits
    namespace core_0_region_pms_constrain_4_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_1 = (30 << 0);  ///< Region 0 end address and Region 1 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_5 Register bits
    namespace core_0_region_pms_constrain_5_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_2 = (30 << 0);  ///< Region 1 end address and Region 2 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_6 Register bits
    namespace core_0_region_pms_constrain_6_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_3 = (30 << 0);  ///< Region 2 end address and Region 3 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_7 Register bits
    namespace core_0_region_pms_constrain_7_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_4 = (30 << 0);  ///< Region 3 end address and Region 4 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_8 Register bits
    namespace core_0_region_pms_constrain_8_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_5 = (30 << 0);  ///< Region 4 end address and Region 5 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_9 Register bits
    namespace core_0_region_pms_constrain_9_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_6 = (30 << 0);  ///< Region 5 end address and Region 6 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_10 Register bits
    namespace core_0_region_pms_constrain_10_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_7 = (30 << 0);  ///< Region 6 end address and Region 7 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_11 Register bits
    namespace core_0_region_pms_constrain_11_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_8 = (30 << 0);  ///< Region 7 end address and Region 8 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_12 Register bits
    namespace core_0_region_pms_constrain_12_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_9 = (30 << 0);  ///< Region 8 end address and Region 9 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_13 Register bits
    namespace core_0_region_pms_constrain_13_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_10 = (30 << 0);  ///< Region 9 end address and Region 10 start address for core0.
    }

    /// CORE_0_REGION_PMS_CONSTRAIN_14 Register bits
    namespace core_0_region_pms_constrain_14_bits {
        constexpr uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_11 = (30 << 0);  ///< Region 10 end address for core0.
    }

    /// CORE_0_PIF_PMS_MONITOR_0 Register bits
    namespace core_0_pif_pms_monitor_0_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core0 permission report registers.
    }

    /// CORE_0_PIF_PMS_MONITOR_1 Register bits
    namespace core_0_pif_pms_monitor_1_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear interrupt that core0 initiate illegal PIF bus access.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable interrupt that core0 initiate illegal PIF bus access.
    }

    /// CORE_0_PIF_PMS_MONITOR_2 Register bits
    namespace core_0_pif_pms_monitor_2_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< Record core0 illegal access interrupt state.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0 = (1U << 1);  ///< Record hport information when core0 initiate illegal access.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE = (3 << 2);  ///< Record access type when core0 initate illegal access.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE = (1U << 5);  ///< Record access direction when core0 initiate illegal access.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD = (2 << 6);  ///< Record world information when core0 initiate illegal access.
    }

    /// CORE_0_PIF_PMS_MONITOR_3 Register bits
    namespace core_0_pif_pms_monitor_3_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR = (32 << 0);  ///< Record address information when core0 initiate illegal access.
    }

    /// CORE_0_PIF_PMS_MONITOR_4 Register bits
    namespace core_0_pif_pms_monitor_4_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear interrupt that core0 initiate unsupported access type.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable interrupt that core0 initiate unsupported access type.
    }

    /// CORE_0_PIF_PMS_MONITOR_5 Register bits
    namespace core_0_pif_pms_monitor_5_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR = (1U << 0);  ///< Record core0 unsupported access type interrupt state.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE = (2 << 1);  ///< Record access type when core0 initiate unsupported access type.
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD = (2 << 3);  ///< Record world information when core0 initiate unsupported access type.
    }

    /// CORE_0_PIF_PMS_MONITOR_6 Register bits
    namespace core_0_pif_pms_monitor_6_bits {
        constexpr uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR = (32 << 0);  ///< Record address information when core0 initiate unsupported access type.
    }

    /// CORE_0_VECBASE_OVERRIDE_LOCK Register bits
    namespace core_0_vecbase_override_lock_bits {
        constexpr uint32_t CORE_0_VECBASE_OVERRIDE_LOCK = (1U << 0);  ///< Set 1 to lock core0 vecbase configuration register
    }

    /// CORE_0_VECBASE_OVERRIDE_0 Register bits
    namespace core_0_vecbase_override_0_bits {
        constexpr uint32_t CORE_0_VECBASE_WORLD_MASK = (1U << 0);  ///< Set 1 to mask world, then only world0_value will work.
    }

    /// CORE_0_VECBASE_OVERRIDE_1 Register bits
    namespace core_0_vecbase_override_1_bits {
        constexpr uint32_t CORE_0_VECBASE_OVERRIDE_WORLD0_VALUE = (22 << 0);  ///< world0 vecbase_override register, when core0 in world0 use this register to override vecbase register.
        constexpr uint32_t CORE_0_VECBASE_OVERRIDE_SEL = (2 << 22);  ///< Set 0x3 to sel vecbase_override to override vecbase register.
    }

    /// CORE_0_VECBASE_OVERRIDE_2 Register bits
    namespace core_0_vecbase_override_2_bits {
        constexpr uint32_t CORE_0_VECBASE_OVERRIDE_WORLD1_VALUE = (22 << 0);  ///< world1 vecbase_override register, when core0 in world1 use this register to override vecbase register.
    }

    /// CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_0 Register bits
    namespace core_0_toomanyexceptions_m_override_0_bits {
        constexpr uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_LOCK = (1U << 0);  ///< Set 1 to lock core0 toomanyexception override configuration register
    }

    /// CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_1 Register bits
    namespace core_0_toomanyexceptions_m_override_1_bits {
        constexpr uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE = (1U << 0);  ///< Set 1 to mask toomanyexception.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_0 Register bits
    namespace core_1_pif_pms_constrain_0_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock core1 pif permission configuration register.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_1 Register bits
    namespace core_1_pif_pms_constrain_1_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART = (2 << 0);  ///< Core1 access uart permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1 = (2 << 2);  ///< Core1 access g0spi_1 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0 = (2 << 4);  ///< Core1 access g0spi_0 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_GPIO = (2 << 6);  ///< Core1 access gpio permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_FE2 = (2 << 8);  ///< Core1 access fe2 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_FE = (2 << 10);  ///< Core1 access fe permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RTC = (2 << 14);  ///< Core1 access rtc permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX = (2 << 16);  ///< Core1 access io_mux permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_HINF = (2 << 20);  ///< Core1 access hinf permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_MISC = (2 << 24);  ///< Core1 access misc permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C = (2 << 26);  ///< Core1 access i2c permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2S0 = (2 << 28);  ///< Core1 access i2s0 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART1 = (2 << 30);  ///< Core1 access uart1 permission in world0.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_2 Register bits
    namespace core_1_pif_pms_constrain_2_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BT = (2 << 0);  ///< Core1 access bt permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0 = (2 << 4);  ///< Core1 access i2c_ext0 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0 = (2 << 6);  ///< Core1 access uhci0 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SLCHOST = (2 << 8);  ///< Core1 access slchost permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RMT = (2 << 10);  ///< Core1 access rmt permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PCNT = (2 << 12);  ///< Core1 access pcnt permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SLC = (2 << 14);  ///< Core1 access slc permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_LEDC = (2 << 16);  ///< Core1 access ledc permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BACKUP = (2 << 18);  ///< Core1 access backup permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BB = (2 << 22);  ///< Core1 access bb permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWM0 = (2 << 24);  ///< Core1 access pwm0 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP = (2 << 26);  ///< Core1 access timergroup permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1 = (2 << 28);  ///< Core1 access timergroup1 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER = (2 << 30);  ///< Core1 access systimer permission in world0.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_3 Register bits
    namespace core_1_pif_pms_constrain_3_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2 = (2 << 0);  ///< Core1 access spi_2 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SPI_3 = (2 << 2);  ///< Core1 access spi_3 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL = (2 << 4);  ///< Core1 access apb_ctrl permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT1 = (2 << 6);  ///< Core1 access i2c_ext1 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SDIO_HOST = (2 << 8);  ///< Core1 access sdio_host permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CAN = (2 << 10);  ///< Core1 access can permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWM1 = (2 << 12);  ///< Core1 access pwm1 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2S1 = (2 << 14);  ///< Core1 access i2s1 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART2 = (2 << 16);  ///< Core1 access uart2 permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RWBT = (2 << 22);  ///< Core1 access rwbt permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC = (2 << 26);  ///< Core1 access wifimac permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWR = (2 << 28);  ///< Core1 access pwr permission in world0.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_4 Register bits
    namespace core_1_pif_pms_constrain_4_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE = (2 << 0);  ///< Core1 access usb_device permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP = (2 << 2);  ///< Core1 access usb_wrap permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI = (2 << 4);  ///< Core1 access crypto_peri permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA = (2 << 6);  ///< Core1 access crypto_dma permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC = (2 << 8);  ///< Core1 access apb_adc permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_LCD_CAM = (2 << 10);  ///< Core1 access lcd_cam permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR = (2 << 12);  ///< Core1 access bt_pwr permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB = (2 << 14);  ///< Core1 access usb permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM = (2 << 16);  ///< Core1 access system permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE = (2 << 18);  ///< Core1 access sensitive permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT = (2 << 20);  ///< Core1 access interrupt permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY = (2 << 22);  ///< Core1 access dma_copy permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG = (2 << 24);  ///< Core1 access cache_config permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_AD = (2 << 26);  ///< Core1 access ad permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_DIO = (2 << 28);  ///< Core1 access dio permission in world0.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER = (2 << 30);  ///< Core1 access world_controller permission in world0.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_5 Register bits
    namespace core_1_pif_pms_constrain_5_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART = (2 << 0);  ///< Core1 access uart permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1 = (2 << 2);  ///< Core1 access g0spi_1 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0 = (2 << 4);  ///< Core1 access g0spi_0 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_GPIO = (2 << 6);  ///< Core1 access gpio permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_FE2 = (2 << 8);  ///< Core1 access fe2 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_FE = (2 << 10);  ///< Core1 access fe permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RTC = (2 << 14);  ///< Core1 access rtc permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX = (2 << 16);  ///< Core1 access io_mux permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_HINF = (2 << 20);  ///< Core1 access hinf permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_MISC = (2 << 24);  ///< Core1 access misc permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C = (2 << 26);  ///< Core1 access i2c permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2S0 = (2 << 28);  ///< Core1 access i2s0 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART1 = (2 << 30);  ///< Core1 access uart1 permission in world1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_6 Register bits
    namespace core_1_pif_pms_constrain_6_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BT = (2 << 0);  ///< Core1 access bt permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0 = (2 << 4);  ///< Core1 access i2c_ext0 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0 = (2 << 6);  ///< Core1 access uhci0 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SLCHOST = (2 << 8);  ///< Core1 access slchost permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RMT = (2 << 10);  ///< Core1 access rmt permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PCNT = (2 << 12);  ///< Core1 access pcnt permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SLC = (2 << 14);  ///< Core1 access slc permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_LEDC = (2 << 16);  ///< Core1 access ledc permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BACKUP = (2 << 18);  ///< Core1 access backup permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BB = (2 << 22);  ///< Core1 access bb permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWM0 = (2 << 24);  ///< Core1 access pwm0 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP = (2 << 26);  ///< Core1 access timergroup permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1 = (2 << 28);  ///< Core1 access timergroup1 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER = (2 << 30);  ///< Core1 access systimer permission in world1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_7 Register bits
    namespace core_1_pif_pms_constrain_7_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2 = (2 << 0);  ///< Core1 access spi_2 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SPI_3 = (2 << 2);  ///< Core1 access spi_3 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL = (2 << 4);  ///< Core1 access apb_ctrl permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT1 = (2 << 6);  ///< Core1 access i2c_ext1 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SDIO_HOST = (2 << 8);  ///< Core1 access sdio_host permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CAN = (2 << 10);  ///< Core1 access can permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWM1 = (2 << 12);  ///< Core1 access pwm1 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2S1 = (2 << 14);  ///< Core1 access i2s1 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART2 = (2 << 16);  ///< Core1 access uart2 permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RWBT = (2 << 22);  ///< Core1 access rwbt permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC = (2 << 26);  ///< Core1 access wifimac permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWR = (2 << 28);  ///< Core1 access pwr permission in world1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_8 Register bits
    namespace core_1_pif_pms_constrain_8_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE = (2 << 0);  ///< Core1 access usb_device permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP = (2 << 2);  ///< Core1 access usb_wrap permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI = (2 << 4);  ///< Core1 access crypto_peri permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA = (2 << 6);  ///< Core1 access crypto_dma permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC = (2 << 8);  ///< Core1 access apb_adc permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_LCD_CAM = (2 << 10);  ///< Core1 access lcd_cam permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR = (2 << 12);  ///< Core1 access bt_pwr permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB = (2 << 14);  ///< Core1 access usb permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM = (2 << 16);  ///< Core1 access system permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE = (2 << 18);  ///< Core1 access sensitive permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT = (2 << 20);  ///< Core1 access interrupt permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY = (2 << 22);  ///< Core1 access dma_copy permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG = (2 << 24);  ///< Core1 access cache_config permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_AD = (2 << 26);  ///< Core1 access ad permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_DIO = (2 << 28);  ///< Core1 access dio permission in world1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER = (2 << 30);  ///< Core1 access world_controller permission in world1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_9 Register bits
    namespace core_1_pif_pms_constrain_9_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCFast memory split address in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCFast memory split address in world 1 for core1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_10 Register bits
    namespace core_1_pif_pms_constrain_10_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L = (3 << 0);  ///< RTCFast memory low region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H = (3 << 3);  ///< RTCFast memory high region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L = (3 << 6);  ///< RTCFast memory low region permission in world 1 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H = (3 << 9);  ///< RTCFast memory high region permission in world 1 for core1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_11 Register bits
    namespace core_1_pif_pms_constrain_11_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCSlow_0 memory split address in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCSlow_0 memory split address in world 1 for core1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_12 Register bits
    namespace core_1_pif_pms_constrain_12_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_L = (3 << 0);  ///< RTCSlow_0 memory low region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_H = (3 << 3);  ///< RTCSlow_0 memory high region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_L = (3 << 6);  ///< RTCSlow_0 memory low region permission in world 1 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_H = (3 << 9);  ///< RTCSlow_0 memory high region permission in world 1 for core1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_13 Register bits
    namespace core_1_pif_pms_constrain_13_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_0 = (11 << 0);  ///< RTCSlow_1 memory split address in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_1 = (11 << 11);  ///< RTCSlow_1 memory split address in world 1 for core1.
    }

    /// CORE_1_PIF_PMS_CONSTRAIN_14 Register bits
    namespace core_1_pif_pms_constrain_14_bits {
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_L = (3 << 0);  ///< RTCSlow_1 memory low region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_H = (3 << 3);  ///< RTCSlow_1 memory high region permission in world 0 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_L = (3 << 6);  ///< RTCSlow_1 memory low region permission in world 1 for core1.
        constexpr uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_H = (3 << 9);  ///< RTCSlow_1 memory high region permission in world 1 for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_0 Register bits
    namespace core_1_region_pms_constrain_0_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock core1 region permission registers.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_1 Register bits
    namespace core_1_region_pms_constrain_1_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_0 = (2 << 0);  ///< Region 0 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_1 = (2 << 2);  ///< Region 1 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_2 = (2 << 4);  ///< Region 2 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_3 = (2 << 6);  ///< Region 3 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_4 = (2 << 8);  ///< Region 4 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_5 = (2 << 10);  ///< Region 5 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_6 = (2 << 12);  ///< Region 6 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_7 = (2 << 14);  ///< Region 7 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_8 = (2 << 16);  ///< Region 8 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_9 = (2 << 18);  ///< Region 9 permission in world 0 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_10 = (2 << 20);  ///< Region 10 permission in world 0 for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_2 Register bits
    namespace core_1_region_pms_constrain_2_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_0 = (2 << 0);  ///< Region 0 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_1 = (2 << 2);  ///< Region 1 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_2 = (2 << 4);  ///< Region 2 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_3 = (2 << 6);  ///< Region 3 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_4 = (2 << 8);  ///< Region 4 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_5 = (2 << 10);  ///< Region 5 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_6 = (2 << 12);  ///< Region 6 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_7 = (2 << 14);  ///< Region 7 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_8 = (2 << 16);  ///< Region 8 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_9 = (2 << 18);  ///< Region 9 permission in world 1 for core1.
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_10 = (2 << 20);  ///< Region 10 permission in world 1 for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_3 Register bits
    namespace core_1_region_pms_constrain_3_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_0 = (30 << 0);  ///< Region 0 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_4 Register bits
    namespace core_1_region_pms_constrain_4_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_1 = (30 << 0);  ///< Region 0 end address and Region 1 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_5 Register bits
    namespace core_1_region_pms_constrain_5_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_2 = (30 << 0);  ///< Region 1 end address and Region 2 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_6 Register bits
    namespace core_1_region_pms_constrain_6_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_3 = (30 << 0);  ///< Region 2 end address and Region 3 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_7 Register bits
    namespace core_1_region_pms_constrain_7_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_4 = (30 << 0);  ///< Region 3 end address and Region 4 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_8 Register bits
    namespace core_1_region_pms_constrain_8_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_5 = (30 << 0);  ///< Region 4 end address and Region 5 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_9 Register bits
    namespace core_1_region_pms_constrain_9_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_6 = (30 << 0);  ///< Region 5 end address and Region 6 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_10 Register bits
    namespace core_1_region_pms_constrain_10_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_7 = (30 << 0);  ///< Region 6 end address and Region 7 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_11 Register bits
    namespace core_1_region_pms_constrain_11_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_8 = (30 << 0);  ///< Region 7 end address and Region 8 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_12 Register bits
    namespace core_1_region_pms_constrain_12_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_9 = (30 << 0);  ///< Region 8 end address and Region 9 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_13 Register bits
    namespace core_1_region_pms_constrain_13_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_10 = (30 << 0);  ///< Region 9 end address and Region 10 start address for core1.
    }

    /// CORE_1_REGION_PMS_CONSTRAIN_14 Register bits
    namespace core_1_region_pms_constrain_14_bits {
        constexpr uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_11 = (30 << 0);  ///< Region 10 end address for core1.
    }

    /// CORE_1_PIF_PMS_MONITOR_0 Register bits
    namespace core_1_pif_pms_monitor_0_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock core1 permission report registers.
    }

    /// CORE_1_PIF_PMS_MONITOR_1 Register bits
    namespace core_1_pif_pms_monitor_1_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear interrupt that core1 initiate illegal PIF bus access.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable interrupt that core1 initiate illegal PIF bus access.
    }

    /// CORE_1_PIF_PMS_MONITOR_2 Register bits
    namespace core_1_pif_pms_monitor_2_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< Record core1 illegal access interrupt state.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0 = (1U << 1);  ///< Record hport information when core1 initiate illegal access.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE = (3 << 2);  ///< Record access type when core1 initate illegal access.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE = (1U << 5);  ///< Record access direction when core1 initiate illegal access.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD = (2 << 6);  ///< Record world information when core1 initiate illegal access.
    }

    /// CORE_1_PIF_PMS_MONITOR_3 Register bits
    namespace core_1_pif_pms_monitor_3_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR = (32 << 0);  ///< Record address information when core1 initiate illegal access.
    }

    /// CORE_1_PIF_PMS_MONITOR_4 Register bits
    namespace core_1_pif_pms_monitor_4_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear interrupt that core1 initiate unsupported access type.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable interrupt that core1 initiate unsupported access type.
    }

    /// CORE_1_PIF_PMS_MONITOR_5 Register bits
    namespace core_1_pif_pms_monitor_5_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR = (1U << 0);  ///< Record core1 unsupported access type interrupt state.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE = (2 << 1);  ///< Record access type when core1 initiate unsupported access type.
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD = (2 << 3);  ///< Record world information when core1 initiate unsupported access type.
    }

    /// CORE_1_PIF_PMS_MONITOR_6 Register bits
    namespace core_1_pif_pms_monitor_6_bits {
        constexpr uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR = (32 << 0);  ///< Record address information when core1 initiate unsupported access type.
    }

    /// CORE_1_VECBASE_OVERRIDE_LOCK Register bits
    namespace core_1_vecbase_override_lock_bits {
        constexpr uint32_t CORE_1_VECBASE_OVERRIDE_LOCK = (1U << 0);  ///< Set 1 to lock core1 vecbase configuration register
    }

    /// CORE_1_VECBASE_OVERRIDE_0 Register bits
    namespace core_1_vecbase_override_0_bits {
        constexpr uint32_t CORE_1_VECBASE_WORLD_MASK = (1U << 0);  ///< Set 1 to mask world, then only world0_value will work.
    }

    /// CORE_1_VECBASE_OVERRIDE_1 Register bits
    namespace core_1_vecbase_override_1_bits {
        constexpr uint32_t CORE_1_VECBASE_OVERRIDE_WORLD0_VALUE = (22 << 0);  ///< world0 vecbase_override register, when core1 in world0 use this register to override vecbase register.
        constexpr uint32_t CORE_1_VECBASE_OVERRIDE_SEL = (2 << 22);  ///< Set 0x3 to sel vecbase_override to override vecbase register.
    }

    /// CORE_1_VECBASE_OVERRIDE_2 Register bits
    namespace core_1_vecbase_override_2_bits {
        constexpr uint32_t CORE_1_VECBASE_OVERRIDE_WORLD1_VALUE = (22 << 0);  ///< world1 vecbase_override register, when core1 in world1 use this register to override vecbase register.
    }

    /// CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_0 Register bits
    namespace core_1_toomanyexceptions_m_override_0_bits {
        constexpr uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_LOCK = (1U << 0);  ///< Set 1 to lock core1 toomanyexception override configuration register
    }

    /// CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_1 Register bits
    namespace core_1_toomanyexceptions_m_override_1_bits {
        constexpr uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE = (1U << 0);  ///< Set 1 to mask toomanyexception.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_0 Register bits
    namespace backup_bus_pms_constrain_0_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_LOCK = (1U << 0);  ///< Set 1 to lock BackUp permission configuration registers.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_1 Register bits
    namespace backup_bus_pms_constrain_1_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART = (2 << 0);  ///< BackUp access uart permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_1 = (2 << 2);  ///< BackUp access g0spi_1 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_0 = (2 << 4);  ///< BackUp access g0spi_0 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_GPIO = (2 << 6);  ///< BackUp access gpio permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE2 = (2 << 8);  ///< BackUp access fe2 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE = (2 << 10);  ///< BackUp access fe permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTC = (2 << 14);  ///< BackUp access rtc permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_IO_MUX = (2 << 16);  ///< BackUp access io_mux permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_HINF = (2 << 20);  ///< BackUp access hinf permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_MISC = (2 << 24);  ///< BackUp access misc permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C = (2 << 26);  ///< BackUp access i2c permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2S0 = (2 << 28);  ///< BackUp access i2s0 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART1 = (2 << 30);  ///< BackUp access uart1 permission.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_2 Register bits
    namespace backup_bus_pms_constrain_2_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT = (2 << 0);  ///< BackUp access bt permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT0 = (2 << 4);  ///< BackUp access i2c_ext0 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UHCI0 = (2 << 6);  ///< BackUp access uhci0 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SLCHOST = (2 << 8);  ///< BackUp access slchost permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RMT = (2 << 10);  ///< BackUp access rmt permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_PCNT = (2 << 12);  ///< BackUp access pcnt permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SLC = (2 << 14);  ///< BackUp access slc permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_LEDC = (2 << 16);  ///< BackUp access ledc permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BACKUP = (2 << 18);  ///< BackUp access backup permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BB = (2 << 22);  ///< BackUp access bb permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWM0 = (2 << 24);  ///< BackUp access pwm0 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP = (2 << 26);  ///< BackUp access timergroup permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP1 = (2 << 28);  ///< BackUp access timergroup1 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SYSTIMER = (2 << 30);  ///< BackUp access systimer permission.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_3 Register bits
    namespace backup_bus_pms_constrain_3_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SPI_2 = (2 << 0);  ///< BackUp access spi_2 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SPI_3 = (2 << 2);  ///< BackUp access spi_3 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_CTRL = (2 << 4);  ///< BackUp access apb_ctrl permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT1 = (2 << 6);  ///< BackUp access i2c_ext1 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SDIO_HOST = (2 << 8);  ///< BackUp access sdio_host permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CAN = (2 << 10);  ///< BackUp access can permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWM1 = (2 << 12);  ///< BackUp access pwm1 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2S1 = (2 << 14);  ///< BackUp access i2s1 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART2 = (2 << 16);  ///< BackUp access uart2 permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RWBT = (2 << 22);  ///< BackUp access rwbt permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_WIFIMAC = (2 << 26);  ///< BackUp access wifimac permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWR = (2 << 28);  ///< BackUp access pwr permission.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_4 Register bits
    namespace backup_bus_pms_constrain_4_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_DEVICE = (2 << 0);  ///< BackUp access usb_device permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_WRAP = (2 << 2);  ///< BackUp access usb_wrap permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_PERI = (2 << 4);  ///< BackUp access crypto_peri permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_DMA = (2 << 6);  ///< BackUp access crypto_dma permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_ADC = (2 << 8);  ///< BackUp access apb_adc permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_LCD_CAM = (2 << 10);  ///< BackUp access lcd_cam permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT_PWR = (2 << 12);  ///< BackUp access bt_pwr permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB = (2 << 14);  ///< BackUp access usb permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SYSTEM = (2 << 16);  ///< BackUp access system permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_SENSITIVE = (2 << 18);  ///< BackUp access sensitive permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_INTERRUPT = (2 << 20);  ///< BackUp access interrupt permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_DMA_COPY = (2 << 22);  ///< BackUp access dma_copy permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_CACHE_CONFIG = (2 << 24);  ///< BackUp access cache_config permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_AD = (2 << 26);  ///< BackUp access ad permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_DIO = (2 << 28);  ///< BackUp access dio permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_WORLD_CONTROLLER = (2 << 30);  ///< BackUp access world_controller permission.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_5 Register bits
    namespace backup_bus_pms_constrain_5_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_SPLTADDR = (11 << 0);  ///< BackUp access rtcfast_spltaddr permission.
    }

    /// BACKUP_BUS_PMS_CONSTRAIN_6 Register bits
    namespace backup_bus_pms_constrain_6_bits {
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_L = (3 << 0);  ///< BackUp access rtcfast_l permission.
        constexpr uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_H = (3 << 3);  ///< BackUp access rtcfast_h permission.
    }

    /// BACKUP_BUS_PMS_MONITOR_0 Register bits
    namespace backup_bus_pms_monitor_0_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_LOCK = (1U << 0);  ///< Set 1 to lock BackUp permission report registers.
    }

    /// BACKUP_BUS_PMS_MONITOR_1 Register bits
    namespace backup_bus_pms_monitor_1_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_CLR = (1U << 0);  ///< Set 1 to clear interrupt that BackUp initiate illegal access.
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_EN = (1U << 1);  ///< Set 1 to enable interrupt that BackUp initiate illegal access.
    }

    /// BACKUP_BUS_PMS_MONITOR_2 Register bits
    namespace backup_bus_pms_monitor_2_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_INTR = (1U << 0);  ///< Record BackUp illegal access interrupt state.
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HTRANS = (2 << 1);  ///< Record htrans when BackUp initate illegal access.
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HSIZE = (3 << 3);  ///< Record access type when BackUp initate illegal access.
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HWRITE = (1U << 6);  ///< Record access direction when BackUp initiate illegal access.
    }

    /// BACKUP_BUS_PMS_MONITOR_3 Register bits
    namespace backup_bus_pms_monitor_3_bits {
        constexpr uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_HADDR = (32 << 0);  ///< Record address information when BackUp initiate illegal access.
    }

    /// EDMA_BOUNDARY_LOCK Register bits
    namespace edma_boundary_lock_bits {
        constexpr uint32_t EDMA_BOUNDARY_LOCK = (1U << 0);  ///< Set 1 to lock EDMA boundary registers.
    }

    /// EDMA_BOUNDARY_0 Register bits
    namespace edma_boundary_0_bits {
        constexpr uint32_t EDMA_BOUNDARY_0 = (14 << 0);  ///< This field is used to configure the boundary 0 of external RAM. The unit is 4K. For example, set this field to 0x80, then the address boundary 0 would be 0x3C080000 (0x3C000000 + 0x80 * 4K).
    }

    /// EDMA_BOUNDARY_1 Register bits
    namespace edma_boundary_1_bits {
        constexpr uint32_t EDMA_BOUNDARY_1 = (14 << 0);  ///< This field is used to configure the boundary 1 of external RAM. The unit is 4K. For example, set this field to 0x80, then the address boundary 0 would be 0x3C080000 (0x3C000000 + 0x80 * 4K).
    }

    /// EDMA_BOUNDARY_2 Register bits
    namespace edma_boundary_2_bits {
        constexpr uint32_t EDMA_BOUNDARY_2 = (14 << 0);  ///< This field is used to configure the boundary 2 of external RAM. The unit is 4K. For example, set this field to 0x80, then the address boundary 0 would be 0x3C080000 (0x3C000000 + 0x80 * 4K).
    }

    /// EDMA_PMS_SPI2_LOCK Register bits
    namespace edma_pms_spi2_lock_bits {
        constexpr uint32_t EDMA_PMS_SPI2_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-SPI2 permission control registers.
    }

    /// EDMA_PMS_SPI2 Register bits
    namespace edma_pms_spi2_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of SPI2 accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of SPI2 accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_SPI3_LOCK Register bits
    namespace edma_pms_spi3_lock_bits {
        constexpr uint32_t EDMA_PMS_SPI3_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-SPI3 permission control registers.
    }

    /// EDMA_PMS_SPI3 Register bits
    namespace edma_pms_spi3_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of SPI3 accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of SPI3 accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_UHCI0_LOCK Register bits
    namespace edma_pms_uhci0_lock_bits {
        constexpr uint32_t EDMA_PMS_UHCI0_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-UHCI0 permission control registers.
    }

    /// EDMA_PMS_UHCI0 Register bits
    namespace edma_pms_uhci0_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of UHCI0 accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of UHCI0 accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_I2S0_LOCK Register bits
    namespace edma_pms_i2s0_lock_bits {
        constexpr uint32_t EDMA_PMS_I2S0_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-I2S0 permission control registers.
    }

    /// EDMA_PMS_I2S0 Register bits
    namespace edma_pms_i2s0_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of I2S0 accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of I2S0 accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_I2S1_LOCK Register bits
    namespace edma_pms_i2s1_lock_bits {
        constexpr uint32_t EDMA_PMS_I2S1_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-I2S1 permission control registers.
    }

    /// EDMA_PMS_I2S1 Register bits
    namespace edma_pms_i2s1_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of I2S1 accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of I2S1 accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_LCD_CAM_LOCK Register bits
    namespace edma_pms_lcd_cam_lock_bits {
        constexpr uint32_t EDMA_PMS_LCD_CAM_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-LCD/CAM permission control registers.
    }

    /// EDMA_PMS_LCD_CAM Register bits
    namespace edma_pms_lcd_cam_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of LCD/CAM accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of LCD/CAM accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_AES_LOCK Register bits
    namespace edma_pms_aes_lock_bits {
        constexpr uint32_t EDMA_PMS_AES_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-AES permission control registers.
    }

    /// EDMA_PMS_AES Register bits
    namespace edma_pms_aes_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of AES accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of AES accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_SHA_LOCK Register bits
    namespace edma_pms_sha_lock_bits {
        constexpr uint32_t EDMA_PMS_SHA_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-SHA permission control registers.
    }

    /// EDMA_PMS_SHA Register bits
    namespace edma_pms_sha_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of SHA accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of SHA accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_ADC_DAC_LOCK Register bits
    namespace edma_pms_adc_dac_lock_bits {
        constexpr uint32_t EDMA_PMS_ADC_DAC_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-ADC/DAC permission control registers.
    }

    /// EDMA_PMS_ADC_DAC Register bits
    namespace edma_pms_adc_dac_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of ADC/DAC accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of ADC/DAC accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// EDMA_PMS_RMT_LOCK Register bits
    namespace edma_pms_rmt_lock_bits {
        constexpr uint32_t EDMA_PMS_RMT_LOCK = (1U << 0);  ///< Set 1 to lock EDMA-RMT permission control registers.
    }

    /// EDMA_PMS_RMT Register bits
    namespace edma_pms_rmt_bits {
        constexpr uint32_t ATTR1 = (2 << 0);  ///< This field is used to configure the permission of RMT accessing address, which is larger than boundary 0 and less than boundary 1, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
        constexpr uint32_t ATTR2 = (2 << 2);  ///< This field is used to configure the permission of RMT accessing address, which is larger than boundary 1 and less than boundary 2, through EDMA. Bit 0: set this bit to enable read permission. Bit 1: set this bit to enable write permission.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t REG_CLK_EN = (1U << 0);  ///< Set 1 to enable clock gate function.
    }

    /// RTC_PMS Register bits
    namespace rtc_pms_bits {
        constexpr uint32_t DIS_RTC_CPU = (1U << 0);  ///< Set 1 to disable rtc coprocessor.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< Sensitive Date register.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x60003000;
    constexpr uint32_t SPI1_BASE = 0x60002000;
    constexpr uint32_t SPI2_BASE = 0x60024000;
    constexpr uint32_t SPI3_BASE = 0x60025000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x08 - SPI0 control register.
        volatile uint32_t CTRL1;  ///< Offset: 0x0C - SPI0 control 1 register.
        volatile uint32_t CTRL2;  ///< Offset: 0x10 - SPI0 control 2 register.
        volatile uint32_t CLOCK;  ///< Offset: 0x14 - SPI_CLK clock division register when SPI0 accesses to flash.
        volatile uint32_t USER;  ///< Offset: 0x18 - SPI0 user register.
        volatile uint32_t USER1;  ///< Offset: 0x1C - SPI0 user1 register.
        volatile uint32_t USER2;  ///< Offset: 0x20 - SPI0 user2 register.
        volatile uint32_t RD_STATUS;  ///< Offset: 0x2C - SPI0 read control register.
        volatile uint32_t EXT_ADDR;  ///< Offset: 0x30 - SPI0 extended address register.
        volatile uint32_t MISC;  ///< Offset: 0x34 - SPI0 misc register
        volatile uint32_t CACHE_FCTRL;  ///< Offset: 0x3C - SPI0 external RAM bit mode control register.
        volatile uint32_t CACHE_SCTRL;  ///< Offset: 0x40 - SPI0 external RAM control register
        volatile uint32_t SRAM_CMD;  ///< Offset: 0x44 - SPI0 external RAM mode control register
        volatile uint32_t SRAM_DRD_CMD;  ///< Offset: 0x48 - SPI0 external RAM DDR read command control register
        volatile uint32_t SRAM_DWR_CMD;  ///< Offset: 0x4C - SPI0 external RAM DDR write command control register
        volatile uint32_t SRAM_CLK;  ///< Offset: 0x50 - SPI_CLK clock division register when SPI0 accesses to Ext_RAM.
        volatile uint32_t FSM;  ///< Offset: 0x54 - SPI0 state machine(FSM) status register.
        volatile uint32_t TIMING_CALI;  ///< Offset: 0xA8 - SPI0 timing compensation register when accesses to flash.
        volatile uint32_t DIN_MODE;  ///< Offset: 0xAC - MSPI input timing delay mode control register when...
        volatile uint32_t DIN_NUM;  ///< Offset: 0xB0 - MSPI input timing delay number control register when...
        volatile uint32_t DOUT_MODE;  ///< Offset: 0xB4 - MSPI output timing delay mode control register when...
        volatile uint32_t SPI_SMEM_TIMING_CALI;  ///< Offset: 0xBC - SPI0 Ext_RAM timing compensation register.
        volatile uint32_t SPI_SMEM_DIN_MODE;  ///< Offset: 0xC0 - MSPI input timing delay mode control register when...
        volatile uint32_t SPI_SMEM_DIN_NUM;  ///< Offset: 0xC4 - MSPI input timing delay number control register when...
        volatile uint32_t SPI_SMEM_DOUT_MODE;  ///< Offset: 0xC8 - MSPI output timing delay mode control register when...
        volatile uint32_t ECC_CTRL;  ///< Offset: 0xCC - MSPI ECC control register
        volatile uint32_t ECC_ERR_ADDR;  ///< Offset: 0xD0 - MSPI ECC error address register
        volatile uint32_t ECC_ERR_BIT;  ///< Offset: 0xD4 - MSPI ECC error bits register
        volatile uint32_t SPI_SMEM_AC;  ///< Offset: 0xDC - MSPI external RAM ECC and SPI CS timing control register
        volatile uint32_t DDR;  ///< Offset: 0xE0 - SPI0 flash DDR mode control register
        volatile uint32_t SPI_SMEM_DDR;  ///< Offset: 0xE4 - SPI0 external RAM DDR mode control register
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0xE8 - SPI0 clk_gate register
        volatile uint32_t CORE_CLK_SEL;  ///< Offset: 0xEC - SPI0 module clock select register
        volatile uint32_t INT_ENA;  ///< Offset: 0xF0 - SPI1 interrupt enable register
        volatile uint32_t INT_CLR;  ///< Offset: 0xF4 - SPI1 interrupt clear register
        volatile uint32_t INT_RAW;  ///< Offset: 0xF8 - SPI1 interrupt raw register
        volatile uint32_t INT_ST;  ///< Offset: 0xFC - SPI1 interrupt status register
        volatile uint32_t DATE;  ///< Offset: 0x3FC - SPI0 version control register
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FDUMMY_OUT = (1U << 3);  ///< In the DUMMY phase the signal level of SPI bus is output by the SPI0 controller.
        constexpr uint32_t FDOUT_OCT = (1U << 4);  ///< Set this bit to enable 8-bit-mode(8-bm) in DOUT phase.
        constexpr uint32_t FDIN_OCT = (1U << 5);  ///< Set this bit to enable 8-bit-mode(8-bm) in DIN phase.
        constexpr uint32_t FADDR_OCT = (1U << 6);  ///< Set this bit to enable 8-bit-mode(8-bm) in ADDR phase.
        constexpr uint32_t FCMD_DUAL = (1U << 7);  ///< Set this bit to enable 2-bit-mode(2-bm) in CMD phase.
        constexpr uint32_t FCMD_QUAD = (1U << 8);  ///< Set this bit to enable 4-bit-mode(4-bm) in CMD phase.
        constexpr uint32_t FCMD_OCT = (1U << 9);  ///< Set this bit to enable 8-bit-mode(8-bm) in CMD phase.
        constexpr uint32_t FASTRD_MODE = (1U << 13);  ///< This bit should be set when SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QUAD or SPI_MEM_FREAD_DUAL is set.
        constexpr uint32_t FREAD_DUAL = (1U << 14);  ///< In hardware 0x3B read operation, DIN phase apply 2 signals. 1: enable 0: disable.
        constexpr uint32_t Q_POL = (1U << 18);  ///< The bit is used to set MISO line polarity, 1: high 0, low
        constexpr uint32_t D_POL = (1U << 19);  ///< The bit is used to set MOSI line polarity, 1: high 0, low
        constexpr uint32_t FREAD_QUAD = (1U << 20);  ///< In hardware 0x6B read operation, DIN phase apply 4 signals(4-bit-mode). 1: enable 0: disable.
        constexpr uint32_t WP = (1U << 21);  ///< Write protect signal output when SPI is idle. 1: output high, 0: output low.
        constexpr uint32_t FREAD_DIO = (1U << 23);  ///< In hardware 0xBB read operation, ADDR phase and DIN phase apply 2 signals(2-bit-mode). 1: enable 0: disable.
        constexpr uint32_t FREAD_QIO = (1U << 24);  ///< In hardware 0xEB read operation, ADDR phase and DIN phase apply 4 signals(4-bit-mode). 1: enable 0: disable.
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t CLK_MODE = (2 << 0);  ///< SPI Bus clock (SPI_CLK) mode bits. 0: SPI Bus clock (SPI_CLK) is off when CS inactive 1: SPI_CLK is delayed one cycle after SPI_CS inactive 2: SPI_CLK is delayed two cycles after SPI_CS inactive 3: SPI_CLK is always on.
        constexpr uint32_t RXFIFO_RST = (1U << 30);  ///< SPI0 RX FIFO reset signal. Set this bit and clear it before SPI0 transfer starts.
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t CS_SETUP_TIME = (5 << 0);  ///< (cycles-1) of PREP phase by SPI_CLK, which is the SPI_CS setup time. These bits are combined with SPI_MEM_CS_SETUP bit.
        constexpr uint32_t CS_HOLD_TIME = (5 << 5);  ///< SPI Bus CS (SPI_CS) signal is delayed to inactive by SPI Bus clock (SPI_CLK), which is the SPI_CS hold time in non-ECC mode. These bits are combined with SPI_MEM_CS_HOLD bit.
        constexpr uint32_t ECC_CS_HOLD_TIME = (3 << 10);  ///< SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI_CS hold cycle in ECC mode when accessed flash.
        constexpr uint32_t ECC_SKIP_PAGE_CORNER = (1U << 13);  ///< 1: MSPI skips page corner when accesses flash. 0: Not skip page corner when accesses flash.
        constexpr uint32_t ECC_16TO18_BYTE_EN = (1U << 14);  ///< Set this bit to enable MSPI ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
        constexpr uint32_t CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        constexpr uint32_t SYNC_RESET = (1U << 31);  ///< The FSM will be reset.
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLKCNT_L = (8 << 0);  ///< It must equal to the value of SPI_MEM_CLKCNT_N.
        constexpr uint32_t CLKCNT_H = (8 << 8);  ///< It must be a floor value of ((SPI_MEM_CLKCNT_N+1)/2-1).
        constexpr uint32_t CLKCNT_N = (8 << 16);  ///< When SPI0 accesses flash, f_SPI_CLK = f_MSPI_CORE_CLK/(SPI_MEM_CLKCNT_N+1)
        constexpr uint32_t CLK_EQU_SYSCLK = (1U << 31);  ///< When SPI0 accesses flash, set this bit in 1-division mode, f_SPI_CLK = f_MSPI_CORE_CLK.
    }

    /// USER Register bits
    namespace user_bits {
        constexpr uint32_t CS_HOLD = (1U << 6);  ///< Set this bit to keep SPI_CS low when MSPI is in DONE state.
        constexpr uint32_t CS_SETUP = (1U << 7);  ///< Set this bit to keep SPI_CS low when MSPI is in PREP state.
        constexpr uint32_t CK_OUT_EDGE = (1U << 9);  ///< This bit, combined with SPI_MEM_CK_IDLE_EDGE bit, is used to change the clock mode 0~3 of SPI_CLK.
        constexpr uint32_t USR_DUMMY_IDLE = (1U << 26);  ///< SPI_CLK is disabled(No clock edges) in DUMMY phase when the bit is enable.
        constexpr uint32_t USR_DUMMY = (1U << 29);  ///< This bit enable the DUMMY phase of an SPI transfer.
    }

    /// USER1 Register bits
    namespace user1_bits {
        constexpr uint32_t USR_DUMMY_CYCLELEN = (6 << 0);  ///< The SPI_CLK cycle length minus 1 of DUMMY phase.
        constexpr uint32_t USR_ADDR_BITLEN = (6 << 26);  ///< The length in bits of ADDR phase. The register value shall be (bit_num-1).
    }

    /// USER2 Register bits
    namespace user2_bits {
        constexpr uint32_t USR_COMMAND_VALUE = (16 << 0);  ///< The value of user defined(USR) command.
        constexpr uint32_t USR_COMMAND_BITLEN = (4 << 28);  ///< The length in bits of CMD phase. The register value shall be (bit_num-1)
    }

    /// RD_STATUS Register bits
    namespace rd_status_bits {
        constexpr uint32_t WB_MODE = (8 << 16);  ///< Mode bits in the flash fast read mode it is combined with SPI_MEM_FASTRD_MODE bit.
    }

    /// EXT_ADDR Register bits
    namespace ext_addr_bits {
        constexpr uint32_t EXT_ADDR = (32 << 0);  ///< The register are the higher 32bits in the 64 bits address mode.
    }

    /// MISC Register bits
    namespace misc_bits {
        constexpr uint32_t FSUB_PIN = (1U << 7);  ///< Flash is connected to SPI SUBPIN bus.
        constexpr uint32_t SSUB_PIN = (1U << 8);  ///< Ext_RAM is connected to SPI SUBPIN bus.
        constexpr uint32_t CK_IDLE_EDGE = (1U << 9);  ///< 1: SPI_CLK line is high when idle. 0: SPI_CLK line is low when idle
        constexpr uint32_t CS_KEEP_ACTIVE = (1U << 10);  ///< SPI_CS line keep low when the bit is set.
    }

    /// CACHE_FCTRL Register bits
    namespace cache_fctrl_bits {
        constexpr uint32_t CACHE_REQ_EN = (1U << 0);  ///< Set this bit to enable Cache's access and SPI0's transfer.
        constexpr uint32_t CACHE_USR_CMD_4BYTE = (1U << 1);  ///< Set this bit to enable SPI0 read flash with 32 bits address. The value of SPI_MEM_USR_ADDR_BITLEN should be 31.
        constexpr uint32_t CACHE_FLASH_USR_CMD = (1U << 2);  ///< 1: The command value of SPI0 reads flash is SPI_MEM_USR_COMMAND_VALUE. 0: Hardware read command value, controlled by SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QUAD, SPI_MEM_FREAD_DUAL and SPI_MEM_FASTRD_MODE bits.
        constexpr uint32_t FDIN_DUAL = (1U << 3);  ///< When SPI0 accesses to flash, set this bit to enable 2-bm in DIN phase.
        constexpr uint32_t FDOUT_DUAL = (1U << 4);  ///< When SPI0 accesses to flash, set this bit to enable 2-bm in DOUT phase.
        constexpr uint32_t FADDR_DUAL = (1U << 5);  ///< When SPI0 accesses to flash, set this bit to enable 2-bm in ADDR phase.
        constexpr uint32_t FDIN_QUAD = (1U << 6);  ///< When SPI0 accesses to flash, set this bit to enable 4-bm in DIN phase.
        constexpr uint32_t FDOUT_QUAD = (1U << 7);  ///< When SPI0 accesses to flash, set this bit to enable 4-bm in DOUT phase.
        constexpr uint32_t FADDR_QUAD = (1U << 8);  ///< When SPI0 accesses to flash, set this bit to enable 4-bm in ADDR phase.
    }

    /// CACHE_SCTRL Register bits
    namespace cache_sctrl_bits {
        constexpr uint32_t CACHE_USR_SCMD_4BYTE = (1U << 0);  ///< Set this bit to enable SPI0 read Ext_RAM with 32 bits address. The value of SPI_MEM_SRAM_ADDR_BITLEN should be 31.
        constexpr uint32_t USR_SRAM_DIO = (1U << 1);  ///< Set the bit to enable 2-bm in all the phases of SPI0 Ext_RAM transfer.
        constexpr uint32_t USR_SRAM_QIO = (1U << 2);  ///< Set the bit to enable QPI mode in all SPI0 Ext_RAM transfer.
        constexpr uint32_t USR_WR_SRAM_DUMMY = (1U << 3);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable DUMMY phase in write operations.
        constexpr uint32_t USR_RD_SRAM_DUMMY = (1U << 4);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable DUMMY phase in read operations.
        constexpr uint32_t CACHE_SRAM_USR_RCMD = (1U << 5);  ///< 1: The command value of SPI0 read Ext_RAM is SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE. 0: The value is 0x2.
        constexpr uint32_t SRAM_RDUMMY_CYCLELEN = (6 << 6);  ///< When SPI0 accesses to Ext_RAM, it is the SPI_CLK cycles minus 1 of DUMMY phase in read data transfer.
        constexpr uint32_t SRAM_ADDR_BITLEN = (6 << 14);  ///< When SPI0 accesses to Ext_RAM, it is the length in bits of ADDR phase. The register value shall be (bit_num-1).
        constexpr uint32_t CACHE_SRAM_USR_WCMD = (1U << 20);  ///< 1: The command value of SPI0 write Ext_RAM is SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE. 0: The value is 0x3.
        constexpr uint32_t SRAM_OCT = (1U << 21);  ///< Set the bit to enable OPI mode in all SPI0 Ext_RAM transfer.
        constexpr uint32_t SRAM_WDUMMY_CYCLELEN = (6 << 22);  ///< When SPI0 accesses to Ext_RAM, it is the SPI_CLK cycles minus 1 of DUMMY phase in write data transfer.
    }

    /// SRAM_CMD Register bits
    namespace sram_cmd_bits {
        constexpr uint32_t SCLK_MODE = (2 << 0);  ///< SPI_CLK mode bits when SPI0 accesses to Ext_RAM. 0: SPI_CLK is off when CS inactive 1: SPI_CLK is delayed one cycle after CS inactive 2: SPI_CLK is delayed two cycles after CS inactive 3: SPI_CLK is always on.
        constexpr uint32_t SWB_MODE = (8 << 2);  ///< Mode bits when SPI0 accesses to Ext_RAM.
        constexpr uint32_t SDIN_DUAL = (1U << 10);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in DIN phase.
        constexpr uint32_t SDOUT_DUAL = (1U << 11);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in DOUT phase.
        constexpr uint32_t SADDR_DUAL = (1U << 12);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in ADDR phase.
        constexpr uint32_t SCMD_DUAL = (1U << 13);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in CMD phase.
        constexpr uint32_t SDIN_QUAD = (1U << 14);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in DIN phase.
        constexpr uint32_t SDOUT_QUAD = (1U << 15);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in DOUT phase.
        constexpr uint32_t SADDR_QUAD = (1U << 16);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in ADDR phase.
        constexpr uint32_t SCMD_QUAD = (1U << 17);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in CMD phase.
        constexpr uint32_t SDIN_OCT = (1U << 18);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in DIN phase.
        constexpr uint32_t SDOUT_OCT = (1U << 19);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in DOUT phase.
        constexpr uint32_t SADDR_OCT = (1U << 20);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in ADDR phase.
        constexpr uint32_t SCMD_OCT = (1U << 21);  ///< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in CMD phase.
        constexpr uint32_t SDUMMY_OUT = (1U << 22);  ///< When SPI0 accesses to Ext_RAM, in the DUMMY phase the signal level of SPI bus is output by the SPI0 controller.
    }

    /// SRAM_DRD_CMD Register bits
    namespace sram_drd_cmd_bits {
        constexpr uint32_t CACHE_SRAM_USR_RD_CMD_VALUE = (16 << 0);  ///< When SPI0 reads Ext_RAM, it is the command value of CMD phase.
        constexpr uint32_t CACHE_SRAM_USR_RD_CMD_BITLEN = (4 << 28);  ///< When SPI0 reads Ext_RAM, it is the length in bits of CMD phase. The register value shall be (bit_num-1).
    }

    /// SRAM_DWR_CMD Register bits
    namespace sram_dwr_cmd_bits {
        constexpr uint32_t CACHE_SRAM_USR_WR_CMD_VALUE = (16 << 0);  ///< When SPI0 writes Ext_RAM, it is the command value of CMD phase.
        constexpr uint32_t CACHE_SRAM_USR_WR_CMD_BITLEN = (4 << 28);  ///< When SPI0 writes Ext_RAM, it is the length in bits of CMD phase. The register value shall be (bit_num-1).
    }

    /// SRAM_CLK Register bits
    namespace sram_clk_bits {
        constexpr uint32_t SCLKCNT_L = (8 << 0);  ///< It must equal to the value of SPI_MEM_SCLKCNT_N.
        constexpr uint32_t SCLKCNT_H = (8 << 8);  ///< It must be a floor value of ((SPI_MEM_SCLKCNT_N+1)/2-1).
        constexpr uint32_t SCLKCNT_N = (8 << 16);  ///< When SPI0 accesses to Ext_RAM, f_SPI_CLK = f_MSPI_CORE_CLK/(SPI_MEM_SCLKCNT_N+1)
        constexpr uint32_t SCLK_EQU_SYSCLK = (1U << 31);  ///< When SPI0 accesses to Ext_RAM, set this bit in 1-division mode, f_SPI_CLK = f_MSPI_CORE_CLK.
    }

    /// FSM Register bits
    namespace fsm_bits {
        constexpr uint32_t ST = (3 << 0);  ///< The status of SPI0 state machine. 0: idle state(IDLE), 1: preparation state(PREP), 2: send command state(CMD), 3: send address state(ADDR), 4: red data state(DIN), 5:write data state(DOUT), 6: wait state(DUMMY), 7: done state(DONE).
    }

    /// TIMING_CALI Register bits
    namespace timing_cali_bits {
        constexpr uint32_t TIMING_CLK_ENA = (1U << 0);  ///< Set this bit to power on HCLK. When PLL is powered on, the frequency of HCLK equals to that of PLL. Otherwise, the frequency equals to that of XTAL.
        constexpr uint32_t TIMING_CALI = (1U << 1);  ///< Set this bit to add extra SPI_CLK cycles in DUMMY phase for all reading operations.
        constexpr uint32_t EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< Extra SPI_CLK cycles added in DUMMY phase for timing compensation, when SPI0 accesses to flash. Active when SPI_MEM_TIMING_CALI bit is set.
    }

    /// DIN_MODE Register bits
    namespace din_mode_bits {
        constexpr uint32_t DIN0_MODE = (3 << 0);  ///< SPI_D input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN0_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN1_MODE = (3 << 3);  ///< SPI_Q input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN3_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN2_MODE = (3 << 6);  ///< SPI_WP input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN6_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN3_MODE = (3 << 9);  ///< SPI_HD input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN9_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN4_MODE = (3 << 12);  ///< SPI_IO4 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN12_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN5_MODE = (3 << 15);  ///< SPI_IO5 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN15_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN6_MODE = (3 << 18);  ///< SPI_IO6 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN18_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DIN7_MODE = (3 << 21);  ///< SPI_IO7 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN21_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DINS_MODE = (3 << 24);  ///< SPI_DQS input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DINS_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
    }

    /// DIN_NUM Register bits
    namespace din_num_bits {
        constexpr uint32_t DIN0_NUM = (2 << 0);  ///< SPI_D input delay number.
        constexpr uint32_t DIN1_NUM = (2 << 2);  ///< SPI_Q input delay number.
        constexpr uint32_t DIN2_NUM = (2 << 4);  ///< SPI_WP input delay number.
        constexpr uint32_t DIN3_NUM = (2 << 6);  ///< SPI_HD input delay number.
        constexpr uint32_t DIN4_NUM = (2 << 8);  ///< SPI_IO4 input delay number.
        constexpr uint32_t DIN5_NUM = (2 << 10);  ///< SPI_IO5 input delay number.
        constexpr uint32_t DIN6_NUM = (2 << 12);  ///< SPI_IO6 input delay number.
        constexpr uint32_t DIN7_NUM = (2 << 14);  ///< SPI_IO7 input delay number.
        constexpr uint32_t DINS_NUM = (2 << 16);  ///< SPI_DQS input delay number.
    }

    /// DOUT_MODE Register bits
    namespace dout_mode_bits {
        constexpr uint32_t DOUT0_MODE = (1U << 0);  ///< SPI_D output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT1_MODE = (1U << 1);  ///< SPI_Q output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT2_MODE = (1U << 2);  ///< SPI_WP output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT3_MODE = (1U << 3);  ///< SPI_HD output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT4_MODE = (1U << 4);  ///< SPI_IO4 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT5_MODE = (1U << 5);  ///< SPI_IO5 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT6_MODE = (1U << 6);  ///< SPI_IO6 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUT7_MODE = (1U << 7);  ///< SPI_IO7 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t DOUTS_MODE = (1U << 8);  ///< SPI_DQS output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
    }

    /// SPI_SMEM_TIMING_CALI Register bits
    namespace spi_smem_timing_cali_bits {
        constexpr uint32_t SPI_SMEM_TIMING_CLK_ENA = (1U << 0);  ///< Set this bit to power on HCLK. When PLL is powered on, the frequency of HCLK equals to that of PLL. Otherwise, the frequency equals to that of XTAL.
        constexpr uint32_t SPI_SMEM_TIMING_CALI = (1U << 1);  ///< Set this bit to add extra SPI_CLK cycles in DUMMY phase for all reading operations.
        constexpr uint32_t SPI_SMEM_EXTRA_DUMMY_CYCLELEN = (3 << 2);  ///< Extra SPI_CLK cycles added in DUMMY phase for timing compensation, when SPI0 accesses to Ext_RAM. Active when SPI_SMEM_TIMING_CALI bit is set.
    }

    /// SPI_SMEM_DIN_MODE Register bits
    namespace spi_smem_din_mode_bits {
        constexpr uint32_t SPI_SMEM_DIN0_MODE = (3 << 0);  ///< SPI_D input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN1_MODE = (3 << 3);  ///< SPI_Q input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN2_MODE = (3 << 6);  ///< SPI_WP input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN3_MODE = (3 << 9);  ///< SPI_HD input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN4_MODE = (3 << 12);  ///< SPI_IO4 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN5_MODE = (3 << 15);  ///< SPI_IO5 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN6_MODE = (3 << 18);  ///< SPI_IO6 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DIN7_MODE = (3 << 21);  ///< SPI_IO7 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DINS_MODE = (3 << 24);  ///< SPI_DQS input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DINS_NUM+1) cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK positive edge. 3: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK negative edge. 4: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK positive edge. 5: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK negative edge and one cycle at MSPI_CORE_CLK negative edge.
    }

    /// SPI_SMEM_DIN_NUM Register bits
    namespace spi_smem_din_num_bits {
        constexpr uint32_t SPI_SMEM_DIN0_NUM = (2 << 0);  ///< SPI_D input delay number.
        constexpr uint32_t SPI_SMEM_DIN1_NUM = (2 << 2);  ///< SPI_Q input delay number.
        constexpr uint32_t SPI_SMEM_DIN2_NUM = (2 << 4);  ///< SPI_WP input delay number.
        constexpr uint32_t SPI_SMEM_DIN3_NUM = (2 << 6);  ///< SPI_HD input delay number.
        constexpr uint32_t SPI_SMEM_DIN4_NUM = (2 << 8);  ///< SPI_IO4 input delay number.
        constexpr uint32_t SPI_SMEM_DIN5_NUM = (2 << 10);  ///< SPI_IO5 input delay number.
        constexpr uint32_t SPI_SMEM_DIN6_NUM = (2 << 12);  ///< SPI_IO6 input delay number.
        constexpr uint32_t SPI_SMEM_DIN7_NUM = (2 << 14);  ///< SPI_IO7 input delay number.
        constexpr uint32_t SPI_SMEM_DINS_NUM = (2 << 16);  ///< SPI_DQS input delay number.
    }

    /// SPI_SMEM_DOUT_MODE Register bits
    namespace spi_smem_dout_mode_bits {
        constexpr uint32_t SPI_SMEM_DOUT0_MODE = (1U << 0);  ///< SPI_D output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT1_MODE = (1U << 1);  ///< SPI_Q output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT2_MODE = (1U << 2);  ///< SPI_WP output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT3_MODE = (1U << 3);  ///< SPI_HD output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT4_MODE = (1U << 4);  ///< SPI_IO4 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT5_MODE = (1U << 5);  ///< SPI_IO5 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT6_MODE = (1U << 6);  ///< SPI_IO6 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUT7_MODE = (1U << 7);  ///< SPI_IO7 output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
        constexpr uint32_t SPI_SMEM_DOUTS_MODE = (1U << 8);  ///< SPI_DQS output delay mode. 0: No delay. 1: Delay one cycle at MSPI_CORE_CLK negative edge.
    }

    /// ECC_CTRL Register bits
    namespace ecc_ctrl_bits {
        constexpr uint32_t ECC_ERR_INT_NUM = (8 << 0);  ///< Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
        constexpr uint32_t SPI_FMEM_ECC_ERR_INT_EN = (1U << 8);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
    }

    /// ECC_ERR_ADDR Register bits
    namespace ecc_err_addr_bits {
        constexpr uint32_t ECC_ERR_ADDR = (32 << 0);  ///< These bits show the first MSPI ECC error address when SPI_FMEM_ECC_ERR_INT_EN/SPI_SMEM_ECC_ERR_INT_EN is set and accessed to flash/Ext_RAM, including ECC byte error and data error. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
    }

    /// ECC_ERR_BIT Register bits
    namespace ecc_err_bit_bits {
        constexpr uint32_t ECC_DATA_ERR_BIT = (7 << 6);  ///< It records the first ECC data error bit number when SPI_FMEM_ECC_ERR_INT_EN/SPI_SMEM_ECC_ERR_INT_EN is set and accessed to flash/Ext_RAM. The value ranges from 0~127, corresponding to the bit number in 16 data bytes. It is cleared by SPI_MEM_ECC_ERR_INT_CLR bit.
        constexpr uint32_t ECC_CHK_ERR_BIT = (3 << 13);  ///< When SPI_MEM_ECC_BYTE_ERR is set, these bits show the error bit number of ECC byte.
        constexpr uint32_t ECC_BYTE_ERR = (1U << 16);  ///< It records the first ECC byte error when SPI_FMEM_ECC_ERR_INT_EN/SPI_SMEM_ECC_ERR_INT_EN is set and accessed to flash/Ext_RAM. It is cleared by SPI_MEM_ECC_ERR_INT_CLR bit.
        constexpr uint32_t ECC_ERR_CNT = (8 << 17);  ///< This bits show the error times of MSPI ECC read, including ECC byte error and data byte error. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
    }

    /// SPI_SMEM_AC Register bits
    namespace spi_smem_ac_bits {
        constexpr uint32_t SPI_SMEM_CS_SETUP = (1U << 0);  ///< Set this bit to keep SPI_CS low when MSPI is in PREP state.
        constexpr uint32_t SPI_SMEM_CS_HOLD = (1U << 1);  ///< Set this bit to keep SPI_CS low when MSPI is in DONE state.
        constexpr uint32_t SPI_SMEM_CS_SETUP_TIME = (5 << 2);  ///< (cycles-1) of PREP phase by SPI_CLK, which is the SPI_CS setup time. These bits are combined with SPI_MEM_CS_SETUP bit.
        constexpr uint32_t SPI_SMEM_CS_HOLD_TIME = (5 << 7);  ///< SPI Bus CS (SPI_CS) signal is delayed to inactive by SPI Bus clock (SPI_CLK), which is the SPI_CS hold time in non-ECC mode. These bits are combined with SPI_MEM_CS_HOLD bit.
        constexpr uint32_t SPI_SMEM_ECC_CS_HOLD_TIME = (3 << 12);  ///< SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the MSPI CS hold cycles in ECC mode when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_ECC_SKIP_PAGE_CORNER = (1U << 15);  ///< 1: MSPI skips page corner when accesses to external RAM. 0: Not skip page corner when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_ECC_16TO18_BYTE_EN = (1U << 16);  ///< Set this bit to enable MSPI ECC 16 bytes data with 2 ECC bytes mode when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_ECC_ERR_INT_EN = (1U << 24);  ///< Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_CS_HOLD_DELAY = (6 << 25);  ///< These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
    }

    /// DDR Register bits
    namespace ddr_bits {
        constexpr uint32_t SPI_FMEM_DDR_EN = (1U << 0);  ///< 1: in ddr mode, 0 in sdr mode
        constexpr uint32_t SPI_FMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_RDAT_SWP = (1U << 2);  ///< Set the bit to reorder RX data of the word in DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_WDAT_SWP = (1U << 3);  ///< Set the bit to swap TX data of a word in DDR mode.
        constexpr uint32_t SPI_FMEM_DDR_CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in CMD phase when ddr mode.
        constexpr uint32_t SPI_FMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the panda device.
        constexpr uint32_t SPI_FMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in MSPI ECC DDR write mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in MSPI ECC DDR read mode, when accesses to flash.
        constexpr uint32_t SPI_FMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI_CLK.
        constexpr uint32_t SPI_FMEM_DDR_DQS_LOOP = (1U << 21);  ///< 1: Use internal signal as data strobe, the strobe can not be delayed by input timing module. 0: Use input SPI_DQS signal from PAD as data strobe, the strobe can be delayed by input timing module
        constexpr uint32_t SPI_FMEM_DDR_DQS_LOOP_MODE = (1U << 22);  ///< When SPI_FMEM_DDR_DQS_LOOP and SPI_FMEM_DDR_EN are set, 1: Use internal SPI_CLK as data strobe. 0: Use internal ~SPI_CLK as data strobe. Otherwise this bit is not active.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_FMEM_HYPERBUS_MODE = (1U << 25);  ///< Set this bit to enable the SPI HyperBus mode.
        constexpr uint32_t SPI_FMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_FMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses to flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_FMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to flash. .
        constexpr uint32_t SPI_FMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_FMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// SPI_SMEM_DDR Register bits
    namespace spi_smem_ddr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< 1: in ddr mode, 0 in sdr mode
        constexpr uint32_t SPI_SMEM_VAR_DUMMY = (1U << 1);  ///< Set the bit to enable variable dummy cycle in spi ddr mode.
        constexpr uint32_t RDAT_SWP = (1U << 2);  ///< Set the bit to reorder rx data of the word in spi ddr mode.
        constexpr uint32_t WDAT_SWP = (1U << 3);  ///< Set the bit to reorder tx data of the word in spi ddr mode.
        constexpr uint32_t CMD_DIS = (1U << 4);  ///< the bit is used to disable dual edge in CMD phase when ddr mode.
        constexpr uint32_t SPI_SMEM_OUTMINBYTELEN = (7 << 5);  ///< It is the minimum output data length in the ddr psram.
        constexpr uint32_t SPI_SMEM_TX_DDR_MSK_EN = (1U << 12);  ///< Set this bit to mask the first or the last byte in MSPI ECC DDR write mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_RX_DDR_MSK_EN = (1U << 13);  ///< Set this bit to mask the first or the last byte in MSPI ECC DDR read mode, when accesses to external RAM.
        constexpr uint32_t SPI_SMEM_USR_DDR_DQS_THD = (7 << 14);  ///< The delay number of data strobe which from memory based on SPI_CLK.
        constexpr uint32_t DQS_LOOP = (1U << 21);  ///< 1: Use internal signal as data strobe, the strobe can not be delayed by input timing module. 0: Use input SPI_DQS signal from PAD as data strobe, the strobe can be delayed by input timing module
        constexpr uint32_t DQS_LOOP_MODE = (1U << 22);  ///< When SPI_SMEM_DDR_DQS_LOOP and SPI_SMEM_DDR_EN are set, 1: Use internal SPI_CLK as data strobe. 0: Use internal ~SPI_CLK as data strobe. Otherwise this bit is not active.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_EN = (1U << 24);  ///< Set this bit to enable the differential SPI_CLK#.
        constexpr uint32_t SPI_SMEM_HYPERBUS_MODE = (1U << 25);  ///< Set this bit to enable the SPI HyperBus mode.
        constexpr uint32_t SPI_SMEM_DQS_CA_IN = (1U << 26);  ///< Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        constexpr uint32_t SPI_SMEM_HYPERBUS_DUMMY_2X = (1U << 27);  ///< Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses to flash or SPI1 accesses flash or sram.
        constexpr uint32_t SPI_SMEM_CLK_DIFF_INV = (1U << 28);  ///< Set this bit to invert SPI_DIFF when accesses to external RAM. .
        constexpr uint32_t SPI_SMEM_OCTA_RAM_ADDR = (1U << 29);  ///< Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        constexpr uint32_t SPI_SMEM_HYPERBUS_CA = (1U << 30);  ///< Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< Register clock gate enable signal. 1: Enable. 0: Disable.
    }

    /// CORE_CLK_SEL Register bits
    namespace core_clk_sel_bits {
        constexpr uint32_t CORE_CLK_SEL = (2 << 0);  ///< When the digital system clock selects PLL clock and the frequency of PLL clock is 480MHz, the value of SPI_MEM_CORE_CLK_SEL: 0: SPI0/1 module clock (MSPI_CORE_CLK) is 80MHz. 1: MSPI_CORE_CLK is 120MHz. 2: MSPI_CORE_CLK is 160MHz. 3: MSPI_CORE_CLK is 240MHz. When the digital system clock selects PLL clock and the frequency of PLL clock is 320MHz, the value of SPI_MEM_CORE_CLK_SEL: 0: MSPI_CORE_CLK is 80MHz. 1: MSPI_CORE_CLK is 80MHz. 2: MSPI_CORE_CLK 160MHz. 3: Not used.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TOTAL_TRANS_END_INT_ENA = (1U << 2);  ///< The enable bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.
        constexpr uint32_t ECC_ERR_INT_ENA = (1U << 4);  ///< The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TOTAL_TRANS_END_INT_CLR = (1U << 2);  ///< The clear bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.
        constexpr uint32_t ECC_ERR_INT_CLR = (1U << 4);  ///< The clear bit for SPI_MEM_ECC_ERR_INT interrupt. SPI_MEM_ECC_ERR_ADDR and SPI_MEM_ECC_ERR_CNT will be cleared by the pulse of this bit.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TOTAL_TRANS_END_INT_RAW = (1U << 2);  ///< The raw bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt. 1: Triggered when SPI1 transfer is done and flash is already idle. When WRSR/PP/SE/BE/CE is sent and PES/PER command is sent, this bit is set when WRSR/PP/SE/BE/CE is success. 0: Others.
        constexpr uint32_t ECC_ERR_INT_RAW = (1U << 4);  ///< The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When APB_CTRL_FECC_ERR_INT_EN is set and APB_CTRL_SECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than APB_CTRL_ECC_ERR_INT_NUM. When APB_CTRL_FECC_ERR_INT_EN is cleared and APB_CTRL_SECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than APB_CTRL_ECC_ERR_INT_NUM. When APB_CTRL_FECC_ERR_INT_EN and APB_CTRL_SECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than APB_CTRL_ECC_ERR_INT_NUM. When APB_CTRL_FECC_ERR_INT_EN and APB_CTRL_SECC_ERR_INT_EN are cleared, this bit will not be triggered.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TOTAL_TRANS_END_INT_ST = (1U << 2);  ///< The status bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.
        constexpr uint32_t ECC_ERR_INT_ST = (1U << 4);  ///< The status bit for SPI_MEM_ECC_ERR_INT interrupt.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t SPI_SMEM_SPICLK_FUN_DRV = (2 << 0);  ///< The driver of SPI_CLK PAD is controlled by the bits SPI_SMEM_SPICLK_FUN_DRV[1:0] when the bit SPI_SPICLK_PAD_DRV_CTL_EN is set and MSPI accesses to external RAM.
        constexpr uint32_t SPI_FMEM_SPICLK_FUN_DRV = (2 << 2);  ///< The driver of SPI_CLK PAD is controlled by the bits SPI_FMEM_SPICLK_FUN_DRV[1:0] when the bit SPI_SPICLK_PAD_DRV_CTL_EN is set and MSPI accesses to flash.
        constexpr uint32_t SPI_SPICLK_PAD_DRV_CTL_EN = (1U << 4);  ///< SPI_CLK PAD driver control signal. 1: The driver of SPI_CLK PAD is controlled by the bits SPI_FMEM_SPICLK_FUN_DRV[1:0] and SPI_SMEM_SPICLK_FUN_DRV[1:0]. 0: The driver of SPI_CLK PAD is controlled by the bits IO_MUX_FUNC_DRV[1:0] of SPICLK PAD.
        constexpr uint32_t DATE = (23 << 5);  ///< SPI register version.
    }

}

// ============================================================================
// SYSTEM Peripheral
// ============================================================================

namespace system {
    /// Base addresses
    constexpr uint32_t SYSTEM_BASE = 0x600C0000;

    /// SYSTEM Register structure
    struct Registers {
        volatile uint32_t CORE_1_CONTROL_0;  ///< Offset: 0x00 - Core0 control regiter 0
        volatile uint32_t CORE_1_CONTROL_1;  ///< Offset: 0x04 - Core0 control regiter 1
        volatile uint32_t CPU_PERI_CLK_EN;  ///< Offset: 0x08 - cpu_peripheral clock configuration register
        volatile uint32_t CPU_PERI_RST_EN;  ///< Offset: 0x0C - cpu_peripheral reset configuration regsiter
        volatile uint32_t CPU_PER_CONF;  ///< Offset: 0x10 - cpu peripheral clock configuration register
        volatile uint32_t MEM_PD_MASK;  ///< Offset: 0x14 - memory power down mask configuration register
        volatile uint32_t PERIP_CLK_EN0;  ///< Offset: 0x18 - peripheral clock configuration regsiter 0
        volatile uint32_t PERIP_CLK_EN1;  ///< Offset: 0x1C - peripheral clock configuration regsiter 1
        volatile uint32_t PERIP_RST_EN0;  ///< Offset: 0x20 - peripheral reset configuration register0
        volatile uint32_t PERIP_RST_EN1;  ///< Offset: 0x24 - peripheral reset configuration regsiter 1
        volatile uint32_t BT_LPCK_DIV_INT;  ///< Offset: 0x28 - low power clock frequent division factor configuration regsiter
        volatile uint32_t BT_LPCK_DIV_FRAC;  ///< Offset: 0x2C - low power clock configuration register
        volatile uint32_t CPU_INTR_FROM_CPU_0;  ///< Offset: 0x30 - interrupt source register 0
        volatile uint32_t CPU_INTR_FROM_CPU_1;  ///< Offset: 0x34 - interrupt source register 1
        volatile uint32_t CPU_INTR_FROM_CPU_2;  ///< Offset: 0x38 - interrupt source register 2
        volatile uint32_t CPU_INTR_FROM_CPU_3;  ///< Offset: 0x3C - interrupt source register 3
        volatile uint32_t RSA_PD_CTRL;  ///< Offset: 0x40 - rsa memory power control register
        volatile uint32_t EDMA_CTRL;  ///< Offset: 0x44 - EDMA control register
        volatile uint32_t CACHE_CONTROL;  ///< Offset: 0x48 - Cache control register
        volatile uint32_t EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL;  ///< Offset: 0x4C - External memory encrypt and decrypt control register
        volatile uint32_t RTC_FASTMEM_CONFIG;  ///< Offset: 0x50 - RTC fast memory configuration register
        volatile uint32_t RTC_FASTMEM_CRC;  ///< Offset: 0x54 - RTC fast memory CRC control register
        volatile uint32_t REDUNDANT_ECO_CTRL;  ///< Offset: 0x58 - ******* Description ***********
        volatile uint32_t CLOCK_GATE;  ///< Offset: 0x5C - ******* Description ***********
        volatile uint32_t SYSCLK_CONF;  ///< Offset: 0x60 - System clock configuration register.
        volatile uint32_t MEM_PVT;  ///< Offset: 0x64 - ******* Description ***********
        volatile uint32_t COMB_PVT_LVT_CONF;  ///< Offset: 0x68 - ******* Description ***********
        volatile uint32_t COMB_PVT_NVT_CONF;  ///< Offset: 0x6C - ******* Description ***********
        volatile uint32_t COMB_PVT_HVT_CONF;  ///< Offset: 0x70 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_LVT_SITE0;  ///< Offset: 0x74 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_NVT_SITE0;  ///< Offset: 0x78 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_HVT_SITE0;  ///< Offset: 0x7C - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_LVT_SITE1;  ///< Offset: 0x80 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_NVT_SITE1;  ///< Offset: 0x84 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_HVT_SITE1;  ///< Offset: 0x88 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_LVT_SITE2;  ///< Offset: 0x8C - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_NVT_SITE2;  ///< Offset: 0x90 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_HVT_SITE2;  ///< Offset: 0x94 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_LVT_SITE3;  ///< Offset: 0x98 - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_NVT_SITE3;  ///< Offset: 0x9C - ******* Description ***********
        volatile uint32_t COMB_PVT_ERR_HVT_SITE3;  ///< Offset: 0xA0 - ******* Description ***********
        volatile uint32_t DATE;  ///< Offset: 0xFFC - version register
    };

    /// Peripheral instances
    inline Registers* SYSTEM = reinterpret_cast<Registers*>(SYSTEM_BASE);

    // Bit definitions
    /// CORE_1_CONTROL_0 Register bits
    namespace core_1_control_0_bits {
        constexpr uint32_t CONTROL_CORE_1_RUNSTALL = (1U << 0);  ///< Set 1 to stall core1
        constexpr uint32_t CONTROL_CORE_1_CLKGATE_EN = (1U << 1);  ///< Set 1 to open core1 clock
        constexpr uint32_t CONTROL_CORE_1_RESETING = (1U << 2);  ///< Set 1 to let core1 reset
    }

    /// CORE_1_CONTROL_1 Register bits
    namespace core_1_control_1_bits {
        constexpr uint32_t CONTROL_CORE_1_MESSAGE = (32 << 0);  ///< it's only a R/W register, no function, software can write any value
    }

    /// CPU_PERI_CLK_EN Register bits
    namespace cpu_peri_clk_en_bits {
        constexpr uint32_t CLK_EN_ASSIST_DEBUG = (1U << 6);  ///< Set 1 to open assist_debug module clock
        constexpr uint32_t CLK_EN_DEDICATED_GPIO = (1U << 7);  ///< Set 1 to open dedicated_gpio module clk
    }

    /// CPU_PERI_RST_EN Register bits
    namespace cpu_peri_rst_en_bits {
        constexpr uint32_t RST_EN_ASSIST_DEBUG = (1U << 6);  ///< Set 1 to let assist_debug module reset
        constexpr uint32_t RST_EN_DEDICATED_GPIO = (1U << 7);  ///< Set 1 to let dedicated_gpio module reset
    }

    /// CPU_PER_CONF Register bits
    namespace cpu_per_conf_bits {
        constexpr uint32_t CPUPERIOD_SEL = (2 << 0);  ///< This field used to sel cpu clock frequent.
        constexpr uint32_t PLL_FREQ_SEL = (1U << 2);  ///< This field used to sel pll frequent.
        constexpr uint32_t CPU_WAIT_MODE_FORCE_ON = (1U << 3);  ///< Set 1 to force cpu_waiti_clk enable.
        constexpr uint32_t CPU_WAITI_DELAY_NUM = (4 << 4);  ///< This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
    }

    /// MEM_PD_MASK Register bits
    namespace mem_pd_mask_bits {
        constexpr uint32_t LSLP_MEM_PD_MASK = (1U << 0);  ///< Set 1 to mask memory power down.
    }

    /// PERIP_CLK_EN0 Register bits
    namespace perip_clk_en0_bits {
        constexpr uint32_t TIMERS_CLK_EN = (1U << 0);  ///< Set 1 to enable TIMERS clock
        constexpr uint32_t SPI01_CLK_EN = (1U << 1);  ///< Set 1 to enable SPI01 clock
        constexpr uint32_t UART_CLK_EN = (1U << 2);  ///< Set 1 to enable UART clock
        constexpr uint32_t WDG_CLK_EN = (1U << 3);  ///< Set 1 to enable WDG clock
        constexpr uint32_t I2S0_CLK_EN = (1U << 4);  ///< Set 1 to enable I2S0 clock
        constexpr uint32_t UART1_CLK_EN = (1U << 5);  ///< Set 1 to enable UART1 clock
        constexpr uint32_t SPI2_CLK_EN = (1U << 6);  ///< Set 1 to enable SPI2 clock
        constexpr uint32_t I2C_EXT0_CLK_EN = (1U << 7);  ///< Set 1 to enable I2C_EXT0 clock
        constexpr uint32_t UHCI0_CLK_EN = (1U << 8);  ///< Set 1 to enable UHCI0 clock
        constexpr uint32_t RMT_CLK_EN = (1U << 9);  ///< Set 1 to enable RMT clock
        constexpr uint32_t PCNT_CLK_EN = (1U << 10);  ///< Set 1 to enable PCNT clock
        constexpr uint32_t LEDC_CLK_EN = (1U << 11);  ///< Set 1 to enable LEDC clock
        constexpr uint32_t UHCI1_CLK_EN = (1U << 12);  ///< Set 1 to enable UHCI1 clock
        constexpr uint32_t TIMERGROUP_CLK_EN = (1U << 13);  ///< Set 1 to enable TIMERGROUP clock
        constexpr uint32_t EFUSE_CLK_EN = (1U << 14);  ///< Set 1 to enable EFUSE clock
        constexpr uint32_t TIMERGROUP1_CLK_EN = (1U << 15);  ///< Set 1 to enable TIMERGROUP1 clock
        constexpr uint32_t SPI3_CLK_EN = (1U << 16);  ///< Set 1 to enable SPI3 clock
        constexpr uint32_t PWM0_CLK_EN = (1U << 17);  ///< Set 1 to enable PWM0 clock
        constexpr uint32_t I2C_EXT1_CLK_EN = (1U << 18);  ///< Set 1 to enable I2C_EXT1 clock
        constexpr uint32_t TWAI_CLK_EN = (1U << 19);  ///< Set 1 to enable CAN clock
        constexpr uint32_t PWM1_CLK_EN = (1U << 20);  ///< Set 1 to enable PWM1 clock
        constexpr uint32_t I2S1_CLK_EN = (1U << 21);  ///< Set 1 to enable I2S1 clock
        constexpr uint32_t SPI2_DMA_CLK_EN = (1U << 22);  ///< Set 1 to enable SPI2_DMA clock
        constexpr uint32_t USB_CLK_EN = (1U << 23);  ///< Set 1 to enable USB clock
        constexpr uint32_t UART_MEM_CLK_EN = (1U << 24);  ///< Set 1 to enable UART_MEM clock
        constexpr uint32_t PWM2_CLK_EN = (1U << 25);  ///< Set 1 to enable PWM2 clock
        constexpr uint32_t PWM3_CLK_EN = (1U << 26);  ///< Set 1 to enable PWM3 clock
        constexpr uint32_t SPI3_DMA_CLK_EN = (1U << 27);  ///< Set 1 to enable SPI4 clock
        constexpr uint32_t APB_SARADC_CLK_EN = (1U << 28);  ///< Set 1 to enable APB_SARADC clock
        constexpr uint32_t SYSTIMER_CLK_EN = (1U << 29);  ///< Set 1 to enable SYSTEMTIMER clock
        constexpr uint32_t ADC2_ARB_CLK_EN = (1U << 30);  ///< Set 1 to enable ADC2_ARB clock
        constexpr uint32_t SPI4_CLK_EN = (1U << 31);  ///< Set 1 to enable SPI4 clock
    }

    /// PERIP_CLK_EN1 Register bits
    namespace perip_clk_en1_bits {
        constexpr uint32_t PERI_BACKUP_CLK_EN = (1U << 0);  ///< Set 1 to enable BACKUP clock
        constexpr uint32_t CRYPTO_AES_CLK_EN = (1U << 1);  ///< Set 1 to enable AES clock
        constexpr uint32_t CRYPTO_SHA_CLK_EN = (1U << 2);  ///< Set 1 to enable SHA clock
        constexpr uint32_t CRYPTO_RSA_CLK_EN = (1U << 3);  ///< Set 1 to enable RSA clock
        constexpr uint32_t CRYPTO_DS_CLK_EN = (1U << 4);  ///< Set 1 to enable DS clock
        constexpr uint32_t CRYPTO_HMAC_CLK_EN = (1U << 5);  ///< Set 1 to enable HMAC clock
        constexpr uint32_t DMA_CLK_EN = (1U << 6);  ///< Set 1 to enable DMA clock
        constexpr uint32_t SDIO_HOST_CLK_EN = (1U << 7);  ///< Set 1 to enable SDIO_HOST clock
        constexpr uint32_t LCD_CAM_CLK_EN = (1U << 8);  ///< Set 1 to enable LCD_CAM clock
        constexpr uint32_t UART2_CLK_EN = (1U << 9);  ///< Set 1 to enable UART2 clock
        constexpr uint32_t USB_DEVICE_CLK_EN = (1U << 10);  ///< Set 1 to enable USB_DEVICE clock
    }

    /// PERIP_RST_EN0 Register bits
    namespace perip_rst_en0_bits {
        constexpr uint32_t TIMERS_RST = (1U << 0);  ///< Set 1 to let TIMERS reset
        constexpr uint32_t SPI01_RST = (1U << 1);  ///< Set 1 to let SPI01 reset
        constexpr uint32_t UART_RST = (1U << 2);  ///< Set 1 to let UART reset
        constexpr uint32_t WDG_RST = (1U << 3);  ///< Set 1 to let WDG reset
        constexpr uint32_t I2S0_RST = (1U << 4);  ///< Set 1 to let I2S0 reset
        constexpr uint32_t UART1_RST = (1U << 5);  ///< Set 1 to let UART1 reset
        constexpr uint32_t SPI2_RST = (1U << 6);  ///< Set 1 to let SPI2 reset
        constexpr uint32_t I2C_EXT0_RST = (1U << 7);  ///< Set 1 to let I2C_EXT0 reset
        constexpr uint32_t UHCI0_RST = (1U << 8);  ///< Set 1 to let UHCI0 reset
        constexpr uint32_t RMT_RST = (1U << 9);  ///< Set 1 to let RMT reset
        constexpr uint32_t PCNT_RST = (1U << 10);  ///< Set 1 to let PCNT reset
        constexpr uint32_t LEDC_RST = (1U << 11);  ///< Set 1 to let LEDC reset
        constexpr uint32_t UHCI1_RST = (1U << 12);  ///< Set 1 to let UHCI1 reset
        constexpr uint32_t TIMERGROUP_RST = (1U << 13);  ///< Set 1 to let TIMERGROUP reset
        constexpr uint32_t EFUSE_RST = (1U << 14);  ///< Set 1 to let EFUSE reset
        constexpr uint32_t TIMERGROUP1_RST = (1U << 15);  ///< Set 1 to let TIMERGROUP1 reset
        constexpr uint32_t SPI3_RST = (1U << 16);  ///< Set 1 to let SPI3 reset
        constexpr uint32_t PWM0_RST = (1U << 17);  ///< Set 1 to let PWM0 reset
        constexpr uint32_t I2C_EXT1_RST = (1U << 18);  ///< Set 1 to let I2C_EXT1 reset
        constexpr uint32_t TWAI_RST = (1U << 19);  ///< Set 1 to let CAN reset
        constexpr uint32_t PWM1_RST = (1U << 20);  ///< Set 1 to let PWM1 reset
        constexpr uint32_t I2S1_RST = (1U << 21);  ///< Set 1 to let I2S1 reset
        constexpr uint32_t SPI2_DMA_RST = (1U << 22);  ///< Set 1 to let SPI2 reset
        constexpr uint32_t USB_RST = (1U << 23);  ///< Set 1 to let USB reset
        constexpr uint32_t UART_MEM_RST = (1U << 24);  ///< Set 1 to let UART_MEM reset
        constexpr uint32_t PWM2_RST = (1U << 25);  ///< Set 1 to let PWM2 reset
        constexpr uint32_t PWM3_RST = (1U << 26);  ///< Set 1 to let PWM3 reset
        constexpr uint32_t SPI3_DMA_RST = (1U << 27);  ///< Set 1 to let SPI3 reset
        constexpr uint32_t APB_SARADC_RST = (1U << 28);  ///< Set 1 to let APB_SARADC reset
        constexpr uint32_t SYSTIMER_RST = (1U << 29);  ///< Set 1 to let SYSTIMER reset
        constexpr uint32_t ADC2_ARB_RST = (1U << 30);  ///< Set 1 to let ADC2_ARB reset
        constexpr uint32_t SPI4_RST = (1U << 31);  ///< Set 1 to let SPI4 reset
    }

    /// PERIP_RST_EN1 Register bits
    namespace perip_rst_en1_bits {
        constexpr uint32_t PERI_BACKUP_RST = (1U << 0);  ///< Set 1 to let BACKUP reset
        constexpr uint32_t CRYPTO_AES_RST = (1U << 1);  ///< Set 1 to let CRYPTO_AES reset
        constexpr uint32_t CRYPTO_SHA_RST = (1U << 2);  ///< Set 1 to let CRYPTO_SHA reset
        constexpr uint32_t CRYPTO_RSA_RST = (1U << 3);  ///< Set 1 to let CRYPTO_RSA reset
        constexpr uint32_t CRYPTO_DS_RST = (1U << 4);  ///< Set 1 to let CRYPTO_DS reset
        constexpr uint32_t CRYPTO_HMAC_RST = (1U << 5);  ///< Set 1 to let CRYPTO_HMAC reset
        constexpr uint32_t DMA_RST = (1U << 6);  ///< Set 1 to let DMA reset
        constexpr uint32_t SDIO_HOST_RST = (1U << 7);  ///< Set 1 to let SDIO_HOST reset
        constexpr uint32_t LCD_CAM_RST = (1U << 8);  ///< Set 1 to let LCD_CAM reset
        constexpr uint32_t UART2_RST = (1U << 9);  ///< Set 1 to let UART2 reset
        constexpr uint32_t USB_DEVICE_RST = (1U << 10);  ///< Set 1 to let USB_DEVICE reset
    }

    /// BT_LPCK_DIV_INT Register bits
    namespace bt_lpck_div_int_bits {
        constexpr uint32_t BT_LPCK_DIV_NUM = (12 << 0);  ///< This field is lower power clock frequent division factor
    }

    /// BT_LPCK_DIV_FRAC Register bits
    namespace bt_lpck_div_frac_bits {
        constexpr uint32_t BT_LPCK_DIV_B = (12 << 0);  ///< This field is lower power clock frequent division factor b
        constexpr uint32_t BT_LPCK_DIV_A = (12 << 12);  ///< This field is lower power clock frequent division factor a
        constexpr uint32_t LPCLK_SEL_RTC_SLOW = (1U << 24);  ///< Set 1 to select rtc-slow clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_8M = (1U << 25);  ///< Set 1 to select 8m clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_XTAL = (1U << 26);  ///< Set 1 to select xtal clock as rtc low power clock
        constexpr uint32_t LPCLK_SEL_XTAL32K = (1U << 27);  ///< Set 1 to select xtal32k clock as low power clock
        constexpr uint32_t LPCLK_RTC_EN = (1U << 28);  ///< Set 1 to enable RTC low power clock
    }

    /// CPU_INTR_FROM_CPU_0 Register bits
    namespace cpu_intr_from_cpu_0_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_0 = (1U << 0);  ///< Set 1 to generate cpu interrupt 0
    }

    /// CPU_INTR_FROM_CPU_1 Register bits
    namespace cpu_intr_from_cpu_1_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_1 = (1U << 0);  ///< Set 1 to generate cpu interrupt 1
    }

    /// CPU_INTR_FROM_CPU_2 Register bits
    namespace cpu_intr_from_cpu_2_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_2 = (1U << 0);  ///< Set 1 to generate cpu interrupt 2
    }

    /// CPU_INTR_FROM_CPU_3 Register bits
    namespace cpu_intr_from_cpu_3_bits {
        constexpr uint32_t CPU_INTR_FROM_CPU_3 = (1U << 0);  ///< Set 1 to generate cpu interrupt 3
    }

    /// RSA_PD_CTRL Register bits
    namespace rsa_pd_ctrl_bits {
        constexpr uint32_t RSA_MEM_PD = (1U << 0);  ///< Set 1 to power down RSA memory. This bit has the lowest priority.When Digital Signature occupies the RSA, this bit is invalid.
        constexpr uint32_t RSA_MEM_FORCE_PU = (1U << 1);  ///< Set 1 to force power up RSA memory, this bit has the second highest priority.
        constexpr uint32_t RSA_MEM_FORCE_PD = (1U << 2);  ///< Set 1 to force power down RSA memory,this bit has the highest priority.
    }

    /// EDMA_CTRL Register bits
    namespace edma_ctrl_bits {
        constexpr uint32_t EDMA_CLK_ON = (1U << 0);  ///< Set 1 to enable EDMA clock.
        constexpr uint32_t EDMA_RESET = (1U << 1);  ///< Set 1 to let EDMA reset
    }

    /// CACHE_CONTROL Register bits
    namespace cache_control_bits {
        constexpr uint32_t ICACHE_CLK_ON = (1U << 0);  ///< Set 1 to enable icache clock
        constexpr uint32_t ICACHE_RESET = (1U << 1);  ///< Set 1 to let icache reset
        constexpr uint32_t DCACHE_CLK_ON = (1U << 2);  ///< Set 1 to enable dcache clock
        constexpr uint32_t DCACHE_RESET = (1U << 3);  ///< Set 1 to let dcache reset
    }

    /// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL Register bits
    namespace external_device_encrypt_decrypt_control_bits {
        constexpr uint32_t ENABLE_SPI_MANUAL_ENCRYPT = (1U << 0);  ///< Set 1 to enable the SPI manual encrypt.
        constexpr uint32_t ENABLE_DOWNLOAD_DB_ENCRYPT = (1U << 1);  ///< Set 1 to enable download DB encrypt.
        constexpr uint32_t ENABLE_DOWNLOAD_G0CB_DECRYPT = (1U << 2);  ///< Set 1 to enable download G0CB decrypt
        constexpr uint32_t ENABLE_DOWNLOAD_MANUAL_ENCRYPT = (1U << 3);  ///< Set 1 to enable download manual encrypt
    }

    /// RTC_FASTMEM_CONFIG Register bits
    namespace rtc_fastmem_config_bits {
        constexpr uint32_t RTC_MEM_CRC_START = (1U << 8);  ///< Set 1 to start the CRC of RTC memory
        constexpr uint32_t RTC_MEM_CRC_ADDR = (11 << 9);  ///< This field is used to set address of RTC memory for CRC.
        constexpr uint32_t RTC_MEM_CRC_LEN = (11 << 20);  ///< This field is used to set length of RTC memory for CRC based on start address.
        constexpr uint32_t RTC_MEM_CRC_FINISH = (1U << 31);  ///< This bit stores the status of RTC memory CRC.1 means finished.
    }

    /// RTC_FASTMEM_CRC Register bits
    namespace rtc_fastmem_crc_bits {
        constexpr uint32_t RTC_MEM_CRC_RES = (32 << 0);  ///< This field stores the CRC result of RTC memory.
    }

    /// REDUNDANT_ECO_CTRL Register bits
    namespace redundant_eco_ctrl_bits {
        constexpr uint32_t REDUNDANT_ECO_DRIVE = (1U << 0);  ///< ******* Description ***********
        constexpr uint32_t REDUNDANT_ECO_RESULT = (1U << 1);  ///< ******* Description ***********
    }

    /// CLOCK_GATE Register bits
    namespace clock_gate_bits {
        constexpr uint32_t CLK_EN = (1U << 0);  ///< ******* Description ***********
    }

    /// SYSCLK_CONF Register bits
    namespace sysclk_conf_bits {
        constexpr uint32_t PRE_DIV_CNT = (10 << 0);  ///< This field is used to set the count of prescaler of XTAL_CLK.
        constexpr uint32_t SOC_CLK_SEL = (2 << 10);  ///< This field is used to select soc clock.
        constexpr uint32_t CLK_XTAL_FREQ = (7 << 12);  ///< This field is used to read xtal frequency in MHz.
        constexpr uint32_t CLK_DIV_EN = (1U << 19);  ///< Reserved.
    }

    /// MEM_PVT Register bits
    namespace mem_pvt_bits {
        constexpr uint32_t MEM_PATH_LEN = (4 << 0);  ///< ******* Description ***********
        constexpr uint32_t MEM_ERR_CNT_CLR = (1U << 4);  ///< ******* Description ***********
        constexpr uint32_t MONITOR_EN = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t MEM_TIMING_ERR_CNT = (16 << 6);  ///< ******* Description ***********
        constexpr uint32_t MEM_VT_SEL = (2 << 22);  ///< ******* Description ***********
    }

    /// COMB_PVT_LVT_CONF Register bits
    namespace comb_pvt_lvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_LVT = (5 << 0);  ///< ******* Description ***********
        constexpr uint32_t COMB_ERR_CNT_CLR_LVT = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t COMB_PVT_MONITOR_EN_LVT = (1U << 6);  ///< ******* Description ***********
    }

    /// COMB_PVT_NVT_CONF Register bits
    namespace comb_pvt_nvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_NVT = (5 << 0);  ///< ******* Description ***********
        constexpr uint32_t COMB_ERR_CNT_CLR_NVT = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t COMB_PVT_MONITOR_EN_NVT = (1U << 6);  ///< ******* Description ***********
    }

    /// COMB_PVT_HVT_CONF Register bits
    namespace comb_pvt_hvt_conf_bits {
        constexpr uint32_t COMB_PATH_LEN_HVT = (5 << 0);  ///< ******* Description ***********
        constexpr uint32_t COMB_ERR_CNT_CLR_HVT = (1U << 5);  ///< ******* Description ***********
        constexpr uint32_t COMB_PVT_MONITOR_EN_HVT = (1U << 6);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_LVT_SITE0 Register bits
    namespace comb_pvt_err_lvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE0 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_NVT_SITE0 Register bits
    namespace comb_pvt_err_nvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE0 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_HVT_SITE0 Register bits
    namespace comb_pvt_err_hvt_site0_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE0 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_LVT_SITE1 Register bits
    namespace comb_pvt_err_lvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE1 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_NVT_SITE1 Register bits
    namespace comb_pvt_err_nvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE1 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_HVT_SITE1 Register bits
    namespace comb_pvt_err_hvt_site1_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE1 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_LVT_SITE2 Register bits
    namespace comb_pvt_err_lvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE2 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_NVT_SITE2 Register bits
    namespace comb_pvt_err_nvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE2 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_HVT_SITE2 Register bits
    namespace comb_pvt_err_hvt_site2_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE2 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_LVT_SITE3 Register bits
    namespace comb_pvt_err_lvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_LVT_SITE3 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_NVT_SITE3 Register bits
    namespace comb_pvt_err_nvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_NVT_SITE3 = (16 << 0);  ///< ******* Description ***********
    }

    /// COMB_PVT_ERR_HVT_SITE3 Register bits
    namespace comb_pvt_err_hvt_site3_bits {
        constexpr uint32_t COMB_TIMING_ERR_CNT_HVT_SITE3 = (16 << 0);  ///< ******* Description ***********
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (28 << 0);  ///< version register
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t SYSTIMER_BASE = 0x60023000;
    constexpr uint32_t TIMG0_BASE = 0x6001F000;
    constexpr uint32_t TIMG1_BASE = 0x60020000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t CONF;  ///< Offset: 0x00 - Configure system timer clock
        volatile uint32_t UNIT0_OP;  ///< Offset: 0x04 - system timer unit0 value update register
        volatile uint32_t UNIT1_OP;  ///< Offset: 0x08 - system timer unit1 value update register
        volatile uint32_t UNIT0_LOAD_HI;  ///< Offset: 0x0C - system timer unit0 value high load register
        volatile uint32_t UNIT0_LOAD_LO;  ///< Offset: 0x10 - system timer unit0 value low load register
        volatile uint32_t UNIT1_LOAD_HI;  ///< Offset: 0x14 - system timer unit1 value high load register
        volatile uint32_t UNIT1_LOAD_LO;  ///< Offset: 0x18 - system timer unit1 value low load register
        volatile uint32_t TARGET0_HI;  ///< Offset: 0x1C - system timer comp0 value high register
        volatile uint32_t TARGET0_LO;  ///< Offset: 0x20 - system timer comp0 value low register
        volatile uint32_t TARGET1_HI;  ///< Offset: 0x24 - system timer comp1 value high register
        volatile uint32_t TARGET1_LO;  ///< Offset: 0x28 - system timer comp1 value low register
        volatile uint32_t TARGET2_HI;  ///< Offset: 0x2C - system timer comp2 value high register
        volatile uint32_t TARGET2_LO;  ///< Offset: 0x30 - system timer comp2 value low register
        volatile uint32_t TARGET0_CONF;  ///< Offset: 0x34 - system timer comp0 target mode register
        volatile uint32_t TARGET1_CONF;  ///< Offset: 0x38 - system timer comp1 target mode register
        volatile uint32_t TARGET2_CONF;  ///< Offset: 0x3C - system timer comp2 target mode register
        volatile uint32_t UNIT0_VALUE_HI;  ///< Offset: 0x40 - system timer unit0 value high register
        volatile uint32_t UNIT0_VALUE_LO;  ///< Offset: 0x44 - system timer unit0 value low register
        volatile uint32_t UNIT1_VALUE_HI;  ///< Offset: 0x48 - system timer unit1 value high register
        volatile uint32_t UNIT1_VALUE_LO;  ///< Offset: 0x4C - system timer unit1 value low register
        volatile uint32_t COMP0_LOAD;  ///< Offset: 0x50 - system timer comp0 conf sync register
        volatile uint32_t COMP1_LOAD;  ///< Offset: 0x54 - system timer comp1 conf sync register
        volatile uint32_t COMP2_LOAD;  ///< Offset: 0x58 - system timer comp2 conf sync register
        volatile uint32_t UNIT0_LOAD;  ///< Offset: 0x5C - system timer unit0 conf sync register
        volatile uint32_t UNIT1_LOAD;  ///< Offset: 0x60 - system timer unit1 conf sync register
        volatile uint32_t INT_ENA;  ///< Offset: 0x64 - systimer interrupt enable register
        volatile uint32_t INT_RAW;  ///< Offset: 0x68 - systimer interrupt raw register
        volatile uint32_t INT_CLR;  ///< Offset: 0x6C - systimer interrupt clear register
        volatile uint32_t INT_ST;  ///< Offset: 0x70 - systimer interrupt status register
        volatile uint32_t REAL_TARGET0_LO;  ///< Offset: 0x74 - system timer comp0 actual target value low register
        volatile uint32_t REAL_TARGET0_HI;  ///< Offset: 0x78 - system timer comp0 actual target value high register
        volatile uint32_t REAL_TARGET1_LO;  ///< Offset: 0x7C - system timer comp1 actual target value low register
        volatile uint32_t REAL_TARGET1_HI;  ///< Offset: 0x80 - system timer comp1 actual target value high register
        volatile uint32_t REAL_TARGET2_LO;  ///< Offset: 0x84 - system timer comp2 actual target value low register
        volatile uint32_t REAL_TARGET2_HI;  ///< Offset: 0x88 - system timer comp2 actual target value high register
        volatile uint32_t DATE;  ///< Offset: 0xFC - system timer version control register
    };

    /// Peripheral instances
    inline Registers* SYSTIMER = reinterpret_cast<Registers*>(SYSTIMER_BASE);
    inline Registers* TIMG0 = reinterpret_cast<Registers*>(TIMG0_BASE);
    inline Registers* TIMG1 = reinterpret_cast<Registers*>(TIMG1_BASE);

    // Bit definitions
    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t SYSTIMER_CLK_FO = (1U << 0);  ///< systimer clock force on
        constexpr uint32_t TARGET2_WORK_EN = (1U << 22);  ///< target2 work enable
        constexpr uint32_t TARGET1_WORK_EN = (1U << 23);  ///< target1 work enable
        constexpr uint32_t TARGET0_WORK_EN = (1U << 24);  ///< target0 work enable
        constexpr uint32_t TIMER_UNIT1_CORE1_STALL_EN = (1U << 25);  ///< If timer unit1 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT1_CORE0_STALL_EN = (1U << 26);  ///< If timer unit1 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT0_CORE1_STALL_EN = (1U << 27);  ///< If timer unit0 is stalled when core1 stalled
        constexpr uint32_t TIMER_UNIT0_CORE0_STALL_EN = (1U << 28);  ///< If timer unit0 is stalled when core0 stalled
        constexpr uint32_t TIMER_UNIT1_WORK_EN = (1U << 29);  ///< timer unit1 work enable
        constexpr uint32_t TIMER_UNIT0_WORK_EN = (1U << 30);  ///< timer unit0 work enable
        constexpr uint32_t CLK_EN = (1U << 31);  ///< register file clk gating
    }

    /// UNIT0_OP Register bits
    namespace unit0_op_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_VALID = (1U << 29);  ///< timer value is sync and valid
        constexpr uint32_t TIMER_UNIT0_UPDATE = (1U << 30);  ///< update timer_unit0
    }

    /// UNIT1_OP Register bits
    namespace unit1_op_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_VALID = (1U << 29);  ///< timer value is sync and valid
        constexpr uint32_t TIMER_UNIT1_UPDATE = (1U << 30);  ///< update timer unit1
    }

    /// UNIT0_LOAD_HI Register bits
    namespace unit0_load_hi_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_HI = (20 << 0);  ///< timer unit0 load high 20 bits
    }

    /// UNIT0_LOAD_LO Register bits
    namespace unit0_load_lo_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD_LO = (32 << 0);  ///< timer unit0 load low 32 bits
    }

    /// UNIT1_LOAD_HI Register bits
    namespace unit1_load_hi_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_HI = (20 << 0);  ///< timer unit1 load high 20 bits
    }

    /// UNIT1_LOAD_LO Register bits
    namespace unit1_load_lo_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD_LO = (32 << 0);  ///< timer unit1 load low 32 bits
    }

    /// TARGET0_HI Register bits
    namespace target0_hi_bits {
        constexpr uint32_t TIMER_TARGET0_HI = (20 << 0);  ///< timer taget0 high 20 bits
    }

    /// TARGET0_LO Register bits
    namespace target0_lo_bits {
        constexpr uint32_t TIMER_TARGET0_LO = (32 << 0);  ///< timer taget0 low 32 bits
    }

    /// TARGET1_HI Register bits
    namespace target1_hi_bits {
        constexpr uint32_t TIMER_TARGET1_HI = (20 << 0);  ///< timer taget1 high 20 bits
    }

    /// TARGET1_LO Register bits
    namespace target1_lo_bits {
        constexpr uint32_t TIMER_TARGET1_LO = (32 << 0);  ///< timer taget1 low 32 bits
    }

    /// TARGET2_HI Register bits
    namespace target2_hi_bits {
        constexpr uint32_t TIMER_TARGET2_HI = (20 << 0);  ///< timer taget2 high 20 bits
    }

    /// TARGET2_LO Register bits
    namespace target2_lo_bits {
        constexpr uint32_t TIMER_TARGET2_LO = (32 << 0);  ///< timer taget2 low 32 bits
    }

    /// TARGET0_CONF Register bits
    namespace target0_conf_bits {
        constexpr uint32_t TARGET0_PERIOD = (26 << 0);  ///< target0 period
        constexpr uint32_t TARGET0_PERIOD_MODE = (1U << 30);  ///< Set target0 to period mode
        constexpr uint32_t TARGET0_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET1_CONF Register bits
    namespace target1_conf_bits {
        constexpr uint32_t TARGET1_PERIOD = (26 << 0);  ///< target1 period
        constexpr uint32_t TARGET1_PERIOD_MODE = (1U << 30);  ///< Set target1 to period mode
        constexpr uint32_t TARGET1_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// TARGET2_CONF Register bits
    namespace target2_conf_bits {
        constexpr uint32_t TARGET2_PERIOD = (26 << 0);  ///< target2 period
        constexpr uint32_t TARGET2_PERIOD_MODE = (1U << 30);  ///< Set target2 to period mode
        constexpr uint32_t TARGET2_TIMER_UNIT_SEL = (1U << 31);  ///< select which unit to compare
    }

    /// UNIT0_VALUE_HI Register bits
    namespace unit0_value_hi_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_HI = (20 << 0);  ///< timer read value high 20bits
    }

    /// UNIT0_VALUE_LO Register bits
    namespace unit0_value_lo_bits {
        constexpr uint32_t TIMER_UNIT0_VALUE_LO = (32 << 0);  ///< timer read value low 32bits
    }

    /// UNIT1_VALUE_HI Register bits
    namespace unit1_value_hi_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_HI = (20 << 0);  ///< timer read value high 20bits
    }

    /// UNIT1_VALUE_LO Register bits
    namespace unit1_value_lo_bits {
        constexpr uint32_t TIMER_UNIT1_VALUE_LO = (32 << 0);  ///< timer read value low 32bits
    }

    /// COMP0_LOAD Register bits
    namespace comp0_load_bits {
        constexpr uint32_t TIMER_COMP0_LOAD = (1U << 0);  ///< timer comp0 sync enable signal
    }

    /// COMP1_LOAD Register bits
    namespace comp1_load_bits {
        constexpr uint32_t TIMER_COMP1_LOAD = (1U << 0);  ///< timer comp1 sync enable signal
    }

    /// COMP2_LOAD Register bits
    namespace comp2_load_bits {
        constexpr uint32_t TIMER_COMP2_LOAD = (1U << 0);  ///< timer comp2 sync enable signal
    }

    /// UNIT0_LOAD Register bits
    namespace unit0_load_bits {
        constexpr uint32_t TIMER_UNIT0_LOAD = (1U << 0);  ///< timer unit0 sync enable signal
    }

    /// UNIT1_LOAD Register bits
    namespace unit1_load_bits {
        constexpr uint32_t TIMER_UNIT1_LOAD = (1U << 0);  ///< timer unit1 sync enable signal
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t TARGET0_INT_ENA = (1U << 0);  ///< interupt0 enable
        constexpr uint32_t TARGET1_INT_ENA = (1U << 1);  ///< interupt1 enable
        constexpr uint32_t TARGET2_INT_ENA = (1U << 2);  ///< interupt2 enable
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t TARGET0_INT_RAW = (1U << 0);  ///< interupt0 raw
        constexpr uint32_t TARGET1_INT_RAW = (1U << 1);  ///< interupt1 raw
        constexpr uint32_t TARGET2_INT_RAW = (1U << 2);  ///< interupt2 raw
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t TARGET0_INT_CLR = (1U << 0);  ///< interupt0 clear
        constexpr uint32_t TARGET1_INT_CLR = (1U << 1);  ///< interupt1 clear
        constexpr uint32_t TARGET2_INT_CLR = (1U << 2);  ///< interupt2 clear
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t TARGET0_INT_ST = (1U << 0);  ///< interupt0 status
        constexpr uint32_t TARGET1_INT_ST = (1U << 1);  ///< interupt1 status
        constexpr uint32_t TARGET2_INT_ST = (1U << 2);  ///< interupt2 status
    }

    /// REAL_TARGET0_LO Register bits
    namespace real_target0_lo_bits {
        constexpr uint32_t TARGET0_LO_RO = (32 << 0);  ///< actual target value value low 32bits
    }

    /// REAL_TARGET0_HI Register bits
    namespace real_target0_hi_bits {
        constexpr uint32_t TARGET0_HI_RO = (20 << 0);  ///< actual target value value high 20bits
    }

    /// REAL_TARGET1_LO Register bits
    namespace real_target1_lo_bits {
        constexpr uint32_t TARGET1_LO_RO = (32 << 0);  ///< actual target value value low 32bits
    }

    /// REAL_TARGET1_HI Register bits
    namespace real_target1_hi_bits {
        constexpr uint32_t TARGET1_HI_RO = (20 << 0);  ///< actual target value value high 20bits
    }

    /// REAL_TARGET2_LO Register bits
    namespace real_target2_lo_bits {
        constexpr uint32_t TARGET2_LO_RO = (32 << 0);  ///< actual target value value low 32bits
    }

    /// REAL_TARGET2_HI Register bits
    namespace real_target2_hi_bits {
        constexpr uint32_t TARGET2_HI_RO = (20 << 0);  ///< actual target value value high 20bits
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< systimer register version
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t TWAI0_BASE = 0x6002B000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MODE;  ///< Offset: 0x00 - Mode Register
        volatile uint32_t CMD;  ///< Offset: 0x04 - Command Register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t INT_RAW;  ///< Offset: 0x0C - Interrupt Register
        volatile uint32_t INT_ENA;  ///< Offset: 0x10 - Interrupt Enable Register
        volatile uint32_t BUS_TIMING_0;  ///< Offset: 0x18 - Bus Timing Register 0
        volatile uint32_t BUS_TIMING_1;  ///< Offset: 0x1C - Bus Timing Register 1
        volatile uint32_t ARB_LOST_CAP;  ///< Offset: 0x2C - Arbitration Lost Capture Register
        volatile uint32_t ERR_CODE_CAP;  ///< Offset: 0x30 - Error Code Capture Register
        volatile uint32_t ERR_WARNING_LIMIT;  ///< Offset: 0x34 - Error Warning Limit Register
        volatile uint32_t RX_ERR_CNT;  ///< Offset: 0x38 - Receive Error Counter Register
        volatile uint32_t TX_ERR_CNT;  ///< Offset: 0x3C - Transmit Error Counter Register
        volatile uint32_t DATA_0;  ///< Offset: 0x40 - Data register 0
        volatile uint32_t DATA_1;  ///< Offset: 0x44 - Data register 1
        volatile uint32_t DATA_2;  ///< Offset: 0x48 - Data register 2
        volatile uint32_t DATA_3;  ///< Offset: 0x4C - Data register 3
        volatile uint32_t DATA_4;  ///< Offset: 0x50 - Data register 4
        volatile uint32_t DATA_5;  ///< Offset: 0x54 - Data register 5
        volatile uint32_t DATA_6;  ///< Offset: 0x58 - Data register 6
        volatile uint32_t DATA_7;  ///< Offset: 0x5C - Data register 7
        volatile uint32_t DATA_8;  ///< Offset: 0x60 - Data register 8
        volatile uint32_t DATA_9;  ///< Offset: 0x64 - Data register 9
        volatile uint32_t DATA_10;  ///< Offset: 0x68 - Data register 10
        volatile uint32_t DATA_11;  ///< Offset: 0x6C - Data register 11
        volatile uint32_t DATA_12;  ///< Offset: 0x70 - Data register 12
        volatile uint32_t RX_MESSAGE_CNT;  ///< Offset: 0x74 - Receive Message Counter Register
        volatile uint32_t CLOCK_DIVIDER;  ///< Offset: 0x7C - Clock Divider register
    };

    /// Peripheral instances
    inline Registers* TWAI0 = reinterpret_cast<Registers*>(TWAI0_BASE);

    // Bit definitions
    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t RESET_MODE = (1U << 0);  ///< This bit is used to configure the operating mode of the TWAI Controller. 1: Reset mode; 0: Operating mode.
        constexpr uint32_t LISTEN_ONLY_MODE = (1U << 1);  ///< 1: Listen only mode. In this mode the nodes will only receive messages from the bus, without generating the acknowledge signal nor updating the RX error counter.
        constexpr uint32_t SELF_TEST_MODE = (1U << 2);  ///< 1: Self test mode. In this mode the TX nodes can perform a successful transmission without receiving the acknowledge signal. This mode is often used to test a single node with the self reception request command.
        constexpr uint32_t RX_FILTER_MODE = (1U << 3);  ///< This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single filter mode.
    }

    /// CMD Register bits
    namespace cmd_bits {
        constexpr uint32_t TX_REQ = (1U << 0);  ///< Set the bit to 1 to allow the driving nodes start transmission.
        constexpr uint32_t ABORT_TX = (1U << 1);  ///< Set the bit to 1 to cancel a pending transmission request.
        constexpr uint32_t RELEASE_BUF = (1U << 2);  ///< Set the bit to 1 to release the RX buffer.
        constexpr uint32_t CLR_OVERRUN = (1U << 3);  ///< Set the bit to 1 to clear the data overrun status bit.
        constexpr uint32_t SELF_RX_REQ = (1U << 4);  ///< Self reception request command. Set the bit to 1 to allow a message be transmitted and received simultaneously.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RX_BUF_ST = (1U << 0);  ///< 1: The data in the RX buffer is not empty, with at least one received data packet.
        constexpr uint32_t OVERRUN_ST = (1U << 1);  ///< 1: The RX FIFO is full and data overrun has occurred.
        constexpr uint32_t TX_BUF_ST = (1U << 2);  ///< 1: The TX buffer is empty, the CPU may write a message into it.
        constexpr uint32_t TX_COMPLETE = (1U << 3);  ///< 1: The TWAI controller has successfully received a packet from the bus.
        constexpr uint32_t RX_ST = (1U << 4);  ///< 1: The TWAI Controller is receiving a message from the bus.
        constexpr uint32_t TX_ST = (1U << 5);  ///< 1: The TWAI Controller is transmitting a message to the bus.
        constexpr uint32_t ERR_ST = (1U << 6);  ///< 1: At least one of the RX/TX error counter has reached or exceeded the value set in register TWAI_ERR_WARNING_LIMIT_REG.
        constexpr uint32_t BUS_OFF_ST = (1U << 7);  ///< 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
        constexpr uint32_t MISS_ST = (1U << 8);  ///< This bit reflects whether the data packet in the RX FIFO is complete. 1: The current packet is missing; 0: The current packet is complete
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_INT_ST = (1U << 0);  ///< Receive interrupt. If this bit is set to 1, it indicates there are messages to be handled in the RX FIFO.
        constexpr uint32_t TX_INT_ST = (1U << 1);  ///< Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis- sion is finished and a new transmission is able to execute.
        constexpr uint32_t ERR_WARN_INT_ST = (1U << 2);  ///< Error warning interrupt. If this bit is set to 1, it indicates the error status signal and the bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or from 1 to 0).
        constexpr uint32_t OVERRUN_INT_ST = (1U << 3);  ///< Data overrun interrupt. If this bit is set to 1, it indicates a data overrun interrupt is generated in the RX FIFO.
        constexpr uint32_t ERR_PASSIVE_INT_ST = (1U << 5);  ///< Error passive interrupt. If this bit is set to 1, it indicates the TWAI Controller is switched between error active status and error passive status due to the change of error counters.
        constexpr uint32_t ARB_LOST_INT_ST = (1U << 6);  ///< Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration lost interrupt is generated.
        constexpr uint32_t BUS_ERR_INT_ST = (1U << 7);  ///< Error interrupt. If this bit is set to 1, it indicates an error is detected on the bus.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_INT_ENA = (1U << 0);  ///< Set this bit to 1 to enable receive interrupt.
        constexpr uint32_t TX_INT_ENA = (1U << 1);  ///< Set this bit to 1 to enable transmit interrupt.
        constexpr uint32_t ERR_WARN_INT_ENA = (1U << 2);  ///< Set this bit to 1 to enable error warning interrupt.
        constexpr uint32_t OVERRUN_INT_ENA = (1U << 3);  ///< Set this bit to 1 to enable data overrun interrupt.
        constexpr uint32_t ERR_PASSIVE_INT_ENA = (1U << 5);  ///< Set this bit to 1 to enable error passive interrupt.
        constexpr uint32_t ARB_LOST_INT_ENA = (1U << 6);  ///< Set this bit to 1 to enable arbitration lost interrupt.
        constexpr uint32_t BUS_ERR_INT_ENA = (1U << 7);  ///< Set this bit to 1 to enable error interrupt.
    }

    /// BUS_TIMING_0 Register bits
    namespace bus_timing_0_bits {
        constexpr uint32_t BAUD_PRESC = (14 << 0);  ///< Baud Rate Prescaler, determines the frequency dividing ratio.
        constexpr uint32_t SYNC_JUMP_WIDTH = (2 << 14);  ///< Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
    }

    /// BUS_TIMING_1 Register bits
    namespace bus_timing_1_bits {
        constexpr uint32_t TIME_SEG1 = (4 << 0);  ///< The width of PBS1.
        constexpr uint32_t TIME_SEG2 = (3 << 4);  ///< The width of PBS2.
        constexpr uint32_t TIME_SAMP = (1U << 7);  ///< The number of sample points. 0: the bus is sampled once; 1: the bus is sampled three times
    }

    /// ARB_LOST_CAP Register bits
    namespace arb_lost_cap_bits {
        constexpr uint32_t ARB_LOST_CAP = (5 << 0);  ///< This register contains information about the bit position of lost arbitration.
    }

    /// ERR_CODE_CAP Register bits
    namespace err_code_cap_bits {
        constexpr uint32_t ECC_SEGMENT = (5 << 0);  ///< This register contains information about the location of errors, see Table 181 for details.
        constexpr uint32_t ECC_DIRECTION = (1U << 5);  ///< This register contains information about transmission direction of the node when error occurs. 1: Error occurs when receiving a message; 0: Error occurs when transmitting a message
        constexpr uint32_t ECC_TYPE = (2 << 6);  ///< This register contains information about error types: 00: bit error; 01: form error; 10: stuff error; 11: other type of error
    }

    /// ERR_WARNING_LIMIT Register bits
    namespace err_warning_limit_bits {
        constexpr uint32_t ERR_WARNING_LIMIT = (8 << 0);  ///< Error warning threshold. In the case when any of a error counter value exceeds the threshold, or all the error counter values are below the threshold, an error warning interrupt will be triggered (given the enable signal is valid).
    }

    /// RX_ERR_CNT Register bits
    namespace rx_err_cnt_bits {
        constexpr uint32_t RX_ERR_CNT = (8 << 0);  ///< The RX error counter register, reflects value changes under reception status.
    }

    /// TX_ERR_CNT Register bits
    namespace tx_err_cnt_bits {
        constexpr uint32_t TX_ERR_CNT = (8 << 0);  ///< The TX error counter register, reflects value changes under transmission status.
    }

    /// DATA_0 Register bits
    namespace data_0_bits {
        constexpr uint32_t TX_BYTE_0 = (8 << 0);  ///< In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, it stores the 0th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_1 Register bits
    namespace data_1_bits {
        constexpr uint32_t TX_BYTE_1 = (8 << 0);  ///< In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, it stores the 1st byte information of the data to be transmitted under operating mode.
    }

    /// DATA_2 Register bits
    namespace data_2_bits {
        constexpr uint32_t TX_BYTE_2 = (8 << 0);  ///< In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, it stores the 2nd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_3 Register bits
    namespace data_3_bits {
        constexpr uint32_t TX_BYTE_3 = (8 << 0);  ///< In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, it stores the 3rd byte information of the data to be transmitted under operating mode.
    }

    /// DATA_4 Register bits
    namespace data_4_bits {
        constexpr uint32_t TX_BYTE_4 = (8 << 0);  ///< In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, it stores the 4th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_5 Register bits
    namespace data_5_bits {
        constexpr uint32_t TX_BYTE_5 = (8 << 0);  ///< In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, it stores the 5th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_6 Register bits
    namespace data_6_bits {
        constexpr uint32_t TX_BYTE_6 = (8 << 0);  ///< In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, it stores the 6th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_7 Register bits
    namespace data_7_bits {
        constexpr uint32_t TX_BYTE_7 = (8 << 0);  ///< In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, it stores the 7th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_8 Register bits
    namespace data_8_bits {
        constexpr uint32_t TX_BYTE_8 = (8 << 0);  ///< Stored the 8th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_9 Register bits
    namespace data_9_bits {
        constexpr uint32_t TX_BYTE_9 = (8 << 0);  ///< Stored the 9th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_10 Register bits
    namespace data_10_bits {
        constexpr uint32_t TX_BYTE_10 = (8 << 0);  ///< Stored the 10th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_11 Register bits
    namespace data_11_bits {
        constexpr uint32_t TX_BYTE_11 = (8 << 0);  ///< Stored the 11th byte information of the data to be transmitted under operating mode.
    }

    /// DATA_12 Register bits
    namespace data_12_bits {
        constexpr uint32_t TX_BYTE_12 = (8 << 0);  ///< Stored the 12th byte information of the data to be transmitted under operating mode.
    }

    /// RX_MESSAGE_CNT Register bits
    namespace rx_message_cnt_bits {
        constexpr uint32_t RX_MESSAGE_COUNTER = (7 << 0);  ///< This register reflects the number of messages available within the RX FIFO.
    }

    /// CLOCK_DIVIDER Register bits
    namespace clock_divider_bits {
        constexpr uint32_t CD = (8 << 0);  ///< These bits are used to configure frequency dividing coefficients of the external CLKOUT pin.
        constexpr uint32_t CLOCK_OFF = (1U << 8);  ///< This bit can be configured under reset mode. 1: Disable the external CLKOUT pin; 0: Enable the external CLKOUT pin
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x60000000;
    constexpr uint32_t UART1_BASE = 0x60010000;
    constexpr uint32_t UART2_BASE = 0x6002E000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t FIFO;  ///< Offset: 0x00 - FIFO data register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t CLKDIV;  ///< Offset: 0x14 - Clock divider configuration
        volatile uint32_t RX_FILT;  ///< Offset: 0x18 - Rx Filter configuration
        volatile uint32_t STATUS;  ///< Offset: 0x1C - UART status register
        volatile uint32_t CONF0;  ///< Offset: 0x20 - a
        volatile uint32_t CONF1;  ///< Offset: 0x24 - Configuration register 1
        volatile uint32_t LOWPULSE;  ///< Offset: 0x28 - Autobaud minimum low pulse duration register
        volatile uint32_t HIGHPULSE;  ///< Offset: 0x2C - Autobaud minimum high pulse duration register
        volatile uint32_t RXD_CNT;  ///< Offset: 0x30 - Autobaud edge change count register
        volatile uint32_t FLOW_CONF;  ///< Offset: 0x34 - Software flow-control configuration
        volatile uint32_t SLEEP_CONF;  ///< Offset: 0x38 - Sleep-mode configuration
        volatile uint32_t SWFC_CONF0;  ///< Offset: 0x3C - Software flow-control character configuration
        volatile uint32_t SWFC_CONF1;  ///< Offset: 0x40 - Software flow-control character configuration
        volatile uint32_t TXBRK_CONF;  ///< Offset: 0x44 - Tx Break character configuration
        volatile uint32_t IDLE_CONF;  ///< Offset: 0x48 - Frame-end idle configuration
        volatile uint32_t RS485_CONF;  ///< Offset: 0x4C - RS485 mode configuration
        volatile uint32_t AT_CMD_PRECNT;  ///< Offset: 0x50 - Pre-sequence timing configuration
        volatile uint32_t AT_CMD_POSTCNT;  ///< Offset: 0x54 - Post-sequence timing configuration
        volatile uint32_t AT_CMD_GAPTOUT;  ///< Offset: 0x58 - Timeout configuration
        volatile uint32_t AT_CMD_CHAR;  ///< Offset: 0x5C - AT escape sequence detection configuration
        volatile uint32_t MEM_CONF;  ///< Offset: 0x60 - UART threshold and allocation configuration
        volatile uint32_t MEM_TX_STATUS;  ///< Offset: 0x64 - Tx-FIFO write and read offset address.
        volatile uint32_t MEM_RX_STATUS;  ///< Offset: 0x68 - Rx-FIFO write and read offset address.
        volatile uint32_t FSM_STATUS;  ///< Offset: 0x6C - UART transmit and receive status.
        volatile uint32_t POSPULSE;  ///< Offset: 0x70 - Autobaud high pulse register
        volatile uint32_t NEGPULSE;  ///< Offset: 0x74 - Autobaud low pulse register
        volatile uint32_t CLK_CONF;  ///< Offset: 0x78 - UART core clock configuration
        volatile uint32_t DATE;  ///< Offset: 0x7C - UART Version register
        volatile uint32_t ID;  ///< Offset: 0x80 - UART ID register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFO_RD_BYTE = (8 << 0);  ///< UART 0 accesses FIFO via this register.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RXFIFO_FULL_INT_RAW = (1U << 0);  ///< This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        constexpr uint32_t TXFIFO_EMPTY_INT_RAW = (1U << 1);  ///< This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        constexpr uint32_t PARITY_ERR_INT_RAW = (1U << 2);  ///< This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        constexpr uint32_t FRM_ERR_INT_RAW = (1U << 3);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error .
        constexpr uint32_t RXFIFO_OVF_INT_RAW = (1U << 4);  ///< This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        constexpr uint32_t DSR_CHG_INT_RAW = (1U << 5);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        constexpr uint32_t CTS_CHG_INT_RAW = (1U << 6);  ///< This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        constexpr uint32_t BRK_DET_INT_RAW = (1U << 7);  ///< This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        constexpr uint32_t RXFIFO_TOUT_INT_RAW = (1U << 8);  ///< This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        constexpr uint32_t SW_XON_INT_RAW = (1U << 9);  ///< This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t SW_XOFF_INT_RAW = (1U << 10);  ///< This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        constexpr uint32_t GLITCH_DET_INT_RAW = (1U << 11);  ///< This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        constexpr uint32_t TX_BRK_DONE_INT_RAW = (1U << 12);  ///< This interrupt raw bit turns to high level when transmitter completes sending NULL characters, after all data in Tx-FIFO are sent.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW = (1U << 13);  ///< This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        constexpr uint32_t TX_DONE_INT_RAW = (1U << 14);  ///< This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        constexpr uint32_t RS485_PARITY_ERR_INT_RAW = (1U << 15);  ///< This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_FRM_ERR_INT_RAW = (1U << 16);  ///< This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
        constexpr uint32_t RS485_CLASH_INT_RAW = (1U << 17);  ///< This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW = (1U << 18);  ///< This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        constexpr uint32_t WAKEUP_INT_RAW = (1U << 19);  ///< This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ST = (1U << 0);  ///< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        constexpr uint32_t TXFIFO_EMPTY_INT_ST = (1U << 1);  ///< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        constexpr uint32_t PARITY_ERR_INT_ST = (1U << 2);  ///< This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        constexpr uint32_t FRM_ERR_INT_ST = (1U << 3);  ///< This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        constexpr uint32_t RXFIFO_OVF_INT_ST = (1U << 4);  ///< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        constexpr uint32_t DSR_CHG_INT_ST = (1U << 5);  ///< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        constexpr uint32_t CTS_CHG_INT_ST = (1U << 6);  ///< This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        constexpr uint32_t BRK_DET_INT_ST = (1U << 7);  ///< This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        constexpr uint32_t RXFIFO_TOUT_INT_ST = (1U << 8);  ///< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        constexpr uint32_t SW_XON_INT_ST = (1U << 9);  ///< This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        constexpr uint32_t SW_XOFF_INT_ST = (1U << 10);  ///< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        constexpr uint32_t GLITCH_DET_INT_ST = (1U << 11);  ///< This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        constexpr uint32_t TX_BRK_DONE_INT_ST = (1U << 12);  ///< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST = (1U << 13);  ///< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        constexpr uint32_t TX_DONE_INT_ST = (1U << 14);  ///< This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        constexpr uint32_t RS485_PARITY_ERR_INT_ST = (1U << 15);  ///< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        constexpr uint32_t RS485_FRM_ERR_INT_ST = (1U << 16);  ///< This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        constexpr uint32_t RS485_CLASH_INT_ST = (1U << 17);  ///< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ST = (1U << 18);  ///< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        constexpr uint32_t WAKEUP_INT_ST = (1U << 19);  ///< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RXFIFO_FULL_INT_ENA = (1U << 0);  ///< This is the enable bit for rxfifo_full_int_st register.
        constexpr uint32_t TXFIFO_EMPTY_INT_ENA = (1U << 1);  ///< This is the enable bit for txfifo_empty_int_st register.
        constexpr uint32_t PARITY_ERR_INT_ENA = (1U << 2);  ///< This is the enable bit for parity_err_int_st register.
        constexpr uint32_t FRM_ERR_INT_ENA = (1U << 3);  ///< This is the enable bit for frm_err_int_st register.
        constexpr uint32_t RXFIFO_OVF_INT_ENA = (1U << 4);  ///< This is the enable bit for rxfifo_ovf_int_st register.
        constexpr uint32_t DSR_CHG_INT_ENA = (1U << 5);  ///< This is the enable bit for dsr_chg_int_st register.
        constexpr uint32_t CTS_CHG_INT_ENA = (1U << 6);  ///< This is the enable bit for cts_chg_int_st register.
        constexpr uint32_t BRK_DET_INT_ENA = (1U << 7);  ///< This is the enable bit for brk_det_int_st register.
        constexpr uint32_t RXFIFO_TOUT_INT_ENA = (1U << 8);  ///< This is the enable bit for rxfifo_tout_int_st register.
        constexpr uint32_t SW_XON_INT_ENA = (1U << 9);  ///< This is the enable bit for sw_xon_int_st register.
        constexpr uint32_t SW_XOFF_INT_ENA = (1U << 10);  ///< This is the enable bit for sw_xoff_int_st register.
        constexpr uint32_t GLITCH_DET_INT_ENA = (1U << 11);  ///< This is the enable bit for glitch_det_int_st register.
        constexpr uint32_t TX_BRK_DONE_INT_ENA = (1U << 12);  ///< This is the enable bit for tx_brk_done_int_st register.
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA = (1U << 13);  ///< This is the enable bit for tx_brk_idle_done_int_st register.
        constexpr uint32_t TX_DONE_INT_ENA = (1U << 14);  ///< This is the enable bit for tx_done_int_st register.
        constexpr uint32_t RS485_PARITY_ERR_INT_ENA = (1U << 15);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_FRM_ERR_INT_ENA = (1U << 16);  ///< This is the enable bit for rs485_parity_err_int_st register.
        constexpr uint32_t RS485_CLASH_INT_ENA = (1U << 17);  ///< This is the enable bit for rs485_clash_int_st register.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA = (1U << 18);  ///< This is the enable bit for at_cmd_char_det_int_st register.
        constexpr uint32_t WAKEUP_INT_ENA = (1U << 19);  ///< This is the enable bit for uart_wakeup_int_st register.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RXFIFO_FULL_INT_CLR = (1U << 0);  ///< Set this bit to clear the rxfifo_full_int_raw interrupt.
        constexpr uint32_t TXFIFO_EMPTY_INT_CLR = (1U << 1);  ///< Set this bit to clear txfifo_empty_int_raw interrupt.
        constexpr uint32_t PARITY_ERR_INT_CLR = (1U << 2);  ///< Set this bit to clear parity_err_int_raw interrupt.
        constexpr uint32_t FRM_ERR_INT_CLR = (1U << 3);  ///< Set this bit to clear frm_err_int_raw interrupt.
        constexpr uint32_t RXFIFO_OVF_INT_CLR = (1U << 4);  ///< Set this bit to clear rxfifo_ovf_int_raw interrupt.
        constexpr uint32_t DSR_CHG_INT_CLR = (1U << 5);  ///< Set this bit to clear the dsr_chg_int_raw interrupt.
        constexpr uint32_t CTS_CHG_INT_CLR = (1U << 6);  ///< Set this bit to clear the cts_chg_int_raw interrupt.
        constexpr uint32_t BRK_DET_INT_CLR = (1U << 7);  ///< Set this bit to clear the brk_det_int_raw interrupt.
        constexpr uint32_t RXFIFO_TOUT_INT_CLR = (1U << 8);  ///< Set this bit to clear the rxfifo_tout_int_raw interrupt.
        constexpr uint32_t SW_XON_INT_CLR = (1U << 9);  ///< Set this bit to clear the sw_xon_int_raw interrupt.
        constexpr uint32_t SW_XOFF_INT_CLR = (1U << 10);  ///< Set this bit to clear the sw_xoff_int_raw interrupt.
        constexpr uint32_t GLITCH_DET_INT_CLR = (1U << 11);  ///< Set this bit to clear the glitch_det_int_raw interrupt.
        constexpr uint32_t TX_BRK_DONE_INT_CLR = (1U << 12);  ///< Set this bit to clear the tx_brk_done_int_raw interrupt..
        constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR = (1U << 13);  ///< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        constexpr uint32_t TX_DONE_INT_CLR = (1U << 14);  ///< Set this bit to clear the tx_done_int_raw interrupt.
        constexpr uint32_t RS485_PARITY_ERR_INT_CLR = (1U << 15);  ///< Set this bit to clear the rs485_parity_err_int_raw interrupt.
        constexpr uint32_t RS485_FRM_ERR_INT_CLR = (1U << 16);  ///< Set this bit to clear the rs485_frm_err_int_raw interrupt.
        constexpr uint32_t RS485_CLASH_INT_CLR = (1U << 17);  ///< Set this bit to clear the rs485_clash_int_raw interrupt.
        constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR = (1U << 18);  ///< Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        constexpr uint32_t WAKEUP_INT_CLR = (1U << 19);  ///< Set this bit to clear the uart_wakeup_int_raw interrupt.
    }

    /// CLKDIV Register bits
    namespace clkdiv_bits {
        constexpr uint32_t CLKDIV = (12 << 0);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t FRAG = (4 << 20);  ///< The decimal part of the frequency divider factor.
    }

    /// RX_FILT Register bits
    namespace rx_filt_bits {
        constexpr uint32_t GLITCH_FILT = (8 << 0);  ///< when input pulse width is lower than this value, the pulse is ignored.
        constexpr uint32_t GLITCH_FILT_EN = (1U << 8);  ///< Set this bit to enable Rx signal filter.
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t RXFIFO_CNT = (10 << 0);  ///< Stores the byte number of valid data in Rx-FIFO.
        constexpr uint32_t DSRN = (1U << 13);  ///< The register represent the level value of the internal uart dsr signal.
        constexpr uint32_t CTSN = (1U << 14);  ///< This register represent the level value of the internal uart cts signal.
        constexpr uint32_t RXD = (1U << 15);  ///< This register represent the level value of the internal uart rxd signal.
        constexpr uint32_t TXFIFO_CNT = (10 << 16);  ///< Stores the byte number of data in Tx-FIFO.
        constexpr uint32_t DTRN = (1U << 29);  ///< This bit represents the level of the internal uart dtr signal.
        constexpr uint32_t RTSN = (1U << 30);  ///< This bit represents the level of the internal uart rts signal.
        constexpr uint32_t TXD = (1U << 31);  ///< This bit represents the level of the internal uart txd signal.
    }

    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t PARITY = (1U << 0);  ///< This register is used to configure the parity check mode.
        constexpr uint32_t PARITY_EN = (1U << 1);  ///< Set this bit to enable uart parity check.
        constexpr uint32_t BIT_NUM = (2 << 2);  ///< This register is used to set the length of data.
        constexpr uint32_t STOP_BIT_NUM = (2 << 4);  ///< This register is used to set the length of stop bit.
        constexpr uint32_t SW_RTS = (1U << 6);  ///< This register is used to configure the software rts signal which is used in software flow control.
        constexpr uint32_t SW_DTR = (1U << 7);  ///< This register is used to configure the software dtr signal which is used in software flow control.
        constexpr uint32_t TXD_BRK = (1U << 8);  ///< Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        constexpr uint32_t IRDA_DPLX = (1U << 9);  ///< Set this bit to enable IrDA loopback mode.
        constexpr uint32_t IRDA_TX_EN = (1U << 10);  ///< This is the start enable bit for IrDA transmitter.
        constexpr uint32_t IRDA_WCTL = (1U << 11);  ///< 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
        constexpr uint32_t IRDA_TX_INV = (1U << 12);  ///< Set this bit to invert the level of IrDA transmitter.
        constexpr uint32_t IRDA_RX_INV = (1U << 13);  ///< Set this bit to invert the level of IrDA receiver.
        constexpr uint32_t LOOPBACK = (1U << 14);  ///< Set this bit to enable uart loopback test mode.
        constexpr uint32_t TX_FLOW_EN = (1U << 15);  ///< Set this bit to enable flow control function for transmitter.
        constexpr uint32_t IRDA_EN = (1U << 16);  ///< Set this bit to enable IrDA protocol.
        constexpr uint32_t RXFIFO_RST = (1U << 17);  ///< Set this bit to reset the uart receive-FIFO.
        constexpr uint32_t TXFIFO_RST = (1U << 18);  ///< Set this bit to reset the uart transmit-FIFO.
        constexpr uint32_t RXD_INV = (1U << 19);  ///< Set this bit to inverse the level value of uart rxd signal.
        constexpr uint32_t CTS_INV = (1U << 20);  ///< Set this bit to inverse the level value of uart cts signal.
        constexpr uint32_t DSR_INV = (1U << 21);  ///< Set this bit to inverse the level value of uart dsr signal.
        constexpr uint32_t TXD_INV = (1U << 22);  ///< Set this bit to inverse the level value of uart txd signal.
        constexpr uint32_t RTS_INV = (1U << 23);  ///< Set this bit to inverse the level value of uart rts signal.
        constexpr uint32_t DTR_INV = (1U << 24);  ///< Set this bit to inverse the level value of uart dtr signal.
        constexpr uint32_t CLK_EN = (1U << 25);  ///< 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
        constexpr uint32_t ERR_WR_MASK = (1U << 26);  ///< 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        constexpr uint32_t AUTOBAUD_EN = (1U << 27);  ///< This is the enable bit for detecting baudrate.
        constexpr uint32_t MEM_CLK_EN = (1U << 28);  ///< UART memory clock gate enable signal.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t RXFIFO_FULL_THRHD = (10 << 0);  ///< It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        constexpr uint32_t TXFIFO_EMPTY_THRHD = (10 << 10);  ///< It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        constexpr uint32_t DIS_RX_DAT_OVF = (1U << 20);  ///< Disable UART Rx data overflow detect.
        constexpr uint32_t RX_TOUT_FLOW_DIS = (1U << 21);  ///< Set this bit to stop accumulating idle_cnt when hardware flow control works.
        constexpr uint32_t RX_FLOW_EN = (1U << 22);  ///< This is the flow enable bit for UART receiver.
        constexpr uint32_t RX_TOUT_EN = (1U << 23);  ///< This is the enble bit for uart receiver's timeout function.
    }

    /// LOWPULSE Register bits
    namespace lowpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
    }

    /// HIGHPULSE Register bits
    namespace highpulse_bits {
        constexpr uint32_t MIN_CNT = (12 << 0);  ///< This register stores the value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
    }

    /// RXD_CNT Register bits
    namespace rxd_cnt_bits {
        constexpr uint32_t RXD_EDGE_CNT = (10 << 0);  ///< This register stores the count of rxd edge change. It is used in baud rate-detect process.
    }

    /// FLOW_CONF Register bits
    namespace flow_conf_bits {
        constexpr uint32_t SW_FLOW_CON_EN = (1U << 0);  ///< Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        constexpr uint32_t XONOFF_DEL = (1U << 1);  ///< Set this bit to remove flow control char from the received data.
        constexpr uint32_t FORCE_XON = (1U << 2);  ///< Set this bit to enable the transmitter to go on sending data.
        constexpr uint32_t FORCE_XOFF = (1U << 3);  ///< Set this bit to stop the transmitter from sending data.
        constexpr uint32_t SEND_XON = (1U << 4);  ///< Set this bit to send Xon char. It is cleared by hardware automatically.
        constexpr uint32_t SEND_XOFF = (1U << 5);  ///< Set this bit to send Xoff char. It is cleared by hardware automatically.
    }

    /// SLEEP_CONF Register bits
    namespace sleep_conf_bits {
        constexpr uint32_t ACTIVE_THRESHOLD = (10 << 0);  ///< The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
    }

    /// SWFC_CONF0 Register bits
    namespace swfc_conf0_bits {
        constexpr uint32_t XOFF_THRESHOLD = (10 << 0);  ///< When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1, it will send a Xoff char.
        constexpr uint32_t XOFF_CHAR = (8 << 10);  ///< This register stores the Xoff flow control char.
    }

    /// SWFC_CONF1 Register bits
    namespace swfc_conf1_bits {
        constexpr uint32_t XON_THRESHOLD = (10 << 0);  ///< When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1, it will send a Xon char.
        constexpr uint32_t XON_CHAR = (8 << 10);  ///< This register stores the Xon flow control char.
    }

    /// TXBRK_CONF Register bits
    namespace txbrk_conf_bits {
        constexpr uint32_t TX_BRK_NUM = (8 << 0);  ///< This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
    }

    /// IDLE_CONF Register bits
    namespace idle_conf_bits {
        constexpr uint32_t RX_IDLE_THRHD = (10 << 0);  ///< It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        constexpr uint32_t TX_IDLE_NUM = (10 << 10);  ///< This register is used to configure the duration time between transfers.
    }

    /// RS485_CONF Register bits
    namespace rs485_conf_bits {
        constexpr uint32_t RS485_EN = (1U << 0);  ///< Set this bit to choose the rs485 mode.
        constexpr uint32_t DL0_EN = (1U << 1);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t DL1_EN = (1U << 2);  ///< Set this bit to delay the stop bit by 1 bit.
        constexpr uint32_t RS485TX_RX_EN = (1U << 3);  ///< Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
        constexpr uint32_t RS485RXBY_TX_EN = (1U << 4);  ///< 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
        constexpr uint32_t RS485_RX_DLY_NUM = (1U << 5);  ///< This register is used to delay the receiver's internal data signal.
        constexpr uint32_t RS485_TX_DLY_NUM = (4 << 6);  ///< This register is used to delay the transmitter's internal data signal.
    }

    /// AT_CMD_PRECNT Register bits
    namespace at_cmd_precnt_bits {
        constexpr uint32_t PRE_IDLE_NUM = (16 << 0);  ///< This register is used to configure the idle duration time before the first at_cmd is received by receiver.
    }

    /// AT_CMD_POSTCNT Register bits
    namespace at_cmd_postcnt_bits {
        constexpr uint32_t POST_IDLE_NUM = (16 << 0);  ///< This register is used to configure the duration time between the last at_cmd and the next data.
    }

    /// AT_CMD_GAPTOUT Register bits
    namespace at_cmd_gaptout_bits {
        constexpr uint32_t RX_GAP_TOUT = (16 << 0);  ///< This register is used to configure the duration time between the at_cmd chars.
    }

    /// AT_CMD_CHAR Register bits
    namespace at_cmd_char_bits {
        constexpr uint32_t AT_CMD_CHAR = (8 << 0);  ///< This register is used to configure the content of at_cmd char.
        constexpr uint32_t CHAR_NUM = (8 << 8);  ///< This register is used to configure the num of continuous at_cmd chars received by receiver.
    }

    /// MEM_CONF Register bits
    namespace mem_conf_bits {
        constexpr uint32_t RX_SIZE = (3 << 1);  ///< This register is used to configure the amount of mem allocated for receive-FIFO. The default number is 128 bytes.
        constexpr uint32_t TX_SIZE = (3 << 4);  ///< This register is used to configure the amount of mem allocated for transmit-FIFO. The default number is 128 bytes.
        constexpr uint32_t RX_FLOW_THRHD = (10 << 7);  ///< This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        constexpr uint32_t RX_TOUT_THRHD = (10 << 17);  ///< This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
        constexpr uint32_t MEM_FORCE_PD = (1U << 27);  ///< Set this bit to force power down UART memory.
        constexpr uint32_t MEM_FORCE_PU = (1U << 28);  ///< Set this bit to force power up UART memory.
    }

    /// MEM_TX_STATUS Register bits
    namespace mem_tx_status_bits {
        constexpr uint32_t APB_TX_WADDR = (10 << 0);  ///< This register stores the offset address in Tx-FIFO when software writes Tx-FIFO via APB.
        constexpr uint32_t TX_RADDR = (10 << 11);  ///< This register stores the offset address in Tx-FIFO when Tx-FSM reads data via Tx-FIFO_Ctrl.
    }

    /// MEM_RX_STATUS Register bits
    namespace mem_rx_status_bits {
        constexpr uint32_t APB_RX_RADDR = (10 << 0);  ///< This register stores the offset address in RX-FIFO when software reads data from Rx-FIFO via APB. UART0 is 10'h200. UART1 is 10'h280. UART2 is 10'h300.
        constexpr uint32_t RX_WADDR = (10 << 11);  ///< This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl writes Rx-FIFO. UART0 is 10'h200. UART1 is 10'h280. UART2 is 10'h300.
    }

    /// FSM_STATUS Register bits
    namespace fsm_status_bits {
        constexpr uint32_t ST_URX_OUT = (4 << 0);  ///< This is the status register of receiver.
        constexpr uint32_t ST_UTX_OUT = (4 << 4);  ///< This is the status register of transmitter.
    }

    /// POSPULSE Register bits
    namespace pospulse_bits {
        constexpr uint32_t POSEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
    }

    /// NEGPULSE Register bits
    namespace negpulse_bits {
        constexpr uint32_t NEGEDGE_MIN_CNT = (12 << 0);  ///< This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
    }

    /// CLK_CONF Register bits
    namespace clk_conf_bits {
        constexpr uint32_t SCLK_DIV_B = (6 << 0);  ///< The denominator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_A = (6 << 6);  ///< The numerator of the frequency divider factor.
        constexpr uint32_t SCLK_DIV_NUM = (8 << 12);  ///< The integral part of the frequency divider factor.
        constexpr uint32_t SCLK_SEL = (2 << 20);  ///< UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.
        constexpr uint32_t SCLK_EN = (1U << 22);  ///< Set this bit to enable UART Tx/Rx clock.
        constexpr uint32_t RST_CORE = (1U << 23);  ///< Write 1 then write 0 to this bit, reset UART Tx/Rx.
        constexpr uint32_t TX_SCLK_EN = (1U << 24);  ///< Set this bit to enable UART Tx clock.
        constexpr uint32_t RX_SCLK_EN = (1U << 25);  ///< Set this bit to enable UART Rx clock.
        constexpr uint32_t TX_RST_CORE = (1U << 26);  ///< Write 1 then write 0 to this bit, reset UART Tx.
        constexpr uint32_t RX_RST_CORE = (1U << 27);  ///< Write 1 then write 0 to this bit, reset UART Rx.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version register.
    }

    /// ID Register bits
    namespace id_bits {
        constexpr uint32_t ID = (30 << 0);  ///< This register is used to configure the uart_id.
        constexpr uint32_t HIGH_SPEED = (1U << 30);  ///< This bit used to select synchronize mode. 1: Registers are auto synchronized into UART Core clock and UART core should be keep the same with APB clock. 0: After configure registers, software needs to write 1 to UART_REG_UPDATE to synchronize registers.
        constexpr uint32_t REG_UPDATE = (1U << 31);  ///< Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
    }

}

// ============================================================================
// UHCI0 Peripheral
// ============================================================================

namespace uhci0 {
    /// Base addresses
    constexpr uint32_t UHCI0_BASE = 0x60014000;

    /// UHCI0 Register structure
    struct Registers {
        volatile uint32_t CONF0;  ///< Offset: 0x00 - UHCI configuration register
        volatile uint32_t INT_RAW;  ///< Offset: 0x04 - Raw interrupt status
        volatile uint32_t INT_ST;  ///< Offset: 0x08 - Masked interrupt status
        volatile uint32_t INT_ENA;  ///< Offset: 0x0C - Interrupt enable bits
        volatile uint32_t INT_CLR;  ///< Offset: 0x10 - Interrupt clear bits
        volatile uint32_t APP_INT_SET;  ///< Offset: 0x14 - Software interrupt trigger source
        volatile uint32_t CONF1;  ///< Offset: 0x18 - UHCI configuration register
        volatile uint32_t STATE0;  ///< Offset: 0x1C - UHCI receive status
        volatile uint32_t STATE1;  ///< Offset: 0x20 - UHCI transmit status
        volatile uint32_t ESCAPE_CONF;  ///< Offset: 0x24 - Escape character configuration
        volatile uint32_t HUNG_CONF;  ///< Offset: 0x28 - Timeout configuration
        volatile uint32_t ACK_NUM;  ///< Offset: 0x2C - UHCI ACK number configuration
        volatile uint32_t RX_HEAD;  ///< Offset: 0x30 - UHCI packet header register
        volatile uint32_t QUICK_SENT;  ///< Offset: 0x34 - UHCI quick send configuration register
        volatile uint32_t REG_Q0_WORD0;  ///< Offset: 0x38 - Q0_WORD0 quick_sent register
        volatile uint32_t REG_Q0_WORD1;  ///< Offset: 0x3C - Q0_WORD1 quick_sent register
        volatile uint32_t REG_Q1_WORD0;  ///< Offset: 0x40 - Q1_WORD0 quick_sent register
        volatile uint32_t REG_Q1_WORD1;  ///< Offset: 0x44 - Q1_WORD1 quick_sent register
        volatile uint32_t REG_Q2_WORD0;  ///< Offset: 0x48 - Q2_WORD0 quick_sent register
        volatile uint32_t REG_Q2_WORD1;  ///< Offset: 0x4C - Q2_WORD1 quick_sent register
        volatile uint32_t REG_Q3_WORD0;  ///< Offset: 0x50 - Q3_WORD0 quick_sent register
        volatile uint32_t REG_Q3_WORD1;  ///< Offset: 0x54 - Q3_WORD1 quick_sent register
        volatile uint32_t REG_Q4_WORD0;  ///< Offset: 0x58 - Q4_WORD0 quick_sent register
        volatile uint32_t REG_Q4_WORD1;  ///< Offset: 0x5C - Q4_WORD1 quick_sent register
        volatile uint32_t REG_Q5_WORD0;  ///< Offset: 0x60 - Q5_WORD0 quick_sent register
        volatile uint32_t REG_Q5_WORD1;  ///< Offset: 0x64 - Q5_WORD1 quick_sent register
        volatile uint32_t REG_Q6_WORD0;  ///< Offset: 0x68 - Q6_WORD0 quick_sent register
        volatile uint32_t REG_Q6_WORD1;  ///< Offset: 0x6C - Q6_WORD1 quick_sent register
        volatile uint32_t ESC_CONF0;  ///< Offset: 0x70 - Escape sequence configuration register 0
        volatile uint32_t ESC_CONF1;  ///< Offset: 0x74 - Escape sequence configuration register 1
        volatile uint32_t ESC_CONF2;  ///< Offset: 0x78 - Escape sequence configuration register 2
        volatile uint32_t ESC_CONF3;  ///< Offset: 0x7C - Escape sequence configuration register 3
        volatile uint32_t PKT_THRES;  ///< Offset: 0x80 - Configure register for packet length
        volatile uint32_t DATE;  ///< Offset: 0x84 - UHCI version control register
    };

    /// Peripheral instances
    inline Registers* UHCI0 = reinterpret_cast<Registers*>(UHCI0_BASE);

    // Bit definitions
    /// CONF0 Register bits
    namespace conf0_bits {
        constexpr uint32_t TX_RST = (1U << 0);  ///< Write 1, then write 0 to this bit to reset decode state machine.
        constexpr uint32_t RX_RST = (1U << 1);  ///< Write 1, then write 0 to this bit to reset encode state machine.
        constexpr uint32_t UART0_CE = (1U << 2);  ///< Set this bit to link up HCI and UART0.
        constexpr uint32_t UART1_CE = (1U << 3);  ///< Set this bit to link up HCI and UART1.
        constexpr uint32_t UART2_CE = (1U << 4);  ///< Set this bit to link up HCI and UART2.
        constexpr uint32_t SEPER_EN = (1U << 5);  ///< Set this bit to separate the data frame using a special char.
        constexpr uint32_t HEAD_EN = (1U << 6);  ///< Set this bit to encode the data packet with a formatting header.
        constexpr uint32_t CRC_REC_EN = (1U << 7);  ///< Set this bit to enable UHCI to receive the 16 bit CRC.
        constexpr uint32_t UART_IDLE_EOF_EN = (1U << 8);  ///< If this bit is set to 1, UHCI will end the payload receiving process when UART has been in idle state.
        constexpr uint32_t LEN_EOF_EN = (1U << 9);  ///< If this bit is set to 1, UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI decoder receiving payload data is end when 0xc0 is received.
        constexpr uint32_t ENCODE_CRC_EN = (1U << 10);  ///< Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
        constexpr uint32_t CLK_EN = (1U << 11);  ///< 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
        constexpr uint32_t UART_RX_BRK_EOF_EN = (1U << 12);  ///< If this bit is set to 1, UHCI will end payload receive process when NULL frame is received by UART.
    }

    /// INT_RAW Register bits
    namespace int_raw_bits {
        constexpr uint32_t RX_START_INT_RAW = (1U << 0);  ///< This is the interrupt raw bit. Triggered when a separator char has been sent.
        constexpr uint32_t TX_START_INT_RAW = (1U << 1);  ///< This is the interrupt raw bit. Triggered when UHCI detects a separator char.
        constexpr uint32_t RX_HUNG_INT_RAW = (1U << 2);  ///< This is the interrupt raw bit. Triggered when UHCI takes more time to receive data than configure value.
        constexpr uint32_t TX_HUNG_INT_RAW = (1U << 3);  ///< This is the interrupt raw bit. Triggered when UHCI takes more time to read data from RAM than the configured value.
        constexpr uint32_t SEND_S_REG_Q_INT_RAW = (1U << 4);  ///< This is the interrupt raw bit. Triggered when UHCI has sent out a short packet using single_send registers.
        constexpr uint32_t SEND_A_REG_Q_INT_RAW = (1U << 5);  ///< This is the interrupt raw bit. Triggered when UHCI has sent out a short packet using always_send registers.
        constexpr uint32_t OUT_EOF_INT_RAW = (1U << 6);  ///< This is the interrupt raw bit. Triggered when there are some errors in EOF in the transmit data.
        constexpr uint32_t APP_CTRL0_INT_RAW = (1U << 7);  ///< This is the interrupt raw bit. Triggered when set UHCI_APP_CTRL0_IN_SET.
        constexpr uint32_t APP_CTRL1_INT_RAW = (1U << 8);  ///< This is the interrupt raw bit. Triggered when set UHCI_APP_CTRL1_IN_SET.
    }

    /// INT_ST Register bits
    namespace int_st_bits {
        constexpr uint32_t RX_START_INT_ST = (1U << 0);  ///< This is the masked interrupt bit for UHCI_RX_START_INT interrupt when UHCI_RX_START_INT_ENA is set to 1.
        constexpr uint32_t TX_START_INT_ST = (1U << 1);  ///< This is the masked interrupt bit for UHCI_TX_START_INT interrupt when UHCI_TX_START_INT_ENA is set to 1.
        constexpr uint32_t RX_HUNG_INT_ST = (1U << 2);  ///< This is the masked interrupt bit for UHCI_RX_HUNG_INT interrupt when UHCI_RX_HUNG_INT_ENA is set to 1.
        constexpr uint32_t TX_HUNG_INT_ST = (1U << 3);  ///< This is the masked interrupt bit for UHCI_TX_HUNG_INT interrupt when UHCI_TX_HUNG_INT_ENA is set to 1.
        constexpr uint32_t SEND_S_REG_Q_INT_ST = (1U << 4);  ///< This is the masked interrupt bit for UHCI_SEND_S_REQ_Q_INT interrupt when UHCI_SEND_S_REQ_Q_INT_ENA is set to 1.
        constexpr uint32_t SEND_A_REG_Q_INT_ST = (1U << 5);  ///< This is the masked interrupt bit for UHCI_SEND_A_REQ_Q_INT interrupt when UHCI_SEND_A_REQ_Q_INT_ENA is set to 1.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ST = (1U << 6);  ///< This is the masked interrupt bit for UHCI_OUTLINK_EOF_ERR_INT interrupt when UHCI_OUTLINK_EOF_ERR_INT_ENA is set to 1.
        constexpr uint32_t APP_CTRL0_INT_ST = (1U << 7);  ///< This is the masked interrupt bit for UHCI_APP_CTRL0_INT interrupt when UHCI_APP_CTRL0_INT_ENA is set to 1.
        constexpr uint32_t APP_CTRL1_INT_ST = (1U << 8);  ///< This is the masked interrupt bit for UHCI_APP_CTRL1_INT interrupt when UHCI_APP_CTRL1_INT_ENA is set to 1.
    }

    /// INT_ENA Register bits
    namespace int_ena_bits {
        constexpr uint32_t RX_START_INT_ENA = (1U << 0);  ///< This is the interrupt enable bit for UHCI_RX_START_INT interrupt.
        constexpr uint32_t TX_START_INT_ENA = (1U << 1);  ///< This is the interrupt enable bit for UHCI_TX_START_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_ENA = (1U << 2);  ///< This is the interrupt enable bit for UHCI_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_ENA = (1U << 3);  ///< This is the interrupt enable bit for UHCI_TX_HUNG_INT interrupt.
        constexpr uint32_t SEND_S_REG_Q_INT_ENA = (1U << 4);  ///< This is the interrupt enable bit for UHCI_SEND_S_REQ_Q_INT interrupt.
        constexpr uint32_t SEND_A_REG_Q_INT_ENA = (1U << 5);  ///< This is the interrupt enable bit for UHCI_SEND_A_REQ_Q_INT interrupt.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA = (1U << 6);  ///< This is the interrupt enable bit for UHCI_OUTLINK_EOF_ERR_INT interrupt.
        constexpr uint32_t APP_CTRL0_INT_ENA = (1U << 7);  ///< This is the interrupt enable bit for UHCI_APP_CTRL0_INT interrupt.
        constexpr uint32_t APP_CTRL1_INT_ENA = (1U << 8);  ///< This is the interrupt enable bit for UHCI_APP_CTRL1_INT interrupt.
    }

    /// INT_CLR Register bits
    namespace int_clr_bits {
        constexpr uint32_t RX_START_INT_CLR = (1U << 0);  ///< Set this bit to clear UHCI_RX_START_INT interrupt.
        constexpr uint32_t TX_START_INT_CLR = (1U << 1);  ///< Set this bit to clear UHCI_TX_START_INT interrupt.
        constexpr uint32_t RX_HUNG_INT_CLR = (1U << 2);  ///< Set this bit to clear UHCI_RX_HUNG_INT interrupt.
        constexpr uint32_t TX_HUNG_INT_CLR = (1U << 3);  ///< Set this bit to clear UHCI_TX_HUNG_INT interrupt.
        constexpr uint32_t SEND_S_REG_Q_INT_CLR = (1U << 4);  ///< Set this bit to clear UHCI_SEND_S_REQ_Q_INT interrupt.
        constexpr uint32_t SEND_A_REG_Q_INT_CLR = (1U << 5);  ///< Set this bit to clear UHCI_SEND_A_REQ_Q_INT interrupt.
        constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR = (1U << 6);  ///< Set this bit to clear UHCI_OUTLINK_EOF_ERR_INT interrupt.
        constexpr uint32_t APP_CTRL0_INT_CLR = (1U << 7);  ///< Set this bit to clear UHCI_APP_CTRL0_INT interrupt.
        constexpr uint32_t APP_CTRL1_INT_CLR = (1U << 8);  ///< Set this bit to clear UHCI_APP_CTRL1_INT interrupt.
    }

    /// APP_INT_SET Register bits
    namespace app_int_set_bits {
        constexpr uint32_t APP_CTRL0_INT_SET = (1U << 0);  ///< This bit is software interrupt trigger source of UHCI_APP_CTRL0_INT.
        constexpr uint32_t APP_CTRL1_INT_SET = (1U << 1);  ///< This bit is software interrupt trigger source of UHCI_APP_CTRL1_INT.
    }

    /// CONF1 Register bits
    namespace conf1_bits {
        constexpr uint32_t CHECK_SUM_EN = (1U << 0);  ///< This is the enable bit to check header checksum when UHCI receives a data packet.
        constexpr uint32_t CHECK_SEQ_EN = (1U << 1);  ///< This is the enable bit to check sequence number when UHCI receives a data packet.
        constexpr uint32_t CRC_DISABLE = (1U << 2);  ///< Set this bit to support CRC calculation. Data Integrity Check Present bit in UHCI packet frame should be 1.
        constexpr uint32_t SAVE_HEAD = (1U << 3);  ///< Set this bit to save the packet header when HCI receives a data packet.
        constexpr uint32_t TX_CHECK_SUM_RE = (1U << 4);  ///< Set this bit to encode the data packet with a checksum.
        constexpr uint32_t TX_ACK_NUM_RE = (1U << 5);  ///< Set this bit to encode the data packet with an acknowledgment when a reliable packet is to be transmit.
        constexpr uint32_t WAIT_SW_START = (1U << 7);  ///< The uhci-encoder will jump to ST_SW_WAIT status if this register is set to 1.
        constexpr uint32_t SW_START = (1U << 8);  ///< If current UHCI_ENCODE_STATE is ST_SW_WAIT, the UHCI will start to send data packet out when this bit is set to 1.
    }

    /// STATE0 Register bits
    namespace state0_bits {
        constexpr uint32_t RX_ERR_CAUSE = (3 << 0);  ///< This register indicates the error type when DMA has received a packet with error. 3'b001: Checksum error in HCI packet. 3'b010: Sequence number error in HCI packet. 3'b011: CRC bit error in HCI packet. 3'b100: 0xc0 is found but received HCI packet is not end. 3'b101: 0xc0 is not found when receiving HCI packet is end. 3'b110: CRC check error.
        constexpr uint32_t DECODE_STATE = (3 << 3);  ///< UHCI decoder status.
    }

    /// STATE1 Register bits
    namespace state1_bits {
        constexpr uint32_t ENCODE_STATE = (3 << 0);  ///< UHCI encoder status.
    }

    /// ESCAPE_CONF Register bits
    namespace escape_conf_bits {
        constexpr uint32_t TX_C0_ESC_EN = (1U << 0);  ///< Set this bit to enable decoding char 0xc0 when DMA receives data.
        constexpr uint32_t TX_DB_ESC_EN = (1U << 1);  ///< Set this bit to enable decoding char 0xdb when DMA receives data.
        constexpr uint32_t TX_11_ESC_EN = (1U << 2);  ///< Set this bit to enable decoding flow control char 0x11 when DMA receives data.
        constexpr uint32_t TX_13_ESC_EN = (1U << 3);  ///< Set this bit to enable decoding flow control char 0x13 when DMA receives data.
        constexpr uint32_t RX_C0_ESC_EN = (1U << 4);  ///< Set this bit to enable replacing 0xc0 by special char when DMA sends data.
        constexpr uint32_t RX_DB_ESC_EN = (1U << 5);  ///< Set this bit to enable replacing 0xdb by special char when DMA sends data.
        constexpr uint32_t RX_11_ESC_EN = (1U << 6);  ///< Set this bit to enable replacing flow control char 0x11 by special char when DMA sends data.
        constexpr uint32_t RX_13_ESC_EN = (1U << 7);  ///< Set this bit to enable replacing flow control char 0x13 by special char when DMA sends data.
    }

    /// HUNG_CONF Register bits
    namespace hung_conf_bits {
        constexpr uint32_t TXFIFO_TIMEOUT = (8 << 0);  ///< This register stores the timeout value. It will produce the UHCI_TX_HUNG_INT interrupt when DMA takes more time to receive data.
        constexpr uint32_t TXFIFO_TIMEOUT_SHIFT = (3 << 8);  ///< This register is used to configure the tick count maximum value.
        constexpr uint32_t TXFIFO_TIMEOUT_ENA = (1U << 11);  ///< This is the enable bit for Tx-FIFO receive-data timeout.
        constexpr uint32_t RXFIFO_TIMEOUT = (8 << 12);  ///< This register stores the timeout value. It will produce the UHCI_RX_HUNG_INT interrupt when DMA takes more time to read data from RAM.
        constexpr uint32_t RXFIFO_TIMEOUT_SHIFT = (3 << 20);  ///< This register is used to configure the tick count maximum value.
        constexpr uint32_t RXFIFO_TIMEOUT_ENA = (1U << 23);  ///< This is the enable bit for DMA send-data timeout.
    }

    /// ACK_NUM Register bits
    namespace ack_num_bits {
        constexpr uint32_t ACK_NUM = (3 << 0);  ///< This ACK number used in software flow control.
        constexpr uint32_t LOAD = (1U << 3);  ///< Set this bit to 1, the value configured by UHCI_ACK_NUM would be loaded.
    }

    /// RX_HEAD Register bits
    namespace rx_head_bits {
        constexpr uint32_t RX_HEAD = (32 << 0);  ///< This register stores the header of the current received packet.
    }

    /// QUICK_SENT Register bits
    namespace quick_sent_bits {
        constexpr uint32_t SINGLE_SEND_NUM = (3 << 0);  ///< This register is used to specify the single_send register.
        constexpr uint32_t SINGLE_SEND_EN = (1U << 3);  ///< Set this bit to enable single_send mode to send short packet.
        constexpr uint32_t ALWAYS_SEND_NUM = (3 << 4);  ///< This register is used to specify the always_send register.
        constexpr uint32_t ALWAYS_SEND_EN = (1U << 7);  ///< Set this bit to enable always_send mode to send short packet.
    }

    /// REG_Q0_WORD0 Register bits
    namespace reg_q0_word0_bits {
        constexpr uint32_t SEND_Q0_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q0_WORD1 Register bits
    namespace reg_q0_word1_bits {
        constexpr uint32_t SEND_Q0_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q1_WORD0 Register bits
    namespace reg_q1_word0_bits {
        constexpr uint32_t SEND_Q1_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q1_WORD1 Register bits
    namespace reg_q1_word1_bits {
        constexpr uint32_t SEND_Q1_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q2_WORD0 Register bits
    namespace reg_q2_word0_bits {
        constexpr uint32_t SEND_Q2_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q2_WORD1 Register bits
    namespace reg_q2_word1_bits {
        constexpr uint32_t SEND_Q2_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q3_WORD0 Register bits
    namespace reg_q3_word0_bits {
        constexpr uint32_t SEND_Q3_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q3_WORD1 Register bits
    namespace reg_q3_word1_bits {
        constexpr uint32_t SEND_Q3_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q4_WORD0 Register bits
    namespace reg_q4_word0_bits {
        constexpr uint32_t SEND_Q4_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q4_WORD1 Register bits
    namespace reg_q4_word1_bits {
        constexpr uint32_t SEND_Q4_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q5_WORD0 Register bits
    namespace reg_q5_word0_bits {
        constexpr uint32_t SEND_Q5_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q5_WORD1 Register bits
    namespace reg_q5_word1_bits {
        constexpr uint32_t SEND_Q5_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q6_WORD0 Register bits
    namespace reg_q6_word0_bits {
        constexpr uint32_t SEND_Q6_WORD0 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// REG_Q6_WORD1 Register bits
    namespace reg_q6_word1_bits {
        constexpr uint32_t SEND_Q6_WORD1 = (32 << 0);  ///< This register is used as a quick_sent register when specified by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
    }

    /// ESC_CONF0 Register bits
    namespace esc_conf0_bits {
        constexpr uint32_t SEPER_CHAR = (8 << 0);  ///< This register is used to define the separate char that need to be encoded, default is 0xc0.
        constexpr uint32_t SEPER_ESC_CHAR0 = (8 << 8);  ///< This register is used to define the first char of slip escape sequence when encoding the separate char, default is 0xdb.
        constexpr uint32_t SEPER_ESC_CHAR1 = (8 << 16);  ///< This register is used to define the second char of slip escape sequence when encoding the separate char, default is 0xdc.
    }

    /// ESC_CONF1 Register bits
    namespace esc_conf1_bits {
        constexpr uint32_t ESC_SEQ0 = (8 << 0);  ///< This register is used to define a char that need to be encoded, default is 0xdb that used as the first char of slip escape sequence.
        constexpr uint32_t ESC_SEQ0_CHAR0 = (8 << 8);  ///< This register is used to define the first char of slip escape sequence when encoding the UHCI_ESC_SEQ0, default is 0xdb.
        constexpr uint32_t ESC_SEQ0_CHAR1 = (8 << 16);  ///< This register is used to define the second char of slip escape sequence when encoding the UHCI_ESC_SEQ0, default is 0xdd.
    }

    /// ESC_CONF2 Register bits
    namespace esc_conf2_bits {
        constexpr uint32_t ESC_SEQ1 = (8 << 0);  ///< This register is used to define a char that need to be encoded, default is 0x11 that used as flow control char.
        constexpr uint32_t ESC_SEQ1_CHAR0 = (8 << 8);  ///< This register is used to define the first char of slip escape sequence when encoding the UHCI_ESC_SEQ1, default is 0xdb.
        constexpr uint32_t ESC_SEQ1_CHAR1 = (8 << 16);  ///< This register is used to define the second char of slip escape sequence when encoding the UHCI_ESC_SEQ1, default is 0xde.
    }

    /// ESC_CONF3 Register bits
    namespace esc_conf3_bits {
        constexpr uint32_t ESC_SEQ2 = (8 << 0);  ///< This register is used to define a char that need to be decoded, default is 0x13 that used as flow control char.
        constexpr uint32_t ESC_SEQ2_CHAR0 = (8 << 8);  ///< This register is used to define the first char of slip escape sequence when encoding the UHCI_ESC_SEQ2, default is 0xdb.
        constexpr uint32_t ESC_SEQ2_CHAR1 = (8 << 16);  ///< This register is used to define the second char of slip escape sequence when encoding the UHCI_ESC_SEQ2, default is 0xdf.
    }

    /// PKT_THRES Register bits
    namespace pkt_thres_bits {
        constexpr uint32_t PKT_THRS = (13 << 0);  ///< This register is used to configure the maximum value of the packet length when UHCI_HEAD_EN is 0.
    }

    /// DATE Register bits
    namespace date_bits {
        constexpr uint32_t DATE = (32 << 0);  ///< This is the version control register.
    }

}

// ============================================================================
// UHCI1 Peripheral
// ============================================================================

namespace uhci1 {
    /// Base addresses
    constexpr uint32_t UHCI1_BASE = 0x6000C000;

    /// UHCI1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* UHCI1 = reinterpret_cast<Registers*>(UHCI1_BASE);

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x60080000;
    constexpr uint32_t USB_DEVICE_BASE = 0x60038000;
    constexpr uint32_t USB_WRAP_BASE = 0x60039000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - 
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - 
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - 
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - 
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - 
        volatile uint32_t GINTSTS;  ///< Offset: 0x14 - 
        volatile uint32_t GINTMSK;  ///< Offset: 0x18 - 
        volatile uint32_t GRXSTSR;  ///< Offset: 0x1C - 
        volatile uint32_t GRXSTSP;  ///< Offset: 0x20 - 
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - 
        volatile uint32_t GNPTXFSIZ;  ///< Offset: 0x28 - 
        volatile uint32_t GNPTXSTS;  ///< Offset: 0x2C - 
        volatile uint32_t GSNPSID;  ///< Offset: 0x40 - 
        volatile uint32_t GHWCFG1;  ///< Offset: 0x44 - 
        volatile uint32_t GHWCFG2;  ///< Offset: 0x48 - 
        volatile uint32_t GHWCFG3;  ///< Offset: 0x4C - 
        volatile uint32_t GHWCFG4;  ///< Offset: 0x50 - 
        volatile uint32_t GDFIFOCFG;  ///< Offset: 0x5C - 
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - 
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - 
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - 
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - 
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - 
        volatile uint32_t HCFG;  ///< Offset: 0x400 - 
        volatile uint32_t HFIR;  ///< Offset: 0x404 - 
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - 
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - 
        volatile uint32_t HAINT;  ///< Offset: 0x414 - 
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - 
        volatile uint32_t HFLBADDR;  ///< Offset: 0x41C - 
        volatile uint32_t HPRT;  ///< Offset: 0x440 - 
        volatile uint32_t HCCHAR0;  ///< Offset: 0x500 - 
        volatile uint32_t HCINT0;  ///< Offset: 0x508 - 
        volatile uint32_t HCINTMSK0;  ///< Offset: 0x50C - 
        volatile uint32_t HCTSIZ0;  ///< Offset: 0x510 - 
        volatile uint32_t HCDMA0;  ///< Offset: 0x514 - 
        volatile uint32_t HCDMAB0;  ///< Offset: 0x51C - 
        volatile uint32_t HCCHAR1;  ///< Offset: 0x520 - 
        volatile uint32_t HCINT1;  ///< Offset: 0x528 - 
        volatile uint32_t HCINTMSK1;  ///< Offset: 0x52C - 
        volatile uint32_t HCTSIZ1;  ///< Offset: 0x530 - 
        volatile uint32_t HCDMA1;  ///< Offset: 0x534 - 
        volatile uint32_t HCDMAB1;  ///< Offset: 0x53C - 
        volatile uint32_t HCCHAR2;  ///< Offset: 0x540 - 
        volatile uint32_t HCINT2;  ///< Offset: 0x548 - 
        volatile uint32_t HCINTMSK2;  ///< Offset: 0x54C - 
        volatile uint32_t HCTSIZ2;  ///< Offset: 0x550 - 
        volatile uint32_t HCDMA2;  ///< Offset: 0x554 - 
        volatile uint32_t HCDMAB2;  ///< Offset: 0x55C - 
        volatile uint32_t HCCHAR3;  ///< Offset: 0x560 - 
        volatile uint32_t HCINT3;  ///< Offset: 0x568 - 
        volatile uint32_t HCINTMSK3;  ///< Offset: 0x56C - 
        volatile uint32_t HCTSIZ3;  ///< Offset: 0x570 - 
        volatile uint32_t HCDMA3;  ///< Offset: 0x574 - 
        volatile uint32_t HCDMAB3;  ///< Offset: 0x57C - 
        volatile uint32_t HCCHAR4;  ///< Offset: 0x580 - 
        volatile uint32_t HCINT4;  ///< Offset: 0x588 - 
        volatile uint32_t HCINTMSK4;  ///< Offset: 0x58C - 
        volatile uint32_t HCTSIZ4;  ///< Offset: 0x590 - 
        volatile uint32_t HCDMA4;  ///< Offset: 0x594 - 
        volatile uint32_t HCDMAB4;  ///< Offset: 0x59C - 
        volatile uint32_t HCCHAR5;  ///< Offset: 0x5A0 - 
        volatile uint32_t HCINT5;  ///< Offset: 0x5A8 - 
        volatile uint32_t HCINTMSK5;  ///< Offset: 0x5AC - 
        volatile uint32_t HCTSIZ5;  ///< Offset: 0x5B0 - 
        volatile uint32_t HCDMA5;  ///< Offset: 0x5B4 - 
        volatile uint32_t HCDMAB5;  ///< Offset: 0x5BC - 
        volatile uint32_t HCCHAR6;  ///< Offset: 0x5C0 - 
        volatile uint32_t HCINT6;  ///< Offset: 0x5C8 - 
        volatile uint32_t HCINTMSK6;  ///< Offset: 0x5CC - 
        volatile uint32_t HCTSIZ6;  ///< Offset: 0x5D0 - 
        volatile uint32_t HCDMA6;  ///< Offset: 0x5D4 - 
        volatile uint32_t HCDMAB6;  ///< Offset: 0x5DC - 
        volatile uint32_t HCCHAR7;  ///< Offset: 0x5E0 - 
        volatile uint32_t HCINT7;  ///< Offset: 0x5E8 - 
        volatile uint32_t HCINTMSK7;  ///< Offset: 0x5EC - 
        volatile uint32_t HCTSIZ7;  ///< Offset: 0x5F0 - 
        volatile uint32_t HCDMA7;  ///< Offset: 0x5F4 - 
        volatile uint32_t HCDMAB7;  ///< Offset: 0x5FC - 
        volatile uint32_t DCFG;  ///< Offset: 0x800 - 
        volatile uint32_t DCTL;  ///< Offset: 0x804 - 
        volatile uint32_t DSTS;  ///< Offset: 0x808 - 
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - 
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - 
        volatile uint32_t DAINT;  ///< Offset: 0x818 - 
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - 
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - 
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - 
        volatile uint32_t DTHRCTL;  ///< Offset: 0x830 - 
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - 
        volatile uint32_t DIEPCTL0;  ///< Offset: 0x900 - 
        volatile uint32_t DIEPINT0;  ///< Offset: 0x908 - 
        volatile uint32_t DIEPTSIZ0;  ///< Offset: 0x910 - 
        volatile uint32_t DIEPDMA0;  ///< Offset: 0x914 - 
        volatile uint32_t DTXFSTS0;  ///< Offset: 0x918 - 
        volatile uint32_t DIEPDMAB0;  ///< Offset: 0x91C - 
        volatile uint32_t DIEPCTL1;  ///< Offset: 0x920 - 
        volatile uint32_t DIEPINT1;  ///< Offset: 0x928 - 
        volatile uint32_t DIEPTSIZ1;  ///< Offset: 0x930 - 
        volatile uint32_t DIEPDMA1;  ///< Offset: 0x934 - 
        volatile uint32_t DTXFSTS1;  ///< Offset: 0x938 - 
        volatile uint32_t DIEPDMAB1;  ///< Offset: 0x93C - 
        volatile uint32_t DIEPCTL2;  ///< Offset: 0x940 - 
        volatile uint32_t DIEPINT2;  ///< Offset: 0x948 - 
        volatile uint32_t DIEPTSIZ2;  ///< Offset: 0x950 - 
        volatile uint32_t DIEPDMA2;  ///< Offset: 0x954 - 
        volatile uint32_t DTXFSTS2;  ///< Offset: 0x958 - 
        volatile uint32_t DIEPDMAB2;  ///< Offset: 0x95C - 
        volatile uint32_t DIEPCTL3;  ///< Offset: 0x960 - 
        volatile uint32_t DIEPINT3;  ///< Offset: 0x968 - 
        volatile uint32_t DIEPTSIZ3;  ///< Offset: 0x970 - 
        volatile uint32_t DIEPDMA3;  ///< Offset: 0x974 - 
        volatile uint32_t DTXFSTS3;  ///< Offset: 0x978 - 
        volatile uint32_t DIEPDMAB3;  ///< Offset: 0x97C - 
        volatile uint32_t DIEPCTL4;  ///< Offset: 0x980 - 
        volatile uint32_t DIEPINT4;  ///< Offset: 0x988 - 
        volatile uint32_t DIEPTSIZ4;  ///< Offset: 0x990 - 
        volatile uint32_t DIEPDMA4;  ///< Offset: 0x994 - 
        volatile uint32_t DTXFSTS4;  ///< Offset: 0x998 - 
        volatile uint32_t DIEPDMAB4;  ///< Offset: 0x99C - 
        volatile uint32_t DIEPCTL5;  ///< Offset: 0x9A0 - 
        volatile uint32_t DIEPINT5;  ///< Offset: 0x9A8 - 
        volatile uint32_t DIEPTSIZ5;  ///< Offset: 0x9B0 - 
        volatile uint32_t DIEPDMA5;  ///< Offset: 0x9B4 - 
        volatile uint32_t DTXFSTS5;  ///< Offset: 0x9B8 - 
        volatile uint32_t DIEPDMAB5;  ///< Offset: 0x9BC - 
        volatile uint32_t DIEPCTL6;  ///< Offset: 0x9C0 - 
        volatile uint32_t DIEPINT6;  ///< Offset: 0x9C8 - 
        volatile uint32_t DIEPTSIZ6;  ///< Offset: 0x9D0 - 
        volatile uint32_t DIEPDMA6;  ///< Offset: 0x9D4 - 
        volatile uint32_t DTXFSTS6;  ///< Offset: 0x9D8 - 
        volatile uint32_t DIEPDMAB6;  ///< Offset: 0x9DC - 
        volatile uint32_t DOEPCTL0;  ///< Offset: 0xB00 - 
        volatile uint32_t DOEPINT0;  ///< Offset: 0xB08 - 
        volatile uint32_t DOEPTSIZ0;  ///< Offset: 0xB10 - 
        volatile uint32_t DOEPDMA0;  ///< Offset: 0xB14 - 
        volatile uint32_t DOEPDMAB0;  ///< Offset: 0xB1C - 
        volatile uint32_t DOEPCTL1;  ///< Offset: 0xB20 - 
        volatile uint32_t DOEPINT1;  ///< Offset: 0xB28 - 
        volatile uint32_t DOEPTSIZ1;  ///< Offset: 0xB30 - 
        volatile uint32_t DOEPDMA1;  ///< Offset: 0xB34 - 
        volatile uint32_t DOEPDMAB1;  ///< Offset: 0xB3C - 
        volatile uint32_t DOEPCTL2;  ///< Offset: 0xB40 - 
        volatile uint32_t DOEPINT2;  ///< Offset: 0xB48 - 
        volatile uint32_t DOEPTSIZ2;  ///< Offset: 0xB50 - 
        volatile uint32_t DOEPDMA2;  ///< Offset: 0xB54 - 
        volatile uint32_t DOEPDMAB2;  ///< Offset: 0xB5C - 
        volatile uint32_t DOEPCTL3;  ///< Offset: 0xB60 - 
        volatile uint32_t DOEPINT3;  ///< Offset: 0xB68 - 
        volatile uint32_t DOEPTSIZ3;  ///< Offset: 0xB70 - 
        volatile uint32_t DOEPDMA3;  ///< Offset: 0xB74 - 
        volatile uint32_t DOEPDMAB3;  ///< Offset: 0xB7C - 
        volatile uint32_t DOEPCTL4;  ///< Offset: 0xB80 - 
        volatile uint32_t DOEPINT4;  ///< Offset: 0xB88 - 
        volatile uint32_t DOEPTSIZ4;  ///< Offset: 0xB90 - 
        volatile uint32_t DOEPDMA4;  ///< Offset: 0xB94 - 
        volatile uint32_t DOEPDMAB4;  ///< Offset: 0xB9C - 
        volatile uint32_t DOEPCTL5;  ///< Offset: 0xBA0 - 
        volatile uint32_t DOEPINT5;  ///< Offset: 0xBA8 - 
        volatile uint32_t DOEPTSIZ5;  ///< Offset: 0xBB0 - 
        volatile uint32_t DOEPDMA5;  ///< Offset: 0xBB4 - 
        volatile uint32_t DOEPDMAB5;  ///< Offset: 0xBBC - 
        volatile uint32_t DOEPCTL6;  ///< Offset: 0xBC0 - 
        volatile uint32_t DOEPINT6;  ///< Offset: 0xBC8 - 
        volatile uint32_t DOEPTSIZ6;  ///< Offset: 0xBD0 - 
        volatile uint32_t DOEPDMA6;  ///< Offset: 0xBD4 - 
        volatile uint32_t DOEPDMAB6;  ///< Offset: 0xBDC - 
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - 
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);
    inline Registers* USB_DEVICE = reinterpret_cast<Registers*>(USB_DEVICE_BASE);
    inline Registers* USB_WRAP = reinterpret_cast<Registers*>(USB_WRAP_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SESREQSCS = (1U << 0);  ///< SESREQSCS
        constexpr uint32_t SESREQ = (1U << 1);  ///< SESREQ
        constexpr uint32_t VBVALIDOVEN = (1U << 2);  ///< VBVALIDOVEN
        constexpr uint32_t VBVALIDOVVAL = (1U << 3);  ///< VBVALIDOVVAL
        constexpr uint32_t AVALIDOVEN = (1U << 4);  ///< AVALIDOVEN
        constexpr uint32_t AVALIDOVVAL = (1U << 5);  ///< AVALIDOVVAL
        constexpr uint32_t BVALIDOVEN = (1U << 6);  ///< BVALIDOVEN
        constexpr uint32_t BVALIDOVVAL = (1U << 7);  ///< BVALIDOVVAL
        constexpr uint32_t HSTNEGSCS = (1U << 8);  ///< HSTNEGSCS
        constexpr uint32_t HNPREQ = (1U << 9);  ///< HNPREQ
        constexpr uint32_t HSTSETHNPEN = (1U << 10);  ///< HSTSETHNPEN
        constexpr uint32_t DEVHNPEN = (1U << 11);  ///< DEVHNPEN
        constexpr uint32_t EHEN = (1U << 12);  ///< EHEN
        constexpr uint32_t DBNCEFLTRBYPASS = (1U << 15);  ///< DBNCEFLTRBYPASS
        constexpr uint32_t CONIDSTS = (1U << 16);  ///< CONIDSTS
        constexpr uint32_t DBNCTIME = (1U << 17);  ///< DBNCTIME
        constexpr uint32_t ASESVLD = (1U << 18);  ///< ASESVLD
        constexpr uint32_t BSESVLD = (1U << 19);  ///< BSESVLD
        constexpr uint32_t OTGVER = (1U << 20);  ///< OTGVER
        constexpr uint32_t CURMOD = (1U << 21);  ///< CURMOD
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SESENDDET = (1U << 2);  ///< SESENDDET
        constexpr uint32_t SESREQSUCSTSCHNG = (1U << 8);  ///< SESREQSUCSTSCHNG
        constexpr uint32_t HSTNEGSUCSTSCHNG = (1U << 9);  ///< HSTNEGSUCSTSCHNG
        constexpr uint32_t HSTNEGDET = (1U << 17);  ///< HSTNEGDET
        constexpr uint32_t ADEVTOUTCHG = (1U << 18);  ///< ADEVTOUTCHG
        constexpr uint32_t DBNCEDONE = (1U << 19);  ///< DBNCEDONE
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GLBLLNTRMSK = (1U << 0);  ///< GLBLLNTRMSK
        constexpr uint32_t HBSTLEN = (4 << 1);  ///< HBSTLEN
        constexpr uint32_t DMAEN = (1U << 5);  ///< DMAEN
        constexpr uint32_t NPTXFEMPLVL = (1U << 7);  ///< NPTXFEMPLVL
        constexpr uint32_t PTXFEMPLVL = (1U << 8);  ///< PTXFEMPLVL
        constexpr uint32_t REMMEMSUPP = (1U << 21);  ///< REMMEMSUPP
        constexpr uint32_t NOTIALLDMAWRIT = (1U << 22);  ///< NOTIALLDMAWRIT
        constexpr uint32_t AHBSINGLE = (1U << 23);  ///< AHBSINGLE
        constexpr uint32_t INVDESCENDIANESS = (1U << 24);  ///< INVDESCENDIANESS
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOUTCAL = (3 << 0);  ///< TOUTCAL
        constexpr uint32_t PHYIF = (1U << 3);  ///< PHYIF
        constexpr uint32_t ULPI_UTMI_SEL = (1U << 4);  ///< ULPI_UTMI_SEL
        constexpr uint32_t FSINTF = (1U << 5);  ///< FSINTF
        constexpr uint32_t PHYSEL = (1U << 6);  ///< PHYSEL
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRPCAP
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNPCAP
        constexpr uint32_t USBTRDTIM = (4 << 10);  ///< USBTRDTIM
        constexpr uint32_t TERMSELDLPULSE = (1U << 22);  ///< TERMSELDLPULSE
        constexpr uint32_t TXENDDELAY = (1U << 28);  ///< TXENDDELAY
        constexpr uint32_t FORCEHSTMODE = (1U << 29);  ///< FORCEHSTMODE
        constexpr uint32_t FORCEDEVMODE = (1U << 30);  ///< FORCEDEVMODE
        constexpr uint32_t CORRUPTTXPKT = (1U << 31);  ///< CORRUPTTXPKT
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSFTRST = (1U << 0);  ///< CSFTRST
        constexpr uint32_t PIUFSSFTRST = (1U << 1);  ///< PIUFSSFTRST
        constexpr uint32_t FRMCNTRRST = (1U << 2);  ///< FRMCNTRRST
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RXFFLSH
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TXFFLSH
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TXFNUM
        constexpr uint32_t DMAREQ = (1U << 30);  ///< DMAREQ
        constexpr uint32_t AHBIDLE = (1U << 31);  ///< AHBIDLE
    }

    /// GINTSTS Register bits
    namespace gintsts_bits {
        constexpr uint32_t CURMOD_INT = (1U << 0);  ///< CURMOD_INT
        constexpr uint32_t MODEMIS = (1U << 1);  ///< MODEMIS
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOF = (1U << 3);  ///< SOF
        constexpr uint32_t RXFLVI = (1U << 4);  ///< RXFLVI
        constexpr uint32_t NPTXFEMP = (1U << 5);  ///< NPTXFEMP
        constexpr uint32_t GINNAKEFF = (1U << 6);  ///< GINNAKEFF
        constexpr uint32_t GOUTNAKEFF = (1U << 7);  ///< GOUTNAKEFF
        constexpr uint32_t ERLYSUSP = (1U << 10);  ///< ERLYSUSP
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USBSUSP
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDONE = (1U << 13);  ///< ENUMDONE
        constexpr uint32_t ISOOUTDROP = (1U << 14);  ///< ISOOUTDROP
        constexpr uint32_t EOPF = (1U << 15);  ///< EOPF
        constexpr uint32_t EPMIS = (1U << 17);  ///< EPMIS
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t INCOMPISOIN = (1U << 20);  ///< INCOMPISOIN
        constexpr uint32_t INCOMPIP = (1U << 21);  ///< INCOMPIP
        constexpr uint32_t FETSUSP = (1U << 22);  ///< FETSUSP
        constexpr uint32_t RESETDET = (1U << 23);  ///< RESETDET
        constexpr uint32_t PRTLNT = (1U << 24);  ///< PRTLNT
        constexpr uint32_t HCHLNT = (1U << 25);  ///< HCHLNT
        constexpr uint32_t PTXFEMP = (1U << 26);  ///< PTXFEMP
        constexpr uint32_t CONIDSTSCHNG = (1U << 28);  ///< CONIDSTSCHNG
        constexpr uint32_t DISCONNINT = (1U << 29);  ///< DISCONNINT
        constexpr uint32_t SESSREQINT = (1U << 30);  ///< SESSREQINT
        constexpr uint32_t WKUPINT = (1U << 31);  ///< WKUPINT
    }

    /// GINTMSK Register bits
    namespace gintmsk_bits {
        constexpr uint32_t MODEMISMSK = (1U << 1);  ///< MODEMISMSK
        constexpr uint32_t OTGINTMSK = (1U << 2);  ///< OTGINTMSK
        constexpr uint32_t SOFMSK = (1U << 3);  ///< SOFMSK
        constexpr uint32_t RXFLVIMSK = (1U << 4);  ///< RXFLVIMSK
        constexpr uint32_t NPTXFEMPMSK = (1U << 5);  ///< NPTXFEMPMSK
        constexpr uint32_t GINNAKEFFMSK = (1U << 6);  ///< GINNAKEFFMSK
        constexpr uint32_t GOUTNACKEFFMSK = (1U << 7);  ///< GOUTNACKEFFMSK
        constexpr uint32_t ERLYSUSPMSK = (1U << 10);  ///< ERLYSUSPMSK
        constexpr uint32_t USBSUSPMSK = (1U << 11);  ///< USBSUSPMSK
        constexpr uint32_t USBRSTMSK = (1U << 12);  ///< USBRSTMSK
        constexpr uint32_t ENUMDONEMSK = (1U << 13);  ///< ENUMDONEMSK
        constexpr uint32_t ISOOUTDROPMSK = (1U << 14);  ///< ISOOUTDROPMSK
        constexpr uint32_t EOPFMSK = (1U << 15);  ///< EOPFMSK
        constexpr uint32_t EPMISMSK = (1U << 17);  ///< EPMISMSK
        constexpr uint32_t IEPINTMSK = (1U << 18);  ///< IEPINTMSK
        constexpr uint32_t OEPINTMSK = (1U << 19);  ///< OEPINTMSK
        constexpr uint32_t INCOMPISOINMSK = (1U << 20);  ///< INCOMPISOINMSK
        constexpr uint32_t INCOMPIPMSK = (1U << 21);  ///< INCOMPIPMSK
        constexpr uint32_t FETSUSPMSK = (1U << 22);  ///< FETSUSPMSK
        constexpr uint32_t RESETDETMSK = (1U << 23);  ///< RESETDETMSK
        constexpr uint32_t PRTLNTMSK = (1U << 24);  ///< PRTLNTMSK
        constexpr uint32_t HCHINTMSK = (1U << 25);  ///< HCHINTMSK
        constexpr uint32_t PTXFEMPMSK = (1U << 26);  ///< PTXFEMPMSK
        constexpr uint32_t CONIDSTSCHNGMSK = (1U << 28);  ///< CONIDSTSCHNGMSK
        constexpr uint32_t DISCONNINTMSK = (1U << 29);  ///< DISCONNINTMSK
        constexpr uint32_t SESSREQINTMSK = (1U << 30);  ///< SESSREQINTMSK
        constexpr uint32_t WKUPINTMSK = (1U << 31);  ///< WKUPINTMSK
    }

    /// GRXSTSR Register bits
    namespace grxstsr_bits {
        constexpr uint32_t G_CHNUM = (4 << 0);  ///< G_CHNUM
        constexpr uint32_t G_BCNT = (11 << 4);  ///< G_BCNT
        constexpr uint32_t G_DPID = (2 << 15);  ///< G_DPID
        constexpr uint32_t G_PKTSTS = (4 << 17);  ///< G_PKTSTS
        constexpr uint32_t G_FN = (4 << 21);  ///< G_FN
    }

    /// GRXSTSP Register bits
    namespace grxstsp_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FN = (4 << 21);  ///< FN
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RXFDEP = (16 << 0);  ///< RXFDEP
    }

    /// GNPTXFSIZ Register bits
    namespace gnptxfsiz_bits {
        constexpr uint32_t NPTXFSTADDR = (16 << 0);  ///< NPTXFSTADDR
        constexpr uint32_t NPTXFDEP = (16 << 16);  ///< NPTXFDEP
    }

    /// GNPTXSTS Register bits
    namespace gnptxsts_bits {
        constexpr uint32_t NPTXFSPCAVAIL = (16 << 0);  ///< NPTXFSPCAVAIL
        constexpr uint32_t NPTXQSPCAVAIL = (4 << 16);  ///< NPTXQSPCAVAIL
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< NPTXQTOP
    }

    /// GSNPSID Register bits
    namespace gsnpsid_bits {
        constexpr uint32_t SYNOPSYSID = (32 << 0);  ///< SYNOPSYSID
    }

    /// GHWCFG1 Register bits
    namespace ghwcfg1_bits {
        constexpr uint32_t EPDIR = (32 << 0);  ///< EPDIR
    }

    /// GHWCFG2 Register bits
    namespace ghwcfg2_bits {
        constexpr uint32_t OTGMODE = (3 << 0);  ///< OTGMODE
        constexpr uint32_t OTGARCH = (2 << 3);  ///< OTGARCH
        constexpr uint32_t SINGPNT = (1U << 5);  ///< SINGPNT
        constexpr uint32_t HSPHYTYPE = (2 << 6);  ///< HSPHYTYPE
        constexpr uint32_t FSPHYTYPE = (2 << 8);  ///< FSPHYTYPE
        constexpr uint32_t NUMDEVEPS = (4 << 10);  ///< NUMDEVEPS
        constexpr uint32_t NUMHSTCHNL = (4 << 14);  ///< NUMHSTCHNL
        constexpr uint32_t PERIOSUPPORT = (1U << 18);  ///< PERIOSUPPORT
        constexpr uint32_t DYNFIFOSIZING = (1U << 19);  ///< DYNFIFOSIZING
        constexpr uint32_t MULTIPROCINTRPT = (1U << 20);  ///< MULTIPROCINTRPT
        constexpr uint32_t NPTXQDEPTH = (2 << 22);  ///< NPTXQDEPTH
        constexpr uint32_t PTXQDEPTH = (2 << 24);  ///< PTXQDEPTH
        constexpr uint32_t TKNQDEPTH = (5 << 26);  ///< TKNQDEPTH
        constexpr uint32_t OTG_ENABLE_IC_USB = (1U << 31);  ///< OTG_ENABLE_IC_USB
    }

    /// GHWCFG3 Register bits
    namespace ghwcfg3_bits {
        constexpr uint32_t XFERSIZEWIDTH = (4 << 0);  ///< XFERSIZEWIDTH
        constexpr uint32_t PKTSIZEWIDTH = (3 << 4);  ///< PKTSIZEWIDTH
        constexpr uint32_t OTGEN = (1U << 7);  ///< OTGEN
        constexpr uint32_t I2CINTSEL = (1U << 8);  ///< I2CINTSEL
        constexpr uint32_t VNDCTLSUPT = (1U << 9);  ///< VNDCTLSUPT
        constexpr uint32_t OPTFEATURE = (1U << 10);  ///< OPTFEATURE
        constexpr uint32_t RSTTYPE = (1U << 11);  ///< RSTTYPE
        constexpr uint32_t ADPSUPPORT = (1U << 12);  ///< ADPSUPPORT
        constexpr uint32_t HSICMODE = (1U << 13);  ///< HSICMODE
        constexpr uint32_t BCSUPPORT = (1U << 14);  ///< BCSUPPORT
        constexpr uint32_t LPMMODE = (1U << 15);  ///< LPMMODE
        constexpr uint32_t DFIFODEPTH = (16 << 16);  ///< DFIFODEPTH
    }

    /// GHWCFG4 Register bits
    namespace ghwcfg4_bits {
        constexpr uint32_t G_NUMDEVPERIOEPS = (4 << 0);  ///< G_NUMDEVPERIOEPS
        constexpr uint32_t G_PARTIALPWRDN = (1U << 4);  ///< G_PARTIALPWRDN
        constexpr uint32_t G_AHBFREQ = (1U << 5);  ///< G_AHBFREQ
        constexpr uint32_t G_HIBERNATION = (1U << 6);  ///< G_HIBERNATION
        constexpr uint32_t G_EXTENDEDHIBERNATION = (1U << 7);  ///< G_EXTENDEDHIBERNATION
        constexpr uint32_t G_ACGSUPT = (1U << 12);  ///< G_ACGSUPT
        constexpr uint32_t G_ENHANCEDLPMSUPT = (1U << 13);  ///< G_ENHANCEDLPMSUPT
        constexpr uint32_t G_PHYDATAWIDTH = (2 << 14);  ///< G_PHYDATAWIDTH
        constexpr uint32_t G_NUMCTLEPS = (4 << 16);  ///< G_NUMCTLEPS
        constexpr uint32_t G_IDDQFLTR = (1U << 20);  ///< G_IDDQFLTR
        constexpr uint32_t G_VBUSVALIDFLTR = (1U << 21);  ///< G_VBUSVALIDFLTR
        constexpr uint32_t G_AVALIDFLTR = (1U << 22);  ///< G_AVALIDFLTR
        constexpr uint32_t G_BVALIDFLTR = (1U << 23);  ///< G_BVALIDFLTR
        constexpr uint32_t G_SESSENDFLTR = (1U << 24);  ///< G_SESSENDFLTR
        constexpr uint32_t G_DEDFIFOMODE = (1U << 25);  ///< G_DEDFIFOMODE
        constexpr uint32_t G_INEPS = (4 << 26);  ///< G_INEPS
        constexpr uint32_t G_DESCDMAENABLED = (1U << 30);  ///< G_DESCDMAENABLED
        constexpr uint32_t G_DESCDMA = (1U << 31);  ///< G_DESCDMA
    }

    /// GDFIFOCFG Register bits
    namespace gdfifocfg_bits {
        constexpr uint32_t GDFIFOCFG = (16 << 0);  ///< GDFIFOCFG
        constexpr uint32_t EPINFOBASEADDR = (16 << 16);  ///< EPINFOBASEADDR
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTXFSTADDR = (16 << 0);  ///< PTXFSTADDR
        constexpr uint32_t PTXFSIZE = (16 << 16);  ///< PTXFSIZE
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEP1TXFSTADDR = (16 << 0);  ///< INEP1TXFSTADDR
        constexpr uint32_t INEP1TXFDEP = (16 << 16);  ///< INEP1TXFDEP
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEP2TXFSTADDR = (16 << 0);  ///< INEP2TXFSTADDR
        constexpr uint32_t INEP2TXFDEP = (16 << 16);  ///< INEP2TXFDEP
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEP3TXFSTADDR = (16 << 0);  ///< INEP3TXFSTADDR
        constexpr uint32_t INEP3TXFDEP = (16 << 16);  ///< INEP3TXFDEP
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEP4TXFSTADDR = (16 << 0);  ///< INEP4TXFSTADDR
        constexpr uint32_t INEP4TXFDEP = (16 << 16);  ///< INEP4TXFDEP
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t H_FSLSPCLKSEL = (2 << 0);  ///< H_FSLSPCLKSEL
        constexpr uint32_t H_FSLSSUPP = (1U << 2);  ///< H_FSLSSUPP
        constexpr uint32_t H_ENA32KHZS = (1U << 7);  ///< H_ENA32KHZS
        constexpr uint32_t H_DESCDMA = (1U << 23);  ///< H_DESCDMA
        constexpr uint32_t H_FRLISTEN = (2 << 24);  ///< H_FRLISTEN
        constexpr uint32_t H_PERSCHEDENA = (1U << 26);  ///< H_PERSCHEDENA
        constexpr uint32_t H_MODECHTIMEN = (1U << 31);  ///< H_MODECHTIMEN
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FRINT = (16 << 0);  ///< FRINT
        constexpr uint32_t HFIRRLDCTRL = (1U << 16);  ///< HFIRRLDCTRL
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FRNUM = (14 << 0);  ///< FRNUM
        constexpr uint32_t FRREM = (16 << 16);  ///< FRREM
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTXFSPCAVAIL = (16 << 0);  ///< PTXFSPCAVAIL
        constexpr uint32_t PTXQSPCAVAIL = (5 << 16);  ///< PTXQSPCAVAIL
        constexpr uint32_t PTXQTOP = (8 << 24);  ///< PTXQTOP
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (8 << 0);  ///< HAINT
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTMSK = (8 << 0);  ///< HAINTMSK
    }

    /// HFLBADDR Register bits
    namespace hflbaddr_bits {
        constexpr uint32_t HFLBADDR = (32 << 0);  ///< HFLBADDR
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PRTCONNSTS = (1U << 0);  ///< PRTCONNSTS
        constexpr uint32_t PRTCONNDET = (1U << 1);  ///< PRTCONNDET
        constexpr uint32_t PRTENA = (1U << 2);  ///< PRTENA
        constexpr uint32_t PRTENCHNG = (1U << 3);  ///< PRTENCHNG
        constexpr uint32_t PRTOVRCURRACT = (1U << 4);  ///< PRTOVRCURRACT
        constexpr uint32_t PRTOVRCURRCHNG = (1U << 5);  ///< PRTOVRCURRCHNG
        constexpr uint32_t PRTRES = (1U << 6);  ///< PRTRES
        constexpr uint32_t PRTSUSP = (1U << 7);  ///< PRTSUSP
        constexpr uint32_t PRTRST = (1U << 8);  ///< PRTRST
        constexpr uint32_t PRTLNSTS = (2 << 10);  ///< PRTLNSTS
        constexpr uint32_t PRTPWR = (1U << 12);  ///< PRTPWR
        constexpr uint32_t PRTTSTCTL = (4 << 13);  ///< PRTTSTCTL
        constexpr uint32_t PRTSPD = (2 << 17);  ///< PRTSPD
    }

    /// HCCHAR0 Register bits
    namespace hcchar0_bits {
        constexpr uint32_t H_MPS0 = (11 << 0);  ///< H_MPS0
        constexpr uint32_t H_EPNUM0 = (4 << 11);  ///< H_EPNUM0
        constexpr uint32_t H_EPDIR0 = (1U << 15);  ///< H_EPDIR0
        constexpr uint32_t H_LSPDDEV0 = (1U << 17);  ///< H_LSPDDEV0
        constexpr uint32_t H_EPTYPE0 = (2 << 18);  ///< H_EPTYPE0
        constexpr uint32_t H_EC0 = (1U << 21);  ///< H_EC0
        constexpr uint32_t H_DEVADDR0 = (7 << 22);  ///< H_DEVADDR0
        constexpr uint32_t H_ODDFRM0 = (1U << 29);  ///< H_ODDFRM0
        constexpr uint32_t H_CHDIS0 = (1U << 30);  ///< H_CHDIS0
        constexpr uint32_t H_CHENA0 = (1U << 31);  ///< H_CHENA0
    }

    /// HCINT0 Register bits
    namespace hcint0_bits {
        constexpr uint32_t H_XFERCOMPL0 = (1U << 0);  ///< H_XFERCOMPL0
        constexpr uint32_t H_CHHLTD0 = (1U << 1);  ///< H_CHHLTD0
        constexpr uint32_t H_AHBERR0 = (1U << 2);  ///< H_AHBERR0
        constexpr uint32_t H_STALL0 = (1U << 3);  ///< H_STALL0
        constexpr uint32_t H_NACK0 = (1U << 4);  ///< H_NACK0
        constexpr uint32_t H_ACK0 = (1U << 5);  ///< H_ACK0
        constexpr uint32_t H_NYET0 = (1U << 6);  ///< H_NYET0
        constexpr uint32_t H_XACTERR0 = (1U << 7);  ///< H_XACTERR0
        constexpr uint32_t H_BBLERR0 = (1U << 8);  ///< H_BBLERR0
        constexpr uint32_t H_FRMOVRUN0 = (1U << 9);  ///< H_FRMOVRUN0
        constexpr uint32_t H_DATATGLERR0 = (1U << 10);  ///< H_DATATGLERR0
        constexpr uint32_t H_BNAINTR0 = (1U << 11);  ///< H_BNAINTR0
        constexpr uint32_t H_XCS_XACT_ERR0 = (1U << 12);  ///< H_XCS_XACT_ERR0
        constexpr uint32_t H_DESC_LST_ROLLINTR0 = (1U << 13);  ///< H_DESC_LST_ROLLINTR0
    }

    /// HCINTMSK0 Register bits
    namespace hcintmsk0_bits {
        constexpr uint32_t H_XFERCOMPLMSK0 = (1U << 0);  ///< H_XFERCOMPLMSK0
        constexpr uint32_t H_CHHLTDMSK0 = (1U << 1);  ///< H_CHHLTDMSK0
        constexpr uint32_t H_AHBERRMSK0 = (1U << 2);  ///< H_AHBERRMSK0
        constexpr uint32_t H_STALLMSK0 = (1U << 3);  ///< H_STALLMSK0
        constexpr uint32_t H_NAKMSK0 = (1U << 4);  ///< H_NAKMSK0
        constexpr uint32_t H_ACKMSK0 = (1U << 5);  ///< H_ACKMSK0
        constexpr uint32_t H_NYETMSK0 = (1U << 6);  ///< H_NYETMSK0
        constexpr uint32_t H_XACTERRMSK0 = (1U << 7);  ///< H_XACTERRMSK0
        constexpr uint32_t H_BBLERRMSK0 = (1U << 8);  ///< H_BBLERRMSK0
        constexpr uint32_t H_FRMOVRUNMSK0 = (1U << 9);  ///< H_FRMOVRUNMSK0
        constexpr uint32_t H_DATATGLERRMSK0 = (1U << 10);  ///< H_DATATGLERRMSK0
        constexpr uint32_t H_BNAINTRMSK0 = (1U << 11);  ///< H_BNAINTRMSK0
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK0 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK0
    }

    /// HCTSIZ0 Register bits
    namespace hctsiz0_bits {
        constexpr uint32_t H_XFERSIZE0 = (19 << 0);  ///< H_XFERSIZE0
        constexpr uint32_t H_PKTCNT0 = (10 << 19);  ///< H_PKTCNT0
        constexpr uint32_t H_PID0 = (2 << 29);  ///< H_PID0
        constexpr uint32_t H_DOPNG0 = (1U << 31);  ///< H_DOPNG0
    }

    /// HCDMA0 Register bits
    namespace hcdma0_bits {
        constexpr uint32_t H_DMAADDR0 = (32 << 0);  ///< H_DMAADDR0
    }

    /// HCDMAB0 Register bits
    namespace hcdmab0_bits {
        constexpr uint32_t H_HCDMAB0 = (32 << 0);  ///< H_HCDMAB0
    }

    /// HCCHAR1 Register bits
    namespace hcchar1_bits {
        constexpr uint32_t H_MPS1 = (11 << 0);  ///< H_MPS1
        constexpr uint32_t H_EPNUM1 = (4 << 11);  ///< H_EPNUM1
        constexpr uint32_t H_EPDIR1 = (1U << 15);  ///< H_EPDIR1
        constexpr uint32_t H_LSPDDEV1 = (1U << 17);  ///< H_LSPDDEV1
        constexpr uint32_t H_EPTYPE1 = (2 << 18);  ///< H_EPTYPE1
        constexpr uint32_t H_EC1 = (1U << 21);  ///< H_EC1
        constexpr uint32_t H_DEVADDR1 = (7 << 22);  ///< H_DEVADDR1
        constexpr uint32_t H_ODDFRM1 = (1U << 29);  ///< H_ODDFRM1
        constexpr uint32_t H_CHDIS1 = (1U << 30);  ///< H_CHDIS1
        constexpr uint32_t H_CHENA1 = (1U << 31);  ///< H_CHENA1
    }

    /// HCINT1 Register bits
    namespace hcint1_bits {
        constexpr uint32_t H_XFERCOMPL1 = (1U << 0);  ///< H_XFERCOMPL1
        constexpr uint32_t H_CHHLTD1 = (1U << 1);  ///< H_CHHLTD1
        constexpr uint32_t H_AHBERR1 = (1U << 2);  ///< H_AHBERR1
        constexpr uint32_t H_STALL1 = (1U << 3);  ///< H_STALL1
        constexpr uint32_t H_NACK1 = (1U << 4);  ///< H_NACK1
        constexpr uint32_t H_ACK1 = (1U << 5);  ///< H_ACK1
        constexpr uint32_t H_NYET1 = (1U << 6);  ///< H_NYET1
        constexpr uint32_t H_XACTERR1 = (1U << 7);  ///< H_XACTERR1
        constexpr uint32_t H_BBLERR1 = (1U << 8);  ///< H_BBLERR1
        constexpr uint32_t H_FRMOVRUN1 = (1U << 9);  ///< H_FRMOVRUN1
        constexpr uint32_t H_DATATGLERR1 = (1U << 10);  ///< H_DATATGLERR1
        constexpr uint32_t H_BNAINTR1 = (1U << 11);  ///< H_BNAINTR1
        constexpr uint32_t H_XCS_XACT_ERR1 = (1U << 12);  ///< H_XCS_XACT_ERR1
        constexpr uint32_t H_DESC_LST_ROLLINTR1 = (1U << 13);  ///< H_DESC_LST_ROLLINTR1
    }

    /// HCINTMSK1 Register bits
    namespace hcintmsk1_bits {
        constexpr uint32_t H_XFERCOMPLMSK1 = (1U << 0);  ///< H_XFERCOMPLMSK1
        constexpr uint32_t H_CHHLTDMSK1 = (1U << 1);  ///< H_CHHLTDMSK1
        constexpr uint32_t H_AHBERRMSK1 = (1U << 2);  ///< H_AHBERRMSK1
        constexpr uint32_t H_STALLMSK1 = (1U << 3);  ///< H_STALLMSK1
        constexpr uint32_t H_NAKMSK1 = (1U << 4);  ///< H_NAKMSK1
        constexpr uint32_t H_ACKMSK1 = (1U << 5);  ///< H_ACKMSK1
        constexpr uint32_t H_NYETMSK1 = (1U << 6);  ///< H_NYETMSK1
        constexpr uint32_t H_XACTERRMSK1 = (1U << 7);  ///< H_XACTERRMSK1
        constexpr uint32_t H_BBLERRMSK1 = (1U << 8);  ///< H_BBLERRMSK1
        constexpr uint32_t H_FRMOVRUNMSK1 = (1U << 9);  ///< H_FRMOVRUNMSK1
        constexpr uint32_t H_DATATGLERRMSK1 = (1U << 10);  ///< H_DATATGLERRMSK1
        constexpr uint32_t H_BNAINTRMSK1 = (1U << 11);  ///< H_BNAINTRMSK1
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK1 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK1
    }

    /// HCTSIZ1 Register bits
    namespace hctsiz1_bits {
        constexpr uint32_t H_XFERSIZE1 = (19 << 0);  ///< H_XFERSIZE1
        constexpr uint32_t H_PKTCNT1 = (10 << 19);  ///< H_PKTCNT1
        constexpr uint32_t H_PID1 = (2 << 29);  ///< H_PID1
        constexpr uint32_t H_DOPNG1 = (1U << 31);  ///< H_DOPNG1
    }

    /// HCDMA1 Register bits
    namespace hcdma1_bits {
        constexpr uint32_t H_DMAADDR1 = (32 << 0);  ///< H_DMAADDR1
    }

    /// HCDMAB1 Register bits
    namespace hcdmab1_bits {
        constexpr uint32_t H_HCDMAB1 = (32 << 0);  ///< H_HCDMAB1
    }

    /// HCCHAR2 Register bits
    namespace hcchar2_bits {
        constexpr uint32_t H_MPS2 = (11 << 0);  ///< H_MPS2
        constexpr uint32_t H_EPNUM2 = (4 << 11);  ///< H_EPNUM2
        constexpr uint32_t H_EPDIR2 = (1U << 15);  ///< H_EPDIR2
        constexpr uint32_t H_LSPDDEV2 = (1U << 17);  ///< H_LSPDDEV2
        constexpr uint32_t H_EPTYPE2 = (2 << 18);  ///< H_EPTYPE2
        constexpr uint32_t H_EC2 = (1U << 21);  ///< H_EC2
        constexpr uint32_t H_DEVADDR2 = (7 << 22);  ///< H_DEVADDR2
        constexpr uint32_t H_ODDFRM2 = (1U << 29);  ///< H_ODDFRM2
        constexpr uint32_t H_CHDIS2 = (1U << 30);  ///< H_CHDIS2
        constexpr uint32_t H_CHENA2 = (1U << 31);  ///< H_CHENA2
    }

    /// HCINT2 Register bits
    namespace hcint2_bits {
        constexpr uint32_t H_XFERCOMPL2 = (1U << 0);  ///< H_XFERCOMPL2
        constexpr uint32_t H_CHHLTD2 = (1U << 1);  ///< H_CHHLTD2
        constexpr uint32_t H_AHBERR2 = (1U << 2);  ///< H_AHBERR2
        constexpr uint32_t H_STALL2 = (1U << 3);  ///< H_STALL2
        constexpr uint32_t H_NACK2 = (1U << 4);  ///< H_NACK2
        constexpr uint32_t H_ACK2 = (1U << 5);  ///< H_ACK2
        constexpr uint32_t H_NYET2 = (1U << 6);  ///< H_NYET2
        constexpr uint32_t H_XACTERR2 = (1U << 7);  ///< H_XACTERR2
        constexpr uint32_t H_BBLERR2 = (1U << 8);  ///< H_BBLERR2
        constexpr uint32_t H_FRMOVRUN2 = (1U << 9);  ///< H_FRMOVRUN2
        constexpr uint32_t H_DATATGLERR2 = (1U << 10);  ///< H_DATATGLERR2
        constexpr uint32_t H_BNAINTR2 = (1U << 11);  ///< H_BNAINTR2
        constexpr uint32_t H_XCS_XACT_ERR2 = (1U << 12);  ///< H_XCS_XACT_ERR2
        constexpr uint32_t H_DESC_LST_ROLLINTR2 = (1U << 13);  ///< H_DESC_LST_ROLLINTR2
    }

    /// HCINTMSK2 Register bits
    namespace hcintmsk2_bits {
        constexpr uint32_t H_XFERCOMPLMSK2 = (1U << 0);  ///< H_XFERCOMPLMSK2
        constexpr uint32_t H_CHHLTDMSK2 = (1U << 1);  ///< H_CHHLTDMSK2
        constexpr uint32_t H_AHBERRMSK2 = (1U << 2);  ///< H_AHBERRMSK2
        constexpr uint32_t H_STALLMSK2 = (1U << 3);  ///< H_STALLMSK2
        constexpr uint32_t H_NAKMSK2 = (1U << 4);  ///< H_NAKMSK2
        constexpr uint32_t H_ACKMSK2 = (1U << 5);  ///< H_ACKMSK2
        constexpr uint32_t H_NYETMSK2 = (1U << 6);  ///< H_NYETMSK2
        constexpr uint32_t H_XACTERRMSK2 = (1U << 7);  ///< H_XACTERRMSK2
        constexpr uint32_t H_BBLERRMSK2 = (1U << 8);  ///< H_BBLERRMSK2
        constexpr uint32_t H_FRMOVRUNMSK2 = (1U << 9);  ///< H_FRMOVRUNMSK2
        constexpr uint32_t H_DATATGLERRMSK2 = (1U << 10);  ///< H_DATATGLERRMSK2
        constexpr uint32_t H_BNAINTRMSK2 = (1U << 11);  ///< H_BNAINTRMSK2
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK2 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK2
    }

    /// HCTSIZ2 Register bits
    namespace hctsiz2_bits {
        constexpr uint32_t H_XFERSIZE2 = (19 << 0);  ///< H_XFERSIZE2
        constexpr uint32_t H_PKTCNT2 = (10 << 19);  ///< H_PKTCNT2
        constexpr uint32_t H_PID2 = (2 << 29);  ///< H_PID2
        constexpr uint32_t H_DOPNG2 = (1U << 31);  ///< H_DOPNG2
    }

    /// HCDMA2 Register bits
    namespace hcdma2_bits {
        constexpr uint32_t H_DMAADDR2 = (32 << 0);  ///< H_DMAADDR2
    }

    /// HCDMAB2 Register bits
    namespace hcdmab2_bits {
        constexpr uint32_t H_HCDMAB2 = (32 << 0);  ///< H_HCDMAB2
    }

    /// HCCHAR3 Register bits
    namespace hcchar3_bits {
        constexpr uint32_t H_MPS3 = (11 << 0);  ///< H_MPS3
        constexpr uint32_t H_EPNUM3 = (4 << 11);  ///< H_EPNUM3
        constexpr uint32_t H_EPDIR3 = (1U << 15);  ///< H_EPDIR3
        constexpr uint32_t H_LSPDDEV3 = (1U << 17);  ///< H_LSPDDEV3
        constexpr uint32_t H_EPTYPE3 = (2 << 18);  ///< H_EPTYPE3
        constexpr uint32_t H_EC3 = (1U << 21);  ///< H_EC3
        constexpr uint32_t H_DEVADDR3 = (7 << 22);  ///< H_DEVADDR3
        constexpr uint32_t H_ODDFRM3 = (1U << 29);  ///< H_ODDFRM3
        constexpr uint32_t H_CHDIS3 = (1U << 30);  ///< H_CHDIS3
        constexpr uint32_t H_CHENA3 = (1U << 31);  ///< H_CHENA3
    }

    /// HCINT3 Register bits
    namespace hcint3_bits {
        constexpr uint32_t H_XFERCOMPL3 = (1U << 0);  ///< H_XFERCOMPL3
        constexpr uint32_t H_CHHLTD3 = (1U << 1);  ///< H_CHHLTD3
        constexpr uint32_t H_AHBERR3 = (1U << 2);  ///< H_AHBERR3
        constexpr uint32_t H_STALL3 = (1U << 3);  ///< H_STALL3
        constexpr uint32_t H_NACK3 = (1U << 4);  ///< H_NACK3
        constexpr uint32_t H_ACK3 = (1U << 5);  ///< H_ACK3
        constexpr uint32_t H_NYET3 = (1U << 6);  ///< H_NYET3
        constexpr uint32_t H_XACTERR3 = (1U << 7);  ///< H_XACTERR3
        constexpr uint32_t H_BBLERR3 = (1U << 8);  ///< H_BBLERR3
        constexpr uint32_t H_FRMOVRUN3 = (1U << 9);  ///< H_FRMOVRUN3
        constexpr uint32_t H_DATATGLERR3 = (1U << 10);  ///< H_DATATGLERR3
        constexpr uint32_t H_BNAINTR3 = (1U << 11);  ///< H_BNAINTR3
        constexpr uint32_t H_XCS_XACT_ERR3 = (1U << 12);  ///< H_XCS_XACT_ERR3
        constexpr uint32_t H_DESC_LST_ROLLINTR3 = (1U << 13);  ///< H_DESC_LST_ROLLINTR3
    }

    /// HCINTMSK3 Register bits
    namespace hcintmsk3_bits {
        constexpr uint32_t H_XFERCOMPLMSK3 = (1U << 0);  ///< H_XFERCOMPLMSK3
        constexpr uint32_t H_CHHLTDMSK3 = (1U << 1);  ///< H_CHHLTDMSK3
        constexpr uint32_t H_AHBERRMSK3 = (1U << 2);  ///< H_AHBERRMSK3
        constexpr uint32_t H_STALLMSK3 = (1U << 3);  ///< H_STALLMSK3
        constexpr uint32_t H_NAKMSK3 = (1U << 4);  ///< H_NAKMSK3
        constexpr uint32_t H_ACKMSK3 = (1U << 5);  ///< H_ACKMSK3
        constexpr uint32_t H_NYETMSK3 = (1U << 6);  ///< H_NYETMSK3
        constexpr uint32_t H_XACTERRMSK3 = (1U << 7);  ///< H_XACTERRMSK3
        constexpr uint32_t H_BBLERRMSK3 = (1U << 8);  ///< H_BBLERRMSK3
        constexpr uint32_t H_FRMOVRUNMSK3 = (1U << 9);  ///< H_FRMOVRUNMSK3
        constexpr uint32_t H_DATATGLERRMSK3 = (1U << 10);  ///< H_DATATGLERRMSK3
        constexpr uint32_t H_BNAINTRMSK3 = (1U << 11);  ///< H_BNAINTRMSK3
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK3 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK3
    }

    /// HCTSIZ3 Register bits
    namespace hctsiz3_bits {
        constexpr uint32_t H_XFERSIZE3 = (19 << 0);  ///< H_XFERSIZE3
        constexpr uint32_t H_PKTCNT3 = (10 << 19);  ///< H_PKTCNT3
        constexpr uint32_t H_PID3 = (2 << 29);  ///< H_PID3
        constexpr uint32_t H_DOPNG3 = (1U << 31);  ///< H_DOPNG3
    }

    /// HCDMA3 Register bits
    namespace hcdma3_bits {
        constexpr uint32_t H_DMAADDR3 = (32 << 0);  ///< H_DMAADDR3
    }

    /// HCDMAB3 Register bits
    namespace hcdmab3_bits {
        constexpr uint32_t H_HCDMAB3 = (32 << 0);  ///< H_HCDMAB3
    }

    /// HCCHAR4 Register bits
    namespace hcchar4_bits {
        constexpr uint32_t H_MPS4 = (11 << 0);  ///< H_MPS4
        constexpr uint32_t H_EPNUM4 = (4 << 11);  ///< H_EPNUM4
        constexpr uint32_t H_EPDIR4 = (1U << 15);  ///< H_EPDIR4
        constexpr uint32_t H_LSPDDEV4 = (1U << 17);  ///< H_LSPDDEV4
        constexpr uint32_t H_EPTYPE4 = (2 << 18);  ///< H_EPTYPE4
        constexpr uint32_t H_EC4 = (1U << 21);  ///< H_EC4
        constexpr uint32_t H_DEVADDR4 = (7 << 22);  ///< H_DEVADDR4
        constexpr uint32_t H_ODDFRM4 = (1U << 29);  ///< H_ODDFRM4
        constexpr uint32_t H_CHDIS4 = (1U << 30);  ///< H_CHDIS4
        constexpr uint32_t H_CHENA4 = (1U << 31);  ///< H_CHENA4
    }

    /// HCINT4 Register bits
    namespace hcint4_bits {
        constexpr uint32_t H_XFERCOMPL4 = (1U << 0);  ///< H_XFERCOMPL4
        constexpr uint32_t H_CHHLTD4 = (1U << 1);  ///< H_CHHLTD4
        constexpr uint32_t H_AHBERR4 = (1U << 2);  ///< H_AHBERR4
        constexpr uint32_t H_STALL4 = (1U << 3);  ///< H_STALL4
        constexpr uint32_t H_NACK4 = (1U << 4);  ///< H_NACK4
        constexpr uint32_t H_ACK4 = (1U << 5);  ///< H_ACK4
        constexpr uint32_t H_NYET4 = (1U << 6);  ///< H_NYET4
        constexpr uint32_t H_XACTERR4 = (1U << 7);  ///< H_XACTERR4
        constexpr uint32_t H_BBLERR4 = (1U << 8);  ///< H_BBLERR4
        constexpr uint32_t H_FRMOVRUN4 = (1U << 9);  ///< H_FRMOVRUN4
        constexpr uint32_t H_DATATGLERR4 = (1U << 10);  ///< H_DATATGLERR4
        constexpr uint32_t H_BNAINTR4 = (1U << 11);  ///< H_BNAINTR4
        constexpr uint32_t H_XCS_XACT_ERR4 = (1U << 12);  ///< H_XCS_XACT_ERR4
        constexpr uint32_t H_DESC_LST_ROLLINTR4 = (1U << 13);  ///< H_DESC_LST_ROLLINTR4
    }

    /// HCINTMSK4 Register bits
    namespace hcintmsk4_bits {
        constexpr uint32_t H_XFERCOMPLMSK4 = (1U << 0);  ///< H_XFERCOMPLMSK4
        constexpr uint32_t H_CHHLTDMSK4 = (1U << 1);  ///< H_CHHLTDMSK4
        constexpr uint32_t H_AHBERRMSK4 = (1U << 2);  ///< H_AHBERRMSK4
        constexpr uint32_t H_STALLMSK4 = (1U << 3);  ///< H_STALLMSK4
        constexpr uint32_t H_NAKMSK4 = (1U << 4);  ///< H_NAKMSK4
        constexpr uint32_t H_ACKMSK4 = (1U << 5);  ///< H_ACKMSK4
        constexpr uint32_t H_NYETMSK4 = (1U << 6);  ///< H_NYETMSK4
        constexpr uint32_t H_XACTERRMSK4 = (1U << 7);  ///< H_XACTERRMSK4
        constexpr uint32_t H_BBLERRMSK4 = (1U << 8);  ///< H_BBLERRMSK4
        constexpr uint32_t H_FRMOVRUNMSK4 = (1U << 9);  ///< H_FRMOVRUNMSK4
        constexpr uint32_t H_DATATGLERRMSK4 = (1U << 10);  ///< H_DATATGLERRMSK4
        constexpr uint32_t H_BNAINTRMSK4 = (1U << 11);  ///< H_BNAINTRMSK4
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK4 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK4
    }

    /// HCTSIZ4 Register bits
    namespace hctsiz4_bits {
        constexpr uint32_t H_XFERSIZE4 = (19 << 0);  ///< H_XFERSIZE4
        constexpr uint32_t H_PKTCNT4 = (10 << 19);  ///< H_PKTCNT4
        constexpr uint32_t H_PID4 = (2 << 29);  ///< H_PID4
        constexpr uint32_t H_DOPNG4 = (1U << 31);  ///< H_DOPNG4
    }

    /// HCDMA4 Register bits
    namespace hcdma4_bits {
        constexpr uint32_t H_DMAADDR4 = (32 << 0);  ///< H_DMAADDR4
    }

    /// HCDMAB4 Register bits
    namespace hcdmab4_bits {
        constexpr uint32_t H_HCDMAB4 = (32 << 0);  ///< H_HCDMAB4
    }

    /// HCCHAR5 Register bits
    namespace hcchar5_bits {
        constexpr uint32_t H_MPS5 = (11 << 0);  ///< H_MPS5
        constexpr uint32_t H_EPNUM5 = (4 << 11);  ///< H_EPNUM5
        constexpr uint32_t H_EPDIR5 = (1U << 15);  ///< H_EPDIR5
        constexpr uint32_t H_LSPDDEV5 = (1U << 17);  ///< H_LSPDDEV5
        constexpr uint32_t H_EPTYPE5 = (2 << 18);  ///< H_EPTYPE5
        constexpr uint32_t H_EC5 = (1U << 21);  ///< H_EC5
        constexpr uint32_t H_DEVADDR5 = (7 << 22);  ///< H_DEVADDR5
        constexpr uint32_t H_ODDFRM5 = (1U << 29);  ///< H_ODDFRM5
        constexpr uint32_t H_CHDIS5 = (1U << 30);  ///< H_CHDIS5
        constexpr uint32_t H_CHENA5 = (1U << 31);  ///< H_CHENA5
    }

    /// HCINT5 Register bits
    namespace hcint5_bits {
        constexpr uint32_t H_XFERCOMPL5 = (1U << 0);  ///< H_XFERCOMPL5
        constexpr uint32_t H_CHHLTD5 = (1U << 1);  ///< H_CHHLTD5
        constexpr uint32_t H_AHBERR5 = (1U << 2);  ///< H_AHBERR5
        constexpr uint32_t H_STALL5 = (1U << 3);  ///< H_STALL5
        constexpr uint32_t H_NACK5 = (1U << 4);  ///< H_NACK5
        constexpr uint32_t H_ACK5 = (1U << 5);  ///< H_ACK5
        constexpr uint32_t H_NYET5 = (1U << 6);  ///< H_NYET5
        constexpr uint32_t H_XACTERR5 = (1U << 7);  ///< H_XACTERR5
        constexpr uint32_t H_BBLERR5 = (1U << 8);  ///< H_BBLERR5
        constexpr uint32_t H_FRMOVRUN5 = (1U << 9);  ///< H_FRMOVRUN5
        constexpr uint32_t H_DATATGLERR5 = (1U << 10);  ///< H_DATATGLERR5
        constexpr uint32_t H_BNAINTR5 = (1U << 11);  ///< H_BNAINTR5
        constexpr uint32_t H_XCS_XACT_ERR5 = (1U << 12);  ///< H_XCS_XACT_ERR5
        constexpr uint32_t H_DESC_LST_ROLLINTR5 = (1U << 13);  ///< H_DESC_LST_ROLLINTR5
    }

    /// HCINTMSK5 Register bits
    namespace hcintmsk5_bits {
        constexpr uint32_t H_XFERCOMPLMSK5 = (1U << 0);  ///< H_XFERCOMPLMSK5
        constexpr uint32_t H_CHHLTDMSK5 = (1U << 1);  ///< H_CHHLTDMSK5
        constexpr uint32_t H_AHBERRMSK5 = (1U << 2);  ///< H_AHBERRMSK5
        constexpr uint32_t H_STALLMSK5 = (1U << 3);  ///< H_STALLMSK5
        constexpr uint32_t H_NAKMSK5 = (1U << 4);  ///< H_NAKMSK5
        constexpr uint32_t H_ACKMSK5 = (1U << 5);  ///< H_ACKMSK5
        constexpr uint32_t H_NYETMSK5 = (1U << 6);  ///< H_NYETMSK5
        constexpr uint32_t H_XACTERRMSK5 = (1U << 7);  ///< H_XACTERRMSK5
        constexpr uint32_t H_BBLERRMSK5 = (1U << 8);  ///< H_BBLERRMSK5
        constexpr uint32_t H_FRMOVRUNMSK5 = (1U << 9);  ///< H_FRMOVRUNMSK5
        constexpr uint32_t H_DATATGLERRMSK5 = (1U << 10);  ///< H_DATATGLERRMSK5
        constexpr uint32_t H_BNAINTRMSK5 = (1U << 11);  ///< H_BNAINTRMSK5
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK5 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK5
    }

    /// HCTSIZ5 Register bits
    namespace hctsiz5_bits {
        constexpr uint32_t H_XFERSIZE5 = (19 << 0);  ///< H_XFERSIZE5
        constexpr uint32_t H_PKTCNT5 = (10 << 19);  ///< H_PKTCNT5
        constexpr uint32_t H_PID5 = (2 << 29);  ///< H_PID5
        constexpr uint32_t H_DOPNG5 = (1U << 31);  ///< H_DOPNG5
    }

    /// HCDMA5 Register bits
    namespace hcdma5_bits {
        constexpr uint32_t H_DMAADDR5 = (32 << 0);  ///< H_DMAADDR5
    }

    /// HCDMAB5 Register bits
    namespace hcdmab5_bits {
        constexpr uint32_t H_HCDMAB5 = (32 << 0);  ///< H_HCDMAB5
    }

    /// HCCHAR6 Register bits
    namespace hcchar6_bits {
        constexpr uint32_t H_MPS6 = (11 << 0);  ///< H_MPS6
        constexpr uint32_t H_EPNUM6 = (4 << 11);  ///< H_EPNUM6
        constexpr uint32_t H_EPDIR6 = (1U << 15);  ///< H_EPDIR6
        constexpr uint32_t H_LSPDDEV6 = (1U << 17);  ///< H_LSPDDEV6
        constexpr uint32_t H_EPTYPE6 = (2 << 18);  ///< H_EPTYPE6
        constexpr uint32_t H_EC6 = (1U << 21);  ///< H_EC6
        constexpr uint32_t H_DEVADDR6 = (7 << 22);  ///< H_DEVADDR6
        constexpr uint32_t H_ODDFRM6 = (1U << 29);  ///< H_ODDFRM6
        constexpr uint32_t H_CHDIS6 = (1U << 30);  ///< H_CHDIS6
        constexpr uint32_t H_CHENA6 = (1U << 31);  ///< H_CHENA6
    }

    /// HCINT6 Register bits
    namespace hcint6_bits {
        constexpr uint32_t H_XFERCOMPL6 = (1U << 0);  ///< H_XFERCOMPL6
        constexpr uint32_t H_CHHLTD6 = (1U << 1);  ///< H_CHHLTD6
        constexpr uint32_t H_AHBERR6 = (1U << 2);  ///< H_AHBERR6
        constexpr uint32_t H_STALL6 = (1U << 3);  ///< H_STALL6
        constexpr uint32_t H_NACK6 = (1U << 4);  ///< H_NACK6
        constexpr uint32_t H_ACK6 = (1U << 5);  ///< H_ACK6
        constexpr uint32_t H_NYET6 = (1U << 6);  ///< H_NYET6
        constexpr uint32_t H_XACTERR6 = (1U << 7);  ///< H_XACTERR6
        constexpr uint32_t H_BBLERR6 = (1U << 8);  ///< H_BBLERR6
        constexpr uint32_t H_FRMOVRUN6 = (1U << 9);  ///< H_FRMOVRUN6
        constexpr uint32_t H_DATATGLERR6 = (1U << 10);  ///< H_DATATGLERR6
        constexpr uint32_t H_BNAINTR6 = (1U << 11);  ///< H_BNAINTR6
        constexpr uint32_t H_XCS_XACT_ERR6 = (1U << 12);  ///< H_XCS_XACT_ERR6
        constexpr uint32_t H_DESC_LST_ROLLINTR6 = (1U << 13);  ///< H_DESC_LST_ROLLINTR6
    }

    /// HCINTMSK6 Register bits
    namespace hcintmsk6_bits {
        constexpr uint32_t H_XFERCOMPLMSK6 = (1U << 0);  ///< H_XFERCOMPLMSK6
        constexpr uint32_t H_CHHLTDMSK6 = (1U << 1);  ///< H_CHHLTDMSK6
        constexpr uint32_t H_AHBERRMSK6 = (1U << 2);  ///< H_AHBERRMSK6
        constexpr uint32_t H_STALLMSK6 = (1U << 3);  ///< H_STALLMSK6
        constexpr uint32_t H_NAKMSK6 = (1U << 4);  ///< H_NAKMSK6
        constexpr uint32_t H_ACKMSK6 = (1U << 5);  ///< H_ACKMSK6
        constexpr uint32_t H_NYETMSK6 = (1U << 6);  ///< H_NYETMSK6
        constexpr uint32_t H_XACTERRMSK6 = (1U << 7);  ///< H_XACTERRMSK6
        constexpr uint32_t H_BBLERRMSK6 = (1U << 8);  ///< H_BBLERRMSK6
        constexpr uint32_t H_FRMOVRUNMSK6 = (1U << 9);  ///< H_FRMOVRUNMSK6
        constexpr uint32_t H_DATATGLERRMSK6 = (1U << 10);  ///< H_DATATGLERRMSK6
        constexpr uint32_t H_BNAINTRMSK6 = (1U << 11);  ///< H_BNAINTRMSK6
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK6 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK6
    }

    /// HCTSIZ6 Register bits
    namespace hctsiz6_bits {
        constexpr uint32_t H_XFERSIZE6 = (19 << 0);  ///< H_XFERSIZE6
        constexpr uint32_t H_PKTCNT6 = (10 << 19);  ///< H_PKTCNT6
        constexpr uint32_t H_PID6 = (2 << 29);  ///< H_PID6
        constexpr uint32_t H_DOPNG6 = (1U << 31);  ///< H_DOPNG6
    }

    /// HCDMA6 Register bits
    namespace hcdma6_bits {
        constexpr uint32_t H_DMAADDR6 = (32 << 0);  ///< H_DMAADDR6
    }

    /// HCDMAB6 Register bits
    namespace hcdmab6_bits {
        constexpr uint32_t H_HCDMAB6 = (32 << 0);  ///< H_HCDMAB6
    }

    /// HCCHAR7 Register bits
    namespace hcchar7_bits {
        constexpr uint32_t H_MPS7 = (11 << 0);  ///< H_MPS7
        constexpr uint32_t H_EPNUM7 = (4 << 11);  ///< H_EPNUM7
        constexpr uint32_t H_EPDIR7 = (1U << 15);  ///< H_EPDIR7
        constexpr uint32_t H_LSPDDEV7 = (1U << 17);  ///< H_LSPDDEV7
        constexpr uint32_t H_EPTYPE7 = (2 << 18);  ///< H_EPTYPE7
        constexpr uint32_t H_EC7 = (1U << 21);  ///< H_EC7
        constexpr uint32_t H_DEVADDR7 = (7 << 22);  ///< H_DEVADDR7
        constexpr uint32_t H_ODDFRM7 = (1U << 29);  ///< H_ODDFRM7
        constexpr uint32_t H_CHDIS7 = (1U << 30);  ///< H_CHDIS7
        constexpr uint32_t H_CHENA7 = (1U << 31);  ///< H_CHENA7
    }

    /// HCINT7 Register bits
    namespace hcint7_bits {
        constexpr uint32_t H_XFERCOMPL7 = (1U << 0);  ///< H_XFERCOMPL7
        constexpr uint32_t H_CHHLTD7 = (1U << 1);  ///< H_CHHLTD7
        constexpr uint32_t H_AHBERR7 = (1U << 2);  ///< H_AHBERR7
        constexpr uint32_t H_STALL7 = (1U << 3);  ///< H_STALL7
        constexpr uint32_t H_NACK7 = (1U << 4);  ///< H_NACK7
        constexpr uint32_t H_ACK7 = (1U << 5);  ///< H_ACK7
        constexpr uint32_t H_NYET7 = (1U << 6);  ///< H_NYET7
        constexpr uint32_t H_XACTERR7 = (1U << 7);  ///< H_XACTERR7
        constexpr uint32_t H_BBLERR7 = (1U << 8);  ///< H_BBLERR7
        constexpr uint32_t H_FRMOVRUN7 = (1U << 9);  ///< H_FRMOVRUN7
        constexpr uint32_t H_DATATGLERR7 = (1U << 10);  ///< H_DATATGLERR7
        constexpr uint32_t H_BNAINTR7 = (1U << 11);  ///< H_BNAINTR7
        constexpr uint32_t H_XCS_XACT_ERR7 = (1U << 12);  ///< H_XCS_XACT_ERR7
        constexpr uint32_t H_DESC_LST_ROLLINTR7 = (1U << 13);  ///< H_DESC_LST_ROLLINTR7
    }

    /// HCINTMSK7 Register bits
    namespace hcintmsk7_bits {
        constexpr uint32_t H_XFERCOMPLMSK7 = (1U << 0);  ///< H_XFERCOMPLMSK7
        constexpr uint32_t H_CHHLTDMSK7 = (1U << 1);  ///< H_CHHLTDMSK7
        constexpr uint32_t H_AHBERRMSK7 = (1U << 2);  ///< H_AHBERRMSK7
        constexpr uint32_t H_STALLMSK7 = (1U << 3);  ///< H_STALLMSK7
        constexpr uint32_t H_NAKMSK7 = (1U << 4);  ///< H_NAKMSK7
        constexpr uint32_t H_ACKMSK7 = (1U << 5);  ///< H_ACKMSK7
        constexpr uint32_t H_NYETMSK7 = (1U << 6);  ///< H_NYETMSK7
        constexpr uint32_t H_XACTERRMSK7 = (1U << 7);  ///< H_XACTERRMSK7
        constexpr uint32_t H_BBLERRMSK7 = (1U << 8);  ///< H_BBLERRMSK7
        constexpr uint32_t H_FRMOVRUNMSK7 = (1U << 9);  ///< H_FRMOVRUNMSK7
        constexpr uint32_t H_DATATGLERRMSK7 = (1U << 10);  ///< H_DATATGLERRMSK7
        constexpr uint32_t H_BNAINTRMSK7 = (1U << 11);  ///< H_BNAINTRMSK7
        constexpr uint32_t H_DESC_LST_ROLLINTRMSK7 = (1U << 13);  ///< H_DESC_LST_ROLLINTRMSK7
    }

    /// HCTSIZ7 Register bits
    namespace hctsiz7_bits {
        constexpr uint32_t H_XFERSIZE7 = (19 << 0);  ///< H_XFERSIZE7
        constexpr uint32_t H_PKTCNT7 = (10 << 19);  ///< H_PKTCNT7
        constexpr uint32_t H_PID7 = (2 << 29);  ///< H_PID7
        constexpr uint32_t H_DOPNG7 = (1U << 31);  ///< H_DOPNG7
    }

    /// HCDMA7 Register bits
    namespace hcdma7_bits {
        constexpr uint32_t H_DMAADDR7 = (32 << 0);  ///< H_DMAADDR7
    }

    /// HCDMAB7 Register bits
    namespace hcdmab7_bits {
        constexpr uint32_t H_HCDMAB7 = (32 << 0);  ///< H_HCDMAB7
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t NZSTSOUTHSHK = (1U << 2);  ///< NZSTSOUTHSHK
        constexpr uint32_t ENA32KHZSUSP = (1U << 3);  ///< ENA32KHZSUSP
        constexpr uint32_t DEVADDR = (7 << 4);  ///< DEVADDR
        constexpr uint32_t PERFRLINT = (2 << 11);  ///< PERFRLINT
        constexpr uint32_t ENDEVOUTNAK = (1U << 13);  ///< ENDEVOUTNAK
        constexpr uint32_t XCVRDLY = (1U << 14);  ///< XCVRDLY
        constexpr uint32_t ERRATICINTMSK = (1U << 15);  ///< ERRATICINTMSK
        constexpr uint32_t EPMISCNT = (5 << 18);  ///< EPMISCNT
        constexpr uint32_t DESCDMA = (1U << 23);  ///< DESCDMA
        constexpr uint32_t PERSCHINTVL = (2 << 24);  ///< PERSCHINTVL
        constexpr uint32_t RESVALID = (6 << 26);  ///< RESVALID
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RMTWKUPSIG = (1U << 0);  ///< RMTWKUPSIG
        constexpr uint32_t SFTDISCON = (1U << 1);  ///< SFTDISCON
        constexpr uint32_t GNPINNAKSTS = (1U << 2);  ///< GNPINNAKSTS
        constexpr uint32_t GOUTNAKSTS = (1U << 3);  ///< GOUTNAKSTS
        constexpr uint32_t TSTCTL = (3 << 4);  ///< TSTCTL
        constexpr uint32_t SGNPINNAK = (1U << 7);  ///< SGNPINNAK
        constexpr uint32_t CGNPINNAK = (1U << 8);  ///< CGNPINNAK
        constexpr uint32_t SGOUTNAK = (1U << 9);  ///< SGOUTNAK
        constexpr uint32_t CGOUTNAK = (1U << 10);  ///< CGOUTNAK
        constexpr uint32_t PWRONPRGDONE = (1U << 11);  ///< PWRONPRGDONE
        constexpr uint32_t GMC = (2 << 13);  ///< GMC
        constexpr uint32_t IGNRFRMNUM = (1U << 15);  ///< IGNRFRMNUM
        constexpr uint32_t NAKONBBLE = (1U << 16);  ///< NAKONBBLE
        constexpr uint32_t ENCOUNTONBNA = (1U << 17);  ///< ENCOUNTONBNA
        constexpr uint32_t DEEPSLEEPBESLREJECT = (1U << 18);  ///< DEEPSLEEPBESLREJECT
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SUSPSTS = (1U << 0);  ///< SUSPSTS
        constexpr uint32_t ENUMSPD = (2 << 1);  ///< ENUMSPD
        constexpr uint32_t ERRTICERR = (1U << 3);  ///< ERRTICERR
        constexpr uint32_t SOFFN = (14 << 8);  ///< SOFFN
        constexpr uint32_t DEVLNSTS = (2 << 22);  ///< DEVLNSTS
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t DI_XFERCOMPLMSK = (1U << 0);  ///< DI_XFERCOMPLMSK
        constexpr uint32_t DI_EPDISBLDMSK = (1U << 1);  ///< DI_EPDISBLDMSK
        constexpr uint32_t DI_AHBERMSK = (1U << 2);  ///< DI_AHBERMSK
        constexpr uint32_t TIMEOUTMSK = (1U << 3);  ///< TIMEOUTMSK
        constexpr uint32_t INTKNTXFEMPMSK = (1U << 4);  ///< INTKNTXFEMPMSK
        constexpr uint32_t INTKNEPMISMSK = (1U << 5);  ///< INTKNEPMISMSK
        constexpr uint32_t INEPNAKEFFMSK = (1U << 6);  ///< INEPNAKEFFMSK
        constexpr uint32_t TXFIFOUNDRNMSK = (1U << 8);  ///< TXFIFOUNDRNMSK
        constexpr uint32_t BNAININTRMSK = (1U << 9);  ///< BNAININTRMSK
        constexpr uint32_t DI_NAKMSK = (1U << 13);  ///< DI_NAKMSK
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XFERCOMPLMSK = (1U << 0);  ///< XFERCOMPLMSK
        constexpr uint32_t EPDISBLDMSK = (1U << 1);  ///< EPDISBLDMSK
        constexpr uint32_t AHBERMSK = (1U << 2);  ///< AHBERMSK
        constexpr uint32_t SETUPMSK = (1U << 3);  ///< SETUPMSK
        constexpr uint32_t OUTTKNEPDISMSK = (1U << 4);  ///< OUTTKNEPDISMSK
        constexpr uint32_t STSPHSERCVDMSK = (1U << 5);  ///< STSPHSERCVDMSK
        constexpr uint32_t BACK2BACKSETUP = (1U << 6);  ///< BACK2BACKSETUP
        constexpr uint32_t OUTPKTERRMSK = (1U << 8);  ///< OUTPKTERRMSK
        constexpr uint32_t BNAOUTINTRMSK = (1U << 9);  ///< BNAOUTINTRMSK
        constexpr uint32_t BBLEERRMSK = (1U << 12);  ///< BBLEERRMSK
        constexpr uint32_t NAKMSK = (1U << 13);  ///< NAKMSK
        constexpr uint32_t NYETMSK = (1U << 14);  ///< NYETMSK
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t INEPINT0 = (1U << 0);  ///< INEPINT0
        constexpr uint32_t INEPINT1 = (1U << 1);  ///< INEPINT1
        constexpr uint32_t INEPINT2 = (1U << 2);  ///< INEPINT2
        constexpr uint32_t INEPINT3 = (1U << 3);  ///< INEPINT3
        constexpr uint32_t INEPINT4 = (1U << 4);  ///< INEPINT4
        constexpr uint32_t INEPINT5 = (1U << 5);  ///< INEPINT5
        constexpr uint32_t INEPINT6 = (1U << 6);  ///< INEPINT6
        constexpr uint32_t OUTEPINT0 = (1U << 16);  ///< OUTEPINT0
        constexpr uint32_t OUTEPINT1 = (1U << 17);  ///< OUTEPINT1
        constexpr uint32_t OUTEPINT2 = (1U << 18);  ///< OUTEPINT2
        constexpr uint32_t OUTEPINT3 = (1U << 19);  ///< OUTEPINT3
        constexpr uint32_t OUTEPINT4 = (1U << 20);  ///< OUTEPINT4
        constexpr uint32_t OUTEPINT5 = (1U << 21);  ///< OUTEPINT5
        constexpr uint32_t OUTEPINT6 = (1U << 22);  ///< OUTEPINT6
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t INEPMSK0 = (1U << 0);  ///< INEPMSK0
        constexpr uint32_t INEPMSK1 = (1U << 1);  ///< INEPMSK1
        constexpr uint32_t INEPMSK2 = (1U << 2);  ///< INEPMSK2
        constexpr uint32_t INEPMSK3 = (1U << 3);  ///< INEPMSK3
        constexpr uint32_t INEPMSK4 = (1U << 4);  ///< INEPMSK4
        constexpr uint32_t INEPMSK5 = (1U << 5);  ///< INEPMSK5
        constexpr uint32_t INEPMSK6 = (1U << 6);  ///< INEPMSK6
        constexpr uint32_t OUTEPMSK0 = (1U << 16);  ///< OUTEPMSK0
        constexpr uint32_t OUTEPMSK1 = (1U << 17);  ///< OUTEPMSK1
        constexpr uint32_t OUTEPMSK2 = (1U << 18);  ///< OUTEPMSK2
        constexpr uint32_t OUTEPMSK3 = (1U << 19);  ///< OUTEPMSK3
        constexpr uint32_t OUTEPMSK4 = (1U << 20);  ///< OUTEPMSK4
        constexpr uint32_t OUTEPMSK5 = (1U << 21);  ///< OUTEPMSK5
        constexpr uint32_t OUTEPMSK6 = (1U << 22);  ///< OUTEPMSK6
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t DVBUSDIS = (16 << 0);  ///< DVBUSDIS
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSPULSE = (12 << 0);  ///< DVBUSPULSE
    }

    /// DTHRCTL Register bits
    namespace dthrctl_bits {
        constexpr uint32_t NONISOTHREN = (1U << 0);  ///< NONISOTHREN
        constexpr uint32_t ISOTHREN = (1U << 1);  ///< ISOTHREN
        constexpr uint32_t TXTHRLEN = (9 << 2);  ///< TXTHRLEN
        constexpr uint32_t AHBTHRRATIO = (2 << 11);  ///< AHBTHRRATIO
        constexpr uint32_t RXTHREN = (1U << 16);  ///< RXTHREN
        constexpr uint32_t RXTHRLEN = (9 << 17);  ///< RXTHRLEN
        constexpr uint32_t ARBPRKEN = (1U << 27);  ///< ARBPRKEN
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t D_INEPTXFEMPMSK = (16 << 0);  ///< D_INEPTXFEMPMSK
    }

    /// DIEPCTL0 Register bits
    namespace diepctl0_bits {
        constexpr uint32_t D_MPS0 = (2 << 0);  ///< D_MPS0
        constexpr uint32_t D_USBACTEP0 = (1U << 15);  ///< D_USBACTEP0
        constexpr uint32_t D_NAKSTS0 = (1U << 17);  ///< D_NAKSTS0
        constexpr uint32_t D_EPTYPE0 = (2 << 18);  ///< D_EPTYPE0
        constexpr uint32_t D_STALL0 = (1U << 21);  ///< D_STALL0
        constexpr uint32_t D_TXFNUM0 = (4 << 22);  ///< D_TXFNUM0
        constexpr uint32_t D_CNAK0 = (1U << 26);  ///< D_CNAK0
        constexpr uint32_t DI_SNAK0 = (1U << 27);  ///< DI_SNAK0
        constexpr uint32_t D_EPDIS0 = (1U << 30);  ///< D_EPDIS0
        constexpr uint32_t D_EPENA0 = (1U << 31);  ///< D_EPENA0
    }

    /// DIEPINT0 Register bits
    namespace diepint0_bits {
        constexpr uint32_t D_XFERCOMPL0 = (1U << 0);  ///< D_XFERCOMPL0
        constexpr uint32_t D_EPDISBLD0 = (1U << 1);  ///< D_EPDISBLD0
        constexpr uint32_t D_AHBERR0 = (1U << 2);  ///< D_AHBERR0
        constexpr uint32_t D_TIMEOUT0 = (1U << 3);  ///< D_TIMEOUT0
        constexpr uint32_t D_INTKNTXFEMP0 = (1U << 4);  ///< D_INTKNTXFEMP0
        constexpr uint32_t D_INTKNEPMIS0 = (1U << 5);  ///< D_INTKNEPMIS0
        constexpr uint32_t D_INEPNAKEFF0 = (1U << 6);  ///< D_INEPNAKEFF0
        constexpr uint32_t D_TXFEMP0 = (1U << 7);  ///< D_TXFEMP0
        constexpr uint32_t D_TXFIFOUNDRN0 = (1U << 8);  ///< D_TXFIFOUNDRN0
        constexpr uint32_t D_BNAINTR0 = (1U << 9);  ///< D_BNAINTR0
        constexpr uint32_t D_PKTDRPSTS0 = (1U << 11);  ///< D_PKTDRPSTS0
        constexpr uint32_t D_BBLEERR0 = (1U << 12);  ///< D_BBLEERR0
        constexpr uint32_t D_NAKINTRPT0 = (1U << 13);  ///< D_NAKINTRPT0
        constexpr uint32_t D_NYETINTRPT0 = (1U << 14);  ///< D_NYETINTRPT0
    }

    /// DIEPTSIZ0 Register bits
    namespace dieptsiz0_bits {
        constexpr uint32_t D_XFERSIZE0 = (7 << 0);  ///< D_XFERSIZE0
        constexpr uint32_t D_PKTCNT0 = (2 << 19);  ///< D_PKTCNT0
    }

    /// DIEPDMA0 Register bits
    namespace diepdma0_bits {
        constexpr uint32_t D_DMAADDR0 = (32 << 0);  ///< D_DMAADDR0
    }

    /// DTXFSTS0 Register bits
    namespace dtxfsts0_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL0 = (16 << 0);  ///< D_INEPTXFSPCAVAIL0
    }

    /// DIEPDMAB0 Register bits
    namespace diepdmab0_bits {
        constexpr uint32_t D_DMABUFFERADDR0 = (32 << 0);  ///< D_DMABUFFERADDR0
    }

    /// DIEPCTL1 Register bits
    namespace diepctl1_bits {
        constexpr uint32_t D_MPS1 = (2 << 0);  ///< D_MPS1
        constexpr uint32_t D_USBACTEP1 = (1U << 15);  ///< D_USBACTEP1
        constexpr uint32_t D_NAKSTS1 = (1U << 17);  ///< D_NAKSTS1
        constexpr uint32_t D_EPTYPE1 = (2 << 18);  ///< D_EPTYPE1
        constexpr uint32_t D_STALL1 = (1U << 21);  ///< D_STALL1
        constexpr uint32_t D_TXFNUM1 = (4 << 22);  ///< D_TXFNUM1
        constexpr uint32_t D_CNAK1 = (1U << 26);  ///< D_CNAK1
        constexpr uint32_t DI_SNAK1 = (1U << 27);  ///< DI_SNAK1
        constexpr uint32_t DI_SETD0PID1 = (1U << 28);  ///< DI_SETD0PID1
        constexpr uint32_t DI_SETD1PID1 = (1U << 29);  ///< DI_SETD1PID1
        constexpr uint32_t D_EPDIS1 = (1U << 30);  ///< D_EPDIS1
        constexpr uint32_t D_EPENA1 = (1U << 31);  ///< D_EPENA1
    }

    /// DIEPINT1 Register bits
    namespace diepint1_bits {
        constexpr uint32_t D_XFERCOMPL1 = (1U << 0);  ///< D_XFERCOMPL1
        constexpr uint32_t D_EPDISBLD1 = (1U << 1);  ///< D_EPDISBLD1
        constexpr uint32_t D_AHBERR1 = (1U << 2);  ///< D_AHBERR1
        constexpr uint32_t D_TIMEOUT1 = (1U << 3);  ///< D_TIMEOUT1
        constexpr uint32_t D_INTKNTXFEMP1 = (1U << 4);  ///< D_INTKNTXFEMP1
        constexpr uint32_t D_INTKNEPMIS1 = (1U << 5);  ///< D_INTKNEPMIS1
        constexpr uint32_t D_INEPNAKEFF1 = (1U << 6);  ///< D_INEPNAKEFF1
        constexpr uint32_t D_TXFEMP1 = (1U << 7);  ///< D_TXFEMP1
        constexpr uint32_t D_TXFIFOUNDRN1 = (1U << 8);  ///< D_TXFIFOUNDRN1
        constexpr uint32_t D_BNAINTR1 = (1U << 9);  ///< D_BNAINTR1
        constexpr uint32_t D_PKTDRPSTS1 = (1U << 11);  ///< D_PKTDRPSTS1
        constexpr uint32_t D_BBLEERR1 = (1U << 12);  ///< D_BBLEERR1
        constexpr uint32_t D_NAKINTRPT1 = (1U << 13);  ///< D_NAKINTRPT1
        constexpr uint32_t D_NYETINTRPT1 = (1U << 14);  ///< D_NYETINTRPT1
    }

    /// DIEPTSIZ1 Register bits
    namespace dieptsiz1_bits {
        constexpr uint32_t D_XFERSIZE1 = (7 << 0);  ///< D_XFERSIZE1
        constexpr uint32_t D_PKTCNT1 = (2 << 19);  ///< D_PKTCNT1
    }

    /// DIEPDMA1 Register bits
    namespace diepdma1_bits {
        constexpr uint32_t D_DMAADDR1 = (32 << 0);  ///< D_DMAADDR1
    }

    /// DTXFSTS1 Register bits
    namespace dtxfsts1_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL1 = (16 << 0);  ///< D_INEPTXFSPCAVAIL1
    }

    /// DIEPDMAB1 Register bits
    namespace diepdmab1_bits {
        constexpr uint32_t D_DMABUFFERADDR1 = (32 << 0);  ///< D_DMABUFFERADDR1
    }

    /// DIEPCTL2 Register bits
    namespace diepctl2_bits {
        constexpr uint32_t D_MPS2 = (2 << 0);  ///< D_MPS2
        constexpr uint32_t D_USBACTEP2 = (1U << 15);  ///< D_USBACTEP2
        constexpr uint32_t D_NAKSTS2 = (1U << 17);  ///< D_NAKSTS2
        constexpr uint32_t D_EPTYPE2 = (2 << 18);  ///< D_EPTYPE2
        constexpr uint32_t D_STALL2 = (1U << 21);  ///< D_STALL2
        constexpr uint32_t D_TXFNUM2 = (4 << 22);  ///< D_TXFNUM2
        constexpr uint32_t D_CNAK2 = (1U << 26);  ///< D_CNAK2
        constexpr uint32_t DI_SNAK2 = (1U << 27);  ///< DI_SNAK2
        constexpr uint32_t DI_SETD0PID2 = (1U << 28);  ///< DI_SETD0PID2
        constexpr uint32_t DI_SETD1PID2 = (1U << 29);  ///< DI_SETD1PID2
        constexpr uint32_t D_EPDIS2 = (1U << 30);  ///< D_EPDIS2
        constexpr uint32_t D_EPENA2 = (1U << 31);  ///< D_EPENA2
    }

    /// DIEPINT2 Register bits
    namespace diepint2_bits {
        constexpr uint32_t D_XFERCOMPL2 = (1U << 0);  ///< D_XFERCOMPL2
        constexpr uint32_t D_EPDISBLD2 = (1U << 1);  ///< D_EPDISBLD2
        constexpr uint32_t D_AHBERR2 = (1U << 2);  ///< D_AHBERR2
        constexpr uint32_t D_TIMEOUT2 = (1U << 3);  ///< D_TIMEOUT2
        constexpr uint32_t D_INTKNTXFEMP2 = (1U << 4);  ///< D_INTKNTXFEMP2
        constexpr uint32_t D_INTKNEPMIS2 = (1U << 5);  ///< D_INTKNEPMIS2
        constexpr uint32_t D_INEPNAKEFF2 = (1U << 6);  ///< D_INEPNAKEFF2
        constexpr uint32_t D_TXFEMP2 = (1U << 7);  ///< D_TXFEMP2
        constexpr uint32_t D_TXFIFOUNDRN2 = (1U << 8);  ///< D_TXFIFOUNDRN2
        constexpr uint32_t D_BNAINTR2 = (1U << 9);  ///< D_BNAINTR2
        constexpr uint32_t D_PKTDRPSTS2 = (1U << 11);  ///< D_PKTDRPSTS2
        constexpr uint32_t D_BBLEERR2 = (1U << 12);  ///< D_BBLEERR2
        constexpr uint32_t D_NAKINTRPT2 = (1U << 13);  ///< D_NAKINTRPT2
        constexpr uint32_t D_NYETINTRPT2 = (1U << 14);  ///< D_NYETINTRPT2
    }

    /// DIEPTSIZ2 Register bits
    namespace dieptsiz2_bits {
        constexpr uint32_t D_XFERSIZE2 = (7 << 0);  ///< D_XFERSIZE2
        constexpr uint32_t D_PKTCNT2 = (2 << 19);  ///< D_PKTCNT2
    }

    /// DIEPDMA2 Register bits
    namespace diepdma2_bits {
        constexpr uint32_t D_DMAADDR2 = (32 << 0);  ///< D_DMAADDR2
    }

    /// DTXFSTS2 Register bits
    namespace dtxfsts2_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL2 = (16 << 0);  ///< D_INEPTXFSPCAVAIL2
    }

    /// DIEPDMAB2 Register bits
    namespace diepdmab2_bits {
        constexpr uint32_t D_DMABUFFERADDR2 = (32 << 0);  ///< D_DMABUFFERADDR2
    }

    /// DIEPCTL3 Register bits
    namespace diepctl3_bits {
        constexpr uint32_t DI_MPS3 = (2 << 0);  ///< DI_MPS3
        constexpr uint32_t DI_USBACTEP3 = (1U << 15);  ///< DI_USBACTEP3
        constexpr uint32_t DI_NAKSTS3 = (1U << 17);  ///< DI_NAKSTS3
        constexpr uint32_t DI_EPTYPE3 = (2 << 18);  ///< DI_EPTYPE3
        constexpr uint32_t DI_STALL3 = (1U << 21);  ///< DI_STALL3
        constexpr uint32_t DI_TXFNUM3 = (4 << 22);  ///< DI_TXFNUM3
        constexpr uint32_t DI_CNAK3 = (1U << 26);  ///< DI_CNAK3
        constexpr uint32_t DI_SNAK3 = (1U << 27);  ///< DI_SNAK3
        constexpr uint32_t DI_SETD0PID3 = (1U << 28);  ///< DI_SETD0PID3
        constexpr uint32_t DI_SETD1PID3 = (1U << 29);  ///< DI_SETD1PID3
        constexpr uint32_t DI_EPDIS3 = (1U << 30);  ///< DI_EPDIS3
        constexpr uint32_t DI_EPENA3 = (1U << 31);  ///< DI_EPENA3
    }

    /// DIEPINT3 Register bits
    namespace diepint3_bits {
        constexpr uint32_t D_XFERCOMPL3 = (1U << 0);  ///< D_XFERCOMPL3
        constexpr uint32_t D_EPDISBLD3 = (1U << 1);  ///< D_EPDISBLD3
        constexpr uint32_t D_AHBERR3 = (1U << 2);  ///< D_AHBERR3
        constexpr uint32_t D_TIMEOUT3 = (1U << 3);  ///< D_TIMEOUT3
        constexpr uint32_t D_INTKNTXFEMP3 = (1U << 4);  ///< D_INTKNTXFEMP3
        constexpr uint32_t D_INTKNEPMIS3 = (1U << 5);  ///< D_INTKNEPMIS3
        constexpr uint32_t D_INEPNAKEFF3 = (1U << 6);  ///< D_INEPNAKEFF3
        constexpr uint32_t D_TXFEMP3 = (1U << 7);  ///< D_TXFEMP3
        constexpr uint32_t D_TXFIFOUNDRN3 = (1U << 8);  ///< D_TXFIFOUNDRN3
        constexpr uint32_t D_BNAINTR3 = (1U << 9);  ///< D_BNAINTR3
        constexpr uint32_t D_PKTDRPSTS3 = (1U << 11);  ///< D_PKTDRPSTS3
        constexpr uint32_t D_BBLEERR3 = (1U << 12);  ///< D_BBLEERR3
        constexpr uint32_t D_NAKINTRPT3 = (1U << 13);  ///< D_NAKINTRPT3
        constexpr uint32_t D_NYETINTRPT3 = (1U << 14);  ///< D_NYETINTRPT3
    }

    /// DIEPTSIZ3 Register bits
    namespace dieptsiz3_bits {
        constexpr uint32_t D_XFERSIZE3 = (7 << 0);  ///< D_XFERSIZE3
        constexpr uint32_t D_PKTCNT3 = (2 << 19);  ///< D_PKTCNT3
    }

    /// DIEPDMA3 Register bits
    namespace diepdma3_bits {
        constexpr uint32_t D_DMAADDR3 = (32 << 0);  ///< D_DMAADDR3
    }

    /// DTXFSTS3 Register bits
    namespace dtxfsts3_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL3 = (16 << 0);  ///< D_INEPTXFSPCAVAIL3
    }

    /// DIEPDMAB3 Register bits
    namespace diepdmab3_bits {
        constexpr uint32_t D_DMABUFFERADDR3 = (32 << 0);  ///< D_DMABUFFERADDR3
    }

    /// DIEPCTL4 Register bits
    namespace diepctl4_bits {
        constexpr uint32_t D_MPS4 = (2 << 0);  ///< D_MPS4
        constexpr uint32_t D_USBACTEP4 = (1U << 15);  ///< D_USBACTEP4
        constexpr uint32_t D_NAKSTS4 = (1U << 17);  ///< D_NAKSTS4
        constexpr uint32_t D_EPTYPE4 = (2 << 18);  ///< D_EPTYPE4
        constexpr uint32_t D_STALL4 = (1U << 21);  ///< D_STALL4
        constexpr uint32_t D_TXFNUM4 = (4 << 22);  ///< D_TXFNUM4
        constexpr uint32_t D_CNAK4 = (1U << 26);  ///< D_CNAK4
        constexpr uint32_t DI_SNAK4 = (1U << 27);  ///< DI_SNAK4
        constexpr uint32_t DI_SETD0PID4 = (1U << 28);  ///< DI_SETD0PID4
        constexpr uint32_t DI_SETD1PID4 = (1U << 29);  ///< DI_SETD1PID4
        constexpr uint32_t D_EPDIS4 = (1U << 30);  ///< D_EPDIS4
        constexpr uint32_t D_EPENA4 = (1U << 31);  ///< D_EPENA4
    }

    /// DIEPINT4 Register bits
    namespace diepint4_bits {
        constexpr uint32_t D_XFERCOMPL4 = (1U << 0);  ///< D_XFERCOMPL4
        constexpr uint32_t D_EPDISBLD4 = (1U << 1);  ///< D_EPDISBLD4
        constexpr uint32_t D_AHBERR4 = (1U << 2);  ///< D_AHBERR4
        constexpr uint32_t D_TIMEOUT4 = (1U << 3);  ///< D_TIMEOUT4
        constexpr uint32_t D_INTKNTXFEMP4 = (1U << 4);  ///< D_INTKNTXFEMP4
        constexpr uint32_t D_INTKNEPMIS4 = (1U << 5);  ///< D_INTKNEPMIS4
        constexpr uint32_t D_INEPNAKEFF4 = (1U << 6);  ///< D_INEPNAKEFF4
        constexpr uint32_t D_TXFEMP4 = (1U << 7);  ///< D_TXFEMP4
        constexpr uint32_t D_TXFIFOUNDRN4 = (1U << 8);  ///< D_TXFIFOUNDRN4
        constexpr uint32_t D_BNAINTR4 = (1U << 9);  ///< D_BNAINTR4
        constexpr uint32_t D_PKTDRPSTS4 = (1U << 11);  ///< D_PKTDRPSTS4
        constexpr uint32_t D_BBLEERR4 = (1U << 12);  ///< D_BBLEERR4
        constexpr uint32_t D_NAKINTRPT4 = (1U << 13);  ///< D_NAKINTRPT4
        constexpr uint32_t D_NYETINTRPT4 = (1U << 14);  ///< D_NYETINTRPT4
    }

    /// DIEPTSIZ4 Register bits
    namespace dieptsiz4_bits {
        constexpr uint32_t D_XFERSIZE4 = (7 << 0);  ///< D_XFERSIZE4
        constexpr uint32_t D_PKTCNT4 = (2 << 19);  ///< D_PKTCNT4
    }

    /// DIEPDMA4 Register bits
    namespace diepdma4_bits {
        constexpr uint32_t D_DMAADDR4 = (32 << 0);  ///< D_DMAADDR4
    }

    /// DTXFSTS4 Register bits
    namespace dtxfsts4_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL4 = (16 << 0);  ///< D_INEPTXFSPCAVAIL4
    }

    /// DIEPDMAB4 Register bits
    namespace diepdmab4_bits {
        constexpr uint32_t D_DMABUFFERADDR4 = (32 << 0);  ///< D_DMABUFFERADDR4
    }

    /// DIEPCTL5 Register bits
    namespace diepctl5_bits {
        constexpr uint32_t DI_MPS5 = (2 << 0);  ///< DI_MPS5
        constexpr uint32_t DI_USBACTEP5 = (1U << 15);  ///< DI_USBACTEP5
        constexpr uint32_t DI_NAKSTS5 = (1U << 17);  ///< DI_NAKSTS5
        constexpr uint32_t DI_EPTYPE5 = (2 << 18);  ///< DI_EPTYPE5
        constexpr uint32_t DI_STALL5 = (1U << 21);  ///< DI_STALL5
        constexpr uint32_t DI_TXFNUM5 = (4 << 22);  ///< DI_TXFNUM5
        constexpr uint32_t DI_CNAK5 = (1U << 26);  ///< DI_CNAK5
        constexpr uint32_t DI_SNAK5 = (1U << 27);  ///< DI_SNAK5
        constexpr uint32_t DI_SETD0PID5 = (1U << 28);  ///< DI_SETD0PID5
        constexpr uint32_t DI_SETD1PID5 = (1U << 29);  ///< DI_SETD1PID5
        constexpr uint32_t DI_EPDIS5 = (1U << 30);  ///< DI_EPDIS5
        constexpr uint32_t DI_EPENA5 = (1U << 31);  ///< DI_EPENA5
    }

    /// DIEPINT5 Register bits
    namespace diepint5_bits {
        constexpr uint32_t D_XFERCOMPL5 = (1U << 0);  ///< D_XFERCOMPL5
        constexpr uint32_t D_EPDISBLD5 = (1U << 1);  ///< D_EPDISBLD5
        constexpr uint32_t D_AHBERR5 = (1U << 2);  ///< D_AHBERR5
        constexpr uint32_t D_TIMEOUT5 = (1U << 3);  ///< D_TIMEOUT5
        constexpr uint32_t D_INTKNTXFEMP5 = (1U << 4);  ///< D_INTKNTXFEMP5
        constexpr uint32_t D_INTKNEPMIS5 = (1U << 5);  ///< D_INTKNEPMIS5
        constexpr uint32_t D_INEPNAKEFF5 = (1U << 6);  ///< D_INEPNAKEFF5
        constexpr uint32_t D_TXFEMP5 = (1U << 7);  ///< D_TXFEMP5
        constexpr uint32_t D_TXFIFOUNDRN5 = (1U << 8);  ///< D_TXFIFOUNDRN5
        constexpr uint32_t D_BNAINTR5 = (1U << 9);  ///< D_BNAINTR5
        constexpr uint32_t D_PKTDRPSTS5 = (1U << 11);  ///< D_PKTDRPSTS5
        constexpr uint32_t D_BBLEERR5 = (1U << 12);  ///< D_BBLEERR5
        constexpr uint32_t D_NAKINTRPT5 = (1U << 13);  ///< D_NAKINTRPT5
        constexpr uint32_t D_NYETINTRPT5 = (1U << 14);  ///< D_NYETINTRPT5
    }

    /// DIEPTSIZ5 Register bits
    namespace dieptsiz5_bits {
        constexpr uint32_t D_XFERSIZE5 = (7 << 0);  ///< D_XFERSIZE5
        constexpr uint32_t D_PKTCNT5 = (2 << 19);  ///< D_PKTCNT5
    }

    /// DIEPDMA5 Register bits
    namespace diepdma5_bits {
        constexpr uint32_t D_DMAADDR5 = (32 << 0);  ///< D_DMAADDR5
    }

    /// DTXFSTS5 Register bits
    namespace dtxfsts5_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL5 = (16 << 0);  ///< D_INEPTXFSPCAVAIL5
    }

    /// DIEPDMAB5 Register bits
    namespace diepdmab5_bits {
        constexpr uint32_t D_DMABUFFERADDR5 = (32 << 0);  ///< D_DMABUFFERADDR5
    }

    /// DIEPCTL6 Register bits
    namespace diepctl6_bits {
        constexpr uint32_t D_MPS6 = (2 << 0);  ///< D_MPS6
        constexpr uint32_t D_USBACTEP6 = (1U << 15);  ///< D_USBACTEP6
        constexpr uint32_t D_NAKSTS6 = (1U << 17);  ///< D_NAKSTS6
        constexpr uint32_t D_EPTYPE6 = (2 << 18);  ///< D_EPTYPE6
        constexpr uint32_t D_STALL6 = (1U << 21);  ///< D_STALL6
        constexpr uint32_t D_TXFNUM6 = (4 << 22);  ///< D_TXFNUM6
        constexpr uint32_t D_CNAK6 = (1U << 26);  ///< D_CNAK6
        constexpr uint32_t DI_SNAK6 = (1U << 27);  ///< DI_SNAK6
        constexpr uint32_t DI_SETD0PID6 = (1U << 28);  ///< DI_SETD0PID6
        constexpr uint32_t DI_SETD1PID6 = (1U << 29);  ///< DI_SETD1PID6
        constexpr uint32_t D_EPDIS6 = (1U << 30);  ///< D_EPDIS6
        constexpr uint32_t D_EPENA6 = (1U << 31);  ///< D_EPENA6
    }

    /// DIEPINT6 Register bits
    namespace diepint6_bits {
        constexpr uint32_t D_XFERCOMPL6 = (1U << 0);  ///< D_XFERCOMPL6
        constexpr uint32_t D_EPDISBLD6 = (1U << 1);  ///< D_EPDISBLD6
        constexpr uint32_t D_AHBERR6 = (1U << 2);  ///< D_AHBERR6
        constexpr uint32_t D_TIMEOUT6 = (1U << 3);  ///< D_TIMEOUT6
        constexpr uint32_t D_INTKNTXFEMP6 = (1U << 4);  ///< D_INTKNTXFEMP6
        constexpr uint32_t D_INTKNEPMIS6 = (1U << 5);  ///< D_INTKNEPMIS6
        constexpr uint32_t D_INEPNAKEFF6 = (1U << 6);  ///< D_INEPNAKEFF6
        constexpr uint32_t D_TXFEMP6 = (1U << 7);  ///< D_TXFEMP6
        constexpr uint32_t D_TXFIFOUNDRN6 = (1U << 8);  ///< D_TXFIFOUNDRN6
        constexpr uint32_t D_BNAINTR6 = (1U << 9);  ///< D_BNAINTR6
        constexpr uint32_t D_PKTDRPSTS6 = (1U << 11);  ///< D_PKTDRPSTS6
        constexpr uint32_t D_BBLEERR6 = (1U << 12);  ///< D_BBLEERR6
        constexpr uint32_t D_NAKINTRPT6 = (1U << 13);  ///< D_NAKINTRPT6
        constexpr uint32_t D_NYETINTRPT6 = (1U << 14);  ///< D_NYETINTRPT6
    }

    /// DIEPTSIZ6 Register bits
    namespace dieptsiz6_bits {
        constexpr uint32_t D_XFERSIZE6 = (7 << 0);  ///< D_XFERSIZE6
        constexpr uint32_t D_PKTCNT6 = (2 << 19);  ///< D_PKTCNT6
    }

    /// DIEPDMA6 Register bits
    namespace diepdma6_bits {
        constexpr uint32_t D_DMAADDR6 = (32 << 0);  ///< D_DMAADDR6
    }

    /// DTXFSTS6 Register bits
    namespace dtxfsts6_bits {
        constexpr uint32_t D_INEPTXFSPCAVAIL6 = (16 << 0);  ///< D_INEPTXFSPCAVAIL6
    }

    /// DIEPDMAB6 Register bits
    namespace diepdmab6_bits {
        constexpr uint32_t D_DMABUFFERADDR6 = (32 << 0);  ///< D_DMABUFFERADDR6
    }

    /// DOEPCTL0 Register bits
    namespace doepctl0_bits {
        constexpr uint32_t MPS0 = (2 << 0);  ///< MPS0
        constexpr uint32_t USBACTEP0 = (1U << 15);  ///< USBACTEP0
        constexpr uint32_t NAKSTS0 = (1U << 17);  ///< NAKSTS0
        constexpr uint32_t EPTYPE0 = (2 << 18);  ///< EPTYPE0
        constexpr uint32_t SNP0 = (1U << 20);  ///< SNP0
        constexpr uint32_t STALL0 = (1U << 21);  ///< STALL0
        constexpr uint32_t CNAK0 = (1U << 26);  ///< CNAK0
        constexpr uint32_t DO_SNAK0 = (1U << 27);  ///< DO_SNAK0
        constexpr uint32_t EPDIS0 = (1U << 30);  ///< EPDIS0
        constexpr uint32_t EPENA0 = (1U << 31);  ///< EPENA0
    }

    /// DOEPINT0 Register bits
    namespace doepint0_bits {
        constexpr uint32_t XFERCOMPL0 = (1U << 0);  ///< XFERCOMPL0
        constexpr uint32_t EPDISBLD0 = (1U << 1);  ///< EPDISBLD0
        constexpr uint32_t AHBERR0 = (1U << 2);  ///< AHBERR0
        constexpr uint32_t SETUP0 = (1U << 3);  ///< SETUP0
        constexpr uint32_t OUTTKNEPDIS0 = (1U << 4);  ///< OUTTKNEPDIS0
        constexpr uint32_t STSPHSERCVD0 = (1U << 5);  ///< STSPHSERCVD0
        constexpr uint32_t BACK2BACKSETUP0 = (1U << 6);  ///< BACK2BACKSETUP0
        constexpr uint32_t OUTPKTERR0 = (1U << 8);  ///< OUTPKTERR0
        constexpr uint32_t BNAINTR0 = (1U << 9);  ///< BNAINTR0
        constexpr uint32_t PKTDRPSTS0 = (1U << 11);  ///< PKTDRPSTS0
        constexpr uint32_t BBLEERR0 = (1U << 12);  ///< BBLEERR0
        constexpr uint32_t NAKINTRPT0 = (1U << 13);  ///< NAKINTRPT0
        constexpr uint32_t NYEPINTRPT0 = (1U << 14);  ///< NYEPINTRPT0
        constexpr uint32_t STUPPKTRCVD0 = (1U << 15);  ///< STUPPKTRCVD0
    }

    /// DOEPTSIZ0 Register bits
    namespace doeptsiz0_bits {
        constexpr uint32_t XFERSIZE0 = (7 << 0);  ///< XFERSIZE0
        constexpr uint32_t PKTCNT0 = (1U << 19);  ///< PKTCNT0
        constexpr uint32_t SUPCNT0 = (2 << 29);  ///< SUPCNT0
    }

    /// DOEPDMA0 Register bits
    namespace doepdma0_bits {
        constexpr uint32_t DMAADDR0 = (32 << 0);  ///< DMAADDR0
    }

    /// DOEPDMAB0 Register bits
    namespace doepdmab0_bits {
        constexpr uint32_t DMABUFFERADDR0 = (32 << 0);  ///< DMABUFFERADDR0
    }

    /// DOEPCTL1 Register bits
    namespace doepctl1_bits {
        constexpr uint32_t MPS1 = (11 << 0);  ///< MPS1
        constexpr uint32_t USBACTEP1 = (1U << 15);  ///< USBACTEP1
        constexpr uint32_t NAKSTS1 = (1U << 17);  ///< NAKSTS1
        constexpr uint32_t EPTYPE1 = (2 << 18);  ///< EPTYPE1
        constexpr uint32_t SNP1 = (1U << 20);  ///< SNP1
        constexpr uint32_t STALL1 = (1U << 21);  ///< STALL1
        constexpr uint32_t CNAK1 = (1U << 26);  ///< CNAK1
        constexpr uint32_t DO_SNAK1 = (1U << 27);  ///< DO_SNAK1
        constexpr uint32_t DO_SETD0PID1 = (1U << 28);  ///< DO_SETD0PID1
        constexpr uint32_t DO_SETD1PID1 = (1U << 29);  ///< DO_SETD1PID1
        constexpr uint32_t EPDIS1 = (1U << 30);  ///< EPDIS1
        constexpr uint32_t EPENA1 = (1U << 31);  ///< EPENA1
    }

    /// DOEPINT1 Register bits
    namespace doepint1_bits {
        constexpr uint32_t XFERCOMPL1 = (1U << 0);  ///< XFERCOMPL1
        constexpr uint32_t EPDISBLD1 = (1U << 1);  ///< EPDISBLD1
        constexpr uint32_t AHBERR1 = (1U << 2);  ///< AHBERR1
        constexpr uint32_t SETUP1 = (1U << 3);  ///< SETUP1
        constexpr uint32_t OUTTKNEPDIS1 = (1U << 4);  ///< OUTTKNEPDIS1
        constexpr uint32_t STSPHSERCVD1 = (1U << 5);  ///< STSPHSERCVD1
        constexpr uint32_t BACK2BACKSETUP1 = (1U << 6);  ///< BACK2BACKSETUP1
        constexpr uint32_t OUTPKTERR1 = (1U << 8);  ///< OUTPKTERR1
        constexpr uint32_t BNAINTR1 = (1U << 9);  ///< BNAINTR1
        constexpr uint32_t PKTDRPSTS1 = (1U << 11);  ///< PKTDRPSTS1
        constexpr uint32_t BBLEERR1 = (1U << 12);  ///< BBLEERR1
        constexpr uint32_t NAKINTRPT1 = (1U << 13);  ///< NAKINTRPT1
        constexpr uint32_t NYEPINTRPT1 = (1U << 14);  ///< NYEPINTRPT1
        constexpr uint32_t STUPPKTRCVD1 = (1U << 15);  ///< STUPPKTRCVD1
    }

    /// DOEPTSIZ1 Register bits
    namespace doeptsiz1_bits {
        constexpr uint32_t XFERSIZE1 = (7 << 0);  ///< XFERSIZE1
        constexpr uint32_t PKTCNT1 = (1U << 19);  ///< PKTCNT1
        constexpr uint32_t SUPCNT1 = (2 << 29);  ///< SUPCNT1
    }

    /// DOEPDMA1 Register bits
    namespace doepdma1_bits {
        constexpr uint32_t DMAADDR1 = (32 << 0);  ///< DMAADDR1
    }

    /// DOEPDMAB1 Register bits
    namespace doepdmab1_bits {
        constexpr uint32_t DMABUFFERADDR1 = (32 << 0);  ///< DMABUFFERADDR1
    }

    /// DOEPCTL2 Register bits
    namespace doepctl2_bits {
        constexpr uint32_t MPS2 = (11 << 0);  ///< MPS2
        constexpr uint32_t USBACTEP2 = (1U << 15);  ///< USBACTEP2
        constexpr uint32_t NAKSTS2 = (1U << 17);  ///< NAKSTS2
        constexpr uint32_t EPTYPE2 = (2 << 18);  ///< EPTYPE2
        constexpr uint32_t SNP2 = (1U << 20);  ///< SNP2
        constexpr uint32_t STALL2 = (1U << 21);  ///< STALL2
        constexpr uint32_t CNAK2 = (1U << 26);  ///< CNAK2
        constexpr uint32_t DO_SNAK2 = (1U << 27);  ///< DO_SNAK2
        constexpr uint32_t DO_SETD0PID2 = (1U << 28);  ///< DO_SETD0PID2
        constexpr uint32_t DO_SETD1PID2 = (1U << 29);  ///< DO_SETD1PID2
        constexpr uint32_t EPDIS2 = (1U << 30);  ///< EPDIS2
        constexpr uint32_t EPENA2 = (1U << 31);  ///< EPENA2
    }

    /// DOEPINT2 Register bits
    namespace doepint2_bits {
        constexpr uint32_t XFERCOMPL2 = (1U << 0);  ///< XFERCOMPL2
        constexpr uint32_t EPDISBLD2 = (1U << 1);  ///< EPDISBLD2
        constexpr uint32_t AHBERR2 = (1U << 2);  ///< AHBERR2
        constexpr uint32_t SETUP2 = (1U << 3);  ///< SETUP2
        constexpr uint32_t OUTTKNEPDIS2 = (1U << 4);  ///< OUTTKNEPDIS2
        constexpr uint32_t STSPHSERCVD2 = (1U << 5);  ///< STSPHSERCVD2
        constexpr uint32_t BACK2BACKSETUP2 = (1U << 6);  ///< BACK2BACKSETUP2
        constexpr uint32_t OUTPKTERR2 = (1U << 8);  ///< OUTPKTERR2
        constexpr uint32_t BNAINTR2 = (1U << 9);  ///< BNAINTR2
        constexpr uint32_t PKTDRPSTS2 = (1U << 11);  ///< PKTDRPSTS2
        constexpr uint32_t BBLEERR2 = (1U << 12);  ///< BBLEERR2
        constexpr uint32_t NAKINTRPT2 = (1U << 13);  ///< NAKINTRPT2
        constexpr uint32_t NYEPINTRPT2 = (1U << 14);  ///< NYEPINTRPT2
        constexpr uint32_t STUPPKTRCVD2 = (1U << 15);  ///< STUPPKTRCVD2
    }

    /// DOEPTSIZ2 Register bits
    namespace doeptsiz2_bits {
        constexpr uint32_t XFERSIZE2 = (7 << 0);  ///< XFERSIZE2
        constexpr uint32_t PKTCNT2 = (1U << 19);  ///< PKTCNT2
        constexpr uint32_t SUPCNT2 = (2 << 29);  ///< SUPCNT2
    }

    /// DOEPDMA2 Register bits
    namespace doepdma2_bits {
        constexpr uint32_t DMAADDR2 = (32 << 0);  ///< DMAADDR2
    }

    /// DOEPDMAB2 Register bits
    namespace doepdmab2_bits {
        constexpr uint32_t DMABUFFERADDR2 = (32 << 0);  ///< DMABUFFERADDR2
    }

    /// DOEPCTL3 Register bits
    namespace doepctl3_bits {
        constexpr uint32_t MPS3 = (11 << 0);  ///< MPS3
        constexpr uint32_t USBACTEP3 = (1U << 15);  ///< USBACTEP3
        constexpr uint32_t NAKSTS3 = (1U << 17);  ///< NAKSTS3
        constexpr uint32_t EPTYPE3 = (2 << 18);  ///< EPTYPE3
        constexpr uint32_t SNP3 = (1U << 20);  ///< SNP3
        constexpr uint32_t STALL3 = (1U << 21);  ///< STALL3
        constexpr uint32_t CNAK3 = (1U << 26);  ///< CNAK3
        constexpr uint32_t DO_SNAK3 = (1U << 27);  ///< DO_SNAK3
        constexpr uint32_t DO_SETD0PID3 = (1U << 28);  ///< DO_SETD0PID3
        constexpr uint32_t DO_SETD1PID3 = (1U << 29);  ///< DO_SETD1PID3
        constexpr uint32_t EPDIS3 = (1U << 30);  ///< EPDIS3
        constexpr uint32_t EPENA3 = (1U << 31);  ///< EPENA3
    }

    /// DOEPINT3 Register bits
    namespace doepint3_bits {
        constexpr uint32_t XFERCOMPL3 = (1U << 0);  ///< XFERCOMPL3
        constexpr uint32_t EPDISBLD3 = (1U << 1);  ///< EPDISBLD3
        constexpr uint32_t AHBERR3 = (1U << 2);  ///< AHBERR3
        constexpr uint32_t SETUP3 = (1U << 3);  ///< SETUP3
        constexpr uint32_t OUTTKNEPDIS3 = (1U << 4);  ///< OUTTKNEPDIS3
        constexpr uint32_t STSPHSERCVD3 = (1U << 5);  ///< STSPHSERCVD3
        constexpr uint32_t BACK2BACKSETUP3 = (1U << 6);  ///< BACK2BACKSETUP3
        constexpr uint32_t OUTPKTERR3 = (1U << 8);  ///< OUTPKTERR3
        constexpr uint32_t BNAINTR3 = (1U << 9);  ///< BNAINTR3
        constexpr uint32_t PKTDRPSTS3 = (1U << 11);  ///< PKTDRPSTS3
        constexpr uint32_t BBLEERR3 = (1U << 12);  ///< BBLEERR3
        constexpr uint32_t NAKINTRPT3 = (1U << 13);  ///< NAKINTRPT3
        constexpr uint32_t NYEPINTRPT3 = (1U << 14);  ///< NYEPINTRPT3
        constexpr uint32_t STUPPKTRCVD3 = (1U << 15);  ///< STUPPKTRCVD3
    }

    /// DOEPTSIZ3 Register bits
    namespace doeptsiz3_bits {
        constexpr uint32_t XFERSIZE3 = (7 << 0);  ///< XFERSIZE3
        constexpr uint32_t PKTCNT3 = (1U << 19);  ///< PKTCNT3
        constexpr uint32_t SUPCNT3 = (2 << 29);  ///< SUPCNT3
    }

    /// DOEPDMA3 Register bits
    namespace doepdma3_bits {
        constexpr uint32_t DMAADDR3 = (32 << 0);  ///< DMAADDR3
    }

    /// DOEPDMAB3 Register bits
    namespace doepdmab3_bits {
        constexpr uint32_t DMABUFFERADDR3 = (32 << 0);  ///< DMABUFFERADDR3
    }

    /// DOEPCTL4 Register bits
    namespace doepctl4_bits {
        constexpr uint32_t MPS4 = (11 << 0);  ///< MPS4
        constexpr uint32_t USBACTEP4 = (1U << 15);  ///< USBACTEP4
        constexpr uint32_t NAKSTS4 = (1U << 17);  ///< NAKSTS4
        constexpr uint32_t EPTYPE4 = (2 << 18);  ///< EPTYPE4
        constexpr uint32_t SNP4 = (1U << 20);  ///< SNP4
        constexpr uint32_t STALL4 = (1U << 21);  ///< STALL4
        constexpr uint32_t CNAK4 = (1U << 26);  ///< CNAK4
        constexpr uint32_t DO_SNAK4 = (1U << 27);  ///< DO_SNAK4
        constexpr uint32_t DO_SETD0PID4 = (1U << 28);  ///< DO_SETD0PID4
        constexpr uint32_t DO_SETD1PID4 = (1U << 29);  ///< DO_SETD1PID4
        constexpr uint32_t EPDIS4 = (1U << 30);  ///< EPDIS4
        constexpr uint32_t EPENA4 = (1U << 31);  ///< EPENA4
    }

    /// DOEPINT4 Register bits
    namespace doepint4_bits {
        constexpr uint32_t XFERCOMPL4 = (1U << 0);  ///< XFERCOMPL4
        constexpr uint32_t EPDISBLD4 = (1U << 1);  ///< EPDISBLD4
        constexpr uint32_t AHBERR4 = (1U << 2);  ///< AHBERR4
        constexpr uint32_t SETUP4 = (1U << 3);  ///< SETUP4
        constexpr uint32_t OUTTKNEPDIS4 = (1U << 4);  ///< OUTTKNEPDIS4
        constexpr uint32_t STSPHSERCVD4 = (1U << 5);  ///< STSPHSERCVD4
        constexpr uint32_t BACK2BACKSETUP4 = (1U << 6);  ///< BACK2BACKSETUP4
        constexpr uint32_t OUTPKTERR4 = (1U << 8);  ///< OUTPKTERR4
        constexpr uint32_t BNAINTR4 = (1U << 9);  ///< BNAINTR4
        constexpr uint32_t PKTDRPSTS4 = (1U << 11);  ///< PKTDRPSTS4
        constexpr uint32_t BBLEERR4 = (1U << 12);  ///< BBLEERR4
        constexpr uint32_t NAKINTRPT4 = (1U << 13);  ///< NAKINTRPT4
        constexpr uint32_t NYEPINTRPT4 = (1U << 14);  ///< NYEPINTRPT4
        constexpr uint32_t STUPPKTRCVD4 = (1U << 15);  ///< STUPPKTRCVD4
    }

    /// DOEPTSIZ4 Register bits
    namespace doeptsiz4_bits {
        constexpr uint32_t XFERSIZE4 = (7 << 0);  ///< XFERSIZE4
        constexpr uint32_t PKTCNT4 = (1U << 19);  ///< PKTCNT4
        constexpr uint32_t SUPCNT4 = (2 << 29);  ///< SUPCNT4
    }

    /// DOEPDMA4 Register bits
    namespace doepdma4_bits {
        constexpr uint32_t DMAADDR4 = (32 << 0);  ///< DMAADDR4
    }

    /// DOEPDMAB4 Register bits
    namespace doepdmab4_bits {
        constexpr uint32_t DMABUFFERADDR4 = (32 << 0);  ///< DMABUFFERADDR4
    }

    /// DOEPCTL5 Register bits
    namespace doepctl5_bits {
        constexpr uint32_t MPS5 = (11 << 0);  ///< MPS5
        constexpr uint32_t USBACTEP5 = (1U << 15);  ///< USBACTEP5
        constexpr uint32_t NAKSTS5 = (1U << 17);  ///< NAKSTS5
        constexpr uint32_t EPTYPE5 = (2 << 18);  ///< EPTYPE5
        constexpr uint32_t SNP5 = (1U << 20);  ///< SNP5
        constexpr uint32_t STALL5 = (1U << 21);  ///< STALL5
        constexpr uint32_t CNAK5 = (1U << 26);  ///< CNAK5
        constexpr uint32_t DO_SNAK5 = (1U << 27);  ///< DO_SNAK5
        constexpr uint32_t DO_SETD0PID5 = (1U << 28);  ///< DO_SETD0PID5
        constexpr uint32_t DO_SETD1PID5 = (1U << 29);  ///< DO_SETD1PID5
        constexpr uint32_t EPDIS5 = (1U << 30);  ///< EPDIS5
        constexpr uint32_t EPENA5 = (1U << 31);  ///< EPENA5
    }

    /// DOEPINT5 Register bits
    namespace doepint5_bits {
        constexpr uint32_t XFERCOMPL5 = (1U << 0);  ///< XFERCOMPL5
        constexpr uint32_t EPDISBLD5 = (1U << 1);  ///< EPDISBLD5
        constexpr uint32_t AHBERR5 = (1U << 2);  ///< AHBERR5
        constexpr uint32_t SETUP5 = (1U << 3);  ///< SETUP5
        constexpr uint32_t OUTTKNEPDIS5 = (1U << 4);  ///< OUTTKNEPDIS5
        constexpr uint32_t STSPHSERCVD5 = (1U << 5);  ///< STSPHSERCVD5
        constexpr uint32_t BACK2BACKSETUP5 = (1U << 6);  ///< BACK2BACKSETUP5
        constexpr uint32_t OUTPKTERR5 = (1U << 8);  ///< OUTPKTERR5
        constexpr uint32_t BNAINTR5 = (1U << 9);  ///< BNAINTR5
        constexpr uint32_t PKTDRPSTS5 = (1U << 11);  ///< PKTDRPSTS5
        constexpr uint32_t BBLEERR5 = (1U << 12);  ///< BBLEERR5
        constexpr uint32_t NAKINTRPT5 = (1U << 13);  ///< NAKINTRPT5
        constexpr uint32_t NYEPINTRPT5 = (1U << 14);  ///< NYEPINTRPT5
        constexpr uint32_t STUPPKTRCVD5 = (1U << 15);  ///< STUPPKTRCVD5
    }

    /// DOEPTSIZ5 Register bits
    namespace doeptsiz5_bits {
        constexpr uint32_t XFERSIZE5 = (7 << 0);  ///< XFERSIZE5
        constexpr uint32_t PKTCNT5 = (1U << 19);  ///< PKTCNT5
        constexpr uint32_t SUPCNT5 = (2 << 29);  ///< SUPCNT5
    }

    /// DOEPDMA5 Register bits
    namespace doepdma5_bits {
        constexpr uint32_t DMAADDR5 = (32 << 0);  ///< DMAADDR5
    }

    /// DOEPDMAB5 Register bits
    namespace doepdmab5_bits {
        constexpr uint32_t DMABUFFERADDR5 = (32 << 0);  ///< DMABUFFERADDR5
    }

    /// DOEPCTL6 Register bits
    namespace doepctl6_bits {
        constexpr uint32_t MPS6 = (11 << 0);  ///< MPS6
        constexpr uint32_t USBACTEP6 = (1U << 15);  ///< USBACTEP6
        constexpr uint32_t NAKSTS6 = (1U << 17);  ///< NAKSTS6
        constexpr uint32_t EPTYPE6 = (2 << 18);  ///< EPTYPE6
        constexpr uint32_t SNP6 = (1U << 20);  ///< SNP6
        constexpr uint32_t STALL6 = (1U << 21);  ///< STALL6
        constexpr uint32_t CNAK6 = (1U << 26);  ///< CNAK6
        constexpr uint32_t DO_SNAK6 = (1U << 27);  ///< DO_SNAK6
        constexpr uint32_t DO_SETD0PID6 = (1U << 28);  ///< DO_SETD0PID6
        constexpr uint32_t DO_SETD1PID6 = (1U << 29);  ///< DO_SETD1PID6
        constexpr uint32_t EPDIS6 = (1U << 30);  ///< EPDIS6
        constexpr uint32_t EPENA6 = (1U << 31);  ///< EPENA6
    }

    /// DOEPINT6 Register bits
    namespace doepint6_bits {
        constexpr uint32_t XFERCOMPL6 = (1U << 0);  ///< XFERCOMPL6
        constexpr uint32_t EPDISBLD6 = (1U << 1);  ///< EPDISBLD6
        constexpr uint32_t AHBERR6 = (1U << 2);  ///< AHBERR6
        constexpr uint32_t SETUP6 = (1U << 3);  ///< SETUP6
        constexpr uint32_t OUTTKNEPDIS6 = (1U << 4);  ///< OUTTKNEPDIS6
        constexpr uint32_t STSPHSERCVD6 = (1U << 5);  ///< STSPHSERCVD6
        constexpr uint32_t BACK2BACKSETUP6 = (1U << 6);  ///< BACK2BACKSETUP6
        constexpr uint32_t OUTPKTERR6 = (1U << 8);  ///< OUTPKTERR6
        constexpr uint32_t BNAINTR6 = (1U << 9);  ///< BNAINTR6
        constexpr uint32_t PKTDRPSTS6 = (1U << 11);  ///< PKTDRPSTS6
        constexpr uint32_t BBLEERR6 = (1U << 12);  ///< BBLEERR6
        constexpr uint32_t NAKINTRPT6 = (1U << 13);  ///< NAKINTRPT6
        constexpr uint32_t NYEPINTRPT6 = (1U << 14);  ///< NYEPINTRPT6
        constexpr uint32_t STUPPKTRCVD6 = (1U << 15);  ///< STUPPKTRCVD6
    }

    /// DOEPTSIZ6 Register bits
    namespace doeptsiz6_bits {
        constexpr uint32_t XFERSIZE6 = (7 << 0);  ///< XFERSIZE6
        constexpr uint32_t PKTCNT6 = (1U << 19);  ///< PKTCNT6
        constexpr uint32_t SUPCNT6 = (2 << 29);  ///< SUPCNT6
    }

    /// DOEPDMA6 Register bits
    namespace doepdma6_bits {
        constexpr uint32_t DMAADDR6 = (32 << 0);  ///< DMAADDR6
    }

    /// DOEPDMAB6 Register bits
    namespace doepdmab6_bits {
        constexpr uint32_t DMABUFFERADDR6 = (32 << 0);  ///< DMABUFFERADDR6
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t STOPPCLK = (1U << 0);  ///< STOPPCLK
        constexpr uint32_t GATEHCLK = (1U << 1);  ///< GATEHCLK
        constexpr uint32_t PWRCLMP = (1U << 2);  ///< PWRCLMP
        constexpr uint32_t RSTPDWNMODULE = (1U << 3);  ///< RSTPDWNMODULE
        constexpr uint32_t PHYSLEEP = (1U << 6);  ///< PHYSLEEP
        constexpr uint32_t L1SUSPENDED = (1U << 7);  ///< L1SUSPENDED
        constexpr uint32_t RESETAFTERSUSP = (1U << 8);  ///< RESETAFTERSUSP
    }

}

// ============================================================================
// WCL Peripheral
// ============================================================================

namespace wcl {
    /// Base addresses
    constexpr uint32_t WCL_BASE = 0x600D0000;

    /// WCL Register structure
    struct Registers {
        volatile uint32_t Core_0_ENTRY_1_ADDR;  ///< Offset: 0x00 - Core_0 Entry 1 address configuration Register
        volatile uint32_t Core_0_ENTRY_2_ADDR;  ///< Offset: 0x04 - Core_0 Entry 2 address configuration Register
        volatile uint32_t Core_0_ENTRY_3_ADDR;  ///< Offset: 0x08 - Core_0 Entry 3 address configuration Register
        volatile uint32_t Core_0_ENTRY_4_ADDR;  ///< Offset: 0x0C - Core_0 Entry 4 address configuration Register
        volatile uint32_t Core_0_ENTRY_5_ADDR;  ///< Offset: 0x10 - Core_0 Entry 5 address configuration Register
        volatile uint32_t Core_0_ENTRY_6_ADDR;  ///< Offset: 0x14 - Core_0 Entry 6 address configuration Register
        volatile uint32_t Core_0_ENTRY_7_ADDR;  ///< Offset: 0x18 - Core_0 Entry 7 address configuration Register
        volatile uint32_t Core_0_ENTRY_8_ADDR;  ///< Offset: 0x1C - Core_0 Entry 8 address configuration Register
        volatile uint32_t Core_0_ENTRY_9_ADDR;  ///< Offset: 0x20 - Core_0 Entry 9 address configuration Register
        volatile uint32_t Core_0_ENTRY_10_ADDR;  ///< Offset: 0x24 - Core_0 Entry 10 address configuration Register
        volatile uint32_t Core_0_ENTRY_11_ADDR;  ///< Offset: 0x28 - Core_0 Entry 11 address configuration Register
        volatile uint32_t Core_0_ENTRY_12_ADDR;  ///< Offset: 0x2C - Core_0 Entry 12 address configuration Register
        volatile uint32_t Core_0_ENTRY_13_ADDR;  ///< Offset: 0x30 - Core_0 Entry 13 address configuration Register
        volatile uint32_t Core_0_ENTRY_CHECK;  ///< Offset: 0x7C - Core_0 Entry check configuration Register
        volatile uint32_t Core_0_STATUSTABLE1;  ///< Offset: 0x80 - Status register of world switch of entry 1
        volatile uint32_t Core_0_STATUSTABLE2;  ///< Offset: 0x84 - Status register of world switch of entry 2
        volatile uint32_t Core_0_STATUSTABLE3;  ///< Offset: 0x88 - Status register of world switch of entry 3
        volatile uint32_t Core_0_STATUSTABLE4;  ///< Offset: 0x8C - Status register of world switch of entry 4
        volatile uint32_t Core_0_STATUSTABLE5;  ///< Offset: 0x90 - Status register of world switch of entry 5
        volatile uint32_t Core_0_STATUSTABLE6;  ///< Offset: 0x94 - Status register of world switch of entry 6
        volatile uint32_t Core_0_STATUSTABLE7;  ///< Offset: 0x98 - Status register of world switch of entry 7
        volatile uint32_t Core_0_STATUSTABLE8;  ///< Offset: 0x9C - Status register of world switch of entry 8
        volatile uint32_t Core_0_STATUSTABLE9;  ///< Offset: 0xA0 - Status register of world switch of entry 9
        volatile uint32_t Core_0_STATUSTABLE10;  ///< Offset: 0xA4 - Status register of world switch of entry 10
        volatile uint32_t Core_0_STATUSTABLE11;  ///< Offset: 0xA8 - Status register of world switch of entry 11
        volatile uint32_t Core_0_STATUSTABLE12;  ///< Offset: 0xAC - Status register of world switch of entry 12
        volatile uint32_t Core_0_STATUSTABLE13;  ///< Offset: 0xB0 - Status register of world switch of entry 13
        volatile uint32_t Core_0_STATUSTABLE_CURRENT;  ///< Offset: 0xFC - Status register of statustable current
        volatile uint32_t Core_0_MESSAGE_ADDR;  ///< Offset: 0x100 - Clear writer_buffer write address configuration register
        volatile uint32_t Core_0_MESSAGE_MAX;  ///< Offset: 0x104 - Clear writer_buffer write number configuration register
        volatile uint32_t Core_0_MESSAGE_PHASE;  ///< Offset: 0x108 - Clear writer_buffer status register
        volatile uint32_t Core_0_World_TRIGGER_ADDR;  ///< Offset: 0x140 - Core_0 trigger address configuration Register
        volatile uint32_t Core_0_World_PREPARE;  ///< Offset: 0x144 - Core_0 prepare world configuration Register
        volatile uint32_t Core_0_World_UPDATE;  ///< Offset: 0x148 - Core_0 configuration update register
        volatile uint32_t Core_0_World_Cancel;  ///< Offset: 0x14C - Core_0 configuration cancel register
        volatile uint32_t Core_0_World_IRam0;  ///< Offset: 0x150 - Core_0 Iram0 world register
        volatile uint32_t Core_0_World_DRam0_PIF;  ///< Offset: 0x154 - Core_0 dram0 and PIF world register
        volatile uint32_t Core_0_World_Phase;  ///< Offset: 0x158 - Core_0 world status register
        volatile uint32_t Core_0_NMI_MASK_ENABLE;  ///< Offset: 0x180 - Core_0 NMI mask enable register
        volatile uint32_t Core_0_NMI_MASK_TRIGGER_ADDR;  ///< Offset: 0x184 - Core_0 NMI mask trigger address register
        volatile uint32_t Core_0_NMI_MASK_DISABLE;  ///< Offset: 0x188 - Core_0 NMI mask disable register
        volatile uint32_t Core_0_NMI_MASK_CANCLE;  ///< Offset: 0x18C - Core_0 NMI mask disable register
        volatile uint32_t Core_0_NMI_MASK;  ///< Offset: 0x190 - Core_0 NMI mask register
        volatile uint32_t Core_0_NMI_MASK_PHASE;  ///< Offset: 0x194 - Core_0 NMI mask phase register
        volatile uint32_t Core_1_ENTRY_1_ADDR;  ///< Offset: 0x400 - Core_1 Entry 1 address configuration Register
        volatile uint32_t Core_1_ENTRY_2_ADDR;  ///< Offset: 0x404 - Core_1 Entry 2 address configuration Register
        volatile uint32_t Core_1_ENTRY_3_ADDR;  ///< Offset: 0x408 - Core_1 Entry 3 address configuration Register
        volatile uint32_t Core_1_ENTRY_4_ADDR;  ///< Offset: 0x40C - Core_1 Entry 4 address configuration Register
        volatile uint32_t Core_1_ENTRY_5_ADDR;  ///< Offset: 0x410 - Core_1 Entry 5 address configuration Register
        volatile uint32_t Core_1_ENTRY_6_ADDR;  ///< Offset: 0x414 - Core_1 Entry 6 address configuration Register
        volatile uint32_t Core_1_ENTRY_7_ADDR;  ///< Offset: 0x418 - Core_1 Entry 7 address configuration Register
        volatile uint32_t Core_1_ENTRY_8_ADDR;  ///< Offset: 0x41C - Core_1 Entry 8 address configuration Register
        volatile uint32_t Core_1_ENTRY_9_ADDR;  ///< Offset: 0x420 - Core_1 Entry 9 address configuration Register
        volatile uint32_t Core_1_ENTRY_10_ADDR;  ///< Offset: 0x424 - Core_1 Entry 10 address configuration Register
        volatile uint32_t Core_1_ENTRY_11_ADDR;  ///< Offset: 0x428 - Core_1 Entry 11 address configuration Register
        volatile uint32_t Core_1_ENTRY_12_ADDR;  ///< Offset: 0x42C - Core_1 Entry 12 address configuration Register
        volatile uint32_t Core_1_ENTRY_13_ADDR;  ///< Offset: 0x430 - Core_1 Entry 13 address configuration Register
        volatile uint32_t Core_1_ENTRY_CHECK;  ///< Offset: 0x47C - Core_1 Entry check configuration Register
        volatile uint32_t Core_1_STATUSTABLE1;  ///< Offset: 0x480 - Status register of world switch of entry 1
        volatile uint32_t Core_1_STATUSTABLE2;  ///< Offset: 0x484 - Status register of world switch of entry 2
        volatile uint32_t Core_1_STATUSTABLE3;  ///< Offset: 0x488 - Status register of world switch of entry 3
        volatile uint32_t Core_1_STATUSTABLE4;  ///< Offset: 0x48C - Status register of world switch of entry 4
        volatile uint32_t Core_1_STATUSTABLE5;  ///< Offset: 0x490 - Status register of world switch of entry 5
        volatile uint32_t Core_1_STATUSTABLE6;  ///< Offset: 0x494 - Status register of world switch of entry 6
        volatile uint32_t Core_1_STATUSTABLE7;  ///< Offset: 0x498 - Status register of world switch of entry 7
        volatile uint32_t Core_1_STATUSTABLE8;  ///< Offset: 0x49C - Status register of world switch of entry 8
        volatile uint32_t Core_1_STATUSTABLE9;  ///< Offset: 0x4A0 - Status register of world switch of entry 9
        volatile uint32_t Core_1_STATUSTABLE10;  ///< Offset: 0x4A4 - Status register of world switch of entry 10
        volatile uint32_t Core_1_STATUSTABLE11;  ///< Offset: 0x4A8 - Status register of world switch of entry 11
        volatile uint32_t Core_1_STATUSTABLE12;  ///< Offset: 0x4AC - Status register of world switch of entry 12
        volatile uint32_t Core_1_STATUSTABLE13;  ///< Offset: 0x4B0 - Status register of world switch of entry 13
        volatile uint32_t Core_1_STATUSTABLE_CURRENT;  ///< Offset: 0x4FC - Status register of statustable current
        volatile uint32_t Core_1_MESSAGE_ADDR;  ///< Offset: 0x500 - Clear writer_buffer write address configuration register
        volatile uint32_t Core_1_MESSAGE_MAX;  ///< Offset: 0x504 - Clear writer_buffer write number configuration register
        volatile uint32_t Core_1_MESSAGE_PHASE;  ///< Offset: 0x508 - Clear writer_buffer status register
        volatile uint32_t Core_1_World_TRIGGER_ADDR;  ///< Offset: 0x540 - Core_1 trigger address configuration Register
        volatile uint32_t Core_1_World_PREPARE;  ///< Offset: 0x544 - Core_1 prepare world configuration Register
        volatile uint32_t Core_1_World_UPDATE;  ///< Offset: 0x548 - Core_1 configuration update register
        volatile uint32_t Core_1_World_Cancel;  ///< Offset: 0x54C - Core_1 configuration cancel register
        volatile uint32_t Core_1_World_IRam0;  ///< Offset: 0x550 - Core_1 Iram0 world register
        volatile uint32_t Core_1_World_DRam0_PIF;  ///< Offset: 0x554 - Core_1 dram0 and PIF world register
        volatile uint32_t Core_1_World_Phase;  ///< Offset: 0x558 - Core_0 world status register
        volatile uint32_t Core_1_NMI_MASK_ENABLE;  ///< Offset: 0x580 - Core_1 NMI mask enable register
        volatile uint32_t Core_1_NMI_MASK_TRIGGER_ADDR;  ///< Offset: 0x584 - Core_1 NMI mask trigger addr register
        volatile uint32_t Core_1_NMI_MASK_DISABLE;  ///< Offset: 0x588 - Core_1 NMI mask disable register
        volatile uint32_t Core_1_NMI_MASK_CANCLE;  ///< Offset: 0x58C - Core_1 NMI mask disable register
        volatile uint32_t Core_1_NMI_MASK;  ///< Offset: 0x590 - Core_1 NMI mask register
        volatile uint32_t Core_1_NMI_MASK_PHASE;  ///< Offset: 0x594 - Core_1 NMI mask phase register
    };

    /// Peripheral instances
    inline Registers* WCL = reinterpret_cast<Registers*>(WCL_BASE);

    // Bit definitions
    /// Core_0_ENTRY_1_ADDR Register bits
    namespace core_0_entry_1_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_1_ADDR = (32 << 0);  ///< Core_0 Entry 1 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_2_ADDR Register bits
    namespace core_0_entry_2_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_2_ADDR = (32 << 0);  ///< Core_0 Entry 2 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_3_ADDR Register bits
    namespace core_0_entry_3_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_3_ADDR = (32 << 0);  ///< Core_0 Entry 3 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_4_ADDR Register bits
    namespace core_0_entry_4_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_4_ADDR = (32 << 0);  ///< Core_0 Entry 4 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_5_ADDR Register bits
    namespace core_0_entry_5_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_5_ADDR = (32 << 0);  ///< Core_0 Entry 5 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_6_ADDR Register bits
    namespace core_0_entry_6_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_6_ADDR = (32 << 0);  ///< Core_0 Entry 6 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_7_ADDR Register bits
    namespace core_0_entry_7_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_7_ADDR = (32 << 0);  ///< Core_0 Entry 7 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_8_ADDR Register bits
    namespace core_0_entry_8_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_8_ADDR = (32 << 0);  ///< Core_0 Entry 8 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_9_ADDR Register bits
    namespace core_0_entry_9_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_9_ADDR = (32 << 0);  ///< Core_0 Entry 9 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_10_ADDR Register bits
    namespace core_0_entry_10_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_10_ADDR = (32 << 0);  ///< Core_0 Entry 10 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_11_ADDR Register bits
    namespace core_0_entry_11_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_11_ADDR = (32 << 0);  ///< Core_0 Entry 11 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_12_ADDR Register bits
    namespace core_0_entry_12_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_12_ADDR = (32 << 0);  ///< Core_0 Entry 12 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_13_ADDR Register bits
    namespace core_0_entry_13_addr_bits {
        constexpr uint32_t CORE_0_ENTRY_13_ADDR = (32 << 0);  ///< Core_0 Entry 13 address from WORLD1 to WORLD0
    }

    /// Core_0_ENTRY_CHECK Register bits
    namespace core_0_entry_check_bits {
        constexpr uint32_t CORE_0_ENTRY_CHECK = (13 << 1);  ///< This filed is used to enable entry address check
    }

    /// Core_0_STATUSTABLE1 Register bits
    namespace core_0_statustable1_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_1 = (1U << 0);  ///< This bit is used to confirm world before enter entry 1
        constexpr uint32_t CORE_0_FROM_ENTRY_1 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 1
        constexpr uint32_t CORE_0_CURRENT_1 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 1
    }

    /// Core_0_STATUSTABLE2 Register bits
    namespace core_0_statustable2_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_2 = (1U << 0);  ///< This bit is used to confirm world before enter entry 2
        constexpr uint32_t CORE_0_FROM_ENTRY_2 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 2
        constexpr uint32_t CORE_0_CURRENT_2 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 2
    }

    /// Core_0_STATUSTABLE3 Register bits
    namespace core_0_statustable3_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_3 = (1U << 0);  ///< This bit is used to confirm world before enter entry 3
        constexpr uint32_t CORE_0_FROM_ENTRY_3 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 3
        constexpr uint32_t CORE_0_CURRENT_3 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 3
    }

    /// Core_0_STATUSTABLE4 Register bits
    namespace core_0_statustable4_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_4 = (1U << 0);  ///< This bit is used to confirm world before enter entry 4
        constexpr uint32_t CORE_0_FROM_ENTRY_4 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 4
        constexpr uint32_t CORE_0_CURRENT_4 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 4
    }

    /// Core_0_STATUSTABLE5 Register bits
    namespace core_0_statustable5_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_5 = (1U << 0);  ///< This bit is used to confirm world before enter entry 5
        constexpr uint32_t CORE_0_FROM_ENTRY_5 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 5
        constexpr uint32_t CORE_0_CURRENT_5 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 5
    }

    /// Core_0_STATUSTABLE6 Register bits
    namespace core_0_statustable6_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_6 = (1U << 0);  ///< This bit is used to confirm world before enter entry 6
        constexpr uint32_t CORE_0_FROM_ENTRY_6 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 6
        constexpr uint32_t CORE_0_CURRENT_6 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 6
    }

    /// Core_0_STATUSTABLE7 Register bits
    namespace core_0_statustable7_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_7 = (1U << 0);  ///< This bit is used to confirm world before enter entry 7
        constexpr uint32_t CORE_0_FROM_ENTRY_7 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 7
        constexpr uint32_t CORE_0_CURRENT_7 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 7
    }

    /// Core_0_STATUSTABLE8 Register bits
    namespace core_0_statustable8_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_8 = (1U << 0);  ///< This bit is used to confirm world before enter entry 8
        constexpr uint32_t CORE_0_FROM_ENTRY_8 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 8
        constexpr uint32_t CORE_0_CURRENT_8 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 8
    }

    /// Core_0_STATUSTABLE9 Register bits
    namespace core_0_statustable9_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_9 = (1U << 0);  ///< This bit is used to confirm world before enter entry 9
        constexpr uint32_t CORE_0_FROM_ENTRY_9 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 9
        constexpr uint32_t CORE_0_CURRENT_9 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 9
    }

    /// Core_0_STATUSTABLE10 Register bits
    namespace core_0_statustable10_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_10 = (1U << 0);  ///< This bit is used to confirm world before enter entry 10
        constexpr uint32_t CORE_0_FROM_ENTRY_10 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 10
        constexpr uint32_t CORE_0_CURRENT_10 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 10
    }

    /// Core_0_STATUSTABLE11 Register bits
    namespace core_0_statustable11_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_11 = (1U << 0);  ///< This bit is used to confirm world before enter entry 11
        constexpr uint32_t CORE_0_FROM_ENTRY_11 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 11
        constexpr uint32_t CORE_0_CURRENT_11 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 11
    }

    /// Core_0_STATUSTABLE12 Register bits
    namespace core_0_statustable12_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_12 = (1U << 0);  ///< This bit is used to confirm world before enter entry 12
        constexpr uint32_t CORE_0_FROM_ENTRY_12 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 12
        constexpr uint32_t CORE_0_CURRENT_12 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 12
    }

    /// Core_0_STATUSTABLE13 Register bits
    namespace core_0_statustable13_bits {
        constexpr uint32_t CORE_0_FROM_WORLD_13 = (1U << 0);  ///< This bit is used to confirm world before enter entry 13
        constexpr uint32_t CORE_0_FROM_ENTRY_13 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 13
        constexpr uint32_t CORE_0_CURRENT_13 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 13
    }

    /// Core_0_STATUSTABLE_CURRENT Register bits
    namespace core_0_statustable_current_bits {
        constexpr uint32_t CORE_0_STATUSTABLE_CURRENT = (13 << 1);  ///< This field is used to quickly read and rewrite the current field of all STATUSTABLE registers,for example,bit 1 represents the current field of STATUSTABLE1,bit2 represents the current field of STATUSTABLE2
    }

    /// Core_0_MESSAGE_ADDR Register bits
    namespace core_0_message_addr_bits {
        constexpr uint32_t CORE_0_MESSAGE_ADDR = (32 << 0);  ///< This field is used to set address that need to write when enter WORLD0
    }

    /// Core_0_MESSAGE_MAX Register bits
    namespace core_0_message_max_bits {
        constexpr uint32_t CORE_0_MESSAGE_MAX = (4 << 0);  ///< This filed is used to set the max value of clear write_buffer
    }

    /// Core_0_MESSAGE_PHASE Register bits
    namespace core_0_message_phase_bits {
        constexpr uint32_t CORE_0_MESSAGE_MATCH = (1U << 0);  ///< This bit indicates whether the check is successful
        constexpr uint32_t CORE_0_MESSAGE_EXPECT = (4 << 1);  ///< This field indicates the data to be written next time
        constexpr uint32_t CORE_0_MESSAGE_DATAPHASE = (1U << 5);  ///< If this bit is 1, it means that is checking clear write_buffer operation,and is checking data
        constexpr uint32_t CORE_0_MESSAGE_ADDRESSPHASE = (1U << 6);  ///< If this bit is 1, it means that is checking clear write_buffer operation,and is checking address.
    }

    /// Core_0_World_TRIGGER_ADDR Register bits
    namespace core_0_world_trigger_addr_bits {
        constexpr uint32_t CORE_0_WORLD_TRIGGER_ADDR = (32 << 0);  ///< This field is used to configure the entry address from WORLD0 to WORLD1,when the CPU executes to this address,switch to WORLD1
    }

    /// Core_0_World_PREPARE Register bits
    namespace core_0_world_prepare_bits {
        constexpr uint32_t CORE_0_WORLD_PREPARE = (2 << 0);  ///< This field to used to set world to enter, 2'b01 means WORLD0, 2'b10 means WORLD1
    }

    /// Core_0_World_UPDATE Register bits
    namespace core_0_world_update_bits {
        constexpr uint32_t CORE_0_UPDATE = (32 << 0);  ///< This field is used to update configuration completed, can write any value,the hardware only checks the write operation of this register and does not case about its value
    }

    /// Core_0_World_Cancel Register bits
    namespace core_0_world_cancel_bits {
        constexpr uint32_t CORE_0_WORLD_CANCEL = (32 << 0);  ///< This field is used to cancel switch world configuration,if the trigger address and update configuration complete,use this register to cancel world switch, jujst need write any value,the hardware only checks the write operation of this register and does not case about its value
    }

    /// Core_0_World_IRam0 Register bits
    namespace core_0_world_iram0_bits {
        constexpr uint32_t CORE_0_WORLD_IRAM0 = (2 << 0);  ///< this field is used to read current world of Iram0 bus
    }

    /// Core_0_World_DRam0_PIF Register bits
    namespace core_0_world_dram0_pif_bits {
        constexpr uint32_t CORE_0_WORLD_DRAM0_PIF = (2 << 0);  ///< this field is used to read current world of Dram0 bus and PIF bus
    }

    /// Core_0_World_Phase Register bits
    namespace core_0_world_phase_bits {
        constexpr uint32_t CORE_0_WORLD_PHASE = (1U << 0);  ///< This bit indicates whether is preparing to switch to WORLD1, 1 means value.
    }

    /// Core_0_NMI_MASK_ENABLE Register bits
    namespace core_0_nmi_mask_enable_bits {
        constexpr uint32_t CORE_0_NMI_MASK_ENABLE = (32 << 0);  ///< this field is used to set NMI mask,it can write any value,when write this register,the hardware start masking NMI interrupt
    }

    /// Core_0_NMI_MASK_TRIGGER_ADDR Register bits
    namespace core_0_nmi_mask_trigger_addr_bits {
        constexpr uint32_t CORE_0_NMI_MASK_TRIGGER_ADDR = (32 << 0);  ///< this field to used to set trigger address, when CPU executes to this address,NMI mask automatically fails
    }

    /// Core_0_NMI_MASK_DISABLE Register bits
    namespace core_0_nmi_mask_disable_bits {
        constexpr uint32_t CORE_0_NMI_MASK_DISABLE = (32 << 0);  ///< this field is used to disable NMI mask,it will not take effect immediately,only when the CPU executes to the trigger address will it start to cancel NMI mask
    }

    /// Core_0_NMI_MASK_CANCLE Register bits
    namespace core_0_nmi_mask_cancle_bits {
        constexpr uint32_t CORE_0_NMI_MASK_CANCEL = (32 << 0);  ///< this field is used to cancel NMI mask disable function.
    }

    /// Core_0_NMI_MASK Register bits
    namespace core_0_nmi_mask_bits {
        constexpr uint32_t CORE_0_NMI_MASK = (1U << 0);  ///< this bit is used to mask NMI interrupt,it can directly mask NMI interrupt
    }

    /// Core_0_NMI_MASK_PHASE Register bits
    namespace core_0_nmi_mask_phase_bits {
        constexpr uint32_t CORE_0_NMI_MASK_PHASE = (1U << 0);  ///< this bit is used to indicates whether the NMI interrupt is being masked, 1 means NMI interrupt is being masked
    }

    /// Core_1_ENTRY_1_ADDR Register bits
    namespace core_1_entry_1_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_1_ADDR = (32 << 0);  ///< Core_1 Entry 1 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_2_ADDR Register bits
    namespace core_1_entry_2_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_2_ADDR = (32 << 0);  ///< Core_1 Entry 2 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_3_ADDR Register bits
    namespace core_1_entry_3_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_3_ADDR = (32 << 0);  ///< Core_1 Entry 3 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_4_ADDR Register bits
    namespace core_1_entry_4_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_4_ADDR = (32 << 0);  ///< Core_1 Entry 4 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_5_ADDR Register bits
    namespace core_1_entry_5_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_5_ADDR = (32 << 0);  ///< Core_1 Entry 5 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_6_ADDR Register bits
    namespace core_1_entry_6_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_6_ADDR = (32 << 0);  ///< Core_1 Entry 6 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_7_ADDR Register bits
    namespace core_1_entry_7_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_7_ADDR = (32 << 0);  ///< Core_1 Entry 7 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_8_ADDR Register bits
    namespace core_1_entry_8_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_8_ADDR = (32 << 0);  ///< Core_1 Entry 8 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_9_ADDR Register bits
    namespace core_1_entry_9_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_9_ADDR = (32 << 0);  ///< Core_1 Entry 9 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_10_ADDR Register bits
    namespace core_1_entry_10_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_10_ADDR = (32 << 0);  ///< Core_1 Entry 10 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_11_ADDR Register bits
    namespace core_1_entry_11_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_11_ADDR = (32 << 0);  ///< Core_1 Entry 11 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_12_ADDR Register bits
    namespace core_1_entry_12_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_12_ADDR = (32 << 0);  ///< Core_1 Entry 12 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_13_ADDR Register bits
    namespace core_1_entry_13_addr_bits {
        constexpr uint32_t CORE_1_ENTRY_13_ADDR = (32 << 0);  ///< Core_1 Entry 13 address from WORLD1 to WORLD0
    }

    /// Core_1_ENTRY_CHECK Register bits
    namespace core_1_entry_check_bits {
        constexpr uint32_t CORE_1_ENTRY_CHECK = (13 << 1);  ///< This filed is used to enable entry address check
    }

    /// Core_1_STATUSTABLE1 Register bits
    namespace core_1_statustable1_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_1 = (1U << 0);  ///< This bit is used to confirm world before enter entry 1
        constexpr uint32_t CORE_1_FROM_ENTRY_1 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 1
        constexpr uint32_t CORE_1_CURRENT_1 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 1
    }

    /// Core_1_STATUSTABLE2 Register bits
    namespace core_1_statustable2_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_2 = (1U << 0);  ///< This bit is used to confirm world before enter entry 2
        constexpr uint32_t CORE_1_FROM_ENTRY_2 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 2
        constexpr uint32_t CORE_1_CURRENT_2 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 2
    }

    /// Core_1_STATUSTABLE3 Register bits
    namespace core_1_statustable3_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_3 = (1U << 0);  ///< This bit is used to confirm world before enter entry 3
        constexpr uint32_t CORE_1_FROM_ENTRY_3 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 3
        constexpr uint32_t CORE_1_CURRENT_3 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 3
    }

    /// Core_1_STATUSTABLE4 Register bits
    namespace core_1_statustable4_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_4 = (1U << 0);  ///< This bit is used to confirm world before enter entry 4
        constexpr uint32_t CORE_1_FROM_ENTRY_4 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 4
        constexpr uint32_t CORE_1_CURRENT_4 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 4
    }

    /// Core_1_STATUSTABLE5 Register bits
    namespace core_1_statustable5_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_5 = (1U << 0);  ///< This bit is used to confirm world before enter entry 5
        constexpr uint32_t CORE_1_FROM_ENTRY_5 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 5
        constexpr uint32_t CORE_1_CURRENT_5 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 5
    }

    /// Core_1_STATUSTABLE6 Register bits
    namespace core_1_statustable6_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_6 = (1U << 0);  ///< This bit is used to confirm world before enter entry 6
        constexpr uint32_t CORE_1_FROM_ENTRY_6 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 6
        constexpr uint32_t CORE_1_CURRENT_6 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 6
    }

    /// Core_1_STATUSTABLE7 Register bits
    namespace core_1_statustable7_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_7 = (1U << 0);  ///< This bit is used to confirm world before enter entry 7
        constexpr uint32_t CORE_1_FROM_ENTRY_7 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 7
        constexpr uint32_t CORE_1_CURRENT_7 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 7
    }

    /// Core_1_STATUSTABLE8 Register bits
    namespace core_1_statustable8_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_8 = (1U << 0);  ///< This bit is used to confirm world before enter entry 8
        constexpr uint32_t CORE_1_FROM_ENTRY_8 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 8
        constexpr uint32_t CORE_1_CURRENT_8 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 8
    }

    /// Core_1_STATUSTABLE9 Register bits
    namespace core_1_statustable9_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_9 = (1U << 0);  ///< This bit is used to confirm world before enter entry 9
        constexpr uint32_t CORE_1_FROM_ENTRY_9 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 9
        constexpr uint32_t CORE_1_CURRENT_9 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 9
    }

    /// Core_1_STATUSTABLE10 Register bits
    namespace core_1_statustable10_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_10 = (1U << 0);  ///< This bit is used to confirm world before enter entry 10
        constexpr uint32_t CORE_1_FROM_ENTRY_10 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 10
        constexpr uint32_t CORE_1_CURRENT_10 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 10
    }

    /// Core_1_STATUSTABLE11 Register bits
    namespace core_1_statustable11_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_11 = (1U << 0);  ///< This bit is used to confirm world before enter entry 11
        constexpr uint32_t CORE_1_FROM_ENTRY_11 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 11
        constexpr uint32_t CORE_1_CURRENT_11 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 11
    }

    /// Core_1_STATUSTABLE12 Register bits
    namespace core_1_statustable12_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_12 = (1U << 0);  ///< This bit is used to confirm world before enter entry 12
        constexpr uint32_t CORE_1_FROM_ENTRY_12 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 12
        constexpr uint32_t CORE_1_CURRENT_12 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 12
    }

    /// Core_1_STATUSTABLE13 Register bits
    namespace core_1_statustable13_bits {
        constexpr uint32_t CORE_1_FROM_WORLD_13 = (1U << 0);  ///< This bit is used to confirm world before enter entry 13
        constexpr uint32_t CORE_1_FROM_ENTRY_13 = (4 << 1);  ///< This filed is used to confirm in which entry before enter entry 13
        constexpr uint32_t CORE_1_CURRENT_13 = (1U << 5);  ///< This bit is used to confirm whether the current state is in entry 13
    }

    /// Core_1_STATUSTABLE_CURRENT Register bits
    namespace core_1_statustable_current_bits {
        constexpr uint32_t CORE_1_STATUSTABLE_CURRENT = (13 << 1);  ///< This field is used to quickly read and rewrite the current field of all STATUSTABLE registers,for example,bit 1 represents the current field of STATUSTABLE1
    }

    /// Core_1_MESSAGE_ADDR Register bits
    namespace core_1_message_addr_bits {
        constexpr uint32_t CORE_1_MESSAGE_ADDR = (32 << 0);  ///< This field is used to set address that need to write when enter WORLD0
    }

    /// Core_1_MESSAGE_MAX Register bits
    namespace core_1_message_max_bits {
        constexpr uint32_t CORE_1_MESSAGE_MAX = (4 << 0);  ///< This filed is used to set the max value of clear write_buffer
    }

    /// Core_1_MESSAGE_PHASE Register bits
    namespace core_1_message_phase_bits {
        constexpr uint32_t CORE_1_MESSAGE_MATCH = (1U << 0);  ///< This bit indicates whether the check is successful
        constexpr uint32_t CORE_1_MESSAGE_EXPECT = (4 << 1);  ///< This field indicates the data to be written next time
        constexpr uint32_t CORE_1_MESSAGE_DATAPHASE = (1U << 5);  ///< If this bit is 1, it means that is checking clear write_buffer operation, and is checking data
        constexpr uint32_t CORE_1_MESSAGE_ADDRESSPHASE = (1U << 6);  ///< If this bit is 1, it means that is checking clear write_buffer operation, and is checking address.
    }

    /// Core_1_World_TRIGGER_ADDR Register bits
    namespace core_1_world_trigger_addr_bits {
        constexpr uint32_t CORE_1_WORLD_TRIGGER_ADDR = (32 << 0);  ///< This field is used to configure the entry address from WORLD0 to WORLD1,when the CPU executes to this address,switch to WORLD1
    }

    /// Core_1_World_PREPARE Register bits
    namespace core_1_world_prepare_bits {
        constexpr uint32_t CORE_1_WORLD_PREPARE = (2 << 0);  ///< This field to used to set world to enter,2'b01 means WORLD0, 2'b10 means WORLD1
    }

    /// Core_1_World_UPDATE Register bits
    namespace core_1_world_update_bits {
        constexpr uint32_t CORE_1_UPDATE = (32 << 0);  ///< This field is used to update configuration completed, can write any value,the hardware only checks the write operation of this register and does not case about its value
    }

    /// Core_1_World_Cancel Register bits
    namespace core_1_world_cancel_bits {
        constexpr uint32_t CORE_1_WORLD_CANCEL = (32 << 0);  ///< This field is used to cancel switch world configuration,if the trigger address and update configuration complete,can use this register to cancel world switch. can write any value, the hardware only checks the write operation of this register and does not case about its value
    }

    /// Core_1_World_IRam0 Register bits
    namespace core_1_world_iram0_bits {
        constexpr uint32_t CORE_1_WORLD_IRAM0 = (2 << 0);  ///< this field is used to read current world of Iram0 bus
    }

    /// Core_1_World_DRam0_PIF Register bits
    namespace core_1_world_dram0_pif_bits {
        constexpr uint32_t CORE_1_WORLD_DRAM0_PIF = (2 << 0);  ///< this field is used to read current world of Dram0 bus and PIF bus
    }

    /// Core_1_World_Phase Register bits
    namespace core_1_world_phase_bits {
        constexpr uint32_t CORE_1_WORLD_PHASE = (1U << 0);  ///< This bit indicates whether is preparing to switch to WORLD1,1 means value.
    }

    /// Core_1_NMI_MASK_ENABLE Register bits
    namespace core_1_nmi_mask_enable_bits {
        constexpr uint32_t CORE_1_NMI_MASK_ENABLE = (32 << 0);  ///< this field is used to set NMI mask, it can write any value, when write this register,the hardware start masking NMI interrupt
    }

    /// Core_1_NMI_MASK_TRIGGER_ADDR Register bits
    namespace core_1_nmi_mask_trigger_addr_bits {
        constexpr uint32_t CORE_1_NMI_MASK_TRIGGER_ADDR = (32 << 0);  ///< this field to used to set trigger address
    }

    /// Core_1_NMI_MASK_DISABLE Register bits
    namespace core_1_nmi_mask_disable_bits {
        constexpr uint32_t CORE_1_NMI_MASK_DISABLE = (32 << 0);  ///< this field is used to disable NMI mask, it will not take effect immediately,only when the CPU executes to the trigger address will it start to cancel NMI mask
    }

    /// Core_1_NMI_MASK_CANCLE Register bits
    namespace core_1_nmi_mask_cancle_bits {
        constexpr uint32_t CORE_1_NMI_MASK_CANCEL = (32 << 0);  ///< this field is used to cancel NMI mask disable function.
    }

    /// Core_1_NMI_MASK Register bits
    namespace core_1_nmi_mask_bits {
        constexpr uint32_t CORE_1_NMI_MASK = (1U << 0);  ///< this bit is used to mask NMI interrupt,it can directly mask NMI interrupt
    }

    /// Core_1_NMI_MASK_PHASE Register bits
    namespace core_1_nmi_mask_phase_bits {
        constexpr uint32_t CORE_1_NMI_MASK_PHASE = (1U << 0);  ///< this bit is used to indicates whether the NMI interrupt is being masked, 1 means NMI interrupt is being masked
    }

}


} // namespace alloy::generated::esp32-s3

#endif // ALLOY_GENERATED_ESP32-S3_PERIPHERALS_HPP