/// Auto-generated code for EXAMPLE_MCU
/// Generated by Alloy Code Generator
/// Source: example.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:27
#ifndef ALLOY_GENERATED_EXAMPLE_MCU_PERIPHERALS_HPP
#define ALLOY_GENERATED_EXAMPLE_MCU_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::example_mcu {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 128 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 128;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 3;
    constexpr uint32_t max_gpio_pins = 48;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_usart1 = true;
    constexpr bool has_usart2 = true;
}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x40010800;
    constexpr uint32_t GPIOB_BASE = 0x40010C00;
    constexpr uint32_t GPIOC_BASE = 0x40011000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t CRL;  ///< Offset: 0x00 - Port configuration register low
        volatile uint32_t CRH;  ///< Offset: 0x04 - Port configuration register high
        volatile uint32_t IDR;  ///< Offset: 0x08 - Port input data register
        volatile uint32_t ODR;  ///< Offset: 0x0C - Port output data register
        volatile uint32_t BSRR;  ///< Offset: 0x10 - Port bit set/reset register
        volatile uint32_t BRR;  ///< Offset: 0x14 - Port bit reset register
        volatile uint32_t LCKR;  ///< Offset: 0x18 - Port configuration lock register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t USART2_BASE = 0x40004400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SR;  ///< Offset: 0x00 - Status register
        volatile uint32_t DR;  ///< Offset: 0x04 - Data register
        volatile uint32_t BRR;  ///< Offset: 0x08 - Baud rate register
        volatile uint32_t CR1;  ///< Offset: 0x0C - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x10 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x14 - Control register 3
    };

    /// Peripheral instances
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);

}


} // namespace alloy::generated::example_mcu

#endif // ALLOY_GENERATED_EXAMPLE_MCU_PERIPHERALS_HPP