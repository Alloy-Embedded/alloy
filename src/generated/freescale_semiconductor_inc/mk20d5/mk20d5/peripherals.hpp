/// Auto-generated code for MK20D5
/// Generated by Alloy Code Generator
/// Source: nxp_mk20.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:38
#ifndef ALLOY_GENERATED_MK20D5_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK20D5_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mk20d5 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfl = true;
    constexpr uint32_t num_ftfl_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 1;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc0 = true;
    constexpr uint32_t num_osc0_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_pta = true;
    constexpr uint32_t num_pta_instances = 1;
    constexpr bool has_ptb = true;
    constexpr uint32_t num_ptb_instances = 1;
    constexpr bool has_ptc = true;
    constexpr uint32_t num_ptc_instances = 1;
    constexpr bool has_ptd = true;
    constexpr uint32_t num_ptd_instances = 1;
    constexpr bool has_pte = true;
    constexpr uint32_t num_pte_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pta_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pte_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFL_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL_FlashConfig = reinterpret_cast<Registers*>(FTFL_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t EZPORT_DIS = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t DCHPRI%s;  ///< Offset: 0x100 - Channel n Priority Register
        volatile uint32_t TCD%s_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD%s_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD%s_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD%s_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled)
        volatile uint32_t TCD%s_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and...
        volatile uint32_t TCD%s_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
        volatile uint32_t TCD%s_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD%s_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD%s_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD%s_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD%s_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD%s_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Cancelled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Cancelled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set enable request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
    }

    /// DCHPRI%s Register bits
    namespace dchpri%s_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// TCD%s_SADDR Register bits
    namespace tcd%s_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD%s_SOFF Register bits
    namespace tcd%s_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD%s_ATTR Register bits
    namespace tcd%s_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo.
    }

    /// TCD%s_NBYTES_MLNO Register bits
    namespace tcd%s_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD%s_NBYTES_MLOFFNO Register bits
    namespace tcd%s_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_NBYTES_MLOFFYES Register bits
    namespace tcd%s_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_SLAST Register bits
    namespace tcd%s_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last source Address Adjustment
    }

    /// TCD%s_DADDR Register bits
    namespace tcd%s_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD%s_DOFF Register bits
    namespace tcd%s_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed offset
    }

    /// TCD%s_CITER_ELINKNO Register bits
    namespace tcd%s_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_CITER_ELINKYES Register bits
    namespace tcd%s_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_DLASTSGA Register bits
    namespace tcd%s_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< no description available
    }

    /// TCD%s_CSR Register bits
    namespace tcd%s_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD%s_BITER_ELINKNO Register bits
    namespace tcd%s_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD%s_BITER_ELINKYES Register bits
    namespace tcd%s_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Control Register
        volatile uint32_t TAGVDW0S%s;  ///< Offset: 0x100 - Cache Tag Storage
        volatile uint32_t TAGVDW1S%s;  ///< Offset: 0x120 - Cache Tag Storage
        volatile uint32_t TAGVDW2S%s;  ///< Offset: 0x140 - Cache Tag Storage
        volatile uint32_t TAGVDW3S%s;  ///< Offset: 0x160 - Cache Tag Storage
        volatile uint32_t DATAW0S%s;  ///< Offset: 0x204 - Cache Data Storage
        volatile uint32_t DATAW1S%s;  ///< Offset: 0x244 - Cache Data Storage
        volatile uint32_t DATAW2S%s;  ///< Offset: 0x284 - Cache Data Storage
        volatile uint32_t DATAW3S%s;  ///< Offset: 0x2C4 - Cache Data Storage
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t B0MW = (2 << 17);  ///< Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Read Wait State Control
    }

    /// TAGVDW0S%s Register bits
    namespace tagvdw0s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW1S%s Register bits
    namespace tagvdw1s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW2S%s Register bits
    namespace tagvdw2s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW3S%s Register bits
    namespace tagvdw3s%s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// DATAW0S%s Register bits
    namespace dataw0s%s_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1S%s Register bits
    namespace dataw1s%s_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2S%s Register bits
    namespace dataw2s%s_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3S%s Register bits
    namespace dataw3s%s_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// FTFL Peripheral
// ============================================================================

namespace ftfl {
    /// Base addresses
    constexpr uint32_t FTFL_BASE = 0x40020000;

    /// FTFL Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB%s;  ///< Offset: 0x04 - Flash Common Command Object Registers
        volatile uint32_t FPROT%s;  ///< Offset: 0x10 - Program Flash Protection Registers
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL = reinterpret_cast<Registers*>(FTFL_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFL Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFL configuration
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB%s Register bits
    namespace fccob%s_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< no description available
    }

    /// FPROT%s Register bits
    namespace fprot%s_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - DSPI Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - DSPI Transfer Count Register
        volatile uint32_t CTAR%s;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Master Mode)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - DSPI Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DSPI DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - DSPI POP RX FIFO Register
        volatile uint32_t TXFR%s;  ///< Offset: 0x3C - DSPI Transmit FIFO Registers
        volatile uint32_t RXFR%s;  ///< Offset: 0x7C - DSPI Receive FIFO Registers
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< Flushes the RX FIFO
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Timing Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< DSPI Configuration
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR%s Register bits
    namespace ctar%s_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LBS First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (5 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select.
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< DSPI Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter.
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select.
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR%s Register bits
    namespace txfr%s_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR%s Register bits
    namespace rxfr%s_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR%s;  ///< Offset: 0x20 - SAI Transmit Data Register
        volatile uint32_t TFR%s;  ///< Offset: 0x40 - SAI Transmit FIFO Register
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR%s;  ///< Offset: 0xA0 - SAI Receive Data Register
        volatile uint32_t RFR%s;  ///< Offset: 0xC0 - SAI Receive FIFO Register
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
        volatile uint32_t MDR;  ///< Offset: 0x104 - MCLK Divide Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO request DMA enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO warning DMA enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO request interrupt enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO warning interrupt enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO error interrupt enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync error interrupt enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word start interrupt enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO request flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO warning flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO error flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync error flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word start flag
        constexpr uint32_t SR = (1U << 24);  ///< Software reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (3 << 0);  ///< Transmit FIFO watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit clock divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit clock direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit clock polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word flag configuration
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit channel enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame sync direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame sync polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame sync early
        constexpr uint32_t MF = (1U << 4);  ///< MSB first
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First bit shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N width
    }

    /// TDR%s Register bits
    namespace tdr%s_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit data register
    }

    /// TFR%s Register bits
    namespace tfr%s_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit word mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO request DMA enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO warning DMA enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO request interrupt enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO warning interrupt enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO error interrupt enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync error interrupt enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word start interrupt enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO request flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO warning flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO error flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync error flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word start flag
        constexpr uint32_t SR = (1U << 24);  ///< Software reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (3 << 0);  ///< Receive FIFO watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit clock divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit clock direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit clock polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word flag configuration
        constexpr uint32_t RCE = (2 << 16);  ///< Receive channel enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame sync direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame sync polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame sync early
        constexpr uint32_t MF = (1U << 4);  ///< MSB first
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First bit shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N width
    }

    /// RDR%s Register bits
    namespace rdr%s_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive data register
    }

    /// RFR%s Register bits
    namespace rfr%s_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive word mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

    /// MDR Register bits
    namespace mdr_bits {
        constexpr uint32_t DIVIDE = (12 << 0);  ///< MCLK Divide
        constexpr uint32_t FRACT = (8 << 12);  ///< MCLK Fraction
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC;  ///< Offset: 0x00 - CRC Data Register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial Register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control Register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCH stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low polynominal half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High polynominal half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC data register as seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read of CRC data register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type of Transpose for Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type of Transpose for Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBDCD_BASE = 0x40035000;
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t CLOCK;  ///< Offset: 0x04 - Clock Register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status Register
        volatile uint32_t TIMER0;  ///< Offset: 0x10 - TIMER0 Register
        volatile uint32_t TIMER1;  ///< Offset: 0x14 - no description available
        volatile uint32_t TIMER2;  ///< Offset: 0x18 - no description available
    };

    /// Peripheral instances
    inline Registers* USBDCD = reinterpret_cast<Registers*>(USBDCD_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t IACK = (1U << 0);  ///< Interrupt Acknowledge
        constexpr uint32_t IF = (1U << 8);  ///< Interrupt Flag
        constexpr uint32_t IE = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t START = (1U << 24);  ///< Start Change Detection Sequence
        constexpr uint32_t SR = (1U << 25);  ///< Software Reset
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLOCK_UNIT = (1U << 0);  ///< Unit of measurement encoding for Clock Speed
        constexpr uint32_t CLOCK_SPEED = (10 << 2);  ///< Numerical Value of Clock Speed in Binary
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SEQ_RES = (2 << 16);  ///< Charger Detection Sequence Results
        constexpr uint32_t SEQ_STAT = (2 << 18);  ///< Charger Detection Sequence Status
        constexpr uint32_t ERR = (1U << 20);  ///< Error Flag
        constexpr uint32_t TO = (1U << 21);  ///< Timeout Flag
        constexpr uint32_t ACTIVE = (1U << 22);  ///< Active Status Indicator
    }

    /// TIMER0 Register bits
    namespace timer0_bits {
        constexpr uint32_t TUNITCON = (12 << 0);  ///< Unit Connection Timer Elapse (in ms)
        constexpr uint32_t TSEQ_INIT = (10 << 16);  ///< Sequence Initiation Time
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t TVDPSRC_ON = (10 << 0);  ///< Time Period Comparator Enabled
        constexpr uint32_t TDCD_DBNC = (10 << 16);  ///< Time Period to Debounce D+ Signal
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t CHECK_DM = (4 << 0);  ///< Time Before Check of D- Line
        constexpr uint32_t TVDPSRC_CON = (10 << 16);  ///< Time Period Before Enabling D+ Pullup
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PO%sDLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus.
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PO%sDLY Register bits
    namespace po%sdly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL%s;  ///< Offset: 0x100 - Timer Load Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x104 - Current Timer Value Register
        volatile uint32_t TCTRL%s;  ///< Offset: 0x108 - Timer Control Register
        volatile uint32_t TFLG%s;  ///< Offset: 0x10C - Timer Flag Register
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
    }

    /// LDVAL%s Register bits
    namespace ldval%s_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value Bits
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable Bit.
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable Bit.
    }

    /// TFLG%s Register bits
    namespace tflg%s_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag.
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status and Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value of the FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status and Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value of the FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1%s;  ///< Offset: 0x00 - ADC status and control registers 1
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC configuration register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - Configuration register 2
        volatile uint32_t R%s;  ///< Offset: 0x10 - ADC data result register
        volatile uint32_t CV%s;  ///< Offset: 0x18 - Compare value registers
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and control register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and control register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC offset correction register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC plus-side gain register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC minus-side gain register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC plus-side general calibration value register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC plus-side general calibration value register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC plus-side general calibration value register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC plus-side general calibration value register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC plus-side general calibration value register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC plus-side general calibration value register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC plus-side general calibration value register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC minus-side general calibration value register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC minus-side general calibration value register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC minus-side general calibration value register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC minus-side general calibration value register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC minus-side general calibration value register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC minus-side general calibration value register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC minus-side general calibration value register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1%s Register bits
    namespace sc1%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential mode enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion complete flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input clock select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample time configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock divide select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-power configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long sample time select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High speed configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous clock output enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux select
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV%s Register bits
    namespace cv%s_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare value
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage reference selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare function range enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare function greater than enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare function enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion trigger select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware average select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware average enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous conversion enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration failed flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset error correction value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-side gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-side gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF load configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF load configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF load configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF load configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG%s;  ///< Offset: 0x00 - VBAT register file register
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG%s Register bits
    namespace reg%s_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG%s;  ///< Offset: 0x00 - Register file register
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG%s Register bits
    namespace reg%s_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - General Control and Status Register
        volatile uint32_t SCANC;  ///< Offset: 0x04 - SCAN Control Register
        volatile uint32_t PEN;  ///< Offset: 0x08 - Pin Enable Register
        volatile uint32_t WUCNTR;  ///< Offset: 0x0C - Wake-Up Channel Counter Register
        volatile uint32_t CNTR%s;  ///< Offset: 0x100 - Counter Register
        volatile uint32_t THRESHOLD;  ///< Offset: 0x120 - Low Power Channel Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t STPE = (1U << 0);  ///< TSI STOP Enable while in Low Power Modes (STOP, VLPS, LLS and VLLS{3,2,1})
        constexpr uint32_t STM = (1U << 1);  ///< Scan Trigger Mode. This bit-field can only be changed if the TSI module is disabled (TSIEN bit = 0).
        constexpr uint32_t ESOR = (1U << 4);  ///< End-of-Scan or Out-of-Range Interrupt select
        constexpr uint32_t ERIE = (1U << 5);  ///< Error Interrupt Enable
        constexpr uint32_t TSIIE = (1U << 6);  ///< Touch Sensing Input Interrupt Module Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t SWTS = (1U << 8);  ///< Software Trigger Start
        constexpr uint32_t SCNIP = (1U << 9);  ///< Scan In Progress status
        constexpr uint32_t OVRF = (1U << 12);  ///< Overrun error Flag. This flag is set when a scan trigger occurs while a scan is still in progress. Write "1", when this flag is set, to clear it..
        constexpr uint32_t EXTERF = (1U << 13);  ///< External Electrode error occurred
        constexpr uint32_t OUTRGF = (1U << 14);  ///< Out of Range Flag.
        constexpr uint32_t EOSF = (1U << 15);  ///< End of Scan Flag.
        constexpr uint32_t PS = (3 << 16);  ///< Electrode Oscillator prescaler. .
        constexpr uint32_t NSCN = (5 << 19);  ///< Number of Consecutive Scans per Electrode electrode.
        constexpr uint32_t LPSCNITV = (4 << 24);  ///< TSI Low Power Mode Scan Interval.
        constexpr uint32_t LPCLKS = (1U << 28);  ///< Low Power Mode Clock Source Selection.
    }

    /// SCANC Register bits
    namespace scanc_bits {
        constexpr uint32_t AMPSC = (3 << 0);  ///< Active Mode Prescaler
        constexpr uint32_t AMCLKS = (2 << 3);  ///< Active Mode Clock Source
        constexpr uint32_t SMOD = (8 << 8);  ///< Scan Module
        constexpr uint32_t EXTCHRG = (4 << 16);  ///< External OSC Charge Current select
        constexpr uint32_t REFCHRG = (4 << 24);  ///< Ref OSC Charge Current select
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN0 = (1U << 0);  ///< Touch Sensing Input Pin Enable Register 0
        constexpr uint32_t PEN1 = (1U << 1);  ///< Touch Sensing Input Pin Enable Register 1
        constexpr uint32_t PEN2 = (1U << 2);  ///< Touch Sensing Input Pin Enable Register 2
        constexpr uint32_t PEN3 = (1U << 3);  ///< Touch Sensing Input Pin Enable Register 3
        constexpr uint32_t PEN4 = (1U << 4);  ///< Touch Sensing Input Pin Enable Register 4
        constexpr uint32_t PEN5 = (1U << 5);  ///< Touch Sensing Input Pin Enable Register 5
        constexpr uint32_t PEN6 = (1U << 6);  ///< Touch Sensing Input Pin Enable Register 6
        constexpr uint32_t PEN7 = (1U << 7);  ///< Touch Sensing Input Pin Enable Register 7
        constexpr uint32_t PEN8 = (1U << 8);  ///< Touch Sensing Input Pin Enable Register 8
        constexpr uint32_t PEN9 = (1U << 9);  ///< Touch Sensing Input Pin Enable Register 9
        constexpr uint32_t PEN10 = (1U << 10);  ///< Touch Sensing Input Pin Enable Register 10
        constexpr uint32_t PEN11 = (1U << 11);  ///< Touch Sensing Input Pin Enable Register 11
        constexpr uint32_t PEN12 = (1U << 12);  ///< Touch Sensing Input Pin Enable Register 12
        constexpr uint32_t PEN13 = (1U << 13);  ///< Touch Sensing Input Pin Enable Register 13
        constexpr uint32_t PEN14 = (1U << 14);  ///< Touch Sensing Input Pin Enable Register 14
        constexpr uint32_t PEN15 = (1U << 15);  ///< Touch Sensing Input Pin Enable Register 15
        constexpr uint32_t LPSP = (4 << 16);  ///< Low Power Scan Pin
    }

    /// WUCNTR Register bits
    namespace wucntr_bits {
        constexpr uint32_t WUCNT = (16 << 0);  ///< TouchSensing wake-up Channel 16bit counter value
    }

    /// CNTR%s Register bits
    namespace cntr%s_bits {
        constexpr uint32_t CTN1 = (16 << 0);  ///< TouchSensing Channel n-1 16-bit counter value
        constexpr uint32_t CTN = (16 << 16);  ///< TouchSensing Channel n 16-bit counter value
    }

    /// THRESHOLD Register bits
    namespace threshold_bits {
        constexpr uint32_t HTHH = (16 << 0);  ///< Touch Sensing Channel High Threshold value
        constexpr uint32_t LTHH = (16 << 16);  ///< Touch Sensing Channel Low Threshold value
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t PTD7PAD = (1U << 11);  ///< PTD7 pad drive strength
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (1U << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM0TRG0SRC = (1U << 28);  ///< FlexTimer 0 Hardware Trigger 0 Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (1U << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UART1TXSRC = (1U << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t USBOTG = (1U << 18);  ///< USB Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTIMER = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Clock Gate Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTFL = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t USBDCD = (1U << 21);  ///< USB DCD Clock Gate Control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFRAC = (1U << 0);  ///< USB clock divider fraction
        constexpr uint32_t USBDIV = (3 << 1);  ///< USB clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t DEPART = (4 << 8);  ///< FlexNVM partition
        constexpr uint32_t EESIZE = (4 << 16);  ///< EEPROM size
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t PFLSH = (1U << 23);  ///< Program flash
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR%s;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);

    // Bit definitions
    /// PCR%s Register bits
    namespace pcr%s_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh Register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock Register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count Register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler Register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enable windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write once registers, after initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Selects the test to be run on the watchdog timer. Effective only if TESTWDOG is set.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field select the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< You can write the unlock sequence values to this register to make the watchdog write once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< These bits control the upper mark periods of the modulator for all modes.
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< These bits control the lower mark periods of the modulator for all modes.
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< These bits control the upper space periods of the modulator for all modes.
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< These bits control the lower space periods of the modulator for all modes.
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV0 = (5 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN0 = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN0 = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV0 = (5 << 0);  ///< VCO 0 Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< no description available
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// OSC0 Peripheral
// ============================================================================

namespace osc0 {
    /// Base addresses
    constexpr uint32_t OSC0_BASE = 0x40065000;

    /// OSC0 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC0 = reinterpret_cast<Registers*>(OSC0_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status Register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< Clock rate
        constexpr uint32_t MULT = (2 << 6);  ///< The MULT bits define the multiplier factor mul
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit acknowledge enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit mode select
        constexpr uint32_t MST = (1U << 5);  ///< Master mode select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C interrupt enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave read/write
        constexpr uint32_t RAM = (1U << 3);  ///< Range address match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed as a slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer complete flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range address matching enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave baud rate control
        constexpr uint32_t HDRS = (1U << 5);  ///< High drive select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General call address enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (5 << 0);  ///< I2C programmable filter factor
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range slave address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 interrupt enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL high timeout flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL high timeout flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL low timeout flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout counter clock select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C address enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus alert response address enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Most significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Least significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers:High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816T0;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WP7816T1;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
        volatile uint32_t C6;  ///< Offset: 0x21 - UART CEA709.1-B Control Register 6
        volatile uint32_t PCTH;  ///< Offset: 0x22 - UART CEA709.1-B Packet Cycle Time Counter High
        volatile uint32_t PCTL;  ///< Offset: 0x23 - UART CEA709.1-B Packet Cycle Time Counter Low
        volatile uint32_t B1T;  ///< Offset: 0x24 - UART CEA709.1-B Beta1 Timer
        volatile uint32_t SDTH;  ///< Offset: 0x25 - UART CEA709.1-B Secondary Delay Timer High
        volatile uint32_t SDTL;  ///< Offset: 0x26 - UART CEA709.1-B Secondary Delay Timer Low
        volatile uint32_t PRE;  ///< Offset: 0x27 - UART CEA709.1-B Preamble
        volatile uint32_t TPL;  ///< Offset: 0x28 - UART CEA709.1-B Transmit Packet Length
        volatile uint32_t IE;  ///< Offset: 0x29 - UART CEA709.1-B Interrupt Enable Register
        volatile uint32_t WB;  ///< Offset: 0x2A - UART CEA709.1-B WBASE
        volatile uint32_t S3;  ///< Offset: 0x2B - UART CEA709.1-B Status Register
        volatile uint32_t S4;  ///< Offset: 0x2C - UART CEA709.1-B Status Register
        volatile uint32_t RPL;  ///< Offset: 0x2D - UART CEA709.1-B Received Packet Length
        volatile uint32_t RPREL;  ///< Offset: 0x2E - UART CEA709.1-B Received Preamble Length
        volatile uint32_t CPW;  ///< Offset: 0x2F - UART CEA709.1-B Collision Pulse Width
        volatile uint32_t RIDT;  ///< Offset: 0x30 - UART CEA709.1-B Receive Indeterminate Time
        volatile uint32_t TIDT;  ///< Offset: 0x31 - UART CEA709.1-B Transmit Indeterminate Time
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 3);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< The current received dataword contained in D and C3[R8] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 7);  ///< The current received dataword contained in D and C3[R8] was received with noise.
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816T0 Register bits
    namespace wp7816t0_bits {
        constexpr uint32_t WI = (8 << 0);  ///< Wait Timer Interrupt (C7816[TTYPE] = 0)
    }

    /// WP7816T1 Register bits
    namespace wp7816t1_bits {
        constexpr uint32_t BWI = (4 << 0);  ///< Block Wait Time Integer(C7816[TTYPE] = 1)
        constexpr uint32_t CWI = (4 << 4);  ///< Character Wait Time Integer (C7816[TTYPE] = 1)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t CP = (1U << 4);  ///< Collision Signal Polarity
        constexpr uint32_t CE = (1U << 5);  ///< Collision Enable
        constexpr uint32_t TX709 = (1U << 6);  ///< CEA709.1-B Transmit Enable
        constexpr uint32_t EN709 = (1U << 7);  ///< EN709
    }

    /// PCTH Register bits
    namespace pcth_bits {
        constexpr uint32_t PCTH = (8 << 0);  ///< Packet Cycle Time Counter High
    }

    /// PCTL Register bits
    namespace pctl_bits {
        constexpr uint32_t PCTL = (8 << 0);  ///< Packet Cycle Time Counter Low
    }

    /// B1T Register bits
    namespace b1t_bits {
        constexpr uint32_t B1T = (8 << 0);  ///< Beta1 Timer
    }

    /// SDTH Register bits
    namespace sdth_bits {
        constexpr uint32_t SDTH = (8 << 0);  ///< Secondary Delay Timer High
    }

    /// SDTL Register bits
    namespace sdtl_bits {
        constexpr uint32_t SDTL = (8 << 0);  ///< Secondary Delay Timer Low
    }

    /// PRE Register bits
    namespace pre_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< CEA709.1-B Preamble Register
    }

    /// TPL Register bits
    namespace tpl_bits {
        constexpr uint32_t TPL = (8 << 0);  ///< Transmit Packet Length Register
    }

    /// IE Register bits
    namespace ie_bits {
        constexpr uint32_t TXFIE = (1U << 0);  ///< Transmission Fail Interrupt Enable
        constexpr uint32_t PSIE = (1U << 1);  ///< Preamble Start Interrupt Enable
        constexpr uint32_t PCTEIE = (1U << 2);  ///< Packet Cycle Timer Interrupt Enable
        constexpr uint32_t PTXIE = (1U << 3);  ///< Packet Transmitted Interrupt Enable
        constexpr uint32_t PRXIE = (1U << 4);  ///< Packet Received Interrupt Enable
        constexpr uint32_t ISDIE = (1U << 5);  ///< Initial Sync Detection Interrupt Enable
        constexpr uint32_t WBEIE = (1U << 6);  ///< Wbase Expired Interrupt Enable
    }

    /// WB Register bits
    namespace wb_bits {
        constexpr uint32_t WBASE = (8 << 0);  ///< CEA709.1-B WBASE register
    }

    /// S3 Register bits
    namespace s3_bits {
        constexpr uint32_t TXFF = (1U << 0);  ///< Transmission Fail Flag
        constexpr uint32_t PSF = (1U << 1);  ///< Preamble Start Flag
        constexpr uint32_t PCTEF = (1U << 2);  ///< Packet Cycle Timer Expired Flag
        constexpr uint32_t PTXF = (1U << 3);  ///< Packet Transmitted Flag
        constexpr uint32_t PRXF = (1U << 4);  ///< Packet Received Flag
        constexpr uint32_t ISD = (1U << 5);  ///< Initial Sync Detect
        constexpr uint32_t WBEF = (1U << 6);  ///< Wbase Expired Flag
        constexpr uint32_t PEF = (1U << 7);  ///< Preamble Error Flag
    }

    /// S4 Register bits
    namespace s4_bits {
        constexpr uint32_t FE = (1U << 0);  ///< Framing Error
        constexpr uint32_t ILCV = (1U << 1);  ///< Improper Line Code Violation
        constexpr uint32_t CDET = (2 << 2);  ///< CDET
        constexpr uint32_t INITF = (1U << 4);  ///< Initial Synchronization Fail Flag
    }

    /// RPL Register bits
    namespace rpl_bits {
        constexpr uint32_t RPL = (8 << 0);  ///< Received packet length
    }

    /// RPREL Register bits
    namespace rprel_bits {
        constexpr uint32_t RPREL = (8 << 0);  ///< Received preamble length
    }

    /// CPW Register bits
    namespace cpw_bits {
        constexpr uint32_t CPW = (8 << 0);  ///< CEA709.1-B CPW register
    }

    /// RIDT Register bits
    namespace ridt_bits {
        constexpr uint32_t RIDT = (8 << 0);  ///< CEA709.1-B Receive IDT Register
    }

    /// TIDT Register bits
    namespace tidt_bits {
        constexpr uint32_t TIDT = (8 << 0);  ///< CEA709.1-B Transmit IDT Register
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 Register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 Register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 Register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 Register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable Register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 Register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 Register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 Register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 Register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 Register
        volatile uint32_t RST;  ///< Offset: 0x0A - LLWU Reset Enable Register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable for Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable for Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable for Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable for Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable for Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable for Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable for Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag for LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag for LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag for LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag for LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag for LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag for LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag for LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag for LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag for LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag for LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag for LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag for LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag for LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag for LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag for LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag for LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag for module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag for module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag for module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag for module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag for module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag for module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag for module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag for module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter pin select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter on External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter pin select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter on External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// RST Register bits
    namespace rst_bits {
        constexpr uint32_t RSTFILT = (1U << 0);  ///< Digital Filter on RESET Pin
        constexpr uint32_t LLRSTE = (1U << 1);  ///< Low Leakage mode RESET enable
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status and Control 1 Register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status and Control 2 Register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status and Control Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator in Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection Register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control Register
        volatile uint32_t VLLSCTRL;  ///< Offset: 0x02 - VLLS Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status Register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow very low leakage stop mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow low leakage stop mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow very low power modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
        constexpr uint32_t LPWUI = (1U << 7);  ///< Low Power Wake Up on Interrupt
    }

    /// VLLSCTRL Register bits
    namespace vllsctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control.
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (7 << 0);  ///< When debug is enabled, the PMSTAT will not update to STOP or VLPS
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control Register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width Register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low leakage wakeup reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-voltage detect reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-clock reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-lock reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External reset pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-on reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG generated reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP system reset request
        constexpr uint32_t EZPT = (1U << 4);  ///< EzPort Reset
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset pin filter select in run and wait modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset pin filter select in stop mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset pin filter bus clock select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t EZP_MS = (1U << 1);  ///< EZP_MS_B pin state
    }

}

// ============================================================================
// PTA Peripheral
// ============================================================================

namespace pta {
    /// Base addresses
    constexpr uint32_t PTA_BASE = 0x400FF000;

    /// PTA Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTA = reinterpret_cast<Registers*>(PTA_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTB Peripheral
// ============================================================================

namespace ptb {
    /// Base addresses
    constexpr uint32_t PTB_BASE = 0x400FF040;

    /// PTB Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTB = reinterpret_cast<Registers*>(PTB_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTC Peripheral
// ============================================================================

namespace ptc {
    /// Base addresses
    constexpr uint32_t PTC_BASE = 0x400FF080;

    /// PTC Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTC = reinterpret_cast<Registers*>(PTC_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTD Peripheral
// ============================================================================

namespace ptd {
    /// Base addresses
    constexpr uint32_t PTD_BASE = 0x400FF0C0;

    /// PTD Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTD = reinterpret_cast<Registers*>(PTD_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTE Peripheral
// ============================================================================

namespace pte {
    /// Base addresses
    constexpr uint32_t PTE_BASE = 0x400FF100;

    /// PTE Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTE = reinterpret_cast<Registers*>(PTE_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}


} // namespace alloy::generated::mk20d5

#endif // ALLOY_GENERATED_MK20D5_PERIPHERALS_HPP