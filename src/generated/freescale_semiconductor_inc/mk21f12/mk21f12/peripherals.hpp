/// Auto-generated code for MK21F12
/// Generated by Alloy Code Generator
/// Source: nxp_mk21.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:43:59
#ifndef ALLOY_GENERATED_MK21F12_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK21F12_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mk21f12 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfe = true;
    constexpr uint32_t num_ftfe_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_sdhc = true;
    constexpr uint32_t num_sdhc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_cau = true;
    constexpr uint32_t num_cau_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cau_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFE_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE_FlashConfig = reinterpret_cast<Registers*>(FTFE_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t EZPORT_DIS = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS;  ///< Offset: 0x00 - Priority Registers Slave (renamed from PRS)
        volatile uint32_t CRS;  ///< Offset: 0x10 - Control Register (renamed from CRS)
        volatile uint32_t MGPCR0;  ///< Offset: 0x800 - Master General Purpose Control Register
        volatile uint32_t MGPCR1;  ///< Offset: 0x900 - Master General Purpose Control Register
        volatile uint32_t MGPCR2;  ///< Offset: 0xA00 - Master General Purpose Control Register
        volatile uint32_t MGPCR4;  ///< Offset: 0xC00 - Master General Purpose Control Register
        volatile uint32_t MGPCR5;  ///< Offset: 0xD00 - Master General Purpose Control Register
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS Register bits
    namespace prs_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M4 = (3 << 16);  ///< Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M5 = (3 << 20);  ///< Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS Register bits
    namespace crs_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking Control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration Mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt Low Priority
        constexpr uint32_t RO = (1U << 31);  ///< Read Only
    }

    /// MGPCR0 Register bits
    namespace mgpcr0_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR1 Register bits
    namespace mgpcr1_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR2 Register bits
    namespace mgpcr2_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR4 Register bits
    namespace mgpcr4_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR5 Register bits
    namespace mgpcr5_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set enable request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop for channel 3.
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo.
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Chip Select Address Register (renamed from CSAR)
        volatile uint32_t CSMR;  ///< Offset: 0x04 - Chip Select Mask Register (renamed from CSMR)
        volatile uint32_t CSCR;  ///< Offset: 0x08 - Chip Select Control Register (renamed from CSCR)
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip Select port Multiplexing Control Register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t BA = (16 << 16);  ///< Base Address
    }

    /// CSMR Register bits
    namespace csmr_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t WP = (1U << 8);  ///< Write Protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base Address Mask
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-Write Enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-Read Enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-Enable Mode
        constexpr uint32_t PS = (2 << 6);  ///< Port Size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-Acknowledge Enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-Lane Shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait States
        constexpr uint32_t WRAH = (2 << 16);  ///< Write Address Hold or Deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read Address Hold or Deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address Setup
        constexpr uint32_t EXTS = (1U << 22);  ///< Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary Wait State Enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary Wait States
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus Signal Group 5 Multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus Signal Group 4 Multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus Signal Group 3 Multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus Signal Group 2 Multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus Signal Group 1 Multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, slave port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, slave port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
        volatile uint32_t PFB1CR;  ///< Offset: 0x08 - Flash Bank 1 Control Register
        volatile uint32_t TAGVDW0S;  ///< Offset: 0x100 - Cache Tag Storage (renamed from TAGVDW0S)
        volatile uint32_t TAGVDW1S;  ///< Offset: 0x110 - Cache Tag Storage (renamed from TAGVDW1S)
        volatile uint32_t TAGVDW2S;  ///< Offset: 0x120 - Cache Tag Storage (renamed from TAGVDW2S)
        volatile uint32_t TAGVDW3S;  ///< Offset: 0x130 - Cache Tag Storage (renamed from TAGVDW3S)
        volatile uint32_t DATAW0SUM;  ///< Offset: 0x200 - Cache Data Storage (uppermost word) (renamed from DATAW0SUM)
        volatile uint32_t DATAW0SMU;  ///< Offset: 0x204 - Cache Data Storage (mid-upper word) (renamed from DATAW0SMU)
        volatile uint32_t DATAW0SML;  ///< Offset: 0x208 - Cache Data Storage (mid-lower word) (renamed from DATAW0SML)
        volatile uint32_t DATAW0SLM;  ///< Offset: 0x20C - Cache Data Storage (lowermost word) (renamed from DATAW0SLM)
        volatile uint32_t DATAW1SUM;  ///< Offset: 0x240 - Cache Data Storage (uppermost word) (renamed from DATAW1SUM)
        volatile uint32_t DATAW1SMU;  ///< Offset: 0x244 - Cache Data Storage (mid-upper word) (renamed from DATAW1SMU)
        volatile uint32_t DATAW1SML;  ///< Offset: 0x248 - Cache Data Storage (mid-lower word) (renamed from DATAW1SML)
        volatile uint32_t DATAW1SLM;  ///< Offset: 0x24C - Cache Data Storage (lowermost word) (renamed from DATAW1SLM)
        volatile uint32_t DATAW2SUM;  ///< Offset: 0x280 - Cache Data Storage (uppermost word) (renamed from DATAW2SUM)
        volatile uint32_t DATAW2SMU;  ///< Offset: 0x284 - Cache Data Storage (mid-upper word) (renamed from DATAW2SMU)
        volatile uint32_t DATAW2SML;  ///< Offset: 0x288 - Cache Data Storage (mid-lower word) (renamed from DATAW2SML)
        volatile uint32_t DATAW2SLM;  ///< Offset: 0x28C - Cache Data Storage (lowermost word) (renamed from DATAW2SLM)
        volatile uint32_t DATAW3SUM;  ///< Offset: 0x2C0 - Cache Data Storage (uppermost word) (renamed from DATAW3SUM)
        volatile uint32_t DATAW3SMU;  ///< Offset: 0x2C4 - Cache Data Storage (mid-upper word) (renamed from DATAW3SMU)
        volatile uint32_t DATAW3SML;  ///< Offset: 0x2C8 - Cache Data Storage (mid-lower word) (renamed from DATAW3SML)
        volatile uint32_t DATAW3SLM;  ///< Offset: 0x2CC - Cache Data Storage (lowermost word) (renamed from DATAW3SLM)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M4AP = (2 << 8);  ///< Master 4 Access Protection
        constexpr uint32_t M5AP = (2 << 10);  ///< Master 5 Access Protection
        constexpr uint32_t M6AP = (2 << 12);  ///< Master 6 Access Protection
        constexpr uint32_t M7AP = (2 << 14);  ///< Master 7 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
        constexpr uint32_t M4PFD = (1U << 20);  ///< Master 4 Prefetch Disable
        constexpr uint32_t M5PFD = (1U << 21);  ///< Master 5 Prefetch Disable
        constexpr uint32_t M6PFD = (1U << 22);  ///< Master 6 Prefetch Disable
        constexpr uint32_t M7PFD = (1U << 23);  ///< Master 7 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Bank 0 Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Bank 0 Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Bank 0 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

    /// PFB1CR Register bits
    namespace pfb1cr_bits {
        constexpr uint32_t B1SEBE = (1U << 0);  ///< Bank 1 Single Entry Buffer Enable
        constexpr uint32_t B1IPE = (1U << 1);  ///< Bank 1 Instruction Prefetch Enable
        constexpr uint32_t B1DPE = (1U << 2);  ///< Bank 1 Data Prefetch Enable
        constexpr uint32_t B1ICE = (1U << 3);  ///< Bank 1 Instruction Cache Enable
        constexpr uint32_t B1DCE = (1U << 4);  ///< Bank 1 Data Cache Enable
        constexpr uint32_t B1MW = (2 << 17);  ///< Bank 1 Memory Width
        constexpr uint32_t B1RWSC = (4 << 28);  ///< Bank 1 Read Wait State Control
    }

    /// TAGVDW0S Register bits
    namespace tagvdw0s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW1S Register bits
    namespace tagvdw1s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW2S Register bits
    namespace tagvdw2s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW3S Register bits
    namespace tagvdw3s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// DATAW0SUM Register bits
    namespace dataw0sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW0SMU Register bits
    namespace dataw0smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW0SML Register bits
    namespace dataw0sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0SLM Register bits
    namespace dataw0slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1SUM Register bits
    namespace dataw1sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW1SMU Register bits
    namespace dataw1smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW1SML Register bits
    namespace dataw1sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1SLM Register bits
    namespace dataw1slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2SUM Register bits
    namespace dataw2sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW2SMU Register bits
    namespace dataw2smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW2SML Register bits
    namespace dataw2sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2SLM Register bits
    namespace dataw2slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3SUM Register bits
    namespace dataw3sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW3SMU Register bits
    namespace dataw3smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW3SML Register bits
    namespace dataw3sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3SLM Register bits
    namespace dataw3slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// FTFE Peripheral
// ============================================================================

namespace ftfe {
    /// Base addresses
    constexpr uint32_t FTFE_BASE = 0x40020000;

    /// FTFE Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB;  ///< Offset: 0x04 - Flash Common Command Object Registers (renamed from FCCOB)
        volatile uint32_t FPROT;  ///< Offset: 0x10 - Program Flash Protection Registers (renamed from FPROT)
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE = reinterpret_cast<Registers*>(FTFE_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFE Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFE configuration
        constexpr uint32_t SWAP = (1U << 3);  ///< Swap
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB Register bits
    namespace fccob_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< The FCCOB register provides a command code and relevant parameters to the memory controller
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t RXIMR;  ///< Offset: 0x880 - Rx Individual Mask Registers (renamed from RXIMR)
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number Of The Last Message Buffer
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking And Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t WAKSRC = (1U << 19);  ///< Wake Up Source
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low-Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer Value
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< Bus Off Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN In Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN In Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< This bit indicates when CAN bus is in IDLE state
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUFLM = (32 << 0);  ///< Buffer MB i Mask
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF0I = (1U << 0);  ///< Buffer MB0 Interrupt Or "reserved"
        constexpr uint32_t BUF4TO1I = (4 << 1);  ///< Buffer MB i Interrupt Or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt Or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt Or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number Of Rx FIFO Filters
        constexpr uint32_t WRMFRZ = (1U << 28);  ///< Write-Access To Memory In Freeze Mode
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< CRC Transmitted
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR Register bits
    namespace rximr_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x40029000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RNGA Control Register
        volatile uint32_t SR;  ///< Offset: 0x04 - RNGA Status Register
        volatile uint32_t ER;  ///< Offset: 0x08 - RNGA Entropy Register
        volatile uint32_t OR_;  ///< Offset: 0x0C - RNGA Output Register (renamed from OR_)
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t GO = (1U << 0);  ///< This bit must be set before the RNGA begins loading data into the RNGA Output Register
        constexpr uint32_t HA = (1U << 1);  ///< High Assurance
        constexpr uint32_t INTM = (1U << 2);  ///< Interrupt Mask
        constexpr uint32_t CLRI = (1U << 3);  ///< Clear Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SECV = (1U << 0);  ///< Security Violation
        constexpr uint32_t LRS = (1U << 1);  ///< Last Read Status
        constexpr uint32_t ORU = (1U << 2);  ///< Output Register Underflow
        constexpr uint32_t ERRI = (1U << 3);  ///< Error Interrupt
        constexpr uint32_t SLP = (1U << 4);  ///< Sleep
        constexpr uint32_t OREG_LVL = (8 << 8);  ///< Output Register Level
        constexpr uint32_t OREG_SIZE = (8 << 16);  ///< Output Register Size
    }

    /// ER Register bits
    namespace er_bits {
        constexpr uint32_t EXT_ENT = (32 << 0);  ///< External Entropy
    }

    /// OR_ Register bits
    namespace or__bits {
        constexpr uint32_t RANDOUT = (32 << 0);  ///< Random Output
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< Flushes the RX FIFO
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Timing Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (5 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register (renamed from TDR)
        volatile uint32_t TFR;  ///< Offset: 0x40 - SAI Transmit FIFO Register (renamed from TFR)
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register (renamed from RDR)
        volatile uint32_t RFR;  ///< Offset: 0xC0 - SAI Receive FIFO Register (renamed from RFR)
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
        volatile uint32_t MDR;  ///< Offset: 0x104 - SAI MCLK Divide Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (3 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit Channel Enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR Register bits
    namespace tfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (3 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (2 << 16);  ///< Receive Channel Enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame Size
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR Register bits
    namespace rfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive Word Mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

    /// MDR Register bits
    namespace mdr_bits {
        constexpr uint32_t DIVIDE = (12 << 0);  ///< MCLK Divide
        constexpr uint32_t FRACT = (8 << 12);  ///< MCLK Fraction
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBDCD_BASE = 0x40035000;
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLOCK;  ///< Offset: 0x04 - Clock register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t TIMER0;  ///< Offset: 0x10 - TIMER0 register
        volatile uint32_t TIMER1;  ///< Offset: 0x14 - TIMER1 register
        volatile uint32_t TIMER2_BC11;  ///< Offset: 0x18 - TIMER2_BC11 register
        volatile uint32_t TIMER2_BC12;  ///< Offset: 0x18 - TIMER2_BC12 register
    };

    /// Peripheral instances
    inline Registers* USBDCD = reinterpret_cast<Registers*>(USBDCD_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t IACK = (1U << 0);  ///< Interrupt Acknowledge
        constexpr uint32_t IF_ = (1U << 8);  ///< Interrupt Flag (renamed from IF_)
        constexpr uint32_t IE = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t BC12 = (1U << 17);  ///< BC1.2 compatibility. This bit cannot be changed after start detection.
        constexpr uint32_t START = (1U << 24);  ///< Start Change Detection Sequence
        constexpr uint32_t SR = (1U << 25);  ///< Software Reset
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLOCK_UNIT = (1U << 0);  ///< Unit of Measurement Encoding for Clock Speed
        constexpr uint32_t CLOCK_SPEED = (10 << 2);  ///< Numerical Value of Clock Speed in Binary
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SEQ_RES = (2 << 16);  ///< Charger Detection Sequence Results
        constexpr uint32_t SEQ_STAT = (2 << 18);  ///< Charger Detection Sequence Status
        constexpr uint32_t ERR = (1U << 20);  ///< Error Flag
        constexpr uint32_t TO = (1U << 21);  ///< Timeout Flag
        constexpr uint32_t ACTIVE = (1U << 22);  ///< Active Status Indicator
    }

    /// TIMER0 Register bits
    namespace timer0_bits {
        constexpr uint32_t TUNITCON = (12 << 0);  ///< Unit Connection Timer Elapse (in ms)
        constexpr uint32_t TSEQ_INIT = (10 << 16);  ///< Sequence Initiation Time
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t TVDPSRC_ON = (10 << 0);  ///< Time Period Comparator Enabled
        constexpr uint32_t TDCD_DBNC = (10 << 16);  ///< Time Period to Debounce D+ Signal
    }

    /// TIMER2_BC11 Register bits
    namespace timer2_bc11_bits {
        constexpr uint32_t CHECK_DM = (4 << 0);  ///< Time Before Check of D- Line
        constexpr uint32_t TVDPSRC_CON = (10 << 16);  ///< Time Period Before Enabling D+ Pullup
    }

    /// TIMER2_BC12 Register bits
    namespace timer2_bc12_bits {
        constexpr uint32_t TVDMSRC_ON = (10 << 0);  ///< Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
        constexpr uint32_t TWAIT_AFTER_PRD = (10 << 16);  ///< Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control register 1 (renamed from CHC1)
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status register (renamed from CHS)
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register (renamed from CHDLY0)
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register (renamed from CHDLY1)
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register (renamed from DACINTC)
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register (renamed from DACINT)
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register (renamed from PODLY)
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT_ = (16 << 0);  ///< DAC Interval (renamed from INT_)
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x400B8000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x400B9000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x400BB000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample time configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t TTSR;  ///< Offset: 0x20 - RTC Tamper Time Seconds Register
        volatile uint32_t MER;  ///< Offset: 0x24 - RTC Monotonic Enable Register
        volatile uint32_t MCLR;  ///< Offset: 0x28 - RTC Monotonic Counter Low Register
        volatile uint32_t MCHR;  ///< Offset: 0x2C - RTC Monotonic Counter High Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t MOF = (1U << 3);  ///< Monotonic Overflow Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
        constexpr uint32_t TTSL = (1U << 8);  ///< Tamper Time Seconds Lock
        constexpr uint32_t MEL = (1U << 9);  ///< Monotonic Enable Lock
        constexpr uint32_t MCLL = (1U << 10);  ///< Monotonic Counter Low Lock
        constexpr uint32_t MCHL = (1U << 11);  ///< Monotonic Counter High Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t MOIE = (1U << 3);  ///< Monotonic Overflow Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

    /// TTSR Register bits
    namespace ttsr_bits {
        constexpr uint32_t TTS = (32 << 0);  ///< Tamper Time Seconds
    }

    /// MER Register bits
    namespace mer_bits {
        constexpr uint32_t MCE = (1U << 4);  ///< Monotonic Counter Enable
    }

    /// MCLR Register bits
    namespace mclr_bits {
        constexpr uint32_t MCL = (32 << 0);  ///< Monotonic Counter Low
    }

    /// MCHR Register bits
    namespace mchr_bits {
        constexpr uint32_t MCH = (32 << 0);  ///< Monotonic Counter High
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
        constexpr uint32_t TTSW = (1U << 8);  ///< Tamper Time Seconds Write
        constexpr uint32_t MERW = (1U << 9);  ///< Monotonic Enable Register Write
        constexpr uint32_t MCLW = (1U << 10);  ///< Monotonic Counter Low Write
        constexpr uint32_t MCHW = (1U << 11);  ///< Monotonic Counter High Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
        constexpr uint32_t TTSR = (1U << 8);  ///< Tamper Time Seconds Read
        constexpr uint32_t MERR = (1U << 9);  ///< Monotonic Enable Register Read
        constexpr uint32_t MCLR = (1U << 10);  ///< Monotonic Counter Low Read
        constexpr uint32_t MCHR = (1U << 11);  ///< Monotonic Counter High Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t FBSL = (2 << 8);  ///< FlexBus security level
        constexpr uint32_t PTD7PAD = (1U << 11);  ///< PTD7 pad drive strength
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (1U << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
        constexpr uint32_t SDHCSRC = (2 << 28);  ///< SDHC clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FTM0 Fault 2 Select
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FTM2 Fault 0 Select
        constexpr uint32_t FTM3FLT0 = (1U << 12);  ///< FTM3 Fault 0 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 20);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 External Clock Pin Select
        constexpr uint32_t FTM3CLKSEL = (1U << 27);  ///< FlexTimer 3 External Clock Pin Select
        constexpr uint32_t FTM0TRG0SRC = (1U << 28);  ///< FlexTimer 0 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM0TRG1SRC = (1U << 29);  ///< FlexTimer 0 Hardware Trigger 1 Source Select
        constexpr uint32_t FTM3TRG0SRC = (1U << 30);  ///< FlexTimer 3 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM3TRG1SRC = (1U << 31);  ///< FlexTimer 3 Hardware Trigger 1 Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UART1TXSRC = (2 << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
        constexpr uint32_t ADC1TRGSEL = (4 << 8);  ///< ADC1 trigger select
        constexpr uint32_t ADC1PRETRGSEL = (1U << 12);  ///< ADC1 pre-trigger select
        constexpr uint32_t ADC1ALTTRGEN = (1U << 15);  ///< ADC1 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t DIEID = (5 << 7);  ///< Device die number
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t I2C2 = (1U << 6);  ///< I2C2 Clock Gate Control
        constexpr uint32_t UART4 = (1U << 10);  ///< UART4 Clock Gate Control
        constexpr uint32_t UART5 = (1U << 11);  ///< UART5 Clock Gate Control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t DAC0 = (1U << 12);  ///< DAC0 Clock Gate Control
        constexpr uint32_t DAC1 = (1U << 13);  ///< DAC1 Clock Gate Control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t RNGA = (1U << 0);  ///< RNGA Clock Gate Control
        constexpr uint32_t SPI2 = (1U << 12);  ///< SPI2 Clock Gate Control
        constexpr uint32_t SDHC = (1U << 17);  ///< SDHC Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 24);  ///< FTM2 Clock Gate Control
        constexpr uint32_t FTM3 = (1U << 25);  ///< FTM3 Clock Gate Control
        constexpr uint32_t ADC1 = (1U << 27);  ///< ADC1 Clock Gate Control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 Clock Gate Control
        constexpr uint32_t USBOTG = (1U << 18);  ///< USB Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t FLEXCAN0 = (1U << 4);  ///< FlexCAN0 Clock Gate Control
        constexpr uint32_t RNGA = (1U << 9);  ///< RNGA Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t USBDCD = (1U << 21);  ///< USB DCD Clock Gate Control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 26);  ///< FTM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFRAC = (1U << 0);  ///< USB clock divider fraction
        constexpr uint32_t USBDIV = (3 << 1);  ///< USB clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t DEPART = (4 << 8);  ///< FlexNVM partition
        constexpr uint32_t EESIZE = (4 << 16);  ///< EEPROM size
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t PFLSH = (1U << 23);  ///< Program flash
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
        constexpr uint32_t SWAPPFLSH = (1U << 31);  ///< Swap program flash
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enables Windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in Stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in Wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< Controls the upper mark periods of the modulator for all modes.
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< Controls the lower mark periods of the modulator for all modes.
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< Controls the upper space periods of the modulator for all modes.
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< Controls the lower space periods of the modulator for all modes.
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV0 = (5 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN0 = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN0 = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV0 = (5 << 0);  ///< VCO 0 Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;
    constexpr uint32_t I2C2_BASE = 0x400E6000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< The MULT bits define the multiplier factor mul
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Most significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Least significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;
    constexpr uint32_t UART4_BASE = 0x400EA000;
    constexpr uint32_t UART5_BASE = 0x400EB000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816T0;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WP7816T1;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 3);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< The current received dataword contained in D and C3[R8] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 7);  ///< The current received dataword contained in D and C3[R8] was received with noise.
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816T0 Register bits
    namespace wp7816t0_bits {
        constexpr uint32_t WI = (8 << 0);  ///< Wait Time Integer (C7816[TTYPE] = 0)
    }

    /// WP7816T1 Register bits
    namespace wp7816t1_bits {
        constexpr uint32_t BWI = (4 << 0);  ///< Block Wait Time Integer(C7816[TTYPE] = 1)
        constexpr uint32_t CWI = (4 << 4);  ///< Character Wait Time Integer (C7816[TTYPE] = 1)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40073010;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
        volatile uint32_t RST;  ///< Offset: 0x0A - LLWU Reset Enable register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// RST Register bits
    namespace rst_bits {
        constexpr uint32_t RSTFILT = (1U << 0);  ///< Digital Filter On RESET Pin
        constexpr uint32_t LLRSTE = (1U << 1);  ///< Low-Leakage Mode RESET Enable
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t VLLSCTRL;  ///< Offset: 0x02 - VLLS Control register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
        constexpr uint32_t LPWUI = (1U << 7);  ///< Low-Power Wake Up On Interrupt
    }

    /// VLLSCTRL Register bits
    namespace vllsctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t LPOPO = (1U << 3);  ///< LPO Power Option
        constexpr uint32_t RAM2PO = (1U << 4);  ///< RAM2 Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (7 << 0);  ///< When debug is enabled, the PMSTAT will not update to STOP or VLPS
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG Generated Reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t EZPT = (1U << 4);  ///< EzPort Reset
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t EZP_MS = (1U << 1);  ///< EZP_MS_B pin state
    }

}

// ============================================================================
// SDHC Peripheral
// ============================================================================

namespace sdhc {
    /// Base addresses
    constexpr uint32_t SDHC_BASE = 0x400B1000;

    /// SDHC Register structure
    struct Registers {
        volatile uint32_t DSADDR;  ///< Offset: 0x00 - DMA System Address register
        volatile uint32_t BLKATTR;  ///< Offset: 0x04 - Block Attributes register
        volatile uint32_t CMDARG;  ///< Offset: 0x08 - Command Argument register
        volatile uint32_t XFERTYP;  ///< Offset: 0x0C - Transfer Type register
        volatile uint32_t CMDRSP0;  ///< Offset: 0x10 - Command Response 0
        volatile uint32_t CMDRSP1;  ///< Offset: 0x14 - Command Response 1
        volatile uint32_t CMDRSP2;  ///< Offset: 0x18 - Command Response 2
        volatile uint32_t CMDRSP3;  ///< Offset: 0x1C - Command Response 3
        volatile uint32_t DATPORT;  ///< Offset: 0x20 - Buffer Data Port register
        volatile uint32_t PRSSTAT;  ///< Offset: 0x24 - Present State register
        volatile uint32_t PROCTL;  ///< Offset: 0x28 - Protocol Control register
        volatile uint32_t SYSCTL;  ///< Offset: 0x2C - System Control register
        volatile uint32_t IRQSTAT;  ///< Offset: 0x30 - Interrupt Status register
        volatile uint32_t IRQSTATEN;  ///< Offset: 0x34 - Interrupt Status Enable register
        volatile uint32_t IRQSIGEN;  ///< Offset: 0x38 - Interrupt Signal Enable register
        volatile uint32_t AC12ERR;  ///< Offset: 0x3C - Auto CMD12 Error Status Register
        volatile uint32_t HTCAPBLT;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WML;  ///< Offset: 0x44 - Watermark Level Register
        volatile uint32_t FEVT;  ///< Offset: 0x50 - Force Event register
        volatile uint32_t ADMAES;  ///< Offset: 0x54 - ADMA Error Status register
        volatile uint32_t ADSADDR;  ///< Offset: 0x58 - ADMA System Addressregister
        volatile uint32_t VENDOR;  ///< Offset: 0xC0 - Vendor Specific register
        volatile uint32_t MMCBOOT;  ///< Offset: 0xC4 - MMC Boot register
        volatile uint32_t HOSTVER;  ///< Offset: 0xFC - Host Controller Version
    };

    /// Peripheral instances
    inline Registers* SDHC = reinterpret_cast<Registers*>(SDHC_BASE);

    // Bit definitions
    /// DSADDR Register bits
    namespace dsaddr_bits {
        constexpr uint32_t DSADDR = (30 << 2);  ///< DMA System Address
    }

    /// BLKATTR Register bits
    namespace blkattr_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Transfer Block Size
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Blocks Count For Current Transfer
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// XFERTYP Register bits
    namespace xfertyp_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Select
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMDRSP0 Register bits
    namespace cmdrsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMDRSP1 Register bits
    namespace cmdrsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMDRSP2 Register bits
    namespace cmdrsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMDRSP3 Register bits
    namespace cmdrsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATPORT Register bits
    namespace datport_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRSSTAT Register bits
    namespace prsstat_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< Bus Clock Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< System Clock Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< SDHC clock Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t CINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DAT Line Signal Level
    }

    /// PROCTL Register bits
    namespace proctl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DAT3 As Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMAS = (2 << 8);  ///< DMA Select
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
    }

    /// SYSCTL Register bits
    namespace sysctl_bits {
        constexpr uint32_t IPGEN = (1U << 0);  ///< IPG Clock Enable
        constexpr uint32_t HCKEN = (1U << 1);  ///< System Clock Enable
        constexpr uint32_t PEREN = (1U << 2);  ///< Peripheral Clock Enable
        constexpr uint32_t SDCLKEN = (1U << 3);  ///< SD Clock Enable
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DAT Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
    }

    /// IRQSTAT Register bits
    namespace irqstat_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// IRQSTATEN Register bits
    namespace irqstaten_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// IRQSIGEN Register bits
    namespace irqsigen_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Enable
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AC12ERR Register bits
    namespace ac12err_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
    }

    /// HTCAPBLT Register bits
    namespace htcapblt_bits {
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3 V
    }

    /// WML Register bits
    namespace wml_bits {
        constexpr uint32_t RDWML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t WRWML = (8 << 16);  ///< Write Watermark Level
    }

    /// FEVT Register bits
    namespace fevt_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t AC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t AC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t CTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t CCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t DCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t CINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMAES Register bits
    namespace admaes_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (When ADMA Error Is Occurred.)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descriptor Error
    }

    /// ADSADDR Register bits
    namespace adsaddr_bits {
        constexpr uint32_t ADSADDR = (30 << 2);  ///< ADMA System Address
    }

    /// VENDOR Register bits
    namespace vendor_bits {
        constexpr uint32_t EXTDMAEN = (1U << 0);  ///< External DMA Request Enable
        constexpr uint32_t EXBLKNU = (1U << 1);  ///< Exact Block Number Block Read Enable For SDIO CMD53
        constexpr uint32_t INTSTVAL = (8 << 16);  ///< Internal State Value
    }

    /// MMCBOOT Register bits
    namespace mmcboot_bits {
        constexpr uint32_t DTOCVACK = (4 << 0);  ///< Boot ACK Time Out Counter Value
        constexpr uint32_t BOOTACK = (1U << 4);  ///< Boot Ack Mode Select
        constexpr uint32_t BOOTMODE = (1U << 5);  ///< Boot Mode Select
        constexpr uint32_t BOOTEN = (1U << 6);  ///< Boot Mode Enable
        constexpr uint32_t AUTOSABGEN = (1U << 7);  ///< When boot, enable auto stop at block gap function
        constexpr uint32_t BOOTBLKCNT = (16 << 16);  ///< Defines the stop at block gap value of automatic mode
    }

    /// HOSTVER Register bits
    namespace hostver_bits {
        constexpr uint32_t SVN = (8 << 0);  ///< Specification Version Number
        constexpr uint32_t VVN = (8 << 8);  ///< Vendor Version Number
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x400CC000;
    constexpr uint32_t DAC1_BASE = 0x400CD000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< When the DAC buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula: V out = V in * (1 + DACDAT0[11:0])/4096 When the DAC buffer is enabled, DATA is mapped to the 16-word buffer
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t ISCR;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t ETBCC;  ///< Offset: 0x14 - ETB Counter Control register
        volatile uint32_t ETBRL;  ///< Offset: 0x18 - ETB Reload register
        volatile uint32_t ETBCNT;  ///< Offset: 0x1C - ETB Counter Value register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// ISCR Register bits
    namespace iscr_bits {
        constexpr uint32_t IRQ = (1U << 1);  ///< Normal Interrupt Pending
        constexpr uint32_t NMI = (1U << 2);  ///< Non-maskable Interrupt Pending
        constexpr uint32_t DHREQ = (1U << 3);  ///< Debug Halt Request Indicator
        constexpr uint32_t FIOC = (1U << 8);  ///< FPU invalid operation interrupt status
        constexpr uint32_t FDZC = (1U << 9);  ///< FPU divide-by-zero interrupt status
        constexpr uint32_t FOFC = (1U << 10);  ///< FPU overflow interrupt status
        constexpr uint32_t FUFC = (1U << 11);  ///< FPU underflow interrupt status
        constexpr uint32_t FIXC = (1U << 12);  ///< FPU inexact interrupt status
        constexpr uint32_t FIDC = (1U << 15);  ///< FPU input denormal interrupt status
        constexpr uint32_t FIOCE = (1U << 24);  ///< FPU invalid operation interrupt enable
        constexpr uint32_t FDZCE = (1U << 25);  ///< FPU divide-by-zero interrupt enable
        constexpr uint32_t FOFCE = (1U << 26);  ///< FPU overflow interrupt enable
        constexpr uint32_t FUFCE = (1U << 27);  ///< FPU underflow interrupt enable
        constexpr uint32_t FIXCE = (1U << 28);  ///< FPU inexact interrupt enable
        constexpr uint32_t FIDCE = (1U << 31);  ///< FPU input denormal interrupt enable
    }

    /// ETBCC Register bits
    namespace etbcc_bits {
        constexpr uint32_t CNTEN = (1U << 0);  ///< Counter Enable
        constexpr uint32_t RSPT = (2 << 1);  ///< Response Type
        constexpr uint32_t RLRQ = (1U << 3);  ///< Reload Request
        constexpr uint32_t ETDIS = (1U << 4);  ///< ETM-To-TPIU Disable
        constexpr uint32_t ITDIS = (1U << 5);  ///< ITM-To-TPIU Disable
    }

    /// ETBRL Register bits
    namespace etbrl_bits {
        constexpr uint32_t RELOAD = (11 << 0);  ///< Byte Count Reload Value
    }

    /// ETBCNT Register bits
    namespace etbcnt_bits {
        constexpr uint32_t COUNTER = (11 << 0);  ///< Byte Count Counter Value
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID And M1_PID For MPU
    }

}

// ============================================================================
// CAU Peripheral
// ============================================================================

namespace cau {
    /// Base addresses
    constexpr uint32_t CAU_BASE = 0xE0081000;

    /// CAU Register structure
    struct Registers {
        volatile uint32_t CAU_DIRECT0;  ///< Offset: 0x00 - Direct access register 0
        volatile uint32_t CAU_DIRECT1;  ///< Offset: 0x04 - Direct access register 1
        volatile uint32_t CAU_DIRECT2;  ///< Offset: 0x08 - Direct access register 2
        volatile uint32_t CAU_DIRECT3;  ///< Offset: 0x0C - Direct access register 3
        volatile uint32_t CAU_DIRECT4;  ///< Offset: 0x10 - Direct access register 4
        volatile uint32_t CAU_DIRECT5;  ///< Offset: 0x14 - Direct access register 5
        volatile uint32_t CAU_DIRECT6;  ///< Offset: 0x18 - Direct access register 6
        volatile uint32_t CAU_DIRECT7;  ///< Offset: 0x1C - Direct access register 7
        volatile uint32_t CAU_DIRECT8;  ///< Offset: 0x20 - Direct access register 8
        volatile uint32_t CAU_DIRECT9;  ///< Offset: 0x24 - Direct access register 9
        volatile uint32_t CAU_DIRECT10;  ///< Offset: 0x28 - Direct access register 10
        volatile uint32_t CAU_DIRECT11;  ///< Offset: 0x2C - Direct access register 11
        volatile uint32_t CAU_DIRECT12;  ///< Offset: 0x30 - Direct access register 12
        volatile uint32_t CAU_DIRECT13;  ///< Offset: 0x34 - Direct access register 13
        volatile uint32_t CAU_DIRECT14;  ///< Offset: 0x38 - Direct access register 14
        volatile uint32_t CAU_DIRECT15;  ///< Offset: 0x3C - Direct access register 15
        volatile uint32_t CAU_LDR_CASR;  ///< Offset: 0x840 - Status register - Load Register command
        volatile uint32_t CAU_LDR_CAA;  ///< Offset: 0x844 - Accumulator register - Load Register command
        volatile uint32_t CAU_LDR_CA0;  ///< Offset: 0x848 - General Purpose Register 0 - Load Register command
        volatile uint32_t CAU_LDR_CA1;  ///< Offset: 0x84C - General Purpose Register 1 - Load Register command
        volatile uint32_t CAU_LDR_CA2;  ///< Offset: 0x850 - General Purpose Register 2 - Load Register command
        volatile uint32_t CAU_LDR_CA3;  ///< Offset: 0x854 - General Purpose Register 3 - Load Register command
        volatile uint32_t CAU_LDR_CA4;  ///< Offset: 0x858 - General Purpose Register 4 - Load Register command
        volatile uint32_t CAU_LDR_CA5;  ///< Offset: 0x85C - General Purpose Register 5 - Load Register command
        volatile uint32_t CAU_LDR_CA6;  ///< Offset: 0x860 - General Purpose Register 6 - Load Register command
        volatile uint32_t CAU_LDR_CA7;  ///< Offset: 0x864 - General Purpose Register 7 - Load Register command
        volatile uint32_t CAU_LDR_CA8;  ///< Offset: 0x868 - General Purpose Register 8 - Load Register command
        volatile uint32_t CAU_STR_CASR;  ///< Offset: 0x880 - Status register - Store Register command
        volatile uint32_t CAU_STR_CAA;  ///< Offset: 0x884 - Accumulator register - Store Register command
        volatile uint32_t CAU_STR_CA0;  ///< Offset: 0x888 - General Purpose Register 0 - Store Register command
        volatile uint32_t CAU_STR_CA1;  ///< Offset: 0x88C - General Purpose Register 1 - Store Register command
        volatile uint32_t CAU_STR_CA2;  ///< Offset: 0x890 - General Purpose Register 2 - Store Register command
        volatile uint32_t CAU_STR_CA3;  ///< Offset: 0x894 - General Purpose Register 3 - Store Register command
        volatile uint32_t CAU_STR_CA4;  ///< Offset: 0x898 - General Purpose Register 4 - Store Register command
        volatile uint32_t CAU_STR_CA5;  ///< Offset: 0x89C - General Purpose Register 5 - Store Register command
        volatile uint32_t CAU_STR_CA6;  ///< Offset: 0x8A0 - General Purpose Register 6 - Store Register command
        volatile uint32_t CAU_STR_CA7;  ///< Offset: 0x8A4 - General Purpose Register 7 - Store Register command
        volatile uint32_t CAU_STR_CA8;  ///< Offset: 0x8A8 - General Purpose Register 8 - Store Register command
        volatile uint32_t CAU_ADR_CASR;  ///< Offset: 0x8C0 - Status register - Add Register command
        volatile uint32_t CAU_ADR_CAA;  ///< Offset: 0x8C4 - Accumulator register - Add to register command
        volatile uint32_t CAU_ADR_CA0;  ///< Offset: 0x8C8 - General Purpose Register 0 - Add to register command
        volatile uint32_t CAU_ADR_CA1;  ///< Offset: 0x8CC - General Purpose Register 1 - Add to register command
        volatile uint32_t CAU_ADR_CA2;  ///< Offset: 0x8D0 - General Purpose Register 2 - Add to register command
        volatile uint32_t CAU_ADR_CA3;  ///< Offset: 0x8D4 - General Purpose Register 3 - Add to register command
        volatile uint32_t CAU_ADR_CA4;  ///< Offset: 0x8D8 - General Purpose Register 4 - Add to register command
        volatile uint32_t CAU_ADR_CA5;  ///< Offset: 0x8DC - General Purpose Register 5 - Add to register command
        volatile uint32_t CAU_ADR_CA6;  ///< Offset: 0x8E0 - General Purpose Register 6 - Add to register command
        volatile uint32_t CAU_ADR_CA7;  ///< Offset: 0x8E4 - General Purpose Register 7 - Add to register command
        volatile uint32_t CAU_ADR_CA8;  ///< Offset: 0x8E8 - General Purpose Register 8 - Add to register command
        volatile uint32_t CAU_RADR_CASR;  ///< Offset: 0x900 - Status register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CAA;  ///< Offset: 0x904 - Accumulator register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA0;  ///< Offset: 0x908 - General Purpose Register 0 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA1;  ///< Offset: 0x90C - General Purpose Register 1 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA2;  ///< Offset: 0x910 - General Purpose Register 2 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA3;  ///< Offset: 0x914 - General Purpose Register 3 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA4;  ///< Offset: 0x918 - General Purpose Register 4 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA5;  ///< Offset: 0x91C - General Purpose Register 5 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA6;  ///< Offset: 0x920 - General Purpose Register 6 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA7;  ///< Offset: 0x924 - General Purpose Register 7 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA8;  ///< Offset: 0x928 - General Purpose Register 8 - Reverse and Add to Register command
        volatile uint32_t CAU_XOR_CASR;  ///< Offset: 0x980 - Status register - Exclusive Or command
        volatile uint32_t CAU_XOR_CAA;  ///< Offset: 0x984 - Accumulator register - Exclusive Or command
        volatile uint32_t CAU_XOR_CA0;  ///< Offset: 0x988 - General Purpose Register 0 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA1;  ///< Offset: 0x98C - General Purpose Register 1 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA2;  ///< Offset: 0x990 - General Purpose Register 2 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA3;  ///< Offset: 0x994 - General Purpose Register 3 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA4;  ///< Offset: 0x998 - General Purpose Register 4 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA5;  ///< Offset: 0x99C - General Purpose Register 5 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA6;  ///< Offset: 0x9A0 - General Purpose Register 6 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA7;  ///< Offset: 0x9A4 - General Purpose Register 7 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA8;  ///< Offset: 0x9A8 - General Purpose Register 8 - Exclusive Or command
        volatile uint32_t CAU_ROTL_CASR;  ///< Offset: 0x9C0 - Status register - Rotate Left command
        volatile uint32_t CAU_ROTL_CAA;  ///< Offset: 0x9C4 - Accumulator register - Rotate Left command
        volatile uint32_t CAU_ROTL_CA0;  ///< Offset: 0x9C8 - General Purpose Register 0 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA1;  ///< Offset: 0x9CC - General Purpose Register 1 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA2;  ///< Offset: 0x9D0 - General Purpose Register 2 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA3;  ///< Offset: 0x9D4 - General Purpose Register 3 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA4;  ///< Offset: 0x9D8 - General Purpose Register 4 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA5;  ///< Offset: 0x9DC - General Purpose Register 5 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA6;  ///< Offset: 0x9E0 - General Purpose Register 6 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA7;  ///< Offset: 0x9E4 - General Purpose Register 7 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA8;  ///< Offset: 0x9E8 - General Purpose Register 8 - Rotate Left command
        volatile uint32_t CAU_AESC_CASR;  ///< Offset: 0xB00 - Status register - AES Column Operation command
        volatile uint32_t CAU_AESC_CAA;  ///< Offset: 0xB04 - Accumulator register - AES Column Operation command
        volatile uint32_t CAU_AESC_CA0;  ///< Offset: 0xB08 - General Purpose Register 0 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA1;  ///< Offset: 0xB0C - General Purpose Register 1 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA2;  ///< Offset: 0xB10 - General Purpose Register 2 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA3;  ///< Offset: 0xB14 - General Purpose Register 3 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA4;  ///< Offset: 0xB18 - General Purpose Register 4 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA5;  ///< Offset: 0xB1C - General Purpose Register 5 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA6;  ///< Offset: 0xB20 - General Purpose Register 6 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA7;  ///< Offset: 0xB24 - General Purpose Register 7 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA8;  ///< Offset: 0xB28 - General Purpose Register 8 - AES Column Operation command
        volatile uint32_t CAU_AESIC_CASR;  ///< Offset: 0xB40 - Status register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CAA;  ///< Offset: 0xB44 - Accumulator register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA0;  ///< Offset: 0xB48 - General Purpose Register 0 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA1;  ///< Offset: 0xB4C - General Purpose Register 1 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA2;  ///< Offset: 0xB50 - General Purpose Register 2 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA3;  ///< Offset: 0xB54 - General Purpose Register 3 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA4;  ///< Offset: 0xB58 - General Purpose Register 4 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA5;  ///< Offset: 0xB5C - General Purpose Register 5 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA6;  ///< Offset: 0xB60 - General Purpose Register 6 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA7;  ///< Offset: 0xB64 - General Purpose Register 7 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA8;  ///< Offset: 0xB68 - General Purpose Register 8 - AES Inverse Column Operation command
    };

    /// Peripheral instances
    inline Registers* CAU = reinterpret_cast<Registers*>(CAU_BASE);

    // Bit definitions
    /// CAU_DIRECT0 Register bits
    namespace cau_direct0_bits {
        constexpr uint32_t CAU_DIRECT0 = (32 << 0);  ///< Direct register 0
    }

    /// CAU_DIRECT1 Register bits
    namespace cau_direct1_bits {
        constexpr uint32_t CAU_DIRECT1 = (32 << 0);  ///< Direct register 1
    }

    /// CAU_DIRECT2 Register bits
    namespace cau_direct2_bits {
        constexpr uint32_t CAU_DIRECT2 = (32 << 0);  ///< Direct register 2
    }

    /// CAU_DIRECT3 Register bits
    namespace cau_direct3_bits {
        constexpr uint32_t CAU_DIRECT3 = (32 << 0);  ///< Direct register 3
    }

    /// CAU_DIRECT4 Register bits
    namespace cau_direct4_bits {
        constexpr uint32_t CAU_DIRECT4 = (32 << 0);  ///< Direct register 4
    }

    /// CAU_DIRECT5 Register bits
    namespace cau_direct5_bits {
        constexpr uint32_t CAU_DIRECT5 = (32 << 0);  ///< Direct register 5
    }

    /// CAU_DIRECT6 Register bits
    namespace cau_direct6_bits {
        constexpr uint32_t CAU_DIRECT6 = (32 << 0);  ///< Direct register 6
    }

    /// CAU_DIRECT7 Register bits
    namespace cau_direct7_bits {
        constexpr uint32_t CAU_DIRECT7 = (32 << 0);  ///< Direct register 7
    }

    /// CAU_DIRECT8 Register bits
    namespace cau_direct8_bits {
        constexpr uint32_t CAU_DIRECT8 = (32 << 0);  ///< Direct register 8
    }

    /// CAU_DIRECT9 Register bits
    namespace cau_direct9_bits {
        constexpr uint32_t CAU_DIRECT9 = (32 << 0);  ///< Direct register 9
    }

    /// CAU_DIRECT10 Register bits
    namespace cau_direct10_bits {
        constexpr uint32_t CAU_DIRECT10 = (32 << 0);  ///< Direct register 10
    }

    /// CAU_DIRECT11 Register bits
    namespace cau_direct11_bits {
        constexpr uint32_t CAU_DIRECT11 = (32 << 0);  ///< Direct register 11
    }

    /// CAU_DIRECT12 Register bits
    namespace cau_direct12_bits {
        constexpr uint32_t CAU_DIRECT12 = (32 << 0);  ///< Direct register 12
    }

    /// CAU_DIRECT13 Register bits
    namespace cau_direct13_bits {
        constexpr uint32_t CAU_DIRECT13 = (32 << 0);  ///< Direct register 13
    }

    /// CAU_DIRECT14 Register bits
    namespace cau_direct14_bits {
        constexpr uint32_t CAU_DIRECT14 = (32 << 0);  ///< Direct register 14
    }

    /// CAU_DIRECT15 Register bits
    namespace cau_direct15_bits {
        constexpr uint32_t CAU_DIRECT15 = (32 << 0);  ///< Direct register 15
    }

    /// CAU_LDR_CASR Register bits
    namespace cau_ldr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_LDR_CAA Register bits
    namespace cau_ldr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_LDR_CA0 Register bits
    namespace cau_ldr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_LDR_CA1 Register bits
    namespace cau_ldr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_LDR_CA2 Register bits
    namespace cau_ldr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_LDR_CA3 Register bits
    namespace cau_ldr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_LDR_CA4 Register bits
    namespace cau_ldr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_LDR_CA5 Register bits
    namespace cau_ldr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_LDR_CA6 Register bits
    namespace cau_ldr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_LDR_CA7 Register bits
    namespace cau_ldr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_LDR_CA8 Register bits
    namespace cau_ldr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_STR_CASR Register bits
    namespace cau_str_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_STR_CAA Register bits
    namespace cau_str_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_STR_CA0 Register bits
    namespace cau_str_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_STR_CA1 Register bits
    namespace cau_str_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_STR_CA2 Register bits
    namespace cau_str_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_STR_CA3 Register bits
    namespace cau_str_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_STR_CA4 Register bits
    namespace cau_str_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_STR_CA5 Register bits
    namespace cau_str_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_STR_CA6 Register bits
    namespace cau_str_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_STR_CA7 Register bits
    namespace cau_str_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_STR_CA8 Register bits
    namespace cau_str_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ADR_CASR Register bits
    namespace cau_adr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ADR_CAA Register bits
    namespace cau_adr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ADR_CA0 Register bits
    namespace cau_adr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ADR_CA1 Register bits
    namespace cau_adr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ADR_CA2 Register bits
    namespace cau_adr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ADR_CA3 Register bits
    namespace cau_adr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ADR_CA4 Register bits
    namespace cau_adr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ADR_CA5 Register bits
    namespace cau_adr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ADR_CA6 Register bits
    namespace cau_adr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ADR_CA7 Register bits
    namespace cau_adr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ADR_CA8 Register bits
    namespace cau_adr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_RADR_CASR Register bits
    namespace cau_radr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_RADR_CAA Register bits
    namespace cau_radr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_RADR_CA0 Register bits
    namespace cau_radr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_RADR_CA1 Register bits
    namespace cau_radr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_RADR_CA2 Register bits
    namespace cau_radr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_RADR_CA3 Register bits
    namespace cau_radr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_RADR_CA4 Register bits
    namespace cau_radr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_RADR_CA5 Register bits
    namespace cau_radr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_RADR_CA6 Register bits
    namespace cau_radr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_RADR_CA7 Register bits
    namespace cau_radr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_RADR_CA8 Register bits
    namespace cau_radr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_XOR_CASR Register bits
    namespace cau_xor_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_XOR_CAA Register bits
    namespace cau_xor_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_XOR_CA0 Register bits
    namespace cau_xor_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_XOR_CA1 Register bits
    namespace cau_xor_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_XOR_CA2 Register bits
    namespace cau_xor_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_XOR_CA3 Register bits
    namespace cau_xor_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_XOR_CA4 Register bits
    namespace cau_xor_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_XOR_CA5 Register bits
    namespace cau_xor_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_XOR_CA6 Register bits
    namespace cau_xor_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_XOR_CA7 Register bits
    namespace cau_xor_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_XOR_CA8 Register bits
    namespace cau_xor_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ROTL_CASR Register bits
    namespace cau_rotl_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ROTL_CAA Register bits
    namespace cau_rotl_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ROTL_CA0 Register bits
    namespace cau_rotl_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ROTL_CA1 Register bits
    namespace cau_rotl_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ROTL_CA2 Register bits
    namespace cau_rotl_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ROTL_CA3 Register bits
    namespace cau_rotl_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ROTL_CA4 Register bits
    namespace cau_rotl_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ROTL_CA5 Register bits
    namespace cau_rotl_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ROTL_CA6 Register bits
    namespace cau_rotl_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ROTL_CA7 Register bits
    namespace cau_rotl_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ROTL_CA8 Register bits
    namespace cau_rotl_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESC_CASR Register bits
    namespace cau_aesc_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESC_CAA Register bits
    namespace cau_aesc_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESC_CA0 Register bits
    namespace cau_aesc_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESC_CA1 Register bits
    namespace cau_aesc_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESC_CA2 Register bits
    namespace cau_aesc_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESC_CA3 Register bits
    namespace cau_aesc_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESC_CA4 Register bits
    namespace cau_aesc_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESC_CA5 Register bits
    namespace cau_aesc_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESC_CA6 Register bits
    namespace cau_aesc_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESC_CA7 Register bits
    namespace cau_aesc_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESC_CA8 Register bits
    namespace cau_aesc_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESIC_CASR Register bits
    namespace cau_aesic_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESIC_CAA Register bits
    namespace cau_aesic_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESIC_CA0 Register bits
    namespace cau_aesic_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESIC_CA1 Register bits
    namespace cau_aesic_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESIC_CA2 Register bits
    namespace cau_aesic_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESIC_CA3 Register bits
    namespace cau_aesic_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESIC_CA4 Register bits
    namespace cau_aesic_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESIC_CA5 Register bits
    namespace cau_aesic_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESIC_CA6 Register bits
    namespace cau_aesic_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESIC_CA7 Register bits
    namespace cau_aesic_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESIC_CA8 Register bits
    namespace cau_aesic_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

}


} // namespace alloy::generated::mk21f12

#endif // ALLOY_GENERATED_MK21F12_PERIPHERALS_HPP