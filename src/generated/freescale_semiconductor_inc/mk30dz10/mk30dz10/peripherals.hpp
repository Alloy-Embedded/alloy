/// Auto-generated code for MK30DZ10
/// Generated by Alloy Code Generator
/// Source: nxp_mk30.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:26
#ifndef ALLOY_GENERATED_MK30DZ10_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK30DZ10_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::mk30dz10 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfl = true;
    constexpr uint32_t num_ftfl_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 5;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_mc = true;
    constexpr uint32_t num_mc_instances = 1;
    constexpr bool has_sdhc = true;
    constexpr uint32_t num_sdhc_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_pta = true;
    constexpr uint32_t num_pta_instances = 1;
    constexpr bool has_ptb = true;
    constexpr uint32_t num_ptb_instances = 1;
    constexpr bool has_ptc = true;
    constexpr uint32_t num_ptc_instances = 1;
    constexpr bool has_ptd = true;
    constexpr uint32_t num_ptd_instances = 1;
    constexpr bool has_pte = true;
    constexpr uint32_t num_pte_instances = 1;
    constexpr bool has_systemcontrol = true;
    constexpr uint32_t num_systemcontrol_instances = 1;
    constexpr bool has_systick = true;
    constexpr uint32_t num_systick_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pta_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ptd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pte_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systemcontrol_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct systick_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 5;
    constexpr uint32_t max_gpio_pins = 80;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFL_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL_FlashConfig = reinterpret_cast<Registers*>(FTFL_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t EZPORT_DIS = (1U << 1);  ///< no description available
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master privilege level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master trusted for writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master trusted for read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master privilege level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master trusted for writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master trusted for read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master privilege level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master trusted for writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master trusted for read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master privilege level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master trusted for writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master trusted for read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master privilege level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master trusted for writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master trusted for read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master privilege level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master trusted for writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master trusted for read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master privilege level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master trusted for writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master trusted for read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master privilege level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master trusted for writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master trusted for read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master privilege level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master trusted for writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master trusted for read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master privilege level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master trusted for writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master trusted for read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor protect
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS;  ///< Offset: 0x00 - Priority Registers Slave (renamed from PRS)
        volatile uint32_t CRS;  ///< Offset: 0x10 - Control Register (renamed from CRS)
        volatile uint32_t MGPCR0;  ///< Offset: 0x800 - Master General Purpose Control Register
        volatile uint32_t MGPCR1;  ///< Offset: 0x900 - Master General Purpose Control Register
        volatile uint32_t MGPCR2;  ///< Offset: 0xA00 - Master General Purpose Control Register
        volatile uint32_t MGPCR5;  ///< Offset: 0xD00 - Master General Purpose Control Register
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS Register bits
    namespace prs_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M3 = (3 << 12);  ///< Master 3 priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M4 = (3 << 16);  ///< Master 4 priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M5 = (3 << 20);  ///< Master 5 priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS Register bits
    namespace crs_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt low priority
        constexpr uint32_t RO = (1U << 31);  ///< Read only
    }

    /// MGPCR0 Register bits
    namespace mgpcr0_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates on undefined length bursts
    }

    /// MGPCR1 Register bits
    namespace mgpcr1_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates on undefined length bursts
    }

    /// MGPCR2 Register bits
    namespace mgpcr2_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates on undefined length bursts
    }

    /// MGPCR5 Register bits
    namespace mgpcr5_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates on undefined length bursts
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Cancelled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Cancelled
        constexpr uint32_t VLD = (1U << 31);  ///< no description available
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set enable request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< no description available
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo.
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< no description available
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Chip select address register (renamed from CSAR)
        volatile uint32_t CSMR;  ///< Offset: 0x04 - Chip select mask register (renamed from CSMR)
        volatile uint32_t CSCR;  ///< Offset: 0x08 - Chip select control register (renamed from CSCR)
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip select port multiplexing control register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t BA = (16 << 16);  ///< Base address
    }

    /// CSMR Register bits
    namespace csmr_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t WP = (1U << 8);  ///< Write protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base address mask
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-write enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-read enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-enable mode
        constexpr uint32_t PS = (2 << 6);  ///< Port size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-acknowledge enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-lane shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait states
        constexpr uint32_t WRAH = (2 << 16);  ///< Write address hold or deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read address hold or deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address setup
        constexpr uint32_t EXTS = (1U << 22);  ///< no description available
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary wait state enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary wait states
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus signal group 5 multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus signal group 4 multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus signal group 3 multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus signal group 2 multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus signal group 1 multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, Slave Port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, Slave Port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid (global enable/disable for the MPU)
        constexpr uint32_t NRGD = (4 << 8);  ///< Number of region descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number of slave ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware revision level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave port n error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error read/write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error master number
        constexpr uint32_t EACD = (16 << 16);  ///< Error access control detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus master 0 user mode access control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus master 0 supervisor mode access control
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus master 1 user mode access control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus master 1 supervisor mode access control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus master 2 user mode access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus master 2 supervisor mode access control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus master 3 user mode access control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus master 3 supervisor mode access control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus master 4 write enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus master 4 read enable.
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus master 5 write enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus master 5 read enable.
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus master 6 write enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus master 6 read enable.
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus master 7 write enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus master 7 read enable.
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus master 0 user mode access control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus master 0 supervisor mode access control
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus master 1 user mode access control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus master 1 supervisor mode access control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus master 2 user mode access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus master 2 supervisor mode access control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus master 3 user mode access control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus master 3 supervisor mode access control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus master 4 write enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus master 4 read enable.
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus master 5 write enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus master 5 read enable.
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus master 6 write enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus master 6 read enable.
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus master 7 write enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus master 7 read enable.
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
        volatile uint32_t PFB1CR;  ///< Offset: 0x08 - Flash Bank 1 Control Register
        volatile uint32_t TAGVDW0S;  ///< Offset: 0x100 - Cache Tag Storage (renamed from TAGVDW0S)
        volatile uint32_t TAGVDW1S;  ///< Offset: 0x120 - Cache Tag Storage (renamed from TAGVDW1S)
        volatile uint32_t TAGVDW2S;  ///< Offset: 0x140 - Cache Tag Storage (renamed from TAGVDW2S)
        volatile uint32_t TAGVDW3S;  ///< Offset: 0x160 - Cache Tag Storage (renamed from TAGVDW3S)
        volatile uint32_t DATAW0SU;  ///< Offset: 0x200 - Cache Data Storage (upper word) (renamed from DATAW0SU)
        volatile uint32_t DATAW0SL;  ///< Offset: 0x204 - Cache Data Storage (lower word) (renamed from DATAW0SL)
        volatile uint32_t DATAW1SU;  ///< Offset: 0x240 - Cache Data Storage (upper word) (renamed from DATAW1SU)
        volatile uint32_t DATAW1SL;  ///< Offset: 0x244 - Cache Data Storage (lower word) (renamed from DATAW1SL)
        volatile uint32_t DATAW2SU;  ///< Offset: 0x280 - Cache Data Storage (upper word) (renamed from DATAW2SU)
        volatile uint32_t DATAW2SL;  ///< Offset: 0x284 - Cache Data Storage (lower word) (renamed from DATAW2SL)
        volatile uint32_t DATAW3SU;  ///< Offset: 0x2C0 - Cache Data Storage (upper word) (renamed from DATAW3SU)
        volatile uint32_t DATAW3SL;  ///< Offset: 0x2C4 - Cache Data Storage (lower word) (renamed from DATAW3SL)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M4AP = (2 << 8);  ///< Master 4 Access Protection
        constexpr uint32_t M5AP = (2 << 10);  ///< Master 5 Access Protection
        constexpr uint32_t M6AP = (2 << 12);  ///< Master 6 Access Protection
        constexpr uint32_t M7AP = (2 << 14);  ///< Master 7 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
        constexpr uint32_t M4PFD = (1U << 20);  ///< Master 4 Prefetch Disable
        constexpr uint32_t M5PFD = (1U << 21);  ///< Master 5 Prefetch Disable
        constexpr uint32_t M6PFD = (1U << 22);  ///< Master 6 Prefetch Disable
        constexpr uint32_t M7PFD = (1U << 23);  ///< Master 7 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Bank 0 Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Bank 0 Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Bank 0 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

    /// PFB1CR Register bits
    namespace pfb1cr_bits {
        constexpr uint32_t B1SEBE = (1U << 0);  ///< Bank 1 Single Entry Buffer Enable
        constexpr uint32_t B1IPE = (1U << 1);  ///< Bank 1 Instruction Prefetch Enable
        constexpr uint32_t B1DPE = (1U << 2);  ///< Bank 1 Data Prefetch Enable
        constexpr uint32_t B1ICE = (1U << 3);  ///< Bank 1 Instruction Cache Enable
        constexpr uint32_t B1DCE = (1U << 4);  ///< Bank 1 Data Cache Enable
        constexpr uint32_t B1MW = (2 << 17);  ///< Bank 1 Memory Width
        constexpr uint32_t B1RWSC = (4 << 28);  ///< Bank 1 Read Wait State Control
    }

    /// TAGVDW0S Register bits
    namespace tagvdw0s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW1S Register bits
    namespace tagvdw1s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW2S Register bits
    namespace tagvdw2s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW3S Register bits
    namespace tagvdw3s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// DATAW0SU Register bits
    namespace dataw0su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0SL Register bits
    namespace dataw0sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1SU Register bits
    namespace dataw1su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1SL Register bits
    namespace dataw1sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2SU Register bits
    namespace dataw2su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2SL Register bits
    namespace dataw2sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3SU Register bits
    namespace dataw3su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3SL Register bits
    namespace dataw3sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// FTFL Peripheral
// ============================================================================

namespace ftfl {
    /// Base addresses
    constexpr uint32_t FTFL_BASE = 0x40020000;

    /// FTFL Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB;  ///< Offset: 0x04 - Flash Common Command Object Registers (renamed from FCCOB)
        volatile uint32_t FPROT;  ///< Offset: 0x10 - Program Flash Protection Registers (renamed from FPROT)
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL = reinterpret_cast<Registers*>(FTFL_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFL Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< no description available
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFL configuration
        constexpr uint32_t SWAP = (1U << 3);  ///< Swap
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB Register bits
    namespace fccob_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< no description available
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;
    constexpr uint32_t CAN1_BASE = 0x400A4000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 Register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask Register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask Register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 Register
        volatile uint32_t IMASK2;  ///< Offset: 0x24 - Interrupt Masks 2 Register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 Register
        volatile uint32_t IFLAG2;  ///< Offset: 0x2C - Interrupt Flags 2 Register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 Register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 Register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 Register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask Register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t RXIMR;  ///< Offset: 0x880 - Rx Individual Mask Registers (renamed from RXIMR)
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number of the Last Message Buffer
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking and Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t DOZE = (1U << 18);  ///< Doze Mode Enable
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer value
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< 'Bus Off' Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN in Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN in Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< no description available
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
    }

    /// IMASK2 Register bits
    namespace imask2_bits {
        constexpr uint32_t BUFHM = (32 << 0);  ///< Buffer MBi Mask
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUFLM = (32 << 0);  ///< Buffer MBi Mask
    }

    /// IFLAG2 Register bits
    namespace iflag2_bits {
        constexpr uint32_t BUFHI = (32 << 0);  ///< Buffer MBi Interrupt
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF4TO0I = (5 << 0);  ///< Buffer MBi Interrupt or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable for Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number of Rx FIFO Filters
        constexpr uint32_t WRMFRZ = (1U << 28);  ///< Write-Access to Memory in Freeze mode
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< CRC Transmitted
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR Register bits
    namespace rximr_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - DSPI Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - DSPI Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - DSPI Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DSPI DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - DSPI PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - DSPI POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - DSPI Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - DSPI Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< no description available
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Timing Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< DSPI Configuration
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LBS First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (5 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select.
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< DSPI Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< no description available
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter.
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select.
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (32 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TX0;  ///< Offset: 0x00 - I2S Transmit Data Registers 0
        volatile uint32_t TX1;  ///< Offset: 0x04 - I2S Transmit Data Registers 1
        volatile uint32_t RX0;  ///< Offset: 0x08 - I2S Receive Data Registers 0
        volatile uint32_t RX1;  ///< Offset: 0x0C - I2S Receive Data Registers 1
        volatile uint32_t CR;  ///< Offset: 0x10 - I2S Control Register
        volatile uint32_t ISR;  ///< Offset: 0x14 - I2S Interrupt Status Register
        volatile uint32_t IER;  ///< Offset: 0x18 - I2S Interrupt Enable Register
        volatile uint32_t TCR;  ///< Offset: 0x1C - I2S Transmit Configuration Register
        volatile uint32_t RCR;  ///< Offset: 0x20 - I2S Receive Configuration Register
        volatile uint32_t TCCR;  ///< Offset: 0x24 - I2S Transmit Clock Control Registers
        volatile uint32_t RCCR;  ///< Offset: 0x28 - I2S Receive Clock Control Registers
        volatile uint32_t FCSR;  ///< Offset: 0x2C - I2S FIFO Control/Status Register
        volatile uint32_t ACNT;  ///< Offset: 0x38 - I2S AC97 Control Register
        volatile uint32_t ACADD;  ///< Offset: 0x3C - I2S AC97 Command Address Register
        volatile uint32_t ACDAT;  ///< Offset: 0x40 - I2S AC97 Command Data Register
        volatile uint32_t ATAG;  ///< Offset: 0x44 - I2S AC97 Tag Register
        volatile uint32_t TMSK;  ///< Offset: 0x48 - I2S Transmit Time Slot Mask Register
        volatile uint32_t RMSK;  ///< Offset: 0x4C - I2S Receive Time Slot Mask Register
        volatile uint32_t ACCST;  ///< Offset: 0x50 - I2S AC97 Channel Status Register
        volatile uint32_t ACCEN;  ///< Offset: 0x54 - I2S AC97 Channel Enable Register
        volatile uint32_t ACCDIS;  ///< Offset: 0x58 - I2S AC97 Channel Disable Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TX0 Register bits
    namespace tx0_bits {
        constexpr uint32_t TX0 = (32 << 0);  ///< I2S transmit data
    }

    /// TX1 Register bits
    namespace tx1_bits {
        constexpr uint32_t TX1 = (32 << 0);  ///< I2S transmit data
    }

    /// RX0 Register bits
    namespace rx0_bits {
        constexpr uint32_t RX0 = (32 << 0);  ///< I2S Receive Data
    }

    /// RX1 Register bits
    namespace rx1_bits {
        constexpr uint32_t RX1 = (32 << 0);  ///< I2S Receive Data
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t I2SEN = (1U << 0);  ///< I2S Enable.
        constexpr uint32_t TE = (1U << 1);  ///< Transmit Enable.
        constexpr uint32_t RE = (1U << 2);  ///< Receive Enable.
        constexpr uint32_t NET = (1U << 3);  ///< Network Mode.
        constexpr uint32_t SYN = (1U << 4);  ///< Synchronous Mode.
        constexpr uint32_t I2SMODE = (2 << 5);  ///< I2S Mode Select
        constexpr uint32_t SYSCLKEN = (1U << 7);  ///< System Clock (Oversampling Clock) Enable.
        constexpr uint32_t TCHEN = (1U << 8);  ///< Two-Channel Operation Enable.
        constexpr uint32_t CLKIST = (1U << 9);  ///< Clock Idle State.
        constexpr uint32_t TFRCLKDIS = (1U << 10);  ///< Transmit Frame Clock Disable.
        constexpr uint32_t RFRCLKDIS = (1U << 11);  ///< Receive Frame Clock Disable.
        constexpr uint32_t SYNCTXFS = (1U << 12);  ///< no description available
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TFE0 = (1U << 0);  ///< Transmit FIFO Empty 0.
        constexpr uint32_t TFE1 = (1U << 1);  ///< Transmit FIFO Empty 1.
        constexpr uint32_t RFF0 = (1U << 2);  ///< Receive FIFO Full 0.
        constexpr uint32_t RFF1 = (1U << 3);  ///< Receive FIFO Full 1.
        constexpr uint32_t RLS = (1U << 4);  ///< Receive Last Time Slot.
        constexpr uint32_t TLS = (1U << 5);  ///< Transmit Last Time Slot.
        constexpr uint32_t RFS = (1U << 6);  ///< Receive Frame Sync.
        constexpr uint32_t TFS = (1U << 7);  ///< Transmit Frame Sync.
        constexpr uint32_t TUE0 = (1U << 8);  ///< Transmitter Underrun Error 1.
        constexpr uint32_t TUE1 = (1U << 9);  ///< Transmitter Underrun Error 1.
        constexpr uint32_t ROE0 = (1U << 10);  ///< Receiver Overrun Error 0.
        constexpr uint32_t ROE1 = (1U << 11);  ///< Receiver Overrun Error 1.
        constexpr uint32_t TDE0 = (1U << 12);  ///< Transmit Data Register Empty 0.
        constexpr uint32_t TDE1 = (1U << 13);  ///< Transmit Data Register Empty 1.
        constexpr uint32_t RDR0 = (1U << 14);  ///< Receive Data Ready 0.
        constexpr uint32_t RDR1 = (1U << 15);  ///< Receive Data Ready 1.
        constexpr uint32_t RXT = (1U << 16);  ///< Receive Tag Updated.
        constexpr uint32_t CMDDU = (1U << 17);  ///< Command Data Register Updated.
        constexpr uint32_t CMDAU = (1U << 18);  ///< Command Address Register Updated.
        constexpr uint32_t TRFC = (1U << 23);  ///< Transmit Frame Complete.
        constexpr uint32_t RFRC = (1U << 24);  ///< Receive Frame Complete.
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TFE0EN = (1U << 0);  ///< Enable Bit.
        constexpr uint32_t TFE1EN = (1U << 1);  ///< Enable Bit.
        constexpr uint32_t RFF0EN = (1U << 2);  ///< Enable Bit.
        constexpr uint32_t RFF1EN = (1U << 3);  ///< Enable Bit.
        constexpr uint32_t RLSEN = (1U << 4);  ///< Enable Bit.
        constexpr uint32_t TLSEN = (1U << 5);  ///< Enable Bit.
        constexpr uint32_t RFSEN = (1U << 6);  ///< Enable Bit.
        constexpr uint32_t TFSEN = (1U << 7);  ///< Enable Bit.
        constexpr uint32_t TUE0EN = (1U << 8);  ///< Enable Bit.
        constexpr uint32_t TUE1EN = (1U << 9);  ///< Enable Bit.
        constexpr uint32_t ROE0EN = (1U << 10);  ///< Enable Bit.
        constexpr uint32_t ROE1EN = (1U << 11);  ///< Enable Bit.
        constexpr uint32_t TDE0EN = (1U << 12);  ///< Enable Bit.
        constexpr uint32_t TDE1EN = (1U << 13);  ///< Enable Bit.
        constexpr uint32_t RDR0EN = (1U << 14);  ///< Enable Bit.
        constexpr uint32_t RDR1EN = (1U << 15);  ///< Enable Bit.
        constexpr uint32_t RXTEN = (1U << 16);  ///< Enable Bit.
        constexpr uint32_t CMDDUEN = (1U << 17);  ///< Enable Bit.
        constexpr uint32_t CMDAUEN = (1U << 18);  ///< Enable Bit.
        constexpr uint32_t TIE = (1U << 19);  ///< Transmit Interrupt Enable.
        constexpr uint32_t TDMAE = (1U << 20);  ///< Transmit DMA Enable.
        constexpr uint32_t RIE = (1U << 21);  ///< Receive Interrupt Enable.
        constexpr uint32_t RDMAE = (1U << 22);  ///< Receive DMA Enable.
        constexpr uint32_t TFRC_EN = (1U << 23);  ///< Enable Bit.
        constexpr uint32_t RFRC_EN = (1U << 24);  ///< Enable Bit.
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TEFS = (1U << 0);  ///< Transmit Early Frame Sync.
        constexpr uint32_t TFSL = (1U << 1);  ///< Transmit Frame Sync Length.
        constexpr uint32_t TFSI = (1U << 2);  ///< Transmit Frame Sync Invert.
        constexpr uint32_t TSCKP = (1U << 3);  ///< Transmit Clock Polarity.
        constexpr uint32_t TSHFD = (1U << 4);  ///< Transmit Shift Direction.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmit clock direction
        constexpr uint32_t TFDIR = (1U << 6);  ///< Transmit Frame Direction.
        constexpr uint32_t TFEN0 = (1U << 7);  ///< Transmit FIFO Enable 0.
        constexpr uint32_t TFEN1 = (1U << 8);  ///< Transmit FIFO Enable 1.
        constexpr uint32_t TXBIT0 = (1U << 9);  ///< Transmit Bit 0.
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REFS = (1U << 0);  ///< Receive Early Frame Sync.
        constexpr uint32_t RFSL = (1U << 1);  ///< Receive Frame Sync Length.
        constexpr uint32_t RFSI = (1U << 2);  ///< Receive Frame Sync Invert.
        constexpr uint32_t RSCKP = (1U << 3);  ///< Receive Clock Polarity.
        constexpr uint32_t RSHFD = (1U << 4);  ///< Receive Shift Direction.
        constexpr uint32_t RXDIR = (1U << 5);  ///< Receive Clock Direction.
        constexpr uint32_t RFDIR = (1U << 6);  ///< Receive Frame Direction.
        constexpr uint32_t RFEN0 = (1U << 7);  ///< Receive FIFO Enable 0.
        constexpr uint32_t RFEN1 = (1U << 8);  ///< Receive FIFO Enable 1.
        constexpr uint32_t RXBIT0 = (1U << 9);  ///< Receive Bit 0.
        constexpr uint32_t RXEXT = (1U << 10);  ///< Receive Data Extension.
    }

    /// TCCR Register bits
    namespace tccr_bits {
        constexpr uint32_t PM = (8 << 0);  ///< Prescaler Modulus Select.
        constexpr uint32_t DC = (5 << 8);  ///< Frame Rate Divider Control.
        constexpr uint32_t WL = (4 << 13);  ///< Word Length Control.
        constexpr uint32_t PSR = (1U << 17);  ///< Prescaler Range.
        constexpr uint32_t DIV2 = (1U << 18);  ///< Divide By 2.
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t PM = (8 << 0);  ///< Prescaler Modulus Select.
        constexpr uint32_t DC = (5 << 8);  ///< Frame Rate Divider Control.
        constexpr uint32_t WL = (4 << 13);  ///< Word Length Control.
        constexpr uint32_t PSR = (1U << 17);  ///< Prescaler Range.
        constexpr uint32_t DIV2 = (1U << 18);  ///< Divide By 2.
    }

    /// FCSR Register bits
    namespace fcsr_bits {
        constexpr uint32_t TFWM0 = (4 << 0);  ///< Transmit FIFO Empty WaterMark 0.
        constexpr uint32_t RFWM0 = (4 << 4);  ///< Receive FIFO Full WaterMark 0.
        constexpr uint32_t TFCNT0 = (4 << 8);  ///< Transmit FIFO Counter 0.
        constexpr uint32_t RFCNT0 = (4 << 12);  ///< Receive FIFO Counter 0.
        constexpr uint32_t TFWM1 = (4 << 16);  ///< Transmit FIFO Empty WaterMark 1.
        constexpr uint32_t RFWM1 = (4 << 20);  ///< Receive FIFO Full WaterMark 1.
        constexpr uint32_t TFCNT1 = (4 << 24);  ///< Transmit FIFO Counter1.
        constexpr uint32_t RFCNT1 = (4 << 28);  ///< Receive FIFO Counter1.
    }

    /// ACNT Register bits
    namespace acnt_bits {
        constexpr uint32_t AC97EN = (1U << 0);  ///< AC97 Mode Enable.
        constexpr uint32_t FV = (1U << 1);  ///< Fixed/Variable Operation.
        constexpr uint32_t TIF = (1U << 2);  ///< Tag in FIFO.
        constexpr uint32_t RD = (1U << 3);  ///< Read Command.
        constexpr uint32_t WR = (1U << 4);  ///< Write Command.
        constexpr uint32_t FRDIV = (6 << 5);  ///< Frame Rate Divider.
    }

    /// ACADD Register bits
    namespace acadd_bits {
        constexpr uint32_t ACADD = (19 << 0);  ///< AC97 Command Address.
    }

    /// ACDAT Register bits
    namespace acdat_bits {
        constexpr uint32_t ACDAT = (20 << 0);  ///< AC97 Command Data.
    }

    /// ATAG Register bits
    namespace atag_bits {
        constexpr uint32_t ATAG = (16 << 0);  ///< AC97 Tag Value.
    }

    /// TMSK Register bits
    namespace tmsk_bits {
        constexpr uint32_t TMSK = (32 << 0);  ///< Transmit Mask.
    }

    /// RMSK Register bits
    namespace rmsk_bits {
        constexpr uint32_t RMSK = (32 << 0);  ///< Receive Mask.
    }

    /// ACCST Register bits
    namespace accst_bits {
        constexpr uint32_t ACCST = (10 << 0);  ///< AC97 Channel Status.
    }

    /// ACCEN Register bits
    namespace accen_bits {
        constexpr uint32_t ACCEN = (10 << 0);  ///< AC97 Channel Enable.
    }

    /// ACCDIS Register bits
    namespace accdis_bits {
        constexpr uint32_t ACCDIS = (10 << 0);  ///< AC97 Channel Disable.
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC;  ///< Offset: 0x00 - CRC Data Register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial Register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control Register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCH stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low polynominal half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High polynominal half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< no description available
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC data register as seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read of CRC data register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type of Transpose for Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type of Transpose for Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1 (renamed from CHC1)
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register (renamed from CHS)
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register (renamed from CHDLY0)
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register (renamed from CHDLY1)
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control Register (renamed from DACINTC)
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n Register (renamed from DACINT)
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus.
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT_ = (16 << 0);  ///< DAC Interval (renamed from INT_)
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value Bits
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable Bit.
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable Bit.
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag.
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x400B8000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture and Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State for Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function for Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< no description available
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< no description available
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize the Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum loading point enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum loading point enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels for n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement of Channel (n) for n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable for n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures for n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable for n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable for n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable for n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels for n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement of Channel (n) for n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable for n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures for n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable for n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable for n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable for n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels for n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement of Channel (n) for n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable for n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures for n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable for n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable for n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable for n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels for n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable for n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures for n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable for n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable for n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable for n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction in Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global time base output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN register synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL register synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL register synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< no description available
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< no description available
        constexpr uint32_t SWOM = (1U << 10);  ///< no description available
        constexpr uint32_t SWINVC = (1U << 11);  ///< no description available
        constexpr uint32_t SWSOC = (1U << 12);  ///< no description available
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< no description available
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< no description available
        constexpr uint32_t HWOM = (1U << 18);  ///< no description available
        constexpr uint32_t HWINVC = (1U << 19);  ///< no description available
        constexpr uint32_t HWSOC = (1U << 20);  ///< no description available
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x400BB000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC status and control registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC configuration register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - Configuration register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC data result register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare value registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and control register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and control register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC offset correction register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC plus-side gain register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC minus-side gain register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC plus-side general calibration value register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC plus-side general calibration value register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC plus-side general calibration value register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC plus-side general calibration value register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC plus-side general calibration value register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC plus-side general calibration value register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC plus-side general calibration value register
        volatile uint32_t PGA;  ///< Offset: 0x50 - ADC PGA register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC minus-side general calibration value register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC minus-side general calibration value register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC minus-side general calibration value register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC minus-side general calibration value register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC minus-side general calibration value register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC minus-side general calibration value register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC minus-side general calibration value register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential mode enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion complete flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input clock select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample time configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock divide select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-power configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long sample time select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High speed configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous clock output enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare value
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage reference selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare function range enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare function greater than enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare function enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion trigger select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware average select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware average enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous conversion enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration failed flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset error correction value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-side gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-side gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< no description available
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< no description available
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< no description available
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< no description available
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< no description available
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< no description available
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< no description available
    }

    /// PGA Register bits
    namespace pga_bits {
        constexpr uint32_t PGAG = (4 << 16);  ///< PGA gain setting
        constexpr uint32_t PGALPb = (1U << 20);  ///< PGA low-power mode control
        constexpr uint32_t PGAEN = (1U << 23);  ///< PGA enable
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< no description available
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< no description available
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< no description available
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< no description available
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< no description available
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< no description available
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< no description available
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF load configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF load configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF load configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF load configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< no description available
        constexpr uint32_t LH = (8 << 8);  ///< no description available
        constexpr uint32_t HL = (8 << 16);  ///< no description available
        constexpr uint32_t HH = (8 << 24);  ///< no description available
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - General Control and Status Register
        volatile uint32_t SCANC;  ///< Offset: 0x04 - SCAN control register
        volatile uint32_t PEN;  ///< Offset: 0x08 - Pin enable register
        volatile uint32_t STATUS;  ///< Offset: 0x0C - Status Register
        volatile uint32_t CNTR;  ///< Offset: 0x100 - Counter Register (renamed from CNTR)
        volatile uint32_t THRESHLD;  ///< Offset: 0x120 - Channel n threshold register (renamed from THRESHLD)
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t STPE = (1U << 0);  ///< no description available
        constexpr uint32_t STM = (1U << 1);  ///< Scan trigger mode
        constexpr uint32_t ESOR = (1U << 4);  ///< End-of-scan or out-of-range interrupt select
        constexpr uint32_t ERIE = (1U << 5);  ///< TSI error interrupt Enable
        constexpr uint32_t TSIIE = (1U << 6);  ///< TSI interrupt enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< TSI module enable
        constexpr uint32_t SWTS = (1U << 8);  ///< Software trigger start
        constexpr uint32_t SCNIP = (1U << 9);  ///< Scan-in-progress status
        constexpr uint32_t OVRF = (1U << 12);  ///< Overrun error flag
        constexpr uint32_t EXTERF = (1U << 13);  ///< External electrode error occurred
        constexpr uint32_t OUTRGF = (1U << 14);  ///< Out of Range Flag
        constexpr uint32_t EOSF = (1U << 15);  ///< End of scan flag
        constexpr uint32_t PS = (3 << 16);  ///< Electrode oscillator prescaler
        constexpr uint32_t NSCN = (5 << 19);  ///< Number of Consecutive Scans per Electrode
        constexpr uint32_t LPSCNITV = (4 << 24);  ///< TSI Low Power Mode Scan Interval
        constexpr uint32_t LPCLKS = (1U << 28);  ///< Low Power Mode Clock Source Selection
    }

    /// SCANC Register bits
    namespace scanc_bits {
        constexpr uint32_t AMPSC = (3 << 0);  ///< Active mode prescaler
        constexpr uint32_t AMCLKS = (2 << 3);  ///< Active mode clock source
        constexpr uint32_t AMCLKDIV = (1U << 5);  ///< Active mode clock divider
        constexpr uint32_t SMOD = (8 << 8);  ///< Scan modulo
        constexpr uint32_t DELVOL = (3 << 16);  ///< Delta voltage select applied to analog oscillators
        constexpr uint32_t EXTCHRG = (5 << 19);  ///< External oscillator charge current select
        constexpr uint32_t CAPTRM = (3 << 24);  ///< Internal capacitance trim value
        constexpr uint32_t REFCHRG = (5 << 27);  ///< Reference oscillator charge current select
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN0 = (1U << 0);  ///< TSI pin 0 enable
        constexpr uint32_t PEN1 = (1U << 1);  ///< TSI pin 1 enable
        constexpr uint32_t PEN2 = (1U << 2);  ///< TSI pin 2 enable
        constexpr uint32_t PEN3 = (1U << 3);  ///< TSI pin 3 enable
        constexpr uint32_t PEN4 = (1U << 4);  ///< TSI pin 4 enable
        constexpr uint32_t PEN5 = (1U << 5);  ///< TSI pin 5 enable
        constexpr uint32_t PEN6 = (1U << 6);  ///< TSI pin 6 enable
        constexpr uint32_t PEN7 = (1U << 7);  ///< TSI pin 7 enable
        constexpr uint32_t PEN8 = (1U << 8);  ///< TSI pin 8 enable
        constexpr uint32_t PEN9 = (1U << 9);  ///< TSI pin 9 enable
        constexpr uint32_t PEN10 = (1U << 10);  ///< TSI pin 10 enable
        constexpr uint32_t PEN11 = (1U << 11);  ///< TSI pin 11 enable
        constexpr uint32_t PEN12 = (1U << 12);  ///< TSI pin 12 enable
        constexpr uint32_t PEN13 = (1U << 13);  ///< TSI pin 13 enable
        constexpr uint32_t PEN14 = (1U << 14);  ///< TSI pin 14 enable
        constexpr uint32_t PEN15 = (1U << 15);  ///< TSI pin 15 enable
        constexpr uint32_t LPSP = (4 << 16);  ///< Low-power scan pin
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t ORNGF0 = (1U << 0);  ///< Touch Sensing Electrode Out-of-Range Flag 0
        constexpr uint32_t ORNGF1 = (1U << 1);  ///< Touch Sensing Electrode Out-of-Range Flag 1
        constexpr uint32_t ORNGF2 = (1U << 2);  ///< Touch Sensing Electrode Out-of-Range Flag 2
        constexpr uint32_t ORNGF3 = (1U << 3);  ///< Touch Sensing Electrode Out-of-Range Flag 3
        constexpr uint32_t ORNGF4 = (1U << 4);  ///< Touch Sensing Electrode Out-of-Range Flag 4
        constexpr uint32_t ORNGF5 = (1U << 5);  ///< Touch Sensing Electrode Out-of-Range Flag 5
        constexpr uint32_t ORNGF6 = (1U << 6);  ///< Touch Sensing Electrode Out-of-Range Flag 6
        constexpr uint32_t ORNGF7 = (1U << 7);  ///< Touch Sensing Electrode Out-of-Range Flag 7
        constexpr uint32_t ORNGF8 = (1U << 8);  ///< Touch Sensing Electrode Out-of-Range Flag 8
        constexpr uint32_t ORNGF9 = (1U << 9);  ///< Touch Sensing Electrode Out-of-Range Flag 9
        constexpr uint32_t ORNGF10 = (1U << 10);  ///< Touch Sensing Electrode Out-of-Range Flag 10
        constexpr uint32_t ORNGF11 = (1U << 11);  ///< Touch Sensing Electrode Out-of-Range Flag 11
        constexpr uint32_t ORNGF12 = (1U << 12);  ///< Touch Sensing Electrode Out-of-Range Flag 12
        constexpr uint32_t ORNGF13 = (1U << 13);  ///< Touch Sensing Electrode Out-of-Range Flag 13
        constexpr uint32_t ORNGF14 = (1U << 14);  ///< Touch Sensing Electrode Out-of-Range Flag 14
        constexpr uint32_t ORNGF15 = (1U << 15);  ///< Touch Sensing Electrode Out-of-Range Flag 15
        constexpr uint32_t ERROF0 = (1U << 16);  ///< TouchSensing Error Flag 0
        constexpr uint32_t ERROF1 = (1U << 17);  ///< TouchSensing Error Flag 1
        constexpr uint32_t ERROF2 = (1U << 18);  ///< TouchSensing Error Flag 2
        constexpr uint32_t ERROF3 = (1U << 19);  ///< TouchSensing Error Flag 3
        constexpr uint32_t ERROF4 = (1U << 20);  ///< TouchSensing Error Flag 4
        constexpr uint32_t ERROF5 = (1U << 21);  ///< TouchSensing Error Flag 5
        constexpr uint32_t ERROF6 = (1U << 22);  ///< TouchSensing Error Flag 6
        constexpr uint32_t ERROF7 = (1U << 23);  ///< TouchSensing Error Flag 7
        constexpr uint32_t ERROF8 = (1U << 24);  ///< TouchSensing Error Flag 8
        constexpr uint32_t ERROF9 = (1U << 25);  ///< TouchSensing Error Flag 9
        constexpr uint32_t ERROF10 = (1U << 26);  ///< TouchSensing Error Flag 10
        constexpr uint32_t ERROF11 = (1U << 27);  ///< TouchSensing Error Flag 11
        constexpr uint32_t ERROF12 = (1U << 28);  ///< TouchSensing Error Flag 12
        constexpr uint32_t ERROF13 = (1U << 29);  ///< TouchSensing Error Flag 13
        constexpr uint32_t ERROF14 = (1U << 30);  ///< TouchSensing Error Flag 14
        constexpr uint32_t ERROF15 = (1U << 31);  ///< TouchSensing Error Flag 15
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t CTN1 = (16 << 0);  ///< Touch sensing channel n-1 counter value.
        constexpr uint32_t CTN = (16 << 16);  ///< Touch sensing channel n counter value.
    }

    /// THRESHLD Register bits
    namespace threshld_bits {
        constexpr uint32_t HTHH = (16 << 0);  ///< High threshold value
        constexpr uint32_t LTHH = (16 << 16);  ///< Low threshold value
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT6;  ///< Offset: 0x1014 - System Options Register 6
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (1U << 19);  ///< 32K oscillator clock select
        constexpr uint32_t MS = (1U << 23);  ///< EzPort chip select pin state
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t MCGCLKSEL = (1U << 0);  ///< MCG clock select
        constexpr uint32_t FBSL = (2 << 8);  ///< FlexBus security level
        constexpr uint32_t CMTUARTPAD = (1U << 11);  ///< CMT/UART pad drive strength
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (1U << 16);  ///< PLL/FLL clock select
        constexpr uint32_t I2SSRC = (2 << 24);  ///< I2S master clock source select
        constexpr uint32_t SDHCSRC = (2 << 28);  ///< SDHC clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FTM0 Fault 2 Select
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FTM2 Fault 0 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 20);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 External Clock Pin Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UARTTXSRC = (2 << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
    }

    /// SOPT6 Register bits
    namespace sopt6_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 24);  ///< Reset pin filter select
        constexpr uint32_t RSTFLTEN = (3 << 29);  ///< Reset pin filter enable
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
        constexpr uint32_t ADC1TRGSEL = (4 << 8);  ///< ADC1 trigger select
        constexpr uint32_t ADC1PRETRGSEL = (1U << 12);  ///< ADC1 pre-trigger select
        constexpr uint32_t ADC1ALTTRGEN = (1U << 15);  ///< ADC1 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t UART4 = (1U << 10);  ///< UART4 Clock Gate Control
        constexpr uint32_t UART5 = (1U << 11);  ///< UART5 Clock Gate Control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t DAC0 = (1U << 12);  ///< DAC0 Clock Gate Control
        constexpr uint32_t DAC1 = (1U << 13);  ///< DAC1 Clock Gate Control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t FLEXCAN1 = (1U << 4);  ///< FlexCAN1 Clock Gate Control
        constexpr uint32_t SPI2 = (1U << 12);  ///< SPI2 Clock Gate Control
        constexpr uint32_t SDHC = (1U << 17);  ///< SDHC Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 24);  ///< FTM2 Clock Gate Control
        constexpr uint32_t ADC1 = (1U << 27);  ///< ADC1 Clock Gate Control
        constexpr uint32_t SLCD = (1U << 30);  ///< Segment LCD Clock Gate Control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
        constexpr uint32_t LLWU = (1U << 28);  ///< LLWU Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTIMER = (1U << 0);  ///< Low Power Timer Clock Gate Control
        constexpr uint32_t REGFILE = (1U << 1);  ///< Register File Clock Gate Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Clock Gate Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTFL = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t FLEXCAN0 = (1U << 4);  ///< FlexCAN0 Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t I2SFRAC = (8 << 8);  ///< I2S clock divider fraction
        constexpr uint32_t I2SDIV = (12 << 20);  ///< I2S clock divider value
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t DEPART = (4 << 8);  ///< FlexNVM partition
        constexpr uint32_t EESIZE = (4 << 16);  ///< EEPROM size
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (6 << 16);  ///< Max address block 1
        constexpr uint32_t PFLSH = (1U << 23);  ///< Program flash
        constexpr uint32_t MAXADDR0 = (6 << 24);  ///< Max address block 0
        constexpr uint32_t SWAPPFLSH = (1U << 31);  ///< Swap program flash
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR;  ///< Offset: 0x00 - Pin Control Register n (renamed from PCR)
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);

    // Bit definitions
    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh Register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock Register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count Register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler Register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< no description available
        constexpr uint32_t CLKSRC = (1U << 1);  ///< no description available
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< no description available
        constexpr uint32_t WINEN = (1U << 3);  ///< no description available
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< no description available
        constexpr uint32_t DBGEN = (1U << 5);  ///< no description available
        constexpr uint32_t STOPEN = (1U << 6);  ///< no description available
        constexpr uint32_t WAITEN = (1U << 7);  ///< no description available
        constexpr uint32_t STNDBYEN = (1U << 8);  ///< no description available
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< no description available
        constexpr uint32_t TESTSEL = (1U << 11);  ///< no description available
        constexpr uint32_t BYTESEL = (2 << 12);  ///< no description available
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< no description available
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< no description available
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< no description available
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< no description available
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< no description available
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< no description available
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< no description available
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< no description available
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< no description available
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< no description available
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< no description available
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< no description available
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< no description available
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< no description available
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< no description available
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< no description available
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t ATC;  ///< Offset: 0x08 - MCG Auto Trim Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV = (5 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV = (5 << 0);  ///< VCO Divider
        constexpr uint32_t CME = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS = (1U << 7);  ///< Loss of Lock Status
    }

    /// ATC Register bits
    namespace atc_bits {
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status Register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< Clock rate
        constexpr uint32_t MULT = (2 << 6);  ///< no description available
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit acknowledge enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit mode select
        constexpr uint32_t MST = (1U << 5);  ///< Master mode select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C interrupt enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave read/write
        constexpr uint32_t RAM = (1U << 3);  ///< Range address match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed as a slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer complete flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range address matching enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave baud rate control
        constexpr uint32_t HDRS = (1U << 5);  ///< High drive select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General call address enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (5 << 0);  ///< I2C programmable filter factor
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range slave address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 interrupt enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL high timeout flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL high timeout flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL low timeout flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout counter clock select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C address enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus alert response address enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< no description available
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;
    constexpr uint32_t UART4_BASE = 0x400EA000;
    constexpr uint32_t UART5_BASE = 0x400EB000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers:High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816T0;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WP7816T1;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 3);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< no description available
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< no description available
        constexpr uint32_t NOISY = (1U << 7);  ///< no description available
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816T0 Register bits
    namespace wp7816t0_bits {
        constexpr uint32_t WI = (8 << 0);  ///< Wait Timer Interrupt (C7816[TTYPE] = 0)
    }

    /// WP7816T1 Register bits
    namespace wp7816t1_bits {
        constexpr uint32_t BWI = (4 << 0);  ///< Block Wait Time Integer(C7816[TTYPE] = 1)
        constexpr uint32_t CWI = (4 << 4);  ///< Character Wait Time Integer (C7816[TTYPE] = 1)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t SMELB = (1U << 5);  ///< Stop Mode Edge/Level Interrupt Control
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t MEN = (1U << 6);  ///< MMUX Enable
        constexpr uint32_t PEN = (1U << 7);  ///< PMUX Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t SMELB = (1U << 5);  ///< Stop Mode Edge/Level Interrupt Control
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t MEN = (1U << 6);  ///< MMUX Enable
        constexpr uint32_t PEN = (1U << 7);  ///< PMUX Enable
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40073010;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t SMELB = (1U << 5);  ///< Stop Mode Edge/Level Interrupt Control
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input MUX Control
        constexpr uint32_t MEN = (1U << 6);  ///< MMUX Enable
        constexpr uint32_t PEN = (1U << 7);  ///< PMUX Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference has settled
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 Register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 Register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 Register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 Register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable Register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 Register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 Register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 Register
        volatile uint32_t CS;  ///< Offset: 0x08 - LLWU Control and Status Register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable for LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable for LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable for LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable for LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable for Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable for Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable for Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable for Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable for Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable for Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable for Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag for LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag for LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag for LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag for LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag for LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag for LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag for LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag for LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag for LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag for LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag for LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag for LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag for LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag for LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag for LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag for LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag for module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag for module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag for module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag for module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag for module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag for module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag for module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag for module 7 (Error Detect)
    }

    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t FLTR = (1U << 0);  ///< Digital Filter on RESET Pin
        constexpr uint32_t FLTEP = (1U << 1);  ///< Digital Filter on External Pin
        constexpr uint32_t ACKISO = (1U << 7);  ///< Acknowledge Isolation
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status and Control 1 Register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status and Control 2 Register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status and Control Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator in Run Regulation Status
        constexpr uint32_t VLPRS = (1U << 3);  ///< Very Low Power Run Status
        constexpr uint32_t TRAMPO = (1U << 4);  ///< For devices with FlexNVM: Traditional RAM Power Option For devices with program flash only: Reserved
    }

}

// ============================================================================
// MC Peripheral
// ============================================================================

namespace mc {
    /// Base addresses
    constexpr uint32_t MC_BASE = 0x4007E000;

    /// MC Register structure
    struct Registers {
        volatile uint32_t SRSH;  ///< Offset: 0x00 - System Reset Status Register High
        volatile uint32_t SRSL;  ///< Offset: 0x01 - System Reset Status Register Low
        volatile uint32_t PMPROT;  ///< Offset: 0x02 - Power Mode Protection Register
        volatile uint32_t PMCTRL;  ///< Offset: 0x03 - Power Mode Control Register
    };

    /// Peripheral instances
    inline Registers* MC = reinterpret_cast<Registers*>(MC_BASE);

    // Bit definitions
    /// SRSH Register bits
    namespace srsh_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG generated reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lock-up
        constexpr uint32_t SW = (1U << 2);  ///< Software
    }

    /// SRSL Register bits
    namespace srsl_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low-leakage wakeup reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-voltage detect reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-clock reset
        constexpr uint32_t COP = (1U << 5);  ///< Computer Operating Properly (COP) Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External reset pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-on reset
    }

    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS1 = (1U << 0);  ///< Allow very low leakage stop 1 mode
        constexpr uint32_t AVLLS2 = (1U << 1);  ///< Allow very low leakage stop 2 mode
        constexpr uint32_t AVLLS3 = (1U << 2);  ///< Allow Very Low Leakage Stop 3 Mode
        constexpr uint32_t ALLS = (1U << 4);  ///< Allow low leakage stop mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow very low power modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t LPLLSM = (3 << 0);  ///< Low Power, Low Leakage Stop Mode
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Enable
        constexpr uint32_t LPWUI = (1U << 7);  ///< Low Power Wake Up on Interrupt
    }

}

// ============================================================================
// SDHC Peripheral
// ============================================================================

namespace sdhc {
    /// Base addresses
    constexpr uint32_t SDHC_BASE = 0x400B1000;

    /// SDHC Register structure
    struct Registers {
        volatile uint32_t DSADDR;  ///< Offset: 0x00 - DMA System Address Register
        volatile uint32_t BLKATTR;  ///< Offset: 0x04 - Block Attributes Register
        volatile uint32_t CMDARG;  ///< Offset: 0x08 - Command Argument Register
        volatile uint32_t XFERTYP;  ///< Offset: 0x0C - Transfer Type Register
        volatile uint32_t CMDRSP0;  ///< Offset: 0x10 - Command Response 0
        volatile uint32_t CMDRSP1;  ///< Offset: 0x14 - Command Response 1
        volatile uint32_t CMDRSP2;  ///< Offset: 0x18 - Command Response 2
        volatile uint32_t CMDRSP3;  ///< Offset: 0x1C - Command Response 3
        volatile uint32_t DATPORT;  ///< Offset: 0x20 - Buffer Data Port Register
        volatile uint32_t PRSSTAT;  ///< Offset: 0x24 - Present State Register
        volatile uint32_t PROCTL;  ///< Offset: 0x28 - Protocol Control Register
        volatile uint32_t SYSCTL;  ///< Offset: 0x2C - System Control Register
        volatile uint32_t IRQSTAT;  ///< Offset: 0x30 - Interrupt Status Register
        volatile uint32_t IRQSTATEN;  ///< Offset: 0x34 - Interrupt Status Enable Register
        volatile uint32_t IRQSIGEN;  ///< Offset: 0x38 - Interrupt Signal Enable Register
        volatile uint32_t AC12ERR;  ///< Offset: 0x3C - Auto CMD12 Error Status Register
        volatile uint32_t HTCAPBLT;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WML;  ///< Offset: 0x44 - Watermark Level Register
        volatile uint32_t FEVT;  ///< Offset: 0x50 - Force Event Register
        volatile uint32_t ADMAES;  ///< Offset: 0x54 - ADMA Error Status Register
        volatile uint32_t ADSADDR;  ///< Offset: 0x58 - ADMA System Address Register
        volatile uint32_t VENDOR;  ///< Offset: 0xC0 - Vendor Specific Register
        volatile uint32_t MMCBOOT;  ///< Offset: 0xC4 - MMC Boot Register
        volatile uint32_t HOSTVER;  ///< Offset: 0xFC - Host Controller Version
    };

    /// Peripheral instances
    inline Registers* SDHC = reinterpret_cast<Registers*>(SDHC_BASE);

    // Bit definitions
    /// DSADDR Register bits
    namespace dsaddr_bits {
        constexpr uint32_t DSADDR = (30 << 2);  ///< DMA System Address
    }

    /// BLKATTR Register bits
    namespace blkattr_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Transfer Block Size
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Blocks Count For Current Transfer
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// XFERTYP Register bits
    namespace xfertyp_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Select
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMDRSP0 Register bits
    namespace cmdrsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMDRSP1 Register bits
    namespace cmdrsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMDRSP2 Register bits
    namespace cmdrsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMDRSP3 Register bits
    namespace cmdrsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATPORT Register bits
    namespace datport_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRSSTAT Register bits
    namespace prsstat_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< Bus Clock Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< System Clock Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< SDHC clock Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t CINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DAT Line Signal Level
    }

    /// PROCTL Register bits
    namespace proctl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DAT3 as Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMAS = (2 << 8);  ///< DMA Select
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
    }

    /// SYSCTL Register bits
    namespace sysctl_bits {
        constexpr uint32_t IPGEN = (1U << 0);  ///< IPG Clock Enable
        constexpr uint32_t HCKEN = (1U << 1);  ///< System Clock Enable
        constexpr uint32_t PEREN = (1U << 2);  ///< Peripheral Clock Enable
        constexpr uint32_t SDCLKEN = (1U << 3);  ///< SD Clock Enable
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DAT Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
    }

    /// IRQSTAT Register bits
    namespace irqstat_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// IRQSTATEN Register bits
    namespace irqstaten_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// IRQSIGEN Register bits
    namespace irqsigen_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Enable
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AC12ERR Register bits
    namespace ac12err_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
    }

    /// HTCAPBLT Register bits
    namespace htcapblt_bits {
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3 V
        constexpr uint32_t VS30 = (1U << 25);  ///< Voltage Support 3.0 V
        constexpr uint32_t VS18 = (1U << 26);  ///< Voltage Support 1.8 V
    }

    /// WML Register bits
    namespace wml_bits {
        constexpr uint32_t RDWML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t WRWML = (8 << 16);  ///< Write Watermark Level
        constexpr uint32_t WRBRSTLEN = (5 << 24);  ///< no description available
    }

    /// FEVT Register bits
    namespace fevt_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t AC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t AC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t CTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t CCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t DCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t CINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMAES Register bits
    namespace admaes_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (when ADMA Error is occurred.)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descritor Error
    }

    /// ADSADDR Register bits
    namespace adsaddr_bits {
        constexpr uint32_t ADSADDR = (30 << 2);  ///< ADMA System Address
    }

    /// VENDOR Register bits
    namespace vendor_bits {
        constexpr uint32_t EXTDMAEN = (1U << 0);  ///< External DMA Request Enable
        constexpr uint32_t EXBLKNU = (1U << 1);  ///< Exact block number block read enable for SDIO CMD53
        constexpr uint32_t INTSTVAL = (8 << 16);  ///< Internal State Value
    }

    /// MMCBOOT Register bits
    namespace mmcboot_bits {
        constexpr uint32_t DTOCVACK = (4 << 0);  ///< Boot ACK time out counter value.
        constexpr uint32_t BOOTACK = (1U << 4);  ///< Boot ack mode select
        constexpr uint32_t BOOTMODE = (1U << 5);  ///< Boot mode select
        constexpr uint32_t BOOTEN = (1U << 6);  ///< Boot mode enable
        constexpr uint32_t AUTOSABGEN = (1U << 7);  ///< no description available
        constexpr uint32_t BOOTBLKCNT = (16 << 16);  ///< no description available
    }

    /// HOSTVER Register bits
    namespace hostver_bits {
        constexpr uint32_t SVN = (8 << 0);  ///< Specification Version Number
        constexpr uint32_t VVN = (8 << 8);  ///< Vendor Version Number
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x400BE000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - LCD general control register
        volatile uint32_t AR;  ///< Offset: 0x04 - LCD auxiliary register
        volatile uint32_t FDCR;  ///< Offset: 0x08 - LCD fault detect control register
        volatile uint32_t FDSR;  ///< Offset: 0x0C - LCD fault detect status register
        volatile uint32_t PEN;  ///< Offset: 0x10 - LCD pin enable register (renamed from PEN)
        volatile uint32_t BPEN;  ///< Offset: 0x18 - LCD backplane enable register (renamed from BPEN)
        volatile uint32_t WF3TO0;  ///< Offset: 0x20 - LCD waveform register
        volatile uint32_t WF0;  ///< Offset: 0x20 - LCD Waveform Register 0.
        volatile uint32_t WF1;  ///< Offset: 0x21 - LCD Waveform Register 1.
        volatile uint32_t WF2;  ///< Offset: 0x22 - LCD Waveform Register 2.
        volatile uint32_t WF3;  ///< Offset: 0x23 - LCD Waveform Register 3.
        volatile uint32_t WF7TO4;  ///< Offset: 0x24 - LCD waveform register
        volatile uint32_t WF4;  ///< Offset: 0x24 - LCD Waveform Register 4.
        volatile uint32_t WF5;  ///< Offset: 0x25 - LCD Waveform Register 5.
        volatile uint32_t WF6;  ///< Offset: 0x26 - LCD Waveform Register 6.
        volatile uint32_t WF7;  ///< Offset: 0x27 - LCD Waveform Register 7.
        volatile uint32_t WF11TO8;  ///< Offset: 0x28 - LCD waveform register
        volatile uint32_t WF8;  ///< Offset: 0x28 - LCD Waveform Register 8.
        volatile uint32_t WF9;  ///< Offset: 0x29 - LCD Waveform Register 9.
        volatile uint32_t WF10;  ///< Offset: 0x2A - LCD Waveform Register 10.
        volatile uint32_t WF11;  ///< Offset: 0x2B - LCD Waveform Register 11.
        volatile uint32_t WF15TO12;  ///< Offset: 0x2C - LCD waveform register
        volatile uint32_t WF12;  ///< Offset: 0x2C - LCD Waveform Register 12.
        volatile uint32_t WF13;  ///< Offset: 0x2D - LCD Waveform Register 13.
        volatile uint32_t WF14;  ///< Offset: 0x2E - LCD Waveform Register 14.
        volatile uint32_t WF15;  ///< Offset: 0x2F - LCD Waveform Register 15.
        volatile uint32_t WF19TO16;  ///< Offset: 0x30 - LCD waveform register
        volatile uint32_t WF16;  ///< Offset: 0x30 - LCD Waveform Register 16.
        volatile uint32_t WF17;  ///< Offset: 0x31 - LCD Waveform Register 17.
        volatile uint32_t WF18;  ///< Offset: 0x32 - LCD Waveform Register 18.
        volatile uint32_t WF19;  ///< Offset: 0x33 - LCD Waveform Register 19.
        volatile uint32_t WF23TO20;  ///< Offset: 0x34 - LCD waveform register
        volatile uint32_t WF20;  ///< Offset: 0x34 - LCD Waveform Register 20.
        volatile uint32_t WF21;  ///< Offset: 0x35 - LCD Waveform Register 21.
        volatile uint32_t WF22;  ///< Offset: 0x36 - LCD Waveform Register 22.
        volatile uint32_t WF23;  ///< Offset: 0x37 - LCD Waveform Register 23.
        volatile uint32_t WF27TO24;  ///< Offset: 0x38 - LCD waveform register
        volatile uint32_t WF24;  ///< Offset: 0x38 - LCD Waveform Register 24.
        volatile uint32_t WF25;  ///< Offset: 0x39 - LCD Waveform Register 25.
        volatile uint32_t WF26;  ///< Offset: 0x3A - LCD Waveform Register 26.
        volatile uint32_t WF27;  ///< Offset: 0x3B - LCD Waveform Register 27.
        volatile uint32_t WF31TO28;  ///< Offset: 0x3C - LCD waveform register
        volatile uint32_t WF28;  ///< Offset: 0x3C - LCD Waveform Register 28.
        volatile uint32_t WF29;  ///< Offset: 0x3D - LCD Waveform Register 29.
        volatile uint32_t WF30;  ///< Offset: 0x3E - LCD Waveform Register 30.
        volatile uint32_t WF31;  ///< Offset: 0x3F - LCD Waveform Register 31.
        volatile uint32_t WF35TO32;  ///< Offset: 0x40 - LCD waveform register
        volatile uint32_t WF32;  ///< Offset: 0x40 - LCD Waveform Register 32.
        volatile uint32_t WF33;  ///< Offset: 0x41 - LCD Waveform Register 33.
        volatile uint32_t WF34;  ///< Offset: 0x42 - LCD Waveform Register 34.
        volatile uint32_t WF35;  ///< Offset: 0x43 - LCD Waveform Register 35.
        volatile uint32_t WF39TO36;  ///< Offset: 0x44 - LCD waveform register
        volatile uint32_t WF36;  ///< Offset: 0x44 - LCD Waveform Register 36.
        volatile uint32_t WF37;  ///< Offset: 0x45 - LCD Waveform Register 37.
        volatile uint32_t WF38;  ///< Offset: 0x46 - LCD Waveform Register 38.
        volatile uint32_t WF39;  ///< Offset: 0x47 - LCD Waveform Register 39.
        volatile uint32_t WF43TO40;  ///< Offset: 0x48 - LCD waveform register
        volatile uint32_t WF40;  ///< Offset: 0x48 - LCD Waveform Register 40.
        volatile uint32_t WF41;  ///< Offset: 0x49 - LCD Waveform Register 41.
        volatile uint32_t WF42;  ///< Offset: 0x4A - LCD Waveform Register 42.
        volatile uint32_t WF43;  ///< Offset: 0x4B - LCD Waveform Register 43.
        volatile uint32_t WF47TO44;  ///< Offset: 0x4C - LCD waveform register
        volatile uint32_t WF44;  ///< Offset: 0x4C - LCD Waveform Register 44.
        volatile uint32_t WF45;  ///< Offset: 0x4D - LCD Waveform Register 45.
        volatile uint32_t WF46;  ///< Offset: 0x4E - LCD Waveform Register 46.
        volatile uint32_t WF47;  ///< Offset: 0x4F - LCD Waveform Register 47.
        volatile uint32_t WF51TO48;  ///< Offset: 0x50 - LCD waveform register
        volatile uint32_t WF48;  ///< Offset: 0x50 - LCD Waveform Register 48.
        volatile uint32_t WF49;  ///< Offset: 0x51 - LCD Waveform Register 49.
        volatile uint32_t WF50;  ///< Offset: 0x52 - LCD Waveform Register 50.
        volatile uint32_t WF51;  ///< Offset: 0x53 - LCD Waveform Register 51.
        volatile uint32_t WF55TO52;  ///< Offset: 0x54 - LCD waveform register
        volatile uint32_t WF52;  ///< Offset: 0x54 - LCD Waveform Register 52.
        volatile uint32_t WF53;  ///< Offset: 0x55 - LCD Waveform Register 53.
        volatile uint32_t WF54;  ///< Offset: 0x56 - LCD Waveform Register 54.
        volatile uint32_t WF55;  ///< Offset: 0x57 - LCD Waveform Register 55.
        volatile uint32_t WF59TO56;  ///< Offset: 0x58 - LCD waveform register
        volatile uint32_t WF56;  ///< Offset: 0x58 - LCD Waveform Register 56.
        volatile uint32_t WF57;  ///< Offset: 0x59 - LCD Waveform Register 57.
        volatile uint32_t WF58;  ///< Offset: 0x5A - LCD Waveform Register 58.
        volatile uint32_t WF59;  ///< Offset: 0x5B - LCD Waveform Register 59.
        volatile uint32_t WF63TO60;  ///< Offset: 0x5C - LCD waveform register
        volatile uint32_t WF60;  ///< Offset: 0x5C - LCD Waveform Register 60.
        volatile uint32_t WF61;  ///< Offset: 0x5D - LCD Waveform Register 61.
        volatile uint32_t WF62;  ///< Offset: 0x5E - LCD Waveform Register 62.
        volatile uint32_t WF63;  ///< Offset: 0x5F - LCD Waveform Register 63.
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t DUTY = (3 << 0);  ///< LCD duty select
        constexpr uint32_t LCLK = (3 << 3);  ///< LCD clock prescaler
        constexpr uint32_t SOURCE = (1U << 6);  ///< LCD clock source select
        constexpr uint32_t LCDEN = (1U << 7);  ///< LCD driver enable
        constexpr uint32_t LCDSTP = (1U << 8);  ///< LCD driver, charge pump, resistor bias network, and voltage regulator while in Stop mode.
        constexpr uint32_t LCDWAIT = (1U << 9);  ///< LCD driver, charge pump, resistor bias network, and voltage regulator stop while in Wait mode.
        constexpr uint32_t ALTDIV = (2 << 12);  ///< LCD alternate clock divider
        constexpr uint32_t FDCIEN = (1U << 14);  ///< LCD fault detection complete interrupt enable
        constexpr uint32_t LCDIEN = (1U << 15);  ///< LCD frame frequency interrupt enable
        constexpr uint32_t VSUPPLY = (2 << 16);  ///< Voltage supply control
        constexpr uint32_t LADJ = (2 << 20);  ///< Load adjust
        constexpr uint32_t HREFSEL = (1U << 22);  ///< High reference select
        constexpr uint32_t CPSEL = (1U << 23);  ///< Charge pump or resistor bias select
        constexpr uint32_t RVTRIM = (4 << 24);  ///< Regulated voltage trim
        constexpr uint32_t RVEN = (1U << 31);  ///< Regulated voltage enable
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t BRATE = (3 << 0);  ///< Blink-rate configuration
        constexpr uint32_t BMODE = (1U << 3);  ///< Blink mode
        constexpr uint32_t BLANK = (1U << 5);  ///< Blank display mode
        constexpr uint32_t ALT = (1U << 6);  ///< Alternate display mode
        constexpr uint32_t BLINK = (1U << 7);  ///< Blink command
        constexpr uint32_t LCDIF = (1U << 15);  ///< LCD frame frequency interrupt flag
    }

    /// FDCR Register bits
    namespace fdcr_bits {
        constexpr uint32_t FDPINID = (6 << 0);  ///< Fault detect pin ID
        constexpr uint32_t FDBPEN = (1U << 6);  ///< Fault detect backplane enable
        constexpr uint32_t FDEN = (1U << 7);  ///< Fault detect enable
        constexpr uint32_t FDSWW = (3 << 9);  ///< Fault detect sample window width
        constexpr uint32_t FDPRS = (3 << 12);  ///< Fault detect clock prescaler
    }

    /// FDSR Register bits
    namespace fdsr_bits {
        constexpr uint32_t FDCNT = (8 << 0);  ///< Fault detect counter
        constexpr uint32_t FDCF = (1U << 15);  ///< Fault detection complete flag
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN = (32 << 0);  ///< LCD pin enable
    }

    /// BPEN Register bits
    namespace bpen_bits {
        constexpr uint32_t BPEN = (32 << 0);  ///< Backplane enable
    }

    /// WF3TO0 Register bits
    namespace wf3to0_bits {
        constexpr uint32_t WF0 = (8 << 0);  ///< no description available
        constexpr uint32_t WF1 = (8 << 8);  ///< no description available
        constexpr uint32_t WF2 = (8 << 16);  ///< no description available
        constexpr uint32_t WF3 = (8 << 24);  ///< no description available
    }

    /// WF0 Register bits
    namespace wf0_bits {
        constexpr uint32_t BPALCD0 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD0 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD0 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD0 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD0 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD0 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD0 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD0 = (1U << 7);  ///< no description available
    }

    /// WF1 Register bits
    namespace wf1_bits {
        constexpr uint32_t BPALCD1 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD1 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD1 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD1 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD1 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD1 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD1 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD1 = (1U << 7);  ///< no description available
    }

    /// WF2 Register bits
    namespace wf2_bits {
        constexpr uint32_t BPALCD2 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD2 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD2 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD2 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD2 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD2 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD2 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD2 = (1U << 7);  ///< no description available
    }

    /// WF3 Register bits
    namespace wf3_bits {
        constexpr uint32_t BPALCD3 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD3 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD3 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD3 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD3 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD3 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD3 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD3 = (1U << 7);  ///< no description available
    }

    /// WF7TO4 Register bits
    namespace wf7to4_bits {
        constexpr uint32_t WF4 = (8 << 0);  ///< no description available
        constexpr uint32_t WF5 = (8 << 8);  ///< no description available
        constexpr uint32_t WF6 = (8 << 16);  ///< no description available
        constexpr uint32_t WF7 = (8 << 24);  ///< no description available
    }

    /// WF4 Register bits
    namespace wf4_bits {
        constexpr uint32_t BPALCD4 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD4 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD4 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD4 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD4 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD4 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD4 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD4 = (1U << 7);  ///< no description available
    }

    /// WF5 Register bits
    namespace wf5_bits {
        constexpr uint32_t BPALCD5 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD5 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD5 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD5 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD5 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD5 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD5 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD5 = (1U << 7);  ///< no description available
    }

    /// WF6 Register bits
    namespace wf6_bits {
        constexpr uint32_t BPALCD6 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD6 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD6 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD6 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD6 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD6 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD6 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD6 = (1U << 7);  ///< no description available
    }

    /// WF7 Register bits
    namespace wf7_bits {
        constexpr uint32_t BPALCD7 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD7 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD7 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD7 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD7 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD7 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD7 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD7 = (1U << 7);  ///< no description available
    }

    /// WF11TO8 Register bits
    namespace wf11to8_bits {
        constexpr uint32_t WF8 = (8 << 0);  ///< no description available
        constexpr uint32_t WF9 = (8 << 8);  ///< no description available
        constexpr uint32_t WF10 = (8 << 16);  ///< no description available
        constexpr uint32_t WF11 = (8 << 24);  ///< no description available
    }

    /// WF8 Register bits
    namespace wf8_bits {
        constexpr uint32_t BPALCD8 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD8 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD8 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD8 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD8 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD8 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD8 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD8 = (1U << 7);  ///< no description available
    }

    /// WF9 Register bits
    namespace wf9_bits {
        constexpr uint32_t BPALCD9 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD9 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD9 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD9 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD9 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD9 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD9 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD9 = (1U << 7);  ///< no description available
    }

    /// WF10 Register bits
    namespace wf10_bits {
        constexpr uint32_t BPALCD10 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD10 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD10 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD10 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD10 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD10 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD10 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD10 = (1U << 7);  ///< no description available
    }

    /// WF11 Register bits
    namespace wf11_bits {
        constexpr uint32_t BPALCD11 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD11 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD11 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD11 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD11 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD11 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD11 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD11 = (1U << 7);  ///< no description available
    }

    /// WF15TO12 Register bits
    namespace wf15to12_bits {
        constexpr uint32_t WF12 = (8 << 0);  ///< no description available
        constexpr uint32_t WF13 = (8 << 8);  ///< no description available
        constexpr uint32_t WF14 = (8 << 16);  ///< no description available
        constexpr uint32_t WF15 = (8 << 24);  ///< no description available
    }

    /// WF12 Register bits
    namespace wf12_bits {
        constexpr uint32_t BPALCD12 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD12 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD12 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD12 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD12 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD12 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD12 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD12 = (1U << 7);  ///< no description available
    }

    /// WF13 Register bits
    namespace wf13_bits {
        constexpr uint32_t BPALCD13 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD13 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD13 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD13 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD13 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD13 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD13 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD13 = (1U << 7);  ///< no description available
    }

    /// WF14 Register bits
    namespace wf14_bits {
        constexpr uint32_t BPALCD14 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD14 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD14 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD14 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD14 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD14 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD14 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD14 = (1U << 7);  ///< no description available
    }

    /// WF15 Register bits
    namespace wf15_bits {
        constexpr uint32_t BPALCD15 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD15 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD15 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD15 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD15 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD15 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD15 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD15 = (1U << 7);  ///< no description available
    }

    /// WF19TO16 Register bits
    namespace wf19to16_bits {
        constexpr uint32_t WF16 = (8 << 0);  ///< no description available
        constexpr uint32_t WF17 = (8 << 8);  ///< no description available
        constexpr uint32_t WF18 = (8 << 16);  ///< no description available
        constexpr uint32_t WF19 = (8 << 24);  ///< no description available
    }

    /// WF16 Register bits
    namespace wf16_bits {
        constexpr uint32_t BPALCD16 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD16 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD16 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD16 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD16 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD16 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD16 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD16 = (1U << 7);  ///< no description available
    }

    /// WF17 Register bits
    namespace wf17_bits {
        constexpr uint32_t BPALCD17 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD17 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD17 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD17 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD17 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD17 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD17 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD17 = (1U << 7);  ///< no description available
    }

    /// WF18 Register bits
    namespace wf18_bits {
        constexpr uint32_t BPALCD18 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD18 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD18 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD18 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD18 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD18 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD18 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD18 = (1U << 7);  ///< no description available
    }

    /// WF19 Register bits
    namespace wf19_bits {
        constexpr uint32_t BPALCD19 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD19 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD19 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD19 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD19 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD19 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD19 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD19 = (1U << 7);  ///< no description available
    }

    /// WF23TO20 Register bits
    namespace wf23to20_bits {
        constexpr uint32_t WF20 = (8 << 0);  ///< no description available
        constexpr uint32_t WF21 = (8 << 8);  ///< no description available
        constexpr uint32_t WF22 = (8 << 16);  ///< no description available
        constexpr uint32_t WF23 = (8 << 24);  ///< no description available
    }

    /// WF20 Register bits
    namespace wf20_bits {
        constexpr uint32_t BPALCD20 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD20 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD20 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD20 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD20 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD20 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD20 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD20 = (1U << 7);  ///< no description available
    }

    /// WF21 Register bits
    namespace wf21_bits {
        constexpr uint32_t BPALCD21 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD21 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD21 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD21 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD21 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD21 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD21 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD21 = (1U << 7);  ///< no description available
    }

    /// WF22 Register bits
    namespace wf22_bits {
        constexpr uint32_t BPALCD22 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD22 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD22 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD22 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD22 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD22 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD22 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD22 = (1U << 7);  ///< no description available
    }

    /// WF23 Register bits
    namespace wf23_bits {
        constexpr uint32_t BPALCD23 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD23 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD23 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD23 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD23 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD23 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD23 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD23 = (1U << 7);  ///< no description available
    }

    /// WF27TO24 Register bits
    namespace wf27to24_bits {
        constexpr uint32_t WF24 = (8 << 0);  ///< no description available
        constexpr uint32_t WF25 = (8 << 8);  ///< no description available
        constexpr uint32_t WF26 = (8 << 16);  ///< no description available
        constexpr uint32_t WF27 = (8 << 24);  ///< no description available
    }

    /// WF24 Register bits
    namespace wf24_bits {
        constexpr uint32_t BPALCD24 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD24 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD24 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD24 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD24 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD24 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD24 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD24 = (1U << 7);  ///< no description available
    }

    /// WF25 Register bits
    namespace wf25_bits {
        constexpr uint32_t BPALCD25 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD25 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD25 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD25 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD25 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD25 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD25 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD25 = (1U << 7);  ///< no description available
    }

    /// WF26 Register bits
    namespace wf26_bits {
        constexpr uint32_t BPALCD26 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD26 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD26 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD26 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD26 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD26 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD26 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD26 = (1U << 7);  ///< no description available
    }

    /// WF27 Register bits
    namespace wf27_bits {
        constexpr uint32_t BPALCD27 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD27 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD27 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD27 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD27 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD27 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD27 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD27 = (1U << 7);  ///< no description available
    }

    /// WF31TO28 Register bits
    namespace wf31to28_bits {
        constexpr uint32_t WF28 = (8 << 0);  ///< no description available
        constexpr uint32_t WF29 = (8 << 8);  ///< no description available
        constexpr uint32_t WF30 = (8 << 16);  ///< no description available
        constexpr uint32_t WF31 = (8 << 24);  ///< no description available
    }

    /// WF28 Register bits
    namespace wf28_bits {
        constexpr uint32_t BPALCD28 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD28 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD28 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD28 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD28 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD28 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD28 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD28 = (1U << 7);  ///< no description available
    }

    /// WF29 Register bits
    namespace wf29_bits {
        constexpr uint32_t BPALCD29 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD29 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD29 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD29 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD29 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD29 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD29 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD29 = (1U << 7);  ///< no description available
    }

    /// WF30 Register bits
    namespace wf30_bits {
        constexpr uint32_t BPALCD30 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD30 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD30 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD30 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD30 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD30 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD30 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD30 = (1U << 7);  ///< no description available
    }

    /// WF31 Register bits
    namespace wf31_bits {
        constexpr uint32_t BPALCD31 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD31 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD31 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD31 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD31 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD31 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD31 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD31 = (1U << 7);  ///< no description available
    }

    /// WF35TO32 Register bits
    namespace wf35to32_bits {
        constexpr uint32_t WF32 = (8 << 0);  ///< no description available
        constexpr uint32_t WF33 = (8 << 8);  ///< no description available
        constexpr uint32_t WF34 = (8 << 16);  ///< no description available
        constexpr uint32_t WF35 = (8 << 24);  ///< no description available
    }

    /// WF32 Register bits
    namespace wf32_bits {
        constexpr uint32_t BPALCD32 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD32 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD32 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD32 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD32 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD32 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD32 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD32 = (1U << 7);  ///< no description available
    }

    /// WF33 Register bits
    namespace wf33_bits {
        constexpr uint32_t BPALCD33 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD33 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD33 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD33 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD33 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD33 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD33 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD33 = (1U << 7);  ///< no description available
    }

    /// WF34 Register bits
    namespace wf34_bits {
        constexpr uint32_t BPALCD34 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD34 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD34 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD34 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD34 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD34 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD34 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD34 = (1U << 7);  ///< no description available
    }

    /// WF35 Register bits
    namespace wf35_bits {
        constexpr uint32_t BPALCD35 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD35 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD35 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD35 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD35 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD35 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD35 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD35 = (1U << 7);  ///< no description available
    }

    /// WF39TO36 Register bits
    namespace wf39to36_bits {
        constexpr uint32_t WF36 = (8 << 0);  ///< no description available
        constexpr uint32_t WF37 = (8 << 8);  ///< no description available
        constexpr uint32_t WF38 = (8 << 16);  ///< no description available
        constexpr uint32_t WF39 = (8 << 24);  ///< no description available
    }

    /// WF36 Register bits
    namespace wf36_bits {
        constexpr uint32_t BPALCD36 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD36 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD36 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD36 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD36 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD36 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD36 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD36 = (1U << 7);  ///< no description available
    }

    /// WF37 Register bits
    namespace wf37_bits {
        constexpr uint32_t BPALCD37 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD37 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD37 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD37 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD37 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD37 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD37 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD37 = (1U << 7);  ///< no description available
    }

    /// WF38 Register bits
    namespace wf38_bits {
        constexpr uint32_t BPALCD38 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD38 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD38 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD38 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD38 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD38 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD38 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD38 = (1U << 7);  ///< no description available
    }

    /// WF39 Register bits
    namespace wf39_bits {
        constexpr uint32_t BPALCD39 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD39 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD39 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD39 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD39 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD39 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD39 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD39 = (1U << 7);  ///< no description available
    }

    /// WF43TO40 Register bits
    namespace wf43to40_bits {
        constexpr uint32_t WF40 = (8 << 0);  ///< no description available
        constexpr uint32_t WF41 = (8 << 8);  ///< no description available
        constexpr uint32_t WF42 = (8 << 16);  ///< no description available
        constexpr uint32_t WF43 = (8 << 24);  ///< no description available
    }

    /// WF40 Register bits
    namespace wf40_bits {
        constexpr uint32_t BPALCD40 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD40 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD40 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD40 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD40 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD40 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD40 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD40 = (1U << 7);  ///< no description available
    }

    /// WF41 Register bits
    namespace wf41_bits {
        constexpr uint32_t BPALCD41 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD41 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD41 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD41 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD41 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD41 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD41 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD41 = (1U << 7);  ///< no description available
    }

    /// WF42 Register bits
    namespace wf42_bits {
        constexpr uint32_t BPALCD42 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD42 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD42 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD42 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD42 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD42 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD42 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD42 = (1U << 7);  ///< no description available
    }

    /// WF43 Register bits
    namespace wf43_bits {
        constexpr uint32_t BPALCD43 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD43 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD43 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD43 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD43 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD43 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD43 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD43 = (1U << 7);  ///< no description available
    }

    /// WF47TO44 Register bits
    namespace wf47to44_bits {
        constexpr uint32_t WF44 = (8 << 0);  ///< no description available
        constexpr uint32_t WF45 = (8 << 8);  ///< no description available
        constexpr uint32_t WF46 = (8 << 16);  ///< no description available
        constexpr uint32_t WF47 = (8 << 24);  ///< no description available
    }

    /// WF44 Register bits
    namespace wf44_bits {
        constexpr uint32_t BPALCD44 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD44 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD44 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD44 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD44 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD44 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD44 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD44 = (1U << 7);  ///< no description available
    }

    /// WF45 Register bits
    namespace wf45_bits {
        constexpr uint32_t BPALCD45 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD45 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD45 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD45 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD45 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD45 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD45 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD45 = (1U << 7);  ///< no description available
    }

    /// WF46 Register bits
    namespace wf46_bits {
        constexpr uint32_t BPALCD46 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD46 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD46 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD46 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD46 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD46 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD46 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD46 = (1U << 7);  ///< no description available
    }

    /// WF47 Register bits
    namespace wf47_bits {
        constexpr uint32_t BPALCD47 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD47 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD47 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD47 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD47 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD47 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD47 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD47 = (1U << 7);  ///< no description available
    }

    /// WF51TO48 Register bits
    namespace wf51to48_bits {
        constexpr uint32_t WF48 = (8 << 0);  ///< no description available
        constexpr uint32_t WF49 = (8 << 8);  ///< no description available
        constexpr uint32_t WF50 = (8 << 16);  ///< no description available
        constexpr uint32_t WF51 = (8 << 24);  ///< no description available
    }

    /// WF48 Register bits
    namespace wf48_bits {
        constexpr uint32_t BPALCD48 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD48 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD48 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD48 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD48 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD48 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD48 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD48 = (1U << 7);  ///< no description available
    }

    /// WF49 Register bits
    namespace wf49_bits {
        constexpr uint32_t BPALCD49 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD49 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD49 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD49 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD49 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD49 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD49 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD49 = (1U << 7);  ///< no description available
    }

    /// WF50 Register bits
    namespace wf50_bits {
        constexpr uint32_t BPALCD50 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD50 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD50 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD50 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD50 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD50 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD50 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD50 = (1U << 7);  ///< no description available
    }

    /// WF51 Register bits
    namespace wf51_bits {
        constexpr uint32_t BPALCD51 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD51 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD51 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD51 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD51 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD51 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD51 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD51 = (1U << 7);  ///< no description available
    }

    /// WF55TO52 Register bits
    namespace wf55to52_bits {
        constexpr uint32_t WF52 = (8 << 0);  ///< no description available
        constexpr uint32_t WF53 = (8 << 8);  ///< no description available
        constexpr uint32_t WF54 = (8 << 16);  ///< no description available
        constexpr uint32_t WF55 = (8 << 24);  ///< no description available
    }

    /// WF52 Register bits
    namespace wf52_bits {
        constexpr uint32_t BPALCD52 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD52 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD52 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD52 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD52 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD52 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD52 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD52 = (1U << 7);  ///< no description available
    }

    /// WF53 Register bits
    namespace wf53_bits {
        constexpr uint32_t BPALCD53 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD53 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD53 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD53 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD53 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD53 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD53 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD53 = (1U << 7);  ///< no description available
    }

    /// WF54 Register bits
    namespace wf54_bits {
        constexpr uint32_t BPALCD54 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD54 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD54 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD54 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD54 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD54 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD54 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD54 = (1U << 7);  ///< no description available
    }

    /// WF55 Register bits
    namespace wf55_bits {
        constexpr uint32_t BPALCD55 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD55 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD55 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD55 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD55 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD55 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD55 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD55 = (1U << 7);  ///< no description available
    }

    /// WF59TO56 Register bits
    namespace wf59to56_bits {
        constexpr uint32_t WF56 = (8 << 0);  ///< no description available
        constexpr uint32_t WF57 = (8 << 8);  ///< no description available
        constexpr uint32_t WF58 = (8 << 16);  ///< no description available
        constexpr uint32_t WF59 = (8 << 24);  ///< no description available
    }

    /// WF56 Register bits
    namespace wf56_bits {
        constexpr uint32_t BPALCD56 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD56 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD56 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD56 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD56 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD56 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD56 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD56 = (1U << 7);  ///< no description available
    }

    /// WF57 Register bits
    namespace wf57_bits {
        constexpr uint32_t BPALCD57 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD57 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD57 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD57 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD57 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD57 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD57 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD57 = (1U << 7);  ///< no description available
    }

    /// WF58 Register bits
    namespace wf58_bits {
        constexpr uint32_t BPALCD58 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD58 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD58 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD58 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD58 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD58 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD58 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD58 = (1U << 7);  ///< no description available
    }

    /// WF59 Register bits
    namespace wf59_bits {
        constexpr uint32_t BPALCD59 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD59 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD59 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD59 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD59 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD59 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD59 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD59 = (1U << 7);  ///< no description available
    }

    /// WF63TO60 Register bits
    namespace wf63to60_bits {
        constexpr uint32_t WF60 = (8 << 0);  ///< no description available
        constexpr uint32_t WF61 = (8 << 8);  ///< no description available
        constexpr uint32_t WF62 = (8 << 16);  ///< no description available
        constexpr uint32_t WF63 = (8 << 24);  ///< no description available
    }

    /// WF60 Register bits
    namespace wf60_bits {
        constexpr uint32_t BPALCD60 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD60 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD60 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD60 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD60 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD60 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD60 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD60 = (1U << 7);  ///< no description available
    }

    /// WF61 Register bits
    namespace wf61_bits {
        constexpr uint32_t BPALCD61 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD61 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD61 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD61 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD61 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD61 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD61 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD61 = (1U << 7);  ///< no description available
    }

    /// WF62 Register bits
    namespace wf62_bits {
        constexpr uint32_t BPALCD62 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD62 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD62 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD62 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD62 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD62 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD62 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD62 = (1U << 7);  ///< no description available
    }

    /// WF63 Register bits
    namespace wf63_bits {
        constexpr uint32_t BPALCD63 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD63 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD63 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD63 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD63 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD63 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD63 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD63 = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x400CC000;
    constexpr uint32_t DAC1_BASE = 0x400CD000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< no description available
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA = (4 << 0);  ///< no description available
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC buffer read pointer bottom position flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC buffer read pointer top position flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC buffer watermark flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC buffer read pointer bottom flag interrupt enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC buffer read pointer top flag interrupt enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC buffer watermark interrupt enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC low power control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC software trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC trigger select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC buffer enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC buffer work mode select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC buffer watermark select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA enable select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC buffer upper limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC buffer read pointer
    }

}

// ============================================================================
// PTA Peripheral
// ============================================================================

namespace pta {
    /// Base addresses
    constexpr uint32_t PTA_BASE = 0x400FF000;

    /// PTA Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTA = reinterpret_cast<Registers*>(PTA_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTB Peripheral
// ============================================================================

namespace ptb {
    /// Base addresses
    constexpr uint32_t PTB_BASE = 0x400FF040;

    /// PTB Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTB = reinterpret_cast<Registers*>(PTB_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTC Peripheral
// ============================================================================

namespace ptc {
    /// Base addresses
    constexpr uint32_t PTC_BASE = 0x400FF080;

    /// PTC Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTC = reinterpret_cast<Registers*>(PTC_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTD Peripheral
// ============================================================================

namespace ptd {
    /// Base addresses
    constexpr uint32_t PTD_BASE = 0x400FF0C0;

    /// PTD Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTD = reinterpret_cast<Registers*>(PTD_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// PTE Peripheral
// ============================================================================

namespace pte {
    /// Base addresses
    constexpr uint32_t PTE_BASE = 0x400FF100;

    /// PTE Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* PTE = reinterpret_cast<Registers*>(PTE_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port data direction
    }

}

// ============================================================================
// SystemControl Peripheral
// ============================================================================

namespace systemcontrol {
    /// Base addresses
    constexpr uint32_t SystemControl_BASE = 0xE000E000;

    /// SystemControl Register structure
    struct Registers {
        volatile uint32_t ACTLR;  ///< Offset: 0x08 - Auxiliary Control Register,
        volatile uint32_t CPUID;  ///< Offset: 0xD00 - CPUID Base Register
        volatile uint32_t ICSR;  ///< Offset: 0xD04 - Interrupt Control and State Register
        volatile uint32_t VTOR;  ///< Offset: 0xD08 - Vector Table Offset Register
        volatile uint32_t AIRCR;  ///< Offset: 0xD0C - Application Interrupt and Reset Control Register
        volatile uint32_t SCR;  ///< Offset: 0xD10 - System Control Register
        volatile uint32_t CCR;  ///< Offset: 0xD14 - Configuration and Control Register
        volatile uint32_t SHPR1;  ///< Offset: 0xD18 - System Handler Priority Register 1
        volatile uint32_t SHPR2;  ///< Offset: 0xD1C - System Handler Priority Register 2
        volatile uint32_t SHPR3;  ///< Offset: 0xD20 - System Handler Priority Register 3
        volatile uint32_t SHCSR;  ///< Offset: 0xD24 - System Handler Control and State Register
        volatile uint32_t CFSR;  ///< Offset: 0xD28 - Configurable Fault Status Registers
        volatile uint32_t HFSR;  ///< Offset: 0xD2C - HardFault Status register
        volatile uint32_t DFSR;  ///< Offset: 0xD30 - Debug Fault Status Register
        volatile uint32_t MMFAR;  ///< Offset: 0xD34 - MemManage Address Register
        volatile uint32_t BFAR;  ///< Offset: 0xD38 - BusFault Address Register
        volatile uint32_t AFSR;  ///< Offset: 0xD3C - Auxiliary Fault Status Register
    };

    /// Peripheral instances
    inline Registers* SystemControl = reinterpret_cast<Registers*>(SystemControl_BASE);

    // Bit definitions
    /// ACTLR Register bits
    namespace actlr_bits {
        constexpr uint32_t DISMCYCINT = (1U << 0);  ///< Disables interruption of multi-cycle instructions.
        constexpr uint32_t DISDEFWBUF = (1U << 1);  ///< Disables write buffer use during default memory map accesses.
        constexpr uint32_t DISFOLD = (1U << 2);  ///< Disables folding of IT instructions.
    }

    /// CPUID Register bits
    namespace cpuid_bits {
        constexpr uint32_t REVISION = (4 << 0);  ///< Indicates patch release: 0x0 = Patch 0
        constexpr uint32_t PARTNO = (12 << 4);  ///< Indicates part number
        constexpr uint32_t VARIANT = (4 << 20);  ///< Indicates processor revision: 0x2 = Revision 2
        constexpr uint32_t IMPLEMENTER = (8 << 24);  ///< Implementer code
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t VECTACTIVE = (9 << 0);  ///< Active exception number
        constexpr uint32_t RETTOBASE = (1U << 11);  ///< no description available
        constexpr uint32_t VECTPENDING = (6 << 12);  ///< Exception number of the highest priority pending enabled exception
        constexpr uint32_t ISRPENDING = (1U << 22);  ///< no description available
        constexpr uint32_t ISRPREEMPT = (1U << 23);  ///< no description available
        constexpr uint32_t PENDSTCLR = (1U << 25);  ///< no description available
        constexpr uint32_t PENDSTSET = (1U << 26);  ///< no description available
        constexpr uint32_t PENDSVCLR = (1U << 27);  ///< no description available
        constexpr uint32_t PENDSVSET = (1U << 28);  ///< no description available
        constexpr uint32_t NMIPENDSET = (1U << 31);  ///< no description available
    }

    /// VTOR Register bits
    namespace vtor_bits {
        constexpr uint32_t TBLOFF = (25 << 7);  ///< Vector table base offset
    }

    /// AIRCR Register bits
    namespace aircr_bits {
        constexpr uint32_t VECTRESET = (1U << 0);  ///< no description available
        constexpr uint32_t VECTCLRACTIVE = (1U << 1);  ///< no description available
        constexpr uint32_t SYSRESETREQ = (1U << 2);  ///< no description available
        constexpr uint32_t PRIGROUP = (3 << 8);  ///< Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        constexpr uint32_t ENDIANNESS = (1U << 15);  ///< no description available
        constexpr uint32_t VECTKEY = (16 << 16);  ///< Register key
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SLEEPONEXIT = (1U << 1);  ///< no description available
        constexpr uint32_t SLEEPDEEP = (1U << 2);  ///< no description available
        constexpr uint32_t SEVONPEND = (1U << 4);  ///< no description available
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t NONBASETHRDENA = (1U << 0);  ///< no description available
        constexpr uint32_t USERSETMPEND = (1U << 1);  ///< Enables unprivileged software access to the STIR
        constexpr uint32_t UNALIGN_TRP = (1U << 3);  ///< Enables unaligned access traps
        constexpr uint32_t DIV_0_TRP = (1U << 4);  ///< Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
        constexpr uint32_t BFHFNMIGN = (1U << 8);  ///< Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
        constexpr uint32_t STKALIGN = (1U << 9);  ///< Indicates stack alignment on exception entry
    }

    /// SHPR1 Register bits
    namespace shpr1_bits {
        constexpr uint32_t PRI_4 = (8 << 0);  ///< Priority of system handler 4, MemManage
        constexpr uint32_t PRI_5 = (8 << 8);  ///< Priority of system handler 5, BusFault
        constexpr uint32_t PRI_6 = (8 << 16);  ///< Priority of system handler 6, UsageFault
    }

    /// SHPR2 Register bits
    namespace shpr2_bits {
        constexpr uint32_t PRI_11 = (8 << 24);  ///< Priority of system handler 11, SVCall
    }

    /// SHPR3 Register bits
    namespace shpr3_bits {
        constexpr uint32_t PRI_14 = (8 << 16);  ///< Priority of system handler 14, PendSV
        constexpr uint32_t PRI_15 = (8 << 24);  ///< Priority of system handler 15, SysTick exception
    }

    /// SHCSR Register bits
    namespace shcsr_bits {
        constexpr uint32_t MEMFAULTACT = (1U << 0);  ///< no description available
        constexpr uint32_t BUSFAULTACT = (1U << 1);  ///< no description available
        constexpr uint32_t USGFAULTACT = (1U << 3);  ///< no description available
        constexpr uint32_t SVCALLACT = (1U << 7);  ///< no description available
        constexpr uint32_t MONITORACT = (1U << 8);  ///< no description available
        constexpr uint32_t PENDSVACT = (1U << 10);  ///< no description available
        constexpr uint32_t SYSTICKACT = (1U << 11);  ///< no description available
        constexpr uint32_t USGFAULTPENDED = (1U << 12);  ///< no description available
        constexpr uint32_t MEMFAULTPENDED = (1U << 13);  ///< no description available
        constexpr uint32_t BUSFAULTPENDED = (1U << 14);  ///< no description available
        constexpr uint32_t SVCALLPENDED = (1U << 15);  ///< no description available
        constexpr uint32_t MEMFAULTENA = (1U << 16);  ///< no description available
        constexpr uint32_t BUSFAULTENA = (1U << 17);  ///< no description available
        constexpr uint32_t USGFAULTENA = (1U << 18);  ///< no description available
    }

    /// CFSR Register bits
    namespace cfsr_bits {
        constexpr uint32_t IACCVIOL = (1U << 0);  ///< no description available
        constexpr uint32_t DACCVIOL = (1U << 1);  ///< no description available
        constexpr uint32_t MUNSTKERR = (1U << 3);  ///< no description available
        constexpr uint32_t MSTKERR = (1U << 4);  ///< no description available
        constexpr uint32_t MLSPERR = (1U << 5);  ///< no description available
        constexpr uint32_t MMARVALID = (1U << 7);  ///< no description available
        constexpr uint32_t IBUSERR = (1U << 8);  ///< no description available
        constexpr uint32_t PRECISERR = (1U << 9);  ///< no description available
        constexpr uint32_t IMPRECISERR = (1U << 10);  ///< no description available
        constexpr uint32_t UNSTKERR = (1U << 11);  ///< no description available
        constexpr uint32_t STKERR = (1U << 12);  ///< no description available
        constexpr uint32_t LSPERR = (1U << 13);  ///< no description available
        constexpr uint32_t BFARVALID = (1U << 15);  ///< no description available
        constexpr uint32_t UNDEFINSTR = (1U << 16);  ///< no description available
        constexpr uint32_t INVSTATE = (1U << 17);  ///< no description available
        constexpr uint32_t INVPC = (1U << 18);  ///< no description available
        constexpr uint32_t NOCP = (1U << 19);  ///< no description available
        constexpr uint32_t UNALIGNED = (1U << 24);  ///< no description available
        constexpr uint32_t DIVBYZERO = (1U << 25);  ///< no description available
    }

    /// HFSR Register bits
    namespace hfsr_bits {
        constexpr uint32_t VECTTBL = (1U << 1);  ///< no description available
        constexpr uint32_t FORCED = (1U << 30);  ///< no description available
        constexpr uint32_t DEBUGEVT = (1U << 31);  ///< no description available
    }

    /// DFSR Register bits
    namespace dfsr_bits {
        constexpr uint32_t HALTED = (1U << 0);  ///< no description available
        constexpr uint32_t BKPT = (1U << 1);  ///< no description available
        constexpr uint32_t DWTTRAP = (1U << 2);  ///< no description available
        constexpr uint32_t VCATCH = (1U << 3);  ///< no description available
        constexpr uint32_t EXTERNAL = (1U << 4);  ///< no description available
    }

    /// MMFAR Register bits
    namespace mmfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of MemManage fault location
    }

    /// BFAR Register bits
    namespace bfar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address of the BusFault location
    }

    /// AFSR Register bits
    namespace afsr_bits {
        constexpr uint32_t AUXFAULT = (32 << 0);  ///< Latched version of the AUXFAULT inputs
    }

}

// ============================================================================
// SysTick Peripheral
// ============================================================================

namespace systick {
    /// Base addresses
    constexpr uint32_t SysTick_BASE = 0xE000E010;

    /// SysTick Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - SysTick Control and Status Register
        volatile uint32_t RVR;  ///< Offset: 0x04 - SysTick Reload Value Register
        volatile uint32_t CVR;  ///< Offset: 0x08 - SysTick Current Value Register
        volatile uint32_t CALIB;  ///< Offset: 0x0C - SysTick Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* SysTick = reinterpret_cast<Registers*>(SysTick_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t ENABLE = (1U << 0);  ///< no description available
        constexpr uint32_t TICKINT = (1U << 1);  ///< no description available
        constexpr uint32_t CLKSOURCE = (1U << 2);  ///< no description available
        constexpr uint32_t COUNTFLAG = (1U << 16);  ///< no description available
    }

    /// RVR Register bits
    namespace rvr_bits {
        constexpr uint32_t RELOAD = (24 << 0);  ///< Value to load into the SysTick Current Value Register when the counter reaches 0
    }

    /// CVR Register bits
    namespace cvr_bits {
        constexpr uint32_t CURRENT = (24 << 0);  ///< Current value at the time the register is accessed
    }

    /// CALIB Register bits
    namespace calib_bits {
        constexpr uint32_t TENMS = (24 << 0);  ///< Reload value to use for 10ms timing
        constexpr uint32_t SKEW = (1U << 30);  ///< no description available
        constexpr uint32_t NOREF = (1U << 31);  ///< no description available
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E100;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t NVICISER0;  ///< Offset: 0x00 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER1;  ///< Offset: 0x04 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER2;  ///< Offset: 0x08 - Interrupt Set Enable Register n
        volatile uint32_t NVICISER3;  ///< Offset: 0x0C - Interrupt Set Enable Register n
        volatile uint32_t NVICICER0;  ///< Offset: 0x80 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER1;  ///< Offset: 0x84 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER2;  ///< Offset: 0x88 - Interrupt Clear Enable Register n
        volatile uint32_t NVICICER3;  ///< Offset: 0x8C - Interrupt Clear Enable Register n
        volatile uint32_t NVICISPR0;  ///< Offset: 0x100 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR1;  ///< Offset: 0x104 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR2;  ///< Offset: 0x108 - Interrupt Set Pending Register n
        volatile uint32_t NVICISPR3;  ///< Offset: 0x10C - Interrupt Set Pending Register n
        volatile uint32_t NVICICPR0;  ///< Offset: 0x180 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR1;  ///< Offset: 0x184 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR2;  ///< Offset: 0x188 - Interrupt Clear Pending Register n
        volatile uint32_t NVICICPR3;  ///< Offset: 0x18C - Interrupt Clear Pending Register n
        volatile uint32_t NVICIABR0;  ///< Offset: 0x200 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR1;  ///< Offset: 0x204 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR2;  ///< Offset: 0x208 - Interrupt Active bit Register n
        volatile uint32_t NVICIABR3;  ///< Offset: 0x20C - Interrupt Active bit Register n
        volatile uint32_t NVICIP0;  ///< Offset: 0x300 - Interrupt Priority Register n
        volatile uint32_t NVICIP1;  ///< Offset: 0x301 - Interrupt Priority Register n
        volatile uint32_t NVICIP2;  ///< Offset: 0x302 - Interrupt Priority Register n
        volatile uint32_t NVICIP3;  ///< Offset: 0x303 - Interrupt Priority Register n
        volatile uint32_t NVICIP4;  ///< Offset: 0x304 - Interrupt Priority Register n
        volatile uint32_t NVICIP5;  ///< Offset: 0x305 - Interrupt Priority Register n
        volatile uint32_t NVICIP6;  ///< Offset: 0x306 - Interrupt Priority Register n
        volatile uint32_t NVICIP7;  ///< Offset: 0x307 - Interrupt Priority Register n
        volatile uint32_t NVICIP8;  ///< Offset: 0x308 - Interrupt Priority Register n
        volatile uint32_t NVICIP9;  ///< Offset: 0x309 - Interrupt Priority Register n
        volatile uint32_t NVICIP10;  ///< Offset: 0x30A - Interrupt Priority Register n
        volatile uint32_t NVICIP11;  ///< Offset: 0x30B - Interrupt Priority Register n
        volatile uint32_t NVICIP12;  ///< Offset: 0x30C - Interrupt Priority Register n
        volatile uint32_t NVICIP13;  ///< Offset: 0x30D - Interrupt Priority Register n
        volatile uint32_t NVICIP14;  ///< Offset: 0x30E - Interrupt Priority Register n
        volatile uint32_t NVICIP15;  ///< Offset: 0x30F - Interrupt Priority Register n
        volatile uint32_t NVICIP16;  ///< Offset: 0x310 - Interrupt Priority Register n
        volatile uint32_t NVICIP17;  ///< Offset: 0x311 - Interrupt Priority Register n
        volatile uint32_t NVICIP18;  ///< Offset: 0x312 - Interrupt Priority Register n
        volatile uint32_t NVICIP19;  ///< Offset: 0x313 - Interrupt Priority Register n
        volatile uint32_t NVICIP20;  ///< Offset: 0x314 - Interrupt Priority Register n
        volatile uint32_t NVICIP21;  ///< Offset: 0x315 - Interrupt Priority Register n
        volatile uint32_t NVICIP22;  ///< Offset: 0x316 - Interrupt Priority Register n
        volatile uint32_t NVICIP23;  ///< Offset: 0x317 - Interrupt Priority Register n
        volatile uint32_t NVICIP24;  ///< Offset: 0x318 - Interrupt Priority Register n
        volatile uint32_t NVICIP25;  ///< Offset: 0x319 - Interrupt Priority Register n
        volatile uint32_t NVICIP26;  ///< Offset: 0x31A - Interrupt Priority Register n
        volatile uint32_t NVICIP27;  ///< Offset: 0x31B - Interrupt Priority Register n
        volatile uint32_t NVICIP28;  ///< Offset: 0x31C - Interrupt Priority Register n
        volatile uint32_t NVICIP29;  ///< Offset: 0x31D - Interrupt Priority Register n
        volatile uint32_t NVICIP30;  ///< Offset: 0x31E - Interrupt Priority Register n
        volatile uint32_t NVICIP31;  ///< Offset: 0x31F - Interrupt Priority Register n
        volatile uint32_t NVICIP32;  ///< Offset: 0x320 - Interrupt Priority Register n
        volatile uint32_t NVICIP33;  ///< Offset: 0x321 - Interrupt Priority Register n
        volatile uint32_t NVICIP34;  ///< Offset: 0x322 - Interrupt Priority Register n
        volatile uint32_t NVICIP35;  ///< Offset: 0x323 - Interrupt Priority Register n
        volatile uint32_t NVICIP36;  ///< Offset: 0x324 - Interrupt Priority Register n
        volatile uint32_t NVICIP37;  ///< Offset: 0x325 - Interrupt Priority Register n
        volatile uint32_t NVICIP38;  ///< Offset: 0x326 - Interrupt Priority Register n
        volatile uint32_t NVICIP39;  ///< Offset: 0x327 - Interrupt Priority Register n
        volatile uint32_t NVICIP40;  ///< Offset: 0x328 - Interrupt Priority Register n
        volatile uint32_t NVICIP41;  ///< Offset: 0x329 - Interrupt Priority Register n
        volatile uint32_t NVICIP42;  ///< Offset: 0x32A - Interrupt Priority Register n
        volatile uint32_t NVICIP43;  ///< Offset: 0x32B - Interrupt Priority Register n
        volatile uint32_t NVICIP44;  ///< Offset: 0x32C - Interrupt Priority Register n
        volatile uint32_t NVICIP45;  ///< Offset: 0x32D - Interrupt Priority Register n
        volatile uint32_t NVICIP46;  ///< Offset: 0x32E - Interrupt Priority Register n
        volatile uint32_t NVICIP47;  ///< Offset: 0x32F - Interrupt Priority Register n
        volatile uint32_t NVICIP48;  ///< Offset: 0x330 - Interrupt Priority Register n
        volatile uint32_t NVICIP49;  ///< Offset: 0x331 - Interrupt Priority Register n
        volatile uint32_t NVICIP50;  ///< Offset: 0x332 - Interrupt Priority Register n
        volatile uint32_t NVICIP51;  ///< Offset: 0x333 - Interrupt Priority Register n
        volatile uint32_t NVICIP52;  ///< Offset: 0x334 - Interrupt Priority Register n
        volatile uint32_t NVICIP53;  ///< Offset: 0x335 - Interrupt Priority Register n
        volatile uint32_t NVICIP54;  ///< Offset: 0x336 - Interrupt Priority Register n
        volatile uint32_t NVICIP55;  ///< Offset: 0x337 - Interrupt Priority Register n
        volatile uint32_t NVICIP56;  ///< Offset: 0x338 - Interrupt Priority Register n
        volatile uint32_t NVICIP57;  ///< Offset: 0x339 - Interrupt Priority Register n
        volatile uint32_t NVICIP58;  ///< Offset: 0x33A - Interrupt Priority Register n
        volatile uint32_t NVICIP59;  ///< Offset: 0x33B - Interrupt Priority Register n
        volatile uint32_t NVICIP60;  ///< Offset: 0x33C - Interrupt Priority Register n
        volatile uint32_t NVICIP61;  ///< Offset: 0x33D - Interrupt Priority Register n
        volatile uint32_t NVICIP62;  ///< Offset: 0x33E - Interrupt Priority Register n
        volatile uint32_t NVICIP63;  ///< Offset: 0x33F - Interrupt Priority Register n
        volatile uint32_t NVICIP64;  ///< Offset: 0x340 - Interrupt Priority Register n
        volatile uint32_t NVICIP65;  ///< Offset: 0x341 - Interrupt Priority Register n
        volatile uint32_t NVICIP66;  ///< Offset: 0x342 - Interrupt Priority Register n
        volatile uint32_t NVICIP67;  ///< Offset: 0x343 - Interrupt Priority Register n
        volatile uint32_t NVICIP68;  ///< Offset: 0x344 - Interrupt Priority Register n
        volatile uint32_t NVICIP69;  ///< Offset: 0x345 - Interrupt Priority Register n
        volatile uint32_t NVICIP70;  ///< Offset: 0x346 - Interrupt Priority Register n
        volatile uint32_t NVICIP71;  ///< Offset: 0x347 - Interrupt Priority Register n
        volatile uint32_t NVICIP72;  ///< Offset: 0x348 - Interrupt Priority Register n
        volatile uint32_t NVICIP73;  ///< Offset: 0x349 - Interrupt Priority Register n
        volatile uint32_t NVICIP74;  ///< Offset: 0x34A - Interrupt Priority Register n
        volatile uint32_t NVICIP75;  ///< Offset: 0x34B - Interrupt Priority Register n
        volatile uint32_t NVICIP76;  ///< Offset: 0x34C - Interrupt Priority Register n
        volatile uint32_t NVICIP77;  ///< Offset: 0x34D - Interrupt Priority Register n
        volatile uint32_t NVICIP78;  ///< Offset: 0x34E - Interrupt Priority Register n
        volatile uint32_t NVICIP79;  ///< Offset: 0x34F - Interrupt Priority Register n
        volatile uint32_t NVICIP80;  ///< Offset: 0x350 - Interrupt Priority Register n
        volatile uint32_t NVICIP81;  ///< Offset: 0x351 - Interrupt Priority Register n
        volatile uint32_t NVICIP82;  ///< Offset: 0x352 - Interrupt Priority Register n
        volatile uint32_t NVICIP83;  ///< Offset: 0x353 - Interrupt Priority Register n
        volatile uint32_t NVICIP84;  ///< Offset: 0x354 - Interrupt Priority Register n
        volatile uint32_t NVICIP85;  ///< Offset: 0x355 - Interrupt Priority Register n
        volatile uint32_t NVICIP86;  ///< Offset: 0x356 - Interrupt Priority Register n
        volatile uint32_t NVICIP87;  ///< Offset: 0x357 - Interrupt Priority Register n
        volatile uint32_t NVICIP88;  ///< Offset: 0x358 - Interrupt Priority Register n
        volatile uint32_t NVICIP89;  ///< Offset: 0x359 - Interrupt Priority Register n
        volatile uint32_t NVICIP90;  ///< Offset: 0x35A - Interrupt Priority Register n
        volatile uint32_t NVICIP91;  ///< Offset: 0x35B - Interrupt Priority Register n
        volatile uint32_t NVICIP92;  ///< Offset: 0x35C - Interrupt Priority Register n
        volatile uint32_t NVICIP93;  ///< Offset: 0x35D - Interrupt Priority Register n
        volatile uint32_t NVICIP94;  ///< Offset: 0x35E - Interrupt Priority Register n
        volatile uint32_t NVICIP95;  ///< Offset: 0x35F - Interrupt Priority Register n
        volatile uint32_t NVICIP96;  ///< Offset: 0x360 - Interrupt Priority Register n
        volatile uint32_t NVICIP97;  ///< Offset: 0x361 - Interrupt Priority Register n
        volatile uint32_t NVICIP98;  ///< Offset: 0x362 - Interrupt Priority Register n
        volatile uint32_t NVICIP99;  ///< Offset: 0x363 - Interrupt Priority Register n
        volatile uint32_t NVICIP100;  ///< Offset: 0x364 - Interrupt Priority Register n
        volatile uint32_t NVICIP101;  ///< Offset: 0x365 - Interrupt Priority Register n
        volatile uint32_t NVICIP102;  ///< Offset: 0x366 - Interrupt Priority Register n
        volatile uint32_t NVICIP103;  ///< Offset: 0x367 - Interrupt Priority Register n
        volatile uint32_t NVICIP104;  ///< Offset: 0x368 - Interrupt Priority Register n
        volatile uint32_t NVICIP105;  ///< Offset: 0x369 - Interrupt Priority Register n
        volatile uint32_t NVICSTIR;  ///< Offset: 0xE00 - Software Trigger Interrupt Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// NVICISER0 Register bits
    namespace nviciser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER1 Register bits
    namespace nviciser1_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER2 Register bits
    namespace nviciser2_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICISER3 Register bits
    namespace nviciser3_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< Interrupt set enable bits
    }

    /// NVICICER0 Register bits
    namespace nvicicer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER1 Register bits
    namespace nvicicer1_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER2 Register bits
    namespace nvicicer2_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICICER3 Register bits
    namespace nvicicer3_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< Interrupt clear-enable bits
    }

    /// NVICISPR0 Register bits
    namespace nvicispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR1 Register bits
    namespace nvicispr1_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR2 Register bits
    namespace nvicispr2_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICISPR3 Register bits
    namespace nvicispr3_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< Interrupt set-pending bits
    }

    /// NVICICPR0 Register bits
    namespace nvicicpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR1 Register bits
    namespace nvicicpr1_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR2 Register bits
    namespace nvicicpr2_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICICPR3 Register bits
    namespace nvicicpr3_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< Interrupt clear-pending bits
    }

    /// NVICIABR0 Register bits
    namespace nviciabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR1 Register bits
    namespace nviciabr1_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR2 Register bits
    namespace nviciabr2_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIABR3 Register bits
    namespace nviciabr3_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< Interrupt active flags
    }

    /// NVICIP0 Register bits
    namespace nvicip0_bits {
        constexpr uint32_t PRI0 = (8 << 0);  ///< Priority of interrupt 0
    }

    /// NVICIP1 Register bits
    namespace nvicip1_bits {
        constexpr uint32_t PRI1 = (8 << 0);  ///< Priority of interrupt 1
    }

    /// NVICIP2 Register bits
    namespace nvicip2_bits {
        constexpr uint32_t PRI2 = (8 << 0);  ///< Priority of interrupt 2
    }

    /// NVICIP3 Register bits
    namespace nvicip3_bits {
        constexpr uint32_t PRI3 = (8 << 0);  ///< Priority of interrupt 3
    }

    /// NVICIP4 Register bits
    namespace nvicip4_bits {
        constexpr uint32_t PRI4 = (8 << 0);  ///< Priority of interrupt 4
    }

    /// NVICIP5 Register bits
    namespace nvicip5_bits {
        constexpr uint32_t PRI5 = (8 << 0);  ///< Priority of interrupt 5
    }

    /// NVICIP6 Register bits
    namespace nvicip6_bits {
        constexpr uint32_t PRI6 = (8 << 0);  ///< Priority of interrupt 6
    }

    /// NVICIP7 Register bits
    namespace nvicip7_bits {
        constexpr uint32_t PRI7 = (8 << 0);  ///< Priority of interrupt 7
    }

    /// NVICIP8 Register bits
    namespace nvicip8_bits {
        constexpr uint32_t PRI8 = (8 << 0);  ///< Priority of interrupt 8
    }

    /// NVICIP9 Register bits
    namespace nvicip9_bits {
        constexpr uint32_t PRI9 = (8 << 0);  ///< Priority of interrupt 9
    }

    /// NVICIP10 Register bits
    namespace nvicip10_bits {
        constexpr uint32_t PRI10 = (8 << 0);  ///< Priority of interrupt 10
    }

    /// NVICIP11 Register bits
    namespace nvicip11_bits {
        constexpr uint32_t PRI11 = (8 << 0);  ///< Priority of interrupt 11
    }

    /// NVICIP12 Register bits
    namespace nvicip12_bits {
        constexpr uint32_t PRI12 = (8 << 0);  ///< Priority of interrupt 12
    }

    /// NVICIP13 Register bits
    namespace nvicip13_bits {
        constexpr uint32_t PRI13 = (8 << 0);  ///< Priority of interrupt 13
    }

    /// NVICIP14 Register bits
    namespace nvicip14_bits {
        constexpr uint32_t PRI14 = (8 << 0);  ///< Priority of interrupt 14
    }

    /// NVICIP15 Register bits
    namespace nvicip15_bits {
        constexpr uint32_t PRI15 = (8 << 0);  ///< Priority of interrupt 15
    }

    /// NVICIP16 Register bits
    namespace nvicip16_bits {
        constexpr uint32_t PRI16 = (8 << 0);  ///< Priority of interrupt 16
    }

    /// NVICIP17 Register bits
    namespace nvicip17_bits {
        constexpr uint32_t PRI17 = (8 << 0);  ///< Priority of interrupt 17
    }

    /// NVICIP18 Register bits
    namespace nvicip18_bits {
        constexpr uint32_t PRI18 = (8 << 0);  ///< Priority of interrupt 18
    }

    /// NVICIP19 Register bits
    namespace nvicip19_bits {
        constexpr uint32_t PRI19 = (8 << 0);  ///< Priority of interrupt 19
    }

    /// NVICIP20 Register bits
    namespace nvicip20_bits {
        constexpr uint32_t PRI20 = (8 << 0);  ///< Priority of interrupt 20
    }

    /// NVICIP21 Register bits
    namespace nvicip21_bits {
        constexpr uint32_t PRI21 = (8 << 0);  ///< Priority of interrupt 21
    }

    /// NVICIP22 Register bits
    namespace nvicip22_bits {
        constexpr uint32_t PRI22 = (8 << 0);  ///< Priority of interrupt 22
    }

    /// NVICIP23 Register bits
    namespace nvicip23_bits {
        constexpr uint32_t PRI23 = (8 << 0);  ///< Priority of interrupt 23
    }

    /// NVICIP24 Register bits
    namespace nvicip24_bits {
        constexpr uint32_t PRI24 = (8 << 0);  ///< Priority of interrupt 24
    }

    /// NVICIP25 Register bits
    namespace nvicip25_bits {
        constexpr uint32_t PRI25 = (8 << 0);  ///< Priority of interrupt 25
    }

    /// NVICIP26 Register bits
    namespace nvicip26_bits {
        constexpr uint32_t PRI26 = (8 << 0);  ///< Priority of interrupt 26
    }

    /// NVICIP27 Register bits
    namespace nvicip27_bits {
        constexpr uint32_t PRI27 = (8 << 0);  ///< Priority of interrupt 27
    }

    /// NVICIP28 Register bits
    namespace nvicip28_bits {
        constexpr uint32_t PRI28 = (8 << 0);  ///< Priority of interrupt 28
    }

    /// NVICIP29 Register bits
    namespace nvicip29_bits {
        constexpr uint32_t PRI29 = (8 << 0);  ///< Priority of interrupt 29
    }

    /// NVICIP30 Register bits
    namespace nvicip30_bits {
        constexpr uint32_t PRI30 = (8 << 0);  ///< Priority of interrupt 30
    }

    /// NVICIP31 Register bits
    namespace nvicip31_bits {
        constexpr uint32_t PRI31 = (8 << 0);  ///< Priority of interrupt 31
    }

    /// NVICIP32 Register bits
    namespace nvicip32_bits {
        constexpr uint32_t PRI32 = (8 << 0);  ///< Priority of interrupt 32
    }

    /// NVICIP33 Register bits
    namespace nvicip33_bits {
        constexpr uint32_t PRI33 = (8 << 0);  ///< Priority of interrupt 33
    }

    /// NVICIP34 Register bits
    namespace nvicip34_bits {
        constexpr uint32_t PRI34 = (8 << 0);  ///< Priority of interrupt 34
    }

    /// NVICIP35 Register bits
    namespace nvicip35_bits {
        constexpr uint32_t PRI35 = (8 << 0);  ///< Priority of interrupt 35
    }

    /// NVICIP36 Register bits
    namespace nvicip36_bits {
        constexpr uint32_t PRI36 = (8 << 0);  ///< Priority of interrupt 36
    }

    /// NVICIP37 Register bits
    namespace nvicip37_bits {
        constexpr uint32_t PRI37 = (8 << 0);  ///< Priority of interrupt 37
    }

    /// NVICIP38 Register bits
    namespace nvicip38_bits {
        constexpr uint32_t PRI38 = (8 << 0);  ///< Priority of interrupt 38
    }

    /// NVICIP39 Register bits
    namespace nvicip39_bits {
        constexpr uint32_t PRI39 = (8 << 0);  ///< Priority of interrupt 39
    }

    /// NVICIP40 Register bits
    namespace nvicip40_bits {
        constexpr uint32_t PRI40 = (8 << 0);  ///< Priority of interrupt 40
    }

    /// NVICIP41 Register bits
    namespace nvicip41_bits {
        constexpr uint32_t PRI41 = (8 << 0);  ///< Priority of interrupt 41
    }

    /// NVICIP42 Register bits
    namespace nvicip42_bits {
        constexpr uint32_t PRI42 = (8 << 0);  ///< Priority of interrupt 42
    }

    /// NVICIP43 Register bits
    namespace nvicip43_bits {
        constexpr uint32_t PRI43 = (8 << 0);  ///< Priority of interrupt 43
    }

    /// NVICIP44 Register bits
    namespace nvicip44_bits {
        constexpr uint32_t PRI44 = (8 << 0);  ///< Priority of interrupt 44
    }

    /// NVICIP45 Register bits
    namespace nvicip45_bits {
        constexpr uint32_t PRI45 = (8 << 0);  ///< Priority of interrupt 45
    }

    /// NVICIP46 Register bits
    namespace nvicip46_bits {
        constexpr uint32_t PRI46 = (8 << 0);  ///< Priority of interrupt 46
    }

    /// NVICIP47 Register bits
    namespace nvicip47_bits {
        constexpr uint32_t PRI47 = (8 << 0);  ///< Priority of interrupt 47
    }

    /// NVICIP48 Register bits
    namespace nvicip48_bits {
        constexpr uint32_t PRI48 = (8 << 0);  ///< Priority of interrupt 48
    }

    /// NVICIP49 Register bits
    namespace nvicip49_bits {
        constexpr uint32_t PRI49 = (8 << 0);  ///< Priority of interrupt 49
    }

    /// NVICIP50 Register bits
    namespace nvicip50_bits {
        constexpr uint32_t PRI50 = (8 << 0);  ///< Priority of interrupt 50
    }

    /// NVICIP51 Register bits
    namespace nvicip51_bits {
        constexpr uint32_t PRI51 = (8 << 0);  ///< Priority of interrupt 51
    }

    /// NVICIP52 Register bits
    namespace nvicip52_bits {
        constexpr uint32_t PRI52 = (8 << 0);  ///< Priority of interrupt 52
    }

    /// NVICIP53 Register bits
    namespace nvicip53_bits {
        constexpr uint32_t PRI53 = (8 << 0);  ///< Priority of interrupt 53
    }

    /// NVICIP54 Register bits
    namespace nvicip54_bits {
        constexpr uint32_t PRI54 = (8 << 0);  ///< Priority of interrupt 54
    }

    /// NVICIP55 Register bits
    namespace nvicip55_bits {
        constexpr uint32_t PRI55 = (8 << 0);  ///< Priority of interrupt 55
    }

    /// NVICIP56 Register bits
    namespace nvicip56_bits {
        constexpr uint32_t PRI56 = (8 << 0);  ///< Priority of interrupt 56
    }

    /// NVICIP57 Register bits
    namespace nvicip57_bits {
        constexpr uint32_t PRI57 = (8 << 0);  ///< Priority of interrupt 57
    }

    /// NVICIP58 Register bits
    namespace nvicip58_bits {
        constexpr uint32_t PRI58 = (8 << 0);  ///< Priority of interrupt 58
    }

    /// NVICIP59 Register bits
    namespace nvicip59_bits {
        constexpr uint32_t PRI59 = (8 << 0);  ///< Priority of interrupt 59
    }

    /// NVICIP60 Register bits
    namespace nvicip60_bits {
        constexpr uint32_t PRI60 = (8 << 0);  ///< Priority of interrupt 60
    }

    /// NVICIP61 Register bits
    namespace nvicip61_bits {
        constexpr uint32_t PRI61 = (8 << 0);  ///< Priority of interrupt 61
    }

    /// NVICIP62 Register bits
    namespace nvicip62_bits {
        constexpr uint32_t PRI62 = (8 << 0);  ///< Priority of interrupt 62
    }

    /// NVICIP63 Register bits
    namespace nvicip63_bits {
        constexpr uint32_t PRI63 = (8 << 0);  ///< Priority of interrupt 63
    }

    /// NVICIP64 Register bits
    namespace nvicip64_bits {
        constexpr uint32_t PRI64 = (8 << 0);  ///< Priority of interrupt 64
    }

    /// NVICIP65 Register bits
    namespace nvicip65_bits {
        constexpr uint32_t PRI65 = (8 << 0);  ///< Priority of interrupt 65
    }

    /// NVICIP66 Register bits
    namespace nvicip66_bits {
        constexpr uint32_t PRI66 = (8 << 0);  ///< Priority of interrupt 66
    }

    /// NVICIP67 Register bits
    namespace nvicip67_bits {
        constexpr uint32_t PRI67 = (8 << 0);  ///< Priority of interrupt 67
    }

    /// NVICIP68 Register bits
    namespace nvicip68_bits {
        constexpr uint32_t PRI68 = (8 << 0);  ///< Priority of interrupt 68
    }

    /// NVICIP69 Register bits
    namespace nvicip69_bits {
        constexpr uint32_t PRI69 = (8 << 0);  ///< Priority of interrupt 69
    }

    /// NVICIP70 Register bits
    namespace nvicip70_bits {
        constexpr uint32_t PRI70 = (8 << 0);  ///< Priority of interrupt 70
    }

    /// NVICIP71 Register bits
    namespace nvicip71_bits {
        constexpr uint32_t PRI71 = (8 << 0);  ///< Priority of interrupt 71
    }

    /// NVICIP72 Register bits
    namespace nvicip72_bits {
        constexpr uint32_t PRI72 = (8 << 0);  ///< Priority of interrupt 72
    }

    /// NVICIP73 Register bits
    namespace nvicip73_bits {
        constexpr uint32_t PRI73 = (8 << 0);  ///< Priority of interrupt 73
    }

    /// NVICIP74 Register bits
    namespace nvicip74_bits {
        constexpr uint32_t PRI74 = (8 << 0);  ///< Priority of interrupt 74
    }

    /// NVICIP75 Register bits
    namespace nvicip75_bits {
        constexpr uint32_t PRI75 = (8 << 0);  ///< Priority of interrupt 75
    }

    /// NVICIP76 Register bits
    namespace nvicip76_bits {
        constexpr uint32_t PRI76 = (8 << 0);  ///< Priority of interrupt 76
    }

    /// NVICIP77 Register bits
    namespace nvicip77_bits {
        constexpr uint32_t PRI77 = (8 << 0);  ///< Priority of interrupt 77
    }

    /// NVICIP78 Register bits
    namespace nvicip78_bits {
        constexpr uint32_t PRI78 = (8 << 0);  ///< Priority of interrupt 78
    }

    /// NVICIP79 Register bits
    namespace nvicip79_bits {
        constexpr uint32_t PRI79 = (8 << 0);  ///< Priority of interrupt 79
    }

    /// NVICIP80 Register bits
    namespace nvicip80_bits {
        constexpr uint32_t PRI80 = (8 << 0);  ///< Priority of interrupt 80
    }

    /// NVICIP81 Register bits
    namespace nvicip81_bits {
        constexpr uint32_t PRI81 = (8 << 0);  ///< Priority of interrupt 81
    }

    /// NVICIP82 Register bits
    namespace nvicip82_bits {
        constexpr uint32_t PRI82 = (8 << 0);  ///< Priority of interrupt 82
    }

    /// NVICIP83 Register bits
    namespace nvicip83_bits {
        constexpr uint32_t PRI83 = (8 << 0);  ///< Priority of interrupt 83
    }

    /// NVICIP84 Register bits
    namespace nvicip84_bits {
        constexpr uint32_t PRI84 = (8 << 0);  ///< Priority of interrupt 84
    }

    /// NVICIP85 Register bits
    namespace nvicip85_bits {
        constexpr uint32_t PRI85 = (8 << 0);  ///< Priority of interrupt 85
    }

    /// NVICIP86 Register bits
    namespace nvicip86_bits {
        constexpr uint32_t PRI86 = (8 << 0);  ///< Priority of interrupt 86
    }

    /// NVICIP87 Register bits
    namespace nvicip87_bits {
        constexpr uint32_t PRI87 = (8 << 0);  ///< Priority of interrupt 87
    }

    /// NVICIP88 Register bits
    namespace nvicip88_bits {
        constexpr uint32_t PRI88 = (8 << 0);  ///< Priority of interrupt 88
    }

    /// NVICIP89 Register bits
    namespace nvicip89_bits {
        constexpr uint32_t PRI89 = (8 << 0);  ///< Priority of interrupt 89
    }

    /// NVICIP90 Register bits
    namespace nvicip90_bits {
        constexpr uint32_t PRI90 = (8 << 0);  ///< Priority of interrupt 90
    }

    /// NVICIP91 Register bits
    namespace nvicip91_bits {
        constexpr uint32_t PRI91 = (8 << 0);  ///< Priority of interrupt 91
    }

    /// NVICIP92 Register bits
    namespace nvicip92_bits {
        constexpr uint32_t PRI92 = (8 << 0);  ///< Priority of interrupt 92
    }

    /// NVICIP93 Register bits
    namespace nvicip93_bits {
        constexpr uint32_t PRI93 = (8 << 0);  ///< Priority of interrupt 93
    }

    /// NVICIP94 Register bits
    namespace nvicip94_bits {
        constexpr uint32_t PRI94 = (8 << 0);  ///< Priority of interrupt 94
    }

    /// NVICIP95 Register bits
    namespace nvicip95_bits {
        constexpr uint32_t PRI95 = (8 << 0);  ///< Priority of interrupt 95
    }

    /// NVICIP96 Register bits
    namespace nvicip96_bits {
        constexpr uint32_t PRI96 = (8 << 0);  ///< Priority of interrupt 96
    }

    /// NVICIP97 Register bits
    namespace nvicip97_bits {
        constexpr uint32_t PRI97 = (8 << 0);  ///< Priority of interrupt 97
    }

    /// NVICIP98 Register bits
    namespace nvicip98_bits {
        constexpr uint32_t PRI98 = (8 << 0);  ///< Priority of interrupt 98
    }

    /// NVICIP99 Register bits
    namespace nvicip99_bits {
        constexpr uint32_t PRI99 = (8 << 0);  ///< Priority of interrupt 99
    }

    /// NVICIP100 Register bits
    namespace nvicip100_bits {
        constexpr uint32_t PRI100 = (8 << 0);  ///< Priority of interrupt 100
    }

    /// NVICIP101 Register bits
    namespace nvicip101_bits {
        constexpr uint32_t PRI101 = (8 << 0);  ///< Priority of interrupt 101
    }

    /// NVICIP102 Register bits
    namespace nvicip102_bits {
        constexpr uint32_t PRI102 = (8 << 0);  ///< Priority of interrupt 102
    }

    /// NVICIP103 Register bits
    namespace nvicip103_bits {
        constexpr uint32_t PRI103 = (8 << 0);  ///< Priority of interrupt 103
    }

    /// NVICIP104 Register bits
    namespace nvicip104_bits {
        constexpr uint32_t PRI104 = (8 << 0);  ///< Priority of interrupt 104
    }

    /// NVICIP105 Register bits
    namespace nvicip105_bits {
        constexpr uint32_t PRI105 = (8 << 0);  ///< Priority of interrupt 105
    }

    /// NVICSTIR Register bits
    namespace nvicstir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar switch (AXBS) slave configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar switch (AXBS) master configuration
        volatile uint32_t SRAMAP;  ///< Offset: 0x0C - SRAM arbitration and protection
        volatile uint32_t ISR;  ///< Offset: 0x10 - Interrupt status register
        volatile uint32_t ETBCC;  ///< Offset: 0x14 - ETB counter control register
        volatile uint32_t ETBRL;  ///< Offset: 0x18 - ETB reload register
        volatile uint32_t ETBCNT;  ///< Offset: 0x1C - ETB counter value register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates if there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates if there is a corresponding connection to the AXBS master input port.
    }

    /// SRAMAP Register bits
    namespace sramap_bits {
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L write protect
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t IRQ = (1U << 1);  ///< Normal interrupt pending
        constexpr uint32_t NMI = (1U << 2);  ///< Non-maskable interrupt pending
    }

    /// ETBCC Register bits
    namespace etbcc_bits {
        constexpr uint32_t CNTEN = (1U << 0);  ///< Counter enable
        constexpr uint32_t RSPT = (2 << 1);  ///< Response type
        constexpr uint32_t RLRQ = (1U << 3);  ///< Reload request
        constexpr uint32_t ETDIS = (1U << 4);  ///< ETM-to-TPIU disable
        constexpr uint32_t ITDIS = (1U << 5);  ///< ITM-to-TPIU disable
    }

    /// ETBRL Register bits
    namespace etbrl_bits {
        constexpr uint32_t RELOAD = (11 << 0);  ///< Byte count reload value
    }

    /// ETBCNT Register bits
    namespace etbcnt_bits {
        constexpr uint32_t COUNTER = (11 << 0);  ///< Byte count counter value
    }

}


} // namespace alloy::generated::mk30dz10

#endif // ALLOY_GENERATED_MK30DZ10_PERIPHERALS_HPP