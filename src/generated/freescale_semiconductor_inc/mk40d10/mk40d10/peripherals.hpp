/// Auto-generated code for MK40D10
/// Generated by Alloy Code Generator
/// Source: nxp_mk40.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:05
#ifndef ALLOY_GENERATED_MK40D10_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK40D10_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mk40d10 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_ftfl = true;
    constexpr uint32_t num_ftfl_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 6;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_sdhc = true;
    constexpr uint32_t num_sdhc_instances = 1;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfl_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_uart0 = true;
    constexpr bool has_uart1 = true;
    constexpr bool has_uart2 = true;
    constexpr bool has_uart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_uart5 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFL_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL_FlashConfig = reinterpret_cast<Registers*>(FTFL_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t EZPORT_DIS = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master Privilege Level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master Trusted For Writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master Trusted For Read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master Privilege Level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master Trusted For Writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master Trusted For Read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL5 = (1U << 8);  ///< Master Privilege Level
        constexpr uint32_t MTW5 = (1U << 9);  ///< Master Trusted For Writes
        constexpr uint32_t MTR5 = (1U << 10);  ///< Master Trusted For Read
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master Privilege Level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master Trusted For Writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master Trusted For Read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master privilege level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master trusted for writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master trusted for read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS;  ///< Offset: 0x00 - Priority Registers Slave (renamed from PRS)
        volatile uint32_t CRS;  ///< Offset: 0x10 - Control Register (renamed from CRS)
        volatile uint32_t MGPCR0;  ///< Offset: 0x800 - Master General Purpose Control Register
        volatile uint32_t MGPCR1;  ///< Offset: 0x900 - Master General Purpose Control Register
        volatile uint32_t MGPCR2;  ///< Offset: 0xA00 - Master General Purpose Control Register
        volatile uint32_t MGPCR4;  ///< Offset: 0xC00 - Master General Purpose Control Register
        volatile uint32_t MGPCR5;  ///< Offset: 0xD00 - Master General Purpose Control Register
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS Register bits
    namespace prs_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M3 = (3 << 12);  ///< Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M4 = (3 << 16);  ///< Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M5 = (3 << 20);  ///< Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS Register bits
    namespace crs_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking Control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration Mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt Low Priority
        constexpr uint32_t RO = (1U << 31);  ///< Read Only
    }

    /// MGPCR0 Register bits
    namespace mgpcr0_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR1 Register bits
    namespace mgpcr1_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR2 Register bits
    namespace mgpcr2_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR4 Register bits
    namespace mgpcr4_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

    /// MGPCR5 Register bits
    namespace mgpcr5_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Enabled and... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Cancelled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Cancelled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set enable request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination Data Transfer Size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo.
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Chip Select Address Register (renamed from CSAR)
        volatile uint32_t CSMR;  ///< Offset: 0x04 - Chip Select Mask Register (renamed from CSMR)
        volatile uint32_t CSCR;  ///< Offset: 0x08 - Chip Select Control Register (renamed from CSCR)
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip Select port Multiplexing Control Register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t BA = (16 << 16);  ///< Base Address
    }

    /// CSMR Register bits
    namespace csmr_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t WP = (1U << 8);  ///< Write Protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base Address Mask
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-Write Enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-Read Enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-Enable Mode
        constexpr uint32_t PS = (2 << 6);  ///< Port Size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-Acknowledge Enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-Lane Shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait States
        constexpr uint32_t WRAH = (2 << 16);  ///< Write Address Hold or Deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read Address Hold or Deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address Setup
        constexpr uint32_t EXTS = (1U << 22);  ///< Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary Wait State Enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary Wait States
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus Signal Group 5 Multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus Signal Group 4 Multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus Signal Group 3 Multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus Signal Group 2 Multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus Signal Group 1 Multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, slave port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, slave port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
        volatile uint32_t PFB1CR;  ///< Offset: 0x08 - Flash Bank 1 Control Register
        volatile uint32_t TAGVDW0S;  ///< Offset: 0x100 - Cache Tag Storage (renamed from TAGVDW0S)
        volatile uint32_t TAGVDW1S;  ///< Offset: 0x120 - Cache Tag Storage (renamed from TAGVDW1S)
        volatile uint32_t TAGVDW2S;  ///< Offset: 0x140 - Cache Tag Storage (renamed from TAGVDW2S)
        volatile uint32_t TAGVDW3S;  ///< Offset: 0x160 - Cache Tag Storage (renamed from TAGVDW3S)
        volatile uint32_t DATAW0SU;  ///< Offset: 0x200 - Cache Data Storage (upper word) (renamed from DATAW0SU)
        volatile uint32_t DATAW0SL;  ///< Offset: 0x204 - Cache Data Storage (lower word) (renamed from DATAW0SL)
        volatile uint32_t DATAW1SU;  ///< Offset: 0x240 - Cache Data Storage (upper word) (renamed from DATAW1SU)
        volatile uint32_t DATAW1SL;  ///< Offset: 0x244 - Cache Data Storage (lower word) (renamed from DATAW1SL)
        volatile uint32_t DATAW2SU;  ///< Offset: 0x280 - Cache Data Storage (upper word) (renamed from DATAW2SU)
        volatile uint32_t DATAW2SL;  ///< Offset: 0x284 - Cache Data Storage (lower word) (renamed from DATAW2SL)
        volatile uint32_t DATAW3SU;  ///< Offset: 0x2C0 - Cache Data Storage (upper word) (renamed from DATAW3SU)
        volatile uint32_t DATAW3SL;  ///< Offset: 0x2C4 - Cache Data Storage (lower word) (renamed from DATAW3SL)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M4AP = (2 << 8);  ///< Master 4 Access Protection
        constexpr uint32_t M5AP = (2 << 10);  ///< Master 5 Access Protection
        constexpr uint32_t M6AP = (2 << 12);  ///< Master 6 Access Protection
        constexpr uint32_t M7AP = (2 << 14);  ///< Master 7 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
        constexpr uint32_t M4PFD = (1U << 20);  ///< Master 4 Prefetch Disable
        constexpr uint32_t M5PFD = (1U << 21);  ///< Master 5 Prefetch Disable
        constexpr uint32_t M6PFD = (1U << 22);  ///< Master 6 Prefetch Disable
        constexpr uint32_t M7PFD = (1U << 23);  ///< Master 7 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Bank 0 Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Bank 0 Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Bank 0 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

    /// PFB1CR Register bits
    namespace pfb1cr_bits {
        constexpr uint32_t B1SEBE = (1U << 0);  ///< Bank 1 Single Entry Buffer Enable
        constexpr uint32_t B1IPE = (1U << 1);  ///< Bank 1 Instruction Prefetch Enable
        constexpr uint32_t B1DPE = (1U << 2);  ///< Bank 1 Data Prefetch Enable
        constexpr uint32_t B1ICE = (1U << 3);  ///< Bank 1 Instruction Cache Enable
        constexpr uint32_t B1DCE = (1U << 4);  ///< Bank 1 Data Cache Enable
        constexpr uint32_t B1MW = (2 << 17);  ///< Bank 1 Memory Width
        constexpr uint32_t B1RWSC = (4 << 28);  ///< Bank 1 Read Wait State Control
    }

    /// TAGVDW0S Register bits
    namespace tagvdw0s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW1S Register bits
    namespace tagvdw1s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW2S Register bits
    namespace tagvdw2s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// TAGVDW3S Register bits
    namespace tagvdw3s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t tag = (13 << 6);  ///< 13-bit tag for cache entry
    }

    /// DATAW0SU Register bits
    namespace dataw0su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0SL Register bits
    namespace dataw0sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1SU Register bits
    namespace dataw1su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1SL Register bits
    namespace dataw1sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2SU Register bits
    namespace dataw2su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2SL Register bits
    namespace dataw2sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3SU Register bits
    namespace dataw3su_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3SL Register bits
    namespace dataw3sl_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// FTFL Peripheral
// ============================================================================

namespace ftfl {
    /// Base addresses
    constexpr uint32_t FTFL_BASE = 0x40020000;

    /// FTFL Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB;  ///< Offset: 0x04 - Flash Common Command Object Registers (renamed from FCCOB)
        volatile uint32_t FPROT;  ///< Offset: 0x10 - Program Flash Protection Registers (renamed from FPROT)
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFL = reinterpret_cast<Registers*>(FTFL_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< Flash Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< Flash memory configuration
        constexpr uint32_t SWAP = (1U << 3);  ///< Swap
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB Register bits
    namespace fccob_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< The FCCOB register provides a command code and relevant parameters to the memory controller
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;
    constexpr uint32_t CAN1_BASE = 0x400A4000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t RXIMR;  ///< Offset: 0x880 - Rx Individual Mask Registers (renamed from RXIMR)
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number Of The Last Message Buffer
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking And Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t WAKSRC = (1U << 19);  ///< Wake Up Source
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low-Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer Value
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< Bus Off Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN In Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN In Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< This bit indicates when CAN bus is in IDLE state
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUFLM = (32 << 0);  ///< Buffer MB i Mask
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF4TO0I = (5 << 0);  ///< Buffer MB i Interrupt Or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt Or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt Or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number Of Rx FIFO Filters
        constexpr uint32_t WRMFRZ = (1U << 28);  ///< Write-Access To Memory In Freeze Mode
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< CRC Transmitted
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR Register bits
    namespace rximr_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - DSPI Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - DSPI Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - DSPI Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - DSPI Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< Flushes the RX FIFO
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Timing Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< DSPI Configuration
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (5 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register (renamed from TDR)
        volatile uint32_t TFR;  ///< Offset: 0x40 - SAI Transmit FIFO Register (renamed from TFR)
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register (renamed from RDR)
        volatile uint32_t RFR;  ///< Offset: 0xC0 - SAI Receive FIFO Register (renamed from RFR)
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
        volatile uint32_t MDR;  ///< Offset: 0x104 - SAI MCLK Divide Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (3 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit Channel Enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR Register bits
    namespace tfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (3 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (2 << 16);  ///< Receive Channel Enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame Size
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR Register bits
    namespace rfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive Word Mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

    /// MDR Register bits
    namespace mdr_bits {
        constexpr uint32_t DIVIDE = (12 << 0);  ///< MCLK Divide
        constexpr uint32_t FRACT = (8 << 12);  ///< MCLK Fraction
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t CRC;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCH stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBDCD_BASE = 0x40035000;
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLOCK;  ///< Offset: 0x04 - Clock register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t TIMER0;  ///< Offset: 0x10 - TIMER0 register
        volatile uint32_t TIMER1;  ///< Offset: 0x14 - TIMER1 register
        volatile uint32_t TIMER2;  ///< Offset: 0x18 - TIMER2 register
    };

    /// Peripheral instances
    inline Registers* USBDCD = reinterpret_cast<Registers*>(USBDCD_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t IACK = (1U << 0);  ///< Interrupt Acknowledge
        constexpr uint32_t IF_ = (1U << 8);  ///< Interrupt Flag (renamed from IF_)
        constexpr uint32_t IE = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t START = (1U << 24);  ///< Start Change Detection Sequence
        constexpr uint32_t SR = (1U << 25);  ///< Software Reset
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLOCK_UNIT = (1U << 0);  ///< Unit of Measurement Encoding for Clock Speed
        constexpr uint32_t CLOCK_SPEED = (10 << 2);  ///< Numerical Value of Clock Speed in Binary
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SEQ_RES = (2 << 16);  ///< Charger Detection Sequence Results
        constexpr uint32_t SEQ_STAT = (2 << 18);  ///< Charger Detection Sequence Status
        constexpr uint32_t ERR = (1U << 20);  ///< Error Flag
        constexpr uint32_t TO = (1U << 21);  ///< Timeout Flag
        constexpr uint32_t ACTIVE = (1U << 22);  ///< Active Status Indicator
    }

    /// TIMER0 Register bits
    namespace timer0_bits {
        constexpr uint32_t TUNITCON = (12 << 0);  ///< Unit Connection Timer Elapse (in ms)
        constexpr uint32_t TSEQ_INIT = (10 << 16);  ///< Sequence Initiation Time
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t TVDPSRC_ON = (10 << 0);  ///< Time Period Comparator Enabled
        constexpr uint32_t TDCD_DBNC = (10 << 16);  ///< Time Period to Debounce D+ Signal
    }

    /// TIMER2 Register bits
    namespace timer2_bits {
        constexpr uint32_t CHECK_DM = (4 << 0);  ///< Time Before Check of D- Line
        constexpr uint32_t TVDPSRC_CON = (10 << 16);  ///< Time Period Before Enabling D+ Pullup
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control Register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus Register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter Register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay Register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control Register 1 (renamed from CHC1)
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status Register (renamed from CHS)
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 Register (renamed from CHDLY0)
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 Register (renamed from CHDLY1)
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control Register (renamed from DACINTC)
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n Register (renamed from DACINT)
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable Register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay Register (renamed from PODLY)
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable.
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT_ = (16 << 0);  ///< DAC Interval (renamed from INT_)
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x400B8000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x400BB000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t PGA;  ///< Offset: 0x50 - ADC PGA Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample time configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// PGA Register bits
    namespace pga_bits {
        constexpr uint32_t PGAG = (4 << 16);  ///< PGA Gain Setting
        constexpr uint32_t PGALPb = (1U << 20);  ///< PGA Low-Power Mode Control
        constexpr uint32_t PGAEN = (1U << 23);  ///< PGA Enable
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - General Control and Status register
        volatile uint32_t SCANC;  ///< Offset: 0x04 - SCAN Control register
        volatile uint32_t PEN;  ///< Offset: 0x08 - Pin Enable register
        volatile uint32_t WUCNTR;  ///< Offset: 0x0C - Wake-Up Channel Counter Register
        volatile uint32_t CNTR;  ///< Offset: 0x100 - Counter Register (renamed from CNTR)
        volatile uint32_t THRESHOLD;  ///< Offset: 0x120 - Low-Power Channel Threshold register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t STPE = (1U << 0);  ///< TSI STOP Enable while in low-power modes (STOP, VLPS, LLS, and VLLS{3,2,1}).
        constexpr uint32_t STM = (1U << 1);  ///< Scan Trigger Mode
        constexpr uint32_t ESOR = (1U << 4);  ///< End-of-Scan Or Out-of-Range Interrupt Select
        constexpr uint32_t ERIE = (1U << 5);  ///< Error Interrupt Enable
        constexpr uint32_t TSIIE = (1U << 6);  ///< Touch Sensing Input Interrupt Module Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t SWTS = (1U << 8);  ///< Software Trigger Start
        constexpr uint32_t SCNIP = (1U << 9);  ///< Scan In Progress Status
        constexpr uint32_t OVRF = (1U << 12);  ///< Overrun Error Flag
        constexpr uint32_t EXTERF = (1U << 13);  ///< External Electrode Error Occurred
        constexpr uint32_t OUTRGF = (1U << 14);  ///< Out of Range Flag
        constexpr uint32_t EOSF = (1U << 15);  ///< End of Scan Flag
        constexpr uint32_t PS = (3 << 16);  ///< Electrode Oscillator Prescaler
        constexpr uint32_t NSCN = (5 << 19);  ///< Number of Consecutive Scans Per Electrode Electrode
        constexpr uint32_t LPSCNITV = (4 << 24);  ///< TSI Low-Power Mode Scan Interval
        constexpr uint32_t LPCLKS = (1U << 28);  ///< Low-Power Mode Clock Source Selection
    }

    /// SCANC Register bits
    namespace scanc_bits {
        constexpr uint32_t AMPSC = (3 << 0);  ///< Active Mode Prescaler
        constexpr uint32_t AMCLKS = (2 << 3);  ///< Active Mode Clock Source
        constexpr uint32_t SMOD = (8 << 8);  ///< Scan Module
        constexpr uint32_t EXTCHRG = (4 << 16);  ///< External OSC Charge Current Select
        constexpr uint32_t REFCHRG = (4 << 24);  ///< Ref OSC Charge Current Select
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN0 = (1U << 0);  ///< Touch Sensing Input Pin Enable Register 0
        constexpr uint32_t PEN1 = (1U << 1);  ///< Touch Sensing Input Pin Enable Register 1
        constexpr uint32_t PEN2 = (1U << 2);  ///< Touch Sensing Input Pin Enable Register 2
        constexpr uint32_t PEN3 = (1U << 3);  ///< Touch Sensing Input Pin Enable Register 3
        constexpr uint32_t PEN4 = (1U << 4);  ///< Touch Sensing Input Pin Enable Register 4
        constexpr uint32_t PEN5 = (1U << 5);  ///< Touch Sensing Input Pin Enable Register 5
        constexpr uint32_t PEN6 = (1U << 6);  ///< Touch Sensing Input Pin Enable Register 6
        constexpr uint32_t PEN7 = (1U << 7);  ///< Touch Sensing Input Pin Enable Register 7
        constexpr uint32_t PEN8 = (1U << 8);  ///< Touch Sensing Input Pin Enable Register 8
        constexpr uint32_t PEN9 = (1U << 9);  ///< Touch Sensing Input Pin Enable Register 9
        constexpr uint32_t PEN10 = (1U << 10);  ///< Touch Sensing Input Pin Enable Register 10
        constexpr uint32_t PEN11 = (1U << 11);  ///< Touch Sensing Input Pin Enable Register 11
        constexpr uint32_t PEN12 = (1U << 12);  ///< Touch Sensing Input Pin Enable Register 12
        constexpr uint32_t PEN13 = (1U << 13);  ///< Touch Sensing Input Pin Enable Register 13
        constexpr uint32_t PEN14 = (1U << 14);  ///< Touch Sensing Input Pin Enable Register 14
        constexpr uint32_t PEN15 = (1U << 15);  ///< Touch Sensing Input Pin Enable Register 15
        constexpr uint32_t LPSP = (4 << 16);  ///< Low-Power Scan Pin
    }

    /// WUCNTR Register bits
    namespace wucntr_bits {
        constexpr uint32_t WUCNT = (16 << 0);  ///< Touch Sensing Wake-Up Channel 16-bit Counter Value
    }

    /// CNTR Register bits
    namespace cntr_bits {
        constexpr uint32_t CTN1 = (16 << 0);  ///< Touch Sensing Channel n-1 16-bit Counter Value
        constexpr uint32_t CTN = (16 << 16);  ///< Touch Sensing Channel n 16-bit Counter Value
    }

    /// THRESHOLD Register bits
    namespace threshold_bits {
        constexpr uint32_t HTHH = (16 << 0);  ///< Touch Sensing Channel High Threshold Value
        constexpr uint32_t LTHH = (16 << 16);  ///< Touch Sensing Channel Low Threshold Value
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t FBSL = (2 << 8);  ///< FlexBus security level
        constexpr uint32_t PTD7PAD = (1U << 11);  ///< PTD7 pad drive strength
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (1U << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
        constexpr uint32_t SDHCSRC = (2 << 28);  ///< SDHC clock source select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM0FLT2 = (1U << 2);  ///< FTM0 Fault 2 Select
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FTM2 Fault 0 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 20);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 External Clock Pin Select
        constexpr uint32_t FTM0TRG0SRC = (1U << 28);  ///< FlexTimer 0 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM0TRG1SRC = (1U << 29);  ///< FlexTimer 0 Hardware Trigger 1 Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t UART0TXSRC = (2 << 0);  ///< UART 0 transmit data source select
        constexpr uint32_t UART0RXSRC = (2 << 2);  ///< UART 0 receive data source select
        constexpr uint32_t UART1TXSRC = (2 << 4);  ///< UART 1 transmit data source select
        constexpr uint32_t UART1RXSRC = (2 << 6);  ///< UART 1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
        constexpr uint32_t ADC1TRGSEL = (4 << 8);  ///< ADC1 trigger select
        constexpr uint32_t ADC1PRETRGSEL = (1U << 12);  ///< ADC1 pre-trigger select
        constexpr uint32_t ADC1ALTTRGEN = (1U << 15);  ///< ADC1 alternate trigger enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t UART4 = (1U << 10);  ///< UART4 Clock Gate Control
        constexpr uint32_t UART5 = (1U << 11);  ///< UART5 Clock Gate Control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t DAC0 = (1U << 12);  ///< DAC0 Clock Gate Control
        constexpr uint32_t DAC1 = (1U << 13);  ///< DAC1 Clock Gate Control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t FLEXCAN1 = (1U << 4);  ///< FlexCAN1 Clock Gate Control
        constexpr uint32_t SPI2 = (1U << 12);  ///< SPI2 Clock Gate Control
        constexpr uint32_t SDHC = (1U << 17);  ///< SDHC Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 24);  ///< FTM2 Clock Gate Control
        constexpr uint32_t ADC1 = (1U << 27);  ///< ADC1 Clock Gate Control
        constexpr uint32_t SLCD = (1U << 30);  ///< Segment LCD Clock Gate Control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART0 = (1U << 10);  ///< UART0 Clock Gate Control
        constexpr uint32_t UART1 = (1U << 11);  ///< UART1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t UART3 = (1U << 13);  ///< UART3 Clock Gate Control
        constexpr uint32_t USBOTG = (1U << 18);  ///< USB Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
        constexpr uint32_t LLWU = (1U << 28);  ///< LLWU Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTIMER = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Clock Gate Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTFL = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t FLEXCAN0 = (1U << 4);  ///< FlexCAN0 Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t USBDCD = (1U << 21);  ///< USB DCD Clock Gate Control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFRAC = (1U << 0);  ///< USB clock divider fraction
        constexpr uint32_t USBDIV = (3 << 1);  ///< USB clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t DEPART = (4 << 8);  ///< FlexNVM partition
        constexpr uint32_t EESIZE = (4 << 16);  ///< EEPROM size
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t PFLSH = (1U << 23);  ///< Program flash
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
        constexpr uint32_t SWAPPFLSH = (1U << 31);  ///< Swap program flash
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR;  ///< Offset: 0x00 - Pin Control Register n (renamed from PCR)
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enables Windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in Stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in Wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< Controls the upper mark periods of the modulator for all modes.
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< Controls the lower mark periods of the modulator for all modes.
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< Controls the upper space periods of the modulator for all modes.
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< Controls the lower space periods of the modulator for all modes.
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
        volatile uint32_t C9;  ///< Offset: 0x0E - MCG Control 9 Register
        volatile uint32_t C10;  ///< Offset: 0x0F - MCG Control 10 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV0 = (5 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN0 = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN0 = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV0 = (5 << 0);  ///< VCO 0 Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (1U << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< The MULT bits define the multiplier factor mul
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (5 << 0);  ///< I2C Programmable Filter Factor
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Most significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< Least significant byte of SCL low timeout value that determines the timeout period of SCL low.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t UART0_BASE = 0x4006A000;
    constexpr uint32_t UART1_BASE = 0x4006B000;
    constexpr uint32_t UART2_BASE = 0x4006C000;
    constexpr uint32_t UART3_BASE = 0x4006D000;
    constexpr uint32_t UART4_BASE = 0x400EA000;
    constexpr uint32_t UART5_BASE = 0x400EB000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BDH;  ///< Offset: 0x00 - UART Baud Rate Registers: High
        volatile uint32_t BDL;  ///< Offset: 0x01 - UART Baud Rate Registers: Low
        volatile uint32_t C1;  ///< Offset: 0x02 - UART Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x03 - UART Control Register 2
        volatile uint32_t S1;  ///< Offset: 0x04 - UART Status Register 1
        volatile uint32_t S2;  ///< Offset: 0x05 - UART Status Register 2
        volatile uint32_t C3;  ///< Offset: 0x06 - UART Control Register 3
        volatile uint32_t D;  ///< Offset: 0x07 - UART Data Register
        volatile uint32_t MA1;  ///< Offset: 0x08 - UART Match Address Registers 1
        volatile uint32_t MA2;  ///< Offset: 0x09 - UART Match Address Registers 2
        volatile uint32_t C4;  ///< Offset: 0x0A - UART Control Register 4
        volatile uint32_t C5;  ///< Offset: 0x0B - UART Control Register 5
        volatile uint32_t ED;  ///< Offset: 0x0C - UART Extended Data Register
        volatile uint32_t MODEM;  ///< Offset: 0x0D - UART Modem Register
        volatile uint32_t IR;  ///< Offset: 0x0E - UART Infrared Register
        volatile uint32_t PFIFO;  ///< Offset: 0x10 - UART FIFO Parameters
        volatile uint32_t CFIFO;  ///< Offset: 0x11 - UART FIFO Control Register
        volatile uint32_t SFIFO;  ///< Offset: 0x12 - UART FIFO Status Register
        volatile uint32_t TWFIFO;  ///< Offset: 0x13 - UART FIFO Transmit Watermark
        volatile uint32_t TCFIFO;  ///< Offset: 0x14 - UART FIFO Transmit Count
        volatile uint32_t RWFIFO;  ///< Offset: 0x15 - UART FIFO Receive Watermark
        volatile uint32_t RCFIFO;  ///< Offset: 0x16 - UART FIFO Receive Count
        volatile uint32_t C7816;  ///< Offset: 0x18 - UART 7816 Control Register
        volatile uint32_t IE7816;  ///< Offset: 0x19 - UART 7816 Interrupt Enable Register
        volatile uint32_t IS7816;  ///< Offset: 0x1A - UART 7816 Interrupt Status Register
        volatile uint32_t WP7816T0;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WP7816T1;  ///< Offset: 0x1B - UART 7816 Wait Parameter Register
        volatile uint32_t WN7816;  ///< Offset: 0x1C - UART 7816 Wait N Register
        volatile uint32_t WF7816;  ///< Offset: 0x1D - UART 7816 Wait FD Register
        volatile uint32_t ET7816;  ///< Offset: 0x1E - UART 7816 Error Threshold Register
        volatile uint32_t TL7816;  ///< Offset: 0x1F - UART 7816 Transmit Length Register
        volatile uint32_t C6;  ///< Offset: 0x21 - UART CEA709.1-B Control Register 6
        volatile uint32_t PCTH;  ///< Offset: 0x22 - UART CEA709.1-B Packet Cycle Time Counter High
        volatile uint32_t PCTL;  ///< Offset: 0x23 - UART CEA709.1-B Packet Cycle Time Counter Low
        volatile uint32_t B1T;  ///< Offset: 0x24 - UART CEA709.1-B Beta1 Timer
        volatile uint32_t SDTH;  ///< Offset: 0x25 - UART CEA709.1-B Secondary Delay Timer High
        volatile uint32_t SDTL;  ///< Offset: 0x26 - UART CEA709.1-B Secondary Delay Timer Low
        volatile uint32_t PRE;  ///< Offset: 0x27 - UART CEA709.1-B Preamble
        volatile uint32_t TPL;  ///< Offset: 0x28 - UART CEA709.1-B Transmit Packet Length
        volatile uint32_t IE;  ///< Offset: 0x29 - UART CEA709.1-B Interrupt Enable Register
        volatile uint32_t WB;  ///< Offset: 0x2A - UART CEA709.1-B WBASE
        volatile uint32_t S3;  ///< Offset: 0x2B - UART CEA709.1-B Status Register
        volatile uint32_t S4;  ///< Offset: 0x2C - UART CEA709.1-B Status Register
        volatile uint32_t RPL;  ///< Offset: 0x2D - UART CEA709.1-B Received Packet Length
        volatile uint32_t RPREL;  ///< Offset: 0x2E - UART CEA709.1-B Received Preamble Length
        volatile uint32_t CPW;  ///< Offset: 0x2F - UART CEA709.1-B Collision Pulse Width
        volatile uint32_t RIDT;  ///< Offset: 0x30 - UART CEA709.1-B Receive Indeterminate Time
        volatile uint32_t TIDT;  ///< Offset: 0x31 - UART CEA709.1-B Transmit Indeterminate Time
    };

    /// Peripheral instances
    inline Registers* UART0 = reinterpret_cast<Registers*>(UART0_BASE);
    inline Registers* UART1 = reinterpret_cast<Registers*>(UART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);
    inline Registers* UART3 = reinterpret_cast<Registers*>(UART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);

    // Bit definitions
    /// BDH Register bits
    namespace bdh_bits {
        constexpr uint32_t SBR = (5 << 0);  ///< UART Baud Rate Bits
        constexpr uint32_t RXEDGIE = (1U << 6);  ///< RxD Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 7);  ///< LIN Break Detect Interrupt Enable
    }

    /// BDL Register bits
    namespace bdl_bits {
        constexpr uint32_t SBR = (8 << 0);  ///< UART Baud Rate Bits
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-bit or 8-bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t UARTSWAI = (1U << 6);  ///< UART Stops in Wait Mode
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SBK = (1U << 0);  ///< Send Break
        constexpr uint32_t RWU = (1U << 1);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 2);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 4);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 5);  ///< Receiver Full Interrupt or DMA Transfer Enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission Complete Interrupt Enable
        constexpr uint32_t TIE = (1U << 7);  ///< Transmitter Interrupt or DMA Transfer Enable.
    }

    /// S1 Register bits
    namespace s1_bits {
        constexpr uint32_t PF = (1U << 0);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 1);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 2);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 3);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 4);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 5);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 6);  ///< Transmit Complete Flag
        constexpr uint32_t TDRE = (1U << 7);  ///< Transmit Data Register Empty Flag
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t RAF = (1U << 0);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 1);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 2);  ///< Break Transmit Character Length
        constexpr uint32_t RWUID = (1U << 3);  ///< Receive Wakeup Idle Detect
        constexpr uint32_t RXINV = (1U << 4);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 5);  ///< Most Significant Bit First
        constexpr uint32_t RXEDGIF = (1U << 6);  ///< RxD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 7);  ///< LIN Break Detect Interrupt Flag
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t PEIE = (1U << 0);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 1);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 2);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 3);  ///< Overrun Error Interrupt Enable
        constexpr uint32_t TXINV = (1U << 4);  ///< Transmit Data Inversion.
        constexpr uint32_t TXDIR = (1U << 5);  ///< Transmitter Pin Data Direction in Single-Wire mode
        constexpr uint32_t T8 = (1U << 6);  ///< Transmit Bit 8
        constexpr uint32_t R8 = (1U << 7);  ///< Received Bit 8
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t RT = (8 << 0);  ///< Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
    }

    /// MA1 Register bits
    namespace ma1_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// MA2 Register bits
    namespace ma2_bits {
        constexpr uint32_t MA = (8 << 0);  ///< Match Address
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t BRFA = (5 << 0);  ///< Baud Rate Fine Adjust
        constexpr uint32_t M10 = (1U << 5);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 6);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 7);  ///< Match Address Mode Enable 1
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t RDMAS = (1U << 5);  ///< Receiver Full DMA Select
        constexpr uint32_t TDMAS = (1U << 7);  ///< Transmitter DMA Select
    }

    /// ED Register bits
    namespace ed_bits {
        constexpr uint32_t PARITYE = (1U << 6);  ///< The current received dataword contained in D and C3[R8] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 7);  ///< The current received dataword contained in D and C3[R8] was received with noise.
    }

    /// MODEM Register bits
    namespace modem_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
    }

    /// IR Register bits
    namespace ir_bits {
        constexpr uint32_t TNP = (2 << 0);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 2);  ///< Infrared enable
    }

    /// PFIFO Register bits
    namespace pfifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
    }

    /// CFIFO Register bits
    namespace cfifo_bits {
        constexpr uint32_t RXUFE = (1U << 0);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 1);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXOFE = (1U << 2);  ///< Receive FIFO Overflow Interrupt Enable
        constexpr uint32_t RXFLUSH = (1U << 6);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 7);  ///< Transmit FIFO/Buffer Flush
    }

    /// SFIFO Register bits
    namespace sfifo_bits {
        constexpr uint32_t RXUF = (1U << 0);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 1);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXOF = (1U << 2);  ///< Receiver Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 6);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 7);  ///< Transmit Buffer/FIFO Empty
    }

    /// TWFIFO Register bits
    namespace twfifo_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
    }

    /// TCFIFO Register bits
    namespace tcfifo_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit Counter
    }

    /// RWFIFO Register bits
    namespace rwfifo_bits {
        constexpr uint32_t RXWATER = (8 << 0);  ///< Receive Watermark
    }

    /// RCFIFO Register bits
    namespace rcfifo_bits {
        constexpr uint32_t RXCOUNT = (8 << 0);  ///< Receive Counter
    }

    /// C7816 Register bits
    namespace c7816_bits {
        constexpr uint32_t ISO_7816E = (1U << 0);  ///< ISO-7816 Functionality Enabled
        constexpr uint32_t TTYPE = (1U << 1);  ///< Transfer Type
        constexpr uint32_t INIT = (1U << 2);  ///< Detect Initial Character
        constexpr uint32_t ANACK = (1U << 3);  ///< Generate NACK on Error
        constexpr uint32_t ONACK = (1U << 4);  ///< Generate NACK on Overflow
    }

    /// IE7816 Register bits
    namespace ie7816_bits {
        constexpr uint32_t RXTE = (1U << 0);  ///< Receive Threshold Exceeded Interrupt Enable
        constexpr uint32_t TXTE = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt Enable
        constexpr uint32_t GTVE = (1U << 2);  ///< Guard Timer Violated Interrupt Enable
        constexpr uint32_t INITDE = (1U << 4);  ///< Initial Character Detected Interrupt Enable
        constexpr uint32_t BWTE = (1U << 5);  ///< Block Wait Timer Interrupt Enable
        constexpr uint32_t CWTE = (1U << 6);  ///< Character Wait Timer Interrupt Enable
        constexpr uint32_t WTE = (1U << 7);  ///< Wait Timer Interrupt Enable
    }

    /// IS7816 Register bits
    namespace is7816_bits {
        constexpr uint32_t RXT = (1U << 0);  ///< Receive Threshold Exceeded Interrupt
        constexpr uint32_t TXT = (1U << 1);  ///< Transmit Threshold Exceeded Interrupt
        constexpr uint32_t GTV = (1U << 2);  ///< Guard Timer Violated Interrupt
        constexpr uint32_t INITD = (1U << 4);  ///< Initial Character Detected Interrupt
        constexpr uint32_t BWT = (1U << 5);  ///< Block Wait Timer Interrupt
        constexpr uint32_t CWT = (1U << 6);  ///< Character Wait Timer Interrupt
        constexpr uint32_t WT = (1U << 7);  ///< Wait Timer Interrupt
    }

    /// WP7816T0 Register bits
    namespace wp7816t0_bits {
        constexpr uint32_t WI = (8 << 0);  ///< Wait Timer Interrupt (C7816[TTYPE] = 0)
    }

    /// WP7816T1 Register bits
    namespace wp7816t1_bits {
        constexpr uint32_t BWI = (4 << 0);  ///< Block Wait Time Integer(C7816[TTYPE] = 1)
        constexpr uint32_t CWI = (4 << 4);  ///< Character Wait Time Integer (C7816[TTYPE] = 1)
    }

    /// WN7816 Register bits
    namespace wn7816_bits {
        constexpr uint32_t GTN = (8 << 0);  ///< Guard Band N
    }

    /// WF7816 Register bits
    namespace wf7816_bits {
        constexpr uint32_t GTFD = (8 << 0);  ///< FD Multiplier
    }

    /// ET7816 Register bits
    namespace et7816_bits {
        constexpr uint32_t RXTHRESHOLD = (4 << 0);  ///< Receive NACK Threshold
        constexpr uint32_t TXTHRESHOLD = (4 << 4);  ///< Transmit NACK Threshold
    }

    /// TL7816 Register bits
    namespace tl7816_bits {
        constexpr uint32_t TLEN = (8 << 0);  ///< Transmit Length
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t CP = (1U << 4);  ///< Collision Signal Polarity
        constexpr uint32_t CE = (1U << 5);  ///< Collision Enable
        constexpr uint32_t TX709 = (1U << 6);  ///< CEA709.1-B Transmit Enable
        constexpr uint32_t EN709 = (1U << 7);  ///< EN709
    }

    /// PCTH Register bits
    namespace pcth_bits {
        constexpr uint32_t PCTH = (8 << 0);  ///< Packet Cycle Time Counter High
    }

    /// PCTL Register bits
    namespace pctl_bits {
        constexpr uint32_t PCTL = (8 << 0);  ///< Packet Cycle Time Counter Low
    }

    /// B1T Register bits
    namespace b1t_bits {
        constexpr uint32_t B1T = (8 << 0);  ///< Beta1 Timer
    }

    /// SDTH Register bits
    namespace sdth_bits {
        constexpr uint32_t SDTH = (8 << 0);  ///< Secondary Delay Timer High
    }

    /// SDTL Register bits
    namespace sdtl_bits {
        constexpr uint32_t SDTL = (8 << 0);  ///< Secondary Delay Timer Low
    }

    /// PRE Register bits
    namespace pre_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< CEA709.1-B Preamble Register
    }

    /// TPL Register bits
    namespace tpl_bits {
        constexpr uint32_t TPL = (8 << 0);  ///< Transmit Packet Length Register
    }

    /// IE Register bits
    namespace ie_bits {
        constexpr uint32_t TXFIE = (1U << 0);  ///< Transmission Fail Interrupt Enable
        constexpr uint32_t PSIE = (1U << 1);  ///< Preamble Start Interrupt Enable
        constexpr uint32_t PCTEIE = (1U << 2);  ///< Packet Cycle Timer Interrupt Enable
        constexpr uint32_t PTXIE = (1U << 3);  ///< Packet Transmitted Interrupt Enable
        constexpr uint32_t PRXIE = (1U << 4);  ///< Packet Received Interrupt Enable
        constexpr uint32_t ISDIE = (1U << 5);  ///< Initial Sync Detection Interrupt Enable
        constexpr uint32_t WBEIE = (1U << 6);  ///< WBASE Expired Interrupt Enable
    }

    /// WB Register bits
    namespace wb_bits {
        constexpr uint32_t WBASE = (8 << 0);  ///< CEA709.1-B WBASE register
    }

    /// S3 Register bits
    namespace s3_bits {
        constexpr uint32_t TXFF = (1U << 0);  ///< Transmission Fail Flag
        constexpr uint32_t PSF = (1U << 1);  ///< Preamble Start Flag
        constexpr uint32_t PCTEF = (1U << 2);  ///< Packet Cycle Timer Expired Flag
        constexpr uint32_t PTXF = (1U << 3);  ///< Packet Transmitted Flag
        constexpr uint32_t PRXF = (1U << 4);  ///< Packet Received Flag
        constexpr uint32_t ISD = (1U << 5);  ///< Initial Sync Detect
        constexpr uint32_t WBEF = (1U << 6);  ///< Wbase Expired Flag
        constexpr uint32_t PEF = (1U << 7);  ///< Preamble Error Flag
    }

    /// S4 Register bits
    namespace s4_bits {
        constexpr uint32_t FE = (1U << 0);  ///< Framing Error
        constexpr uint32_t ILCV = (1U << 1);  ///< Improper Line Code Violation
        constexpr uint32_t CDET = (2 << 2);  ///< CDET
        constexpr uint32_t INITF = (1U << 4);  ///< Initial Synchronization Fail Flag
    }

    /// RPL Register bits
    namespace rpl_bits {
        constexpr uint32_t RPL = (8 << 0);  ///< Received Packet Length
    }

    /// RPREL Register bits
    namespace rprel_bits {
        constexpr uint32_t RPREL = (8 << 0);  ///< Received Preamble Length
    }

    /// CPW Register bits
    namespace cpw_bits {
        constexpr uint32_t CPW = (8 << 0);  ///< CEA709.1-B CPW register
    }

    /// RIDT Register bits
    namespace ridt_bits {
        constexpr uint32_t RIDT = (8 << 0);  ///< CEA709.1-B Receive IDT register
    }

    /// TIDT Register bits
    namespace tidt_bits {
        constexpr uint32_t TIDT = (8 << 0);  ///< CEA709.1-B Transmit IDT Register
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 6);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 6);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40073010;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 6);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
        volatile uint32_t RST;  ///< Offset: 0x0A - LLWU Reset Enable register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// RST Register bits
    namespace rst_bits {
        constexpr uint32_t RSTFILT = (1U << 0);  ///< Digital Filter On RESET Pin
        constexpr uint32_t LLRSTE = (1U << 1);  ///< Low-Leakage Mode RESET Enable
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t VLLSCTRL;  ///< Offset: 0x02 - VLLS Control register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
        constexpr uint32_t LPWUI = (1U << 7);  ///< Low-Power Wake Up On Interrupt
    }

    /// VLLSCTRL Register bits
    namespace vllsctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t RAM2PO = (1U << 4);  ///< RAM2 Power Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (7 << 0);  ///< When debug is enabled, the PMSTAT will not update to STOP or VLPS
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG Generated Reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t EZPT = (1U << 4);  ///< EzPort Reset
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t EZP_MS = (1U << 1);  ///< EZP_MS_B pin state
    }

}

// ============================================================================
// SDHC Peripheral
// ============================================================================

namespace sdhc {
    /// Base addresses
    constexpr uint32_t SDHC_BASE = 0x400B1000;

    /// SDHC Register structure
    struct Registers {
        volatile uint32_t DSADDR;  ///< Offset: 0x00 - DMA System Address register
        volatile uint32_t BLKATTR;  ///< Offset: 0x04 - Block Attributes register
        volatile uint32_t CMDARG;  ///< Offset: 0x08 - Command Argument register
        volatile uint32_t XFERTYP;  ///< Offset: 0x0C - Transfer Type register
        volatile uint32_t CMDRSP0;  ///< Offset: 0x10 - Command Response 0
        volatile uint32_t CMDRSP1;  ///< Offset: 0x14 - Command Response 1
        volatile uint32_t CMDRSP2;  ///< Offset: 0x18 - Command Response 2
        volatile uint32_t CMDRSP3;  ///< Offset: 0x1C - Command Response 3
        volatile uint32_t DATPORT;  ///< Offset: 0x20 - Buffer Data Port register
        volatile uint32_t PRSSTAT;  ///< Offset: 0x24 - Present State register
        volatile uint32_t PROCTL;  ///< Offset: 0x28 - Protocol Control register
        volatile uint32_t SYSCTL;  ///< Offset: 0x2C - System Control register
        volatile uint32_t IRQSTAT;  ///< Offset: 0x30 - Interrupt Status register
        volatile uint32_t IRQSTATEN;  ///< Offset: 0x34 - Interrupt Status Enable register
        volatile uint32_t IRQSIGEN;  ///< Offset: 0x38 - Interrupt Signal Enable register
        volatile uint32_t AC12ERR;  ///< Offset: 0x3C - Auto CMD12 Error Status Register
        volatile uint32_t HTCAPBLT;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WML;  ///< Offset: 0x44 - Watermark Level Register
        volatile uint32_t FEVT;  ///< Offset: 0x50 - Force Event register
        volatile uint32_t ADMAES;  ///< Offset: 0x54 - ADMA Error Status register
        volatile uint32_t ADSADDR;  ///< Offset: 0x58 - ADMA System Addressregister
        volatile uint32_t VENDOR;  ///< Offset: 0xC0 - Vendor Specific register
        volatile uint32_t MMCBOOT;  ///< Offset: 0xC4 - MMC Boot register
        volatile uint32_t HOSTVER;  ///< Offset: 0xFC - Host Controller Version
    };

    /// Peripheral instances
    inline Registers* SDHC = reinterpret_cast<Registers*>(SDHC_BASE);

    // Bit definitions
    /// DSADDR Register bits
    namespace dsaddr_bits {
        constexpr uint32_t DSADDR = (30 << 2);  ///< DMA System Address
    }

    /// BLKATTR Register bits
    namespace blkattr_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Transfer Block Size
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Blocks Count For Current Transfer
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// XFERTYP Register bits
    namespace xfertyp_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Select
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMDRSP0 Register bits
    namespace cmdrsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMDRSP1 Register bits
    namespace cmdrsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMDRSP2 Register bits
    namespace cmdrsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMDRSP3 Register bits
    namespace cmdrsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATPORT Register bits
    namespace datport_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRSSTAT Register bits
    namespace prsstat_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< Bus Clock Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< System Clock Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< SDHC clock Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t CINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DAT Line Signal Level
    }

    /// PROCTL Register bits
    namespace proctl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DAT3 As Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMAS = (2 << 8);  ///< DMA Select
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
    }

    /// SYSCTL Register bits
    namespace sysctl_bits {
        constexpr uint32_t IPGEN = (1U << 0);  ///< IPG Clock Enable
        constexpr uint32_t HCKEN = (1U << 1);  ///< System Clock Enable
        constexpr uint32_t PEREN = (1U << 2);  ///< Peripheral Clock Enable
        constexpr uint32_t SDCLKEN = (1U << 3);  ///< SD Clock Enable
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DAT Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
    }

    /// IRQSTAT Register bits
    namespace irqstat_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// IRQSTATEN Register bits
    namespace irqstaten_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// IRQSIGEN Register bits
    namespace irqsigen_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Enable
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AC12ERR Register bits
    namespace ac12err_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
    }

    /// HTCAPBLT Register bits
    namespace htcapblt_bits {
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3 V
        constexpr uint32_t VS30 = (1U << 25);  ///< Voltage Support 3.0 V
        constexpr uint32_t VS18 = (1U << 26);  ///< Voltage Support 1.8 V
    }

    /// WML Register bits
    namespace wml_bits {
        constexpr uint32_t RDWML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t WRWML = (8 << 16);  ///< Write Watermark Level
    }

    /// FEVT Register bits
    namespace fevt_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t AC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t AC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t CTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t CCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t DCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t CINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMAES Register bits
    namespace admaes_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (When ADMA Error Is Occurred.)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descriptor Error
    }

    /// ADSADDR Register bits
    namespace adsaddr_bits {
        constexpr uint32_t ADSADDR = (30 << 2);  ///< ADMA System Address
    }

    /// VENDOR Register bits
    namespace vendor_bits {
        constexpr uint32_t EXTDMAEN = (1U << 0);  ///< External DMA Request Enable
        constexpr uint32_t EXBLKNU = (1U << 1);  ///< Exact Block Number Block Read Enable For SDIO CMD53
        constexpr uint32_t INTSTVAL = (8 << 16);  ///< Internal State Value
    }

    /// MMCBOOT Register bits
    namespace mmcboot_bits {
        constexpr uint32_t DTOCVACK = (4 << 0);  ///< Boot ACK Time Out Counter Value
        constexpr uint32_t BOOTACK = (1U << 4);  ///< Boot Ack Mode Select
        constexpr uint32_t BOOTMODE = (1U << 5);  ///< Boot Mode Select
        constexpr uint32_t BOOTEN = (1U << 6);  ///< Boot Mode Enable
        constexpr uint32_t AUTOSABGEN = (1U << 7);  ///< When boot, enable auto stop at block gap function
        constexpr uint32_t BOOTBLKCNT = (16 << 16);  ///< Defines the stop at block gap value of automatic mode
    }

    /// HOSTVER Register bits
    namespace hostver_bits {
        constexpr uint32_t SVN = (8 << 0);  ///< Specification Version Number
        constexpr uint32_t VVN = (8 << 8);  ///< Vendor Version Number
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x400BE000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - LCD General Control Register
        volatile uint32_t AR;  ///< Offset: 0x04 - LCD Auxiliary Register
        volatile uint32_t FDCR;  ///< Offset: 0x08 - LCD Fault Detect Control Register
        volatile uint32_t FDSR;  ///< Offset: 0x0C - LCD Fault Detect Status Register
        volatile uint32_t PEN;  ///< Offset: 0x10 - LCD Pin Enable register (renamed from PEN)
        volatile uint32_t BPEN;  ///< Offset: 0x18 - LCD Back Plane Enable register (renamed from BPEN)
        volatile uint32_t WF3TO0;  ///< Offset: 0x20 - LCD Waveform register
        volatile uint32_t WF0;  ///< Offset: 0x20 - LCD Waveform Register 0.
        volatile uint32_t WF1;  ///< Offset: 0x21 - LCD Waveform Register 1.
        volatile uint32_t WF2;  ///< Offset: 0x22 - LCD Waveform Register 2.
        volatile uint32_t WF3;  ///< Offset: 0x23 - LCD Waveform Register 3.
        volatile uint32_t WF7TO4;  ///< Offset: 0x24 - LCD Waveform register
        volatile uint32_t WF4;  ///< Offset: 0x24 - LCD Waveform Register 4.
        volatile uint32_t WF5;  ///< Offset: 0x25 - LCD Waveform Register 5.
        volatile uint32_t WF6;  ///< Offset: 0x26 - LCD Waveform Register 6.
        volatile uint32_t WF7;  ///< Offset: 0x27 - LCD Waveform Register 7.
        volatile uint32_t WF11TO8;  ///< Offset: 0x28 - LCD Waveform register
        volatile uint32_t WF8;  ///< Offset: 0x28 - LCD Waveform Register 8.
        volatile uint32_t WF9;  ///< Offset: 0x29 - LCD Waveform Register 9.
        volatile uint32_t WF10;  ///< Offset: 0x2A - LCD Waveform Register 10.
        volatile uint32_t WF11;  ///< Offset: 0x2B - LCD Waveform Register 11.
        volatile uint32_t WF15TO12;  ///< Offset: 0x2C - LCD Waveform register
        volatile uint32_t WF12;  ///< Offset: 0x2C - LCD Waveform Register 12.
        volatile uint32_t WF13;  ///< Offset: 0x2D - LCD Waveform Register 13.
        volatile uint32_t WF14;  ///< Offset: 0x2E - LCD Waveform Register 14.
        volatile uint32_t WF15;  ///< Offset: 0x2F - LCD Waveform Register 15.
        volatile uint32_t WF19TO16;  ///< Offset: 0x30 - LCD Waveform register
        volatile uint32_t WF16;  ///< Offset: 0x30 - LCD Waveform Register 16.
        volatile uint32_t WF17;  ///< Offset: 0x31 - LCD Waveform Register 17.
        volatile uint32_t WF18;  ///< Offset: 0x32 - LCD Waveform Register 18.
        volatile uint32_t WF19;  ///< Offset: 0x33 - LCD Waveform Register 19.
        volatile uint32_t WF23TO20;  ///< Offset: 0x34 - LCD Waveform register
        volatile uint32_t WF20;  ///< Offset: 0x34 - LCD Waveform Register 20.
        volatile uint32_t WF21;  ///< Offset: 0x35 - LCD Waveform Register 21.
        volatile uint32_t WF22;  ///< Offset: 0x36 - LCD Waveform Register 22.
        volatile uint32_t WF23;  ///< Offset: 0x37 - LCD Waveform Register 23.
        volatile uint32_t WF27TO24;  ///< Offset: 0x38 - LCD Waveform register
        volatile uint32_t WF24;  ///< Offset: 0x38 - LCD Waveform Register 24.
        volatile uint32_t WF25;  ///< Offset: 0x39 - LCD Waveform Register 25.
        volatile uint32_t WF26;  ///< Offset: 0x3A - LCD Waveform Register 26.
        volatile uint32_t WF27;  ///< Offset: 0x3B - LCD Waveform Register 27.
        volatile uint32_t WF31TO28;  ///< Offset: 0x3C - LCD Waveform register
        volatile uint32_t WF28;  ///< Offset: 0x3C - LCD Waveform Register 28.
        volatile uint32_t WF29;  ///< Offset: 0x3D - LCD Waveform Register 29.
        volatile uint32_t WF30;  ///< Offset: 0x3E - LCD Waveform Register 30.
        volatile uint32_t WF31;  ///< Offset: 0x3F - LCD Waveform Register 31.
        volatile uint32_t WF35TO32;  ///< Offset: 0x40 - LCD Waveform register
        volatile uint32_t WF32;  ///< Offset: 0x40 - LCD Waveform Register 32.
        volatile uint32_t WF33;  ///< Offset: 0x41 - LCD Waveform Register 33.
        volatile uint32_t WF34;  ///< Offset: 0x42 - LCD Waveform Register 34.
        volatile uint32_t WF35;  ///< Offset: 0x43 - LCD Waveform Register 35.
        volatile uint32_t WF39TO36;  ///< Offset: 0x44 - LCD Waveform register
        volatile uint32_t WF36;  ///< Offset: 0x44 - LCD Waveform Register 36.
        volatile uint32_t WF37;  ///< Offset: 0x45 - LCD Waveform Register 37.
        volatile uint32_t WF38;  ///< Offset: 0x46 - LCD Waveform Register 38.
        volatile uint32_t WF39;  ///< Offset: 0x47 - LCD Waveform Register 39.
        volatile uint32_t WF43TO40;  ///< Offset: 0x48 - LCD Waveform register
        volatile uint32_t WF40;  ///< Offset: 0x48 - LCD Waveform Register 40.
        volatile uint32_t WF41;  ///< Offset: 0x49 - LCD Waveform Register 41.
        volatile uint32_t WF42;  ///< Offset: 0x4A - LCD Waveform Register 42.
        volatile uint32_t WF43;  ///< Offset: 0x4B - LCD Waveform Register 43.
        volatile uint32_t WF47TO44;  ///< Offset: 0x4C - LCD Waveform register
        volatile uint32_t WF44;  ///< Offset: 0x4C - LCD Waveform Register 44.
        volatile uint32_t WF45;  ///< Offset: 0x4D - LCD Waveform Register 45.
        volatile uint32_t WF46;  ///< Offset: 0x4E - LCD Waveform Register 46.
        volatile uint32_t WF47;  ///< Offset: 0x4F - LCD Waveform Register 47.
        volatile uint32_t WF51TO48;  ///< Offset: 0x50 - LCD Waveform register
        volatile uint32_t WF48;  ///< Offset: 0x50 - LCD Waveform Register 48.
        volatile uint32_t WF49;  ///< Offset: 0x51 - LCD Waveform Register 49.
        volatile uint32_t WF50;  ///< Offset: 0x52 - LCD Waveform Register 50.
        volatile uint32_t WF51;  ///< Offset: 0x53 - LCD Waveform Register 51.
        volatile uint32_t WF55TO52;  ///< Offset: 0x54 - LCD Waveform register
        volatile uint32_t WF52;  ///< Offset: 0x54 - LCD Waveform Register 52.
        volatile uint32_t WF53;  ///< Offset: 0x55 - LCD Waveform Register 53.
        volatile uint32_t WF54;  ///< Offset: 0x56 - LCD Waveform Register 54.
        volatile uint32_t WF55;  ///< Offset: 0x57 - LCD Waveform Register 55.
        volatile uint32_t WF59TO56;  ///< Offset: 0x58 - LCD Waveform register
        volatile uint32_t WF56;  ///< Offset: 0x58 - LCD Waveform Register 56.
        volatile uint32_t WF57;  ///< Offset: 0x59 - LCD Waveform Register 57.
        volatile uint32_t WF58;  ///< Offset: 0x5A - LCD Waveform Register 58.
        volatile uint32_t WF59;  ///< Offset: 0x5B - LCD Waveform Register 59.
        volatile uint32_t WF63TO60;  ///< Offset: 0x5C - LCD Waveform register
        volatile uint32_t WF60;  ///< Offset: 0x5C - LCD Waveform Register 60.
        volatile uint32_t WF61;  ///< Offset: 0x5D - LCD Waveform Register 61.
        volatile uint32_t WF62;  ///< Offset: 0x5E - LCD Waveform Register 62.
        volatile uint32_t WF63;  ///< Offset: 0x5F - LCD Waveform Register 63.
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t DUTY = (3 << 0);  ///< LCD duty select
        constexpr uint32_t LCLK = (3 << 3);  ///< LCD Clock Prescaler
        constexpr uint32_t SOURCE = (1U << 6);  ///< LCD Clock Source Select
        constexpr uint32_t LCDEN = (1U << 7);  ///< LCD Driver Enable
        constexpr uint32_t LCDSTP = (1U << 8);  ///< LCD Stop
        constexpr uint32_t LCDWAIT = (1U << 9);  ///< LCD Wait
        constexpr uint32_t ALTDIV = (2 << 12);  ///< LCD AlternateClock Divider
        constexpr uint32_t FDCIEN = (1U << 14);  ///< LCD Fault Detection Complete Interrupt Enable
        constexpr uint32_t LCDIEN = (1U << 15);  ///< LCD Frame Frequency Interrupt Enable
        constexpr uint32_t VSUPPLY = (2 << 16);  ///< Voltage Supply Control
        constexpr uint32_t LADJ = (2 << 20);  ///< Load Adjust
        constexpr uint32_t HREFSEL = (1U << 22);  ///< High Reference Select
        constexpr uint32_t CPSEL = (1U << 23);  ///< Charge Pump or Resistor Bias Select
        constexpr uint32_t RVTRIM = (4 << 24);  ///< Regulated Voltage Trim
        constexpr uint32_t RVEN = (1U << 31);  ///< Regulated Voltage Enable
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t BRATE = (3 << 0);  ///< Blink-rate configuration
        constexpr uint32_t BMODE = (1U << 3);  ///< Blink mode
        constexpr uint32_t BLANK = (1U << 5);  ///< Blank display mode
        constexpr uint32_t ALT = (1U << 6);  ///< Alternate display mode
        constexpr uint32_t BLINK = (1U << 7);  ///< Blink command
        constexpr uint32_t LCDIF = (1U << 15);  ///< LCD Frame Frequency Interrupt flag
    }

    /// FDCR Register bits
    namespace fdcr_bits {
        constexpr uint32_t FDPINID = (6 << 0);  ///< Fault Detect Pin ID
        constexpr uint32_t FDBPEN = (1U << 6);  ///< Fault Detect Back Plane Enable
        constexpr uint32_t FDEN = (1U << 7);  ///< Fault Detect Enable
        constexpr uint32_t FDSWW = (3 << 9);  ///< Fault Detect Sample Window Width
        constexpr uint32_t FDPRS = (3 << 12);  ///< Fault Detect Clock Prescaler
    }

    /// FDSR Register bits
    namespace fdsr_bits {
        constexpr uint32_t FDCNT = (8 << 0);  ///< Fault Detect Counter
        constexpr uint32_t FDCF = (1U << 15);  ///< Fault Detection Complete Flag
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN = (32 << 0);  ///< LCD Pin Enable
    }

    /// BPEN Register bits
    namespace bpen_bits {
        constexpr uint32_t BPEN = (32 << 0);  ///< Back Plane Enable
    }

    /// WF3TO0 Register bits
    namespace wf3to0_bits {
        constexpr uint32_t WF0 = (8 << 0);  ///< Controls segments or phases connected to LCD_P0 as described above for WF3.
        constexpr uint32_t WF1 = (8 << 8);  ///< Controls segments or phases connected to LCD_P1 as described above for WF3.
        constexpr uint32_t WF2 = (8 << 16);  ///< Controls segments or phases connected to LCD_P2 as described above for WF3.
        constexpr uint32_t WF3 = (8 << 24);  ///< Segment-on front plane operation - Each bit turns on or off the segments associated with LCD_P3 in the following pattern: HGFEDCBA (most significant bit controls segment H and least significant bit controls segment A)
    }

    /// WF0 Register bits
    namespace wf0_bits {
        constexpr uint32_t BPALCD0 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD0 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD0 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD0 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD0 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD0 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD0 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD0 = (1U << 7);  ///< no description available
    }

    /// WF1 Register bits
    namespace wf1_bits {
        constexpr uint32_t BPALCD1 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD1 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD1 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD1 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD1 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD1 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD1 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD1 = (1U << 7);  ///< no description available
    }

    /// WF2 Register bits
    namespace wf2_bits {
        constexpr uint32_t BPALCD2 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD2 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD2 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD2 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD2 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD2 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD2 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD2 = (1U << 7);  ///< no description available
    }

    /// WF3 Register bits
    namespace wf3_bits {
        constexpr uint32_t BPALCD3 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD3 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD3 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD3 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD3 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD3 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD3 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD3 = (1U << 7);  ///< no description available
    }

    /// WF7TO4 Register bits
    namespace wf7to4_bits {
        constexpr uint32_t WF4 = (8 << 0);  ///< Controls segments or phases connected to LCD_P4 as described above for WF3TO0[WF3].
        constexpr uint32_t WF5 = (8 << 8);  ///< Controls segments or phases connected to LCD_P5 as described above for WF3TO0[WF3].
        constexpr uint32_t WF6 = (8 << 16);  ///< Controls segments or phases connected to LCD_P6 as described above for WF3TO0[WF3].
        constexpr uint32_t WF7 = (8 << 24);  ///< Controls segments or phases connected to LCD_P7 as described above for WF3TO0[WF3].
    }

    /// WF4 Register bits
    namespace wf4_bits {
        constexpr uint32_t BPALCD4 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD4 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD4 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD4 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD4 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD4 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD4 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD4 = (1U << 7);  ///< no description available
    }

    /// WF5 Register bits
    namespace wf5_bits {
        constexpr uint32_t BPALCD5 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD5 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD5 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD5 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD5 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD5 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD5 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD5 = (1U << 7);  ///< no description available
    }

    /// WF6 Register bits
    namespace wf6_bits {
        constexpr uint32_t BPALCD6 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD6 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD6 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD6 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD6 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD6 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD6 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD6 = (1U << 7);  ///< no description available
    }

    /// WF7 Register bits
    namespace wf7_bits {
        constexpr uint32_t BPALCD7 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD7 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD7 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD7 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD7 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD7 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD7 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD7 = (1U << 7);  ///< no description available
    }

    /// WF11TO8 Register bits
    namespace wf11to8_bits {
        constexpr uint32_t WF8 = (8 << 0);  ///< Controls segments or phases connected to LCD_P8 as described above for WF3TO0[WF3].
        constexpr uint32_t WF9 = (8 << 8);  ///< Controls segments or phases connected to LCD_P9 as described above for WF3TO0[WF3].
        constexpr uint32_t WF10 = (8 << 16);  ///< Controls segments or phases connected to LCD_P10 as described above for WF3TO0[WF3].
        constexpr uint32_t WF11 = (8 << 24);  ///< Controls segments or phases connected to LCD_P11 as described above for WF3TO0[WF3].
    }

    /// WF8 Register bits
    namespace wf8_bits {
        constexpr uint32_t BPALCD8 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD8 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD8 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD8 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD8 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD8 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD8 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD8 = (1U << 7);  ///< no description available
    }

    /// WF9 Register bits
    namespace wf9_bits {
        constexpr uint32_t BPALCD9 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD9 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD9 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD9 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD9 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD9 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD9 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD9 = (1U << 7);  ///< no description available
    }

    /// WF10 Register bits
    namespace wf10_bits {
        constexpr uint32_t BPALCD10 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD10 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD10 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD10 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD10 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD10 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD10 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD10 = (1U << 7);  ///< no description available
    }

    /// WF11 Register bits
    namespace wf11_bits {
        constexpr uint32_t BPALCD11 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD11 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD11 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD11 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD11 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD11 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD11 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD11 = (1U << 7);  ///< no description available
    }

    /// WF15TO12 Register bits
    namespace wf15to12_bits {
        constexpr uint32_t WF12 = (8 << 0);  ///< Controls segments or phases connected to LCD_P12 as described above for WF3TO0[WF3].
        constexpr uint32_t WF13 = (8 << 8);  ///< Controls segments or phases connected to LCD_P13 as described above for WF3TO0[WF3].
        constexpr uint32_t WF14 = (8 << 16);  ///< Controls segments or phases connected to LCD_P14 as described above for WF3TO0[WF3].
        constexpr uint32_t WF15 = (8 << 24);  ///< Controls segments or phases connected to LCD_P15 as described above for WF3TO0[WF3].
    }

    /// WF12 Register bits
    namespace wf12_bits {
        constexpr uint32_t BPALCD12 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD12 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD12 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD12 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD12 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD12 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD12 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD12 = (1U << 7);  ///< no description available
    }

    /// WF13 Register bits
    namespace wf13_bits {
        constexpr uint32_t BPALCD13 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD13 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD13 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD13 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD13 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD13 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD13 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD13 = (1U << 7);  ///< no description available
    }

    /// WF14 Register bits
    namespace wf14_bits {
        constexpr uint32_t BPALCD14 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD14 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD14 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD14 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD14 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD14 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD14 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD14 = (1U << 7);  ///< no description available
    }

    /// WF15 Register bits
    namespace wf15_bits {
        constexpr uint32_t BPALCD15 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD15 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD15 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD15 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD15 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD15 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD15 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD15 = (1U << 7);  ///< no description available
    }

    /// WF19TO16 Register bits
    namespace wf19to16_bits {
        constexpr uint32_t WF16 = (8 << 0);  ///< Controls segments or phases connected to LCD_P16 as described above for WF3TO0[WF3].
        constexpr uint32_t WF17 = (8 << 8);  ///< Controls segments or phases connected to LCD_P17 as described above for WF3TO0[WF3].
        constexpr uint32_t WF18 = (8 << 16);  ///< Controls segments or phases connected to LCD_P18 as described above for WF3TO0[WF3].
        constexpr uint32_t WF19 = (8 << 24);  ///< Controls segments or phases connected to LCD_P19 as described above for WF3TO0[WF3].
    }

    /// WF16 Register bits
    namespace wf16_bits {
        constexpr uint32_t BPALCD16 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD16 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD16 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD16 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD16 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD16 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD16 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD16 = (1U << 7);  ///< no description available
    }

    /// WF17 Register bits
    namespace wf17_bits {
        constexpr uint32_t BPALCD17 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD17 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD17 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD17 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD17 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD17 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD17 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD17 = (1U << 7);  ///< no description available
    }

    /// WF18 Register bits
    namespace wf18_bits {
        constexpr uint32_t BPALCD18 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD18 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD18 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD18 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD18 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD18 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD18 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD18 = (1U << 7);  ///< no description available
    }

    /// WF19 Register bits
    namespace wf19_bits {
        constexpr uint32_t BPALCD19 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD19 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD19 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD19 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD19 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD19 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD19 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD19 = (1U << 7);  ///< no description available
    }

    /// WF23TO20 Register bits
    namespace wf23to20_bits {
        constexpr uint32_t WF20 = (8 << 0);  ///< Controls segments or phases connected to LCD_P20 as described above for WF3TO0[WF3].
        constexpr uint32_t WF21 = (8 << 8);  ///< Controls segments or phases connected to LCD_P21 as described above for WF3TO0[WF3].
        constexpr uint32_t WF22 = (8 << 16);  ///< Controls segments or phases connected to LCD_P22 as described above for WF3TO0[WF3].
        constexpr uint32_t WF23 = (8 << 24);  ///< Controls segments or phases connected to LCD_P23 as described above for WF3TO0[WF3].
    }

    /// WF20 Register bits
    namespace wf20_bits {
        constexpr uint32_t BPALCD20 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD20 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD20 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD20 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD20 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD20 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD20 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD20 = (1U << 7);  ///< no description available
    }

    /// WF21 Register bits
    namespace wf21_bits {
        constexpr uint32_t BPALCD21 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD21 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD21 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD21 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD21 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD21 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD21 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD21 = (1U << 7);  ///< no description available
    }

    /// WF22 Register bits
    namespace wf22_bits {
        constexpr uint32_t BPALCD22 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD22 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD22 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD22 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD22 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD22 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD22 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD22 = (1U << 7);  ///< no description available
    }

    /// WF23 Register bits
    namespace wf23_bits {
        constexpr uint32_t BPALCD23 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD23 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD23 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD23 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD23 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD23 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD23 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD23 = (1U << 7);  ///< no description available
    }

    /// WF27TO24 Register bits
    namespace wf27to24_bits {
        constexpr uint32_t WF24 = (8 << 0);  ///< Controls segments or phases connected to LCD_P24 as described above for WF3TO0[WF3].
        constexpr uint32_t WF25 = (8 << 8);  ///< Controls segments or phases connected to LCD_P25 as described above for WF3TO0[WF3].
        constexpr uint32_t WF26 = (8 << 16);  ///< Controls segments or phases connected to LCD_P26 as described above for WF3TO0[WF3].
        constexpr uint32_t WF27 = (8 << 24);  ///< Controls segments or phases connected to LCD_P27 as described above for WF3TO0[WF3].
    }

    /// WF24 Register bits
    namespace wf24_bits {
        constexpr uint32_t BPALCD24 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD24 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD24 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD24 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD24 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD24 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD24 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD24 = (1U << 7);  ///< no description available
    }

    /// WF25 Register bits
    namespace wf25_bits {
        constexpr uint32_t BPALCD25 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD25 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD25 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD25 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD25 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD25 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD25 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD25 = (1U << 7);  ///< no description available
    }

    /// WF26 Register bits
    namespace wf26_bits {
        constexpr uint32_t BPALCD26 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD26 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD26 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD26 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD26 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD26 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD26 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD26 = (1U << 7);  ///< no description available
    }

    /// WF27 Register bits
    namespace wf27_bits {
        constexpr uint32_t BPALCD27 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD27 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD27 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD27 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD27 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD27 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD27 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD27 = (1U << 7);  ///< no description available
    }

    /// WF31TO28 Register bits
    namespace wf31to28_bits {
        constexpr uint32_t WF28 = (8 << 0);  ///< Controls segments or phases connected to LCD_P28 as described above for WF3TO0[WF3].
        constexpr uint32_t WF29 = (8 << 8);  ///< Controls segments or phases connected to LCD_P29 as described above for WF3TO0[WF3].
        constexpr uint32_t WF30 = (8 << 16);  ///< Controls segments or phases connected to LCD_P30 as described above for WF3TO0[WF3].
        constexpr uint32_t WF31 = (8 << 24);  ///< Controls segments or phases connected to LCD_P31 as described above for WF3TO0[WF3].
    }

    /// WF28 Register bits
    namespace wf28_bits {
        constexpr uint32_t BPALCD28 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD28 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD28 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD28 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD28 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD28 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD28 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD28 = (1U << 7);  ///< no description available
    }

    /// WF29 Register bits
    namespace wf29_bits {
        constexpr uint32_t BPALCD29 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD29 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD29 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD29 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD29 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD29 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD29 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD29 = (1U << 7);  ///< no description available
    }

    /// WF30 Register bits
    namespace wf30_bits {
        constexpr uint32_t BPALCD30 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD30 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD30 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD30 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD30 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD30 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD30 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD30 = (1U << 7);  ///< no description available
    }

    /// WF31 Register bits
    namespace wf31_bits {
        constexpr uint32_t BPALCD31 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD31 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD31 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD31 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD31 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD31 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD31 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD31 = (1U << 7);  ///< no description available
    }

    /// WF35TO32 Register bits
    namespace wf35to32_bits {
        constexpr uint32_t WF32 = (8 << 0);  ///< Controls segments or phases connected to LCD_P32 as described above for WF3TO0[WF3].
        constexpr uint32_t WF33 = (8 << 8);  ///< Controls segments or phases connected to LCD_P33 as described above for WF3TO0[WF3].
        constexpr uint32_t WF34 = (8 << 16);  ///< Controls segments or phases connected to LCD_P34 as described above for WF3TO0[WF3].
        constexpr uint32_t WF35 = (8 << 24);  ///< Controls segments or phases connected to LCD_P35 as described above for WF3TO0[WF3].
    }

    /// WF32 Register bits
    namespace wf32_bits {
        constexpr uint32_t BPALCD32 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD32 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD32 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD32 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD32 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD32 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD32 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD32 = (1U << 7);  ///< no description available
    }

    /// WF33 Register bits
    namespace wf33_bits {
        constexpr uint32_t BPALCD33 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD33 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD33 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD33 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD33 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD33 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD33 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD33 = (1U << 7);  ///< no description available
    }

    /// WF34 Register bits
    namespace wf34_bits {
        constexpr uint32_t BPALCD34 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD34 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD34 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD34 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD34 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD34 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD34 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD34 = (1U << 7);  ///< no description available
    }

    /// WF35 Register bits
    namespace wf35_bits {
        constexpr uint32_t BPALCD35 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD35 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD35 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD35 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD35 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD35 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD35 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD35 = (1U << 7);  ///< no description available
    }

    /// WF39TO36 Register bits
    namespace wf39to36_bits {
        constexpr uint32_t WF36 = (8 << 0);  ///< Controls segments or phases connected to LCD_P36 as described above for WF3TO0[WF3].
        constexpr uint32_t WF37 = (8 << 8);  ///< Controls segments or phases connected to LCD_P37 as described above for WF3TO0[WF3].
        constexpr uint32_t WF38 = (8 << 16);  ///< Controls segments or phases connected to LCD_P38 as described above for WF3TO0[WF3].
        constexpr uint32_t WF39 = (8 << 24);  ///< Controls segments or phases connected to LCD_P39 as described above for WF3TO0[WF3].
    }

    /// WF36 Register bits
    namespace wf36_bits {
        constexpr uint32_t BPALCD36 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD36 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD36 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD36 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD36 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD36 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD36 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD36 = (1U << 7);  ///< no description available
    }

    /// WF37 Register bits
    namespace wf37_bits {
        constexpr uint32_t BPALCD37 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD37 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD37 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD37 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD37 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD37 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD37 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD37 = (1U << 7);  ///< no description available
    }

    /// WF38 Register bits
    namespace wf38_bits {
        constexpr uint32_t BPALCD38 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD38 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD38 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD38 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD38 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD38 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD38 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD38 = (1U << 7);  ///< no description available
    }

    /// WF39 Register bits
    namespace wf39_bits {
        constexpr uint32_t BPALCD39 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD39 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD39 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD39 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD39 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD39 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD39 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD39 = (1U << 7);  ///< no description available
    }

    /// WF43TO40 Register bits
    namespace wf43to40_bits {
        constexpr uint32_t WF40 = (8 << 0);  ///< Controls segments or phases connected to LCD_P40 as described above for WF3TO0[WF3].
        constexpr uint32_t WF41 = (8 << 8);  ///< Controls segments or phases connected to LCD_P41 as described above for WF3TO0[WF3].
        constexpr uint32_t WF42 = (8 << 16);  ///< Controls segments or phases connected to LCD_P42 as described above for WF3TO0[WF3].
        constexpr uint32_t WF43 = (8 << 24);  ///< Controls segments or phases connected to LCD_P43 as described above for WF3TO0[WF3].
    }

    /// WF40 Register bits
    namespace wf40_bits {
        constexpr uint32_t BPALCD40 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD40 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD40 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD40 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD40 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD40 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD40 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD40 = (1U << 7);  ///< no description available
    }

    /// WF41 Register bits
    namespace wf41_bits {
        constexpr uint32_t BPALCD41 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD41 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD41 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD41 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD41 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD41 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD41 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD41 = (1U << 7);  ///< no description available
    }

    /// WF42 Register bits
    namespace wf42_bits {
        constexpr uint32_t BPALCD42 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD42 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD42 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD42 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD42 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD42 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD42 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD42 = (1U << 7);  ///< no description available
    }

    /// WF43 Register bits
    namespace wf43_bits {
        constexpr uint32_t BPALCD43 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD43 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD43 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD43 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD43 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD43 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD43 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD43 = (1U << 7);  ///< no description available
    }

    /// WF47TO44 Register bits
    namespace wf47to44_bits {
        constexpr uint32_t WF44 = (8 << 0);  ///< Controls segments or phases connected to LCD_P44 as described above for WF3TO0[WF3].
        constexpr uint32_t WF45 = (8 << 8);  ///< Controls segments or phases connected to LCD_P45 as described above for WF3TO0[WF3].
        constexpr uint32_t WF46 = (8 << 16);  ///< Controls segments or phases connected to LCD_P46 as described above for WF3TO0[WF3].
        constexpr uint32_t WF47 = (8 << 24);  ///< Controls segments or phases connected to LCD_P47 as described above for WF3TO0[WF3].
    }

    /// WF44 Register bits
    namespace wf44_bits {
        constexpr uint32_t BPALCD44 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD44 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD44 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD44 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD44 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD44 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD44 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD44 = (1U << 7);  ///< no description available
    }

    /// WF45 Register bits
    namespace wf45_bits {
        constexpr uint32_t BPALCD45 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD45 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD45 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD45 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD45 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD45 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD45 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD45 = (1U << 7);  ///< no description available
    }

    /// WF46 Register bits
    namespace wf46_bits {
        constexpr uint32_t BPALCD46 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD46 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD46 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD46 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD46 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD46 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD46 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD46 = (1U << 7);  ///< no description available
    }

    /// WF47 Register bits
    namespace wf47_bits {
        constexpr uint32_t BPALCD47 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD47 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD47 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD47 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD47 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD47 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD47 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD47 = (1U << 7);  ///< no description available
    }

    /// WF51TO48 Register bits
    namespace wf51to48_bits {
        constexpr uint32_t WF48 = (8 << 0);  ///< Controls segments or phases connected to LCD_P48 as described above for WF3TO0[WF3].
        constexpr uint32_t WF49 = (8 << 8);  ///< Controls segments or phases connected to LCD_P49 as described above for WF3TO0[WF3].
        constexpr uint32_t WF50 = (8 << 16);  ///< Controls segments or phases connected to LCD_P50 as described above for WF3TO0[WF3].
        constexpr uint32_t WF51 = (8 << 24);  ///< Controls segments or phases connected to LCD_P51 as described above for WF3TO0[WF3].
    }

    /// WF48 Register bits
    namespace wf48_bits {
        constexpr uint32_t BPALCD48 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD48 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD48 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD48 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD48 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD48 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD48 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD48 = (1U << 7);  ///< no description available
    }

    /// WF49 Register bits
    namespace wf49_bits {
        constexpr uint32_t BPALCD49 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD49 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD49 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD49 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD49 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD49 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD49 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD49 = (1U << 7);  ///< no description available
    }

    /// WF50 Register bits
    namespace wf50_bits {
        constexpr uint32_t BPALCD50 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD50 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD50 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD50 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD50 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD50 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD50 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD50 = (1U << 7);  ///< no description available
    }

    /// WF51 Register bits
    namespace wf51_bits {
        constexpr uint32_t BPALCD51 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD51 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD51 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD51 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD51 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD51 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD51 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD51 = (1U << 7);  ///< no description available
    }

    /// WF55TO52 Register bits
    namespace wf55to52_bits {
        constexpr uint32_t WF52 = (8 << 0);  ///< Controls segments or phases connected to LCD_P52 as described above for WF3TO0[WF3].
        constexpr uint32_t WF53 = (8 << 8);  ///< Controls segments or phases connected to LCD_P53 as described above for WF3TO0[WF3].
        constexpr uint32_t WF54 = (8 << 16);  ///< Controls segments or phases connected to LCD_P54 as described above for WF3TO0[WF3].
        constexpr uint32_t WF55 = (8 << 24);  ///< Controls segments or phases connected to LCD_P55 as described above for WF3TO0[WF3].
    }

    /// WF52 Register bits
    namespace wf52_bits {
        constexpr uint32_t BPALCD52 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD52 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD52 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD52 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD52 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD52 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD52 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD52 = (1U << 7);  ///< no description available
    }

    /// WF53 Register bits
    namespace wf53_bits {
        constexpr uint32_t BPALCD53 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD53 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD53 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD53 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD53 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD53 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD53 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD53 = (1U << 7);  ///< no description available
    }

    /// WF54 Register bits
    namespace wf54_bits {
        constexpr uint32_t BPALCD54 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD54 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD54 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD54 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD54 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD54 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD54 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD54 = (1U << 7);  ///< no description available
    }

    /// WF55 Register bits
    namespace wf55_bits {
        constexpr uint32_t BPALCD55 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD55 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD55 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD55 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD55 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD55 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD55 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD55 = (1U << 7);  ///< no description available
    }

    /// WF59TO56 Register bits
    namespace wf59to56_bits {
        constexpr uint32_t WF56 = (8 << 0);  ///< Controls segments or phases connected to LCD_P56 as described above for WF3TO0[WF3].
        constexpr uint32_t WF57 = (8 << 8);  ///< Controls segments or phases connected to LCD_P57 as described above for WF3TO0[WF3].
        constexpr uint32_t WF58 = (8 << 16);  ///< Controls segments or phases connected to LCD_P58 as described above for WF3TO0[WF3].
        constexpr uint32_t WF59 = (8 << 24);  ///< Controls segments or phases connected to LCD_P59 as described above for WF3TO0[WF3].
    }

    /// WF56 Register bits
    namespace wf56_bits {
        constexpr uint32_t BPALCD56 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD56 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD56 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD56 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD56 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD56 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD56 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD56 = (1U << 7);  ///< no description available
    }

    /// WF57 Register bits
    namespace wf57_bits {
        constexpr uint32_t BPALCD57 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD57 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD57 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD57 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD57 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD57 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD57 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD57 = (1U << 7);  ///< no description available
    }

    /// WF58 Register bits
    namespace wf58_bits {
        constexpr uint32_t BPALCD58 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD58 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD58 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD58 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD58 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD58 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD58 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD58 = (1U << 7);  ///< no description available
    }

    /// WF59 Register bits
    namespace wf59_bits {
        constexpr uint32_t BPALCD59 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD59 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD59 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD59 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD59 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD59 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD59 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD59 = (1U << 7);  ///< no description available
    }

    /// WF63TO60 Register bits
    namespace wf63to60_bits {
        constexpr uint32_t WF60 = (8 << 0);  ///< Controls segments or phases connected to LCD_P60 as described above for WF3TO0[WF3].
        constexpr uint32_t WF61 = (8 << 8);  ///< Controls segments or phases connected to LCD_P61 as described above for WF3TO0[WF3].
        constexpr uint32_t WF62 = (8 << 16);  ///< Controls segments or phases connected to LCD_P62 as described above for WF3TO0[WF3].
        constexpr uint32_t WF63 = (8 << 24);  ///< Controls segments or phases connected to LCD_P63 as described above for WF3TO0[WF3].
    }

    /// WF60 Register bits
    namespace wf60_bits {
        constexpr uint32_t BPALCD60 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD60 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD60 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD60 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD60 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD60 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD60 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD60 = (1U << 7);  ///< no description available
    }

    /// WF61 Register bits
    namespace wf61_bits {
        constexpr uint32_t BPALCD61 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD61 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD61 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD61 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD61 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD61 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD61 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD61 = (1U << 7);  ///< no description available
    }

    /// WF62 Register bits
    namespace wf62_bits {
        constexpr uint32_t BPALCD62 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD62 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD62 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD62 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD62 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD62 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD62 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD62 = (1U << 7);  ///< no description available
    }

    /// WF63 Register bits
    namespace wf63_bits {
        constexpr uint32_t BPALCD63 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD63 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD63 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD63 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD63 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD63 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD63 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD63 = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x400CC000;
    constexpr uint32_t DAC1_BASE = 0x400CD000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< When the DAC buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula: V out = V in * (1 + DACDAT0[11:0])/4096 When the DAC buffer is enabled, DATA is mapped to the 16-word buffer
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t ISR;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t ETBCC;  ///< Offset: 0x14 - ETB Counter Control register
        volatile uint32_t ETBRL;  ///< Offset: 0x18 - ETB Reload register
        volatile uint32_t ETBCNT;  ///< Offset: 0x1C - ETB Counter Value register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t IRQ = (1U << 1);  ///< Normal Interrupt Pending
        constexpr uint32_t NMI = (1U << 2);  ///< Non-maskable Interrupt Pending
        constexpr uint32_t DHREQ = (1U << 3);  ///< Debug Halt Request Indicator
    }

    /// ETBCC Register bits
    namespace etbcc_bits {
        constexpr uint32_t CNTEN = (1U << 0);  ///< Counter Enable
        constexpr uint32_t RSPT = (2 << 1);  ///< Response Type
        constexpr uint32_t RLRQ = (1U << 3);  ///< Reload Request
        constexpr uint32_t ETDIS = (1U << 4);  ///< ETM-To-TPIU Disable
        constexpr uint32_t ITDIS = (1U << 5);  ///< ITM-To-TPIU Disable
    }

    /// ETBRL Register bits
    namespace etbrl_bits {
        constexpr uint32_t RELOAD = (11 << 0);  ///< Byte Count Reload Value
    }

    /// ETBCNT Register bits
    namespace etbcnt_bits {
        constexpr uint32_t COUNTER = (11 << 0);  ///< Byte Count Counter Value
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID And M1_PID For MPU
    }

}


} // namespace alloy::generated::mk40d10

#endif // ALLOY_GENERATED_MK40D10_PERIPHERALS_HPP