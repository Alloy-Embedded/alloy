/// Auto-generated code for MK82F25615
/// Generated by Alloy Code Generator
/// Source: nxp_mk82.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:09
#ifndef ALLOY_GENERATED_MK82F25615_PERIPHERALS_HPP
#define ALLOY_GENERATED_MK82F25615_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mk82f25615 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_aips0 = true;
    constexpr uint32_t num_aips0_instances = 1;
    constexpr bool has_aips1 = true;
    constexpr uint32_t num_aips1_instances = 1;
    constexpr bool has_axbs = true;
    constexpr uint32_t num_axbs_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_fb = true;
    constexpr uint32_t num_fb_instances = 1;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_sdram = true;
    constexpr uint32_t num_sdram_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 4;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 2;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_cmt = true;
    constexpr uint32_t num_cmt_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 4;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_sdhc = true;
    constexpr uint32_t num_sdhc_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 5;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_ltc0 = true;
    constexpr uint32_t num_ltc0_instances = 1;
    constexpr bool has_emvsim0 = true;
    constexpr uint32_t num_emvsim0_instances = 1;
    constexpr bool has_emvsim1 = true;
    constexpr uint32_t num_emvsim1_instances = 1;
    constexpr bool has_otfad = true;
    constexpr uint32_t num_otfad_instances = 1;
    constexpr bool has_flexio0 = true;
    constexpr uint32_t num_flexio0_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_cau = true;
    constexpr uint32_t num_cau_instances = 1;
    constexpr bool has_lmem = true;
    constexpr uint32_t num_lmem_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct aips0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct axbs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdram_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdhc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ltc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct emvsim0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct emvsim1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfad_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cau_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lmem_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
    constexpr bool has_lpuart3 = true;
    constexpr bool has_lpuart4 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

}

// ============================================================================
// AIPS0 Peripheral
// ============================================================================

namespace aips0 {
    /// Base addresses
    constexpr uint32_t AIPS0_BASE = 0x40000000;

    /// AIPS0 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS0 = reinterpret_cast<Registers*>(AIPS0_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master 4 Privilege Level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master 4 Trusted For Writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master 4 Trusted For Read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master 3 Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master 3 Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master 3 Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AIPS1 Peripheral
// ============================================================================

namespace aips1 {
    /// Base addresses
    constexpr uint32_t AIPS1_BASE = 0x40080000;

    /// AIPS1 Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS1 = reinterpret_cast<Registers*>(AIPS1_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master 4 Privilege Level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master 4 Trusted For Writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master 4 Trusted For Read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master 3 Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master 3 Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master 3 Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// AXBS Peripheral
// ============================================================================

namespace axbs {
    /// Base addresses
    constexpr uint32_t AXBS_BASE = 0x40004000;

    /// AXBS Register structure
    struct Registers {
        volatile uint32_t PRS;  ///< Offset: 0x00 - Priority Registers Slave (renamed from PRS)
        volatile uint32_t CRS;  ///< Offset: 0x10 - Control Register (renamed from CRS)
        volatile uint32_t MGPCR;  ///< Offset: 0x800 - Master General Purpose Control Register (renamed from MGPCR)
    };

    /// Peripheral instances
    inline Registers* AXBS = reinterpret_cast<Registers*>(AXBS_BASE);

    // Bit definitions
    /// PRS Register bits
    namespace prs_bits {
        constexpr uint32_t M0 = (3 << 0);  ///< Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M1 = (3 << 4);  ///< Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M2 = (3 << 8);  ///< Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M3 = (3 << 12);  ///< Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
        constexpr uint32_t M4 = (3 << 16);  ///< Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
    }

    /// CRS Register bits
    namespace crs_bits {
        constexpr uint32_t PARK = (3 << 0);  ///< Park
        constexpr uint32_t PCTL = (2 << 4);  ///< Parking Control
        constexpr uint32_t ARB = (2 << 8);  ///< Arbitration Mode
        constexpr uint32_t HLP = (1U << 30);  ///< Halt Low Priority
        constexpr uint32_t RO = (1U << 31);  ///< Read Only
    }

    /// MGPCR Register bits
    namespace mgpcr_bits {
        constexpr uint32_t AULB = (3 << 0);  ///< Arbitrates On Undefined Length Bursts
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and... (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t ERGA = (1U << 3);  ///< Enable Round Robin Group Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t GRP0PRI = (1U << 8);  ///< Channel Group 0 Priority
        constexpr uint32_t GRP1PRI = (1U << 10);  ///< Channel Group 1 Priority
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (5 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t GPE = (1U << 15);  ///< Group Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
        constexpr uint32_t ERQ16 = (1U << 16);  ///< Enable DMA Request 16
        constexpr uint32_t ERQ17 = (1U << 17);  ///< Enable DMA Request 17
        constexpr uint32_t ERQ18 = (1U << 18);  ///< Enable DMA Request 18
        constexpr uint32_t ERQ19 = (1U << 19);  ///< Enable DMA Request 19
        constexpr uint32_t ERQ20 = (1U << 20);  ///< Enable DMA Request 20
        constexpr uint32_t ERQ21 = (1U << 21);  ///< Enable DMA Request 21
        constexpr uint32_t ERQ22 = (1U << 22);  ///< Enable DMA Request 22
        constexpr uint32_t ERQ23 = (1U << 23);  ///< Enable DMA Request 23
        constexpr uint32_t ERQ24 = (1U << 24);  ///< Enable DMA Request 24
        constexpr uint32_t ERQ25 = (1U << 25);  ///< Enable DMA Request 25
        constexpr uint32_t ERQ26 = (1U << 26);  ///< Enable DMA Request 26
        constexpr uint32_t ERQ27 = (1U << 27);  ///< Enable DMA Request 27
        constexpr uint32_t ERQ28 = (1U << 28);  ///< Enable DMA Request 28
        constexpr uint32_t ERQ29 = (1U << 29);  ///< Enable DMA Request 29
        constexpr uint32_t ERQ30 = (1U << 30);  ///< Enable DMA Request 30
        constexpr uint32_t ERQ31 = (1U << 31);  ///< Enable DMA Request 31
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
        constexpr uint32_t EEI16 = (1U << 16);  ///< Enable Error Interrupt 16
        constexpr uint32_t EEI17 = (1U << 17);  ///< Enable Error Interrupt 17
        constexpr uint32_t EEI18 = (1U << 18);  ///< Enable Error Interrupt 18
        constexpr uint32_t EEI19 = (1U << 19);  ///< Enable Error Interrupt 19
        constexpr uint32_t EEI20 = (1U << 20);  ///< Enable Error Interrupt 20
        constexpr uint32_t EEI21 = (1U << 21);  ///< Enable Error Interrupt 21
        constexpr uint32_t EEI22 = (1U << 22);  ///< Enable Error Interrupt 22
        constexpr uint32_t EEI23 = (1U << 23);  ///< Enable Error Interrupt 23
        constexpr uint32_t EEI24 = (1U << 24);  ///< Enable Error Interrupt 24
        constexpr uint32_t EEI25 = (1U << 25);  ///< Enable Error Interrupt 25
        constexpr uint32_t EEI26 = (1U << 26);  ///< Enable Error Interrupt 26
        constexpr uint32_t EEI27 = (1U << 27);  ///< Enable Error Interrupt 27
        constexpr uint32_t EEI28 = (1U << 28);  ///< Enable Error Interrupt 28
        constexpr uint32_t EEI29 = (1U << 29);  ///< Enable Error Interrupt 29
        constexpr uint32_t EEI30 = (1U << 30);  ///< Enable Error Interrupt 30
        constexpr uint32_t EEI31 = (1U << 31);  ///< Enable Error Interrupt 31
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (5 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (5 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (5 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (5 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (5 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (5 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (5 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (5 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
        constexpr uint32_t INT16 = (1U << 16);  ///< Interrupt Request 16
        constexpr uint32_t INT17 = (1U << 17);  ///< Interrupt Request 17
        constexpr uint32_t INT18 = (1U << 18);  ///< Interrupt Request 18
        constexpr uint32_t INT19 = (1U << 19);  ///< Interrupt Request 19
        constexpr uint32_t INT20 = (1U << 20);  ///< Interrupt Request 20
        constexpr uint32_t INT21 = (1U << 21);  ///< Interrupt Request 21
        constexpr uint32_t INT22 = (1U << 22);  ///< Interrupt Request 22
        constexpr uint32_t INT23 = (1U << 23);  ///< Interrupt Request 23
        constexpr uint32_t INT24 = (1U << 24);  ///< Interrupt Request 24
        constexpr uint32_t INT25 = (1U << 25);  ///< Interrupt Request 25
        constexpr uint32_t INT26 = (1U << 26);  ///< Interrupt Request 26
        constexpr uint32_t INT27 = (1U << 27);  ///< Interrupt Request 27
        constexpr uint32_t INT28 = (1U << 28);  ///< Interrupt Request 28
        constexpr uint32_t INT29 = (1U << 29);  ///< Interrupt Request 29
        constexpr uint32_t INT30 = (1U << 30);  ///< Interrupt Request 30
        constexpr uint32_t INT31 = (1U << 31);  ///< Interrupt Request 31
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
        constexpr uint32_t ERR16 = (1U << 16);  ///< Error In Channel 16
        constexpr uint32_t ERR17 = (1U << 17);  ///< Error In Channel 17
        constexpr uint32_t ERR18 = (1U << 18);  ///< Error In Channel 18
        constexpr uint32_t ERR19 = (1U << 19);  ///< Error In Channel 19
        constexpr uint32_t ERR20 = (1U << 20);  ///< Error In Channel 20
        constexpr uint32_t ERR21 = (1U << 21);  ///< Error In Channel 21
        constexpr uint32_t ERR22 = (1U << 22);  ///< Error In Channel 22
        constexpr uint32_t ERR23 = (1U << 23);  ///< Error In Channel 23
        constexpr uint32_t ERR24 = (1U << 24);  ///< Error In Channel 24
        constexpr uint32_t ERR25 = (1U << 25);  ///< Error In Channel 25
        constexpr uint32_t ERR26 = (1U << 26);  ///< Error In Channel 26
        constexpr uint32_t ERR27 = (1U << 27);  ///< Error In Channel 27
        constexpr uint32_t ERR28 = (1U << 28);  ///< Error In Channel 28
        constexpr uint32_t ERR29 = (1U << 29);  ///< Error In Channel 29
        constexpr uint32_t ERR30 = (1U << 30);  ///< Error In Channel 30
        constexpr uint32_t ERR31 = (1U << 31);  ///< Error In Channel 31
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
        constexpr uint32_t HRS16 = (1U << 16);  ///< Hardware Request Status Channel 16
        constexpr uint32_t HRS17 = (1U << 17);  ///< Hardware Request Status Channel 17
        constexpr uint32_t HRS18 = (1U << 18);  ///< Hardware Request Status Channel 18
        constexpr uint32_t HRS19 = (1U << 19);  ///< Hardware Request Status Channel 19
        constexpr uint32_t HRS20 = (1U << 20);  ///< Hardware Request Status Channel 20
        constexpr uint32_t HRS21 = (1U << 21);  ///< Hardware Request Status Channel 21
        constexpr uint32_t HRS22 = (1U << 22);  ///< Hardware Request Status Channel 22
        constexpr uint32_t HRS23 = (1U << 23);  ///< Hardware Request Status Channel 23
        constexpr uint32_t HRS24 = (1U << 24);  ///< Hardware Request Status Channel 24
        constexpr uint32_t HRS25 = (1U << 25);  ///< Hardware Request Status Channel 25
        constexpr uint32_t HRS26 = (1U << 26);  ///< Hardware Request Status Channel 26
        constexpr uint32_t HRS27 = (1U << 27);  ///< Hardware Request Status Channel 27
        constexpr uint32_t HRS28 = (1U << 28);  ///< Hardware Request Status Channel 28
        constexpr uint32_t HRS29 = (1U << 29);  ///< Hardware Request Status Channel 29
        constexpr uint32_t HRS30 = (1U << 30);  ///< Hardware Request Status Channel 30
        constexpr uint32_t HRS31 = (1U << 31);  ///< Hardware Request Status Channel 31
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
        constexpr uint32_t EDREQ_8 = (1U << 8);  ///< Enable asynchronous DMA request in stop mode for channel 8
        constexpr uint32_t EDREQ_9 = (1U << 9);  ///< Enable asynchronous DMA request in stop mode for channel 9
        constexpr uint32_t EDREQ_10 = (1U << 10);  ///< Enable asynchronous DMA request in stop mode for channel 10
        constexpr uint32_t EDREQ_11 = (1U << 11);  ///< Enable asynchronous DMA request in stop mode for channel 11
        constexpr uint32_t EDREQ_12 = (1U << 12);  ///< Enable asynchronous DMA request in stop mode for channel 12
        constexpr uint32_t EDREQ_13 = (1U << 13);  ///< Enable asynchronous DMA request in stop mode for channel 13
        constexpr uint32_t EDREQ_14 = (1U << 14);  ///< Enable asynchronous DMA request in stop mode for channel 14
        constexpr uint32_t EDREQ_15 = (1U << 15);  ///< Enable asynchronous DMA request in stop mode for channel 15
        constexpr uint32_t EDREQ_16 = (1U << 16);  ///< Enable asynchronous DMA request in stop mode for channel 16
        constexpr uint32_t EDREQ_17 = (1U << 17);  ///< Enable asynchronous DMA request in stop mode for channel 17
        constexpr uint32_t EDREQ_18 = (1U << 18);  ///< Enable asynchronous DMA request in stop mode for channel 18
        constexpr uint32_t EDREQ_19 = (1U << 19);  ///< Enable asynchronous DMA request in stop mode for channel 19
        constexpr uint32_t EDREQ_20 = (1U << 20);  ///< Enable asynchronous DMA request in stop mode for channel 20
        constexpr uint32_t EDREQ_21 = (1U << 21);  ///< Enable asynchronous DMA request in stop mode for channel 21
        constexpr uint32_t EDREQ_22 = (1U << 22);  ///< Enable asynchronous DMA request in stop mode for channel 22
        constexpr uint32_t EDREQ_23 = (1U << 23);  ///< Enable asynchronous DMA request in stop mode for channel 23
        constexpr uint32_t EDREQ_24 = (1U << 24);  ///< Enable asynchronous DMA request in stop mode for channel 24
        constexpr uint32_t EDREQ_25 = (1U << 25);  ///< Enable asynchronous DMA request in stop mode for channel 25
        constexpr uint32_t EDREQ_26 = (1U << 26);  ///< Enable asynchronous DMA request in stop mode for channel 26
        constexpr uint32_t EDREQ_27 = (1U << 27);  ///< Enable asynchronous DMA request in stop mode for channel 27
        constexpr uint32_t EDREQ_28 = (1U << 28);  ///< Enable asynchronous DMA request in stop mode for channel 28
        constexpr uint32_t EDREQ_29 = (1U << 29);  ///< Enable asynchronous DMA request in stop mode for channel 29
        constexpr uint32_t EDREQ_30 = (1U << 30);  ///< Enable asynchronous DMA request in stop mode for channel 30
        constexpr uint32_t EDREQ_31 = (1U << 31);  ///< Enable asynchronous DMA request in stop mode for channel 31
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t GRPPRI = (2 << 4);  ///< Channel n Current Group Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (5 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (5 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FB Peripheral
// ============================================================================

namespace fb {
    /// Base addresses
    constexpr uint32_t FB_BASE = 0x4000C000;

    /// FB Register structure
    struct Registers {
        volatile uint32_t CSAR;  ///< Offset: 0x00 - Chip Select Address Register (renamed from CSAR)
        volatile uint32_t CSMR;  ///< Offset: 0x04 - Chip Select Mask Register (renamed from CSMR)
        volatile uint32_t CSCR;  ///< Offset: 0x08 - Chip Select Control Register (renamed from CSCR)
        volatile uint32_t CSPMCR;  ///< Offset: 0x60 - Chip Select port Multiplexing Control Register
    };

    /// Peripheral instances
    inline Registers* FB = reinterpret_cast<Registers*>(FB_BASE);

    // Bit definitions
    /// CSAR Register bits
    namespace csar_bits {
        constexpr uint32_t BA = (16 << 16);  ///< Base Address
    }

    /// CSMR Register bits
    namespace csmr_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid
        constexpr uint32_t WP = (1U << 8);  ///< Write Protect
        constexpr uint32_t BAM = (16 << 16);  ///< Base Address Mask
    }

    /// CSCR Register bits
    namespace cscr_bits {
        constexpr uint32_t BSTW = (1U << 3);  ///< Burst-Write Enable
        constexpr uint32_t BSTR = (1U << 4);  ///< Burst-Read Enable
        constexpr uint32_t BEM = (1U << 5);  ///< Byte-Enable Mode
        constexpr uint32_t PS = (2 << 6);  ///< Port Size
        constexpr uint32_t AA = (1U << 8);  ///< Auto-Acknowledge Enable
        constexpr uint32_t BLS = (1U << 9);  ///< Byte-Lane Shift
        constexpr uint32_t WS = (6 << 10);  ///< Wait States
        constexpr uint32_t WRAH = (2 << 16);  ///< Write Address Hold or Deselect
        constexpr uint32_t RDAH = (2 << 18);  ///< Read Address Hold or Deselect
        constexpr uint32_t ASET = (2 << 20);  ///< Address Setup
        constexpr uint32_t EXTS = (1U << 22);  ///< Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
        constexpr uint32_t SWSEN = (1U << 23);  ///< Secondary Wait State Enable
        constexpr uint32_t SWS = (6 << 26);  ///< Secondary Wait States
    }

    /// CSPMCR Register bits
    namespace cspmcr_bits {
        constexpr uint32_t GROUP5 = (4 << 12);  ///< FlexBus Signal Group 5 Multiplex control
        constexpr uint32_t GROUP4 = (4 << 16);  ///< FlexBus Signal Group 4 Multiplex control
        constexpr uint32_t GROUP3 = (4 << 20);  ///< FlexBus Signal Group 3 Multiplex control
        constexpr uint32_t GROUP2 = (4 << 24);  ///< FlexBus Signal Group 2 Multiplex control
        constexpr uint32_t GROUP1 = (4 << 28);  ///< FlexBus Signal Group 1 Multiplex control
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, slave port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, slave port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// SDRAM Peripheral
// ============================================================================

namespace sdram {
    /// Base addresses
    constexpr uint32_t SDRAM_BASE = 0x4000F000;

    /// SDRAM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x42 - Control Register
        volatile uint32_t AC;  ///< Offset: 0x48 - Address and Control Register (renamed from AC)
        volatile uint32_t CM;  ///< Offset: 0x4C - Control Mask (renamed from CM)
    };

    /// Peripheral instances
    inline Registers* SDRAM = reinterpret_cast<Registers*>(SDRAM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t RC = (9 << 0);  ///< Refresh count
        constexpr uint32_t RTIM = (2 << 9);  ///< Refresh timing
        constexpr uint32_t IS = (1U << 11);  ///< Initiate self-refresh command.
    }

    /// AC Register bits
    namespace ac_bits {
        constexpr uint32_t IP = (1U << 3);  ///< Initiate precharge all (pall) command.
        constexpr uint32_t PS = (2 << 4);  ///< Port size.
        constexpr uint32_t IMRS = (1U << 6);  ///< Initiate mode register set (mrs) command.
        constexpr uint32_t CBM = (3 << 8);  ///< Command bit location
        constexpr uint32_t CASL = (2 << 12);  ///< CAS Latency
        constexpr uint32_t RE = (1U << 15);  ///< Refresh enable
        constexpr uint32_t BA = (14 << 18);  ///< Base address register.
    }

    /// CM Register bits
    namespace cm_bits {
        constexpr uint32_t V = (1U << 0);  ///< Valid.
        constexpr uint32_t WP = (1U << 8);  ///< Write protect.
        constexpr uint32_t BAM = (14 << 18);  ///< Base address mask.
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x4001F000;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t PFAPR;  ///< Offset: 0x00 - Flash Access Protection Register
        volatile uint32_t PFB0CR;  ///< Offset: 0x04 - Flash Bank 0 Control Register
        volatile uint32_t Reserved;  ///< Offset: 0x08 - Reserved
        volatile uint32_t TAGVDW0S;  ///< Offset: 0x100 - Cache Tag Storage (renamed from TAGVDW0S)
        volatile uint32_t TAGVDW1S;  ///< Offset: 0x110 - Cache Tag Storage (renamed from TAGVDW1S)
        volatile uint32_t TAGVDW2S;  ///< Offset: 0x120 - Cache Tag Storage (renamed from TAGVDW2S)
        volatile uint32_t TAGVDW3S;  ///< Offset: 0x130 - Cache Tag Storage (renamed from TAGVDW3S)
        volatile uint32_t DATAW0SUM;  ///< Offset: 0x200 - Cache Data Storage (uppermost word) (renamed from DATAW0SUM)
        volatile uint32_t DATAW0SMU;  ///< Offset: 0x204 - Cache Data Storage (mid-upper word) (renamed from DATAW0SMU)
        volatile uint32_t DATAW0SML;  ///< Offset: 0x208 - Cache Data Storage (mid-lower word) (renamed from DATAW0SML)
        volatile uint32_t DATAW0SLM;  ///< Offset: 0x20C - Cache Data Storage (lowermost word) (renamed from DATAW0SLM)
        volatile uint32_t DATAW1SUM;  ///< Offset: 0x240 - Cache Data Storage (uppermost word) (renamed from DATAW1SUM)
        volatile uint32_t DATAW1SMU;  ///< Offset: 0x244 - Cache Data Storage (mid-upper word) (renamed from DATAW1SMU)
        volatile uint32_t DATAW1SML;  ///< Offset: 0x248 - Cache Data Storage (mid-lower word) (renamed from DATAW1SML)
        volatile uint32_t DATAW1SLM;  ///< Offset: 0x24C - Cache Data Storage (lowermost word) (renamed from DATAW1SLM)
        volatile uint32_t DATAW2SUM;  ///< Offset: 0x280 - Cache Data Storage (uppermost word) (renamed from DATAW2SUM)
        volatile uint32_t DATAW2SMU;  ///< Offset: 0x284 - Cache Data Storage (mid-upper word) (renamed from DATAW2SMU)
        volatile uint32_t DATAW2SML;  ///< Offset: 0x288 - Cache Data Storage (mid-lower word) (renamed from DATAW2SML)
        volatile uint32_t DATAW2SLM;  ///< Offset: 0x28C - Cache Data Storage (lowermost word) (renamed from DATAW2SLM)
        volatile uint32_t DATAW3SUM;  ///< Offset: 0x2C0 - Cache Data Storage (uppermost word) (renamed from DATAW3SUM)
        volatile uint32_t DATAW3SMU;  ///< Offset: 0x2C4 - Cache Data Storage (mid-upper word) (renamed from DATAW3SMU)
        volatile uint32_t DATAW3SML;  ///< Offset: 0x2C8 - Cache Data Storage (mid-lower word) (renamed from DATAW3SML)
        volatile uint32_t DATAW3SLM;  ///< Offset: 0x2CC - Cache Data Storage (lowermost word) (renamed from DATAW3SLM)
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// PFAPR Register bits
    namespace pfapr_bits {
        constexpr uint32_t M0AP = (2 << 0);  ///< Master 0 Access Protection
        constexpr uint32_t M1AP = (2 << 2);  ///< Master 1 Access Protection
        constexpr uint32_t M2AP = (2 << 4);  ///< Master 2 Access Protection
        constexpr uint32_t M3AP = (2 << 6);  ///< Master 3 Access Protection
        constexpr uint32_t M4AP = (2 << 8);  ///< Master 4 Access Protection
        constexpr uint32_t M0PFD = (1U << 16);  ///< Master 0 Prefetch Disable
        constexpr uint32_t M1PFD = (1U << 17);  ///< Master 1 Prefetch Disable
        constexpr uint32_t M2PFD = (1U << 18);  ///< Master 2 Prefetch Disable
        constexpr uint32_t M3PFD = (1U << 19);  ///< Master 3 Prefetch Disable
        constexpr uint32_t M4PFD = (1U << 20);  ///< Master 4 Prefetch Disable
    }

    /// PFB0CR Register bits
    namespace pfb0cr_bits {
        constexpr uint32_t B0SEBE = (1U << 0);  ///< Bank 0 Single Entry Buffer Enable
        constexpr uint32_t B0IPE = (1U << 1);  ///< Bank 0 Instruction Prefetch Enable
        constexpr uint32_t B0DPE = (1U << 2);  ///< Bank 0 Data Prefetch Enable
        constexpr uint32_t B0ICE = (1U << 3);  ///< Bank 0 Instruction Cache Enable
        constexpr uint32_t B0DCE = (1U << 4);  ///< Bank 0 Data Cache Enable
        constexpr uint32_t CRC = (3 << 5);  ///< Cache Replacement Control
        constexpr uint32_t B0MW = (2 << 17);  ///< Bank 0 Memory Width
        constexpr uint32_t S_B_INV = (1U << 19);  ///< Invalidate Prefetch Speculation Buffer
        constexpr uint32_t CINV_WAY = (4 << 20);  ///< Cache Invalidate Way x
        constexpr uint32_t CLCK_WAY = (4 << 24);  ///< Cache Lock Way x
        constexpr uint32_t B0RWSC = (4 << 28);  ///< Bank 0 Read Wait State Control
    }

    /// TAGVDW0S Register bits
    namespace tagvdw0s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t cache_tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW1S Register bits
    namespace tagvdw1s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t cache_tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW2S Register bits
    namespace tagvdw2s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t cache_tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// TAGVDW3S Register bits
    namespace tagvdw3s_bits {
        constexpr uint32_t valid = (1U << 0);  ///< 1-bit valid for cache entry
        constexpr uint32_t cache_tag = (14 << 6);  ///< 14-bit tag for cache entry
    }

    /// DATAW0SUM Register bits
    namespace dataw0sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW0SMU Register bits
    namespace dataw0smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW0SML Register bits
    namespace dataw0sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW0SLM Register bits
    namespace dataw0slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW1SUM Register bits
    namespace dataw1sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW1SMU Register bits
    namespace dataw1smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW1SML Register bits
    namespace dataw1sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW1SLM Register bits
    namespace dataw1slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW2SUM Register bits
    namespace dataw2sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW2SMU Register bits
    namespace dataw2smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW2SML Register bits
    namespace dataw2sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW2SLM Register bits
    namespace dataw2slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

    /// DATAW3SUM Register bits
    namespace dataw3sum_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [127:96] of data entry
    }

    /// DATAW3SMU Register bits
    namespace dataw3smu_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [95:64] of data entry
    }

    /// DATAW3SML Register bits
    namespace dataw3sml_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [63:32] of data entry
    }

    /// DATAW3SLM Register bits
    namespace dataw3slm_bits {
        constexpr uint32_t data = (32 << 0);  ///< Bits [31:0] of data entry
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t SPI2_BASE = 0x400AC000;
    constexpr uint32_t QuadSPI0_BASE = 0x400DA000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* QuadSPI0 = reinterpret_cast<Registers*>(QuadSPI0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< CLR_RXF
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Transfer Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register (renamed from TDR)
        volatile uint32_t TFR;  ///< Offset: 0x40 - SAI Transmit FIFO Register (renamed from TFR)
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register (renamed from RDR)
        volatile uint32_t RFR;  ///< Offset: 0xC0 - SAI Receive FIFO Register (renamed from RFR)
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
        volatile uint32_t MDR;  ///< Offset: 0x104 - SAI MCLK Divide Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (3 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (2 << 16);  ///< Transmit Channel Enable
        constexpr uint32_t CFR = (2 << 24);  ///< Channel FIFO Reset
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR Register bits
    namespace tfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
        constexpr uint32_t WCP = (1U << 31);  ///< Write Channel Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (32 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (3 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (5 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (2 << 16);  ///< Receive Channel Enable
        constexpr uint32_t CFR = (2 << 24);  ///< Channel FIFO Reset
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (5 << 16);  ///< Frame Size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCOMB = (2 << 26);  ///< FIFO Combine Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR Register bits
    namespace rfr_bits {
        constexpr uint32_t RFP = (4 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t RCP = (1U << 15);  ///< Receive Channel Pointer
        constexpr uint32_t WFP = (4 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (32 << 0);  ///< Receive Word Mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

    /// MDR Register bits
    namespace mdr_bits {
        constexpr uint32_t DIVIDE = (12 << 0);  ///< MCLK Divide
        constexpr uint32_t FRACT = (8 << 12);  ///< MCLK Fraction
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USBDCD_BASE = 0x40035000;
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t CONTROL;  ///< Offset: 0x00 - Control register
        volatile uint32_t CLOCK;  ///< Offset: 0x04 - Clock register
        volatile uint32_t STATUS;  ///< Offset: 0x08 - Status register
        volatile uint32_t SIGNAL_OVERRIDE;  ///< Offset: 0x0C - Signal Override Register
        volatile uint32_t TIMER0;  ///< Offset: 0x10 - TIMER0 register
        volatile uint32_t TIMER1;  ///< Offset: 0x14 - TIMER1 register
        volatile uint32_t TIMER2_BC11;  ///< Offset: 0x18 - TIMER2_BC11 register
        volatile uint32_t TIMER2_BC12;  ///< Offset: 0x18 - TIMER2_BC12 register
    };

    /// Peripheral instances
    inline Registers* USBDCD = reinterpret_cast<Registers*>(USBDCD_BASE);
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t IACK = (1U << 0);  ///< Interrupt Acknowledge
        constexpr uint32_t IF_ = (1U << 8);  ///< Interrupt Flag (renamed from IF_)
        constexpr uint32_t IE = (1U << 16);  ///< Interrupt Enable
        constexpr uint32_t BC12 = (1U << 17);  ///< BC1.2 compatibility. This bit cannot be changed after start detection.
        constexpr uint32_t START = (1U << 24);  ///< Start Change Detection Sequence
        constexpr uint32_t SR = (1U << 25);  ///< Software Reset
    }

    /// CLOCK Register bits
    namespace clock_bits {
        constexpr uint32_t CLOCK_UNIT = (1U << 0);  ///< Unit of Measurement Encoding for Clock Speed
        constexpr uint32_t CLOCK_SPEED = (10 << 2);  ///< Numerical Value of Clock Speed in Binary
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t SEQ_RES = (2 << 16);  ///< Charger Detection Sequence Results
        constexpr uint32_t SEQ_STAT = (2 << 18);  ///< Charger Detection Sequence Status
        constexpr uint32_t ERR = (1U << 20);  ///< Error Flag
        constexpr uint32_t TO = (1U << 21);  ///< Timeout Flag
        constexpr uint32_t ACTIVE = (1U << 22);  ///< Active Status Indicator
    }

    /// SIGNAL_OVERRIDE Register bits
    namespace signal_override_bits {
        constexpr uint32_t PS = (2 << 0);  ///< Phase Selection
    }

    /// TIMER0 Register bits
    namespace timer0_bits {
        constexpr uint32_t TUNITCON = (12 << 0);  ///< Unit Connection Timer Elapse (in ms)
        constexpr uint32_t TSEQ_INIT = (10 << 16);  ///< Sequence Initiation Time
    }

    /// TIMER1 Register bits
    namespace timer1_bits {
        constexpr uint32_t TVDPSRC_ON = (10 << 0);  ///< Time Period Comparator Enabled
        constexpr uint32_t TDCD_DBNC = (10 << 16);  ///< Time Period to Debounce D+ Signal
    }

    /// TIMER2_BC11 Register bits
    namespace timer2_bc11_bits {
        constexpr uint32_t CHECK_DM = (4 << 0);  ///< Time Before Check of D- Line
        constexpr uint32_t TVDPSRC_CON = (10 << 16);  ///< Time Period Before Enabling D+ Pullup
    }

    /// TIMER2_BC12 Register bits
    namespace timer2_bc12_bits {
        constexpr uint32_t TVDMSRC_ON = (10 << 0);  ///< Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
        constexpr uint32_t TWAIT_AFTER_PRD = (10 << 16);  ///< Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register (renamed from PODLY)
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT_ = (16 << 0);  ///< DAC Interval (renamed from INT_)
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT0_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;
    constexpr uint32_t LPTMR1_BASE = 0x40044000;
    constexpr uint32_t TPM1_BASE = 0x400C9000;
    constexpr uint32_t TPM2_BASE = 0x400CA000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT0 = reinterpret_cast<Registers*>(PIT0_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);
    inline Registers* LPTMR1 = reinterpret_cast<Registers*>(LPTMR1_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4003A000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x400B9000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t NUMTOF = (5 << 0);  ///< TOF Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< BDM Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - TSI General Control and Status Register
        volatile uint32_t DATA;  ///< Offset: 0x04 - TSI DATA Register
        volatile uint32_t TSHD;  ///< Offset: 0x08 - TSI Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t EOSDMEO = (1U << 0);  ///< End-of-Scan DMA Transfer Request Enable Only
        constexpr uint32_t CURSW = (1U << 1);  ///< CURSW
        constexpr uint32_t EOSF = (1U << 2);  ///< End of Scan Flag
        constexpr uint32_t SCNIP = (1U << 3);  ///< Scan In Progress Status
        constexpr uint32_t STM = (1U << 4);  ///< Scan Trigger Mode
        constexpr uint32_t STPE = (1U << 5);  ///< TSI STOP Enable
        constexpr uint32_t TSIIEN = (1U << 6);  ///< Touch Sensing Input Interrupt Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t NSCN = (5 << 8);  ///< NSCN
        constexpr uint32_t PS = (3 << 13);  ///< PS
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< EXTCHRG
        constexpr uint32_t DVOLT = (2 << 19);  ///< DVOLT
        constexpr uint32_t REFCHRG = (3 << 21);  ///< REFCHRG
        constexpr uint32_t MODE = (4 << 24);  ///< TSI analog modes setup and status bits.
        constexpr uint32_t ESOR = (1U << 28);  ///< End-of-scan or Out-of-Range Interrupt Selection
        constexpr uint32_t OUTRGF = (1U << 31);  ///< Out of Range Flag.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t TSICNT = (16 << 0);  ///< TSI Conversion Counter Value
        constexpr uint32_t SWTS = (1U << 22);  ///< Software Trigger Start
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Transfer Enabled
        constexpr uint32_t TSICH = (4 << 28);  ///< TSICH
    }

    /// TSHD Register bits
    namespace tshd_bits {
        constexpr uint32_t THRESL = (16 << 0);  ///< TSI Wakeup Channel Low-threshold
        constexpr uint32_t THRESH = (16 << 16);  ///< TSI Wakeup Channel High-threshold
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SOPT8;  ///< Offset: 0x101C - System Options Register 8
        volatile uint32_t SOPT9;  ///< Offset: 0x1020 - System Options Register 9
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC1;  ///< Offset: 0x1028 - System Clock Gating Control Register 1
        volatile uint32_t SCGC2;  ///< Offset: 0x102C - System Clock Gating Control Register 2
        volatile uint32_t SCGC3;  ///< Offset: 0x1030 - System Clock Gating Control Register 3
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t CLKDIV3;  ///< Offset: 0x1064 - System Clock Divider Register 3
        volatile uint32_t CLKDIV4;  ///< Offset: 0x1068 - System Clock Divider Register 4
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< RAM size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K oscillator clock select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t FBSL = (2 << 8);  ///< FlexBus security level
        constexpr uint32_t TRACECLKSEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PLLFLLSEL = (2 << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
        constexpr uint32_t FLEXIOSRC = (2 << 22);  ///< FlexIO Module Clock Source Select
        constexpr uint32_t TPMSRC = (2 << 24);  ///< TPM clock source select
        constexpr uint32_t LPUARTSRC = (2 << 26);  ///< LPUART clock source select
        constexpr uint32_t SDHCSRC = (2 << 28);  ///< SDHC clock source select
        constexpr uint32_t EMVSIMSRC = (2 << 30);  ///< EMVSIM Module Clock Source Select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t FTM0FLT0 = (1U << 0);  ///< FTM0 Fault 0 Select
        constexpr uint32_t FTM0FLT1 = (1U << 1);  ///< FTM0 Fault 1 Select
        constexpr uint32_t FTM1FLT0 = (1U << 4);  ///< FTM1 Fault 0 Select
        constexpr uint32_t FTM2FLT0 = (1U << 8);  ///< FTM2 Fault 0 Select
        constexpr uint32_t FTM3FLT0 = (1U << 12);  ///< FTM3 Fault 0 Select
        constexpr uint32_t FTM1CH0SRC = (2 << 18);  ///< FTM1 channel 0 input capture source select
        constexpr uint32_t FTM2CH0SRC = (2 << 20);  ///< FTM2 channel 0 input capture source select
        constexpr uint32_t FTM2CH1SRC = (1U << 22);  ///< FTM2 channel 1 input capture source select
        constexpr uint32_t FTM0CLKSEL = (1U << 24);  ///< FlexTimer 0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (1U << 25);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (1U << 26);  ///< FlexTimer 2 External Clock Pin Select
        constexpr uint32_t FTM3CLKSEL = (1U << 27);  ///< FlexTimer 3 External Clock Pin Select
        constexpr uint32_t FTM0TRG0SRC = (1U << 28);  ///< FlexTimer 0 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM0TRG1SRC = (1U << 29);  ///< FlexTimer 0 Hardware Trigger 1 Source Select
        constexpr uint32_t FTM3TRG0SRC = (1U << 30);  ///< FlexTimer 3 Hardware Trigger 0 Source Select
        constexpr uint32_t FTM3TRG1SRC = (1U << 31);  ///< FlexTimer 3 Hardware Trigger 1 Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t LPUART0TXSRC = (2 << 16);  ///< LPUART0 transmit data source select
        constexpr uint32_t LPUART0RXSRC = (2 << 18);  ///< LPUART0 receive data source select
        constexpr uint32_t LPUART1TXSRC = (2 << 20);  ///< LPUART1 transmit data source select
        constexpr uint32_t LPUART1RXSRC = (2 << 22);  ///< LPUART1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 alternate trigger enable
    }

    /// SOPT8 Register bits
    namespace sopt8_bits {
        constexpr uint32_t FTM0SYNCBIT = (1U << 0);  ///< FTM0 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM1SYNCBIT = (1U << 1);  ///< FTM1 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM2SYNCBIT = (1U << 2);  ///< FTM2 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM3SYNCBIT = (1U << 3);  ///< FTM3 Hardware Trigger 0 Software Synchronization
        constexpr uint32_t FTM0OCH0SRC = (1U << 16);  ///< FTM0 channel 0 output source
        constexpr uint32_t FTM0OCH1SRC = (1U << 17);  ///< FTM0 channel 1 output source
        constexpr uint32_t FTM0OCH2SRC = (1U << 18);  ///< FTM0 channel 2 output source
        constexpr uint32_t FTM0OCH3SRC = (1U << 19);  ///< FTM0 channel 3 output source
        constexpr uint32_t FTM0OCH4SRC = (1U << 20);  ///< FTM0 channel 4 output source
        constexpr uint32_t FTM0OCH5SRC = (1U << 21);  ///< FTM0 channel 5 output source
        constexpr uint32_t FTM0OCH6SRC = (1U << 22);  ///< FTM0 channel 6 output source
        constexpr uint32_t FTM0OCH7SRC = (1U << 23);  ///< FTM0 channel 7 output source
        constexpr uint32_t FTM3OCH0SRC = (1U << 24);  ///< FTM3 channel 0 output source
        constexpr uint32_t FTM3OCH1SRC = (1U << 25);  ///< FTM3 channel 1 output source
        constexpr uint32_t FTM3OCH2SRC = (1U << 26);  ///< FTM3 channel 2 output source
        constexpr uint32_t FTM3OCH3SRC = (1U << 27);  ///< FTM3 channel 3 output source
        constexpr uint32_t FTM3OCH4SRC = (1U << 28);  ///< FTM3 channel 4 output source
        constexpr uint32_t FTM3OCH5SRC = (1U << 29);  ///< FTM3 channel 5 output source
        constexpr uint32_t FTM3OCH6SRC = (1U << 30);  ///< FTM3 channel 6 output source
        constexpr uint32_t FTM3OCH7SRC = (1U << 31);  ///< FTM3 channel 7 output source
    }

    /// SOPT9 Register bits
    namespace sopt9_bits {
        constexpr uint32_t TPM1CH0SRC = (2 << 18);  ///< TPM1 channel 0 input capture source select
        constexpr uint32_t TPM2CH0SRC = (2 << 20);  ///< TPM2 channel 0 input capture source select
        constexpr uint32_t TPM1CLKSEL = (1U << 25);  ///< TPM1 External Clock Pin Select
        constexpr uint32_t TPM2CLKSEL = (1U << 26);  ///< TPM2 External Clock Pin Select
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family identification
        constexpr uint32_t DIEID = (5 << 7);  ///< Device Die ID
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis Sub-Family ID
        constexpr uint32_t FAMILYID = (4 << 28);  ///< Kinetis Family ID
    }

    /// SCGC1 Register bits
    namespace scgc1_bits {
        constexpr uint32_t I2C2 = (1U << 6);  ///< I2C2 Clock Gate Control
        constexpr uint32_t I2C3 = (1U << 7);  ///< I2C3 Clock Gate Control
    }

    /// SCGC2 Register bits
    namespace scgc2_bits {
        constexpr uint32_t LPUART0 = (1U << 4);  ///< LPUART0 Clock Gate Control
        constexpr uint32_t LPUART1 = (1U << 5);  ///< LPUART1 Clock Gate Control
        constexpr uint32_t LPUART2 = (1U << 6);  ///< LPUART2 Clock Gate Control
        constexpr uint32_t LPUART3 = (1U << 7);  ///< LPUART3 Clock Gate Control
        constexpr uint32_t TPM1 = (1U << 9);  ///< TPM1 Clock Gate Control
        constexpr uint32_t TPM2 = (1U << 10);  ///< TPM2 Clock Gate Control
        constexpr uint32_t DAC0 = (1U << 12);  ///< DAC0 Clock Gate Control
        constexpr uint32_t LTC = (1U << 17);  ///< LTC Clock Gate Control
        constexpr uint32_t EMVSIM0 = (1U << 20);  ///< EMVSIM0 Clock Gate Control
        constexpr uint32_t EMVSIM1 = (1U << 21);  ///< EMVSIM1 Clock Gate Control
        constexpr uint32_t LPUART4 = (1U << 22);  ///< LPUART4 Clock Gate Control
        constexpr uint32_t QSPI = (1U << 26);  ///< QSPI Clock Gate Control
        constexpr uint32_t FLEXIO = (1U << 31);  ///< FlexIO Clock Gate Control
    }

    /// SCGC3 Register bits
    namespace scgc3_bits {
        constexpr uint32_t TRNG = (1U << 0);  ///< TRNG Clock Gate Control
        constexpr uint32_t SPI2 = (1U << 12);  ///< SPI2 Clock Gate Control
        constexpr uint32_t SDHC = (1U << 17);  ///< SDHC Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 24);  ///< FTM2 Clock Gate Control
        constexpr uint32_t FTM3 = (1U << 25);  ///< FTM3 Clock Gate Control
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t CMT = (1U << 2);  ///< CMT Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t USBOTG = (1U << 18);  ///< USB Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t LPTMR1 = (1U << 4);  ///< LPTMR1 Clock Gate Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Clock Gate Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t USBDCD = (1U << 21);  ///< USB DCD Clock Gate Control
        constexpr uint32_t PDB = (1U << 22);  ///< PDB Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t FTM0 = (1U << 24);  ///< FTM0 Clock Gate Control
        constexpr uint32_t FTM1 = (1U << 25);  ///< FTM1 Clock Gate Control
        constexpr uint32_t FTM2 = (1U << 26);  ///< FTM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t FLEXBUS = (1U << 0);  ///< FlexBus Clock Gate Control
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
        constexpr uint32_t SDRAMC = (1U << 3);  ///< SDRAMC Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV3 = (4 << 20);  ///< Clock 3 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFRAC = (1U << 0);  ///< USB clock divider fraction
        constexpr uint32_t USBDIV = (3 << 1);  ///< USB clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// CLKDIV3 Register bits
    namespace clkdiv3_bits {
        constexpr uint32_t PLLFLLFRAC = (1U << 0);  ///< PLLFLL clock divider fraction
        constexpr uint32_t PLLFLLDIV = (3 << 1);  ///< PLLFLL clock divider divisor
    }

    /// CLKDIV4 Register bits
    namespace clkdiv4_bits {
        constexpr uint32_t TRACEFRAC = (1U << 0);  ///< Trace clock divider fraction
        constexpr uint32_t TRACEDIV = (3 << 1);  ///< Trace clock divider divisor
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR;  ///< Offset: 0x00 - Pin Control Register n (renamed from PCR)
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enables Windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in Stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in Wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKCTRL;  ///< Offset: 0x04 - Clock Control Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
    }

    /// CLKCTRL Register bits
    namespace clkctrl_bits {
        constexpr uint32_t CLKSEL = (2 << 0);  ///< EWM has 4 possible low power clock sources for running EWM counter
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power clock source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// CMT Peripheral
// ============================================================================

namespace cmt {
    /// Base addresses
    constexpr uint32_t CMT_BASE = 0x40062000;

    /// CMT Register structure
    struct Registers {
        volatile uint32_t CGH1;  ///< Offset: 0x00 - CMT Carrier Generator High Data Register 1
        volatile uint32_t CGL1;  ///< Offset: 0x01 - CMT Carrier Generator Low Data Register 1
        volatile uint32_t CGH2;  ///< Offset: 0x02 - CMT Carrier Generator High Data Register 2
        volatile uint32_t CGL2;  ///< Offset: 0x03 - CMT Carrier Generator Low Data Register 2
        volatile uint32_t OC;  ///< Offset: 0x04 - CMT Output Control Register
        volatile uint32_t MSC;  ///< Offset: 0x05 - CMT Modulator Status and Control Register
        volatile uint32_t CMD1;  ///< Offset: 0x06 - CMT Modulator Data Register Mark High
        volatile uint32_t CMD2;  ///< Offset: 0x07 - CMT Modulator Data Register Mark Low
        volatile uint32_t CMD3;  ///< Offset: 0x08 - CMT Modulator Data Register Space High
        volatile uint32_t CMD4;  ///< Offset: 0x09 - CMT Modulator Data Register Space Low
        volatile uint32_t PPS;  ///< Offset: 0x0A - CMT Primary Prescaler Register
        volatile uint32_t DMA;  ///< Offset: 0x0B - CMT Direct Memory Access Register
    };

    /// Peripheral instances
    inline Registers* CMT = reinterpret_cast<Registers*>(CMT_BASE);

    // Bit definitions
    /// CGH1 Register bits
    namespace cgh1_bits {
        constexpr uint32_t PH = (8 << 0);  ///< Primary Carrier High Time Data Value
    }

    /// CGL1 Register bits
    namespace cgl1_bits {
        constexpr uint32_t PL = (8 << 0);  ///< Primary Carrier Low Time Data Value
    }

    /// CGH2 Register bits
    namespace cgh2_bits {
        constexpr uint32_t SH = (8 << 0);  ///< Secondary Carrier High Time Data Value
    }

    /// CGL2 Register bits
    namespace cgl2_bits {
        constexpr uint32_t SL = (8 << 0);  ///< Secondary Carrier Low Time Data Value
    }

    /// OC Register bits
    namespace oc_bits {
        constexpr uint32_t IROPEN = (1U << 5);  ///< IRO Pin Enable
        constexpr uint32_t CMTPOL = (1U << 6);  ///< CMT Output Polarity
        constexpr uint32_t IROL = (1U << 7);  ///< IRO Latch Control
    }

    /// MSC Register bits
    namespace msc_bits {
        constexpr uint32_t MCGEN = (1U << 0);  ///< Modulator and Carrier Generator Enable
        constexpr uint32_t EOCIE = (1U << 1);  ///< End of Cycle Interrupt Enable
        constexpr uint32_t FSK = (1U << 2);  ///< FSK Mode Select
        constexpr uint32_t BASE = (1U << 3);  ///< Baseband Enable
        constexpr uint32_t EXSPC = (1U << 4);  ///< Extended Space Enable
        constexpr uint32_t CMTDIV = (2 << 5);  ///< CMT Clock Divide Prescaler
        constexpr uint32_t EOCF = (1U << 7);  ///< End Of Cycle Status Flag
    }

    /// CMD1 Register bits
    namespace cmd1_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[15:8]
    }

    /// CMD2 Register bits
    namespace cmd2_bits {
        constexpr uint32_t MB = (8 << 0);  ///< MB[7:0]
    }

    /// CMD3 Register bits
    namespace cmd3_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[15:8]
    }

    /// CMD4 Register bits
    namespace cmd4_bits {
        constexpr uint32_t SB = (8 << 0);  ///< SB[7:0]
    }

    /// PPS Register bits
    namespace pps_bits {
        constexpr uint32_t PPSDIV = (4 << 0);  ///< Primary Prescaler Divider
    }

    /// DMA Register bits
    namespace dma_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t FCFTRIM = (1U << 6);  ///< Fast Internal Reference Clock Fine Trim
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV = (3 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV = (5 << 0);  ///< VCO Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (2 << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
        volatile uint32_t DIV;  ///< Offset: 0x02 - OSC_DIV
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

    /// DIV Register bits
    namespace div_bits {
        constexpr uint32_t ERPS = (2 << 6);  ///< ERCLK prescaler
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;
    constexpr uint32_t I2C2_BASE = 0x400E6000;
    constexpr uint32_t I2C3_BASE = 0x400E7000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
        volatile uint32_t S2;  ///< Offset: 0x0C - I2C Status register 2
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t EMPTY = (1U << 0);  ///< Empty flag
        constexpr uint32_t ERROR = (1U << 1);  ///< Error flag
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40073008;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t PE5;  ///< Offset: 0x04 - LLWU Pin Enable 5 register
        volatile uint32_t PE6;  ///< Offset: 0x05 - LLWU Pin Enable 6 register
        volatile uint32_t PE7;  ///< Offset: 0x06 - LLWU Pin Enable 7 register
        volatile uint32_t PE8;  ///< Offset: 0x07 - LLWU Pin Enable 8 register
        volatile uint32_t ME;  ///< Offset: 0x08 - LLWU Module Enable register
        volatile uint32_t PF1;  ///< Offset: 0x09 - LLWU Pin Flag 1 register
        volatile uint32_t PF2;  ///< Offset: 0x0A - LLWU Pin Flag 2 register
        volatile uint32_t PF3;  ///< Offset: 0x0B - LLWU Pin Flag 3 register
        volatile uint32_t PF4;  ///< Offset: 0x0C - LLWU Pin Flag 4 register
        volatile uint32_t MF5;  ///< Offset: 0x0D - LLWU Module Flag 5 register
        volatile uint32_t FILT1;  ///< Offset: 0x0E - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x0F - LLWU Pin Filter 2 register
        volatile uint32_t FILT3;  ///< Offset: 0x10 - LLWU Pin Filter 3 register
        volatile uint32_t FILT4;  ///< Offset: 0x11 - LLWU Pin Filter 4 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// PE5 Register bits
    namespace pe5_bits {
        constexpr uint32_t WUPE16 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P16
        constexpr uint32_t WUPE17 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P17
        constexpr uint32_t WUPE18 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P18
        constexpr uint32_t WUPE19 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P19
    }

    /// PE6 Register bits
    namespace pe6_bits {
        constexpr uint32_t WUPE20 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P20
        constexpr uint32_t WUPE21 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P21
        constexpr uint32_t WUPE22 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P22
        constexpr uint32_t WUPE23 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P23
    }

    /// PE7 Register bits
    namespace pe7_bits {
        constexpr uint32_t WUPE24 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P24
        constexpr uint32_t WUPE25 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P25
        constexpr uint32_t WUPE26 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P26
        constexpr uint32_t WUPE27 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P27
    }

    /// PE8 Register bits
    namespace pe8_bits {
        constexpr uint32_t WUPE28 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P28
        constexpr uint32_t WUPE29 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P29
        constexpr uint32_t WUPE30 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P30
        constexpr uint32_t WUPE31 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P31
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// PF1 Register bits
    namespace pf1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// PF2 Register bits
    namespace pf2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// PF3 Register bits
    namespace pf3_bits {
        constexpr uint32_t WUF16 = (1U << 0);  ///< Wakeup Flag For LLWU_P16
        constexpr uint32_t WUF17 = (1U << 1);  ///< Wakeup Flag For LLWU_P17
        constexpr uint32_t WUF18 = (1U << 2);  ///< Wakeup Flag For LLWU_P18
        constexpr uint32_t WUF19 = (1U << 3);  ///< Wakeup Flag For LLWU_P19
        constexpr uint32_t WUF20 = (1U << 4);  ///< Wakeup Flag For LLWU_P20
        constexpr uint32_t WUF21 = (1U << 5);  ///< Wakeup Flag For LLWU_P21
        constexpr uint32_t WUF22 = (1U << 6);  ///< Wakeup Flag For LLWU_P22
        constexpr uint32_t WUF23 = (1U << 7);  ///< Wakeup Flag For LLWU_P23
    }

    /// PF4 Register bits
    namespace pf4_bits {
        constexpr uint32_t WUF24 = (1U << 0);  ///< Wakeup Flag For LLWU_P24
        constexpr uint32_t WUF25 = (1U << 1);  ///< Wakeup Flag For LLWU_P25
        constexpr uint32_t WUF26 = (1U << 2);  ///< Wakeup Flag For LLWU_P26
        constexpr uint32_t WUF27 = (1U << 3);  ///< Wakeup Flag For LLWU_P27
        constexpr uint32_t WUF28 = (1U << 4);  ///< Wakeup Flag For LLWU_P28
        constexpr uint32_t WUF29 = (1U << 5);  ///< Wakeup Flag For LLWU_P29
        constexpr uint32_t WUF30 = (1U << 6);  ///< Wakeup Flag For LLWU_P30
        constexpr uint32_t WUF31 = (1U << 7);  ///< Wakeup Flag For LLWU_P31
    }

    /// MF5 Register bits
    namespace mf5_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT3 Register bits
    namespace filt3_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT4 Register bits
    namespace filt4_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
        volatile uint32_t HVDSC1;  ///< Offset: 0x0B - High Voltage Detect Status And Control 1 register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

    /// HVDSC1 Register bits
    namespace hvdsc1_bits {
        constexpr uint32_t HVDV = (1U << 0);  ///< High-Voltage Detect Voltage Select
        constexpr uint32_t HVDRE = (1U << 4);  ///< High-Voltage Detect Reset Enable
        constexpr uint32_t HVDIE = (1U << 5);  ///< High-Voltage Detect Interrupt Enable
        constexpr uint32_t HVDACK = (1U << 6);  ///< High-Voltage Detect Acknowledge
        constexpr uint32_t HVDF = (1U << 7);  ///< High-Voltage Detect Flag
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t LLSM = (3 << 0);  ///< LLS or VLLS Mode Control
        constexpr uint32_t LPOPO = (1U << 3);  ///< LPO Power Option
        constexpr uint32_t RAM2PO = (1U << 4);  ///< RAM2 Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t FM;  ///< Offset: 0x06 - Force Mode Register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
        volatile uint32_t SSRS0;  ///< Offset: 0x08 - Sticky System Reset Status Register 0
        volatile uint32_t SSRS1;  ///< Offset: 0x09 - Sticky System Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t JTAG = (1U << 0);  ///< JTAG Generated Reset
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// SSRS0 Register bits
    namespace ssrs0_bits {
        constexpr uint32_t SWAKEUP = (1U << 0);  ///< Sticky Low Leakage Wakeup Reset
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
    }

    /// SSRS1 Register bits
    namespace ssrs1_bits {
        constexpr uint32_t SJTAG = (1U << 0);  ///< Sticky JTAG Generated Reset
        constexpr uint32_t SLOCKUP = (1U << 1);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 2);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 3);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 5);  ///< Sticky Stop Mode Acknowledge Error Reset
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG0_BASE = 0x400A0000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TRNG0_MCTL;  ///< Offset: 0x00 - RNG Miscellaneous Control Register
        volatile uint32_t TRNG0_SCMISC;  ///< Offset: 0x04 - RNG Statistical Check Miscellaneous Register
        volatile uint32_t TRNG0_PKRRNG;  ///< Offset: 0x08 - RNG Poker Range Register
        volatile uint32_t TRNG0_PKRMAX;  ///< Offset: 0x0C - RNG Poker Maximum Limit Register
        volatile uint32_t TRNG0_PKRSQ;  ///< Offset: 0x0C - RNG Poker Square Calculation Result Register
        volatile uint32_t TRNG0_SDCTL;  ///< Offset: 0x10 - RNG Seed Control Register
        volatile uint32_t TRNG0_SBLIM;  ///< Offset: 0x14 - RNG Sparse Bit Limit Register
        volatile uint32_t TRNG0_TOTSAM;  ///< Offset: 0x14 - RNG Total Samples Register
        volatile uint32_t TRNG0_FRQMIN;  ///< Offset: 0x18 - RNG Frequency Count Minimum Limit Register
        volatile uint32_t TRNG0_FRQCNT;  ///< Offset: 0x1C - RNG Frequency Count Register
        volatile uint32_t TRNG0_FRQMAX;  ///< Offset: 0x1C - RNG Frequency Count Maximum Limit Register
        volatile uint32_t TRNG0_SCMC;  ///< Offset: 0x20 - RNG Statistical Check Monobit Count Register
        volatile uint32_t TRNG0_SCML;  ///< Offset: 0x20 - RNG Statistical Check Monobit Limit Register
        volatile uint32_t TRNG0_SCR1C;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Count Register
        volatile uint32_t TRNG0_SCR1L;  ///< Offset: 0x24 - RNG Statistical Check Run Length 1 Limit Register
        volatile uint32_t TRNG0_SCR2C;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Count Register
        volatile uint32_t TRNG0_SCR2L;  ///< Offset: 0x28 - RNG Statistical Check Run Length 2 Limit Register
        volatile uint32_t TRNG0_SCR3C;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Count Register
        volatile uint32_t TRNG0_SCR3L;  ///< Offset: 0x2C - RNG Statistical Check Run Length 3 Limit Register
        volatile uint32_t TRNG0_SCR4C;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Count Register
        volatile uint32_t TRNG0_SCR4L;  ///< Offset: 0x30 - RNG Statistical Check Run Length 4 Limit Register
        volatile uint32_t TRNG0_SCR5C;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Count Register
        volatile uint32_t TRNG0_SCR5L;  ///< Offset: 0x34 - RNG Statistical Check Run Length 5 Limit Register
        volatile uint32_t TRNG0_SCR6PC;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Count Register
        volatile uint32_t TRNG0_SCR6PL;  ///< Offset: 0x38 - RNG Statistical Check Run Length 6+ Limit Register
        volatile uint32_t TRNG0_STATUS;  ///< Offset: 0x3C - RNG Status Register
        volatile uint32_t TRNG0_ENT0;  ///< Offset: 0x40 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT1;  ///< Offset: 0x44 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT2;  ///< Offset: 0x48 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT3;  ///< Offset: 0x4C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT4;  ///< Offset: 0x50 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT5;  ///< Offset: 0x54 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT6;  ///< Offset: 0x58 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT7;  ///< Offset: 0x5C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT8;  ///< Offset: 0x60 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT9;  ///< Offset: 0x64 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT10;  ///< Offset: 0x68 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT11;  ///< Offset: 0x6C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT12;  ///< Offset: 0x70 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT13;  ///< Offset: 0x74 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT14;  ///< Offset: 0x78 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT15;  ///< Offset: 0x7C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_PKRCNT10;  ///< Offset: 0x80 - RNG Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t TRNG0_PKRCNT32;  ///< Offset: 0x84 - RNG Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t TRNG0_PKRCNT54;  ///< Offset: 0x88 - RNG Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t TRNG0_PKRCNT76;  ///< Offset: 0x8C - RNG Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t TRNG0_PKRCNT98;  ///< Offset: 0x90 - RNG Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t TRNG0_PKRCNTBA;  ///< Offset: 0x94 - RNG Statistical Check Poker Count B and A Register
        volatile uint32_t TRNG0_PKRCNTDC;  ///< Offset: 0x98 - RNG Statistical Check Poker Count D and C Register
        volatile uint32_t TRNG0_PKRCNTFE;  ///< Offset: 0x9C - RNG Statistical Check Poker Count F and E Register
        volatile uint32_t TRNG0_SEC_CFG;  ///< Offset: 0xB0 - RNG Security Configuration Register
        volatile uint32_t TRNG0_INT_CTRL;  ///< Offset: 0xB4 - RNG Interrupt Control Register
        volatile uint32_t TRNG0_INT_MASK;  ///< Offset: 0xB8 - RNG Mask Register
        volatile uint32_t TRNG0_INT_STATUS;  ///< Offset: 0xBC - RNG Interrupt Status Register
        volatile uint32_t TRNG0_VID1;  ///< Offset: 0xF0 - RNG Version ID Register (MS)
        volatile uint32_t TRNG0_VID2;  ///< Offset: 0xF4 - RNG Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG0 = reinterpret_cast<Registers*>(TRNG0_BASE);

    // Bit definitions
    /// TRNG0_MCTL Register bits
    namespace trng0_mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// TRNG0_SCMISC Register bits
    namespace trng0_scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_PKRRNG Register bits
    namespace trng0_pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// TRNG0_PKRMAX Register bits
    namespace trng0_pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit
    }

    /// TRNG0_PKRSQ Register bits
    namespace trng0_pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result
    }

    /// TRNG0_SDCTL Register bits
    namespace trng0_sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// TRNG0_SBLIM Register bits
    namespace trng0_sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TRNG0_TOTSAM Register bits
    namespace trng0_totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// TRNG0_FRQMIN Register bits
    namespace trng0_frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// TRNG0_FRQCNT Register bits
    namespace trng0_frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// TRNG0_FRQMAX Register bits
    namespace trng0_frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// TRNG0_SCMC Register bits
    namespace trng0_scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// TRNG0_SCML Register bits
    namespace trng0_scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// TRNG0_SCR1C Register bits
    namespace trng0_scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// TRNG0_SCR1L Register bits
    namespace trng0_scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// TRNG0_SCR2C Register bits
    namespace trng0_scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// TRNG0_SCR2L Register bits
    namespace trng0_scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// TRNG0_SCR3C Register bits
    namespace trng0_scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// TRNG0_SCR3L Register bits
    namespace trng0_scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// TRNG0_SCR4C Register bits
    namespace trng0_scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// TRNG0_SCR4L Register bits
    namespace trng0_scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// TRNG0_SCR5C Register bits
    namespace trng0_scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// TRNG0_SCR5L Register bits
    namespace trng0_scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// TRNG0_SCR6PC Register bits
    namespace trng0_scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// TRNG0_SCR6PL Register bits
    namespace trng0_scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// TRNG0_STATUS Register bits
    namespace trng0_status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_ENT0 Register bits
    namespace trng0_ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT1 Register bits
    namespace trng0_ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT2 Register bits
    namespace trng0_ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT3 Register bits
    namespace trng0_ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT4 Register bits
    namespace trng0_ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT5 Register bits
    namespace trng0_ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT6 Register bits
    namespace trng0_ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT7 Register bits
    namespace trng0_ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT8 Register bits
    namespace trng0_ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT9 Register bits
    namespace trng0_ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT10 Register bits
    namespace trng0_ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT11 Register bits
    namespace trng0_ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT12 Register bits
    namespace trng0_ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT13 Register bits
    namespace trng0_ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT14 Register bits
    namespace trng0_ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT15 Register bits
    namespace trng0_ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_PKRCNT10 Register bits
    namespace trng0_pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// TRNG0_PKRCNT32 Register bits
    namespace trng0_pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// TRNG0_PKRCNT54 Register bits
    namespace trng0_pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// TRNG0_PKRCNT76 Register bits
    namespace trng0_pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// TRNG0_PKRCNT98 Register bits
    namespace trng0_pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// TRNG0_PKRCNTBA Register bits
    namespace trng0_pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// TRNG0_PKRCNTDC Register bits
    namespace trng0_pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// TRNG0_PKRCNTFE Register bits
    namespace trng0_pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// TRNG0_SEC_CFG Register bits
    namespace trng0_sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// TRNG0_INT_CTRL Register bits
    namespace trng0_int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// TRNG0_INT_MASK Register bits
    namespace trng0_int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// TRNG0_INT_STATUS Register bits
    namespace trng0_int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// TRNG0_VID1 Register bits
    namespace trng0_vid1_bits {
        constexpr uint32_t RNG_MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t RNG_MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t RNG_IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// TRNG0_VID2 Register bits
    namespace trng0_vid2_bits {
        constexpr uint32_t RNG_CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t RNG_ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t RNG_INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t RNG_ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// SDHC Peripheral
// ============================================================================

namespace sdhc {
    /// Base addresses
    constexpr uint32_t SDHC_BASE = 0x400B1000;

    /// SDHC Register structure
    struct Registers {
        volatile uint32_t DSADDR;  ///< Offset: 0x00 - DMA System Address register
        volatile uint32_t BLKATTR;  ///< Offset: 0x04 - Block Attributes register
        volatile uint32_t CMDARG;  ///< Offset: 0x08 - Command Argument register
        volatile uint32_t XFERTYP;  ///< Offset: 0x0C - Transfer Type register
        volatile uint32_t CMDRSP0;  ///< Offset: 0x10 - Command Response 0
        volatile uint32_t CMDRSP1;  ///< Offset: 0x14 - Command Response 1
        volatile uint32_t CMDRSP2;  ///< Offset: 0x18 - Command Response 2
        volatile uint32_t CMDRSP3;  ///< Offset: 0x1C - Command Response 3
        volatile uint32_t DATPORT;  ///< Offset: 0x20 - Buffer Data Port register
        volatile uint32_t PRSSTAT;  ///< Offset: 0x24 - Present State register
        volatile uint32_t PROCTL;  ///< Offset: 0x28 - Protocol Control register
        volatile uint32_t SYSCTL;  ///< Offset: 0x2C - System Control register
        volatile uint32_t IRQSTAT;  ///< Offset: 0x30 - Interrupt Status register
        volatile uint32_t IRQSTATEN;  ///< Offset: 0x34 - Interrupt Status Enable register
        volatile uint32_t IRQSIGEN;  ///< Offset: 0x38 - Interrupt Signal Enable register
        volatile uint32_t AC12ERR;  ///< Offset: 0x3C - Auto CMD12 Error Status Register
        volatile uint32_t HTCAPBLT;  ///< Offset: 0x40 - Host Controller Capabilities
        volatile uint32_t WML;  ///< Offset: 0x44 - Watermark Level Register
        volatile uint32_t FEVT;  ///< Offset: 0x50 - Force Event register
        volatile uint32_t ADMAES;  ///< Offset: 0x54 - ADMA Error Status register
        volatile uint32_t ADSADDR;  ///< Offset: 0x58 - ADMA System Addressregister
        volatile uint32_t VENDOR;  ///< Offset: 0xC0 - Vendor Specific register
        volatile uint32_t MMCBOOT;  ///< Offset: 0xC4 - MMC Boot register
        volatile uint32_t HOSTVER;  ///< Offset: 0xFC - Host Controller Version
    };

    /// Peripheral instances
    inline Registers* SDHC = reinterpret_cast<Registers*>(SDHC_BASE);

    // Bit definitions
    /// DSADDR Register bits
    namespace dsaddr_bits {
        constexpr uint32_t DSADDR = (30 << 2);  ///< DMA System Address
    }

    /// BLKATTR Register bits
    namespace blkattr_bits {
        constexpr uint32_t BLKSIZE = (13 << 0);  ///< Transfer Block Size
        constexpr uint32_t BLKCNT = (16 << 16);  ///< Blocks Count For Current Transfer
    }

    /// CMDARG Register bits
    namespace cmdarg_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command Argument
    }

    /// XFERTYP Register bits
    namespace xfertyp_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t BCEN = (1U << 1);  ///< Block Count Enable
        constexpr uint32_t AC12EN = (1U << 2);  ///< Auto CMD12 Enable
        constexpr uint32_t DTDSEL = (1U << 4);  ///< Data Transfer Direction Select
        constexpr uint32_t MSBSEL = (1U << 5);  ///< Multi/Single Block Select
        constexpr uint32_t RSPTYP = (2 << 16);  ///< Response Type Select
        constexpr uint32_t CCCEN = (1U << 19);  ///< Command CRC Check Enable
        constexpr uint32_t CICEN = (1U << 20);  ///< Command Index Check Enable
        constexpr uint32_t DPSEL = (1U << 21);  ///< Data Present Select
        constexpr uint32_t CMDTYP = (2 << 22);  ///< Command Type
        constexpr uint32_t CMDINX = (6 << 24);  ///< Command Index
    }

    /// CMDRSP0 Register bits
    namespace cmdrsp0_bits {
        constexpr uint32_t CMDRSP0 = (32 << 0);  ///< Command Response 0
    }

    /// CMDRSP1 Register bits
    namespace cmdrsp1_bits {
        constexpr uint32_t CMDRSP1 = (32 << 0);  ///< Command Response 1
    }

    /// CMDRSP2 Register bits
    namespace cmdrsp2_bits {
        constexpr uint32_t CMDRSP2 = (32 << 0);  ///< Command Response 2
    }

    /// CMDRSP3 Register bits
    namespace cmdrsp3_bits {
        constexpr uint32_t CMDRSP3 = (32 << 0);  ///< Command Response 3
    }

    /// DATPORT Register bits
    namespace datport_bits {
        constexpr uint32_t DATCONT = (32 << 0);  ///< Data Content
    }

    /// PRSSTAT Register bits
    namespace prsstat_bits {
        constexpr uint32_t CIHB = (1U << 0);  ///< Command Inhibit (CMD)
        constexpr uint32_t CDIHB = (1U << 1);  ///< Command Inhibit (DAT)
        constexpr uint32_t DLA = (1U << 2);  ///< Data Line Active
        constexpr uint32_t SDSTB = (1U << 3);  ///< SD Clock Stable
        constexpr uint32_t IPGOFF = (1U << 4);  ///< Bus Clock Gated Off Internally
        constexpr uint32_t HCKOFF = (1U << 5);  ///< System Clock Gated Off Internally
        constexpr uint32_t PEROFF = (1U << 6);  ///< SDHC clock Gated Off Internally
        constexpr uint32_t SDOFF = (1U << 7);  ///< SD Clock Gated Off Internally
        constexpr uint32_t WTA = (1U << 8);  ///< Write Transfer Active
        constexpr uint32_t RTA = (1U << 9);  ///< Read Transfer Active
        constexpr uint32_t BWEN = (1U << 10);  ///< Buffer Write Enable
        constexpr uint32_t BREN = (1U << 11);  ///< Buffer Read Enable
        constexpr uint32_t CINS = (1U << 16);  ///< Card Inserted
        constexpr uint32_t CLSL = (1U << 23);  ///< CMD Line Signal Level
        constexpr uint32_t DLSL = (8 << 24);  ///< DAT Line Signal Level
    }

    /// PROCTL Register bits
    namespace proctl_bits {
        constexpr uint32_t LCTL = (1U << 0);  ///< LED Control
        constexpr uint32_t DTW = (2 << 1);  ///< Data Transfer Width
        constexpr uint32_t D3CD = (1U << 3);  ///< DAT3 As Card Detection Pin
        constexpr uint32_t EMODE = (2 << 4);  ///< Endian Mode
        constexpr uint32_t CDTL = (1U << 6);  ///< Card Detect Test Level
        constexpr uint32_t CDSS = (1U << 7);  ///< Card Detect Signal Selection
        constexpr uint32_t DMAS = (2 << 8);  ///< DMA Select
        constexpr uint32_t SABGREQ = (1U << 16);  ///< Stop At Block Gap Request
        constexpr uint32_t CREQ = (1U << 17);  ///< Continue Request
        constexpr uint32_t RWCTL = (1U << 18);  ///< Read Wait Control
        constexpr uint32_t IABG = (1U << 19);  ///< Interrupt At Block Gap
        constexpr uint32_t WECINT = (1U << 24);  ///< Wakeup Event Enable On Card Interrupt
        constexpr uint32_t WECINS = (1U << 25);  ///< Wakeup Event Enable On SD Card Insertion
        constexpr uint32_t WECRM = (1U << 26);  ///< Wakeup Event Enable On SD Card Removal
    }

    /// SYSCTL Register bits
    namespace sysctl_bits {
        constexpr uint32_t IPGEN = (1U << 0);  ///< IPG Clock Enable
        constexpr uint32_t HCKEN = (1U << 1);  ///< System Clock Enable
        constexpr uint32_t PEREN = (1U << 2);  ///< Peripheral Clock Enable
        constexpr uint32_t SDCLKEN = (1U << 3);  ///< SD Clock Enable
        constexpr uint32_t DVS = (4 << 4);  ///< Divisor
        constexpr uint32_t SDCLKFS = (8 << 8);  ///< SDCLK Frequency Select
        constexpr uint32_t DTOCV = (4 << 16);  ///< Data Timeout Counter Value
        constexpr uint32_t RSTA = (1U << 24);  ///< Software Reset For ALL
        constexpr uint32_t RSTC = (1U << 25);  ///< Software Reset For CMD Line
        constexpr uint32_t RSTD = (1U << 26);  ///< Software Reset For DAT Line
        constexpr uint32_t INITA = (1U << 27);  ///< Initialization Active
    }

    /// IRQSTAT Register bits
    namespace irqstat_bits {
        constexpr uint32_t CC = (1U << 0);  ///< Command Complete
        constexpr uint32_t TC = (1U << 1);  ///< Transfer Complete
        constexpr uint32_t BGE = (1U << 2);  ///< Block Gap Event
        constexpr uint32_t DINT = (1U << 3);  ///< DMA Interrupt
        constexpr uint32_t BWR = (1U << 4);  ///< Buffer Write Ready
        constexpr uint32_t BRR = (1U << 5);  ///< Buffer Read Ready
        constexpr uint32_t CINS = (1U << 6);  ///< Card Insertion
        constexpr uint32_t CRM = (1U << 7);  ///< Card Removal
        constexpr uint32_t CINT = (1U << 8);  ///< Card Interrupt
        constexpr uint32_t CTOE = (1U << 16);  ///< Command Timeout Error
        constexpr uint32_t CCE = (1U << 17);  ///< Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Data Timeout Error
        constexpr uint32_t DCE = (1U << 21);  ///< Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Auto CMD12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< DMA Error
    }

    /// IRQSTATEN Register bits
    namespace irqstaten_bits {
        constexpr uint32_t CCSEN = (1U << 0);  ///< Command Complete Status Enable
        constexpr uint32_t TCSEN = (1U << 1);  ///< Transfer Complete Status Enable
        constexpr uint32_t BGESEN = (1U << 2);  ///< Block Gap Event Status Enable
        constexpr uint32_t DINTSEN = (1U << 3);  ///< DMA Interrupt Status Enable
        constexpr uint32_t BWRSEN = (1U << 4);  ///< Buffer Write Ready Status Enable
        constexpr uint32_t BRRSEN = (1U << 5);  ///< Buffer Read Ready Status Enable
        constexpr uint32_t CINSEN = (1U << 6);  ///< Card Insertion Status Enable
        constexpr uint32_t CRMSEN = (1U << 7);  ///< Card Removal Status Enable
        constexpr uint32_t CINTSEN = (1U << 8);  ///< Card Interrupt Status Enable
        constexpr uint32_t CTOESEN = (1U << 16);  ///< Command Timeout Error Status Enable
        constexpr uint32_t CCESEN = (1U << 17);  ///< Command CRC Error Status Enable
        constexpr uint32_t CEBESEN = (1U << 18);  ///< Command End Bit Error Status Enable
        constexpr uint32_t CIESEN = (1U << 19);  ///< Command Index Error Status Enable
        constexpr uint32_t DTOESEN = (1U << 20);  ///< Data Timeout Error Status Enable
        constexpr uint32_t DCESEN = (1U << 21);  ///< Data CRC Error Status Enable
        constexpr uint32_t DEBESEN = (1U << 22);  ///< Data End Bit Error Status Enable
        constexpr uint32_t AC12ESEN = (1U << 24);  ///< Auto CMD12 Error Status Enable
        constexpr uint32_t DMAESEN = (1U << 28);  ///< DMA Error Status Enable
    }

    /// IRQSIGEN Register bits
    namespace irqsigen_bits {
        constexpr uint32_t CCIEN = (1U << 0);  ///< Command Complete Interrupt Enable
        constexpr uint32_t TCIEN = (1U << 1);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t BGEIEN = (1U << 2);  ///< Block Gap Event Interrupt Enable
        constexpr uint32_t DINTIEN = (1U << 3);  ///< DMA Interrupt Enable
        constexpr uint32_t BWRIEN = (1U << 4);  ///< Buffer Write Ready Interrupt Enable
        constexpr uint32_t BRRIEN = (1U << 5);  ///< Buffer Read Ready Interrupt Enable
        constexpr uint32_t CINSIEN = (1U << 6);  ///< Card Insertion Interrupt Enable
        constexpr uint32_t CRMIEN = (1U << 7);  ///< Card Removal Interrupt Enable
        constexpr uint32_t CINTIEN = (1U << 8);  ///< Card Interrupt Enable
        constexpr uint32_t CTOEIEN = (1U << 16);  ///< Command Timeout Error Interrupt Enable
        constexpr uint32_t CCEIEN = (1U << 17);  ///< Command CRC Error Interrupt Enable
        constexpr uint32_t CEBEIEN = (1U << 18);  ///< Command End Bit Error Interrupt Enable
        constexpr uint32_t CIEIEN = (1U << 19);  ///< Command Index Error Interrupt Enable
        constexpr uint32_t DTOEIEN = (1U << 20);  ///< Data Timeout Error Interrupt Enable
        constexpr uint32_t DCEIEN = (1U << 21);  ///< Data CRC Error Interrupt Enable
        constexpr uint32_t DEBEIEN = (1U << 22);  ///< Data End Bit Error Interrupt Enable
        constexpr uint32_t AC12EIEN = (1U << 24);  ///< Auto CMD12 Error Interrupt Enable
        constexpr uint32_t DMAEIEN = (1U << 28);  ///< DMA Error Interrupt Enable
    }

    /// AC12ERR Register bits
    namespace ac12err_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Auto CMD12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Auto CMD12 Timeout Error
        constexpr uint32_t AC12EBE = (1U << 2);  ///< Auto CMD12 End Bit Error
        constexpr uint32_t AC12CE = (1U << 3);  ///< Auto CMD12 CRC Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Auto CMD12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Command Not Issued By Auto CMD12 Error
    }

    /// HTCAPBLT Register bits
    namespace htcapblt_bits {
        constexpr uint32_t MBL = (3 << 16);  ///< Max Block Length
        constexpr uint32_t ADMAS = (1U << 20);  ///< ADMA Support
        constexpr uint32_t HSS = (1U << 21);  ///< High Speed Support
        constexpr uint32_t DMAS = (1U << 22);  ///< DMA Support
        constexpr uint32_t SRS = (1U << 23);  ///< Suspend/Resume Support
        constexpr uint32_t VS33 = (1U << 24);  ///< Voltage Support 3.3 V
    }

    /// WML Register bits
    namespace wml_bits {
        constexpr uint32_t RDWML = (8 << 0);  ///< Read Watermark Level
        constexpr uint32_t WRWML = (8 << 16);  ///< Write Watermark Level
    }

    /// FEVT Register bits
    namespace fevt_bits {
        constexpr uint32_t AC12NE = (1U << 0);  ///< Force Event Auto Command 12 Not Executed
        constexpr uint32_t AC12TOE = (1U << 1);  ///< Force Event Auto Command 12 Time Out Error
        constexpr uint32_t AC12CE = (1U << 2);  ///< Force Event Auto Command 12 CRC Error
        constexpr uint32_t AC12EBE = (1U << 3);  ///< Force Event Auto Command 12 End Bit Error
        constexpr uint32_t AC12IE = (1U << 4);  ///< Force Event Auto Command 12 Index Error
        constexpr uint32_t CNIBAC12E = (1U << 7);  ///< Force Event Command Not Executed By Auto Command 12 Error
        constexpr uint32_t CTOE = (1U << 16);  ///< Force Event Command Time Out Error
        constexpr uint32_t CCE = (1U << 17);  ///< Force Event Command CRC Error
        constexpr uint32_t CEBE = (1U << 18);  ///< Force Event Command End Bit Error
        constexpr uint32_t CIE = (1U << 19);  ///< Force Event Command Index Error
        constexpr uint32_t DTOE = (1U << 20);  ///< Force Event Data Time Out Error
        constexpr uint32_t DCE = (1U << 21);  ///< Force Event Data CRC Error
        constexpr uint32_t DEBE = (1U << 22);  ///< Force Event Data End Bit Error
        constexpr uint32_t AC12E = (1U << 24);  ///< Force Event Auto Command 12 Error
        constexpr uint32_t DMAE = (1U << 28);  ///< Force Event DMA Error
        constexpr uint32_t CINT = (1U << 31);  ///< Force Event Card Interrupt
    }

    /// ADMAES Register bits
    namespace admaes_bits {
        constexpr uint32_t ADMAES = (2 << 0);  ///< ADMA Error State (When ADMA Error Is Occurred.)
        constexpr uint32_t ADMALME = (1U << 2);  ///< ADMA Length Mismatch Error
        constexpr uint32_t ADMADCE = (1U << 3);  ///< ADMA Descriptor Error
    }

    /// ADSADDR Register bits
    namespace adsaddr_bits {
        constexpr uint32_t ADSADDR = (30 << 2);  ///< ADMA System Address
    }

    /// VENDOR Register bits
    namespace vendor_bits {
        constexpr uint32_t EXBLKNU = (1U << 1);  ///< Exact Block Number Block Read Enable For SDIO CMD53
        constexpr uint32_t INTSTVAL = (8 << 16);  ///< Internal State Value
    }

    /// MMCBOOT Register bits
    namespace mmcboot_bits {
        constexpr uint32_t DTOCVACK = (4 << 0);  ///< Boot ACK Time Out Counter Value
        constexpr uint32_t BOOTACK = (1U << 4);  ///< Boot Ack Mode Select
        constexpr uint32_t BOOTMODE = (1U << 5);  ///< Boot Mode Select
        constexpr uint32_t BOOTEN = (1U << 6);  ///< Boot Mode Enable
        constexpr uint32_t AUTOSABGEN = (1U << 7);  ///< When boot, enable auto stop at block gap function
        constexpr uint32_t BOOTBLKCNT = (16 << 16);  ///< Defines the stop at block gap value of automatic mode
    }

    /// HOSTVER Register bits
    namespace hostver_bits {
        constexpr uint32_t SVN = (8 << 0);  ///< Specification Version Number
        constexpr uint32_t VVN = (8 << 8);  ///< Vendor Version Number
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x400C4000;
    constexpr uint32_t LPUART1_BASE = 0x400C5000;
    constexpr uint32_t LPUART2_BASE = 0x400C6000;
    constexpr uint32_t LPUART3_BASE = 0x400C7000;
    constexpr uint32_t LPUART4_BASE = 0x400D6000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BAUD;  ///< Offset: 0x00 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x04 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x0C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x10 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x14 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x18 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x1C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);
    inline Registers* LPUART3 = reinterpret_cast<Registers*>(LPUART3_BASE);
    inline Registers* LPUART4 = reinterpret_cast<Registers*>(LPUART4_BASE);

    // Bit definitions
    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Over Sampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (8 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (8 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (8 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x400CC000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// LTC0 Peripheral
// ============================================================================

namespace ltc0 {
    /// Base addresses
    constexpr uint32_t LTC0_BASE = 0x400D1000;

    /// LTC0 Register structure
    struct Registers {
        volatile uint32_t LTC0_MD;  ///< Offset: 0x00 - LTC Mode Register (non-PKHA/non-RNG use)
        volatile uint32_t LTC0_MDPK;  ///< Offset: 0x00 - LTC Mode Register (PublicKey)
        volatile uint32_t LTC0_KS;  ///< Offset: 0x08 - LTC Key Size Register
        volatile uint32_t LTC0_DS;  ///< Offset: 0x10 - LTC Data Size Register
        volatile uint32_t LTC0_ICVS;  ///< Offset: 0x18 - LTC ICV Size Register
        volatile uint32_t LTC0_COM;  ///< Offset: 0x30 - LTC Command Register
        volatile uint32_t LTC0_CTL;  ///< Offset: 0x34 - LTC Control Register
        volatile uint32_t LTC0_CW;  ///< Offset: 0x40 - LTC Clear Written Register
        volatile uint32_t LTC0_STA;  ///< Offset: 0x48 - LTC Status Register
        volatile uint32_t LTC0_ESTA;  ///< Offset: 0x4C - LTC Error Status Register
        volatile uint32_t LTC0_AADSZ;  ///< Offset: 0x58 - LTC AAD Size Register
        volatile uint32_t LTC0_IVSZ;  ///< Offset: 0x60 - LTC IV Size Register
        volatile uint32_t LTC0_DPAMS;  ///< Offset: 0x68 - LTC DPA Mask Seed Register
        volatile uint32_t LTC0_PKASZ;  ///< Offset: 0x80 - LTC PKHA A Size Register
        volatile uint32_t LTC0_PKBSZ;  ///< Offset: 0x88 - LTC PKHA B Size Register
        volatile uint32_t LTC0_PKNSZ;  ///< Offset: 0x90 - LTC PKHA N Size Register
        volatile uint32_t LTC0_PKESZ;  ///< Offset: 0x98 - LTC PKHA E Size Register
        volatile uint32_t LTC0_CTX_0;  ///< Offset: 0x100 - LTC Context Register
        volatile uint32_t LTC0_CTX_1;  ///< Offset: 0x104 - LTC Context Register
        volatile uint32_t LTC0_CTX_2;  ///< Offset: 0x108 - LTC Context Register
        volatile uint32_t LTC0_CTX_3;  ///< Offset: 0x10C - LTC Context Register
        volatile uint32_t LTC0_CTX_4;  ///< Offset: 0x110 - LTC Context Register
        volatile uint32_t LTC0_CTX_5;  ///< Offset: 0x114 - LTC Context Register
        volatile uint32_t LTC0_CTX_6;  ///< Offset: 0x118 - LTC Context Register
        volatile uint32_t LTC0_CTX_7;  ///< Offset: 0x11C - LTC Context Register
        volatile uint32_t LTC0_CTX_8;  ///< Offset: 0x120 - LTC Context Register
        volatile uint32_t LTC0_CTX_9;  ///< Offset: 0x124 - LTC Context Register
        volatile uint32_t LTC0_CTX_10;  ///< Offset: 0x128 - LTC Context Register
        volatile uint32_t LTC0_CTX_11;  ///< Offset: 0x12C - LTC Context Register
        volatile uint32_t LTC0_CTX_12;  ///< Offset: 0x130 - LTC Context Register
        volatile uint32_t LTC0_CTX_13;  ///< Offset: 0x134 - LTC Context Register
        volatile uint32_t LTC0_CTX_14;  ///< Offset: 0x138 - LTC Context Register
        volatile uint32_t LTC0_CTX_15;  ///< Offset: 0x13C - LTC Context Register
        volatile uint32_t LTC0_KEY_0;  ///< Offset: 0x200 - LTC Key Registers
        volatile uint32_t LTC0_KEY_1;  ///< Offset: 0x204 - LTC Key Registers
        volatile uint32_t LTC0_KEY_2;  ///< Offset: 0x208 - LTC Key Registers
        volatile uint32_t LTC0_KEY_3;  ///< Offset: 0x20C - LTC Key Registers
        volatile uint32_t LTC0_KEY_4;  ///< Offset: 0x210 - LTC Key Registers
        volatile uint32_t LTC0_KEY_5;  ///< Offset: 0x214 - LTC Key Registers
        volatile uint32_t LTC0_KEY_6;  ///< Offset: 0x218 - LTC Key Registers
        volatile uint32_t LTC0_KEY_7;  ///< Offset: 0x21C - LTC Key Registers
        volatile uint32_t LTC0_RNG4_DRNG_STATUS;  ///< Offset: 0x300 - LTC RNG4 DRNG Status
        volatile uint32_t LTC0_RNG4_DRNG_INTERVAL_0;  ///< Offset: 0x310 - LTC RNG4 DRNG Interval 0 Register
        volatile uint32_t LTC0_RNG4_DRNG_INTERVAL_1;  ///< Offset: 0x314 - LTC RNG4 DRNG Interval 1 Register
        volatile uint32_t LTC0_RNG4_DRNG_HASH_CONTROL;  ///< Offset: 0x340 - LTC RNG4 DRNG Hash Control Register
        volatile uint32_t LTC0_RNG4_DRNG_HASH_DIGEST;  ///< Offset: 0x344 - LTC RNG4 DRNG Hash Digest Register
        volatile uint32_t LTC0_RNG4_DRNG_DEBUG_BUFFER;  ///< Offset: 0x348 - LTC RNG4 DRNG Debug Buffer
        volatile uint32_t LTC0_VID1;  ///< Offset: 0x4F0 - LTC Version ID Register
        volatile uint32_t LTC0_CHAVID;  ///< Offset: 0x4F8 - LTC CHA Version ID Register
        volatile uint32_t LTC0_FIFOSTA;  ///< Offset: 0x7C0 - LTC FIFO Status Register
        volatile uint32_t LTC0_IFIFO;  ///< Offset: 0x7E0 - LTC Input Data FIFO
        volatile uint32_t LTC0_OFIFO;  ///< Offset: 0x7F0 - LTC Output Data FIFO
        volatile uint32_t LTC0_PKA0_0;  ///< Offset: 0x800 - LTC PKHA A0 0 Register
        volatile uint32_t LTC0_PKA_0;  ///< Offset: 0x800 - LTC PKHA A 0 Register
        volatile uint32_t LTC0_PKA0_1;  ///< Offset: 0x804 - LTC PKHA A0 1 Register
        volatile uint32_t LTC0_PKA_1;  ///< Offset: 0x804 - LTC PKHA A 1 Register
        volatile uint32_t LTC0_PKA0_2;  ///< Offset: 0x808 - LTC PKHA A0 2 Register
        volatile uint32_t LTC0_PKA_2;  ///< Offset: 0x808 - LTC PKHA A 2 Register
        volatile uint32_t LTC0_PKA0_3;  ///< Offset: 0x80C - LTC PKHA A0 3 Register
        volatile uint32_t LTC0_PKA_3;  ///< Offset: 0x80C - LTC PKHA A 3 Register
        volatile uint32_t LTC0_PKA0_4;  ///< Offset: 0x810 - LTC PKHA A0 4 Register
        volatile uint32_t LTC0_PKA_4;  ///< Offset: 0x810 - LTC PKHA A 4 Register
        volatile uint32_t LTC0_PKA0_5;  ///< Offset: 0x814 - LTC PKHA A0 5 Register
        volatile uint32_t LTC0_PKA_5;  ///< Offset: 0x814 - LTC PKHA A 5 Register
        volatile uint32_t LTC0_PKA0_6;  ///< Offset: 0x818 - LTC PKHA A0 6 Register
        volatile uint32_t LTC0_PKA_6;  ///< Offset: 0x818 - LTC PKHA A 6 Register
        volatile uint32_t LTC0_PKA0_7;  ///< Offset: 0x81C - LTC PKHA A0 7 Register
        volatile uint32_t LTC0_PKA_7;  ///< Offset: 0x81C - LTC PKHA A 7 Register
        volatile uint32_t LTC0_PKA0_8;  ///< Offset: 0x820 - LTC PKHA A0 8 Register
        volatile uint32_t LTC0_PKA_8;  ///< Offset: 0x820 - LTC PKHA A 8 Register
        volatile uint32_t LTC0_PKA0_9;  ///< Offset: 0x824 - LTC PKHA A0 9 Register
        volatile uint32_t LTC0_PKA_9;  ///< Offset: 0x824 - LTC PKHA A 9 Register
        volatile uint32_t LTC0_PKA0_10;  ///< Offset: 0x828 - LTC PKHA A0 10 Register
        volatile uint32_t LTC0_PKA_10;  ///< Offset: 0x828 - LTC PKHA A 10 Register
        volatile uint32_t LTC0_PKA0_11;  ///< Offset: 0x82C - LTC PKHA A0 11 Register
        volatile uint32_t LTC0_PKA_11;  ///< Offset: 0x82C - LTC PKHA A 11 Register
        volatile uint32_t LTC0_PKA0_12;  ///< Offset: 0x830 - LTC PKHA A0 12 Register
        volatile uint32_t LTC0_PKA_12;  ///< Offset: 0x830 - LTC PKHA A 12 Register
        volatile uint32_t LTC0_PKA0_13;  ///< Offset: 0x834 - LTC PKHA A0 13 Register
        volatile uint32_t LTC0_PKA_13;  ///< Offset: 0x834 - LTC PKHA A 13 Register
        volatile uint32_t LTC0_PKA0_14;  ///< Offset: 0x838 - LTC PKHA A0 14 Register
        volatile uint32_t LTC0_PKA_14;  ///< Offset: 0x838 - LTC PKHA A 14 Register
        volatile uint32_t LTC0_PKA0_15;  ///< Offset: 0x83C - LTC PKHA A0 15 Register
        volatile uint32_t LTC0_PKA_15;  ///< Offset: 0x83C - LTC PKHA A 15 Register
        volatile uint32_t LTC0_PKA1_0;  ///< Offset: 0x840 - LTC PKHA A1 0 Register
        volatile uint32_t LTC0_PKA_16;  ///< Offset: 0x840 - LTC PKHA A 16 Register
        volatile uint32_t LTC0_PKA1_1;  ///< Offset: 0x844 - LTC PKHA A1 1 Register
        volatile uint32_t LTC0_PKA_17;  ///< Offset: 0x844 - LTC PKHA A 17 Register
        volatile uint32_t LTC0_PKA1_2;  ///< Offset: 0x848 - LTC PKHA A1 2 Register
        volatile uint32_t LTC0_PKA_18;  ///< Offset: 0x848 - LTC PKHA A 18 Register
        volatile uint32_t LTC0_PKA1_3;  ///< Offset: 0x84C - LTC PKHA A1 3 Register
        volatile uint32_t LTC0_PKA_19;  ///< Offset: 0x84C - LTC PKHA A 19 Register
        volatile uint32_t LTC0_PKA1_4;  ///< Offset: 0x850 - LTC PKHA A1 4 Register
        volatile uint32_t LTC0_PKA_20;  ///< Offset: 0x850 - LTC PKHA A 20 Register
        volatile uint32_t LTC0_PKA1_5;  ///< Offset: 0x854 - LTC PKHA A1 5 Register
        volatile uint32_t LTC0_PKA_21;  ///< Offset: 0x854 - LTC PKHA A 21 Register
        volatile uint32_t LTC0_PKA1_6;  ///< Offset: 0x858 - LTC PKHA A1 6 Register
        volatile uint32_t LTC0_PKA_22;  ///< Offset: 0x858 - LTC PKHA A 22 Register
        volatile uint32_t LTC0_PKA1_7;  ///< Offset: 0x85C - LTC PKHA A1 7 Register
        volatile uint32_t LTC0_PKA_23;  ///< Offset: 0x85C - LTC PKHA A 23 Register
        volatile uint32_t LTC0_PKA1_8;  ///< Offset: 0x860 - LTC PKHA A1 8 Register
        volatile uint32_t LTC0_PKA_24;  ///< Offset: 0x860 - LTC PKHA A 24 Register
        volatile uint32_t LTC0_PKA1_9;  ///< Offset: 0x864 - LTC PKHA A1 9 Register
        volatile uint32_t LTC0_PKA_25;  ///< Offset: 0x864 - LTC PKHA A 25 Register
        volatile uint32_t LTC0_PKA1_10;  ///< Offset: 0x868 - LTC PKHA A1 10 Register
        volatile uint32_t LTC0_PKA_26;  ///< Offset: 0x868 - LTC PKHA A 26 Register
        volatile uint32_t LTC0_PKA1_11;  ///< Offset: 0x86C - LTC PKHA A1 11 Register
        volatile uint32_t LTC0_PKA_27;  ///< Offset: 0x86C - LTC PKHA A 27 Register
        volatile uint32_t LTC0_PKA1_12;  ///< Offset: 0x870 - LTC PKHA A1 12 Register
        volatile uint32_t LTC0_PKA_28;  ///< Offset: 0x870 - LTC PKHA A 28 Register
        volatile uint32_t LTC0_PKA1_13;  ///< Offset: 0x874 - LTC PKHA A1 13 Register
        volatile uint32_t LTC0_PKA_29;  ///< Offset: 0x874 - LTC PKHA A 29 Register
        volatile uint32_t LTC0_PKA1_14;  ///< Offset: 0x878 - LTC PKHA A1 14 Register
        volatile uint32_t LTC0_PKA_30;  ///< Offset: 0x878 - LTC PKHA A 30 Register
        volatile uint32_t LTC0_PKA1_15;  ///< Offset: 0x87C - LTC PKHA A1 15 Register
        volatile uint32_t LTC0_PKA_31;  ///< Offset: 0x87C - LTC PKHA A 31 Register
        volatile uint32_t LTC0_PKA2_0;  ///< Offset: 0x880 - LTC PKHA A2 0 Register
        volatile uint32_t LTC0_PKA_32;  ///< Offset: 0x880 - LTC PKHA A 32 Register
        volatile uint32_t LTC0_PKA2_1;  ///< Offset: 0x884 - LTC PKHA A2 1 Register
        volatile uint32_t LTC0_PKA_33;  ///< Offset: 0x884 - LTC PKHA A 33 Register
        volatile uint32_t LTC0_PKA2_2;  ///< Offset: 0x888 - LTC PKHA A2 2 Register
        volatile uint32_t LTC0_PKA_34;  ///< Offset: 0x888 - LTC PKHA A 34 Register
        volatile uint32_t LTC0_PKA2_3;  ///< Offset: 0x88C - LTC PKHA A2 3 Register
        volatile uint32_t LTC0_PKA_35;  ///< Offset: 0x88C - LTC PKHA A 35 Register
        volatile uint32_t LTC0_PKA2_4;  ///< Offset: 0x890 - LTC PKHA A2 4 Register
        volatile uint32_t LTC0_PKA_36;  ///< Offset: 0x890 - LTC PKHA A 36 Register
        volatile uint32_t LTC0_PKA2_5;  ///< Offset: 0x894 - LTC PKHA A2 5 Register
        volatile uint32_t LTC0_PKA_37;  ///< Offset: 0x894 - LTC PKHA A 37 Register
        volatile uint32_t LTC0_PKA2_6;  ///< Offset: 0x898 - LTC PKHA A2 6 Register
        volatile uint32_t LTC0_PKA_38;  ///< Offset: 0x898 - LTC PKHA A 38 Register
        volatile uint32_t LTC0_PKA2_7;  ///< Offset: 0x89C - LTC PKHA A2 7 Register
        volatile uint32_t LTC0_PKA_39;  ///< Offset: 0x89C - LTC PKHA A 39 Register
        volatile uint32_t LTC0_PKA2_8;  ///< Offset: 0x8A0 - LTC PKHA A2 8 Register
        volatile uint32_t LTC0_PKA_40;  ///< Offset: 0x8A0 - LTC PKHA A 40 Register
        volatile uint32_t LTC0_PKA2_9;  ///< Offset: 0x8A4 - LTC PKHA A2 9 Register
        volatile uint32_t LTC0_PKA_41;  ///< Offset: 0x8A4 - LTC PKHA A 41 Register
        volatile uint32_t LTC0_PKA2_10;  ///< Offset: 0x8A8 - LTC PKHA A2 10 Register
        volatile uint32_t LTC0_PKA_42;  ///< Offset: 0x8A8 - LTC PKHA A 42 Register
        volatile uint32_t LTC0_PKA2_11;  ///< Offset: 0x8AC - LTC PKHA A2 11 Register
        volatile uint32_t LTC0_PKA_43;  ///< Offset: 0x8AC - LTC PKHA A 43 Register
        volatile uint32_t LTC0_PKA2_12;  ///< Offset: 0x8B0 - LTC PKHA A2 12 Register
        volatile uint32_t LTC0_PKA_44;  ///< Offset: 0x8B0 - LTC PKHA A 44 Register
        volatile uint32_t LTC0_PKA2_13;  ///< Offset: 0x8B4 - LTC PKHA A2 13 Register
        volatile uint32_t LTC0_PKA_45;  ///< Offset: 0x8B4 - LTC PKHA A 45 Register
        volatile uint32_t LTC0_PKA2_14;  ///< Offset: 0x8B8 - LTC PKHA A2 14 Register
        volatile uint32_t LTC0_PKA_46;  ///< Offset: 0x8B8 - LTC PKHA A 46 Register
        volatile uint32_t LTC0_PKA2_15;  ///< Offset: 0x8BC - LTC PKHA A2 15 Register
        volatile uint32_t LTC0_PKA_47;  ///< Offset: 0x8BC - LTC PKHA A 47 Register
        volatile uint32_t LTC0_PKA3_0;  ///< Offset: 0x8C0 - LTC PKHA A3 0 Register
        volatile uint32_t LTC0_PKA_48;  ///< Offset: 0x8C0 - LTC PKHA A 48 Register
        volatile uint32_t LTC0_PKA3_1;  ///< Offset: 0x8C4 - LTC PKHA A3 1 Register
        volatile uint32_t LTC0_PKA_49;  ///< Offset: 0x8C4 - LTC PKHA A 49 Register
        volatile uint32_t LTC0_PKA3_2;  ///< Offset: 0x8C8 - LTC PKHA A3 2 Register
        volatile uint32_t LTC0_PKA_50;  ///< Offset: 0x8C8 - LTC PKHA A 50 Register
        volatile uint32_t LTC0_PKA3_3;  ///< Offset: 0x8CC - LTC PKHA A3 3 Register
        volatile uint32_t LTC0_PKA_51;  ///< Offset: 0x8CC - LTC PKHA A 51 Register
        volatile uint32_t LTC0_PKA3_4;  ///< Offset: 0x8D0 - LTC PKHA A3 4 Register
        volatile uint32_t LTC0_PKA_52;  ///< Offset: 0x8D0 - LTC PKHA A 52 Register
        volatile uint32_t LTC0_PKA3_5;  ///< Offset: 0x8D4 - LTC PKHA A3 5 Register
        volatile uint32_t LTC0_PKA_53;  ///< Offset: 0x8D4 - LTC PKHA A 53 Register
        volatile uint32_t LTC0_PKA3_6;  ///< Offset: 0x8D8 - LTC PKHA A3 6 Register
        volatile uint32_t LTC0_PKA_54;  ///< Offset: 0x8D8 - LTC PKHA A 54 Register
        volatile uint32_t LTC0_PKA3_7;  ///< Offset: 0x8DC - LTC PKHA A3 7 Register
        volatile uint32_t LTC0_PKA_55;  ///< Offset: 0x8DC - LTC PKHA A 55 Register
        volatile uint32_t LTC0_PKA3_8;  ///< Offset: 0x8E0 - LTC PKHA A3 8 Register
        volatile uint32_t LTC0_PKA_56;  ///< Offset: 0x8E0 - LTC PKHA A 56 Register
        volatile uint32_t LTC0_PKA3_9;  ///< Offset: 0x8E4 - LTC PKHA A3 9 Register
        volatile uint32_t LTC0_PKA_57;  ///< Offset: 0x8E4 - LTC PKHA A 57 Register
        volatile uint32_t LTC0_PKA3_10;  ///< Offset: 0x8E8 - LTC PKHA A3 10 Register
        volatile uint32_t LTC0_PKA_58;  ///< Offset: 0x8E8 - LTC PKHA A 58 Register
        volatile uint32_t LTC0_PKA3_11;  ///< Offset: 0x8EC - LTC PKHA A3 11 Register
        volatile uint32_t LTC0_PKA_59;  ///< Offset: 0x8EC - LTC PKHA A 59 Register
        volatile uint32_t LTC0_PKA3_12;  ///< Offset: 0x8F0 - LTC PKHA A3 12 Register
        volatile uint32_t LTC0_PKA_60;  ///< Offset: 0x8F0 - LTC PKHA A 60 Register
        volatile uint32_t LTC0_PKA3_13;  ///< Offset: 0x8F4 - LTC PKHA A3 13 Register
        volatile uint32_t LTC0_PKA_61;  ///< Offset: 0x8F4 - LTC PKHA A 61 Register
        volatile uint32_t LTC0_PKA3_14;  ///< Offset: 0x8F8 - LTC PKHA A3 14 Register
        volatile uint32_t LTC0_PKA_62;  ///< Offset: 0x8F8 - LTC PKHA A 62 Register
        volatile uint32_t LTC0_PKA3_15;  ///< Offset: 0x8FC - LTC PKHA A3 15 Register
        volatile uint32_t LTC0_PKA_63;  ///< Offset: 0x8FC - LTC PKHA A 63 Register
        volatile uint32_t LTC0_PKB0_0;  ///< Offset: 0xA00 - LTC PKHA B0 0 Register
        volatile uint32_t LTC0_PKB_0;  ///< Offset: 0xA00 - LTC PKHA B 0 Register
        volatile uint32_t LTC0_PKB0_1;  ///< Offset: 0xA04 - LTC PKHA B0 1 Register
        volatile uint32_t LTC0_PKB_1;  ///< Offset: 0xA04 - LTC PKHA B 1 Register
        volatile uint32_t LTC0_PKB0_2;  ///< Offset: 0xA08 - LTC PKHA B0 2 Register
        volatile uint32_t LTC0_PKB_2;  ///< Offset: 0xA08 - LTC PKHA B 2 Register
        volatile uint32_t LTC0_PKB0_3;  ///< Offset: 0xA0C - LTC PKHA B0 3 Register
        volatile uint32_t LTC0_PKB_3;  ///< Offset: 0xA0C - LTC PKHA B 3 Register
        volatile uint32_t LTC0_PKB0_4;  ///< Offset: 0xA10 - LTC PKHA B0 4 Register
        volatile uint32_t LTC0_PKB_4;  ///< Offset: 0xA10 - LTC PKHA B 4 Register
        volatile uint32_t LTC0_PKB0_5;  ///< Offset: 0xA14 - LTC PKHA B0 5 Register
        volatile uint32_t LTC0_PKB_5;  ///< Offset: 0xA14 - LTC PKHA B 5 Register
        volatile uint32_t LTC0_PKB0_6;  ///< Offset: 0xA18 - LTC PKHA B0 6 Register
        volatile uint32_t LTC0_PKB_6;  ///< Offset: 0xA18 - LTC PKHA B 6 Register
        volatile uint32_t LTC0_PKB0_7;  ///< Offset: 0xA1C - LTC PKHA B0 7 Register
        volatile uint32_t LTC0_PKB_7;  ///< Offset: 0xA1C - LTC PKHA B 7 Register
        volatile uint32_t LTC0_PKB0_8;  ///< Offset: 0xA20 - LTC PKHA B0 8 Register
        volatile uint32_t LTC0_PKB_8;  ///< Offset: 0xA20 - LTC PKHA B 8 Register
        volatile uint32_t LTC0_PKB0_9;  ///< Offset: 0xA24 - LTC PKHA B0 9 Register
        volatile uint32_t LTC0_PKB_9;  ///< Offset: 0xA24 - LTC PKHA B 9 Register
        volatile uint32_t LTC0_PKB0_10;  ///< Offset: 0xA28 - LTC PKHA B0 10 Register
        volatile uint32_t LTC0_PKB_10;  ///< Offset: 0xA28 - LTC PKHA B 10 Register
        volatile uint32_t LTC0_PKB0_11;  ///< Offset: 0xA2C - LTC PKHA B0 11 Register
        volatile uint32_t LTC0_PKB_11;  ///< Offset: 0xA2C - LTC PKHA B 11 Register
        volatile uint32_t LTC0_PKB0_12;  ///< Offset: 0xA30 - LTC PKHA B0 12 Register
        volatile uint32_t LTC0_PKB_12;  ///< Offset: 0xA30 - LTC PKHA B 12 Register
        volatile uint32_t LTC0_PKB0_13;  ///< Offset: 0xA34 - LTC PKHA B0 13 Register
        volatile uint32_t LTC0_PKB_13;  ///< Offset: 0xA34 - LTC PKHA B 13 Register
        volatile uint32_t LTC0_PKB0_14;  ///< Offset: 0xA38 - LTC PKHA B0 14 Register
        volatile uint32_t LTC0_PKB_14;  ///< Offset: 0xA38 - LTC PKHA B 14 Register
        volatile uint32_t LTC0_PKB0_15;  ///< Offset: 0xA3C - LTC PKHA B0 15 Register
        volatile uint32_t LTC0_PKB_15;  ///< Offset: 0xA3C - LTC PKHA B 15 Register
        volatile uint32_t LTC0_PKB1_0;  ///< Offset: 0xA40 - LTC PKHA B1 0 Register
        volatile uint32_t LTC0_PKB_16;  ///< Offset: 0xA40 - LTC PKHA B 16 Register
        volatile uint32_t LTC0_PKB1_1;  ///< Offset: 0xA44 - LTC PKHA B1 1 Register
        volatile uint32_t LTC0_PKB_17;  ///< Offset: 0xA44 - LTC PKHA B 17 Register
        volatile uint32_t LTC0_PKB1_2;  ///< Offset: 0xA48 - LTC PKHA B1 2 Register
        volatile uint32_t LTC0_PKB_18;  ///< Offset: 0xA48 - LTC PKHA B 18 Register
        volatile uint32_t LTC0_PKB1_3;  ///< Offset: 0xA4C - LTC PKHA B1 3 Register
        volatile uint32_t LTC0_PKB_19;  ///< Offset: 0xA4C - LTC PKHA B 19 Register
        volatile uint32_t LTC0_PKB1_4;  ///< Offset: 0xA50 - LTC PKHA B1 4 Register
        volatile uint32_t LTC0_PKB_20;  ///< Offset: 0xA50 - LTC PKHA B 20 Register
        volatile uint32_t LTC0_PKB1_5;  ///< Offset: 0xA54 - LTC PKHA B1 5 Register
        volatile uint32_t LTC0_PKB_21;  ///< Offset: 0xA54 - LTC PKHA B 21 Register
        volatile uint32_t LTC0_PKB1_6;  ///< Offset: 0xA58 - LTC PKHA B1 6 Register
        volatile uint32_t LTC0_PKB_22;  ///< Offset: 0xA58 - LTC PKHA B 22 Register
        volatile uint32_t LTC0_PKB1_7;  ///< Offset: 0xA5C - LTC PKHA B1 7 Register
        volatile uint32_t LTC0_PKB_23;  ///< Offset: 0xA5C - LTC PKHA B 23 Register
        volatile uint32_t LTC0_PKB1_8;  ///< Offset: 0xA60 - LTC PKHA B1 8 Register
        volatile uint32_t LTC0_PKB_24;  ///< Offset: 0xA60 - LTC PKHA B 24 Register
        volatile uint32_t LTC0_PKB1_9;  ///< Offset: 0xA64 - LTC PKHA B1 9 Register
        volatile uint32_t LTC0_PKB_25;  ///< Offset: 0xA64 - LTC PKHA B 25 Register
        volatile uint32_t LTC0_PKB1_10;  ///< Offset: 0xA68 - LTC PKHA B1 10 Register
        volatile uint32_t LTC0_PKB_26;  ///< Offset: 0xA68 - LTC PKHA B 26 Register
        volatile uint32_t LTC0_PKB1_11;  ///< Offset: 0xA6C - LTC PKHA B1 11 Register
        volatile uint32_t LTC0_PKB_27;  ///< Offset: 0xA6C - LTC PKHA B 27 Register
        volatile uint32_t LTC0_PKB1_12;  ///< Offset: 0xA70 - LTC PKHA B1 12 Register
        volatile uint32_t LTC0_PKB_28;  ///< Offset: 0xA70 - LTC PKHA B 28 Register
        volatile uint32_t LTC0_PKB1_13;  ///< Offset: 0xA74 - LTC PKHA B1 13 Register
        volatile uint32_t LTC0_PKB_29;  ///< Offset: 0xA74 - LTC PKHA B 29 Register
        volatile uint32_t LTC0_PKB1_14;  ///< Offset: 0xA78 - LTC PKHA B1 14 Register
        volatile uint32_t LTC0_PKB_30;  ///< Offset: 0xA78 - LTC PKHA B 30 Register
        volatile uint32_t LTC0_PKB1_15;  ///< Offset: 0xA7C - LTC PKHA B1 15 Register
        volatile uint32_t LTC0_PKB_31;  ///< Offset: 0xA7C - LTC PKHA B 31 Register
        volatile uint32_t LTC0_PKB2_0;  ///< Offset: 0xA80 - LTC PKHA B2 0 Register
        volatile uint32_t LTC0_PKB_32;  ///< Offset: 0xA80 - LTC PKHA B 32 Register
        volatile uint32_t LTC0_PKB2_1;  ///< Offset: 0xA84 - LTC PKHA B2 1 Register
        volatile uint32_t LTC0_PKB_33;  ///< Offset: 0xA84 - LTC PKHA B 33 Register
        volatile uint32_t LTC0_PKB2_2;  ///< Offset: 0xA88 - LTC PKHA B2 2 Register
        volatile uint32_t LTC0_PKB_34;  ///< Offset: 0xA88 - LTC PKHA B 34 Register
        volatile uint32_t LTC0_PKB2_3;  ///< Offset: 0xA8C - LTC PKHA B2 3 Register
        volatile uint32_t LTC0_PKB_35;  ///< Offset: 0xA8C - LTC PKHA B 35 Register
        volatile uint32_t LTC0_PKB2_4;  ///< Offset: 0xA90 - LTC PKHA B2 4 Register
        volatile uint32_t LTC0_PKB_36;  ///< Offset: 0xA90 - LTC PKHA B 36 Register
        volatile uint32_t LTC0_PKB2_5;  ///< Offset: 0xA94 - LTC PKHA B2 5 Register
        volatile uint32_t LTC0_PKB_37;  ///< Offset: 0xA94 - LTC PKHA B 37 Register
        volatile uint32_t LTC0_PKB2_6;  ///< Offset: 0xA98 - LTC PKHA B2 6 Register
        volatile uint32_t LTC0_PKB_38;  ///< Offset: 0xA98 - LTC PKHA B 38 Register
        volatile uint32_t LTC0_PKB2_7;  ///< Offset: 0xA9C - LTC PKHA B2 7 Register
        volatile uint32_t LTC0_PKB_39;  ///< Offset: 0xA9C - LTC PKHA B 39 Register
        volatile uint32_t LTC0_PKB2_8;  ///< Offset: 0xAA0 - LTC PKHA B2 8 Register
        volatile uint32_t LTC0_PKB_40;  ///< Offset: 0xAA0 - LTC PKHA B 40 Register
        volatile uint32_t LTC0_PKB2_9;  ///< Offset: 0xAA4 - LTC PKHA B2 9 Register
        volatile uint32_t LTC0_PKB_41;  ///< Offset: 0xAA4 - LTC PKHA B 41 Register
        volatile uint32_t LTC0_PKB2_10;  ///< Offset: 0xAA8 - LTC PKHA B2 10 Register
        volatile uint32_t LTC0_PKB_42;  ///< Offset: 0xAA8 - LTC PKHA B 42 Register
        volatile uint32_t LTC0_PKB2_11;  ///< Offset: 0xAAC - LTC PKHA B2 11 Register
        volatile uint32_t LTC0_PKB_43;  ///< Offset: 0xAAC - LTC PKHA B 43 Register
        volatile uint32_t LTC0_PKB2_12;  ///< Offset: 0xAB0 - LTC PKHA B2 12 Register
        volatile uint32_t LTC0_PKB_44;  ///< Offset: 0xAB0 - LTC PKHA B 44 Register
        volatile uint32_t LTC0_PKB2_13;  ///< Offset: 0xAB4 - LTC PKHA B2 13 Register
        volatile uint32_t LTC0_PKB_45;  ///< Offset: 0xAB4 - LTC PKHA B 45 Register
        volatile uint32_t LTC0_PKB2_14;  ///< Offset: 0xAB8 - LTC PKHA B2 14 Register
        volatile uint32_t LTC0_PKB_46;  ///< Offset: 0xAB8 - LTC PKHA B 46 Register
        volatile uint32_t LTC0_PKB2_15;  ///< Offset: 0xABC - LTC PKHA B2 15 Register
        volatile uint32_t LTC0_PKB_47;  ///< Offset: 0xABC - LTC PKHA B 47 Register
        volatile uint32_t LTC0_PKB3_0;  ///< Offset: 0xAC0 - LTC PKHA B3 0 Register
        volatile uint32_t LTC0_PKB_48;  ///< Offset: 0xAC0 - LTC PKHA B 48 Register
        volatile uint32_t LTC0_PKB3_1;  ///< Offset: 0xAC4 - LTC PKHA B3 1 Register
        volatile uint32_t LTC0_PKB_49;  ///< Offset: 0xAC4 - LTC PKHA B 49 Register
        volatile uint32_t LTC0_PKB3_2;  ///< Offset: 0xAC8 - LTC PKHA B3 2 Register
        volatile uint32_t LTC0_PKB_50;  ///< Offset: 0xAC8 - LTC PKHA B 50 Register
        volatile uint32_t LTC0_PKB3_3;  ///< Offset: 0xACC - LTC PKHA B3 3 Register
        volatile uint32_t LTC0_PKB_51;  ///< Offset: 0xACC - LTC PKHA B 51 Register
        volatile uint32_t LTC0_PKB3_4;  ///< Offset: 0xAD0 - LTC PKHA B3 4 Register
        volatile uint32_t LTC0_PKB_52;  ///< Offset: 0xAD0 - LTC PKHA B 52 Register
        volatile uint32_t LTC0_PKB3_5;  ///< Offset: 0xAD4 - LTC PKHA B3 5 Register
        volatile uint32_t LTC0_PKB_53;  ///< Offset: 0xAD4 - LTC PKHA B 53 Register
        volatile uint32_t LTC0_PKB3_6;  ///< Offset: 0xAD8 - LTC PKHA B3 6 Register
        volatile uint32_t LTC0_PKB_54;  ///< Offset: 0xAD8 - LTC PKHA B 54 Register
        volatile uint32_t LTC0_PKB3_7;  ///< Offset: 0xADC - LTC PKHA B3 7 Register
        volatile uint32_t LTC0_PKB_55;  ///< Offset: 0xADC - LTC PKHA B 55 Register
        volatile uint32_t LTC0_PKB3_8;  ///< Offset: 0xAE0 - LTC PKHA B3 8 Register
        volatile uint32_t LTC0_PKB_56;  ///< Offset: 0xAE0 - LTC PKHA B 56 Register
        volatile uint32_t LTC0_PKB3_9;  ///< Offset: 0xAE4 - LTC PKHA B3 9 Register
        volatile uint32_t LTC0_PKB_57;  ///< Offset: 0xAE4 - LTC PKHA B 57 Register
        volatile uint32_t LTC0_PKB3_10;  ///< Offset: 0xAE8 - LTC PKHA B3 10 Register
        volatile uint32_t LTC0_PKB_58;  ///< Offset: 0xAE8 - LTC PKHA B 58 Register
        volatile uint32_t LTC0_PKB3_11;  ///< Offset: 0xAEC - LTC PKHA B3 11 Register
        volatile uint32_t LTC0_PKB_59;  ///< Offset: 0xAEC - LTC PKHA B 59 Register
        volatile uint32_t LTC0_PKB3_12;  ///< Offset: 0xAF0 - LTC PKHA B3 12 Register
        volatile uint32_t LTC0_PKB_60;  ///< Offset: 0xAF0 - LTC PKHA B 60 Register
        volatile uint32_t LTC0_PKB3_13;  ///< Offset: 0xAF4 - LTC PKHA B3 13 Register
        volatile uint32_t LTC0_PKB_61;  ///< Offset: 0xAF4 - LTC PKHA B 61 Register
        volatile uint32_t LTC0_PKB3_14;  ///< Offset: 0xAF8 - LTC PKHA B3 14 Register
        volatile uint32_t LTC0_PKB_62;  ///< Offset: 0xAF8 - LTC PKHA B 62 Register
        volatile uint32_t LTC0_PKB3_15;  ///< Offset: 0xAFC - LTC PKHA B3 15 Register
        volatile uint32_t LTC0_PKB_63;  ///< Offset: 0xAFC - LTC PKHA B 63 Register
        volatile uint32_t LTC0_PKN0_0;  ///< Offset: 0xC00 - LTC PKHA N0 0 Register
        volatile uint32_t LTC0_PKN_0;  ///< Offset: 0xC00 - LTC PKHA N 0 Register
        volatile uint32_t LTC0_PKN0_1;  ///< Offset: 0xC04 - LTC PKHA N0 1 Register
        volatile uint32_t LTC0_PKN_1;  ///< Offset: 0xC04 - LTC PKHA N 1 Register
        volatile uint32_t LTC0_PKN0_2;  ///< Offset: 0xC08 - LTC PKHA N0 2 Register
        volatile uint32_t LTC0_PKN_2;  ///< Offset: 0xC08 - LTC PKHA N 2 Register
        volatile uint32_t LTC0_PKN0_3;  ///< Offset: 0xC0C - LTC PKHA N0 3 Register
        volatile uint32_t LTC0_PKN_3;  ///< Offset: 0xC0C - LTC PKHA N 3 Register
        volatile uint32_t LTC0_PKN0_4;  ///< Offset: 0xC10 - LTC PKHA N0 4 Register
        volatile uint32_t LTC0_PKN_4;  ///< Offset: 0xC10 - LTC PKHA N 4 Register
        volatile uint32_t LTC0_PKN0_5;  ///< Offset: 0xC14 - LTC PKHA N0 5 Register
        volatile uint32_t LTC0_PKN_5;  ///< Offset: 0xC14 - LTC PKHA N 5 Register
        volatile uint32_t LTC0_PKN0_6;  ///< Offset: 0xC18 - LTC PKHA N0 6 Register
        volatile uint32_t LTC0_PKN_6;  ///< Offset: 0xC18 - LTC PKHA N 6 Register
        volatile uint32_t LTC0_PKN0_7;  ///< Offset: 0xC1C - LTC PKHA N0 7 Register
        volatile uint32_t LTC0_PKN_7;  ///< Offset: 0xC1C - LTC PKHA N 7 Register
        volatile uint32_t LTC0_PKN0_8;  ///< Offset: 0xC20 - LTC PKHA N0 8 Register
        volatile uint32_t LTC0_PKN_8;  ///< Offset: 0xC20 - LTC PKHA N 8 Register
        volatile uint32_t LTC0_PKN0_9;  ///< Offset: 0xC24 - LTC PKHA N0 9 Register
        volatile uint32_t LTC0_PKN_9;  ///< Offset: 0xC24 - LTC PKHA N 9 Register
        volatile uint32_t LTC0_PKN0_10;  ///< Offset: 0xC28 - LTC PKHA N0 10 Register
        volatile uint32_t LTC0_PKN_10;  ///< Offset: 0xC28 - LTC PKHA N 10 Register
        volatile uint32_t LTC0_PKN0_11;  ///< Offset: 0xC2C - LTC PKHA N0 11 Register
        volatile uint32_t LTC0_PKN_11;  ///< Offset: 0xC2C - LTC PKHA N 11 Register
        volatile uint32_t LTC0_PKN0_12;  ///< Offset: 0xC30 - LTC PKHA N0 12 Register
        volatile uint32_t LTC0_PKN_12;  ///< Offset: 0xC30 - LTC PKHA N 12 Register
        volatile uint32_t LTC0_PKN0_13;  ///< Offset: 0xC34 - LTC PKHA N0 13 Register
        volatile uint32_t LTC0_PKN_13;  ///< Offset: 0xC34 - LTC PKHA N 13 Register
        volatile uint32_t LTC0_PKN0_14;  ///< Offset: 0xC38 - LTC PKHA N0 14 Register
        volatile uint32_t LTC0_PKN_14;  ///< Offset: 0xC38 - LTC PKHA N 14 Register
        volatile uint32_t LTC0_PKN0_15;  ///< Offset: 0xC3C - LTC PKHA N0 15 Register
        volatile uint32_t LTC0_PKN_15;  ///< Offset: 0xC3C - LTC PKHA N 15 Register
        volatile uint32_t LTC0_PKN1_0;  ///< Offset: 0xC40 - LTC PKHA N1 0 Register
        volatile uint32_t LTC0_PKN_16;  ///< Offset: 0xC40 - LTC PKHA N 16 Register
        volatile uint32_t LTC0_PKN1_1;  ///< Offset: 0xC44 - LTC PKHA N1 1 Register
        volatile uint32_t LTC0_PKN_17;  ///< Offset: 0xC44 - LTC PKHA N 17 Register
        volatile uint32_t LTC0_PKN1_2;  ///< Offset: 0xC48 - LTC PKHA N1 2 Register
        volatile uint32_t LTC0_PKN_18;  ///< Offset: 0xC48 - LTC PKHA N 18 Register
        volatile uint32_t LTC0_PKN1_3;  ///< Offset: 0xC4C - LTC PKHA N1 3 Register
        volatile uint32_t LTC0_PKN_19;  ///< Offset: 0xC4C - LTC PKHA N 19 Register
        volatile uint32_t LTC0_PKN1_4;  ///< Offset: 0xC50 - LTC PKHA N1 4 Register
        volatile uint32_t LTC0_PKN_20;  ///< Offset: 0xC50 - LTC PKHA N 20 Register
        volatile uint32_t LTC0_PKN1_5;  ///< Offset: 0xC54 - LTC PKHA N1 5 Register
        volatile uint32_t LTC0_PKN_21;  ///< Offset: 0xC54 - LTC PKHA N 21 Register
        volatile uint32_t LTC0_PKN1_6;  ///< Offset: 0xC58 - LTC PKHA N1 6 Register
        volatile uint32_t LTC0_PKN_22;  ///< Offset: 0xC58 - LTC PKHA N 22 Register
        volatile uint32_t LTC0_PKN1_7;  ///< Offset: 0xC5C - LTC PKHA N1 7 Register
        volatile uint32_t LTC0_PKN_23;  ///< Offset: 0xC5C - LTC PKHA N 23 Register
        volatile uint32_t LTC0_PKN1_8;  ///< Offset: 0xC60 - LTC PKHA N1 8 Register
        volatile uint32_t LTC0_PKN_24;  ///< Offset: 0xC60 - LTC PKHA N 24 Register
        volatile uint32_t LTC0_PKN1_9;  ///< Offset: 0xC64 - LTC PKHA N1 9 Register
        volatile uint32_t LTC0_PKN_25;  ///< Offset: 0xC64 - LTC PKHA N 25 Register
        volatile uint32_t LTC0_PKN1_10;  ///< Offset: 0xC68 - LTC PKHA N1 10 Register
        volatile uint32_t LTC0_PKN_26;  ///< Offset: 0xC68 - LTC PKHA N 26 Register
        volatile uint32_t LTC0_PKN1_11;  ///< Offset: 0xC6C - LTC PKHA N1 11 Register
        volatile uint32_t LTC0_PKN_27;  ///< Offset: 0xC6C - LTC PKHA N 27 Register
        volatile uint32_t LTC0_PKN1_12;  ///< Offset: 0xC70 - LTC PKHA N1 12 Register
        volatile uint32_t LTC0_PKN_28;  ///< Offset: 0xC70 - LTC PKHA N 28 Register
        volatile uint32_t LTC0_PKN1_13;  ///< Offset: 0xC74 - LTC PKHA N1 13 Register
        volatile uint32_t LTC0_PKN_29;  ///< Offset: 0xC74 - LTC PKHA N 29 Register
        volatile uint32_t LTC0_PKN1_14;  ///< Offset: 0xC78 - LTC PKHA N1 14 Register
        volatile uint32_t LTC0_PKN_30;  ///< Offset: 0xC78 - LTC PKHA N 30 Register
        volatile uint32_t LTC0_PKN1_15;  ///< Offset: 0xC7C - LTC PKHA N1 15 Register
        volatile uint32_t LTC0_PKN_31;  ///< Offset: 0xC7C - LTC PKHA N 31 Register
        volatile uint32_t LTC0_PKN2_0;  ///< Offset: 0xC80 - LTC PKHA N2 0 Register
        volatile uint32_t LTC0_PKN_32;  ///< Offset: 0xC80 - LTC PKHA N 32 Register
        volatile uint32_t LTC0_PKN2_1;  ///< Offset: 0xC84 - LTC PKHA N2 1 Register
        volatile uint32_t LTC0_PKN_33;  ///< Offset: 0xC84 - LTC PKHA N 33 Register
        volatile uint32_t LTC0_PKN2_2;  ///< Offset: 0xC88 - LTC PKHA N2 2 Register
        volatile uint32_t LTC0_PKN_34;  ///< Offset: 0xC88 - LTC PKHA N 34 Register
        volatile uint32_t LTC0_PKN2_3;  ///< Offset: 0xC8C - LTC PKHA N2 3 Register
        volatile uint32_t LTC0_PKN_35;  ///< Offset: 0xC8C - LTC PKHA N 35 Register
        volatile uint32_t LTC0_PKN2_4;  ///< Offset: 0xC90 - LTC PKHA N2 4 Register
        volatile uint32_t LTC0_PKN_36;  ///< Offset: 0xC90 - LTC PKHA N 36 Register
        volatile uint32_t LTC0_PKN2_5;  ///< Offset: 0xC94 - LTC PKHA N2 5 Register
        volatile uint32_t LTC0_PKN_37;  ///< Offset: 0xC94 - LTC PKHA N 37 Register
        volatile uint32_t LTC0_PKN2_6;  ///< Offset: 0xC98 - LTC PKHA N2 6 Register
        volatile uint32_t LTC0_PKN_38;  ///< Offset: 0xC98 - LTC PKHA N 38 Register
        volatile uint32_t LTC0_PKN2_7;  ///< Offset: 0xC9C - LTC PKHA N2 7 Register
        volatile uint32_t LTC0_PKN_39;  ///< Offset: 0xC9C - LTC PKHA N 39 Register
        volatile uint32_t LTC0_PKN2_8;  ///< Offset: 0xCA0 - LTC PKHA N2 8 Register
        volatile uint32_t LTC0_PKN_40;  ///< Offset: 0xCA0 - LTC PKHA N 40 Register
        volatile uint32_t LTC0_PKN2_9;  ///< Offset: 0xCA4 - LTC PKHA N2 9 Register
        volatile uint32_t LTC0_PKN_41;  ///< Offset: 0xCA4 - LTC PKHA N 41 Register
        volatile uint32_t LTC0_PKN2_10;  ///< Offset: 0xCA8 - LTC PKHA N2 10 Register
        volatile uint32_t LTC0_PKN_42;  ///< Offset: 0xCA8 - LTC PKHA N 42 Register
        volatile uint32_t LTC0_PKN2_11;  ///< Offset: 0xCAC - LTC PKHA N2 11 Register
        volatile uint32_t LTC0_PKN_43;  ///< Offset: 0xCAC - LTC PKHA N 43 Register
        volatile uint32_t LTC0_PKN2_12;  ///< Offset: 0xCB0 - LTC PKHA N2 12 Register
        volatile uint32_t LTC0_PKN_44;  ///< Offset: 0xCB0 - LTC PKHA N 44 Register
        volatile uint32_t LTC0_PKN2_13;  ///< Offset: 0xCB4 - LTC PKHA N2 13 Register
        volatile uint32_t LTC0_PKN_45;  ///< Offset: 0xCB4 - LTC PKHA N 45 Register
        volatile uint32_t LTC0_PKN2_14;  ///< Offset: 0xCB8 - LTC PKHA N2 14 Register
        volatile uint32_t LTC0_PKN_46;  ///< Offset: 0xCB8 - LTC PKHA N 46 Register
        volatile uint32_t LTC0_PKN2_15;  ///< Offset: 0xCBC - LTC PKHA N2 15 Register
        volatile uint32_t LTC0_PKN_47;  ///< Offset: 0xCBC - LTC PKHA N 47 Register
        volatile uint32_t LTC0_PKN3_0;  ///< Offset: 0xCC0 - LTC PKHA N3 0 Register
        volatile uint32_t LTC0_PKN_48;  ///< Offset: 0xCC0 - LTC PKHA N 48 Register
        volatile uint32_t LTC0_PKN3_1;  ///< Offset: 0xCC4 - LTC PKHA N3 1 Register
        volatile uint32_t LTC0_PKN_49;  ///< Offset: 0xCC4 - LTC PKHA N 49 Register
        volatile uint32_t LTC0_PKN3_2;  ///< Offset: 0xCC8 - LTC PKHA N3 2 Register
        volatile uint32_t LTC0_PKN_50;  ///< Offset: 0xCC8 - LTC PKHA N 50 Register
        volatile uint32_t LTC0_PKN3_3;  ///< Offset: 0xCCC - LTC PKHA N3 3 Register
        volatile uint32_t LTC0_PKN_51;  ///< Offset: 0xCCC - LTC PKHA N 51 Register
        volatile uint32_t LTC0_PKN3_4;  ///< Offset: 0xCD0 - LTC PKHA N3 4 Register
        volatile uint32_t LTC0_PKN_52;  ///< Offset: 0xCD0 - LTC PKHA N 52 Register
        volatile uint32_t LTC0_PKN3_5;  ///< Offset: 0xCD4 - LTC PKHA N3 5 Register
        volatile uint32_t LTC0_PKN_53;  ///< Offset: 0xCD4 - LTC PKHA N 53 Register
        volatile uint32_t LTC0_PKN3_6;  ///< Offset: 0xCD8 - LTC PKHA N3 6 Register
        volatile uint32_t LTC0_PKN_54;  ///< Offset: 0xCD8 - LTC PKHA N 54 Register
        volatile uint32_t LTC0_PKN3_7;  ///< Offset: 0xCDC - LTC PKHA N3 7 Register
        volatile uint32_t LTC0_PKN_55;  ///< Offset: 0xCDC - LTC PKHA N 55 Register
        volatile uint32_t LTC0_PKN3_8;  ///< Offset: 0xCE0 - LTC PKHA N3 8 Register
        volatile uint32_t LTC0_PKN_56;  ///< Offset: 0xCE0 - LTC PKHA N 56 Register
        volatile uint32_t LTC0_PKN3_9;  ///< Offset: 0xCE4 - LTC PKHA N3 9 Register
        volatile uint32_t LTC0_PKN_57;  ///< Offset: 0xCE4 - LTC PKHA N 57 Register
        volatile uint32_t LTC0_PKN3_10;  ///< Offset: 0xCE8 - LTC PKHA N3 10 Register
        volatile uint32_t LTC0_PKN_58;  ///< Offset: 0xCE8 - LTC PKHA N 58 Register
        volatile uint32_t LTC0_PKN3_11;  ///< Offset: 0xCEC - LTC PKHA N3 11 Register
        volatile uint32_t LTC0_PKN_59;  ///< Offset: 0xCEC - LTC PKHA N 59 Register
        volatile uint32_t LTC0_PKN3_12;  ///< Offset: 0xCF0 - LTC PKHA N3 12 Register
        volatile uint32_t LTC0_PKN_60;  ///< Offset: 0xCF0 - LTC PKHA N 60 Register
        volatile uint32_t LTC0_PKN3_13;  ///< Offset: 0xCF4 - LTC PKHA N3 13 Register
        volatile uint32_t LTC0_PKN_61;  ///< Offset: 0xCF4 - LTC PKHA N 61 Register
        volatile uint32_t LTC0_PKN3_14;  ///< Offset: 0xCF8 - LTC PKHA N3 14 Register
        volatile uint32_t LTC0_PKN_62;  ///< Offset: 0xCF8 - LTC PKHA N 62 Register
        volatile uint32_t LTC0_PKN3_15;  ///< Offset: 0xCFC - LTC PKHA N3 15 Register
        volatile uint32_t LTC0_PKN_63;  ///< Offset: 0xCFC - LTC PKHA N 63 Register
        volatile uint32_t LTC0_PKE0_0;  ///< Offset: 0xE00 - LTC PKHA E0 0 Register
        volatile uint32_t LTC0_PKE_0;  ///< Offset: 0xE00 - LTC PKHA E 0 Register
        volatile uint32_t LTC0_PKE0_1;  ///< Offset: 0xE04 - LTC PKHA E0 1 Register
        volatile uint32_t LTC0_PKE_1;  ///< Offset: 0xE04 - LTC PKHA E 1 Register
        volatile uint32_t LTC0_PKE0_2;  ///< Offset: 0xE08 - LTC PKHA E0 2 Register
        volatile uint32_t LTC0_PKE_2;  ///< Offset: 0xE08 - LTC PKHA E 2 Register
        volatile uint32_t LTC0_PKE0_3;  ///< Offset: 0xE0C - LTC PKHA E0 3 Register
        volatile uint32_t LTC0_PKE_3;  ///< Offset: 0xE0C - LTC PKHA E 3 Register
        volatile uint32_t LTC0_PKE0_4;  ///< Offset: 0xE10 - LTC PKHA E0 4 Register
        volatile uint32_t LTC0_PKE_4;  ///< Offset: 0xE10 - LTC PKHA E 4 Register
        volatile uint32_t LTC0_PKE0_5;  ///< Offset: 0xE14 - LTC PKHA E0 5 Register
        volatile uint32_t LTC0_PKE_5;  ///< Offset: 0xE14 - LTC PKHA E 5 Register
        volatile uint32_t LTC0_PKE0_6;  ///< Offset: 0xE18 - LTC PKHA E0 6 Register
        volatile uint32_t LTC0_PKE_6;  ///< Offset: 0xE18 - LTC PKHA E 6 Register
        volatile uint32_t LTC0_PKE0_7;  ///< Offset: 0xE1C - LTC PKHA E0 7 Register
        volatile uint32_t LTC0_PKE_7;  ///< Offset: 0xE1C - LTC PKHA E 7 Register
        volatile uint32_t LTC0_PKE0_8;  ///< Offset: 0xE20 - LTC PKHA E0 8 Register
        volatile uint32_t LTC0_PKE_8;  ///< Offset: 0xE20 - LTC PKHA E 8 Register
        volatile uint32_t LTC0_PKE0_9;  ///< Offset: 0xE24 - LTC PKHA E0 9 Register
        volatile uint32_t LTC0_PKE_9;  ///< Offset: 0xE24 - LTC PKHA E 9 Register
        volatile uint32_t LTC0_PKE0_10;  ///< Offset: 0xE28 - LTC PKHA E0 10 Register
        volatile uint32_t LTC0_PKE_10;  ///< Offset: 0xE28 - LTC PKHA E 10 Register
        volatile uint32_t LTC0_PKE0_11;  ///< Offset: 0xE2C - LTC PKHA E0 11 Register
        volatile uint32_t LTC0_PKE_11;  ///< Offset: 0xE2C - LTC PKHA E 11 Register
        volatile uint32_t LTC0_PKE0_12;  ///< Offset: 0xE30 - LTC PKHA E0 12 Register
        volatile uint32_t LTC0_PKE_12;  ///< Offset: 0xE30 - LTC PKHA E 12 Register
        volatile uint32_t LTC0_PKE0_13;  ///< Offset: 0xE34 - LTC PKHA E0 13 Register
        volatile uint32_t LTC0_PKE_13;  ///< Offset: 0xE34 - LTC PKHA E 13 Register
        volatile uint32_t LTC0_PKE0_14;  ///< Offset: 0xE38 - LTC PKHA E0 14 Register
        volatile uint32_t LTC0_PKE_14;  ///< Offset: 0xE38 - LTC PKHA E 14 Register
        volatile uint32_t LTC0_PKE0_15;  ///< Offset: 0xE3C - LTC PKHA E0 15 Register
        volatile uint32_t LTC0_PKE_15;  ///< Offset: 0xE3C - LTC PKHA E 15 Register
        volatile uint32_t LTC0_PKE1_0;  ///< Offset: 0xE40 - LTC PKHA E1 0 Register
        volatile uint32_t LTC0_PKE_16;  ///< Offset: 0xE40 - LTC PKHA E 16 Register
        volatile uint32_t LTC0_PKE1_1;  ///< Offset: 0xE44 - LTC PKHA E1 1 Register
        volatile uint32_t LTC0_PKE_17;  ///< Offset: 0xE44 - LTC PKHA E 17 Register
        volatile uint32_t LTC0_PKE1_2;  ///< Offset: 0xE48 - LTC PKHA E1 2 Register
        volatile uint32_t LTC0_PKE_18;  ///< Offset: 0xE48 - LTC PKHA E 18 Register
        volatile uint32_t LTC0_PKE1_3;  ///< Offset: 0xE4C - LTC PKHA E1 3 Register
        volatile uint32_t LTC0_PKE_19;  ///< Offset: 0xE4C - LTC PKHA E 19 Register
        volatile uint32_t LTC0_PKE1_4;  ///< Offset: 0xE50 - LTC PKHA E1 4 Register
        volatile uint32_t LTC0_PKE_20;  ///< Offset: 0xE50 - LTC PKHA E 20 Register
        volatile uint32_t LTC0_PKE1_5;  ///< Offset: 0xE54 - LTC PKHA E1 5 Register
        volatile uint32_t LTC0_PKE_21;  ///< Offset: 0xE54 - LTC PKHA E 21 Register
        volatile uint32_t LTC0_PKE1_6;  ///< Offset: 0xE58 - LTC PKHA E1 6 Register
        volatile uint32_t LTC0_PKE_22;  ///< Offset: 0xE58 - LTC PKHA E 22 Register
        volatile uint32_t LTC0_PKE1_7;  ///< Offset: 0xE5C - LTC PKHA E1 7 Register
        volatile uint32_t LTC0_PKE_23;  ///< Offset: 0xE5C - LTC PKHA E 23 Register
        volatile uint32_t LTC0_PKE1_8;  ///< Offset: 0xE60 - LTC PKHA E1 8 Register
        volatile uint32_t LTC0_PKE_24;  ///< Offset: 0xE60 - LTC PKHA E 24 Register
        volatile uint32_t LTC0_PKE1_9;  ///< Offset: 0xE64 - LTC PKHA E1 9 Register
        volatile uint32_t LTC0_PKE_25;  ///< Offset: 0xE64 - LTC PKHA E 25 Register
        volatile uint32_t LTC0_PKE1_10;  ///< Offset: 0xE68 - LTC PKHA E1 10 Register
        volatile uint32_t LTC0_PKE_26;  ///< Offset: 0xE68 - LTC PKHA E 26 Register
        volatile uint32_t LTC0_PKE1_11;  ///< Offset: 0xE6C - LTC PKHA E1 11 Register
        volatile uint32_t LTC0_PKE_27;  ///< Offset: 0xE6C - LTC PKHA E 27 Register
        volatile uint32_t LTC0_PKE1_12;  ///< Offset: 0xE70 - LTC PKHA E1 12 Register
        volatile uint32_t LTC0_PKE_28;  ///< Offset: 0xE70 - LTC PKHA E 28 Register
        volatile uint32_t LTC0_PKE1_13;  ///< Offset: 0xE74 - LTC PKHA E1 13 Register
        volatile uint32_t LTC0_PKE_29;  ///< Offset: 0xE74 - LTC PKHA E 29 Register
        volatile uint32_t LTC0_PKE1_14;  ///< Offset: 0xE78 - LTC PKHA E1 14 Register
        volatile uint32_t LTC0_PKE_30;  ///< Offset: 0xE78 - LTC PKHA E 30 Register
        volatile uint32_t LTC0_PKE1_15;  ///< Offset: 0xE7C - LTC PKHA E1 15 Register
        volatile uint32_t LTC0_PKE_31;  ///< Offset: 0xE7C - LTC PKHA E 31 Register
        volatile uint32_t LTC0_PKE2_0;  ///< Offset: 0xE80 - LTC PKHA E2 0 Register
        volatile uint32_t LTC0_PKE_32;  ///< Offset: 0xE80 - LTC PKHA E 32 Register
        volatile uint32_t LTC0_PKE2_1;  ///< Offset: 0xE84 - LTC PKHA E2 1 Register
        volatile uint32_t LTC0_PKE_33;  ///< Offset: 0xE84 - LTC PKHA E 33 Register
        volatile uint32_t LTC0_PKE2_2;  ///< Offset: 0xE88 - LTC PKHA E2 2 Register
        volatile uint32_t LTC0_PKE_34;  ///< Offset: 0xE88 - LTC PKHA E 34 Register
        volatile uint32_t LTC0_PKE2_3;  ///< Offset: 0xE8C - LTC PKHA E2 3 Register
        volatile uint32_t LTC0_PKE_35;  ///< Offset: 0xE8C - LTC PKHA E 35 Register
        volatile uint32_t LTC0_PKE2_4;  ///< Offset: 0xE90 - LTC PKHA E2 4 Register
        volatile uint32_t LTC0_PKE_36;  ///< Offset: 0xE90 - LTC PKHA E 36 Register
        volatile uint32_t LTC0_PKE2_5;  ///< Offset: 0xE94 - LTC PKHA E2 5 Register
        volatile uint32_t LTC0_PKE_37;  ///< Offset: 0xE94 - LTC PKHA E 37 Register
        volatile uint32_t LTC0_PKE2_6;  ///< Offset: 0xE98 - LTC PKHA E2 6 Register
        volatile uint32_t LTC0_PKE_38;  ///< Offset: 0xE98 - LTC PKHA E 38 Register
        volatile uint32_t LTC0_PKE2_7;  ///< Offset: 0xE9C - LTC PKHA E2 7 Register
        volatile uint32_t LTC0_PKE_39;  ///< Offset: 0xE9C - LTC PKHA E 39 Register
        volatile uint32_t LTC0_PKE2_8;  ///< Offset: 0xEA0 - LTC PKHA E2 8 Register
        volatile uint32_t LTC0_PKE_40;  ///< Offset: 0xEA0 - LTC PKHA E 40 Register
        volatile uint32_t LTC0_PKE2_9;  ///< Offset: 0xEA4 - LTC PKHA E2 9 Register
        volatile uint32_t LTC0_PKE_41;  ///< Offset: 0xEA4 - LTC PKHA E 41 Register
        volatile uint32_t LTC0_PKE2_10;  ///< Offset: 0xEA8 - LTC PKHA E2 10 Register
        volatile uint32_t LTC0_PKE_42;  ///< Offset: 0xEA8 - LTC PKHA E 42 Register
        volatile uint32_t LTC0_PKE2_11;  ///< Offset: 0xEAC - LTC PKHA E2 11 Register
        volatile uint32_t LTC0_PKE_43;  ///< Offset: 0xEAC - LTC PKHA E 43 Register
        volatile uint32_t LTC0_PKE2_12;  ///< Offset: 0xEB0 - LTC PKHA E2 12 Register
        volatile uint32_t LTC0_PKE_44;  ///< Offset: 0xEB0 - LTC PKHA E 44 Register
        volatile uint32_t LTC0_PKE2_13;  ///< Offset: 0xEB4 - LTC PKHA E2 13 Register
        volatile uint32_t LTC0_PKE_45;  ///< Offset: 0xEB4 - LTC PKHA E 45 Register
        volatile uint32_t LTC0_PKE2_14;  ///< Offset: 0xEB8 - LTC PKHA E2 14 Register
        volatile uint32_t LTC0_PKE_46;  ///< Offset: 0xEB8 - LTC PKHA E 46 Register
        volatile uint32_t LTC0_PKE2_15;  ///< Offset: 0xEBC - LTC PKHA E2 15 Register
        volatile uint32_t LTC0_PKE_47;  ///< Offset: 0xEBC - LTC PKHA E 47 Register
        volatile uint32_t LTC0_PKE3_0;  ///< Offset: 0xEC0 - LTC PKHA E3 0 Register
        volatile uint32_t LTC0_PKE_48;  ///< Offset: 0xEC0 - LTC PKHA E 48 Register
        volatile uint32_t LTC0_PKE3_1;  ///< Offset: 0xEC4 - LTC PKHA E3 1 Register
        volatile uint32_t LTC0_PKE_49;  ///< Offset: 0xEC4 - LTC PKHA E 49 Register
        volatile uint32_t LTC0_PKE3_2;  ///< Offset: 0xEC8 - LTC PKHA E3 2 Register
        volatile uint32_t LTC0_PKE_50;  ///< Offset: 0xEC8 - LTC PKHA E 50 Register
        volatile uint32_t LTC0_PKE3_3;  ///< Offset: 0xECC - LTC PKHA E3 3 Register
        volatile uint32_t LTC0_PKE_51;  ///< Offset: 0xECC - LTC PKHA E 51 Register
        volatile uint32_t LTC0_PKE3_4;  ///< Offset: 0xED0 - LTC PKHA E3 4 Register
        volatile uint32_t LTC0_PKE_52;  ///< Offset: 0xED0 - LTC PKHA E 52 Register
        volatile uint32_t LTC0_PKE3_5;  ///< Offset: 0xED4 - LTC PKHA E3 5 Register
        volatile uint32_t LTC0_PKE_53;  ///< Offset: 0xED4 - LTC PKHA E 53 Register
        volatile uint32_t LTC0_PKE3_6;  ///< Offset: 0xED8 - LTC PKHA E3 6 Register
        volatile uint32_t LTC0_PKE_54;  ///< Offset: 0xED8 - LTC PKHA E 54 Register
        volatile uint32_t LTC0_PKE3_7;  ///< Offset: 0xEDC - LTC PKHA E3 7 Register
        volatile uint32_t LTC0_PKE_55;  ///< Offset: 0xEDC - LTC PKHA E 55 Register
        volatile uint32_t LTC0_PKE3_8;  ///< Offset: 0xEE0 - LTC PKHA E3 8 Register
        volatile uint32_t LTC0_PKE_56;  ///< Offset: 0xEE0 - LTC PKHA E 56 Register
        volatile uint32_t LTC0_PKE3_9;  ///< Offset: 0xEE4 - LTC PKHA E3 9 Register
        volatile uint32_t LTC0_PKE_57;  ///< Offset: 0xEE4 - LTC PKHA E 57 Register
        volatile uint32_t LTC0_PKE3_10;  ///< Offset: 0xEE8 - LTC PKHA E3 10 Register
        volatile uint32_t LTC0_PKE_58;  ///< Offset: 0xEE8 - LTC PKHA E 58 Register
        volatile uint32_t LTC0_PKE3_11;  ///< Offset: 0xEEC - LTC PKHA E3 11 Register
        volatile uint32_t LTC0_PKE_59;  ///< Offset: 0xEEC - LTC PKHA E 59 Register
        volatile uint32_t LTC0_PKE3_12;  ///< Offset: 0xEF0 - LTC PKHA E3 12 Register
        volatile uint32_t LTC0_PKE_60;  ///< Offset: 0xEF0 - LTC PKHA E 60 Register
        volatile uint32_t LTC0_PKE3_13;  ///< Offset: 0xEF4 - LTC PKHA E3 13 Register
        volatile uint32_t LTC0_PKE_61;  ///< Offset: 0xEF4 - LTC PKHA E 61 Register
        volatile uint32_t LTC0_PKE3_14;  ///< Offset: 0xEF8 - LTC PKHA E3 14 Register
        volatile uint32_t LTC0_PKE_62;  ///< Offset: 0xEF8 - LTC PKHA E 62 Register
        volatile uint32_t LTC0_PKE3_15;  ///< Offset: 0xEFC - LTC PKHA E3 15 Register
        volatile uint32_t LTC0_PKE_63;  ///< Offset: 0xEFC - LTC PKHA E 63 Register
    };

    /// Peripheral instances
    inline Registers* LTC0 = reinterpret_cast<Registers*>(LTC0_BASE);

    // Bit definitions
    /// LTC0_MD Register bits
    namespace ltc0_md_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encrypt/Decrypt. This bit selects encryption or decryption.
        constexpr uint32_t ICV_TEST = (1U << 1);  ///< ICV Checking / Test AES fault detection
        constexpr uint32_t AS = (2 << 2);  ///< Algorithm State
        constexpr uint32_t AAI = (9 << 4);  ///< Additional Algorithm information
        constexpr uint32_t ALG = (8 << 16);  ///< Algorithm. This field specifies which algorithm is being selected.
    }

    /// LTC0_MDPK Register bits
    namespace ltc0_mdpk_bits {
        constexpr uint32_t PKHA_MODE_LS = (12 << 0);  ///< PKHA_MODE least significant 12 bits
        constexpr uint32_t PKHA_MODE_MS = (4 << 16);  ///< PKHA_MODE most-significant 4 bits
        constexpr uint32_t ALG = (4 << 20);  ///< Algorithm. This field specifies which algorithm is being selected.
    }

    /// LTC0_KS Register bits
    namespace ltc0_ks_bits {
        constexpr uint32_t KS = (6 << 0);  ///< Key Size. This is the size of a Key measured in bytes
    }

    /// LTC0_DS Register bits
    namespace ltc0_ds_bits {
        constexpr uint32_t DS = (12 << 0);  ///< Data Size
    }

    /// LTC0_ICVS Register bits
    namespace ltc0_icvs_bits {
        constexpr uint32_t ICVS = (5 << 0);  ///< ICV Size, in Bytes.
    }

    /// LTC0_COM Register bits
    namespace ltc0_com_bits {
        constexpr uint32_t ALL = (1U << 0);  ///< Reset All Internal Logic
        constexpr uint32_t AES = (1U << 1);  ///< Reset AESA. Writing a 1 to this bit resets the AES Accelerator core engine.
        constexpr uint32_t DES = (1U << 2);  ///< Reset DESA. Writing a 1 to this bit resets the DES Accelerator.
        constexpr uint32_t PK = (1U << 6);  ///< Reset PKHA. Writing a 1 to this bit resets the Public Key Hardware Accelerator.
    }

    /// LTC0_CTL Register bits
    namespace ltc0_ctl_bits {
        constexpr uint32_t IM = (1U << 0);  ///< Interrupt Mask. Once this bit is set, it can only be cleared by hard reset.
        constexpr uint32_t PDE = (1U << 4);  ///< PKHA Register DMA Enable.
        constexpr uint32_t IFE = (1U << 8);  ///< Input FIFO DMA Enable.
        constexpr uint32_t IFR = (1U << 9);  ///< Input FIFO DMA Request Size
        constexpr uint32_t OFE = (1U << 12);  ///< Output FIFO DMA Enable.
        constexpr uint32_t OFR = (1U << 13);  ///< Output FIFO DMA Request Size
        constexpr uint32_t IFS = (1U << 16);  ///< Input FIFO Byte Swap. Byte swap all data that is written to the Input FIFO.
        constexpr uint32_t OFS = (1U << 17);  ///< Output FIFO Byte Swap. Byte swap all data that is read from the Onput FIFO.
        constexpr uint32_t KIS = (1U << 20);  ///< Key Register Input Byte Swap
        constexpr uint32_t KOS = (1U << 21);  ///< Key Register Output Byte Swap
        constexpr uint32_t CIS = (1U << 22);  ///< Context Register Input Byte Swap
        constexpr uint32_t COS = (1U << 23);  ///< Context Register Output Byte Swap
        constexpr uint32_t KAL = (1U << 31);  ///< Key Register Access Lock
    }

    /// LTC0_CW Register bits
    namespace ltc0_cw_bits {
        constexpr uint32_t CM = (1U << 0);  ///< Clear the Mode Register. Writing a one to this bit causes the Mode Register to be cleared.
        constexpr uint32_t CDS = (1U << 2);  ///< Clear the Data Size Register
        constexpr uint32_t CICV = (1U << 3);  ///< Clear the ICV Size Register. Writing a one to this bit causes the ICV Size Register to be cleared.
        constexpr uint32_t CCR = (1U << 5);  ///< Clear the Context Register. Writing a one to this bit causes the Context Register to be cleared.
        constexpr uint32_t CKR = (1U << 6);  ///< Clear the Key Register
        constexpr uint32_t CPKA = (1U << 12);  ///< Clear the PKHA A Size Register
        constexpr uint32_t CPKB = (1U << 13);  ///< Clear the PKHA B Size Register
        constexpr uint32_t CPKN = (1U << 14);  ///< Clear the PKHA N Size Register
        constexpr uint32_t CPKE = (1U << 15);  ///< Clear the PKHA E Size Register
        constexpr uint32_t COF = (1U << 30);  ///< Clear Output FIFO. Writing a 1 to this bit causes the Output FIFO to be cleared.
        constexpr uint32_t CIF = (1U << 31);  ///< Clear Input FIFO. Writing a 1 to this bit causes the Input Data FIFO.
    }

    /// LTC0_STA Register bits
    namespace ltc0_sta_bits {
        constexpr uint32_t AB = (1U << 1);  ///< AESA Busy
        constexpr uint32_t DB = (1U << 2);  ///< DESA Busy
        constexpr uint32_t PB = (1U << 6);  ///< PKHA Busy
        constexpr uint32_t DI = (1U << 16);  ///< Done Interrupt
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt
        constexpr uint32_t PKP = (1U << 28);  ///< Public Key is Prime
        constexpr uint32_t PKO = (1U << 29);  ///< Public Key Operation is One
        constexpr uint32_t PKZ = (1U << 30);  ///< Public Key Operation is Zero
    }

    /// LTC0_ESTA Register bits
    namespace ltc0_esta_bits {
        constexpr uint32_t ERRID1 = (4 << 0);  ///< Error ID 1
        constexpr uint32_t CL1 = (4 << 8);  ///< algorithms. The algorithms field indicates which algorithm is asserting an error. Others reserved
    }

    /// LTC0_AADSZ Register bits
    namespace ltc0_aadsz_bits {
        constexpr uint32_t AADSZ = (4 << 0);  ///< AAD size in Bytes, mod 16.
        constexpr uint32_t AL = (1U << 31);  ///< AAD Last. Only AAD data will be written into the Input FIFO.
    }

    /// LTC0_IVSZ Register bits
    namespace ltc0_ivsz_bits {
        constexpr uint32_t IVSZ = (4 << 0);  ///< IV size in Bytes, mod 16.
        constexpr uint32_t IL = (1U << 31);  ///< IV Last. Only IV data will be written into the Input FIFO.
    }

    /// LTC0_DPAMS Register bits
    namespace ltc0_dpams_bits {
        constexpr uint32_t DPAMS = (32 << 0);  ///< Differential Power Analysis Mask Seed
    }

    /// LTC0_PKASZ Register bits
    namespace ltc0_pkasz_bits {
        constexpr uint32_t PKASZ = (9 << 0);  ///< PKHA A Size. This is the size of the numeric value, in bytes, contained within the PKHA A Register.
    }

    /// LTC0_PKBSZ Register bits
    namespace ltc0_pkbsz_bits {
        constexpr uint32_t PKBSZ = (9 << 0);  ///< PKHA B Size. This is the size of the numeric value, in bytes, contained within the PKHA B Register.
    }

    /// LTC0_PKNSZ Register bits
    namespace ltc0_pknsz_bits {
        constexpr uint32_t PKNSZ = (9 << 0);  ///< PKHA N Size. This is the size of the numeric value, in bytes, contained within the PKHA N Register.
    }

    /// LTC0_PKESZ Register bits
    namespace ltc0_pkesz_bits {
        constexpr uint32_t PKESZ = (9 << 0);  ///< PKHA E Size. This is the size of the numeric value, in bytes, contained within the PKHA E Register.
    }

    /// LTC0_CTX_0 Register bits
    namespace ltc0_ctx_0_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_1 Register bits
    namespace ltc0_ctx_1_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_2 Register bits
    namespace ltc0_ctx_2_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_3 Register bits
    namespace ltc0_ctx_3_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_4 Register bits
    namespace ltc0_ctx_4_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_5 Register bits
    namespace ltc0_ctx_5_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_6 Register bits
    namespace ltc0_ctx_6_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_7 Register bits
    namespace ltc0_ctx_7_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_8 Register bits
    namespace ltc0_ctx_8_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_9 Register bits
    namespace ltc0_ctx_9_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_10 Register bits
    namespace ltc0_ctx_10_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_11 Register bits
    namespace ltc0_ctx_11_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_12 Register bits
    namespace ltc0_ctx_12_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_13 Register bits
    namespace ltc0_ctx_13_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_14 Register bits
    namespace ltc0_ctx_14_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_15 Register bits
    namespace ltc0_ctx_15_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_KEY_0 Register bits
    namespace ltc0_key_0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_1 Register bits
    namespace ltc0_key_1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_2 Register bits
    namespace ltc0_key_2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_3 Register bits
    namespace ltc0_key_3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_4 Register bits
    namespace ltc0_key_4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_5 Register bits
    namespace ltc0_key_5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_6 Register bits
    namespace ltc0_key_6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_7 Register bits
    namespace ltc0_key_7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_RNG4_DRNG_STATUS Register bits
    namespace ltc0_rng4_drng_status_bits {
        constexpr uint32_t IF0 = (1U << 0);  ///< Instantiated Flag 0. State Handle 0 has been instantiated.
        constexpr uint32_t IF1 = (1U << 1);  ///< Instantiated Flag 1. State Handle 1 has been instantiated.
        constexpr uint32_t PR0 = (1U << 4);  ///< Prediction Resistance State Handle 0
        constexpr uint32_t PR1 = (1U << 5);  ///< Prediction Resistance State Handle 1
        constexpr uint32_t TF0 = (1U << 8);  ///< Test Flag State Handle 0. State Handle 0 has been instantiated as a test (deterministic) instance.
        constexpr uint32_t TF1 = (1U << 9);  ///< Test Flag State Handle 1. State Handle 1 has been instantiated as a test (deterministic) instance.
        constexpr uint32_t ERRCODE = (4 << 16);  ///< Error Code
        constexpr uint32_t CE = (1U << 20);  ///< Catastrophic Error
    }

    /// LTC0_RNG4_DRNG_INTERVAL_0 Register bits
    namespace ltc0_rng4_drng_interval_0_bits {
        constexpr uint32_t RESINT0 = (32 << 0);  ///< This read-only register holds the Reseed Interval for State Handle 0.
    }

    /// LTC0_RNG4_DRNG_INTERVAL_1 Register bits
    namespace ltc0_rng4_drng_interval_1_bits {
        constexpr uint32_t RESINT1 = (32 << 0);  ///< This read-only register holds the Reseed Interval for State Handle 1.
    }

    /// LTC0_RNG4_DRNG_HASH_CONTROL Register bits
    namespace ltc0_rng4_drng_hash_control_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Hashing Done. This bit asserts when the hashing engine is done.
        constexpr uint32_t HB = (1U << 1);  ///< Hashing Begin. Writing this bit will cause the Hashing Engine to begin hashing.
        constexpr uint32_t HI = (1U << 2);  ///< Hashing Initialize. Writing this bit will initialize the Hashing Engine.
        constexpr uint32_t HTM = (1U << 3);  ///< Hashing Test Mode. Writing this bit will put RNG in Hashing Test Mode.
        constexpr uint32_t HTC = (1U << 4);  ///< Hashing Test Mode Clear. Writing this bit will take the RNG out of hashing test mode.
    }

    /// LTC0_RNG4_DRNG_HASH_DIGEST Register bits
    namespace ltc0_rng4_drng_hash_digest_bits {
        constexpr uint32_t HASHMD = (32 << 0);  ///< Hashing Message Digest Register
    }

    /// LTC0_RNG4_DRNG_DEBUG_BUFFER Register bits
    namespace ltc0_rng4_drng_debug_buffer_bits {
        constexpr uint32_t HASHBUF = (32 << 0);  ///< This write-only register provides access to the internal SHA-256 hashing engine's 64-byte buffer
    }

    /// LTC0_VID1 Register bits
    namespace ltc0_vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Minor revision number(0x00).
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Major revision number(0x01).
        constexpr uint32_t IP_ID = (16 << 16);  ///< ID(0x0038).
    }

    /// LTC0_CHAVID Register bits
    namespace ltc0_chavid_bits {
        constexpr uint32_t AESREV = (4 << 0);  ///< AES Revision Number(0x1).
        constexpr uint32_t AESVID = (4 << 4);  ///< AES Version ID(0x5).
        constexpr uint32_t DESREV = (4 << 8);  ///< DES Revision Number(0x1).
        constexpr uint32_t DESVID = (4 << 12);  ///< DES Version ID(0x0).
        constexpr uint32_t PKHAREV = (4 << 16);  ///< PK Revision Number(0x4).
        constexpr uint32_t PKHAVID = (4 << 20);  ///< PK Version ID(0x4).
    }

    /// LTC0_FIFOSTA Register bits
    namespace ltc0_fifosta_bits {
        constexpr uint32_t IFL = (7 << 0);  ///< Input FIFO Level. These bits indicate the current number of entries in the Input FIFO.
        constexpr uint32_t IFF = (1U << 15);  ///< Input FIFO Full. The Input FIFO is full and should not be written to.
        constexpr uint32_t OFL = (7 << 16);  ///< Output FIFO Level. These bits indicate the current number of entries in the Output FIFO.
        constexpr uint32_t OFF = (1U << 31);  ///< Output FIFO Full. The Output FIFO is full and should not be written to.
    }

    /// LTC0_IFIFO Register bits
    namespace ltc0_ififo_bits {
        constexpr uint32_t IFIFO = (32 << 0);  ///< IFIFO
    }

    /// LTC0_OFIFO Register bits
    namespace ltc0_ofifo_bits {
        constexpr uint32_t OFIFO = (32 << 0);  ///< Output FIFO
    }

    /// LTC0_PKA0_0 Register bits
    namespace ltc0_pka0_0_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_1 Register bits
    namespace ltc0_pka0_1_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_2 Register bits
    namespace ltc0_pka0_2_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_3 Register bits
    namespace ltc0_pka0_3_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_4 Register bits
    namespace ltc0_pka0_4_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_5 Register bits
    namespace ltc0_pka0_5_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_6 Register bits
    namespace ltc0_pka0_6_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_7 Register bits
    namespace ltc0_pka0_7_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_8 Register bits
    namespace ltc0_pka0_8_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_9 Register bits
    namespace ltc0_pka0_9_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_10 Register bits
    namespace ltc0_pka0_10_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_11 Register bits
    namespace ltc0_pka0_11_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_12 Register bits
    namespace ltc0_pka0_12_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_13 Register bits
    namespace ltc0_pka0_13_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_14 Register bits
    namespace ltc0_pka0_14_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_15 Register bits
    namespace ltc0_pka0_15_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA1_0 Register bits
    namespace ltc0_pka1_0_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_1 Register bits
    namespace ltc0_pka1_1_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_2 Register bits
    namespace ltc0_pka1_2_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_3 Register bits
    namespace ltc0_pka1_3_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_4 Register bits
    namespace ltc0_pka1_4_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_5 Register bits
    namespace ltc0_pka1_5_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_6 Register bits
    namespace ltc0_pka1_6_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_7 Register bits
    namespace ltc0_pka1_7_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_8 Register bits
    namespace ltc0_pka1_8_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_9 Register bits
    namespace ltc0_pka1_9_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_10 Register bits
    namespace ltc0_pka1_10_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_11 Register bits
    namespace ltc0_pka1_11_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_12 Register bits
    namespace ltc0_pka1_12_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_13 Register bits
    namespace ltc0_pka1_13_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_14 Register bits
    namespace ltc0_pka1_14_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_15 Register bits
    namespace ltc0_pka1_15_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA2_0 Register bits
    namespace ltc0_pka2_0_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_1 Register bits
    namespace ltc0_pka2_1_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_2 Register bits
    namespace ltc0_pka2_2_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_3 Register bits
    namespace ltc0_pka2_3_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_4 Register bits
    namespace ltc0_pka2_4_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_5 Register bits
    namespace ltc0_pka2_5_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_6 Register bits
    namespace ltc0_pka2_6_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_7 Register bits
    namespace ltc0_pka2_7_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_8 Register bits
    namespace ltc0_pka2_8_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_9 Register bits
    namespace ltc0_pka2_9_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_10 Register bits
    namespace ltc0_pka2_10_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_11 Register bits
    namespace ltc0_pka2_11_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_12 Register bits
    namespace ltc0_pka2_12_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_13 Register bits
    namespace ltc0_pka2_13_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_14 Register bits
    namespace ltc0_pka2_14_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_15 Register bits
    namespace ltc0_pka2_15_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA3_0 Register bits
    namespace ltc0_pka3_0_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_1 Register bits
    namespace ltc0_pka3_1_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_2 Register bits
    namespace ltc0_pka3_2_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_3 Register bits
    namespace ltc0_pka3_3_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_4 Register bits
    namespace ltc0_pka3_4_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_5 Register bits
    namespace ltc0_pka3_5_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_6 Register bits
    namespace ltc0_pka3_6_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_7 Register bits
    namespace ltc0_pka3_7_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_8 Register bits
    namespace ltc0_pka3_8_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_9 Register bits
    namespace ltc0_pka3_9_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_10 Register bits
    namespace ltc0_pka3_10_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_11 Register bits
    namespace ltc0_pka3_11_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_12 Register bits
    namespace ltc0_pka3_12_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_13 Register bits
    namespace ltc0_pka3_13_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_14 Register bits
    namespace ltc0_pka3_14_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_15 Register bits
    namespace ltc0_pka3_15_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKB0_0 Register bits
    namespace ltc0_pkb0_0_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_1 Register bits
    namespace ltc0_pkb0_1_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_2 Register bits
    namespace ltc0_pkb0_2_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_3 Register bits
    namespace ltc0_pkb0_3_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_4 Register bits
    namespace ltc0_pkb0_4_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_5 Register bits
    namespace ltc0_pkb0_5_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_6 Register bits
    namespace ltc0_pkb0_6_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_7 Register bits
    namespace ltc0_pkb0_7_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_8 Register bits
    namespace ltc0_pkb0_8_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_9 Register bits
    namespace ltc0_pkb0_9_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_10 Register bits
    namespace ltc0_pkb0_10_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_11 Register bits
    namespace ltc0_pkb0_11_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_12 Register bits
    namespace ltc0_pkb0_12_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_13 Register bits
    namespace ltc0_pkb0_13_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_14 Register bits
    namespace ltc0_pkb0_14_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_15 Register bits
    namespace ltc0_pkb0_15_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB1_0 Register bits
    namespace ltc0_pkb1_0_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_1 Register bits
    namespace ltc0_pkb1_1_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_2 Register bits
    namespace ltc0_pkb1_2_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_3 Register bits
    namespace ltc0_pkb1_3_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_4 Register bits
    namespace ltc0_pkb1_4_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_5 Register bits
    namespace ltc0_pkb1_5_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_6 Register bits
    namespace ltc0_pkb1_6_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_7 Register bits
    namespace ltc0_pkb1_7_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_8 Register bits
    namespace ltc0_pkb1_8_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_9 Register bits
    namespace ltc0_pkb1_9_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_10 Register bits
    namespace ltc0_pkb1_10_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_11 Register bits
    namespace ltc0_pkb1_11_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_12 Register bits
    namespace ltc0_pkb1_12_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_13 Register bits
    namespace ltc0_pkb1_13_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_14 Register bits
    namespace ltc0_pkb1_14_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_15 Register bits
    namespace ltc0_pkb1_15_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB2_0 Register bits
    namespace ltc0_pkb2_0_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_1 Register bits
    namespace ltc0_pkb2_1_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_2 Register bits
    namespace ltc0_pkb2_2_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_3 Register bits
    namespace ltc0_pkb2_3_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_4 Register bits
    namespace ltc0_pkb2_4_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_5 Register bits
    namespace ltc0_pkb2_5_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_6 Register bits
    namespace ltc0_pkb2_6_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_7 Register bits
    namespace ltc0_pkb2_7_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_8 Register bits
    namespace ltc0_pkb2_8_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_9 Register bits
    namespace ltc0_pkb2_9_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_10 Register bits
    namespace ltc0_pkb2_10_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_11 Register bits
    namespace ltc0_pkb2_11_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_12 Register bits
    namespace ltc0_pkb2_12_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_13 Register bits
    namespace ltc0_pkb2_13_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_14 Register bits
    namespace ltc0_pkb2_14_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_15 Register bits
    namespace ltc0_pkb2_15_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB3_0 Register bits
    namespace ltc0_pkb3_0_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_1 Register bits
    namespace ltc0_pkb3_1_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_2 Register bits
    namespace ltc0_pkb3_2_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_3 Register bits
    namespace ltc0_pkb3_3_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_4 Register bits
    namespace ltc0_pkb3_4_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_5 Register bits
    namespace ltc0_pkb3_5_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_6 Register bits
    namespace ltc0_pkb3_6_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_7 Register bits
    namespace ltc0_pkb3_7_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_8 Register bits
    namespace ltc0_pkb3_8_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_9 Register bits
    namespace ltc0_pkb3_9_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_10 Register bits
    namespace ltc0_pkb3_10_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_11 Register bits
    namespace ltc0_pkb3_11_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_12 Register bits
    namespace ltc0_pkb3_12_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_13 Register bits
    namespace ltc0_pkb3_13_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_14 Register bits
    namespace ltc0_pkb3_14_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_15 Register bits
    namespace ltc0_pkb3_15_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKN0_0 Register bits
    namespace ltc0_pkn0_0_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_1 Register bits
    namespace ltc0_pkn0_1_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_2 Register bits
    namespace ltc0_pkn0_2_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_3 Register bits
    namespace ltc0_pkn0_3_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_4 Register bits
    namespace ltc0_pkn0_4_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_5 Register bits
    namespace ltc0_pkn0_5_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_6 Register bits
    namespace ltc0_pkn0_6_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_7 Register bits
    namespace ltc0_pkn0_7_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_8 Register bits
    namespace ltc0_pkn0_8_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_9 Register bits
    namespace ltc0_pkn0_9_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_10 Register bits
    namespace ltc0_pkn0_10_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_11 Register bits
    namespace ltc0_pkn0_11_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_12 Register bits
    namespace ltc0_pkn0_12_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_13 Register bits
    namespace ltc0_pkn0_13_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_14 Register bits
    namespace ltc0_pkn0_14_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_15 Register bits
    namespace ltc0_pkn0_15_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN1_0 Register bits
    namespace ltc0_pkn1_0_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_1 Register bits
    namespace ltc0_pkn1_1_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_2 Register bits
    namespace ltc0_pkn1_2_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_3 Register bits
    namespace ltc0_pkn1_3_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_4 Register bits
    namespace ltc0_pkn1_4_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_5 Register bits
    namespace ltc0_pkn1_5_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_6 Register bits
    namespace ltc0_pkn1_6_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_7 Register bits
    namespace ltc0_pkn1_7_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_8 Register bits
    namespace ltc0_pkn1_8_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_9 Register bits
    namespace ltc0_pkn1_9_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_10 Register bits
    namespace ltc0_pkn1_10_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_11 Register bits
    namespace ltc0_pkn1_11_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_12 Register bits
    namespace ltc0_pkn1_12_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_13 Register bits
    namespace ltc0_pkn1_13_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_14 Register bits
    namespace ltc0_pkn1_14_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_15 Register bits
    namespace ltc0_pkn1_15_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN2_0 Register bits
    namespace ltc0_pkn2_0_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_1 Register bits
    namespace ltc0_pkn2_1_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_2 Register bits
    namespace ltc0_pkn2_2_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_3 Register bits
    namespace ltc0_pkn2_3_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_4 Register bits
    namespace ltc0_pkn2_4_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_5 Register bits
    namespace ltc0_pkn2_5_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_6 Register bits
    namespace ltc0_pkn2_6_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_7 Register bits
    namespace ltc0_pkn2_7_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_8 Register bits
    namespace ltc0_pkn2_8_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_9 Register bits
    namespace ltc0_pkn2_9_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_10 Register bits
    namespace ltc0_pkn2_10_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_11 Register bits
    namespace ltc0_pkn2_11_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_12 Register bits
    namespace ltc0_pkn2_12_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_13 Register bits
    namespace ltc0_pkn2_13_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_14 Register bits
    namespace ltc0_pkn2_14_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_15 Register bits
    namespace ltc0_pkn2_15_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN3_0 Register bits
    namespace ltc0_pkn3_0_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_1 Register bits
    namespace ltc0_pkn3_1_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_2 Register bits
    namespace ltc0_pkn3_2_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_3 Register bits
    namespace ltc0_pkn3_3_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_4 Register bits
    namespace ltc0_pkn3_4_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_5 Register bits
    namespace ltc0_pkn3_5_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_6 Register bits
    namespace ltc0_pkn3_6_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_7 Register bits
    namespace ltc0_pkn3_7_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_8 Register bits
    namespace ltc0_pkn3_8_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_9 Register bits
    namespace ltc0_pkn3_9_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_10 Register bits
    namespace ltc0_pkn3_10_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_11 Register bits
    namespace ltc0_pkn3_11_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_12 Register bits
    namespace ltc0_pkn3_12_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_13 Register bits
    namespace ltc0_pkn3_13_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_14 Register bits
    namespace ltc0_pkn3_14_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_15 Register bits
    namespace ltc0_pkn3_15_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKE0_0 Register bits
    namespace ltc0_pke0_0_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_1 Register bits
    namespace ltc0_pke0_1_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_2 Register bits
    namespace ltc0_pke0_2_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_3 Register bits
    namespace ltc0_pke0_3_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_4 Register bits
    namespace ltc0_pke0_4_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_5 Register bits
    namespace ltc0_pke0_5_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_6 Register bits
    namespace ltc0_pke0_6_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_7 Register bits
    namespace ltc0_pke0_7_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_8 Register bits
    namespace ltc0_pke0_8_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_9 Register bits
    namespace ltc0_pke0_9_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_10 Register bits
    namespace ltc0_pke0_10_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_11 Register bits
    namespace ltc0_pke0_11_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_12 Register bits
    namespace ltc0_pke0_12_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_13 Register bits
    namespace ltc0_pke0_13_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_14 Register bits
    namespace ltc0_pke0_14_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_15 Register bits
    namespace ltc0_pke0_15_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE1_0 Register bits
    namespace ltc0_pke1_0_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_1 Register bits
    namespace ltc0_pke1_1_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_2 Register bits
    namespace ltc0_pke1_2_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_3 Register bits
    namespace ltc0_pke1_3_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_4 Register bits
    namespace ltc0_pke1_4_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_5 Register bits
    namespace ltc0_pke1_5_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_6 Register bits
    namespace ltc0_pke1_6_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_7 Register bits
    namespace ltc0_pke1_7_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_8 Register bits
    namespace ltc0_pke1_8_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_9 Register bits
    namespace ltc0_pke1_9_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_10 Register bits
    namespace ltc0_pke1_10_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_11 Register bits
    namespace ltc0_pke1_11_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_12 Register bits
    namespace ltc0_pke1_12_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_13 Register bits
    namespace ltc0_pke1_13_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_14 Register bits
    namespace ltc0_pke1_14_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_15 Register bits
    namespace ltc0_pke1_15_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE2_0 Register bits
    namespace ltc0_pke2_0_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_1 Register bits
    namespace ltc0_pke2_1_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_2 Register bits
    namespace ltc0_pke2_2_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_3 Register bits
    namespace ltc0_pke2_3_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_4 Register bits
    namespace ltc0_pke2_4_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_5 Register bits
    namespace ltc0_pke2_5_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_6 Register bits
    namespace ltc0_pke2_6_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_7 Register bits
    namespace ltc0_pke2_7_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_8 Register bits
    namespace ltc0_pke2_8_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_9 Register bits
    namespace ltc0_pke2_9_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_10 Register bits
    namespace ltc0_pke2_10_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_11 Register bits
    namespace ltc0_pke2_11_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_12 Register bits
    namespace ltc0_pke2_12_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_13 Register bits
    namespace ltc0_pke2_13_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_14 Register bits
    namespace ltc0_pke2_14_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_15 Register bits
    namespace ltc0_pke2_15_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE3_0 Register bits
    namespace ltc0_pke3_0_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_1 Register bits
    namespace ltc0_pke3_1_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_2 Register bits
    namespace ltc0_pke3_2_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_3 Register bits
    namespace ltc0_pke3_3_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_4 Register bits
    namespace ltc0_pke3_4_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_5 Register bits
    namespace ltc0_pke3_5_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_6 Register bits
    namespace ltc0_pke3_6_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_7 Register bits
    namespace ltc0_pke3_7_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_8 Register bits
    namespace ltc0_pke3_8_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_9 Register bits
    namespace ltc0_pke3_9_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_10 Register bits
    namespace ltc0_pke3_10_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_11 Register bits
    namespace ltc0_pke3_11_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_12 Register bits
    namespace ltc0_pke3_12_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_13 Register bits
    namespace ltc0_pke3_13_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_14 Register bits
    namespace ltc0_pke3_14_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_15 Register bits
    namespace ltc0_pke3_15_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

}

// ============================================================================
// EMVSIM0 Peripheral
// ============================================================================

namespace emvsim0 {
    /// Base addresses
    constexpr uint32_t EMVSIM0_BASE = 0x400D4000;

    /// EMVSIM0 Register structure
    struct Registers {
        volatile uint32_t VER_ID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CLKCFG;  ///< Offset: 0x08 - Clock Configuration Register
        volatile uint32_t DIVISOR;  ///< Offset: 0x0C - Baud Rate Divisor Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0x14 - Interrupt Mask Register
        volatile uint32_t RX_THD;  ///< Offset: 0x18 - Receiver Threshold Register
        volatile uint32_t TX_THD;  ///< Offset: 0x1C - Transmitter Threshold Register
        volatile uint32_t RX_STATUS;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t TX_STATUS;  ///< Offset: 0x24 - Transmitter Status Register
        volatile uint32_t PCSR;  ///< Offset: 0x28 - Port Control and Status Register
        volatile uint32_t RX_BUF;  ///< Offset: 0x2C - Receive Data Read Buffer
        volatile uint32_t TX_BUF;  ///< Offset: 0x30 - Transmit Data Buffer
        volatile uint32_t TX_GETU;  ///< Offset: 0x34 - Transmitter Guard ETU Value Register
        volatile uint32_t CWT_VAL;  ///< Offset: 0x38 - Character Wait Time Value Register
        volatile uint32_t BWT_VAL;  ///< Offset: 0x3C - Block Wait Time Value Register
        volatile uint32_t BGT_VAL;  ///< Offset: 0x40 - Block Guard Time Value Register
        volatile uint32_t GPCNT0_VAL;  ///< Offset: 0x44 - General Purpose Counter 0 Timeout Value Register
        volatile uint32_t GPCNT1_VAL;  ///< Offset: 0x48 - General Purpose Counter 1 Timeout Value
    };

    /// Peripheral instances
    inline Registers* EMVSIM0 = reinterpret_cast<Registers*>(EMVSIM0_BASE);

    // Bit definitions
    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t VER = (32 << 0);  ///< Version ID of the module
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RX_FIFO_DEPTH = (8 << 0);  ///< Receive FIFO Depth
        constexpr uint32_t TX_FIFO_DEPTH = (8 << 8);  ///< Transmit FIFO Depth
    }

    /// CLKCFG Register bits
    namespace clkcfg_bits {
        constexpr uint32_t CLK_PRSC = (8 << 0);  ///< Clock Prescaler Value
        constexpr uint32_t GPCNT1_CLK_SEL = (2 << 8);  ///< General Purpose Counter 1 Clock Select
        constexpr uint32_t GPCNT0_CLK_SEL = (2 << 10);  ///< General Purpose Counter 0 Clock Select
    }

    /// DIVISOR Register bits
    namespace divisor_bits {
        constexpr uint32_t DIVISOR_VALUE = (9 << 0);  ///< Divisor (F/D) Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t IC = (1U << 0);  ///< Inverse Convention
        constexpr uint32_t ICM = (1U << 1);  ///< Initial Character Mode
        constexpr uint32_t ANACK = (1U << 2);  ///< Auto NACK Enable
        constexpr uint32_t ONACK = (1U << 3);  ///< Overrun NACK Enable
        constexpr uint32_t FLSH_RX = (1U << 8);  ///< Flush Receiver Bit
        constexpr uint32_t FLSH_TX = (1U << 9);  ///< Flush Transmitter Bit
        constexpr uint32_t SW_RST = (1U << 10);  ///< Software Reset Bit
        constexpr uint32_t KILL_CLOCKS = (1U << 11);  ///< Kill all internal clocks
        constexpr uint32_t DOZE_EN = (1U << 12);  ///< Doze Enable
        constexpr uint32_t STOP_EN = (1U << 13);  ///< STOP Enable
        constexpr uint32_t RCV_EN = (1U << 16);  ///< Receiver Enable
        constexpr uint32_t XMT_EN = (1U << 17);  ///< Transmitter Enable
        constexpr uint32_t RCVR_11 = (1U << 18);  ///< Receiver 11 ETU Mode Enable
        constexpr uint32_t RX_DMA_EN = (1U << 19);  ///< Receive DMA Enable
        constexpr uint32_t TX_DMA_EN = (1U << 20);  ///< Transmit DMA Enable
        constexpr uint32_t INV_CRC_VAL = (1U << 24);  ///< Invert bits in the CRC Output Value
        constexpr uint32_t CRC_OUT_FLIP = (1U << 25);  ///< CRC Output Value Bit Reversal or Flip
        constexpr uint32_t CRC_IN_FLIP = (1U << 26);  ///< CRC Input Byte's Bit Reversal or Flip Control
        constexpr uint32_t CWT_EN = (1U << 27);  ///< Character Wait Time Counter Enable
        constexpr uint32_t LRC_EN = (1U << 28);  ///< LRC Enable
        constexpr uint32_t CRC_EN = (1U << 29);  ///< CRC Enable
        constexpr uint32_t XMT_CRC_LRC = (1U << 30);  ///< Transmit CRC or LRC Enable
        constexpr uint32_t BWT_EN = (1U << 31);  ///< Block Wait Time Counter Enable
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t RDT_IM = (1U << 0);  ///< Receive Data Threshold Interrupt Mask
        constexpr uint32_t TC_IM = (1U << 1);  ///< Transmit Complete Interrupt Mask
        constexpr uint32_t RFO_IM = (1U << 2);  ///< Receive FIFO Overflow Interrupt Mask
        constexpr uint32_t ETC_IM = (1U << 3);  ///< Early Transmit Complete Interrupt Mask
        constexpr uint32_t TFE_IM = (1U << 4);  ///< Transmit FIFO Empty Interrupt Mask
        constexpr uint32_t TNACK_IM = (1U << 5);  ///< Transmit NACK Threshold Interrupt Mask
        constexpr uint32_t TFF_IM = (1U << 6);  ///< Transmit FIFO Full Interrupt Mask
        constexpr uint32_t TDT_IM = (1U << 7);  ///< Transmit Data Threshold Interrupt Mask
        constexpr uint32_t GPCNT0_IM = (1U << 8);  ///< General Purpose Timer 0 Timeout Interrupt Mask
        constexpr uint32_t CWT_ERR_IM = (1U << 9);  ///< Character Wait Time Error Interrupt Mask
        constexpr uint32_t RNACK_IM = (1U << 10);  ///< Receiver NACK Threshold Interrupt Mask
        constexpr uint32_t BWT_ERR_IM = (1U << 11);  ///< Block Wait Time Error Interrupt Mask
        constexpr uint32_t BGT_ERR_IM = (1U << 12);  ///< Block Guard Time Error Interrupt
        constexpr uint32_t GPCNT1_IM = (1U << 13);  ///< General Purpose Counter 1 Timeout Interrupt Mask
        constexpr uint32_t RX_DATA_IM = (1U << 14);  ///< Receive Data Interrupt Mask
        constexpr uint32_t PEF_IM = (1U << 15);  ///< Parity Error Interrupt Mask
    }

    /// RX_THD Register bits
    namespace rx_thd_bits {
        constexpr uint32_t RDT = (4 << 0);  ///< Receiver Data Threshold Value
        constexpr uint32_t RNCK_THD = (4 << 8);  ///< Receiver NACK Threshold Value
    }

    /// TX_THD Register bits
    namespace tx_thd_bits {
        constexpr uint32_t TDT = (4 << 0);  ///< Transmitter Data Threshold Value
        constexpr uint32_t TNCK_THD = (4 << 8);  ///< Transmitter NACK Threshold Value
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t RFO = (1U << 0);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t RX_DATA = (1U << 4);  ///< Receive Data Interrupt Flag
        constexpr uint32_t RDTF = (1U << 5);  ///< Receive Data Threshold Interrupt Flag
        constexpr uint32_t LRC_OK = (1U << 6);  ///< LRC Check OK Flag
        constexpr uint32_t CRC_OK = (1U << 7);  ///< CRC Check OK Flag
        constexpr uint32_t CWT_ERR = (1U << 8);  ///< Character Wait Time Error Flag
        constexpr uint32_t RTE = (1U << 9);  ///< Received NACK Threshold Error Flag
        constexpr uint32_t BWT_ERR = (1U << 10);  ///< Block Wait Time Error Flag
        constexpr uint32_t BGT_ERR = (1U << 11);  ///< Block Guard Time Error Flag
        constexpr uint32_t PEF = (1U << 12);  ///< Parity Error Flag
        constexpr uint32_t FEF = (1U << 13);  ///< Frame Error Flag
        constexpr uint32_t RX_WPTR = (4 << 16);  ///< Receive FIFO Write Pointer Value
        constexpr uint32_t RX_CNT = (5 << 24);  ///< Receive FIFO Byte Count
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t TNTE = (1U << 0);  ///< Transmit NACK Threshold Error Flag
        constexpr uint32_t TFE = (1U << 3);  ///< Transmit FIFO Empty Flag
        constexpr uint32_t ETCF = (1U << 4);  ///< Early Transmit Complete Flag
        constexpr uint32_t TCF = (1U << 5);  ///< Transmit Complete Flag
        constexpr uint32_t TFF = (1U << 6);  ///< Transmit FIFO Full Flag
        constexpr uint32_t TDTF = (1U << 7);  ///< Transmit Data Threshold Flag
        constexpr uint32_t GPCNT0_TO = (1U << 8);  ///< General Purpose Counter 0 Timeout Flag
        constexpr uint32_t GPCNT1_TO = (1U << 9);  ///< General Purpose Counter 1 Timeout Flag
        constexpr uint32_t TX_RPTR = (4 << 16);  ///< Transmit FIFO Read Pointer
        constexpr uint32_t TX_CNT = (5 << 24);  ///< Transmit FIFO Byte Count
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t SAPD = (1U << 0);  ///< Auto Power Down Enable
        constexpr uint32_t SVCC_EN = (1U << 1);  ///< Vcc Enable for Smart Card
        constexpr uint32_t VCCENP = (1U << 2);  ///< VCC Enable Polarity Control
        constexpr uint32_t SRST = (1U << 3);  ///< Reset to Smart Card
        constexpr uint32_t SCEN = (1U << 4);  ///< Clock Enable for Smart Card
        constexpr uint32_t SCSP = (1U << 5);  ///< Smart Card Clock Stop Polarity
        constexpr uint32_t SPD = (1U << 7);  ///< Auto Power Down Control
        constexpr uint32_t SPDIM = (1U << 24);  ///< Smart Card Presence Detect Interrupt Mask
        constexpr uint32_t SPDIF = (1U << 25);  ///< Smart Card Presence Detect Interrupt Flag
        constexpr uint32_t SPDP = (1U << 26);  ///< Smart Card Presence Detect Pin Status
        constexpr uint32_t SPDES = (1U << 27);  ///< SIM Presence Detect Edge Select
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BYTE = (8 << 0);  ///< Receive Data Byte Read
    }

    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BYTE = (8 << 0);  ///< Transmit Data Byte
    }

    /// TX_GETU Register bits
    namespace tx_getu_bits {
        constexpr uint32_t GETU = (8 << 0);  ///< Transmitter Guard Time Value in ETU
    }

    /// CWT_VAL Register bits
    namespace cwt_val_bits {
        constexpr uint32_t CWT = (16 << 0);  ///< Character Wait Time Value
    }

    /// BWT_VAL Register bits
    namespace bwt_val_bits {
        constexpr uint32_t BWT = (32 << 0);  ///< Block Wait Time Value
    }

    /// BGT_VAL Register bits
    namespace bgt_val_bits {
        constexpr uint32_t BGT = (16 << 0);  ///< Block Guard Time Value
    }

    /// GPCNT0_VAL Register bits
    namespace gpcnt0_val_bits {
        constexpr uint32_t GPCNT0 = (16 << 0);  ///< General Purpose Counter 0 Timeout Value
    }

    /// GPCNT1_VAL Register bits
    namespace gpcnt1_val_bits {
        constexpr uint32_t GPCNT1 = (16 << 0);  ///< General Purpose Counter 1 Timeout Value
    }

}

// ============================================================================
// EMVSIM1 Peripheral
// ============================================================================

namespace emvsim1 {
    /// Base addresses
    constexpr uint32_t EMVSIM1_BASE = 0x400D5000;

    /// EMVSIM1 Register structure
    struct Registers {
        volatile uint32_t VER_ID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CLKCFG;  ///< Offset: 0x08 - Clock Configuration Register
        volatile uint32_t DIVISOR;  ///< Offset: 0x0C - Baud Rate Divisor Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0x14 - Interrupt Mask Register
        volatile uint32_t RX_THD;  ///< Offset: 0x18 - Receiver Threshold Register
        volatile uint32_t TX_THD;  ///< Offset: 0x1C - Transmitter Threshold Register
        volatile uint32_t RX_STATUS;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t TX_STATUS;  ///< Offset: 0x24 - Transmitter Status Register
        volatile uint32_t PCSR;  ///< Offset: 0x28 - Port Control and Status Register
        volatile uint32_t RX_BUF;  ///< Offset: 0x2C - Receive Data Read Buffer
        volatile uint32_t TX_BUF;  ///< Offset: 0x30 - Transmit Data Buffer
        volatile uint32_t TX_GETU;  ///< Offset: 0x34 - Transmitter Guard ETU Value Register
        volatile uint32_t CWT_VAL;  ///< Offset: 0x38 - Character Wait Time Value Register
        volatile uint32_t BWT_VAL;  ///< Offset: 0x3C - Block Wait Time Value Register
        volatile uint32_t BGT_VAL;  ///< Offset: 0x40 - Block Guard Time Value Register
        volatile uint32_t GPCNT0_VAL;  ///< Offset: 0x44 - General Purpose Counter 0 Timeout Value Register
        volatile uint32_t GPCNT1_VAL;  ///< Offset: 0x48 - General Purpose Counter 1 Timeout Value
    };

    /// Peripheral instances
    inline Registers* EMVSIM1 = reinterpret_cast<Registers*>(EMVSIM1_BASE);

    // Bit definitions
    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t VER = (32 << 0);  ///< Version ID of the module
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RX_FIFO_DEPTH = (8 << 0);  ///< Receive FIFO Depth
        constexpr uint32_t TX_FIFO_DEPTH = (8 << 8);  ///< Transmit FIFO Depth
    }

    /// CLKCFG Register bits
    namespace clkcfg_bits {
        constexpr uint32_t CLK_PRSC = (8 << 0);  ///< Clock Prescaler Value
        constexpr uint32_t GPCNT1_CLK_SEL = (2 << 8);  ///< General Purpose Counter 1 Clock Select
        constexpr uint32_t GPCNT0_CLK_SEL = (2 << 10);  ///< General Purpose Counter 0 Clock Select
    }

    /// DIVISOR Register bits
    namespace divisor_bits {
        constexpr uint32_t DIVISOR_VALUE = (9 << 0);  ///< Divisor (F/D) Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t IC = (1U << 0);  ///< Inverse Convention
        constexpr uint32_t ICM = (1U << 1);  ///< Initial Character Mode
        constexpr uint32_t ANACK = (1U << 2);  ///< Auto NACK Enable
        constexpr uint32_t ONACK = (1U << 3);  ///< Overrun NACK Enable
        constexpr uint32_t FLSH_RX = (1U << 8);  ///< Flush Receiver Bit
        constexpr uint32_t FLSH_TX = (1U << 9);  ///< Flush Transmitter Bit
        constexpr uint32_t SW_RST = (1U << 10);  ///< Software Reset Bit
        constexpr uint32_t KILL_CLOCKS = (1U << 11);  ///< Kill all internal clocks
        constexpr uint32_t DOZE_EN = (1U << 12);  ///< Doze Enable
        constexpr uint32_t STOP_EN = (1U << 13);  ///< STOP Enable
        constexpr uint32_t RCV_EN = (1U << 16);  ///< Receiver Enable
        constexpr uint32_t XMT_EN = (1U << 17);  ///< Transmitter Enable
        constexpr uint32_t RCVR_11 = (1U << 18);  ///< Receiver 11 ETU Mode Enable
        constexpr uint32_t RX_DMA_EN = (1U << 19);  ///< Receive DMA Enable
        constexpr uint32_t TX_DMA_EN = (1U << 20);  ///< Transmit DMA Enable
        constexpr uint32_t INV_CRC_VAL = (1U << 24);  ///< Invert bits in the CRC Output Value
        constexpr uint32_t CRC_OUT_FLIP = (1U << 25);  ///< CRC Output Value Bit Reversal or Flip
        constexpr uint32_t CRC_IN_FLIP = (1U << 26);  ///< CRC Input Byte's Bit Reversal or Flip Control
        constexpr uint32_t CWT_EN = (1U << 27);  ///< Character Wait Time Counter Enable
        constexpr uint32_t LRC_EN = (1U << 28);  ///< LRC Enable
        constexpr uint32_t CRC_EN = (1U << 29);  ///< CRC Enable
        constexpr uint32_t XMT_CRC_LRC = (1U << 30);  ///< Transmit CRC or LRC Enable
        constexpr uint32_t BWT_EN = (1U << 31);  ///< Block Wait Time Counter Enable
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t RDT_IM = (1U << 0);  ///< Receive Data Threshold Interrupt Mask
        constexpr uint32_t TC_IM = (1U << 1);  ///< Transmit Complete Interrupt Mask
        constexpr uint32_t RFO_IM = (1U << 2);  ///< Receive FIFO Overflow Interrupt Mask
        constexpr uint32_t ETC_IM = (1U << 3);  ///< Early Transmit Complete Interrupt Mask
        constexpr uint32_t TFE_IM = (1U << 4);  ///< Transmit FIFO Empty Interrupt Mask
        constexpr uint32_t TNACK_IM = (1U << 5);  ///< Transmit NACK Threshold Interrupt Mask
        constexpr uint32_t TFF_IM = (1U << 6);  ///< Transmit FIFO Full Interrupt Mask
        constexpr uint32_t TDT_IM = (1U << 7);  ///< Transmit Data Threshold Interrupt Mask
        constexpr uint32_t GPCNT0_IM = (1U << 8);  ///< General Purpose Timer 0 Timeout Interrupt Mask
        constexpr uint32_t CWT_ERR_IM = (1U << 9);  ///< Character Wait Time Error Interrupt Mask
        constexpr uint32_t RNACK_IM = (1U << 10);  ///< Receiver NACK Threshold Interrupt Mask
        constexpr uint32_t BWT_ERR_IM = (1U << 11);  ///< Block Wait Time Error Interrupt Mask
        constexpr uint32_t BGT_ERR_IM = (1U << 12);  ///< Block Guard Time Error Interrupt
        constexpr uint32_t GPCNT1_IM = (1U << 13);  ///< General Purpose Counter 1 Timeout Interrupt Mask
        constexpr uint32_t RX_DATA_IM = (1U << 14);  ///< Receive Data Interrupt Mask
        constexpr uint32_t PEF_IM = (1U << 15);  ///< Parity Error Interrupt Mask
    }

    /// RX_THD Register bits
    namespace rx_thd_bits {
        constexpr uint32_t RDT = (4 << 0);  ///< Receiver Data Threshold Value
        constexpr uint32_t RNCK_THD = (4 << 8);  ///< Receiver NACK Threshold Value
    }

    /// TX_THD Register bits
    namespace tx_thd_bits {
        constexpr uint32_t TDT = (4 << 0);  ///< Transmitter Data Threshold Value
        constexpr uint32_t TNCK_THD = (4 << 8);  ///< Transmitter NACK Threshold Value
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t RFO = (1U << 0);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t RX_DATA = (1U << 4);  ///< Receive Data Interrupt Flag
        constexpr uint32_t RDTF = (1U << 5);  ///< Receive Data Threshold Interrupt Flag
        constexpr uint32_t LRC_OK = (1U << 6);  ///< LRC Check OK Flag
        constexpr uint32_t CRC_OK = (1U << 7);  ///< CRC Check OK Flag
        constexpr uint32_t CWT_ERR = (1U << 8);  ///< Character Wait Time Error Flag
        constexpr uint32_t RTE = (1U << 9);  ///< Received NACK Threshold Error Flag
        constexpr uint32_t BWT_ERR = (1U << 10);  ///< Block Wait Time Error Flag
        constexpr uint32_t BGT_ERR = (1U << 11);  ///< Block Guard Time Error Flag
        constexpr uint32_t PEF = (1U << 12);  ///< Parity Error Flag
        constexpr uint32_t FEF = (1U << 13);  ///< Frame Error Flag
        constexpr uint32_t RX_WPTR = (4 << 16);  ///< Receive FIFO Write Pointer Value
        constexpr uint32_t RX_CNT = (5 << 24);  ///< Receive FIFO Byte Count
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t TNTE = (1U << 0);  ///< Transmit NACK Threshold Error Flag
        constexpr uint32_t TFE = (1U << 3);  ///< Transmit FIFO Empty Flag
        constexpr uint32_t ETCF = (1U << 4);  ///< Early Transmit Complete Flag
        constexpr uint32_t TCF = (1U << 5);  ///< Transmit Complete Flag
        constexpr uint32_t TFF = (1U << 6);  ///< Transmit FIFO Full Flag
        constexpr uint32_t TDTF = (1U << 7);  ///< Transmit Data Threshold Flag
        constexpr uint32_t GPCNT0_TO = (1U << 8);  ///< General Purpose Counter 0 Timeout Flag
        constexpr uint32_t GPCNT1_TO = (1U << 9);  ///< General Purpose Counter 1 Timeout Flag
        constexpr uint32_t TX_RPTR = (4 << 16);  ///< Transmit FIFO Read Pointer
        constexpr uint32_t TX_CNT = (5 << 24);  ///< Transmit FIFO Byte Count
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t SAPD = (1U << 0);  ///< Auto Power Down Enable
        constexpr uint32_t SVCC_EN = (1U << 1);  ///< Vcc Enable for Smart Card
        constexpr uint32_t VCCENP = (1U << 2);  ///< VCC Enable Polarity Control
        constexpr uint32_t SRST = (1U << 3);  ///< Reset to Smart Card
        constexpr uint32_t SCEN = (1U << 4);  ///< Clock Enable for Smart Card
        constexpr uint32_t SCSP = (1U << 5);  ///< Smart Card Clock Stop Polarity
        constexpr uint32_t SPD = (1U << 7);  ///< Auto Power Down Control
        constexpr uint32_t SPDIM = (1U << 24);  ///< Smart Card Presence Detect Interrupt Mask
        constexpr uint32_t SPDIF = (1U << 25);  ///< Smart Card Presence Detect Interrupt Flag
        constexpr uint32_t SPDP = (1U << 26);  ///< Smart Card Presence Detect Pin Status
        constexpr uint32_t SPDES = (1U << 27);  ///< SIM Presence Detect Edge Select
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BYTE = (8 << 0);  ///< Receive Data Byte Read
    }

    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BYTE = (8 << 0);  ///< Transmit Data Byte
    }

    /// TX_GETU Register bits
    namespace tx_getu_bits {
        constexpr uint32_t GETU = (8 << 0);  ///< Transmitter Guard Time Value in ETU
    }

    /// CWT_VAL Register bits
    namespace cwt_val_bits {
        constexpr uint32_t CWT = (16 << 0);  ///< Character Wait Time Value
    }

    /// BWT_VAL Register bits
    namespace bwt_val_bits {
        constexpr uint32_t BWT = (32 << 0);  ///< Block Wait Time Value
    }

    /// BGT_VAL Register bits
    namespace bgt_val_bits {
        constexpr uint32_t BGT = (16 << 0);  ///< Block Guard Time Value
    }

    /// GPCNT0_VAL Register bits
    namespace gpcnt0_val_bits {
        constexpr uint32_t GPCNT0 = (16 << 0);  ///< General Purpose Counter 0 Timeout Value
    }

    /// GPCNT1_VAL Register bits
    namespace gpcnt1_val_bits {
        constexpr uint32_t GPCNT1 = (16 << 0);  ///< General Purpose Counter 1 Timeout Value
    }

}

// ============================================================================
// OTFAD Peripheral
// ============================================================================

namespace otfad {
    /// Base addresses
    constexpr uint32_t OTFAD_BASE = 0x400DAC00;

    /// OTFAD Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SR;  ///< Offset: 0x04 - Status Register
        volatile uint32_t CRC;  ///< Offset: 0x08 - Cyclic Redundancy Check Register
        volatile uint32_t CTX_KEY_W0;  ///< Offset: 0x100 - AES Key Word0 (renamed from CTX_KEY_W0)
        volatile uint32_t CTX_KEY_W1;  ///< Offset: 0x104 - AES Key Word1 (renamed from CTX_KEY_W1)
        volatile uint32_t CTX_KEY_W2;  ///< Offset: 0x108 - AES Key Word2 (renamed from CTX_KEY_W2)
        volatile uint32_t CTX_KEY_W3;  ///< Offset: 0x10C - AES Key Word3 (renamed from CTX_KEY_W3)
        volatile uint32_t CTX_CTR_W0;  ///< Offset: 0x110 - AES Counter Word0 (renamed from CTX_CTR_W0)
        volatile uint32_t CTX_CTR_W1;  ///< Offset: 0x114 - AES Counter Word1 (renamed from CTX_CTR_W1)
        volatile uint32_t CTX_RGD_W0;  ///< Offset: 0x118 - AES Region Descriptor Word0 (renamed from CTX_RGD_W0)
        volatile uint32_t CTX_RGD_W1;  ///< Offset: 0x11C - AES Region Descriptor Word1 (renamed from CTX_RGD_W1)
    };

    /// Peripheral instances
    inline Registers* OTFAD = reinterpret_cast<Registers*>(OTFAD_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t FSVM = (1U << 2);  ///< Force Security Violation Mode
        constexpr uint32_t FLDM = (1U << 3);  ///< Force Logically Disabled Mode
        constexpr uint32_t RRAE = (1U << 7);  ///< Restricted Register Access Enable
        constexpr uint32_t CCTX = (2 << 16);  ///< CRC Context
        constexpr uint32_t CRCE = (1U << 20);  ///< CRC Enable
        constexpr uint32_t CRCI = (1U << 21);  ///< CRC Initialization
        constexpr uint32_t GE = (1U << 31);  ///< Global OTFAD Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t MDPCP = (1U << 1);  ///< MDPC Present
        constexpr uint32_t MODE = (2 << 2);  ///< Operating Mode
        constexpr uint32_t NCTX = (4 << 4);  ///< Number of Contexts
        constexpr uint32_t HRL = (4 << 24);  ///< Hardware Revision Level
        constexpr uint32_t RRAM = (1U << 28);  ///< Restricted Register Access Mode
        constexpr uint32_t GEM = (1U << 29);  ///< Global Enable Mode
    }

    /// CRC Register bits
    namespace crc_bits {
        constexpr uint32_t CRCD = (32 << 0);  ///< CRC Data.
    }

    /// CTX_KEY_W0 Register bits
    namespace ctx_key_w0_bits {
        constexpr uint32_t W0KEY = (32 << 0);  ///< AES Key
    }

    /// CTX_KEY_W1 Register bits
    namespace ctx_key_w1_bits {
        constexpr uint32_t W1KEY = (32 << 0);  ///< AES Key
    }

    /// CTX_KEY_W2 Register bits
    namespace ctx_key_w2_bits {
        constexpr uint32_t W2KEY = (32 << 0);  ///< AES Key
    }

    /// CTX_KEY_W3 Register bits
    namespace ctx_key_w3_bits {
        constexpr uint32_t W3KEY = (32 << 0);  ///< AES Key
    }

    /// CTX_CTR_W0 Register bits
    namespace ctx_ctr_w0_bits {
        constexpr uint32_t W0CTR = (32 << 0);  ///< AES Counter
    }

    /// CTX_CTR_W1 Register bits
    namespace ctx_ctr_w1_bits {
        constexpr uint32_t W1CTR = (32 << 0);  ///< AES Counter
    }

    /// CTX_RGD_W0 Register bits
    namespace ctx_rgd_w0_bits {
        constexpr uint32_t SRTADDR = (22 << 10);  ///< Start Address
    }

    /// CTX_RGD_W1 Register bits
    namespace ctx_rgd_w1_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t ADE = (1U << 1);  ///< Aes Decryption Enable.
        constexpr uint32_t RO = (1U << 2);  ///< Read-Only
        constexpr uint32_t ENDADDR = (22 << 10);  ///< End Address
    }

}

// ============================================================================
// FLEXIO0 Peripheral
// ============================================================================

namespace flexio0 {
    /// Base addresses
    constexpr uint32_t FLEXIO0_BASE = 0x400DF000;

    /// FLEXIO0 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL;  ///< Offset: 0x80 - Shifter Control N Register (renamed from SHIFTCTL)
        volatile uint32_t SHIFTCFG;  ///< Offset: 0x100 - Shifter Configuration N Register (renamed from SHIFTCFG)
        volatile uint32_t SHIFTBUF;  ///< Offset: 0x200 - Shifter Buffer N Register (renamed from SHIFTBUF)
        volatile uint32_t SHIFTBUFBIS;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register (renamed from SHIFTBUFBIS)
        volatile uint32_t SHIFTBUFBYS;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register (renamed from SHIFTBUFBYS)
        volatile uint32_t SHIFTBUFBBS;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register (renamed from SHIFTBUFBBS)
        volatile uint32_t TIMCTL;  ///< Offset: 0x400 - Timer Control N Register (renamed from TIMCTL)
        volatile uint32_t TIMCFG;  ///< Offset: 0x480 - Timer Configuration N Register (renamed from TIMCFG)
        volatile uint32_t TIMCMP;  ///< Offset: 0x500 - Timer Compare N Register (renamed from TIMCMP)
        volatile uint32_t SHIFTBUFNBS;  ///< Offset: 0x680 - Shifter Buffer N Nibble Byte Swapped Register (renamed from SHIFTBUFNBS)
        volatile uint32_t SHIFTBUFHWS;  ///< Offset: 0x700 - Shifter Buffer N Half Word Swapped Register (renamed from SHIFTBUFHWS)
        volatile uint32_t SHIFTBUFNIS;  ///< Offset: 0x780 - Shifter Buffer N Nibble Swapped Register (renamed from SHIFTBUFNIS)
    };

    /// Peripheral instances
    inline Registers* FLEXIO0 = reinterpret_cast<Registers*>(FLEXIO0_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (8 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (8 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (8 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (8 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (8 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (8 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (8 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL Register bits
    namespace shiftctl_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// SHIFTCFG Register bits
    namespace shiftcfg_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// SHIFTBUF Register bits
    namespace shiftbuf_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS Register bits
    namespace shiftbufbis_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS Register bits
    namespace shiftbufbys_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS Register bits
    namespace shiftbufbbs_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL Register bits
    namespace timctl_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// TIMCFG Register bits
    namespace timcfg_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP Register bits
    namespace timcmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// SHIFTBUFNBS Register bits
    namespace shiftbufnbs_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFHWS Register bits
    namespace shiftbufhws_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFNIS Register bits
    namespace shiftbufnis_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CR;  ///< Offset: 0x0C - Control Register
        volatile uint32_t ISCR;  ///< Offset: 0x10 - Interrupt Status Register
        volatile uint32_t FADR;  ///< Offset: 0x20 - Fault address register
        volatile uint32_t FATR;  ///< Offset: 0x24 - Fault attributes register
        volatile uint32_t FDR;  ///< Offset: 0x28 - Fault data register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// ISCR Register bits
    namespace iscr_bits {
        constexpr uint32_t FIOC = (1U << 8);  ///< FPU invalid operation interrupt status
        constexpr uint32_t FDZC = (1U << 9);  ///< FPU divide-by-zero interrupt status
        constexpr uint32_t FOFC = (1U << 10);  ///< FPU overflow interrupt status
        constexpr uint32_t FUFC = (1U << 11);  ///< FPU underflow interrupt status
        constexpr uint32_t FIXC = (1U << 12);  ///< FPU inexact interrupt status
        constexpr uint32_t FIDC = (1U << 15);  ///< FPU input denormal interrupt status
        constexpr uint32_t FIOCE = (1U << 24);  ///< FPU invalid operation interrupt enable
        constexpr uint32_t FDZCE = (1U << 25);  ///< FPU divide-by-zero interrupt enable
        constexpr uint32_t FOFCE = (1U << 26);  ///< FPU overflow interrupt enable
        constexpr uint32_t FUFCE = (1U << 27);  ///< FPU underflow interrupt enable
        constexpr uint32_t FIXCE = (1U << 28);  ///< FPU inexact interrupt enable
        constexpr uint32_t FIDCE = (1U << 31);  ///< FPU input denormal interrupt enable
    }

    /// FADR Register bits
    namespace fadr_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Fault address
    }

    /// FATR Register bits
    namespace fatr_bits {
        constexpr uint32_t BEDA = (1U << 0);  ///< Bus error access type
        constexpr uint32_t BEMD = (1U << 1);  ///< Bus error privilege level
        constexpr uint32_t BESZ = (2 << 4);  ///< Bus error size
        constexpr uint32_t BEWT = (1U << 7);  ///< Bus error write
        constexpr uint32_t BEMN = (4 << 8);  ///< Bus error master number
        constexpr uint32_t BEOVR = (1U << 31);  ///< Bus error overrun
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Fault data
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID And M1_PID For MPU
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation wakeup on interrupt
    }

}

// ============================================================================
// CAU Peripheral
// ============================================================================

namespace cau {
    /// Base addresses
    constexpr uint32_t CAU_BASE = 0xE0081000;

    /// CAU Register structure
    struct Registers {
        volatile uint32_t CAU_DIRECT0;  ///< Offset: 0x00 - Direct access register 0
        volatile uint32_t CAU_DIRECT1;  ///< Offset: 0x04 - Direct access register 1
        volatile uint32_t CAU_DIRECT2;  ///< Offset: 0x08 - Direct access register 2
        volatile uint32_t CAU_DIRECT3;  ///< Offset: 0x0C - Direct access register 3
        volatile uint32_t CAU_DIRECT4;  ///< Offset: 0x10 - Direct access register 4
        volatile uint32_t CAU_DIRECT5;  ///< Offset: 0x14 - Direct access register 5
        volatile uint32_t CAU_DIRECT6;  ///< Offset: 0x18 - Direct access register 6
        volatile uint32_t CAU_DIRECT7;  ///< Offset: 0x1C - Direct access register 7
        volatile uint32_t CAU_DIRECT8;  ///< Offset: 0x20 - Direct access register 8
        volatile uint32_t CAU_DIRECT9;  ///< Offset: 0x24 - Direct access register 9
        volatile uint32_t CAU_DIRECT10;  ///< Offset: 0x28 - Direct access register 10
        volatile uint32_t CAU_DIRECT11;  ///< Offset: 0x2C - Direct access register 11
        volatile uint32_t CAU_DIRECT12;  ///< Offset: 0x30 - Direct access register 12
        volatile uint32_t CAU_DIRECT13;  ///< Offset: 0x34 - Direct access register 13
        volatile uint32_t CAU_DIRECT14;  ///< Offset: 0x38 - Direct access register 14
        volatile uint32_t CAU_DIRECT15;  ///< Offset: 0x3C - Direct access register 15
        volatile uint32_t CAU_LDR_CASR;  ///< Offset: 0x840 - Status register - Load Register command
        volatile uint32_t CAU_LDR_CAA;  ///< Offset: 0x844 - Accumulator register - Load Register command
        volatile uint32_t CAU_LDR_CA0;  ///< Offset: 0x848 - General Purpose Register 0 - Load Register command
        volatile uint32_t CAU_LDR_CA1;  ///< Offset: 0x84C - General Purpose Register 1 - Load Register command
        volatile uint32_t CAU_LDR_CA2;  ///< Offset: 0x850 - General Purpose Register 2 - Load Register command
        volatile uint32_t CAU_LDR_CA3;  ///< Offset: 0x854 - General Purpose Register 3 - Load Register command
        volatile uint32_t CAU_LDR_CA4;  ///< Offset: 0x858 - General Purpose Register 4 - Load Register command
        volatile uint32_t CAU_LDR_CA5;  ///< Offset: 0x85C - General Purpose Register 5 - Load Register command
        volatile uint32_t CAU_LDR_CA6;  ///< Offset: 0x860 - General Purpose Register 6 - Load Register command
        volatile uint32_t CAU_LDR_CA7;  ///< Offset: 0x864 - General Purpose Register 7 - Load Register command
        volatile uint32_t CAU_LDR_CA8;  ///< Offset: 0x868 - General Purpose Register 8 - Load Register command
        volatile uint32_t CAU_STR_CASR;  ///< Offset: 0x880 - Status register - Store Register command
        volatile uint32_t CAU_STR_CAA;  ///< Offset: 0x884 - Accumulator register - Store Register command
        volatile uint32_t CAU_STR_CA0;  ///< Offset: 0x888 - General Purpose Register 0 - Store Register command
        volatile uint32_t CAU_STR_CA1;  ///< Offset: 0x88C - General Purpose Register 1 - Store Register command
        volatile uint32_t CAU_STR_CA2;  ///< Offset: 0x890 - General Purpose Register 2 - Store Register command
        volatile uint32_t CAU_STR_CA3;  ///< Offset: 0x894 - General Purpose Register 3 - Store Register command
        volatile uint32_t CAU_STR_CA4;  ///< Offset: 0x898 - General Purpose Register 4 - Store Register command
        volatile uint32_t CAU_STR_CA5;  ///< Offset: 0x89C - General Purpose Register 5 - Store Register command
        volatile uint32_t CAU_STR_CA6;  ///< Offset: 0x8A0 - General Purpose Register 6 - Store Register command
        volatile uint32_t CAU_STR_CA7;  ///< Offset: 0x8A4 - General Purpose Register 7 - Store Register command
        volatile uint32_t CAU_STR_CA8;  ///< Offset: 0x8A8 - General Purpose Register 8 - Store Register command
        volatile uint32_t CAU_ADR_CASR;  ///< Offset: 0x8C0 - Status register - Add Register command
        volatile uint32_t CAU_ADR_CAA;  ///< Offset: 0x8C4 - Accumulator register - Add to register command
        volatile uint32_t CAU_ADR_CA0;  ///< Offset: 0x8C8 - General Purpose Register 0 - Add to register command
        volatile uint32_t CAU_ADR_CA1;  ///< Offset: 0x8CC - General Purpose Register 1 - Add to register command
        volatile uint32_t CAU_ADR_CA2;  ///< Offset: 0x8D0 - General Purpose Register 2 - Add to register command
        volatile uint32_t CAU_ADR_CA3;  ///< Offset: 0x8D4 - General Purpose Register 3 - Add to register command
        volatile uint32_t CAU_ADR_CA4;  ///< Offset: 0x8D8 - General Purpose Register 4 - Add to register command
        volatile uint32_t CAU_ADR_CA5;  ///< Offset: 0x8DC - General Purpose Register 5 - Add to register command
        volatile uint32_t CAU_ADR_CA6;  ///< Offset: 0x8E0 - General Purpose Register 6 - Add to register command
        volatile uint32_t CAU_ADR_CA7;  ///< Offset: 0x8E4 - General Purpose Register 7 - Add to register command
        volatile uint32_t CAU_ADR_CA8;  ///< Offset: 0x8E8 - General Purpose Register 8 - Add to register command
        volatile uint32_t CAU_RADR_CASR;  ///< Offset: 0x900 - Status register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CAA;  ///< Offset: 0x904 - Accumulator register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA0;  ///< Offset: 0x908 - General Purpose Register 0 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA1;  ///< Offset: 0x90C - General Purpose Register 1 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA2;  ///< Offset: 0x910 - General Purpose Register 2 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA3;  ///< Offset: 0x914 - General Purpose Register 3 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA4;  ///< Offset: 0x918 - General Purpose Register 4 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA5;  ///< Offset: 0x91C - General Purpose Register 5 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA6;  ///< Offset: 0x920 - General Purpose Register 6 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA7;  ///< Offset: 0x924 - General Purpose Register 7 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA8;  ///< Offset: 0x928 - General Purpose Register 8 - Reverse and Add to Register command
        volatile uint32_t CAU_XOR_CASR;  ///< Offset: 0x980 - Status register - Exclusive Or command
        volatile uint32_t CAU_XOR_CAA;  ///< Offset: 0x984 - Accumulator register - Exclusive Or command
        volatile uint32_t CAU_XOR_CA0;  ///< Offset: 0x988 - General Purpose Register 0 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA1;  ///< Offset: 0x98C - General Purpose Register 1 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA2;  ///< Offset: 0x990 - General Purpose Register 2 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA3;  ///< Offset: 0x994 - General Purpose Register 3 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA4;  ///< Offset: 0x998 - General Purpose Register 4 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA5;  ///< Offset: 0x99C - General Purpose Register 5 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA6;  ///< Offset: 0x9A0 - General Purpose Register 6 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA7;  ///< Offset: 0x9A4 - General Purpose Register 7 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA8;  ///< Offset: 0x9A8 - General Purpose Register 8 - Exclusive Or command
        volatile uint32_t CAU_ROTL_CASR;  ///< Offset: 0x9C0 - Status register - Rotate Left command
        volatile uint32_t CAU_ROTL_CAA;  ///< Offset: 0x9C4 - Accumulator register - Rotate Left command
        volatile uint32_t CAU_ROTL_CA0;  ///< Offset: 0x9C8 - General Purpose Register 0 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA1;  ///< Offset: 0x9CC - General Purpose Register 1 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA2;  ///< Offset: 0x9D0 - General Purpose Register 2 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA3;  ///< Offset: 0x9D4 - General Purpose Register 3 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA4;  ///< Offset: 0x9D8 - General Purpose Register 4 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA5;  ///< Offset: 0x9DC - General Purpose Register 5 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA6;  ///< Offset: 0x9E0 - General Purpose Register 6 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA7;  ///< Offset: 0x9E4 - General Purpose Register 7 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA8;  ///< Offset: 0x9E8 - General Purpose Register 8 - Rotate Left command
        volatile uint32_t CAU_AESC_CASR;  ///< Offset: 0xB00 - Status register - AES Column Operation command
        volatile uint32_t CAU_AESC_CAA;  ///< Offset: 0xB04 - Accumulator register - AES Column Operation command
        volatile uint32_t CAU_AESC_CA0;  ///< Offset: 0xB08 - General Purpose Register 0 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA1;  ///< Offset: 0xB0C - General Purpose Register 1 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA2;  ///< Offset: 0xB10 - General Purpose Register 2 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA3;  ///< Offset: 0xB14 - General Purpose Register 3 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA4;  ///< Offset: 0xB18 - General Purpose Register 4 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA5;  ///< Offset: 0xB1C - General Purpose Register 5 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA6;  ///< Offset: 0xB20 - General Purpose Register 6 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA7;  ///< Offset: 0xB24 - General Purpose Register 7 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA8;  ///< Offset: 0xB28 - General Purpose Register 8 - AES Column Operation command
        volatile uint32_t CAU_AESIC_CASR;  ///< Offset: 0xB40 - Status register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CAA;  ///< Offset: 0xB44 - Accumulator register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA0;  ///< Offset: 0xB48 - General Purpose Register 0 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA1;  ///< Offset: 0xB4C - General Purpose Register 1 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA2;  ///< Offset: 0xB50 - General Purpose Register 2 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA3;  ///< Offset: 0xB54 - General Purpose Register 3 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA4;  ///< Offset: 0xB58 - General Purpose Register 4 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA5;  ///< Offset: 0xB5C - General Purpose Register 5 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA6;  ///< Offset: 0xB60 - General Purpose Register 6 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA7;  ///< Offset: 0xB64 - General Purpose Register 7 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA8;  ///< Offset: 0xB68 - General Purpose Register 8 - AES Inverse Column Operation command
    };

    /// Peripheral instances
    inline Registers* CAU = reinterpret_cast<Registers*>(CAU_BASE);

    // Bit definitions
    /// CAU_DIRECT0 Register bits
    namespace cau_direct0_bits {
        constexpr uint32_t CAU_DIRECT0 = (32 << 0);  ///< Direct register 0
    }

    /// CAU_DIRECT1 Register bits
    namespace cau_direct1_bits {
        constexpr uint32_t CAU_DIRECT1 = (32 << 0);  ///< Direct register 1
    }

    /// CAU_DIRECT2 Register bits
    namespace cau_direct2_bits {
        constexpr uint32_t CAU_DIRECT2 = (32 << 0);  ///< Direct register 2
    }

    /// CAU_DIRECT3 Register bits
    namespace cau_direct3_bits {
        constexpr uint32_t CAU_DIRECT3 = (32 << 0);  ///< Direct register 3
    }

    /// CAU_DIRECT4 Register bits
    namespace cau_direct4_bits {
        constexpr uint32_t CAU_DIRECT4 = (32 << 0);  ///< Direct register 4
    }

    /// CAU_DIRECT5 Register bits
    namespace cau_direct5_bits {
        constexpr uint32_t CAU_DIRECT5 = (32 << 0);  ///< Direct register 5
    }

    /// CAU_DIRECT6 Register bits
    namespace cau_direct6_bits {
        constexpr uint32_t CAU_DIRECT6 = (32 << 0);  ///< Direct register 6
    }

    /// CAU_DIRECT7 Register bits
    namespace cau_direct7_bits {
        constexpr uint32_t CAU_DIRECT7 = (32 << 0);  ///< Direct register 7
    }

    /// CAU_DIRECT8 Register bits
    namespace cau_direct8_bits {
        constexpr uint32_t CAU_DIRECT8 = (32 << 0);  ///< Direct register 8
    }

    /// CAU_DIRECT9 Register bits
    namespace cau_direct9_bits {
        constexpr uint32_t CAU_DIRECT9 = (32 << 0);  ///< Direct register 9
    }

    /// CAU_DIRECT10 Register bits
    namespace cau_direct10_bits {
        constexpr uint32_t CAU_DIRECT10 = (32 << 0);  ///< Direct register 10
    }

    /// CAU_DIRECT11 Register bits
    namespace cau_direct11_bits {
        constexpr uint32_t CAU_DIRECT11 = (32 << 0);  ///< Direct register 11
    }

    /// CAU_DIRECT12 Register bits
    namespace cau_direct12_bits {
        constexpr uint32_t CAU_DIRECT12 = (32 << 0);  ///< Direct register 12
    }

    /// CAU_DIRECT13 Register bits
    namespace cau_direct13_bits {
        constexpr uint32_t CAU_DIRECT13 = (32 << 0);  ///< Direct register 13
    }

    /// CAU_DIRECT14 Register bits
    namespace cau_direct14_bits {
        constexpr uint32_t CAU_DIRECT14 = (32 << 0);  ///< Direct register 14
    }

    /// CAU_DIRECT15 Register bits
    namespace cau_direct15_bits {
        constexpr uint32_t CAU_DIRECT15 = (32 << 0);  ///< Direct register 15
    }

    /// CAU_LDR_CASR Register bits
    namespace cau_ldr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_LDR_CAA Register bits
    namespace cau_ldr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_LDR_CA0 Register bits
    namespace cau_ldr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_LDR_CA1 Register bits
    namespace cau_ldr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_LDR_CA2 Register bits
    namespace cau_ldr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_LDR_CA3 Register bits
    namespace cau_ldr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_LDR_CA4 Register bits
    namespace cau_ldr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_LDR_CA5 Register bits
    namespace cau_ldr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_LDR_CA6 Register bits
    namespace cau_ldr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_LDR_CA7 Register bits
    namespace cau_ldr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_LDR_CA8 Register bits
    namespace cau_ldr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_STR_CASR Register bits
    namespace cau_str_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_STR_CAA Register bits
    namespace cau_str_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_STR_CA0 Register bits
    namespace cau_str_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_STR_CA1 Register bits
    namespace cau_str_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_STR_CA2 Register bits
    namespace cau_str_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_STR_CA3 Register bits
    namespace cau_str_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_STR_CA4 Register bits
    namespace cau_str_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_STR_CA5 Register bits
    namespace cau_str_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_STR_CA6 Register bits
    namespace cau_str_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_STR_CA7 Register bits
    namespace cau_str_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_STR_CA8 Register bits
    namespace cau_str_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ADR_CASR Register bits
    namespace cau_adr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ADR_CAA Register bits
    namespace cau_adr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ADR_CA0 Register bits
    namespace cau_adr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ADR_CA1 Register bits
    namespace cau_adr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ADR_CA2 Register bits
    namespace cau_adr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ADR_CA3 Register bits
    namespace cau_adr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ADR_CA4 Register bits
    namespace cau_adr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ADR_CA5 Register bits
    namespace cau_adr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ADR_CA6 Register bits
    namespace cau_adr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ADR_CA7 Register bits
    namespace cau_adr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ADR_CA8 Register bits
    namespace cau_adr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_RADR_CASR Register bits
    namespace cau_radr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_RADR_CAA Register bits
    namespace cau_radr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_RADR_CA0 Register bits
    namespace cau_radr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_RADR_CA1 Register bits
    namespace cau_radr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_RADR_CA2 Register bits
    namespace cau_radr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_RADR_CA3 Register bits
    namespace cau_radr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_RADR_CA4 Register bits
    namespace cau_radr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_RADR_CA5 Register bits
    namespace cau_radr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_RADR_CA6 Register bits
    namespace cau_radr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_RADR_CA7 Register bits
    namespace cau_radr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_RADR_CA8 Register bits
    namespace cau_radr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_XOR_CASR Register bits
    namespace cau_xor_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_XOR_CAA Register bits
    namespace cau_xor_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_XOR_CA0 Register bits
    namespace cau_xor_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_XOR_CA1 Register bits
    namespace cau_xor_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_XOR_CA2 Register bits
    namespace cau_xor_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_XOR_CA3 Register bits
    namespace cau_xor_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_XOR_CA4 Register bits
    namespace cau_xor_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_XOR_CA5 Register bits
    namespace cau_xor_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_XOR_CA6 Register bits
    namespace cau_xor_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_XOR_CA7 Register bits
    namespace cau_xor_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_XOR_CA8 Register bits
    namespace cau_xor_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ROTL_CASR Register bits
    namespace cau_rotl_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ROTL_CAA Register bits
    namespace cau_rotl_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ROTL_CA0 Register bits
    namespace cau_rotl_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ROTL_CA1 Register bits
    namespace cau_rotl_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ROTL_CA2 Register bits
    namespace cau_rotl_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ROTL_CA3 Register bits
    namespace cau_rotl_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ROTL_CA4 Register bits
    namespace cau_rotl_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ROTL_CA5 Register bits
    namespace cau_rotl_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ROTL_CA6 Register bits
    namespace cau_rotl_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ROTL_CA7 Register bits
    namespace cau_rotl_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ROTL_CA8 Register bits
    namespace cau_rotl_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESC_CASR Register bits
    namespace cau_aesc_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESC_CAA Register bits
    namespace cau_aesc_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESC_CA0 Register bits
    namespace cau_aesc_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESC_CA1 Register bits
    namespace cau_aesc_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESC_CA2 Register bits
    namespace cau_aesc_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESC_CA3 Register bits
    namespace cau_aesc_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESC_CA4 Register bits
    namespace cau_aesc_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESC_CA5 Register bits
    namespace cau_aesc_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESC_CA6 Register bits
    namespace cau_aesc_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESC_CA7 Register bits
    namespace cau_aesc_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESC_CA8 Register bits
    namespace cau_aesc_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESIC_CASR Register bits
    namespace cau_aesic_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESIC_CAA Register bits
    namespace cau_aesic_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESIC_CA0 Register bits
    namespace cau_aesic_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESIC_CA1 Register bits
    namespace cau_aesic_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESIC_CA2 Register bits
    namespace cau_aesic_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESIC_CA3 Register bits
    namespace cau_aesic_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESIC_CA4 Register bits
    namespace cau_aesic_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESIC_CA5 Register bits
    namespace cau_aesic_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESIC_CA6 Register bits
    namespace cau_aesic_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESIC_CA7 Register bits
    namespace cau_aesic_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESIC_CA8 Register bits
    namespace cau_aesic_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

}

// ============================================================================
// LMEM Peripheral
// ============================================================================

namespace lmem {
    /// Base addresses
    constexpr uint32_t LMEM_BASE = 0xE0082000;

    /// LMEM Register structure
    struct Registers {
        volatile uint32_t PCCCR;  ///< Offset: 0x00 - Cache control register
        volatile uint32_t PCCLCR;  ///< Offset: 0x04 - Cache line control register
        volatile uint32_t PCCSAR;  ///< Offset: 0x08 - Cache search address register
        volatile uint32_t PCCCVR;  ///< Offset: 0x0C - Cache read/write value register
        volatile uint32_t PCCRMR;  ///< Offset: 0x20 - Cache regions mode register
        volatile uint32_t PSCCR;  ///< Offset: 0x800 - Cache control register
        volatile uint32_t PSCLCR;  ///< Offset: 0x804 - Cache line control register
        volatile uint32_t PSCSAR;  ///< Offset: 0x808 - Cache search address register
        volatile uint32_t PSCCVR;  ///< Offset: 0x80C - Cache read/write value register
        volatile uint32_t PSCRMR;  ///< Offset: 0x820 - Cache regions mode register
    };

    /// Peripheral instances
    inline Registers* LMEM = reinterpret_cast<Registers*>(LMEM_BASE);

    // Bit definitions
    /// PCCCR Register bits
    namespace pcccr_bits {
        constexpr uint32_t ENCACHE = (1U << 0);  ///< Cache enable
        constexpr uint32_t ENWRBUF = (1U << 1);  ///< Enable Write Buffer
        constexpr uint32_t PCCR2 = (1U << 2);  ///< Forces all cacheable spaces to write through
        constexpr uint32_t PCCR3 = (1U << 3);  ///< Forces no allocation on cache misses (must also have PCCR2 asserted)
        constexpr uint32_t INVW0 = (1U << 24);  ///< Invalidate Way 0
        constexpr uint32_t PUSHW0 = (1U << 25);  ///< Push Way 0
        constexpr uint32_t INVW1 = (1U << 26);  ///< Invalidate Way 1
        constexpr uint32_t PUSHW1 = (1U << 27);  ///< Push Way 1
        constexpr uint32_t GO = (1U << 31);  ///< Initiate Cache Command
    }

    /// PCCLCR Register bits
    namespace pcclcr_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t CACHEADDR = (10 << 2);  ///< Cache address
        constexpr uint32_t WSEL = (1U << 14);  ///< Way select
        constexpr uint32_t TDSEL = (1U << 16);  ///< Tag/Data Select
        constexpr uint32_t LCIVB = (1U << 20);  ///< Line Command Initial Valid Bit
        constexpr uint32_t LCIMB = (1U << 21);  ///< Line Command Initial Modified Bit
        constexpr uint32_t LCWAY = (1U << 22);  ///< Line Command Way
        constexpr uint32_t LCMD = (2 << 24);  ///< Line Command
        constexpr uint32_t LADSEL = (1U << 26);  ///< Line Address Select
        constexpr uint32_t LACC = (1U << 27);  ///< Line access type
    }

    /// PCCSAR Register bits
    namespace pccsar_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t PHYADDR = (30 << 2);  ///< Physical Address
    }

    /// PCCCVR Register bits
    namespace pcccvr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Cache read/write Data
    }

    /// PCCRMR Register bits
    namespace pccrmr_bits {
        constexpr uint32_t R15 = (2 << 0);  ///< Region 15 mode
        constexpr uint32_t R14 = (2 << 2);  ///< Region 14 mode
        constexpr uint32_t R13 = (2 << 4);  ///< Region 13 mode
        constexpr uint32_t R12 = (2 << 6);  ///< Region 12 mode
        constexpr uint32_t R11 = (2 << 8);  ///< Region 11 mode
        constexpr uint32_t R10 = (2 << 10);  ///< Region 10 mode
        constexpr uint32_t R9 = (2 << 12);  ///< Region 9 mode
        constexpr uint32_t R8 = (2 << 14);  ///< Region 8 mode
        constexpr uint32_t R7 = (2 << 16);  ///< Region 7 mode
        constexpr uint32_t R6 = (2 << 18);  ///< Region 6 mode
        constexpr uint32_t R5 = (2 << 20);  ///< Region 5 mode
        constexpr uint32_t R4 = (2 << 22);  ///< Region 4 mode
        constexpr uint32_t R3 = (2 << 24);  ///< Region 3 mode
        constexpr uint32_t R2 = (2 << 26);  ///< Region 2 mode
        constexpr uint32_t R1 = (2 << 28);  ///< Region 1 mode
        constexpr uint32_t R0 = (2 << 30);  ///< Region 0 mode
    }

    /// PSCCR Register bits
    namespace psccr_bits {
        constexpr uint32_t ENCACHE = (1U << 0);  ///< Cache enable
        constexpr uint32_t ENWRBUF = (1U << 1);  ///< Enable Write Buffer
        constexpr uint32_t INVW0 = (1U << 24);  ///< Invalidate Way 0
        constexpr uint32_t PUSHW0 = (1U << 25);  ///< Push Way 0
        constexpr uint32_t INVW1 = (1U << 26);  ///< Invalidate Way 1
        constexpr uint32_t PUSHW1 = (1U << 27);  ///< Push Way 1
        constexpr uint32_t GO = (1U << 31);  ///< Initiate Cache Command
    }

    /// PSCLCR Register bits
    namespace psclcr_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t CACHEADDR = (10 << 2);  ///< Cache address
        constexpr uint32_t WSEL = (1U << 14);  ///< Way select
        constexpr uint32_t TDSEL = (1U << 16);  ///< Tag/Data Select
        constexpr uint32_t LCIVB = (1U << 20);  ///< Line Command Initial Valid Bit
        constexpr uint32_t LCIMB = (1U << 21);  ///< Line Command Initial Modified Bit
        constexpr uint32_t LCWAY = (1U << 22);  ///< Line Command Way
        constexpr uint32_t LCMD = (2 << 24);  ///< Line Command
        constexpr uint32_t LADSEL = (1U << 26);  ///< Line Address Select
        constexpr uint32_t LACC = (1U << 27);  ///< Line access type
    }

    /// PSCSAR Register bits
    namespace pscsar_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t PHYADDR = (30 << 2);  ///< Physical Address
    }

    /// PSCCVR Register bits
    namespace psccvr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Cache read/write Data
    }

    /// PSCRMR Register bits
    namespace pscrmr_bits {
        constexpr uint32_t R15 = (2 << 0);  ///< Region 15 mode
        constexpr uint32_t R14 = (2 << 2);  ///< Region 14 mode
        constexpr uint32_t R13 = (2 << 4);  ///< Region 13 mode
        constexpr uint32_t R12 = (2 << 6);  ///< Region 12 mode
        constexpr uint32_t R11 = (2 << 8);  ///< Region 11 mode
        constexpr uint32_t R10 = (2 << 10);  ///< Region 10 mode
        constexpr uint32_t R9 = (2 << 12);  ///< Region 9 mode
        constexpr uint32_t R8 = (2 << 14);  ///< Region 8 mode
        constexpr uint32_t R7 = (2 << 16);  ///< Region 7 mode
        constexpr uint32_t R6 = (2 << 18);  ///< Region 6 mode
        constexpr uint32_t R5 = (2 << 20);  ///< Region 5 mode
        constexpr uint32_t R4 = (2 << 22);  ///< Region 4 mode
        constexpr uint32_t R3 = (2 << 24);  ///< Region 3 mode
        constexpr uint32_t R2 = (2 << 26);  ///< Region 2 mode
        constexpr uint32_t R1 = (2 << 28);  ///< Region 1 mode
        constexpr uint32_t R0 = (2 << 30);  ///< Region 0 mode
    }

}


} // namespace alloy::generated::mk82f25615

#endif // ALLOY_GENERATED_MK82F25615_PERIPHERALS_HPP