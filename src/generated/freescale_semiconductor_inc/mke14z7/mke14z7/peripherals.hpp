/// Auto-generated code for MKE14Z7
/// Generated by Alloy Code Generator
/// Source: nxp_mke14.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:25
#ifndef ALLOY_GENERATED_MKE14Z7_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKE14Z7_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mke14z7 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips = true;
    constexpr uint32_t num_aips_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_ftfe = true;
    constexpr uint32_t num_ftfe_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_pwt = true;
    constexpr uint32_t num_pwt_instances = 1;
    constexpr bool has_flexio = true;
    constexpr uint32_t num_flexio_instances = 1;
    constexpr bool has_osc32 = true;
    constexpr uint32_t num_osc32_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_trgmux0 = true;
    constexpr uint32_t num_trgmux0_instances = 1;
    constexpr bool has_trgmux1 = true;
    constexpr uint32_t num_trgmux1_instances = 1;
    constexpr bool has_scg = true;
    constexpr uint32_t num_scg_instances = 1;
    constexpr bool has_pcc = true;
    constexpr uint32_t num_pcc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_mmdvsq = true;
    constexpr uint32_t num_mmdvsq_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftfe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc32_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmdvsq_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFE_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE_FlashConfig = reinterpret_cast<Registers*>(FTFE_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS Peripheral
// ============================================================================

namespace aips {
    /// Base addresses
    constexpr uint32_t AIPS_BASE = 0x40000000;

    /// AIPS Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACR;  ///< Offset: 0x20 - Peripheral Access Control Register (renamed from PACR)
        volatile uint32_t OPACR;  ///< Offset: 0x40 - Off-Platform Peripheral Access Control Register (renamed from OPACR)
        volatile uint32_t PACRU;  ///< Offset: 0x80 - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS = reinterpret_cast<Registers*>(AIPS_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACR Register bits
    namespace pacr_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// OPACR Register bits
    namespace opacr_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRU Register bits
    namespace pacru_bits {
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and... (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (3 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (3 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (3 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (3 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (3 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (3 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (3 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (3 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (3 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (3 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (3 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// FTFE Peripheral
// ============================================================================

namespace ftfe {
    /// Base addresses
    constexpr uint32_t FTFE_BASE = 0x40020000;

    /// FTFE Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB;  ///< Offset: 0x04 - Flash Common Command Object Registers (renamed from FCCOB)
        volatile uint32_t FPROT;  ///< Offset: 0x10 - Program Flash Protection Registers (renamed from FPROT)
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
        volatile uint32_t XACC;  ///< Offset: 0x18 - Execute-only Access Registers (renamed from XACC)
        volatile uint32_t SACC;  ///< Offset: 0x20 - Supervisor-only Access Registers (renamed from SACC)
        volatile uint32_t FACSS;  ///< Offset: 0x28 - Flash Access Segment Size Register
        volatile uint32_t FACSN;  ///< Offset: 0x2B - Flash Access Segment Number Register
        volatile uint32_t FERSTAT;  ///< Offset: 0x2E - Flash Error Status Register
        volatile uint32_t FERCNFG;  ///< Offset: 0x2F - Flash Error Configuration Register
    };

    /// Peripheral instances
    inline Registers* FTFE = reinterpret_cast<Registers*>(FTFE_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFE Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFE configuration
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB Register bits
    namespace fccob_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< The FCCOB register provides a command code and relevant parameters to the memory controller
    }

    /// FPROT Register bits
    namespace fprot_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

    /// XACC Register bits
    namespace xacc_bits {
        constexpr uint32_t XA = (8 << 0);  ///< Execute-only access control
    }

    /// SACC Register bits
    namespace sacc_bits {
        constexpr uint32_t SA = (8 << 0);  ///< Supervisor-only access control
    }

    /// FACSS Register bits
    namespace facss_bits {
        constexpr uint32_t SGSIZE = (8 << 0);  ///< Segment Size
    }

    /// FACSN Register bits
    namespace facsn_bits {
        constexpr uint32_t NUMSG = (8 << 0);  ///< Number of Segments Indicator
    }

    /// FERSTAT Register bits
    namespace ferstat_bits {
        constexpr uint32_t DFDIF = (1U << 1);  ///< Double Bit Fault Detect Interrupt Flag
    }

    /// FERCNFG Register bits
    namespace fercnfg_bits {
        constexpr uint32_t DFDIE = (1U << 1);  ///< Double Bit Fault Detect Interrupt Enable
        constexpr uint32_t FDFD = (1U << 5);  ///< Force Double Bit Fault Detect
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x40027000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x40 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x44 - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x48 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x88 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x90 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x94 - Status and Control Register 3
        volatile uint32_t BASE_OFS;  ///< Offset: 0x98 - BASE Offset Register
        volatile uint32_t OFS;  ///< Offset: 0x9C - ADC Offset Correction Register
        volatile uint32_t USR_OFS;  ///< Offset: 0xA0 - USER Offset Correction Register
        volatile uint32_t XOFS;  ///< Offset: 0xA4 - ADC X Offset Correction Register
        volatile uint32_t YOFS;  ///< Offset: 0xA8 - ADC Y Offset Correction Register
        volatile uint32_t G;  ///< Offset: 0xAC - ADC Gain Register
        volatile uint32_t UG;  ///< Offset: 0xB0 - ADC User Gain Register
        volatile uint32_t CLPS;  ///< Offset: 0xB4 - ADC General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0xB8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0xBC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0xC0 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0xC4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPX;  ///< Offset: 0xC8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP9;  ///< Offset: 0xCC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS_OFS;  ///< Offset: 0xD0 - ADC General Calibration Value Register
        volatile uint32_t CLP3_OFS;  ///< Offset: 0xD4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2_OFS;  ///< Offset: 0xD8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1_OFS;  ///< Offset: 0xDC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0_OFS;  ///< Offset: 0xE0 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPX_OFS;  ///< Offset: 0xE4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP9_OFS;  ///< Offset: 0xE8 - ADC Plus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t SMPLTS = (8 << 0);  ///< Sample Time Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (12 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (12 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// BASE_OFS Register bits
    namespace base_ofs_bits {
        constexpr uint32_t BA_OFS = (8 << 0);  ///< Base Offset Error Correction Value
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// USR_OFS Register bits
    namespace usr_ofs_bits {
        constexpr uint32_t USR_OFS = (8 << 0);  ///< USER Offset Error Correction Value
    }

    /// XOFS Register bits
    namespace xofs_bits {
        constexpr uint32_t OFS = (6 << 0);  ///< Offset Error Correction Value
    }

    /// YOFS Register bits
    namespace yofs_bits {
        constexpr uint32_t YOFS = (8 << 0);  ///< Y Offset Error Correction Value
    }

    /// G Register bits
    namespace g_bits {
        constexpr uint32_t G = (11 << 0);  ///< Gain
    }

    /// UG Register bits
    namespace ug_bits {
        constexpr uint32_t UG = (10 << 0);  ///< User Gain
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (7 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (10 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (10 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (9 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (8 << 0);  ///< Calibration Value
    }

    /// CLPX Register bits
    namespace clpx_bits {
        constexpr uint32_t CLPX = (7 << 0);  ///< Calibration Value
        constexpr uint32_t CLPXEN = (1U << 7);  ///< CLPX compare bit
    }

    /// CLP9 Register bits
    namespace clp9_bits {
        constexpr uint32_t CLP9 = (7 << 0);  ///< Calibration Value
        constexpr uint32_t CLP9EN = (1U << 7);  ///< CLP9 compare bit
    }

    /// CLPS_OFS Register bits
    namespace clps_ofs_bits {
        constexpr uint32_t CLPS_OFS = (4 << 0);  ///< CLPS Offset
    }

    /// CLP3_OFS Register bits
    namespace clp3_ofs_bits {
        constexpr uint32_t CLP3_OFS = (4 << 0);  ///< CLP3 Offset
    }

    /// CLP2_OFS Register bits
    namespace clp2_ofs_bits {
        constexpr uint32_t CLP2_OFS = (4 << 0);  ///< CLP2 Offset
    }

    /// CLP1_OFS Register bits
    namespace clp1_ofs_bits {
        constexpr uint32_t CLP1_OFS = (4 << 0);  ///< CLP1 Offset
    }

    /// CLP0_OFS Register bits
    namespace clp0_ofs_bits {
        constexpr uint32_t CLP0_OFS = (4 << 0);  ///< CLP0 Offset
    }

    /// CLPX_OFS Register bits
    namespace clpx_ofs_bits {
        constexpr uint32_t CLPX_OFS = (12 << 0);  ///< CLPX Offset
    }

    /// CLP9_OFS Register bits
    namespace clp9_ofs_bits {
        constexpr uint32_t CLP9_OFS = (12 << 0);  ///< CLP9 Offset
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t LPSPI0_BASE = 0x4002C000;
    constexpr uint32_t LPSPI1_BASE = 0x4002D000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - Status Register
        volatile uint32_t IER;  ///< Offset: 0x18 - Interrupt Enable Register
        volatile uint32_t DER;  ///< Offset: 0x1C - DMA Enable Register
        volatile uint32_t CFGR0;  ///< Offset: 0x20 - Configuration Register 0
        volatile uint32_t CFGR1;  ///< Offset: 0x24 - Configuration Register 1
        volatile uint32_t DMR0;  ///< Offset: 0x30 - Data Match Register 0
        volatile uint32_t DMR1;  ///< Offset: 0x34 - Data Match Register 1
        volatile uint32_t CCR;  ///< Offset: 0x40 - Clock Configuration Register
        volatile uint32_t FCR;  ///< Offset: 0x58 - FIFO Control Register
        volatile uint32_t FSR;  ///< Offset: 0x5C - FIFO Status Register
        volatile uint32_t TCR;  ///< Offset: 0x60 - Transmit Command Register
        volatile uint32_t TDR;  ///< Offset: 0x64 - Transmit Data Register
        volatile uint32_t RSR;  ///< Offset: 0x70 - Receive Status Register
        volatile uint32_t RDR;  ///< Offset: 0x74 - Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPSPI0 = reinterpret_cast<Registers*>(LPSPI0_BASE);
    inline Registers* LPSPI1 = reinterpret_cast<Registers*>(LPSPI1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Module Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Module Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t WCF = (1U << 8);  ///< Word Complete Flag
        constexpr uint32_t FCF = (1U << 9);  ///< Frame Complete Flag
        constexpr uint32_t TCF = (1U << 10);  ///< Transfer Complete Flag
        constexpr uint32_t TEF = (1U << 11);  ///< Transmit Error Flag
        constexpr uint32_t REF = (1U << 12);  ///< Receive Error Flag
        constexpr uint32_t DMF = (1U << 13);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Module Busy Flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t WCIE = (1U << 8);  ///< Word Complete Interrupt Enable
        constexpr uint32_t FCIE = (1U << 9);  ///< Frame Complete Interrupt Enable
        constexpr uint32_t TCIE = (1U << 10);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t TEIE = (1U << 11);  ///< Transmit Error Interrupt Enable
        constexpr uint32_t REIE = (1U << 12);  ///< Receive Error Interrupt Enable
        constexpr uint32_t DMIE = (1U << 13);  ///< Data Match Interrupt Enable
    }

    /// DER Register bits
    namespace der_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// CFGR0 Register bits
    namespace cfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t MASTER = (1U << 0);  ///< Master Mode
        constexpr uint32_t SAMPLE = (1U << 1);  ///< Sample Point
        constexpr uint32_t AUTOPCS = (1U << 2);  ///< Automatic PCS
        constexpr uint32_t NOSTALL = (1U << 3);  ///< No Stall
        constexpr uint32_t PCSPOL = (4 << 8);  ///< Peripheral Chip Select Polarity
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (2 << 24);  ///< Pin Configuration
        constexpr uint32_t OUTCFG = (1U << 26);  ///< Output Config
        constexpr uint32_t PCSCFG = (1U << 27);  ///< Peripheral Chip Select Configuration
    }

    /// DMR0 Register bits
    namespace dmr0_bits {
        constexpr uint32_t MATCH0 = (32 << 0);  ///< Match 0 Value
    }

    /// DMR1 Register bits
    namespace dmr1_bits {
        constexpr uint32_t MATCH1 = (32 << 0);  ///< Match 1 Value
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t SCKDIV = (8 << 0);  ///< SCK Divider
        constexpr uint32_t DBT = (8 << 8);  ///< Delay Between Transfers
        constexpr uint32_t PCSSCK = (8 << 16);  ///< PCS to SCK Delay
        constexpr uint32_t SCKPCS = (8 << 24);  ///< SCK to PCS Delay
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// FSR Register bits
    namespace fsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t FRAMESZ = (12 << 0);  ///< Frame Size
        constexpr uint32_t WIDTH = (2 << 16);  ///< Transfer Width
        constexpr uint32_t TXMSK = (1U << 18);  ///< Transmit Data Mask
        constexpr uint32_t RXMSK = (1U << 19);  ///< Receive Data Mask
        constexpr uint32_t CONTC = (1U << 20);  ///< Continuing Command
        constexpr uint32_t CONT = (1U << 21);  ///< Continuous Transfer
        constexpr uint32_t BYSW = (1U << 22);  ///< Byte Swap
        constexpr uint32_t LSBF = (1U << 23);  ///< LSB First
        constexpr uint32_t PCS = (2 << 24);  ///< Peripheral Chip Select
        constexpr uint32_t PRESCALE = (3 << 27);  ///< Prescaler Value
        constexpr uint32_t CPHA = (1U << 30);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 31);  ///< Clock Polarity
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Transmit Data
    }

    /// RSR Register bits
    namespace rsr_bits {
        constexpr uint32_t SOF = (1U << 0);  ///< Start Of Frame
        constexpr uint32_t RXEMPTY = (1U << 1);  ///< RX FIFO Empty
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CHC1;  ///< Offset: 0x10 - Channel n Control register 1 (renamed from CHC1)
        volatile uint32_t CHS;  ///< Offset: 0x14 - Channel n Status register (renamed from CHS)
        volatile uint32_t CHDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register (renamed from CHDLY0)
        volatile uint32_t CHDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register (renamed from CHDLY1)
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register (renamed from PODLY)
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CHC1 Register bits
    namespace chc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CHS Register bits
    namespace chs_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CHDLY0 Register bits
    namespace chdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CHDLY1 Register bits
    namespace chdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPIT0_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x08 - Module Control Register
        volatile uint32_t MSR;  ///< Offset: 0x0C - Module Status Register
        volatile uint32_t MIER;  ///< Offset: 0x10 - Module Interrupt Enable Register
        volatile uint32_t SETTEN;  ///< Offset: 0x14 - Set Timer Enable Register
        volatile uint32_t CLRTEN;  ///< Offset: 0x18 - Clear Timer Enable Register
        volatile uint32_t TVAL;  ///< Offset: 0x20 - Timer Value Register (renamed from TVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x24 - Current Timer Value (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x28 - Timer Control Register (renamed from TCTRL)
    };

    /// Peripheral instances
    inline Registers* LPIT0 = reinterpret_cast<Registers*>(LPIT0_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CHANNEL = (8 << 0);  ///< Number of Timer Channels
        constexpr uint32_t EXT_TRIG = (8 << 8);  ///< Number of External Trigger Inputs
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t M_CEN = (1U << 0);  ///< Module Clock Enable
        constexpr uint32_t SW_RST = (1U << 1);  ///< Software Reset Bit
        constexpr uint32_t DOZE_EN = (1U << 2);  ///< DOZE Mode Enable Bit
        constexpr uint32_t DBG_EN = (1U << 3);  ///< Debug Enable Bit
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TIF0 = (1U << 0);  ///< Channel 0 Timer Interrupt Flag
        constexpr uint32_t TIF1 = (1U << 1);  ///< Channel 1 Timer Interrupt Flag
        constexpr uint32_t TIF2 = (1U << 2);  ///< Channel 2 Timer Interrupt Flag
        constexpr uint32_t TIF3 = (1U << 3);  ///< Channel 3 Timer Interrupt Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TIE0 = (1U << 0);  ///< Channel 0 Timer Interrupt Enable
        constexpr uint32_t TIE1 = (1U << 1);  ///< Channel 1 Timer Interrupt Enable
        constexpr uint32_t TIE2 = (1U << 2);  ///< Channel 2 Timer Interrupt Enable
        constexpr uint32_t TIE3 = (1U << 3);  ///< Channel 3 Timer Interrupt Enable
    }

    /// SETTEN Register bits
    namespace setten_bits {
        constexpr uint32_t SET_T_EN_0 = (1U << 0);  ///< Set Timer 0 Enable
        constexpr uint32_t SET_T_EN_1 = (1U << 1);  ///< Set Timer 1 Enable
        constexpr uint32_t SET_T_EN_2 = (1U << 2);  ///< Set Timer 2 Enable
        constexpr uint32_t SET_T_EN_3 = (1U << 3);  ///< Set Timer 3 Enable
    }

    /// CLRTEN Register bits
    namespace clrten_bits {
        constexpr uint32_t CLR_T_EN_0 = (1U << 0);  ///< Clear Timer 0 Enable
        constexpr uint32_t CLR_T_EN_1 = (1U << 1);  ///< Clear Timer 1 Enable
        constexpr uint32_t CLR_T_EN_2 = (1U << 2);  ///< Clear Timer 2 Enable
        constexpr uint32_t CLR_T_EN_3 = (1U << 3);  ///< Clear Timer 3 Enable
    }

    /// TVAL Register bits
    namespace tval_bits {
        constexpr uint32_t TMR_VAL = (32 << 0);  ///< Timer Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TMR_CUR_VAL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t T_EN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t CHAIN = (1U << 1);  ///< Chain Channel
        constexpr uint32_t MODE = (2 << 2);  ///< Timer Operation Mode
        constexpr uint32_t TSOT = (1U << 16);  ///< Timer Start On Trigger
        constexpr uint32_t TSOI = (1U << 17);  ///< Timer Stop On Interrupt
        constexpr uint32_t TROT = (1U << 18);  ///< Timer Reload On Trigger
        constexpr uint32_t TRG_SRC = (1U << 23);  ///< Trigger Source
        constexpr uint32_t TRG_SEL = (4 << 24);  ///< Trigger Select
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
        volatile uint32_t MOD_MIRROR;  ///< Offset: 0x200 - Modulo
        volatile uint32_t CV_MIRROR;  ///< Offset: 0x204 - Channel (n) Value (renamed from CV_MIRROR)
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel (n) Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel (n) Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel (n) Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel (n) Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel (n) Input State
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

    /// MOD_MIRROR Register bits
    namespace mod_mirror_bits {
        constexpr uint32_t FRACMOD = (5 << 11);  ///< Fractional Value for MOD register
        constexpr uint32_t MOD = (16 << 16);  ///< Modulo Value
    }

    /// CV_MIRROR Register bits
    namespace cv_mirror_bits {
        constexpr uint32_t FRACVAL = (5 << 11);  ///< Fractional Value for VAL register
        constexpr uint32_t VAL = (16 << 16);  ///< Channel Value
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
        volatile uint32_t MOD_MIRROR;  ///< Offset: 0x200 - Modulo
        volatile uint32_t CV_MIRROR;  ///< Offset: 0x204 - Channel (n) Value (renamed from CV_MIRROR)
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel (n) Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel (n) Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel (n) Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel (n) Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel (n) Input State
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

    /// MOD_MIRROR Register bits
    namespace mod_mirror_bits {
        constexpr uint32_t FRACMOD = (5 << 11);  ///< Fractional Value for MOD register
        constexpr uint32_t MOD = (16 << 16);  ///< Modulo Value
    }

    /// CV_MIRROR Register bits
    namespace cv_mirror_bits {
        constexpr uint32_t FRACVAL = (5 << 11);  ///< Fractional Value for VAL register
        constexpr uint32_t VAL = (16 << 16);  ///< Channel Value
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4003A000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t CSC;  ///< Offset: 0x0C - Channel (n) Status And Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x10 - Channel (n) Value (renamed from CV)
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
        volatile uint32_t MOD_MIRROR;  ///< Offset: 0x200 - Modulo
        volatile uint32_t CV_MIRROR;  ///< Offset: 0x204 - Channel (n) Value (renamed from CV_MIRROR)
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Channel (n) Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel (n) Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel (n) Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel (n) Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel (n) Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel (n) Input State
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

    /// MOD_MIRROR Register bits
    namespace mod_mirror_bits {
        constexpr uint32_t FRACMOD = (5 << 11);  ///< Fractional Value for MOD register
        constexpr uint32_t MOD = (16 << 16);  ///< Modulo Value
    }

    /// CV_MIRROR Register bits
    namespace cv_mirror_bits {
        constexpr uint32_t FRACVAL = (5 << 11);  ///< Fractional Value for VAL register
        constexpr uint32_t VAL = (16 << 16);  ///< Channel Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t CPS = (1U << 5);  ///< Clock Pin Select
        constexpr uint32_t LPOS = (1U << 7);  ///< LPO Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t CPE = (2 << 24);  ///< Clock Pin Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
        constexpr uint32_t TSIC = (3 << 16);  ///< Timer Seconds Interrupt Configuration
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40048000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t CHIPCTL;  ///< Offset: 0x04 - Chip Control register
        volatile uint32_t FTMOPT0;  ///< Offset: 0x0C - FTM Option Register 0
        volatile uint32_t ADCOPT;  ///< Offset: 0x18 - ADC Options Register
        volatile uint32_t FTMOPT1;  ///< Offset: 0x1C - FTM Option Register 1
        volatile uint32_t SDID;  ///< Offset: 0x24 - System Device Identification Register
        volatile uint32_t FCFG1;  ///< Offset: 0x4C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x50 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x54 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x58 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x5C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x60 - Unique Identification Register Low
        volatile uint32_t MISCTRL;  ///< Offset: 0x6C - Miscellaneous Control register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// CHIPCTL Register bits
    namespace chipctl_bits {
        constexpr uint32_t ADC_INTERLEAVE_EN = (2 << 0);  ///< ADC interleave channel enable
        constexpr uint32_t CLKOUTDIV = (2 << 4);  ///< CLKOUT divider ratio
        constexpr uint32_t CLKOUTSEL = (2 << 6);  ///< CLKOUT Select
        constexpr uint32_t PDB_BB_SEL = (1U << 13);  ///< PDB back-to-back select
        constexpr uint32_t PWTCLKSEL = (2 << 16);  ///< PWT clock source select
        constexpr uint32_t RTC32KCLKSEL = (2 << 18);  ///< RTC 32K clock input select
    }

    /// FTMOPT0 Register bits
    namespace ftmopt0_bits {
        constexpr uint32_t FTM0FLTxSEL = (3 << 0);  ///< FTM0 Fault x Select
        constexpr uint32_t FTM0CLKSEL = (2 << 24);  ///< FTM0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (2 << 26);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (2 << 28);  ///< FTM2 External Clock Pin Select
    }

    /// ADCOPT Register bits
    namespace adcopt_bits {
        constexpr uint32_t ADC0TRGSEL = (1U << 0);  ///< ADC0 trigger source select
        constexpr uint32_t ADC0SWPRETRG = (2 << 1);  ///< ADC0 software pre-trigger sources
        constexpr uint32_t ADC0PRETRGSEL = (2 << 4);  ///< ADC0 pre-trigger source select
        constexpr uint32_t ADC1TRGSEL = (1U << 8);  ///< ADC1 trigger source select
        constexpr uint32_t ADC1SWPRETRG = (2 << 9);  ///< ADC1 software pre-trigger sources
        constexpr uint32_t ADC1PRETRGSEL = (2 << 12);  ///< ADC1 pre-trigger source select
    }

    /// FTMOPT1 Register bits
    namespace ftmopt1_bits {
        constexpr uint32_t FTM0SYNCBIT = (1U << 0);  ///< FTM0 Sync Bit
        constexpr uint32_t FTM1SYNCBIT = (1U << 1);  ///< FTM1 Sync Bit
        constexpr uint32_t FTM2SYNCBIT = (1U << 2);  ///< FTM2 Sync Bit
        constexpr uint32_t FTM1CH0SEL = (2 << 4);  ///< FTM1 CH0 Select
        constexpr uint32_t FTM2CH0SEL = (2 << 6);  ///< FTM2 CH0 Select
        constexpr uint32_t FTM2CH1SEL = (1U << 8);  ///< FTM2 CH1 Select
        constexpr uint32_t FTM0_OUTSEL = (8 << 16);  ///< FTM0 channel modulation select with FTM1_CH1
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (7 << 0);  ///< Pin identification
        constexpr uint32_t PROJECTID = (5 << 7);  ///< Project ID
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
        constexpr uint32_t RAMSIZE = (4 << 16);  ///< RAM size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis E-series Sub-Family ID
        constexpr uint32_t FAMILYID = (4 << 28);  ///< Kinetis E-series Family ID
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t DEPART = (4 << 12);  ///< FlexNVM partition
        constexpr uint32_t EEERAMSIZE = (4 << 16);  ///< EEE SRAM SIZE
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID127_96 = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID95_64 = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID63_32 = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID31_0 = (32 << 0);  ///< Unique Identification
    }

    /// MISCTRL Register bits
    namespace misctrl_bits {
        constexpr uint32_t SW_TRG = (1U << 0);  ///< Software Trigger bit to TRGMUX
        constexpr uint32_t DMA_INT_SEL = (4 << 4);  ///< DMA channel interrupt OR select
        constexpr uint32_t UART0ODE = (1U << 16);  ///< UART0 Open Drain Enable
        constexpr uint32_t UART1ODE = (1U << 17);  ///< UART1 Open Drain Enable
        constexpr uint32_t UART2ODE = (1U << 18);  ///< UART2 Open Drain Enable
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT_ = (1U << 6);  ///< Watchdog Interrupt (renamed from INT_)
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t RCS = (1U << 10);  ///< Reconfiguration Success
        constexpr uint32_t ULK = (1U << 11);  ///< Unlock status
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog prescaler
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (or 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// PWT Peripheral
// ============================================================================

namespace pwt {
    /// Base addresses
    constexpr uint32_t PWT_BASE = 0x40056000;

    /// PWT Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Pulse Width Timer Control and Status Register
        volatile uint32_t CR;  ///< Offset: 0x01 - Pulse Width Timer Control Register
        volatile uint32_t PPH;  ///< Offset: 0x02 - Pulse Width Timer Positive Pulse Width Register: High
        volatile uint32_t PPL;  ///< Offset: 0x03 - Pulse Width Timer Positive Pulse Width Register: Loq
        volatile uint32_t NPH;  ///< Offset: 0x04 - Pulse Width Timer Negative Pulse Width Register: High
        volatile uint32_t NPL;  ///< Offset: 0x05 - Pulse Width Timer Negative Pulse Width Register: Low
        volatile uint32_t CNTH;  ///< Offset: 0x06 - Pulse Width Timer Counter Register: High
        volatile uint32_t CNTL;  ///< Offset: 0x07 - Pulse Width Timer Counter Register: Low
    };

    /// Peripheral instances
    inline Registers* PWT = reinterpret_cast<Registers*>(PWT_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t PWTOV = (1U << 0);  ///< PWT Counter Overflow
        constexpr uint32_t PWTRDY = (1U << 1);  ///< PWT Pulse Width Valid
        constexpr uint32_t FCTLE = (1U << 2);  ///< First counter load enable after enable
        constexpr uint32_t PWTSR = (1U << 3);  ///< PWT Soft Reset
        constexpr uint32_t POVIE = (1U << 4);  ///< PWT Counter Overflow Interrupt Enable
        constexpr uint32_t PRDYIE = (1U << 5);  ///< PWT Pulse Width Data Ready Interrupt Enable
        constexpr uint32_t PWTIE = (1U << 6);  ///< PWT Module Interrupt Enable
        constexpr uint32_t PWTEN = (1U << 7);  ///< PWT Module Enable
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PRE = (3 << 0);  ///< PWT Clock Prescaler (CLKPRE) Setting
        constexpr uint32_t LVL = (1U << 3);  ///< PWTIN Level when Overflows
        constexpr uint32_t TGL = (1U << 4);  ///< PWTIN states Toggled from last state
        constexpr uint32_t PINSEL = (2 << 5);  ///< PWT Pulse Inputs Selection
        constexpr uint32_t PCLKS = (1U << 7);  ///< PWT Clock Source Selection
    }

    /// PPH Register bits
    namespace pph_bits {
        constexpr uint32_t PPWH = (8 << 0);  ///< Positive Pulse Width[15:8]
    }

    /// PPL Register bits
    namespace ppl_bits {
        constexpr uint32_t PPWL = (8 << 0);  ///< Positive Pulse Width[7:0]
    }

    /// NPH Register bits
    namespace nph_bits {
        constexpr uint32_t NPWH = (8 << 0);  ///< Negative Pulse Width[15:8]
    }

    /// NPL Register bits
    namespace npl_bits {
        constexpr uint32_t NPWL = (8 << 0);  ///< Negative Pulse Width[7:0]
    }

    /// CNTH Register bits
    namespace cnth_bits {
        constexpr uint32_t PWTH = (8 << 0);  ///< PWT counter[15:8]
    }

    /// CNTL Register bits
    namespace cntl_bits {
        constexpr uint32_t PWTL = (8 << 0);  ///< PWT counter[7:0]
    }

}

// ============================================================================
// FLEXIO Peripheral
// ============================================================================

namespace flexio {
    /// Base addresses
    constexpr uint32_t FLEXIO_BASE = 0x4005A000;

    /// FLEXIO Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL;  ///< Offset: 0x80 - Shifter Control N Register (renamed from SHIFTCTL)
        volatile uint32_t SHIFTCFG;  ///< Offset: 0x100 - Shifter Configuration N Register (renamed from SHIFTCFG)
        volatile uint32_t SHIFTBUF;  ///< Offset: 0x200 - Shifter Buffer N Register (renamed from SHIFTBUF)
        volatile uint32_t SHIFTBUFBIS;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register (renamed from SHIFTBUFBIS)
        volatile uint32_t SHIFTBUFBYS;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register (renamed from SHIFTBUFBYS)
        volatile uint32_t SHIFTBUFBBS;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register (renamed from SHIFTBUFBBS)
        volatile uint32_t TIMCTL;  ///< Offset: 0x400 - Timer Control N Register (renamed from TIMCTL)
        volatile uint32_t TIMCFG;  ///< Offset: 0x480 - Timer Configuration N Register (renamed from TIMCFG)
        volatile uint32_t TIMCMP;  ///< Offset: 0x500 - Timer Compare N Register (renamed from TIMCMP)
    };

    /// Peripheral instances
    inline Registers* FLEXIO = reinterpret_cast<Registers*>(FLEXIO_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (8 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (4 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (4 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (4 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (4 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (4 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (4 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (4 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL Register bits
    namespace shiftctl_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (2 << 24);  ///< Timer Select
    }

    /// SHIFTCFG Register bits
    namespace shiftcfg_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
    }

    /// SHIFTBUF Register bits
    namespace shiftbuf_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS Register bits
    namespace shiftbufbis_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS Register bits
    namespace shiftbufbys_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS Register bits
    namespace shiftbufbbs_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL Register bits
    namespace timctl_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (4 << 24);  ///< Trigger Select
    }

    /// TIMCFG Register bits
    namespace timcfg_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP Register bits
    namespace timcmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

}

// ============================================================================
// OSC32 Peripheral
// ============================================================================

namespace osc32 {
    /// Base addresses
    constexpr uint32_t OSC32_BASE = 0x40060000;

    /// OSC32 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RTC Oscillator Control Register
    };

    /// Peripheral instances
    inline Registers* OSC32 = reinterpret_cast<Registers*>(OSC32_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ROSCEREFS = (1U << 4);  ///< RTC 32k Oscillator external reference clcok selection
        constexpr uint32_t ROSCSTB = (1U << 5);  ///< RTC 32k Oscillator stable flag
        constexpr uint32_t ROSCSTPEN = (1U << 6);  ///< RTC 32k Oscillator stop mode enable
        constexpr uint32_t ROSCEN = (1U << 7);  ///< RTC 32k Oscillator enable
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM refresh mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum refresh time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum refresh time is required
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power clock source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// TRGMUX0 Peripheral
// ============================================================================

namespace trgmux0 {
    /// Base addresses
    constexpr uint32_t TRGMUX0_BASE = 0x40062000;

    /// TRGMUX0 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_DMAMUX0;  ///< Offset: 0x00 - TRGMUX Register
        volatile uint32_t TRGMUX_EXTOUT0;  ///< Offset: 0x04 - TRGMUX Register
        volatile uint32_t TRGMUX_EXTOUT1;  ///< Offset: 0x08 - TRGMUX Register
        volatile uint32_t TRGMUX_ADC0;  ///< Offset: 0x0C - TRGMUX Register
        volatile uint32_t TRGMUX_ADC1;  ///< Offset: 0x10 - TRGMUX Register
        volatile uint32_t TRGMUX_CMP0;  ///< Offset: 0x1C - TRGMUX Register
        volatile uint32_t TRGMUX_CMP1;  ///< Offset: 0x20 - TRGMUX Register
        volatile uint32_t TRGMUX_FTM0;  ///< Offset: 0x28 - TRGMUX Register
        volatile uint32_t TRGMUX_FTM1;  ///< Offset: 0x2C - TRGMUX Register
        volatile uint32_t TRGMUX_FTM2;  ///< Offset: 0x30 - TRGMUX Register
        volatile uint32_t TRGMUX_PDB0;  ///< Offset: 0x38 - TRGMUX Register
        volatile uint32_t TRGMUX_FLEXIO;  ///< Offset: 0x44 - TRGMUX Register
        volatile uint32_t TRGMUX_LPIT0;  ///< Offset: 0x48 - TRGMUX Register
        volatile uint32_t TRGMUX_LPUART0;  ///< Offset: 0x4C - TRGMUX Register
        volatile uint32_t TRGMUX_LPUART1;  ///< Offset: 0x50 - TRGMUX Register
        volatile uint32_t TRGMUX_LPI2C0;  ///< Offset: 0x54 - TRGMUX Register
        volatile uint32_t TRGMUX_LPI2C1;  ///< Offset: 0x58 - TRGMUX Register
        volatile uint32_t TRGMUX_LPSPI0;  ///< Offset: 0x5C - TRGMUX Register
        volatile uint32_t TRGMUX_LPSPI1;  ///< Offset: 0x60 - TRGMUX Register
        volatile uint32_t TRGMUX_LPTMR0;  ///< Offset: 0x64 - TRGMUX Register
        volatile uint32_t TRGMUX_PWT;  ///< Offset: 0x6C - TRGMUX Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX0 = reinterpret_cast<Registers*>(TRGMUX0_BASE);

    // Bit definitions
    /// TRGMUX_DMAMUX0 Register bits
    namespace trgmux_dmamux0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_EXTOUT0 Register bits
    namespace trgmux_extout0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_EXTOUT1 Register bits
    namespace trgmux_extout1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC0 Register bits
    namespace trgmux_adc0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC1 Register bits
    namespace trgmux_adc1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP0 Register bits
    namespace trgmux_cmp0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP1 Register bits
    namespace trgmux_cmp1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM0 Register bits
    namespace trgmux_ftm0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM1 Register bits
    namespace trgmux_ftm1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM2 Register bits
    namespace trgmux_ftm2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PDB0 Register bits
    namespace trgmux_pdb0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FLEXIO Register bits
    namespace trgmux_flexio_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPIT0 Register bits
    namespace trgmux_lpit0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART0 Register bits
    namespace trgmux_lpuart0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART1 Register bits
    namespace trgmux_lpuart1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C0 Register bits
    namespace trgmux_lpi2c0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C1 Register bits
    namespace trgmux_lpi2c1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI0 Register bits
    namespace trgmux_lpspi0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI1 Register bits
    namespace trgmux_lpspi1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPTMR0 Register bits
    namespace trgmux_lptmr0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PWT Register bits
    namespace trgmux_pwt_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// TRGMUX1 Peripheral
// ============================================================================

namespace trgmux1 {
    /// Base addresses
    constexpr uint32_t TRGMUX1_BASE = 0x40063000;

    /// TRGMUX1 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_CTRL0;  ///< Offset: 0x00 - TRGMUX Register
        volatile uint32_t TRGMUX_CTRL1;  ///< Offset: 0x04 - TRGMUX Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX1 = reinterpret_cast<Registers*>(TRGMUX1_BASE);

    // Bit definitions
    /// TRGMUX_CTRL0 Register bits
    namespace trgmux_ctrl0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CTRL1 Register bits
    namespace trgmux_ctrl1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// SCG Peripheral
// ============================================================================

namespace scg {
    /// Base addresses
    constexpr uint32_t SCG_BASE = 0x40064000;

    /// SCG Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CSR;  ///< Offset: 0x10 - Clock Status Register
        volatile uint32_t RCCR;  ///< Offset: 0x14 - Run Clock Control Register
        volatile uint32_t VCCR;  ///< Offset: 0x18 - VLPR Clock Control Register
        volatile uint32_t CLKOUTCNFG;  ///< Offset: 0x20 - SCG CLKOUT Configuration Register
        volatile uint32_t SOSCCSR;  ///< Offset: 0x100 - System OSC Control Status Register
        volatile uint32_t SOSCDIV;  ///< Offset: 0x104 - System OSC Divide Register
        volatile uint32_t SOSCCFG;  ///< Offset: 0x108 - System Oscillator Configuration Register
        volatile uint32_t SIRCCSR;  ///< Offset: 0x200 - Slow IRC Control Status Register
        volatile uint32_t SIRCDIV;  ///< Offset: 0x204 - Slow IRC Divide Register
        volatile uint32_t SIRCCFG;  ///< Offset: 0x208 - Slow IRC Configuration Register
        volatile uint32_t FIRCCSR;  ///< Offset: 0x300 - Fast IRC Control Status Register
        volatile uint32_t FIRCDIV;  ///< Offset: 0x304 - Fast IRC Divide Register
        volatile uint32_t FIRCCFG;  ///< Offset: 0x308 - Fast IRC Configuration Register
        volatile uint32_t FIRCTCFG;  ///< Offset: 0x30C - Fast IRC Trim Configuration Register
        volatile uint32_t FIRCSTAT;  ///< Offset: 0x318 - Fast IRC Status Register
        volatile uint32_t ROSCCSR;  ///< Offset: 0x400 - RTC OSC Control Status Register
        volatile uint32_t LPFLLCSR;  ///< Offset: 0x500 - Low Power FLL Control Status Register
        volatile uint32_t LPFLLDIV;  ///< Offset: 0x504 - Low Power FLL Divide Register
        volatile uint32_t LPFLLCFG;  ///< Offset: 0x508 - Low Power FLL Configuration Register
        volatile uint32_t LPFLLTCFG;  ///< Offset: 0x50C - Low Power FLL Trim Configuration Register
        volatile uint32_t LPFLLSTAT;  ///< Offset: 0x514 - Low Power FLL Status Register
    };

    /// Peripheral instances
    inline Registers* SCG = reinterpret_cast<Registers*>(SCG_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSION = (32 << 0);  ///< SCG Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CLKPRES = (8 << 0);  ///< Clock Present
        constexpr uint32_t DIVPRES = (5 << 27);  ///< Divider Present
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// VCCR Register bits
    namespace vccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// CLKOUTCNFG Register bits
    namespace clkoutcnfg_bits {
        constexpr uint32_t CLKOUTSEL = (4 << 24);  ///< SCG Clkout Select
    }

    /// SOSCCSR Register bits
    namespace sosccsr_bits {
        constexpr uint32_t SOSCEN = (1U << 0);  ///< System OSC Enable
        constexpr uint32_t SOSCSTEN = (1U << 1);  ///< System OSC Stop Enable
        constexpr uint32_t SOSCLPEN = (1U << 2);  ///< System OSC Low Power Enable
        constexpr uint32_t SOSCERCLKEN = (1U << 3);  ///< System OSC 3V ERCLK Enable
        constexpr uint32_t SOSCCM = (1U << 16);  ///< System OSC Clock Monitor
        constexpr uint32_t SOSCCMRE = (1U << 17);  ///< System OSC Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SOSCVLD = (1U << 24);  ///< System OSC Valid
        constexpr uint32_t SOSCSEL = (1U << 25);  ///< System OSC Selected
        constexpr uint32_t SOSCERR = (1U << 26);  ///< System OSC Clock Error
    }

    /// SOSCDIV Register bits
    namespace soscdiv_bits {
        constexpr uint32_t SOSCDIV1 = (3 << 0);  ///< System OSC Clock Divide 1
        constexpr uint32_t SOSCDIV2 = (3 << 8);  ///< System OSC Clock Divide 2
    }

    /// SOSCCFG Register bits
    namespace sosccfg_bits {
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< System OSC Range Select
    }

    /// SIRCCSR Register bits
    namespace sirccsr_bits {
        constexpr uint32_t SIRCEN = (1U << 0);  ///< Slow IRC Enable
        constexpr uint32_t SIRCSTEN = (1U << 1);  ///< Slow IRC Stop Enable
        constexpr uint32_t SIRCLPEN = (1U << 2);  ///< Slow IRC Low Power Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SIRCVLD = (1U << 24);  ///< Slow IRC Valid
        constexpr uint32_t SIRCSEL = (1U << 25);  ///< Slow IRC Selected
    }

    /// SIRCDIV Register bits
    namespace sircdiv_bits {
        constexpr uint32_t SIRCDIV1 = (3 << 0);  ///< Slow IRC Clock Divide 1
        constexpr uint32_t SIRCDIV2 = (3 << 8);  ///< Slow IRC Clock Divide 2
    }

    /// SIRCCFG Register bits
    namespace sirccfg_bits {
        constexpr uint32_t RANGE = (1U << 0);  ///< Frequency Range
    }

    /// FIRCCSR Register bits
    namespace firccsr_bits {
        constexpr uint32_t FIRCEN = (1U << 0);  ///< Fast IRC Enable
        constexpr uint32_t FIRCSTEN = (1U << 1);  ///< Fast IRC Stop Enable
        constexpr uint32_t FIRCLPEN = (1U << 2);  ///< Fast IRC Low Power Enable
        constexpr uint32_t FIRCREGOFF = (1U << 3);  ///< Fast IRC Regulator Enable
        constexpr uint32_t FIRCTREN = (1U << 8);  ///< Fast IRC Trim Enable
        constexpr uint32_t FIRCTRUP = (1U << 9);  ///< Fast IRC Trim Update
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t FIRCVLD = (1U << 24);  ///< Fast IRC Valid status
        constexpr uint32_t FIRCSEL = (1U << 25);  ///< Fast IRC Selected status
        constexpr uint32_t FIRCERR = (1U << 26);  ///< Fast IRC Clock Error
    }

    /// FIRCDIV Register bits
    namespace fircdiv_bits {
        constexpr uint32_t FIRCDIV1 = (3 << 0);  ///< Fast IRC Clock Divide 1
        constexpr uint32_t FIRCDIV2 = (3 << 8);  ///< Fast IRC Clock Divide 2
    }

    /// FIRCCFG Register bits
    namespace firccfg_bits {
        constexpr uint32_t RANGE = (2 << 0);  ///< Frequency Range
    }

    /// FIRCTCFG Register bits
    namespace firctcfg_bits {
        constexpr uint32_t TRIMSRC = (2 << 0);  ///< Trim Source
        constexpr uint32_t TRIMDIV = (3 << 8);  ///< Fast IRC Trim Predivide
    }

    /// FIRCSTAT Register bits
    namespace fircstat_bits {
        constexpr uint32_t TRIMFINE = (7 << 0);  ///< Trim Fine Status
        constexpr uint32_t TRIMCOAR = (6 << 8);  ///< Trim Coarse
    }

    /// ROSCCSR Register bits
    namespace rosccsr_bits {
        constexpr uint32_t ROSCCM = (1U << 16);  ///< RTC OSC Clock Monitor
        constexpr uint32_t ROSCCMRE = (1U << 17);  ///< RTC OSC Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t ROSCVLD = (1U << 24);  ///< RTC OSC Valid
        constexpr uint32_t ROSCERR = (1U << 26);  ///< RTC OSC Clock Error
    }

    /// LPFLLCSR Register bits
    namespace lpfllcsr_bits {
        constexpr uint32_t LPFLLEN = (1U << 0);  ///< LPFLL Enable
        constexpr uint32_t LPFLLTREN = (1U << 8);  ///< LPFLL Trim Enable
        constexpr uint32_t LPFLLTRUP = (1U << 9);  ///< LPFLL Trim Update
        constexpr uint32_t LPFLLTRMLOCK = (1U << 10);  ///< LPFLL Trim LOCK
        constexpr uint32_t LPFLLCM = (1U << 16);  ///< LPFLL Clock Monitor
        constexpr uint32_t LPFLLCMRE = (1U << 17);  ///< LPFLL Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t LPFLLVLD = (1U << 24);  ///< LPFLL Valid
        constexpr uint32_t LPFLLSEL = (1U << 25);  ///< LPFLL Selected
        constexpr uint32_t LPFLLERR = (1U << 26);  ///< LPFLL Clock Error
    }

    /// LPFLLDIV Register bits
    namespace lpflldiv_bits {
        constexpr uint32_t LPFLLDIV1 = (3 << 0);  ///< LPFLL Clock Divide 1
        constexpr uint32_t LPFLLDIV2 = (3 << 8);  ///< LPFLL Clock Divide 2
    }

    /// LPFLLCFG Register bits
    namespace lpfllcfg_bits {
        constexpr uint32_t FSEL = (2 << 0);  ///< Frequency Select
    }

    /// LPFLLTCFG Register bits
    namespace lpflltcfg_bits {
        constexpr uint32_t TRIMSRC = (2 << 0);  ///< Trim Source
        constexpr uint32_t TRIMDIV = (5 << 8);  ///< LPFLL Trim Predivide
        constexpr uint32_t LOCKW2LSB = (1U << 16);  ///< Lock LPFLL with 2 LSBS
    }

    /// LPFLLSTAT Register bits
    namespace lpfllstat_bits {
        constexpr uint32_t AUTOTRIM = (8 << 0);  ///< Auto Tune Trim Status
    }

}

// ============================================================================
// PCC Peripheral
// ============================================================================

namespace pcc {
    /// Base addresses
    constexpr uint32_t PCC_BASE = 0x40065000;

    /// PCC Register structure
    struct Registers {
        volatile uint32_t PCC_DMA0;  ///< Offset: 0x20 - PCC Register
        volatile uint32_t PCC_FLASH;  ///< Offset: 0x80 - PCC Register
        volatile uint32_t PCC_DMAMUX0;  ///< Offset: 0x84 - PCC Register
        volatile uint32_t PCC_ADC1;  ///< Offset: 0x9C - PCC Register
        volatile uint32_t PCC_LPSPI0;  ///< Offset: 0xB0 - PCC Register
        volatile uint32_t PCC_LPSPI1;  ///< Offset: 0xB4 - PCC Register
        volatile uint32_t PCC_CRC;  ///< Offset: 0xC8 - PCC Register
        volatile uint32_t PCC_PDB0;  ///< Offset: 0xD8 - PCC Register
        volatile uint32_t PCC_LPIT0;  ///< Offset: 0xDC - PCC Register
        volatile uint32_t PCC_FLEXTMR0;  ///< Offset: 0xE0 - PCC Register
        volatile uint32_t PCC_FLEXTMR1;  ///< Offset: 0xE4 - PCC Register
        volatile uint32_t PCC_FLEXTMR2;  ///< Offset: 0xE8 - PCC Register
        volatile uint32_t PCC_ADC0;  ///< Offset: 0xEC - PCC Register
        volatile uint32_t PCC_RTC;  ///< Offset: 0xF4 - PCC Register
        volatile uint32_t PCC_LPTMR0;  ///< Offset: 0x100 - PCC Register
        volatile uint32_t PCC_PORTA;  ///< Offset: 0x124 - PCC Register
        volatile uint32_t PCC_PORTB;  ///< Offset: 0x128 - PCC Register
        volatile uint32_t PCC_PORTC;  ///< Offset: 0x12C - PCC Register
        volatile uint32_t PCC_PORTD;  ///< Offset: 0x130 - PCC Register
        volatile uint32_t PCC_PORTE;  ///< Offset: 0x134 - PCC Register
        volatile uint32_t PCC_PWT;  ///< Offset: 0x158 - PCC Register
        volatile uint32_t PCC_FLEXIO;  ///< Offset: 0x168 - PCC Register
        volatile uint32_t PCC_OSC32;  ///< Offset: 0x180 - PCC Register
        volatile uint32_t PCC_EWM;  ///< Offset: 0x184 - PCC Register
        volatile uint32_t PCC_LPI2C0;  ///< Offset: 0x198 - PCC Register
        volatile uint32_t PCC_LPI2C1;  ///< Offset: 0x19C - PCC Register
        volatile uint32_t PCC_LPUART0;  ///< Offset: 0x1A8 - PCC Register
        volatile uint32_t PCC_LPUART1;  ///< Offset: 0x1AC - PCC Register
        volatile uint32_t PCC_LPUART2;  ///< Offset: 0x1B0 - PCC Register
        volatile uint32_t PCC_CMP0;  ///< Offset: 0x1CC - PCC Register
        volatile uint32_t PCC_CMP1;  ///< Offset: 0x1D0 - PCC Register
    };

    /// Peripheral instances
    inline Registers* PCC = reinterpret_cast<Registers*>(PCC_BASE);

    // Bit definitions
    /// PCC_DMA0 Register bits
    namespace pcc_dma0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLASH Register bits
    namespace pcc_flash_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_DMAMUX0 Register bits
    namespace pcc_dmamux0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_ADC1 Register bits
    namespace pcc_adc1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPSPI0 Register bits
    namespace pcc_lpspi0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPSPI1 Register bits
    namespace pcc_lpspi1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CRC Register bits
    namespace pcc_crc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PDB0 Register bits
    namespace pcc_pdb0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPIT0 Register bits
    namespace pcc_lpit0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLEXTMR0 Register bits
    namespace pcc_flextmr0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLEXTMR1 Register bits
    namespace pcc_flextmr1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLEXTMR2 Register bits
    namespace pcc_flextmr2_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_ADC0 Register bits
    namespace pcc_adc0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_RTC Register bits
    namespace pcc_rtc_bits {
        constexpr uint32_t PCD = (3 << 0);  ///< Peripheral Clock Divider Select
        constexpr uint32_t FRAC = (1U << 3);  ///< Peripheral Clock Divider Fraction
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPTMR0 Register bits
    namespace pcc_lptmr0_bits {
        constexpr uint32_t PCD = (3 << 0);  ///< Peripheral Clock Divider Select
        constexpr uint32_t FRAC = (1U << 3);  ///< Peripheral Clock Divider Fraction
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTA Register bits
    namespace pcc_porta_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTB Register bits
    namespace pcc_portb_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTC Register bits
    namespace pcc_portc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTD Register bits
    namespace pcc_portd_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTE Register bits
    namespace pcc_porte_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PWT Register bits
    namespace pcc_pwt_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLEXIO Register bits
    namespace pcc_flexio_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_OSC32 Register bits
    namespace pcc_osc32_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_EWM Register bits
    namespace pcc_ewm_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPI2C0 Register bits
    namespace pcc_lpi2c0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPI2C1 Register bits
    namespace pcc_lpi2c1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART0 Register bits
    namespace pcc_lpuart0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART1 Register bits
    namespace pcc_lpuart1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART2 Register bits
    namespace pcc_lpuart2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CMP0 Register bits
    namespace pcc_cmp0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CMP1 Register bits
    namespace pcc_cmp1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C0_BASE = 0x40066000;
    constexpr uint32_t LPI2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x10 - Master Control Register
        volatile uint32_t MSR;  ///< Offset: 0x14 - Master Status Register
        volatile uint32_t MIER;  ///< Offset: 0x18 - Master Interrupt Enable Register
        volatile uint32_t MDER;  ///< Offset: 0x1C - Master DMA Enable Register
        volatile uint32_t MCFGR0;  ///< Offset: 0x20 - Master Configuration Register 0
        volatile uint32_t MCFGR1;  ///< Offset: 0x24 - Master Configuration Register 1
        volatile uint32_t MCFGR2;  ///< Offset: 0x28 - Master Configuration Register 2
        volatile uint32_t MCFGR3;  ///< Offset: 0x2C - Master Configuration Register 3
        volatile uint32_t MDMR;  ///< Offset: 0x40 - Master Data Match Register
        volatile uint32_t MCCR0;  ///< Offset: 0x48 - Master Clock Configuration Register 0
        volatile uint32_t MCCR1;  ///< Offset: 0x50 - Master Clock Configuration Register 1
        volatile uint32_t MFCR;  ///< Offset: 0x58 - Master FIFO Control Register
        volatile uint32_t MFSR;  ///< Offset: 0x5C - Master FIFO Status Register
        volatile uint32_t MTDR;  ///< Offset: 0x60 - Master Transmit Data Register
        volatile uint32_t MRDR;  ///< Offset: 0x70 - Master Receive Data Register
        volatile uint32_t SCR;  ///< Offset: 0x110 - Slave Control Register
        volatile uint32_t SSR;  ///< Offset: 0x114 - Slave Status Register
        volatile uint32_t SIER;  ///< Offset: 0x118 - Slave Interrupt Enable Register
        volatile uint32_t SDER;  ///< Offset: 0x11C - Slave DMA Enable Register
        volatile uint32_t SCFGR1;  ///< Offset: 0x124 - Slave Configuration Register 1
        volatile uint32_t SCFGR2;  ///< Offset: 0x128 - Slave Configuration Register 2
        volatile uint32_t SAMR;  ///< Offset: 0x140 - Slave Address Match Register
        volatile uint32_t SASR;  ///< Offset: 0x150 - Slave Address Status Register
        volatile uint32_t STAR;  ///< Offset: 0x154 - Slave Transmit ACK Register
        volatile uint32_t STDR;  ///< Offset: 0x160 - Slave Transmit Data Register
        volatile uint32_t SRDR;  ///< Offset: 0x170 - Slave Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPI2C0 = reinterpret_cast<Registers*>(LPI2C0_BASE);
    inline Registers* LPI2C1 = reinterpret_cast<Registers*>(LPI2C1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t MTXFIFO = (4 << 0);  ///< Master Transmit FIFO Size
        constexpr uint32_t MRXFIFO = (4 << 8);  ///< Master Receive FIFO Size
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Master Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t EPF = (1U << 8);  ///< End Packet Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t NDF = (1U << 10);  ///< NACK Detect Flag
        constexpr uint32_t ALF = (1U << 11);  ///< Arbitration Lost Flag
        constexpr uint32_t FEF = (1U << 12);  ///< FIFO Error Flag
        constexpr uint32_t PLTF = (1U << 13);  ///< Pin Low Timeout Flag
        constexpr uint32_t DMF = (1U << 14);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Master Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t EPIE = (1U << 8);  ///< End Packet Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t NDIE = (1U << 10);  ///< NACK Detect Interrupt Enable
        constexpr uint32_t ALIE = (1U << 11);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t FEIE = (1U << 12);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t PLTIE = (1U << 13);  ///< Pin Low Timeout Interrupt Enable
        constexpr uint32_t DMIE = (1U << 14);  ///< Data Match Interrupt Enable
    }

    /// MDER Register bits
    namespace mder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// MCFGR0 Register bits
    namespace mcfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// MCFGR1 Register bits
    namespace mcfgr1_bits {
        constexpr uint32_t PRESCALE = (3 << 0);  ///< Prescaler
        constexpr uint32_t AUTOSTOP = (1U << 8);  ///< Automatic STOP Generation
        constexpr uint32_t IGNACK = (1U << 9);  ///< When set, the received NACK field is ignored and assumed to be ACK
        constexpr uint32_t TIMECFG = (1U << 10);  ///< Timeout Configuration
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (3 << 24);  ///< Pin Configuration
    }

    /// MCFGR2 Register bits
    namespace mcfgr2_bits {
        constexpr uint32_t BUSIDLE = (12 << 0);  ///< Bus Idle Timeout
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// MCFGR3 Register bits
    namespace mcfgr3_bits {
        constexpr uint32_t PINLOW = (12 << 8);  ///< Pin Low Timeout
    }

    /// MDMR Register bits
    namespace mdmr_bits {
        constexpr uint32_t MATCH0 = (8 << 0);  ///< Match 0 Value
        constexpr uint32_t MATCH1 = (8 << 16);  ///< Match 1 Value
    }

    /// MCCR0 Register bits
    namespace mccr0_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MCCR1 Register bits
    namespace mccr1_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MFCR Register bits
    namespace mfcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// MFSR Register bits
    namespace mfsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// MTDR Register bits
    namespace mtdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
        constexpr uint32_t CMD = (3 << 8);  ///< Command Data
    }

    /// MRDR Register bits
    namespace mrdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEN = (1U << 0);  ///< Slave Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FILTEN = (1U << 4);  ///< Filter Enable
        constexpr uint32_t FILTDZ = (1U << 5);  ///< Filter Doze Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t AVF = (1U << 2);  ///< Address Valid Flag
        constexpr uint32_t TAF = (1U << 3);  ///< Transmit ACK Flag
        constexpr uint32_t RSF = (1U << 8);  ///< Repeated Start Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t BEF = (1U << 10);  ///< Bit Error Flag
        constexpr uint32_t FEF = (1U << 11);  ///< FIFO Error Flag
        constexpr uint32_t AM0F = (1U << 12);  ///< Address Match 0 Flag
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Flag
        constexpr uint32_t GCF = (1U << 14);  ///< General Call Flag
        constexpr uint32_t SARF = (1U << 15);  ///< SMBus Alert Response Flag
        constexpr uint32_t SBF = (1U << 24);  ///< Slave Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// SIER Register bits
    namespace sier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t AVIE = (1U << 2);  ///< Address Valid Interrupt Enable
        constexpr uint32_t TAIE = (1U << 3);  ///< Transmit ACK Interrupt Enable
        constexpr uint32_t RSIE = (1U << 8);  ///< Repeated Start Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t BEIE = (1U << 10);  ///< Bit Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 11);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t AM0IE = (1U << 12);  ///< Address Match 0 Interrupt Enable
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Interrupt Enable
        constexpr uint32_t GCIE = (1U << 14);  ///< General Call Interrupt Enable
        constexpr uint32_t SARIE = (1U << 15);  ///< SMBus Alert Response Interrupt Enable
    }

    /// SDER Register bits
    namespace sder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
        constexpr uint32_t AVDE = (1U << 2);  ///< Address Valid DMA Enable
    }

    /// SCFGR1 Register bits
    namespace scfgr1_bits {
        constexpr uint32_t ADRSTALL = (1U << 0);  ///< Address SCL Stall
        constexpr uint32_t RXSTALL = (1U << 1);  ///< RX SCL Stall
        constexpr uint32_t TXDSTALL = (1U << 2);  ///< TX Data SCL Stall
        constexpr uint32_t ACKSTALL = (1U << 3);  ///< ACK SCL Stall
        constexpr uint32_t GCEN = (1U << 8);  ///< General Call Enable
        constexpr uint32_t SAEN = (1U << 9);  ///< SMBus Alert Enable
        constexpr uint32_t TXCFG = (1U << 10);  ///< Transmit Flag Configuration
        constexpr uint32_t RXCFG = (1U << 11);  ///< Receive Data Configuration
        constexpr uint32_t IGNACK = (1U << 12);  ///< Ignore NACK
        constexpr uint32_t HSMEN = (1U << 13);  ///< High Speed Mode Enable
        constexpr uint32_t ADDRCFG = (3 << 16);  ///< Address Configuration
    }

    /// SCFGR2 Register bits
    namespace scfgr2_bits {
        constexpr uint32_t CLKHOLD = (4 << 0);  ///< Clock Hold Time
        constexpr uint32_t DATAVD = (6 << 8);  ///< Data Valid Delay
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// SAMR Register bits
    namespace samr_bits {
        constexpr uint32_t ADDR0 = (10 << 1);  ///< Address 0 Value
        constexpr uint32_t ADDR1 = (10 << 17);  ///< Address 1 Value
    }

    /// SASR Register bits
    namespace sasr_bits {
        constexpr uint32_t RADDR = (11 << 0);  ///< Received Address
        constexpr uint32_t ANV = (1U << 14);  ///< Address Not Valid
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t TXNACK = (1U << 0);  ///< Transmit NACK
    }

    /// STDR Register bits
    namespace stdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
    }

    /// SRDR Register bits
    namespace srdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
        constexpr uint32_t SOF = (1U << 15);  ///< Start Of Frame
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x4006A000;
    constexpr uint32_t LPUART1_BASE = 0x4006B000;
    constexpr uint32_t LPUART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - LPUART Global Register
        volatile uint32_t PINCFG;  ///< Offset: 0x0C - LPUART Pin Configuration Register
        volatile uint32_t BAUD;  ///< Offset: 0x10 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x14 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x1C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x20 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x24 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x28 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x2C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// PINCFG Register bits
    namespace pincfg_bits {
        constexpr uint32_t TRGSEL = (2 << 0);  ///< Trigger Select
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RIDMAE = (1U << 20);  ///< Receiver Idle DMA Enable
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< RXD Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t M7 = (1U << 11);  ///< 7-Bit Mode Select
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< TXD Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< R0T0
        constexpr uint32_t R1T1 = (1U << 1);  ///< R1T1
        constexpr uint32_t R2T2 = (1U << 2);  ///< R2T2
        constexpr uint32_t R3T3 = (1U << 3);  ///< R3T3
        constexpr uint32_t R4T4 = (1U << 4);  ///< R4T4
        constexpr uint32_t R5T5 = (1U << 5);  ///< R5T5
        constexpr uint32_t R6T6 = (1U << 6);  ///< R6T6
        constexpr uint32_t R7T7 = (1U << 7);  ///< R7T7
        constexpr uint32_t R8T8 = (1U << 8);  ///< R8T8
        constexpr uint32_t R9T9 = (1U << 9);  ///< R9T9
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< PARITYE
        constexpr uint32_t NOISY = (1U << 15);  ///< NOISY
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (8 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (8 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (8 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t C0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x04 - CMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x08 - CMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control. See chip data sheet to get the actual hystersis value with each level
        constexpr uint32_t OFFSET = (1U << 2);  ///< Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
        constexpr uint32_t EN = (1U << 8);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 9);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 10);  ///< Comparator Output Select
        constexpr uint32_t INVT = (1U << 11);  ///< Comparator invert
        constexpr uint32_t PMODE = (1U << 12);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 14);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 15);  ///< Sample Enable
        constexpr uint32_t FPR = (8 << 16);  ///< Filter Sample Period
        constexpr uint32_t COUT = (1U << 24);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 25);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 26);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 27);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 28);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t VOSEL = (8 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t MSEL = (3 << 8);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 11);  ///< Plus Input MUX Control
        constexpr uint32_t VRSEL = (1U << 14);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t CHN0 = (1U << 16);  ///< Channel 0 input enable
        constexpr uint32_t CHN1 = (1U << 17);  ///< Channel 1 input enable
        constexpr uint32_t CHN2 = (1U << 18);  ///< Channel 2 input enable
        constexpr uint32_t CHN3 = (1U << 19);  ///< Channel 3 input enable
        constexpr uint32_t CHN4 = (1U << 20);  ///< Channel 4 input enable
        constexpr uint32_t CHN5 = (1U << 21);  ///< Channel 5 input enable
        constexpr uint32_t CHN6 = (1U << 22);  ///< Channel 6 input enable
        constexpr uint32_t CHN7 = (1U << 23);  ///< Channel 7 input enable
        constexpr uint32_t INNSEL = (2 << 24);  ///< Selection of the input to the negative port of the comparator
        constexpr uint32_t INPSEL = (2 << 27);  ///< Selection of the input to the positive port of the comparator
        constexpr uint32_t DACOE = (1U << 29);  ///< DAC output Enable
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACOn = (8 << 0);  ///< The result of the input comparison for channel n
        constexpr uint32_t INITMOD = (6 << 8);  ///< Comparator and DAC initialization delay modulus.
        constexpr uint32_t NSAM = (2 << 14);  ///< Number of sample clocks
        constexpr uint32_t CH0F = (1U << 16);  ///< Channel 0 input changed flag
        constexpr uint32_t CH1F = (1U << 17);  ///< Channel 1 input changed flag
        constexpr uint32_t CH2F = (1U << 18);  ///< Channel 2 input changed flag
        constexpr uint32_t CH3F = (1U << 19);  ///< Channel 3 input changed flag
        constexpr uint32_t CH4F = (1U << 20);  ///< Channel 4 input changed flag
        constexpr uint32_t CH5F = (1U << 21);  ///< Channel 5 input changed flag
        constexpr uint32_t CH6F = (1U << 22);  ///< Channel 6 input changed flag
        constexpr uint32_t CH7F = (1U << 23);  ///< Channel 7 input changed flag
        constexpr uint32_t FXMXCH = (3 << 25);  ///< Fixed channel selection
        constexpr uint32_t FXMP = (1U << 29);  ///< Fixed MUX Port
        constexpr uint32_t RRIE = (1U << 30);  ///< Round-Robin interrupt enable
        constexpr uint32_t RRE = (1U << 31);  ///< Round-Robin Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40074000;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t C0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x04 - CMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x08 - CMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control. See chip data sheet to get the actual hystersis value with each level
        constexpr uint32_t OFFSET = (1U << 2);  ///< Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
        constexpr uint32_t EN = (1U << 8);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 9);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 10);  ///< Comparator Output Select
        constexpr uint32_t INVT = (1U << 11);  ///< Comparator invert
        constexpr uint32_t PMODE = (1U << 12);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 14);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 15);  ///< Sample Enable
        constexpr uint32_t FPR = (8 << 16);  ///< Filter Sample Period
        constexpr uint32_t COUT = (1U << 24);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 25);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 26);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 27);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 28);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t VOSEL = (8 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t MSEL = (3 << 8);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 11);  ///< Plus Input MUX Control
        constexpr uint32_t VRSEL = (1U << 14);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t CHN0 = (1U << 16);  ///< Channel 0 input enable
        constexpr uint32_t CHN1 = (1U << 17);  ///< Channel 1 input enable
        constexpr uint32_t CHN2 = (1U << 18);  ///< Channel 2 input enable
        constexpr uint32_t CHN3 = (1U << 19);  ///< Channel 3 input enable
        constexpr uint32_t CHN4 = (1U << 20);  ///< Channel 4 input enable
        constexpr uint32_t CHN5 = (1U << 21);  ///< Channel 5 input enable
        constexpr uint32_t CHN6 = (1U << 22);  ///< Channel 6 input enable
        constexpr uint32_t CHN7 = (1U << 23);  ///< Channel 7 input enable
        constexpr uint32_t INNSEL = (2 << 24);  ///< Selection of the input to the negative port of the comparator
        constexpr uint32_t INPSEL = (2 << 27);  ///< Selection of the input to the positive port of the comparator
        constexpr uint32_t DACOE = (1U << 29);  ///< DAC output Enable
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACOn = (8 << 0);  ///< The result of the input comparison for channel n
        constexpr uint32_t INITMOD = (6 << 8);  ///< Comparator and DAC initialization delay modulus.
        constexpr uint32_t NSAM = (2 << 14);  ///< Number of sample clocks
        constexpr uint32_t CH0F = (1U << 16);  ///< Channel 0 input changed flag
        constexpr uint32_t CH1F = (1U << 17);  ///< Channel 1 input changed flag
        constexpr uint32_t CH2F = (1U << 18);  ///< Channel 2 input changed flag
        constexpr uint32_t CH3F = (1U << 19);  ///< Channel 3 input changed flag
        constexpr uint32_t CH4F = (1U << 20);  ///< Channel 4 input changed flag
        constexpr uint32_t CH5F = (1U << 21);  ///< Channel 5 input changed flag
        constexpr uint32_t CH6F = (1U << 22);  ///< Channel 6 input changed flag
        constexpr uint32_t CH7F = (1U << 23);  ///< Channel 7 input changed flag
        constexpr uint32_t FXMXCH = (3 << 25);  ///< Fixed channel selection
        constexpr uint32_t FXMP = (1U << 29);  ///< Fixed MUX Port
        constexpr uint32_t RRIE = (1U << 30);  ///< Round-Robin interrupt enable
        constexpr uint32_t RRE = (1U << 31);  ///< Round-Robin Enable
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status and Control 1 Register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status and Control 2 Register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status and Control Register
        volatile uint32_t LPOTRIM;  ///< Offset: 0x04 - Low Power Oscillator Trim Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BIASEN = (1U << 0);  ///< Bias Enable Bit
        constexpr uint32_t REGFPM = (1U << 2);  ///< Regulator in Full Performance Mode Status Bit
        constexpr uint32_t LPOSTAT = (1U << 6);  ///< LPO Status Bit
        constexpr uint32_t LPODIS = (1U << 7);  ///< LPO Disable Bit
    }

    /// LPOTRIM Register bits
    namespace lpotrim_bits {
        constexpr uint32_t LPOTRIM = (5 << 0);  ///< LPO trimming bits
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - SMC Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - SMC Parameter Register
        volatile uint32_t PMPROT;  ///< Offset: 0x08 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x0C - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x10 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x14 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t EHSRUN = (1U << 0);  ///< HSRUN feature exists
        constexpr uint32_t ELLS = (1U << 3);  ///< LLS feature exists
        constexpr uint32_t ELLS2 = (1U << 5);  ///< LLS2 feature exists
        constexpr uint32_t EVLLS0 = (1U << 6);  ///< VLLS0 feature exists
    }

    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t SRS;  ///< Offset: 0x08 - System Reset Status Register
        volatile uint32_t RPC;  ///< Offset: 0x0C - Reset Pin Control register
        volatile uint32_t MR;  ///< Offset: 0x10 - Mode Register
        volatile uint32_t FM;  ///< Offset: 0x14 - Force Mode Register
        volatile uint32_t SSRS;  ///< Offset: 0x18 - Sticky System Reset Status Register
        volatile uint32_t SRIE;  ///< Offset: 0x1C - System Reset Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t EWAKEUP = (1U << 0);  ///< Existence of SRS[WAKEUP] status indication feature
        constexpr uint32_t ELVD = (1U << 1);  ///< Existence of SRS[LVD] status indication feature
        constexpr uint32_t ELOC = (1U << 2);  ///< Existence of SRS[LOC] status indication feature
        constexpr uint32_t ELOL = (1U << 3);  ///< Existence of SRS[LOL] status indication feature
        constexpr uint32_t EWDOG = (1U << 5);  ///< Existence of SRS[WDOG] status indication feature
        constexpr uint32_t EPIN = (1U << 6);  ///< Existence of SRS[PIN] status indication feature
        constexpr uint32_t EPOR = (1U << 7);  ///< Existence of SRS[POR] status indication feature
        constexpr uint32_t EJTAG = (1U << 8);  ///< Existence of SRS[JTAG] status indication feature
        constexpr uint32_t ELOCKUP = (1U << 9);  ///< Existence of SRS[LOCKUP] status indication feature
        constexpr uint32_t ESW = (1U << 10);  ///< Existence of SRS[SW] status indication feature
        constexpr uint32_t EMDM_AP = (1U << 11);  ///< Existence of SRS[MDM_AP] status indication feature
        constexpr uint32_t ESACKERR = (1U << 13);  ///< Existence of SRS[SACKERR] status indication feature
        constexpr uint32_t ETAMPER = (1U << 15);  ///< Existence of SRS[TAMPER] status indication feature
        constexpr uint32_t ECORE1 = (1U << 16);  ///< Existence of SRS[CORE1] status indication feature
    }

    /// SRS Register bits
    namespace srs_bits {
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset or High-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 10);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Acknowledge Error
    }

    /// RPC Register bits
    namespace rpc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
        constexpr uint32_t RSTFLTSEL = (5 << 8);  ///< Reset Pin Filter Bus Clock Select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// SSRS Register bits
    namespace ssrs_bits {
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
        constexpr uint32_t SLOCKUP = (1U << 9);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 10);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 11);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 13);  ///< Sticky Stop Acknowledge Error
    }

    /// SRIE Register bits
    namespace srie_bits {
        constexpr uint32_t DELAY = (2 << 0);  ///< Reset Delay Time
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Interrupt
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Interrupt
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog Interrupt
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin Interrupt
        constexpr uint32_t GIE = (1U << 7);  ///< Global Interrupt Enable
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup Interrupt
        constexpr uint32_t SW = (1U << 10);  ///< Software Interrupt
        constexpr uint32_t MDM_AP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Acknowledge Error Interrupt
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP;  ///< Offset: 0x20 - MTB_DWT Comparator Register (renamed from COMP)
        volatile uint32_t MASK;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register (renamed from MASK)
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP Register bits
    namespace comp_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY;  ///< Offset: 0x00 - Entry (renamed from ENTRY)
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
        volatile uint32_t MATCR;  ///< Offset: 0x80 - Master Attribute Configuration Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID For MPU
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

    /// MATCR Register bits
    namespace matcr_bits {
        constexpr uint32_t ATC0 = (3 << 0);  ///< Attribute Configuration Master n
        constexpr uint32_t RO0 = (1U << 7);  ///< Read-Only Master n
        constexpr uint32_t ATC2 = (3 << 16);  ///< Attribute Configuration Master n
        constexpr uint32_t RO2 = (1U << 23);  ///< Read-Only Master n
    }

}

// ============================================================================
// MMDVSQ Peripheral
// ============================================================================

namespace mmdvsq {
    /// Base addresses
    constexpr uint32_t MMDVSQ_BASE = 0xF0004000;

    /// MMDVSQ Register structure
    struct Registers {
        volatile uint32_t DEND;  ///< Offset: 0x00 - Dividend Register
        volatile uint32_t DSOR;  ///< Offset: 0x04 - Divisor Register
        volatile uint32_t CSR;  ///< Offset: 0x08 - Control/Status Register
        volatile uint32_t RES;  ///< Offset: 0x0C - Result Register
        volatile uint32_t RCND;  ///< Offset: 0x10 - Radicand Register
    };

    /// Peripheral instances
    inline Registers* MMDVSQ = reinterpret_cast<Registers*>(MMDVSQ_BASE);

    // Bit definitions
    /// DEND Register bits
    namespace dend_bits {
        constexpr uint32_t DIVIDEND = (32 << 0);  ///< Dividend
    }

    /// DSOR Register bits
    namespace dsor_bits {
        constexpr uint32_t DIVISOR = (32 << 0);  ///< Divisor
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t SRT = (1U << 0);  ///< Start
        constexpr uint32_t USGN = (1U << 1);  ///< Unsigned calculation
        constexpr uint32_t REM = (1U << 2);  ///< REMainder calculation
        constexpr uint32_t DZE = (1U << 3);  ///< Divide-by-Zero-Enable
        constexpr uint32_t DZ = (1U << 4);  ///< Divide-by-Zero
        constexpr uint32_t DFS = (1U << 5);  ///< Disable Fast Start
        constexpr uint32_t SQRT = (1U << 29);  ///< SQUARE ROOT
        constexpr uint32_t DIV = (1U << 30);  ///< DIVIDE
        constexpr uint32_t BUSY = (1U << 31);  ///< BUSY
    }

    /// RES Register bits
    namespace res_bits {
        constexpr uint32_t RESULT = (32 << 0);  ///< Result
    }

    /// RCND Register bits
    namespace rcnd_bits {
        constexpr uint32_t RADICAND = (32 << 0);  ///< Radicand
    }

}


} // namespace alloy::generated::mke14z7

#endif // ALLOY_GENERATED_MKE14Z7_PERIPHERALS_HPP