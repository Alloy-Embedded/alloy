/// Auto-generated code for MKE18F16
/// Generated by Alloy Code Generator
/// Source: nxp_mke18.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 12:00:54
#ifndef ALLOY_GENERATED_MKE18F16_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKE18F16_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mke18f16 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_aips = true;
    constexpr uint32_t num_aips_instances = 1;
    constexpr bool has_mscm = true;
    constexpr uint32_t num_mscm_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_ftfe = true;
    constexpr uint32_t num_ftfe_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 2;
    constexpr bool has_ftm0 = true;
    constexpr uint32_t num_ftm0_instances = 1;
    constexpr bool has_ftm1 = true;
    constexpr uint32_t num_ftm1_instances = 1;
    constexpr bool has_ftm2 = true;
    constexpr uint32_t num_ftm2_instances = 1;
    constexpr bool has_ftm3 = true;
    constexpr uint32_t num_ftm3_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 3;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_pdb0 = true;
    constexpr uint32_t num_pdb0_instances = 1;
    constexpr bool has_pdb1 = true;
    constexpr uint32_t num_pdb1_instances = 1;
    constexpr bool has_pdb2 = true;
    constexpr uint32_t num_pdb2_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 10;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_pwt = true;
    constexpr uint32_t num_pwt_instances = 1;
    constexpr bool has_flexio = true;
    constexpr uint32_t num_flexio_instances = 1;
    constexpr bool has_osc32 = true;
    constexpr uint32_t num_osc32_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_trgmux0 = true;
    constexpr uint32_t num_trgmux0_instances = 1;
    constexpr bool has_trgmux1 = true;
    constexpr uint32_t num_trgmux1_instances = 1;
    constexpr bool has_scg = true;
    constexpr uint32_t num_scg_instances = 1;
    constexpr bool has_pcc = true;
    constexpr uint32_t num_pcc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_cmp2 = true;
    constexpr uint32_t num_cmp2_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;
    constexpr bool has_lmem = true;
    constexpr uint32_t num_lmem_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct aips_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mscm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftfe_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ftm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ftm3_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct pdb0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pdb2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 10;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc32_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct lmem_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 10;
    constexpr uint32_t max_gpio_pins = 160;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFE_FlashConfig_BASE = 0x00000400;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
        volatile uint32_t FEPROT;  ///< Offset: 0x0E - Non-volatile EERAM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x0F - Non-volatile D-Flash Protection Register
    };

    /// Peripheral instances
    inline Registers* FTFE_FlashConfig = reinterpret_cast<Registers*>(FTFE_FlashConfig_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< no description available
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< D-Flash Region Protect
    }

}

// ============================================================================
// AIPS Peripheral
// ============================================================================

namespace aips {
    /// Base addresses
    constexpr uint32_t AIPS_BASE = 0x40000000;

    /// AIPS Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACR%s;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t OPACR%s;  ///< Offset: 0x40 - Off-Platform Peripheral Access Control Register
        volatile uint32_t PACRU;  ///< Offset: 0x80 - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS = reinterpret_cast<Registers*>(AIPS_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACR%s Register bits
    namespace pacr%s_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// OPACR%s Register bits
    namespace opacr%s_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRU Register bits
    namespace pacru_bits {
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// MSCM Peripheral
// ============================================================================

namespace mscm {
    /// Base addresses
    constexpr uint32_t MSCM_BASE = 0x40001000;

    /// MSCM Register structure
    struct Registers {
        volatile uint32_t CPxTYPE;  ///< Offset: 0x00 - Processor X Type Register
        volatile uint32_t CPxNUM;  ///< Offset: 0x04 - Processor X Number Register
        volatile uint32_t CPxMASTER;  ///< Offset: 0x08 - Processor X Master Register
        volatile uint32_t CPxCOUNT;  ///< Offset: 0x0C - Processor X Count Register
        volatile uint32_t CPxCFG%s;  ///< Offset: 0x10 - Processor X Configuration Register
        volatile uint32_t CP0TYPE;  ///< Offset: 0x20 - Processor 0 Type Register
        volatile uint32_t CP0NUM;  ///< Offset: 0x24 - Processor 0 Number Register
        volatile uint32_t CP0MASTER;  ///< Offset: 0x28 - Processor 0 Master Register
        volatile uint32_t CP0COUNT;  ///< Offset: 0x2C - Processor 0 Count Register
        volatile uint32_t CP0CFG%s;  ///< Offset: 0x30 - Processor 0 Configuration Register
        volatile uint32_t OCMDR%s;  ///< Offset: 0x400 - On-Chip Memory Descriptor Register
    };

    /// Peripheral instances
    inline Registers* MSCM = reinterpret_cast<Registers*>(MSCM_BASE);

    // Bit definitions
    /// CPxTYPE Register bits
    namespace cpxtype_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CPxNUM Register bits
    namespace cpxnum_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CPxMASTER Register bits
    namespace cpxmaster_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CPxCOUNT Register bits
    namespace cpxcount_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CPxCFG%s Register bits
    namespace cpxcfg%s_bits {
        constexpr uint32_t ICSZ = (8 << 24);  ///< Level 1 Instruction Cache Size
    }

    /// CP0TYPE Register bits
    namespace cp0type_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CP0NUM Register bits
    namespace cp0num_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CP0MASTER Register bits
    namespace cp0master_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CP0COUNT Register bits
    namespace cp0count_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CP0CFG%s Register bits
    namespace cp0cfg%s_bits {
        constexpr uint32_t ICSZ = (8 << 24);  ///< Level 1 Instruction Cache Size
    }

    /// OCMDR%s Register bits
    namespace ocmdr%s_bits {
        constexpr uint32_t OCMC0 = (4 << 0);  ///< OCMEM Control Field 0
        constexpr uint32_t OCMC1 = (4 << 4);  ///< OCMEM Control Field 1
        constexpr uint32_t OCMC2 = (4 << 8);  ///< OCMEM Control Field 2
        constexpr uint32_t OCMPU = (1U << 12);  ///< OCMEM Memory Protection Unit
        constexpr uint32_t OCMT = (3 << 13);  ///< OCMEM Type. This field defines the type of the on-chip memory:
        constexpr uint32_t RO = (1U << 16);  ///< Read-Only
        constexpr uint32_t OCMW = (3 << 17);  ///< OCMEM datapath Width. This read-only field defines the width of the on-chip memory:
        constexpr uint32_t OCMSZ = (4 << 24);  ///< OCMEM Size
        constexpr uint32_t OCMSZH = (1U << 28);  ///< OCMEM Size "Hole"
        constexpr uint32_t V = (1U << 31);  ///< OCMEM Valid bit. This read-only field defines the validity (presence) of the on-chip memory
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT;  ///< Offset: 0x24 - Interrupt Request Register
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI%s;  ///< Offset: 0x100 - Channel n Priority Register
        volatile uint32_t TCD%s_SADDR;  ///< Offset: 0x1000 - TCD Source Address
        volatile uint32_t TCD%s_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset
        volatile uint32_t TCD%s_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes
        volatile uint32_t TCD%s_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled)
        volatile uint32_t TCD%s_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled...
        volatile uint32_t TCD%s_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and...
        volatile uint32_t TCD%s_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment
        volatile uint32_t TCD%s_DADDR;  ///< Offset: 0x1010 - TCD Destination Address
        volatile uint32_t TCD%s_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset
        volatile uint32_t TCD%s_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address
        volatile uint32_t TCD%s_CSR;  ///< Offset: 0x101C - TCD Control and Status
        volatile uint32_t TCD%s_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
        volatile uint32_t TCD%s_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel...
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (4 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
        constexpr uint32_t ERQ8 = (1U << 8);  ///< Enable DMA Request 8
        constexpr uint32_t ERQ9 = (1U << 9);  ///< Enable DMA Request 9
        constexpr uint32_t ERQ10 = (1U << 10);  ///< Enable DMA Request 10
        constexpr uint32_t ERQ11 = (1U << 11);  ///< Enable DMA Request 11
        constexpr uint32_t ERQ12 = (1U << 12);  ///< Enable DMA Request 12
        constexpr uint32_t ERQ13 = (1U << 13);  ///< Enable DMA Request 13
        constexpr uint32_t ERQ14 = (1U << 14);  ///< Enable DMA Request 14
        constexpr uint32_t ERQ15 = (1U << 15);  ///< Enable DMA Request 15
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
        constexpr uint32_t EEI8 = (1U << 8);  ///< Enable Error Interrupt 8
        constexpr uint32_t EEI9 = (1U << 9);  ///< Enable Error Interrupt 9
        constexpr uint32_t EEI10 = (1U << 10);  ///< Enable Error Interrupt 10
        constexpr uint32_t EEI11 = (1U << 11);  ///< Enable Error Interrupt 11
        constexpr uint32_t EEI12 = (1U << 12);  ///< Enable Error Interrupt 12
        constexpr uint32_t EEI13 = (1U << 13);  ///< Enable Error Interrupt 13
        constexpr uint32_t EEI14 = (1U << 14);  ///< Enable Error Interrupt 14
        constexpr uint32_t EEI15 = (1U << 15);  ///< Enable Error Interrupt 15
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (4 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (4 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (4 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (4 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (4 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (4 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (4 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (4 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT Register bits
    namespace int_bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
        constexpr uint32_t INT8 = (1U << 8);  ///< Interrupt Request 8
        constexpr uint32_t INT9 = (1U << 9);  ///< Interrupt Request 9
        constexpr uint32_t INT10 = (1U << 10);  ///< Interrupt Request 10
        constexpr uint32_t INT11 = (1U << 11);  ///< Interrupt Request 11
        constexpr uint32_t INT12 = (1U << 12);  ///< Interrupt Request 12
        constexpr uint32_t INT13 = (1U << 13);  ///< Interrupt Request 13
        constexpr uint32_t INT14 = (1U << 14);  ///< Interrupt Request 14
        constexpr uint32_t INT15 = (1U << 15);  ///< Interrupt Request 15
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
        constexpr uint32_t ERR8 = (1U << 8);  ///< Error In Channel 8
        constexpr uint32_t ERR9 = (1U << 9);  ///< Error In Channel 9
        constexpr uint32_t ERR10 = (1U << 10);  ///< Error In Channel 10
        constexpr uint32_t ERR11 = (1U << 11);  ///< Error In Channel 11
        constexpr uint32_t ERR12 = (1U << 12);  ///< Error In Channel 12
        constexpr uint32_t ERR13 = (1U << 13);  ///< Error In Channel 13
        constexpr uint32_t ERR14 = (1U << 14);  ///< Error In Channel 14
        constexpr uint32_t ERR15 = (1U << 15);  ///< Error In Channel 15
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
        constexpr uint32_t HRS8 = (1U << 8);  ///< Hardware Request Status Channel 8
        constexpr uint32_t HRS9 = (1U << 9);  ///< Hardware Request Status Channel 9
        constexpr uint32_t HRS10 = (1U << 10);  ///< Hardware Request Status Channel 10
        constexpr uint32_t HRS11 = (1U << 11);  ///< Hardware Request Status Channel 11
        constexpr uint32_t HRS12 = (1U << 12);  ///< Hardware Request Status Channel 12
        constexpr uint32_t HRS13 = (1U << 13);  ///< Hardware Request Status Channel 13
        constexpr uint32_t HRS14 = (1U << 14);  ///< Hardware Request Status Channel 14
        constexpr uint32_t HRS15 = (1U << 15);  ///< Hardware Request Status Channel 15
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
        constexpr uint32_t EDREQ_8 = (1U << 8);  ///< Enable asynchronous DMA request in stop mode for channel 8
        constexpr uint32_t EDREQ_9 = (1U << 9);  ///< Enable asynchronous DMA request in stop mode for channel 9
        constexpr uint32_t EDREQ_10 = (1U << 10);  ///< Enable asynchronous DMA request in stop mode for channel 10
        constexpr uint32_t EDREQ_11 = (1U << 11);  ///< Enable asynchronous DMA request in stop mode for channel 11
        constexpr uint32_t EDREQ_12 = (1U << 12);  ///< Enable asynchronous DMA request in stop mode for channel 12
        constexpr uint32_t EDREQ_13 = (1U << 13);  ///< Enable asynchronous DMA request in stop mode for channel 13
        constexpr uint32_t EDREQ_14 = (1U << 14);  ///< Enable asynchronous DMA request in stop mode for channel 14
        constexpr uint32_t EDREQ_15 = (1U << 15);  ///< Enable asynchronous DMA request in stop mode for channel 15
    }

    /// DCHPRI%s Register bits
    namespace dchpri%s_bits {
        constexpr uint32_t CHPRI = (4 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD%s_SADDR Register bits
    namespace tcd%s_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD%s_SOFF Register bits
    namespace tcd%s_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD%s_ATTR Register bits
    namespace tcd%s_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD%s_NBYTES_MLNO Register bits
    namespace tcd%s_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD%s_NBYTES_MLOFFNO Register bits
    namespace tcd%s_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_NBYTES_MLOFFYES Register bits
    namespace tcd%s_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD%s_SLAST Register bits
    namespace tcd%s_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD%s_DADDR Register bits
    namespace tcd%s_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD%s_DOFF Register bits
    namespace tcd%s_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD%s_CITER_ELINKNO Register bits
    namespace tcd%s_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_CITER_ELINKYES Register bits
    namespace tcd%s_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD%s_DLASTSGA Register bits
    namespace tcd%s_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD%s_CSR Register bits
    namespace tcd%s_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (4 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD%s_BITER_ELINKNO Register bits
    namespace tcd%s_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD%s_BITER_ELINKYES Register bits
    namespace tcd%s_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (4 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR%s;  ///< Offset: 0x10 - Error Address Register, slave port n
        volatile uint32_t EDR%s;  ///< Offset: 0x14 - Error Detail Register, slave port n
        volatile uint32_t RGD%s_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0
        volatile uint32_t RGD%s_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1
        volatile uint32_t RGD%s_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2
        volatile uint32_t RGD%s_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3
        volatile uint32_t RGDAAC%s;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (8 << 24);  ///< Slave Port n Error
    }

    /// EAR%s Register bits
    namespace ear%s_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR%s Register bits
    namespace edr%s_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD%s_WORD0 Register bits
    namespace rgd%s_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD%s_WORD1 Register bits
    namespace rgd%s_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD%s_WORD2 Register bits
    namespace rgd%s_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD%s_WORD3 Register bits
    namespace rgd%s_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC%s Register bits
    namespace rgdaac%s_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// FTFE Peripheral
// ============================================================================

namespace ftfe {
    /// Base addresses
    constexpr uint32_t FTFE_BASE = 0x40020000;

    /// FTFE Register structure
    struct Registers {
        volatile uint32_t FSTAT;  ///< Offset: 0x00 - Flash Status Register
        volatile uint32_t FCNFG;  ///< Offset: 0x01 - Flash Configuration Register
        volatile uint32_t FSEC;  ///< Offset: 0x02 - Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x03 - Flash Option Register
        volatile uint32_t FCCOB%s;  ///< Offset: 0x04 - Flash Common Command Object Registers
        volatile uint32_t FPROT%s;  ///< Offset: 0x10 - Program Flash Protection Registers
        volatile uint32_t FEPROT;  ///< Offset: 0x16 - EEPROM Protection Register
        volatile uint32_t FDPROT;  ///< Offset: 0x17 - Data Flash Protection Register
        volatile uint32_t XACC%s;  ///< Offset: 0x18 - Execute-only Access Registers
        volatile uint32_t SACC%s;  ///< Offset: 0x20 - Supervisor-only Access Registers
        volatile uint32_t FACSS;  ///< Offset: 0x28 - Flash Access Segment Size Register
        volatile uint32_t FACSN;  ///< Offset: 0x2B - Flash Access Segment Number Register
        volatile uint32_t FERSTAT;  ///< Offset: 0x2E - Flash Error Status Register
        volatile uint32_t FERCNFG;  ///< Offset: 0x2F - Flash Error Configuration Register
    };

    /// Peripheral instances
    inline Registers* FTFE = reinterpret_cast<Registers*>(FTFE_BASE);

    // Bit definitions
    /// FSTAT Register bits
    namespace fstat_bits {
        constexpr uint32_t MGSTAT0 = (1U << 0);  ///< Memory Controller Command Completion Status Flag
        constexpr uint32_t FPVIOL = (1U << 4);  ///< Flash Protection Violation Flag
        constexpr uint32_t ACCERR = (1U << 5);  ///< Flash Access Error Flag
        constexpr uint32_t RDCOLERR = (1U << 6);  ///< FTFE Read Collision Error Flag
        constexpr uint32_t CCIF = (1U << 7);  ///< Command Complete Interrupt Flag
    }

    /// FCNFG Register bits
    namespace fcnfg_bits {
        constexpr uint32_t EEERDY = (1U << 0);  ///< This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
        constexpr uint32_t RAMRDY = (1U << 1);  ///< RAM Ready
        constexpr uint32_t PFLSH = (1U << 2);  ///< FTFE configuration
        constexpr uint32_t ERSSUSP = (1U << 4);  ///< Erase Suspend
        constexpr uint32_t ERSAREQ = (1U << 5);  ///< Erase All Request
        constexpr uint32_t RDCOLLIE = (1U << 6);  ///< Read Collision Error Interrupt Enable
        constexpr uint32_t CCIE = (1U << 7);  ///< Command Complete Interrupt Enable
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< Mass Erase Enable Bits
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t OPT = (8 << 0);  ///< Nonvolatile Option
    }

    /// FCCOB%s Register bits
    namespace fccob%s_bits {
        constexpr uint32_t CCOBn = (8 << 0);  ///< The FCCOB register provides a command code and relevant parameters to the memory controller
    }

    /// FPROT%s Register bits
    namespace fprot%s_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< Program Flash Region Protect
    }

    /// FEPROT Register bits
    namespace feprot_bits {
        constexpr uint32_t EPROT = (8 << 0);  ///< EEPROM Region Protect
    }

    /// FDPROT Register bits
    namespace fdprot_bits {
        constexpr uint32_t DPROT = (8 << 0);  ///< Data Flash Region Protect
    }

    /// XACC%s Register bits
    namespace xacc%s_bits {
        constexpr uint32_t XA = (8 << 0);  ///< Execute-only access control
    }

    /// SACC%s Register bits
    namespace sacc%s_bits {
        constexpr uint32_t SA = (8 << 0);  ///< Supervisor-only access control
    }

    /// FACSS Register bits
    namespace facss_bits {
        constexpr uint32_t SGSIZE = (8 << 0);  ///< Segment Size
    }

    /// FACSN Register bits
    namespace facsn_bits {
        constexpr uint32_t NUMSG = (8 << 0);  ///< Number of Segments Indicator
    }

    /// FERSTAT Register bits
    namespace ferstat_bits {
        constexpr uint32_t DFDIF = (1U << 1);  ///< Double Bit Fault Detect Interrupt Flag
    }

    /// FERCNFG Register bits
    namespace fercnfg_bits {
        constexpr uint32_t DFDIE = (1U << 1);  ///< Double Bit Fault Detect Interrupt Enable
        constexpr uint32_t FDFD = (1U << 5);  ///< Force Double Bit Fault Detect
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t CAN0_BASE = 0x40024000;
    constexpr uint32_t CAN1_BASE = 0x40025000;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t CTRL1;  ///< Offset: 0x04 - Control 1 register
        volatile uint32_t TIMER;  ///< Offset: 0x08 - Free Running Timer
        volatile uint32_t RXMGMASK;  ///< Offset: 0x10 - Rx Mailboxes Global Mask Register
        volatile uint32_t RX14MASK;  ///< Offset: 0x14 - Rx 14 Mask register
        volatile uint32_t RX15MASK;  ///< Offset: 0x18 - Rx 15 Mask register
        volatile uint32_t ECR;  ///< Offset: 0x1C - Error Counter
        volatile uint32_t ESR1;  ///< Offset: 0x20 - Error and Status 1 register
        volatile uint32_t IMASK1;  ///< Offset: 0x28 - Interrupt Masks 1 register
        volatile uint32_t IFLAG1;  ///< Offset: 0x30 - Interrupt Flags 1 register
        volatile uint32_t CTRL2;  ///< Offset: 0x34 - Control 2 register
        volatile uint32_t ESR2;  ///< Offset: 0x38 - Error and Status 2 register
        volatile uint32_t CRCR;  ///< Offset: 0x44 - CRC Register
        volatile uint32_t RXFGMASK;  ///< Offset: 0x48 - Rx FIFO Global Mask register
        volatile uint32_t RXFIR;  ///< Offset: 0x4C - Rx FIFO Information Register
        volatile uint32_t CBT;  ///< Offset: 0x50 - CAN Bit Timing Register
        volatile uint32_t CS0;  ///< Offset: 0x80 - Message Buffer 0 CS Register
        volatile uint32_t ID0;  ///< Offset: 0x84 - Message Buffer 0 ID Register
        volatile uint32_t WORD00;  ///< Offset: 0x88 - Message Buffer 0 WORD0 Register
        volatile uint32_t WORD10;  ///< Offset: 0x8C - Message Buffer 0 WORD1 Register
        volatile uint32_t CS1;  ///< Offset: 0x90 - Message Buffer 1 CS Register
        volatile uint32_t ID1;  ///< Offset: 0x94 - Message Buffer 1 ID Register
        volatile uint32_t WORD01;  ///< Offset: 0x98 - Message Buffer 1 WORD0 Register
        volatile uint32_t WORD11;  ///< Offset: 0x9C - Message Buffer 1 WORD1 Register
        volatile uint32_t CS2;  ///< Offset: 0xA0 - Message Buffer 2 CS Register
        volatile uint32_t ID2;  ///< Offset: 0xA4 - Message Buffer 2 ID Register
        volatile uint32_t WORD02;  ///< Offset: 0xA8 - Message Buffer 2 WORD0 Register
        volatile uint32_t WORD12;  ///< Offset: 0xAC - Message Buffer 2 WORD1 Register
        volatile uint32_t CS3;  ///< Offset: 0xB0 - Message Buffer 3 CS Register
        volatile uint32_t ID3;  ///< Offset: 0xB4 - Message Buffer 3 ID Register
        volatile uint32_t WORD03;  ///< Offset: 0xB8 - Message Buffer 3 WORD0 Register
        volatile uint32_t WORD13;  ///< Offset: 0xBC - Message Buffer 3 WORD1 Register
        volatile uint32_t CS4;  ///< Offset: 0xC0 - Message Buffer 4 CS Register
        volatile uint32_t ID4;  ///< Offset: 0xC4 - Message Buffer 4 ID Register
        volatile uint32_t WORD04;  ///< Offset: 0xC8 - Message Buffer 4 WORD0 Register
        volatile uint32_t WORD14;  ///< Offset: 0xCC - Message Buffer 4 WORD1 Register
        volatile uint32_t CS5;  ///< Offset: 0xD0 - Message Buffer 5 CS Register
        volatile uint32_t ID5;  ///< Offset: 0xD4 - Message Buffer 5 ID Register
        volatile uint32_t WORD05;  ///< Offset: 0xD8 - Message Buffer 5 WORD0 Register
        volatile uint32_t WORD15;  ///< Offset: 0xDC - Message Buffer 5 WORD1 Register
        volatile uint32_t CS6;  ///< Offset: 0xE0 - Message Buffer 6 CS Register
        volatile uint32_t ID6;  ///< Offset: 0xE4 - Message Buffer 6 ID Register
        volatile uint32_t WORD06;  ///< Offset: 0xE8 - Message Buffer 6 WORD0 Register
        volatile uint32_t WORD16;  ///< Offset: 0xEC - Message Buffer 6 WORD1 Register
        volatile uint32_t CS7;  ///< Offset: 0xF0 - Message Buffer 7 CS Register
        volatile uint32_t ID7;  ///< Offset: 0xF4 - Message Buffer 7 ID Register
        volatile uint32_t WORD07;  ///< Offset: 0xF8 - Message Buffer 7 WORD0 Register
        volatile uint32_t WORD17;  ///< Offset: 0xFC - Message Buffer 7 WORD1 Register
        volatile uint32_t CS8;  ///< Offset: 0x100 - Message Buffer 8 CS Register
        volatile uint32_t ID8;  ///< Offset: 0x104 - Message Buffer 8 ID Register
        volatile uint32_t WORD08;  ///< Offset: 0x108 - Message Buffer 8 WORD0 Register
        volatile uint32_t WORD18;  ///< Offset: 0x10C - Message Buffer 8 WORD1 Register
        volatile uint32_t CS9;  ///< Offset: 0x110 - Message Buffer 9 CS Register
        volatile uint32_t ID9;  ///< Offset: 0x114 - Message Buffer 9 ID Register
        volatile uint32_t WORD09;  ///< Offset: 0x118 - Message Buffer 9 WORD0 Register
        volatile uint32_t WORD19;  ///< Offset: 0x11C - Message Buffer 9 WORD1 Register
        volatile uint32_t CS10;  ///< Offset: 0x120 - Message Buffer 10 CS Register
        volatile uint32_t ID10;  ///< Offset: 0x124 - Message Buffer 10 ID Register
        volatile uint32_t WORD010;  ///< Offset: 0x128 - Message Buffer 10 WORD0 Register
        volatile uint32_t WORD110;  ///< Offset: 0x12C - Message Buffer 10 WORD1 Register
        volatile uint32_t CS11;  ///< Offset: 0x130 - Message Buffer 11 CS Register
        volatile uint32_t ID11;  ///< Offset: 0x134 - Message Buffer 11 ID Register
        volatile uint32_t WORD011;  ///< Offset: 0x138 - Message Buffer 11 WORD0 Register
        volatile uint32_t WORD111;  ///< Offset: 0x13C - Message Buffer 11 WORD1 Register
        volatile uint32_t CS12;  ///< Offset: 0x140 - Message Buffer 12 CS Register
        volatile uint32_t ID12;  ///< Offset: 0x144 - Message Buffer 12 ID Register
        volatile uint32_t WORD012;  ///< Offset: 0x148 - Message Buffer 12 WORD0 Register
        volatile uint32_t WORD112;  ///< Offset: 0x14C - Message Buffer 12 WORD1 Register
        volatile uint32_t CS13;  ///< Offset: 0x150 - Message Buffer 13 CS Register
        volatile uint32_t ID13;  ///< Offset: 0x154 - Message Buffer 13 ID Register
        volatile uint32_t WORD013;  ///< Offset: 0x158 - Message Buffer 13 WORD0 Register
        volatile uint32_t WORD113;  ///< Offset: 0x15C - Message Buffer 13 WORD1 Register
        volatile uint32_t CS14;  ///< Offset: 0x160 - Message Buffer 14 CS Register
        volatile uint32_t ID14;  ///< Offset: 0x164 - Message Buffer 14 ID Register
        volatile uint32_t WORD014;  ///< Offset: 0x168 - Message Buffer 14 WORD0 Register
        volatile uint32_t WORD114;  ///< Offset: 0x16C - Message Buffer 14 WORD1 Register
        volatile uint32_t CS15;  ///< Offset: 0x170 - Message Buffer 15 CS Register
        volatile uint32_t ID15;  ///< Offset: 0x174 - Message Buffer 15 ID Register
        volatile uint32_t WORD015;  ///< Offset: 0x178 - Message Buffer 15 WORD0 Register
        volatile uint32_t WORD115;  ///< Offset: 0x17C - Message Buffer 15 WORD1 Register
        volatile uint32_t CS16;  ///< Offset: 0x180 - Message Buffer 16 CS Register
        volatile uint32_t ID16;  ///< Offset: 0x184 - Message Buffer 16 ID Register
        volatile uint32_t WORD016;  ///< Offset: 0x188 - Message Buffer 16 WORD0 Register
        volatile uint32_t WORD116;  ///< Offset: 0x18C - Message Buffer 16 WORD1 Register
        volatile uint32_t CS17;  ///< Offset: 0x190 - Message Buffer 17 CS Register
        volatile uint32_t ID17;  ///< Offset: 0x194 - Message Buffer 17 ID Register
        volatile uint32_t WORD017;  ///< Offset: 0x198 - Message Buffer 17 WORD0 Register
        volatile uint32_t WORD117;  ///< Offset: 0x19C - Message Buffer 17 WORD1 Register
        volatile uint32_t CS18;  ///< Offset: 0x1A0 - Message Buffer 18 CS Register
        volatile uint32_t ID18;  ///< Offset: 0x1A4 - Message Buffer 18 ID Register
        volatile uint32_t WORD018;  ///< Offset: 0x1A8 - Message Buffer 18 WORD0 Register
        volatile uint32_t WORD118;  ///< Offset: 0x1AC - Message Buffer 18 WORD1 Register
        volatile uint32_t CS19;  ///< Offset: 0x1B0 - Message Buffer 19 CS Register
        volatile uint32_t ID19;  ///< Offset: 0x1B4 - Message Buffer 19 ID Register
        volatile uint32_t WORD019;  ///< Offset: 0x1B8 - Message Buffer 19 WORD0 Register
        volatile uint32_t WORD119;  ///< Offset: 0x1BC - Message Buffer 19 WORD1 Register
        volatile uint32_t CS20;  ///< Offset: 0x1C0 - Message Buffer 20 CS Register
        volatile uint32_t ID20;  ///< Offset: 0x1C4 - Message Buffer 20 ID Register
        volatile uint32_t WORD020;  ///< Offset: 0x1C8 - Message Buffer 20 WORD0 Register
        volatile uint32_t WORD120;  ///< Offset: 0x1CC - Message Buffer 20 WORD1 Register
        volatile uint32_t CS21;  ///< Offset: 0x1D0 - Message Buffer 21 CS Register
        volatile uint32_t ID21;  ///< Offset: 0x1D4 - Message Buffer 21 ID Register
        volatile uint32_t WORD021;  ///< Offset: 0x1D8 - Message Buffer 21 WORD0 Register
        volatile uint32_t WORD121;  ///< Offset: 0x1DC - Message Buffer 21 WORD1 Register
        volatile uint32_t CS22;  ///< Offset: 0x1E0 - Message Buffer 22 CS Register
        volatile uint32_t ID22;  ///< Offset: 0x1E4 - Message Buffer 22 ID Register
        volatile uint32_t WORD022;  ///< Offset: 0x1E8 - Message Buffer 22 WORD0 Register
        volatile uint32_t WORD122;  ///< Offset: 0x1EC - Message Buffer 22 WORD1 Register
        volatile uint32_t CS23;  ///< Offset: 0x1F0 - Message Buffer 23 CS Register
        volatile uint32_t ID23;  ///< Offset: 0x1F4 - Message Buffer 23 ID Register
        volatile uint32_t WORD023;  ///< Offset: 0x1F8 - Message Buffer 23 WORD0 Register
        volatile uint32_t WORD123;  ///< Offset: 0x1FC - Message Buffer 23 WORD1 Register
        volatile uint32_t CS24;  ///< Offset: 0x200 - Message Buffer 24 CS Register
        volatile uint32_t ID24;  ///< Offset: 0x204 - Message Buffer 24 ID Register
        volatile uint32_t WORD024;  ///< Offset: 0x208 - Message Buffer 24 WORD0 Register
        volatile uint32_t WORD124;  ///< Offset: 0x20C - Message Buffer 24 WORD1 Register
        volatile uint32_t CS25;  ///< Offset: 0x210 - Message Buffer 25 CS Register
        volatile uint32_t ID25;  ///< Offset: 0x214 - Message Buffer 25 ID Register
        volatile uint32_t WORD025;  ///< Offset: 0x218 - Message Buffer 25 WORD0 Register
        volatile uint32_t WORD125;  ///< Offset: 0x21C - Message Buffer 25 WORD1 Register
        volatile uint32_t CS26;  ///< Offset: 0x220 - Message Buffer 26 CS Register
        volatile uint32_t ID26;  ///< Offset: 0x224 - Message Buffer 26 ID Register
        volatile uint32_t WORD026;  ///< Offset: 0x228 - Message Buffer 26 WORD0 Register
        volatile uint32_t WORD126;  ///< Offset: 0x22C - Message Buffer 26 WORD1 Register
        volatile uint32_t CS27;  ///< Offset: 0x230 - Message Buffer 27 CS Register
        volatile uint32_t ID27;  ///< Offset: 0x234 - Message Buffer 27 ID Register
        volatile uint32_t WORD027;  ///< Offset: 0x238 - Message Buffer 27 WORD0 Register
        volatile uint32_t WORD127;  ///< Offset: 0x23C - Message Buffer 27 WORD1 Register
        volatile uint32_t CS28;  ///< Offset: 0x240 - Message Buffer 28 CS Register
        volatile uint32_t ID28;  ///< Offset: 0x244 - Message Buffer 28 ID Register
        volatile uint32_t WORD028;  ///< Offset: 0x248 - Message Buffer 28 WORD0 Register
        volatile uint32_t WORD128;  ///< Offset: 0x24C - Message Buffer 28 WORD1 Register
        volatile uint32_t CS29;  ///< Offset: 0x250 - Message Buffer 29 CS Register
        volatile uint32_t ID29;  ///< Offset: 0x254 - Message Buffer 29 ID Register
        volatile uint32_t WORD029;  ///< Offset: 0x258 - Message Buffer 29 WORD0 Register
        volatile uint32_t WORD129;  ///< Offset: 0x25C - Message Buffer 29 WORD1 Register
        volatile uint32_t CS30;  ///< Offset: 0x260 - Message Buffer 30 CS Register
        volatile uint32_t ID30;  ///< Offset: 0x264 - Message Buffer 30 ID Register
        volatile uint32_t WORD030;  ///< Offset: 0x268 - Message Buffer 30 WORD0 Register
        volatile uint32_t WORD130;  ///< Offset: 0x26C - Message Buffer 30 WORD1 Register
        volatile uint32_t CS31;  ///< Offset: 0x270 - Message Buffer 31 CS Register
        volatile uint32_t ID31;  ///< Offset: 0x274 - Message Buffer 31 ID Register
        volatile uint32_t WORD031;  ///< Offset: 0x278 - Message Buffer 31 WORD0 Register
        volatile uint32_t WORD131;  ///< Offset: 0x27C - Message Buffer 31 WORD1 Register
        volatile uint32_t CS32;  ///< Offset: 0x280 - Message Buffer 32 CS Register
        volatile uint32_t ID32;  ///< Offset: 0x284 - Message Buffer 32 ID Register
        volatile uint32_t WORD032;  ///< Offset: 0x288 - Message Buffer 32 WORD0 Register
        volatile uint32_t WORD132;  ///< Offset: 0x28C - Message Buffer 32 WORD1 Register
        volatile uint32_t CS33;  ///< Offset: 0x290 - Message Buffer 33 CS Register
        volatile uint32_t ID33;  ///< Offset: 0x294 - Message Buffer 33 ID Register
        volatile uint32_t WORD033;  ///< Offset: 0x298 - Message Buffer 33 WORD0 Register
        volatile uint32_t WORD133;  ///< Offset: 0x29C - Message Buffer 33 WORD1 Register
        volatile uint32_t CS34;  ///< Offset: 0x2A0 - Message Buffer 34 CS Register
        volatile uint32_t ID34;  ///< Offset: 0x2A4 - Message Buffer 34 ID Register
        volatile uint32_t WORD034;  ///< Offset: 0x2A8 - Message Buffer 34 WORD0 Register
        volatile uint32_t WORD134;  ///< Offset: 0x2AC - Message Buffer 34 WORD1 Register
        volatile uint32_t CS35;  ///< Offset: 0x2B0 - Message Buffer 35 CS Register
        volatile uint32_t ID35;  ///< Offset: 0x2B4 - Message Buffer 35 ID Register
        volatile uint32_t WORD035;  ///< Offset: 0x2B8 - Message Buffer 35 WORD0 Register
        volatile uint32_t WORD135;  ///< Offset: 0x2BC - Message Buffer 35 WORD1 Register
        volatile uint32_t CS36;  ///< Offset: 0x2C0 - Message Buffer 36 CS Register
        volatile uint32_t ID36;  ///< Offset: 0x2C4 - Message Buffer 36 ID Register
        volatile uint32_t WORD036;  ///< Offset: 0x2C8 - Message Buffer 36 WORD0 Register
        volatile uint32_t WORD136;  ///< Offset: 0x2CC - Message Buffer 36 WORD1 Register
        volatile uint32_t CS37;  ///< Offset: 0x2D0 - Message Buffer 37 CS Register
        volatile uint32_t ID37;  ///< Offset: 0x2D4 - Message Buffer 37 ID Register
        volatile uint32_t WORD037;  ///< Offset: 0x2D8 - Message Buffer 37 WORD0 Register
        volatile uint32_t WORD137;  ///< Offset: 0x2DC - Message Buffer 37 WORD1 Register
        volatile uint32_t CS38;  ///< Offset: 0x2E0 - Message Buffer 38 CS Register
        volatile uint32_t ID38;  ///< Offset: 0x2E4 - Message Buffer 38 ID Register
        volatile uint32_t WORD038;  ///< Offset: 0x2E8 - Message Buffer 38 WORD0 Register
        volatile uint32_t WORD138;  ///< Offset: 0x2EC - Message Buffer 38 WORD1 Register
        volatile uint32_t CS39;  ///< Offset: 0x2F0 - Message Buffer 39 CS Register
        volatile uint32_t ID39;  ///< Offset: 0x2F4 - Message Buffer 39 ID Register
        volatile uint32_t WORD039;  ///< Offset: 0x2F8 - Message Buffer 39 WORD0 Register
        volatile uint32_t WORD139;  ///< Offset: 0x2FC - Message Buffer 39 WORD1 Register
        volatile uint32_t CS40;  ///< Offset: 0x300 - Message Buffer 40 CS Register
        volatile uint32_t ID40;  ///< Offset: 0x304 - Message Buffer 40 ID Register
        volatile uint32_t WORD040;  ///< Offset: 0x308 - Message Buffer 40 WORD0 Register
        volatile uint32_t WORD140;  ///< Offset: 0x30C - Message Buffer 40 WORD1 Register
        volatile uint32_t CS41;  ///< Offset: 0x310 - Message Buffer 41 CS Register
        volatile uint32_t ID41;  ///< Offset: 0x314 - Message Buffer 41 ID Register
        volatile uint32_t WORD041;  ///< Offset: 0x318 - Message Buffer 41 WORD0 Register
        volatile uint32_t WORD141;  ///< Offset: 0x31C - Message Buffer 41 WORD1 Register
        volatile uint32_t CS42;  ///< Offset: 0x320 - Message Buffer 42 CS Register
        volatile uint32_t ID42;  ///< Offset: 0x324 - Message Buffer 42 ID Register
        volatile uint32_t WORD042;  ///< Offset: 0x328 - Message Buffer 42 WORD0 Register
        volatile uint32_t WORD142;  ///< Offset: 0x32C - Message Buffer 42 WORD1 Register
        volatile uint32_t CS43;  ///< Offset: 0x330 - Message Buffer 43 CS Register
        volatile uint32_t ID43;  ///< Offset: 0x334 - Message Buffer 43 ID Register
        volatile uint32_t WORD043;  ///< Offset: 0x338 - Message Buffer 43 WORD0 Register
        volatile uint32_t WORD143;  ///< Offset: 0x33C - Message Buffer 43 WORD1 Register
        volatile uint32_t CS44;  ///< Offset: 0x340 - Message Buffer 44 CS Register
        volatile uint32_t ID44;  ///< Offset: 0x344 - Message Buffer 44 ID Register
        volatile uint32_t WORD044;  ///< Offset: 0x348 - Message Buffer 44 WORD0 Register
        volatile uint32_t WORD144;  ///< Offset: 0x34C - Message Buffer 44 WORD1 Register
        volatile uint32_t CS45;  ///< Offset: 0x350 - Message Buffer 45 CS Register
        volatile uint32_t ID45;  ///< Offset: 0x354 - Message Buffer 45 ID Register
        volatile uint32_t WORD045;  ///< Offset: 0x358 - Message Buffer 45 WORD0 Register
        volatile uint32_t WORD145;  ///< Offset: 0x35C - Message Buffer 45 WORD1 Register
        volatile uint32_t CS46;  ///< Offset: 0x360 - Message Buffer 46 CS Register
        volatile uint32_t ID46;  ///< Offset: 0x364 - Message Buffer 46 ID Register
        volatile uint32_t WORD046;  ///< Offset: 0x368 - Message Buffer 46 WORD0 Register
        volatile uint32_t WORD146;  ///< Offset: 0x36C - Message Buffer 46 WORD1 Register
        volatile uint32_t CS47;  ///< Offset: 0x370 - Message Buffer 47 CS Register
        volatile uint32_t ID47;  ///< Offset: 0x374 - Message Buffer 47 ID Register
        volatile uint32_t WORD047;  ///< Offset: 0x378 - Message Buffer 47 WORD0 Register
        volatile uint32_t WORD147;  ///< Offset: 0x37C - Message Buffer 47 WORD1 Register
        volatile uint32_t CS48;  ///< Offset: 0x380 - Message Buffer 48 CS Register
        volatile uint32_t ID48;  ///< Offset: 0x384 - Message Buffer 48 ID Register
        volatile uint32_t WORD048;  ///< Offset: 0x388 - Message Buffer 48 WORD0 Register
        volatile uint32_t WORD148;  ///< Offset: 0x38C - Message Buffer 48 WORD1 Register
        volatile uint32_t CS49;  ///< Offset: 0x390 - Message Buffer 49 CS Register
        volatile uint32_t ID49;  ///< Offset: 0x394 - Message Buffer 49 ID Register
        volatile uint32_t WORD049;  ///< Offset: 0x398 - Message Buffer 49 WORD0 Register
        volatile uint32_t WORD149;  ///< Offset: 0x39C - Message Buffer 49 WORD1 Register
        volatile uint32_t CS50;  ///< Offset: 0x3A0 - Message Buffer 50 CS Register
        volatile uint32_t ID50;  ///< Offset: 0x3A4 - Message Buffer 50 ID Register
        volatile uint32_t WORD050;  ///< Offset: 0x3A8 - Message Buffer 50 WORD0 Register
        volatile uint32_t WORD150;  ///< Offset: 0x3AC - Message Buffer 50 WORD1 Register
        volatile uint32_t CS51;  ///< Offset: 0x3B0 - Message Buffer 51 CS Register
        volatile uint32_t ID51;  ///< Offset: 0x3B4 - Message Buffer 51 ID Register
        volatile uint32_t WORD051;  ///< Offset: 0x3B8 - Message Buffer 51 WORD0 Register
        volatile uint32_t WORD151;  ///< Offset: 0x3BC - Message Buffer 51 WORD1 Register
        volatile uint32_t CS52;  ///< Offset: 0x3C0 - Message Buffer 52 CS Register
        volatile uint32_t ID52;  ///< Offset: 0x3C4 - Message Buffer 52 ID Register
        volatile uint32_t WORD052;  ///< Offset: 0x3C8 - Message Buffer 52 WORD0 Register
        volatile uint32_t WORD152;  ///< Offset: 0x3CC - Message Buffer 52 WORD1 Register
        volatile uint32_t CS53;  ///< Offset: 0x3D0 - Message Buffer 53 CS Register
        volatile uint32_t ID53;  ///< Offset: 0x3D4 - Message Buffer 53 ID Register
        volatile uint32_t WORD053;  ///< Offset: 0x3D8 - Message Buffer 53 WORD0 Register
        volatile uint32_t WORD153;  ///< Offset: 0x3DC - Message Buffer 53 WORD1 Register
        volatile uint32_t CS54;  ///< Offset: 0x3E0 - Message Buffer 54 CS Register
        volatile uint32_t ID54;  ///< Offset: 0x3E4 - Message Buffer 54 ID Register
        volatile uint32_t WORD054;  ///< Offset: 0x3E8 - Message Buffer 54 WORD0 Register
        volatile uint32_t WORD154;  ///< Offset: 0x3EC - Message Buffer 54 WORD1 Register
        volatile uint32_t CS55;  ///< Offset: 0x3F0 - Message Buffer 55 CS Register
        volatile uint32_t ID55;  ///< Offset: 0x3F4 - Message Buffer 55 ID Register
        volatile uint32_t WORD055;  ///< Offset: 0x3F8 - Message Buffer 55 WORD0 Register
        volatile uint32_t WORD155;  ///< Offset: 0x3FC - Message Buffer 55 WORD1 Register
        volatile uint32_t CS56;  ///< Offset: 0x400 - Message Buffer 56 CS Register
        volatile uint32_t ID56;  ///< Offset: 0x404 - Message Buffer 56 ID Register
        volatile uint32_t WORD056;  ///< Offset: 0x408 - Message Buffer 56 WORD0 Register
        volatile uint32_t WORD156;  ///< Offset: 0x40C - Message Buffer 56 WORD1 Register
        volatile uint32_t CS57;  ///< Offset: 0x410 - Message Buffer 57 CS Register
        volatile uint32_t ID57;  ///< Offset: 0x414 - Message Buffer 57 ID Register
        volatile uint32_t WORD057;  ///< Offset: 0x418 - Message Buffer 57 WORD0 Register
        volatile uint32_t WORD157;  ///< Offset: 0x41C - Message Buffer 57 WORD1 Register
        volatile uint32_t CS58;  ///< Offset: 0x420 - Message Buffer 58 CS Register
        volatile uint32_t ID58;  ///< Offset: 0x424 - Message Buffer 58 ID Register
        volatile uint32_t WORD058;  ///< Offset: 0x428 - Message Buffer 58 WORD0 Register
        volatile uint32_t WORD158;  ///< Offset: 0x42C - Message Buffer 58 WORD1 Register
        volatile uint32_t CS59;  ///< Offset: 0x430 - Message Buffer 59 CS Register
        volatile uint32_t ID59;  ///< Offset: 0x434 - Message Buffer 59 ID Register
        volatile uint32_t WORD059;  ///< Offset: 0x438 - Message Buffer 59 WORD0 Register
        volatile uint32_t WORD159;  ///< Offset: 0x43C - Message Buffer 59 WORD1 Register
        volatile uint32_t CS60;  ///< Offset: 0x440 - Message Buffer 60 CS Register
        volatile uint32_t ID60;  ///< Offset: 0x444 - Message Buffer 60 ID Register
        volatile uint32_t WORD060;  ///< Offset: 0x448 - Message Buffer 60 WORD0 Register
        volatile uint32_t WORD160;  ///< Offset: 0x44C - Message Buffer 60 WORD1 Register
        volatile uint32_t CS61;  ///< Offset: 0x450 - Message Buffer 61 CS Register
        volatile uint32_t ID61;  ///< Offset: 0x454 - Message Buffer 61 ID Register
        volatile uint32_t WORD061;  ///< Offset: 0x458 - Message Buffer 61 WORD0 Register
        volatile uint32_t WORD161;  ///< Offset: 0x45C - Message Buffer 61 WORD1 Register
        volatile uint32_t CS62;  ///< Offset: 0x460 - Message Buffer 62 CS Register
        volatile uint32_t ID62;  ///< Offset: 0x464 - Message Buffer 62 ID Register
        volatile uint32_t WORD062;  ///< Offset: 0x468 - Message Buffer 62 WORD0 Register
        volatile uint32_t WORD162;  ///< Offset: 0x46C - Message Buffer 62 WORD1 Register
        volatile uint32_t CS63;  ///< Offset: 0x470 - Message Buffer 63 CS Register
        volatile uint32_t ID63;  ///< Offset: 0x474 - Message Buffer 63 ID Register
        volatile uint32_t WORD063;  ///< Offset: 0x478 - Message Buffer 63 WORD0 Register
        volatile uint32_t WORD163;  ///< Offset: 0x47C - Message Buffer 63 WORD1 Register
        volatile uint32_t RXIMR%s;  ///< Offset: 0x880 - Rx Individual Mask Registers
        volatile uint32_t CTRL1_PN;  ///< Offset: 0xB00 - Pretended Networking Control 1 Register
        volatile uint32_t CTRL2_PN;  ///< Offset: 0xB04 - Pretended Networking Control 2 Register
        volatile uint32_t WU_MTC;  ///< Offset: 0xB08 - Pretended Networking Wake Up Match Register
        volatile uint32_t FLT_ID1;  ///< Offset: 0xB0C - Pretended Networking ID Filter 1 Register
        volatile uint32_t FLT_DLC;  ///< Offset: 0xB10 - Pretended Networking DLC Filter Register
        volatile uint32_t PL1_LO;  ///< Offset: 0xB14 - Pretended Networking Payload Low Filter 1 Register
        volatile uint32_t PL1_HI;  ///< Offset: 0xB18 - Pretended Networking Payload High Filter 1 Register
        volatile uint32_t FLT_ID2_IDMASK;  ///< Offset: 0xB1C - Pretended Networking ID Filter 2 Register / ID Mask Register
        volatile uint32_t PL2_PLMASK_LO;  ///< Offset: 0xB20 - Pretended Networking Payload Low Filter 2 Register /...
        volatile uint32_t PL2_PLMASK_HI;  ///< Offset: 0xB24 - Pretended Networking Payload High Filter 2 low order...
        volatile uint32_t WMB%s_CS;  ///< Offset: 0xB40 - Wake Up Message Buffer Register for C/S
        volatile uint32_t WMB%s_ID;  ///< Offset: 0xB44 - Wake Up Message Buffer Register for ID
        volatile uint32_t WMB%s_D03;  ///< Offset: 0xB48 - Wake Up Message Buffer Register for Data 0-3
        volatile uint32_t WMB%s_D47;  ///< Offset: 0xB4C - Wake Up Message Buffer Register Data 4-7
    };

    /// Peripheral instances
    inline Registers* CAN0 = reinterpret_cast<Registers*>(CAN0_BASE);
    inline Registers* CAN1 = reinterpret_cast<Registers*>(CAN1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MAXMB = (7 << 0);  ///< Number Of The Last Message Buffer
        constexpr uint32_t IDAM = (2 << 8);  ///< ID Acceptance Mode
        constexpr uint32_t AEN = (1U << 12);  ///< Abort Enable
        constexpr uint32_t LPRIOEN = (1U << 13);  ///< Local Priority Enable
        constexpr uint32_t PNET_EN = (1U << 14);  ///< Pretended Networking Enable
        constexpr uint32_t DMA = (1U << 15);  ///< DMA Enable
        constexpr uint32_t IRMQ = (1U << 16);  ///< Individual Rx Masking And Queue Enable
        constexpr uint32_t SRXDIS = (1U << 17);  ///< Self Reception Disable
        constexpr uint32_t WAKSRC = (1U << 19);  ///< Wake Up Source
        constexpr uint32_t LPMACK = (1U << 20);  ///< Low-Power Mode Acknowledge
        constexpr uint32_t WRNEN = (1U << 21);  ///< Warning Interrupt Enable
        constexpr uint32_t SLFWAK = (1U << 22);  ///< Self Wake Up
        constexpr uint32_t SUPV = (1U << 23);  ///< Supervisor Mode
        constexpr uint32_t FRZACK = (1U << 24);  ///< Freeze Mode Acknowledge
        constexpr uint32_t SOFTRST = (1U << 25);  ///< Soft Reset
        constexpr uint32_t WAKMSK = (1U << 26);  ///< Wake Up Interrupt Mask
        constexpr uint32_t NOTRDY = (1U << 27);  ///< FlexCAN Not Ready
        constexpr uint32_t HALT = (1U << 28);  ///< Halt FlexCAN
        constexpr uint32_t RFEN = (1U << 29);  ///< Rx FIFO Enable
        constexpr uint32_t FRZ = (1U << 30);  ///< Freeze Enable
        constexpr uint32_t MDIS = (1U << 31);  ///< Module Disable
    }

    /// CTRL1 Register bits
    namespace ctrl1_bits {
        constexpr uint32_t PROPSEG = (3 << 0);  ///< Propagation Segment
        constexpr uint32_t LOM = (1U << 3);  ///< Listen-Only Mode
        constexpr uint32_t LBUF = (1U << 4);  ///< Lowest Buffer Transmitted First
        constexpr uint32_t TSYN = (1U << 5);  ///< Timer Sync
        constexpr uint32_t BOFFREC = (1U << 6);  ///< Bus Off Recovery
        constexpr uint32_t SMP = (1U << 7);  ///< CAN Bit Sampling
        constexpr uint32_t RWRNMSK = (1U << 10);  ///< Rx Warning Interrupt Mask
        constexpr uint32_t TWRNMSK = (1U << 11);  ///< Tx Warning Interrupt Mask
        constexpr uint32_t LPB = (1U << 12);  ///< Loop Back Mode
        constexpr uint32_t CLKSRC = (1U << 13);  ///< CAN Engine Clock Source
        constexpr uint32_t ERRMSK = (1U << 14);  ///< Error Interrupt Mask
        constexpr uint32_t BOFFMSK = (1U << 15);  ///< Bus Off Interrupt Mask
        constexpr uint32_t PSEG2 = (3 << 16);  ///< Phase Segment 2
        constexpr uint32_t PSEG1 = (3 << 19);  ///< Phase Segment 1
        constexpr uint32_t RJW = (2 << 22);  ///< Resync Jump Width
        constexpr uint32_t PRESDIV = (8 << 24);  ///< Prescaler Division Factor
    }

    /// TIMER Register bits
    namespace timer_bits {
        constexpr uint32_t TIMER = (16 << 0);  ///< Timer Value
    }

    /// RXMGMASK Register bits
    namespace rxmgmask_bits {
        constexpr uint32_t MG = (32 << 0);  ///< Rx Mailboxes Global Mask Bits
    }

    /// RX14MASK Register bits
    namespace rx14mask_bits {
        constexpr uint32_t RX14M = (32 << 0);  ///< Rx Buffer 14 Mask Bits
    }

    /// RX15MASK Register bits
    namespace rx15mask_bits {
        constexpr uint32_t RX15M = (32 << 0);  ///< Rx Buffer 15 Mask Bits
    }

    /// ECR Register bits
    namespace ecr_bits {
        constexpr uint32_t TXERRCNT = (8 << 0);  ///< Transmit Error Counter
        constexpr uint32_t RXERRCNT = (8 << 8);  ///< Receive Error Counter
    }

    /// ESR1 Register bits
    namespace esr1_bits {
        constexpr uint32_t WAKINT = (1U << 0);  ///< Wake-Up Interrupt
        constexpr uint32_t ERRINT = (1U << 1);  ///< Error Interrupt
        constexpr uint32_t BOFFINT = (1U << 2);  ///< Bus Off Interrupt
        constexpr uint32_t RX = (1U << 3);  ///< FlexCAN In Reception
        constexpr uint32_t FLTCONF = (2 << 4);  ///< Fault Confinement State
        constexpr uint32_t TX = (1U << 6);  ///< FlexCAN In Transmission
        constexpr uint32_t IDLE = (1U << 7);  ///< This bit indicates when CAN bus is in IDLE state
        constexpr uint32_t RXWRN = (1U << 8);  ///< Rx Error Warning
        constexpr uint32_t TXWRN = (1U << 9);  ///< TX Error Warning
        constexpr uint32_t STFERR = (1U << 10);  ///< Stuffing Error
        constexpr uint32_t FRMERR = (1U << 11);  ///< Form Error
        constexpr uint32_t CRCERR = (1U << 12);  ///< Cyclic Redundancy Check Error
        constexpr uint32_t ACKERR = (1U << 13);  ///< Acknowledge Error
        constexpr uint32_t BIT0ERR = (1U << 14);  ///< Bit0 Error
        constexpr uint32_t BIT1ERR = (1U << 15);  ///< Bit1 Error
        constexpr uint32_t RWRNINT = (1U << 16);  ///< Rx Warning Interrupt Flag
        constexpr uint32_t TWRNINT = (1U << 17);  ///< Tx Warning Interrupt Flag
        constexpr uint32_t SYNCH = (1U << 18);  ///< CAN Synchronization Status
        constexpr uint32_t BOFFDONEINT = (1U << 19);  ///< Bus Off Done Interrupt
        constexpr uint32_t ERROVR = (1U << 21);  ///< Error Overrun bit
    }

    /// IMASK1 Register bits
    namespace imask1_bits {
        constexpr uint32_t BUF31TO0M = (32 << 0);  ///< Buffer MB i Mask
    }

    /// IFLAG1 Register bits
    namespace iflag1_bits {
        constexpr uint32_t BUF0I = (1U << 0);  ///< Buffer MB0 Interrupt Or Clear FIFO bit
        constexpr uint32_t BUF4TO1I = (4 << 1);  ///< Buffer MB i Interrupt Or "reserved"
        constexpr uint32_t BUF5I = (1U << 5);  ///< Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
        constexpr uint32_t BUF6I = (1U << 6);  ///< Buffer MB6 Interrupt Or "Rx FIFO Warning"
        constexpr uint32_t BUF7I = (1U << 7);  ///< Buffer MB7 Interrupt Or "Rx FIFO Overflow"
        constexpr uint32_t BUF31TO8I = (24 << 8);  ///< Buffer MBi Interrupt
    }

    /// CTRL2 Register bits
    namespace ctrl2_bits {
        constexpr uint32_t EDFLTDIS = (1U << 11);  ///< Edge Filter Disable
        constexpr uint32_t STFCNTEN = (1U << 12);  ///< Stuff Count Enable
        constexpr uint32_t PREXCEN = (1U << 14);  ///< Protocol Exception Enable
        constexpr uint32_t TIMER_SRC = (1U << 15);  ///< Timer Source
        constexpr uint32_t EACEN = (1U << 16);  ///< Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
        constexpr uint32_t RRS = (1U << 17);  ///< Remote Request Storing
        constexpr uint32_t MRP = (1U << 18);  ///< Mailboxes Reception Priority
        constexpr uint32_t TASD = (5 << 19);  ///< Tx Arbitration Start Delay
        constexpr uint32_t RFFN = (4 << 24);  ///< Number Of Rx FIFO Filters
        constexpr uint32_t BOFFDONEMSK = (1U << 30);  ///< Bus Off Done Interrupt Mask
    }

    /// ESR2 Register bits
    namespace esr2_bits {
        constexpr uint32_t IMB = (1U << 13);  ///< Inactive Mailbox
        constexpr uint32_t VPS = (1U << 14);  ///< Valid Priority Status
        constexpr uint32_t LPTM = (7 << 16);  ///< Lowest Priority Tx Mailbox
    }

    /// CRCR Register bits
    namespace crcr_bits {
        constexpr uint32_t TXCRC = (15 << 0);  ///< Transmitted CRC value
        constexpr uint32_t MBCRC = (7 << 16);  ///< CRC Mailbox
    }

    /// RXFGMASK Register bits
    namespace rxfgmask_bits {
        constexpr uint32_t FGM = (32 << 0);  ///< Rx FIFO Global Mask Bits
    }

    /// RXFIR Register bits
    namespace rxfir_bits {
        constexpr uint32_t IDHIT = (9 << 0);  ///< Identifier Acceptance Filter Hit Indicator
    }

    /// CBT Register bits
    namespace cbt_bits {
        constexpr uint32_t EPSEG2 = (5 << 0);  ///< Extended Phase Segment 2
        constexpr uint32_t EPSEG1 = (5 << 5);  ///< Extended Phase Segment 1
        constexpr uint32_t EPROPSEG = (6 << 10);  ///< Extended Propagation Segment
        constexpr uint32_t ERJW = (5 << 16);  ///< Extended Resync Jump Width
        constexpr uint32_t EPRESDIV = (10 << 21);  ///< Extended Prescaler Division Factor
        constexpr uint32_t BTF = (1U << 31);  ///< Bit Timing Format Enable
    }

    /// CS0 Register bits
    namespace cs0_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID0 Register bits
    namespace id0_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD00 Register bits
    namespace word00_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD10 Register bits
    namespace word10_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS1 Register bits
    namespace cs1_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID1 Register bits
    namespace id1_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD01 Register bits
    namespace word01_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD11 Register bits
    namespace word11_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS2 Register bits
    namespace cs2_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID2 Register bits
    namespace id2_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD02 Register bits
    namespace word02_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD12 Register bits
    namespace word12_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS3 Register bits
    namespace cs3_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID3 Register bits
    namespace id3_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD03 Register bits
    namespace word03_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD13 Register bits
    namespace word13_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS4 Register bits
    namespace cs4_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID4 Register bits
    namespace id4_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD04 Register bits
    namespace word04_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD14 Register bits
    namespace word14_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS5 Register bits
    namespace cs5_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID5 Register bits
    namespace id5_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD05 Register bits
    namespace word05_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD15 Register bits
    namespace word15_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS6 Register bits
    namespace cs6_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID6 Register bits
    namespace id6_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD06 Register bits
    namespace word06_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD16 Register bits
    namespace word16_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS7 Register bits
    namespace cs7_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID7 Register bits
    namespace id7_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD07 Register bits
    namespace word07_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD17 Register bits
    namespace word17_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS8 Register bits
    namespace cs8_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID8 Register bits
    namespace id8_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD08 Register bits
    namespace word08_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD18 Register bits
    namespace word18_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS9 Register bits
    namespace cs9_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID9 Register bits
    namespace id9_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD09 Register bits
    namespace word09_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD19 Register bits
    namespace word19_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS10 Register bits
    namespace cs10_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID10 Register bits
    namespace id10_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD010 Register bits
    namespace word010_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD110 Register bits
    namespace word110_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS11 Register bits
    namespace cs11_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID11 Register bits
    namespace id11_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD011 Register bits
    namespace word011_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD111 Register bits
    namespace word111_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS12 Register bits
    namespace cs12_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID12 Register bits
    namespace id12_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD012 Register bits
    namespace word012_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD112 Register bits
    namespace word112_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS13 Register bits
    namespace cs13_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID13 Register bits
    namespace id13_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD013 Register bits
    namespace word013_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD113 Register bits
    namespace word113_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS14 Register bits
    namespace cs14_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID14 Register bits
    namespace id14_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD014 Register bits
    namespace word014_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD114 Register bits
    namespace word114_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS15 Register bits
    namespace cs15_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID15 Register bits
    namespace id15_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD015 Register bits
    namespace word015_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD115 Register bits
    namespace word115_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS16 Register bits
    namespace cs16_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID16 Register bits
    namespace id16_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD016 Register bits
    namespace word016_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD116 Register bits
    namespace word116_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS17 Register bits
    namespace cs17_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID17 Register bits
    namespace id17_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD017 Register bits
    namespace word017_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD117 Register bits
    namespace word117_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS18 Register bits
    namespace cs18_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID18 Register bits
    namespace id18_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD018 Register bits
    namespace word018_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD118 Register bits
    namespace word118_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS19 Register bits
    namespace cs19_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID19 Register bits
    namespace id19_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD019 Register bits
    namespace word019_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD119 Register bits
    namespace word119_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS20 Register bits
    namespace cs20_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID20 Register bits
    namespace id20_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD020 Register bits
    namespace word020_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD120 Register bits
    namespace word120_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS21 Register bits
    namespace cs21_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID21 Register bits
    namespace id21_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD021 Register bits
    namespace word021_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD121 Register bits
    namespace word121_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS22 Register bits
    namespace cs22_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID22 Register bits
    namespace id22_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD022 Register bits
    namespace word022_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD122 Register bits
    namespace word122_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS23 Register bits
    namespace cs23_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID23 Register bits
    namespace id23_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD023 Register bits
    namespace word023_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD123 Register bits
    namespace word123_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS24 Register bits
    namespace cs24_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID24 Register bits
    namespace id24_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD024 Register bits
    namespace word024_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD124 Register bits
    namespace word124_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS25 Register bits
    namespace cs25_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID25 Register bits
    namespace id25_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD025 Register bits
    namespace word025_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD125 Register bits
    namespace word125_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS26 Register bits
    namespace cs26_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID26 Register bits
    namespace id26_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD026 Register bits
    namespace word026_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD126 Register bits
    namespace word126_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS27 Register bits
    namespace cs27_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID27 Register bits
    namespace id27_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD027 Register bits
    namespace word027_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD127 Register bits
    namespace word127_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS28 Register bits
    namespace cs28_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID28 Register bits
    namespace id28_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD028 Register bits
    namespace word028_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD128 Register bits
    namespace word128_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS29 Register bits
    namespace cs29_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID29 Register bits
    namespace id29_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD029 Register bits
    namespace word029_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD129 Register bits
    namespace word129_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS30 Register bits
    namespace cs30_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID30 Register bits
    namespace id30_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD030 Register bits
    namespace word030_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD130 Register bits
    namespace word130_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS31 Register bits
    namespace cs31_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID31 Register bits
    namespace id31_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD031 Register bits
    namespace word031_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD131 Register bits
    namespace word131_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS32 Register bits
    namespace cs32_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID32 Register bits
    namespace id32_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD032 Register bits
    namespace word032_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD132 Register bits
    namespace word132_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS33 Register bits
    namespace cs33_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID33 Register bits
    namespace id33_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD033 Register bits
    namespace word033_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD133 Register bits
    namespace word133_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS34 Register bits
    namespace cs34_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID34 Register bits
    namespace id34_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD034 Register bits
    namespace word034_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD134 Register bits
    namespace word134_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS35 Register bits
    namespace cs35_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID35 Register bits
    namespace id35_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD035 Register bits
    namespace word035_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD135 Register bits
    namespace word135_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS36 Register bits
    namespace cs36_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID36 Register bits
    namespace id36_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD036 Register bits
    namespace word036_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD136 Register bits
    namespace word136_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS37 Register bits
    namespace cs37_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID37 Register bits
    namespace id37_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD037 Register bits
    namespace word037_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD137 Register bits
    namespace word137_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS38 Register bits
    namespace cs38_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID38 Register bits
    namespace id38_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD038 Register bits
    namespace word038_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD138 Register bits
    namespace word138_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS39 Register bits
    namespace cs39_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID39 Register bits
    namespace id39_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD039 Register bits
    namespace word039_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD139 Register bits
    namespace word139_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS40 Register bits
    namespace cs40_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID40 Register bits
    namespace id40_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD040 Register bits
    namespace word040_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD140 Register bits
    namespace word140_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS41 Register bits
    namespace cs41_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID41 Register bits
    namespace id41_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD041 Register bits
    namespace word041_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD141 Register bits
    namespace word141_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS42 Register bits
    namespace cs42_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID42 Register bits
    namespace id42_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD042 Register bits
    namespace word042_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD142 Register bits
    namespace word142_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS43 Register bits
    namespace cs43_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID43 Register bits
    namespace id43_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD043 Register bits
    namespace word043_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD143 Register bits
    namespace word143_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS44 Register bits
    namespace cs44_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID44 Register bits
    namespace id44_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD044 Register bits
    namespace word044_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD144 Register bits
    namespace word144_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS45 Register bits
    namespace cs45_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID45 Register bits
    namespace id45_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD045 Register bits
    namespace word045_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD145 Register bits
    namespace word145_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS46 Register bits
    namespace cs46_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID46 Register bits
    namespace id46_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD046 Register bits
    namespace word046_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD146 Register bits
    namespace word146_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS47 Register bits
    namespace cs47_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID47 Register bits
    namespace id47_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD047 Register bits
    namespace word047_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD147 Register bits
    namespace word147_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS48 Register bits
    namespace cs48_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID48 Register bits
    namespace id48_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD048 Register bits
    namespace word048_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD148 Register bits
    namespace word148_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS49 Register bits
    namespace cs49_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID49 Register bits
    namespace id49_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD049 Register bits
    namespace word049_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD149 Register bits
    namespace word149_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS50 Register bits
    namespace cs50_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID50 Register bits
    namespace id50_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD050 Register bits
    namespace word050_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD150 Register bits
    namespace word150_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS51 Register bits
    namespace cs51_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID51 Register bits
    namespace id51_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD051 Register bits
    namespace word051_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD151 Register bits
    namespace word151_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS52 Register bits
    namespace cs52_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID52 Register bits
    namespace id52_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD052 Register bits
    namespace word052_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD152 Register bits
    namespace word152_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS53 Register bits
    namespace cs53_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID53 Register bits
    namespace id53_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD053 Register bits
    namespace word053_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD153 Register bits
    namespace word153_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS54 Register bits
    namespace cs54_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID54 Register bits
    namespace id54_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD054 Register bits
    namespace word054_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD154 Register bits
    namespace word154_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS55 Register bits
    namespace cs55_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID55 Register bits
    namespace id55_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD055 Register bits
    namespace word055_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD155 Register bits
    namespace word155_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS56 Register bits
    namespace cs56_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID56 Register bits
    namespace id56_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD056 Register bits
    namespace word056_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD156 Register bits
    namespace word156_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS57 Register bits
    namespace cs57_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID57 Register bits
    namespace id57_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD057 Register bits
    namespace word057_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD157 Register bits
    namespace word157_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS58 Register bits
    namespace cs58_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID58 Register bits
    namespace id58_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD058 Register bits
    namespace word058_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD158 Register bits
    namespace word158_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS59 Register bits
    namespace cs59_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID59 Register bits
    namespace id59_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD059 Register bits
    namespace word059_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD159 Register bits
    namespace word159_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS60 Register bits
    namespace cs60_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID60 Register bits
    namespace id60_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD060 Register bits
    namespace word060_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD160 Register bits
    namespace word160_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS61 Register bits
    namespace cs61_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID61 Register bits
    namespace id61_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD061 Register bits
    namespace word061_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD161 Register bits
    namespace word161_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS62 Register bits
    namespace cs62_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID62 Register bits
    namespace id62_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD062 Register bits
    namespace word062_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD162 Register bits
    namespace word162_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// CS63 Register bits
    namespace cs63_bits {
        constexpr uint32_t TIME_STAMP = (16 << 0);  ///< Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
        constexpr uint32_t DLC = (4 << 16);  ///< Length of the data to be stored/transmitted.
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request. One/zero for remote/data frame.
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended. One/zero for extended/standard format frame.
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request. Contains a fixed recessive bit.
        constexpr uint32_t CODE = (4 << 24);  ///< Reserved
    }

    /// ID63 Register bits
    namespace id63_bits {
        constexpr uint32_t EXT = (18 << 0);  ///< Contains extended (LOW word) identifier of message buffer.
        constexpr uint32_t STD = (11 << 18);  ///< Contains standard/extended (HIGH word) identifier of message buffer.
        constexpr uint32_t PRIO = (3 << 29);  ///< Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    }

    /// WORD063 Register bits
    namespace word063_bits {
        constexpr uint32_t DATA_BYTE_3 = (8 << 0);  ///< Data byte 3 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_2 = (8 << 8);  ///< Data byte 2 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_1 = (8 << 16);  ///< Data byte 1 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_0 = (8 << 24);  ///< Data byte 0 of Rx/Tx frame.
    }

    /// WORD163 Register bits
    namespace word163_bits {
        constexpr uint32_t DATA_BYTE_7 = (8 << 0);  ///< Data byte 7 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_6 = (8 << 8);  ///< Data byte 6 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_5 = (8 << 16);  ///< Data byte 5 of Rx/Tx frame.
        constexpr uint32_t DATA_BYTE_4 = (8 << 24);  ///< Data byte 4 of Rx/Tx frame.
    }

    /// RXIMR%s Register bits
    namespace rximr%s_bits {
        constexpr uint32_t MI = (32 << 0);  ///< Individual Mask Bits
    }

    /// CTRL1_PN Register bits
    namespace ctrl1_pn_bits {
        constexpr uint32_t FCS = (2 << 0);  ///< Filtering Combination Selection
        constexpr uint32_t IDFS = (2 << 2);  ///< ID Filtering Selection
        constexpr uint32_t PLFS = (2 << 4);  ///< Payload Filtering Selection
        constexpr uint32_t NMATCH = (8 << 8);  ///< Number of Messages Matching the Same Filtering Criteria
        constexpr uint32_t WUMF_MSK = (1U << 16);  ///< Wake Up by Match Flag Mask Bit
        constexpr uint32_t WTOF_MSK = (1U << 17);  ///< Wake Up by Timeout Flag Mask Bit
    }

    /// CTRL2_PN Register bits
    namespace ctrl2_pn_bits {
        constexpr uint32_t MATCHTO = (16 << 0);  ///< Timeout for No Message Matching the Filtering Criteria
    }

    /// WU_MTC Register bits
    namespace wu_mtc_bits {
        constexpr uint32_t MCOUNTER = (8 << 8);  ///< Number of Matches while in Pretended Networking
        constexpr uint32_t WUMF = (1U << 16);  ///< Wake Up by Match Flag Bit
        constexpr uint32_t WTOF = (1U << 17);  ///< Wake Up by Timeout Flag Bit
    }

    /// FLT_ID1 Register bits
    namespace flt_id1_bits {
        constexpr uint32_t FLT_ID1 = (29 << 0);  ///< ID Filter 1 for Pretended Networking filtering
        constexpr uint32_t FLT_RTR = (1U << 29);  ///< Remote Transmission Request Filter
        constexpr uint32_t FLT_IDE = (1U << 30);  ///< ID Extended Filter
    }

    /// FLT_DLC Register bits
    namespace flt_dlc_bits {
        constexpr uint32_t FLT_DLC_HI = (4 << 0);  ///< Upper Limit for Length of Data Bytes Filter
        constexpr uint32_t FLT_DLC_LO = (4 << 16);  ///< Lower Limit for Length of Data Bytes Filter
    }

    /// PL1_LO Register bits
    namespace pl1_lo_bits {
        constexpr uint32_t Data_byte_3 = (8 << 0);  ///< Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 3.
        constexpr uint32_t Data_byte_2 = (8 << 8);  ///< Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 2.
        constexpr uint32_t Data_byte_1 = (8 << 16);  ///< Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 1.
        constexpr uint32_t Data_byte_0 = (8 << 24);  ///< Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 0.
    }

    /// PL1_HI Register bits
    namespace pl1_hi_bits {
        constexpr uint32_t Data_byte_7 = (8 << 0);  ///< Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 7.
        constexpr uint32_t Data_byte_6 = (8 << 8);  ///< Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 6.
        constexpr uint32_t Data_byte_5 = (8 << 16);  ///< Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 5.
        constexpr uint32_t Data_byte_4 = (8 << 24);  ///< Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 4.
    }

    /// FLT_ID2_IDMASK Register bits
    namespace flt_id2_idmask_bits {
        constexpr uint32_t FLT_ID2_IDMASK = (29 << 0);  ///< ID Filter 2 for Pretended Networking Filtering / ID Mask Bits for Pretended Networking ID Filtering
        constexpr uint32_t RTR_MSK = (1U << 29);  ///< Remote Transmission Request Mask Bit
        constexpr uint32_t IDE_MSK = (1U << 30);  ///< ID Extended Mask Bit
    }

    /// PL2_PLMASK_LO Register bits
    namespace pl2_plmask_lo_bits {
        constexpr uint32_t Data_byte_3 = (8 << 0);  ///< Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 3.
        constexpr uint32_t Data_byte_2 = (8 << 8);  ///< Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 2.
        constexpr uint32_t Data_byte_1 = (8 << 16);  ///< Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 1.
        constexpr uint32_t Data_byte_0 = (8 << 24);  ///< Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 0.
    }

    /// PL2_PLMASK_HI Register bits
    namespace pl2_plmask_hi_bits {
        constexpr uint32_t Data_byte_7 = (8 << 0);  ///< Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 7.
        constexpr uint32_t Data_byte_6 = (8 << 8);  ///< Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 6.
        constexpr uint32_t Data_byte_5 = (8 << 16);  ///< Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 5.
        constexpr uint32_t Data_byte_4 = (8 << 24);  ///< Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 4.
    }

    /// WMB%s_CS Register bits
    namespace wmb%s_cs_bits {
        constexpr uint32_t DLC = (4 << 16);  ///< Length of Data in Bytes
        constexpr uint32_t RTR = (1U << 20);  ///< Remote Transmission Request Bit
        constexpr uint32_t IDE = (1U << 21);  ///< ID Extended Bit
        constexpr uint32_t SRR = (1U << 22);  ///< Substitute Remote Request
    }

    /// WMB%s_ID Register bits
    namespace wmb%s_id_bits {
        constexpr uint32_t ID = (29 << 0);  ///< Received ID under Pretended Networking mode
    }

    /// WMB%s_D03 Register bits
    namespace wmb%s_d03_bits {
        constexpr uint32_t Data_byte_3 = (8 << 0);  ///< Received payload corresponding to the data byte 3 under Pretended Networking mode
        constexpr uint32_t Data_byte_2 = (8 << 8);  ///< Received payload corresponding to the data byte 2 under Pretended Networking mode
        constexpr uint32_t Data_byte_1 = (8 << 16);  ///< Received payload corresponding to the data byte 1 under Pretended Networking mode
        constexpr uint32_t Data_byte_0 = (8 << 24);  ///< Received payload corresponding to the data byte 0 under Pretended Networking mode
    }

    /// WMB%s_D47 Register bits
    namespace wmb%s_d47_bits {
        constexpr uint32_t Data_byte_7 = (8 << 0);  ///< Received payload corresponding to the data byte 7 under Pretended Networking mode
        constexpr uint32_t Data_byte_6 = (8 << 8);  ///< Received payload corresponding to the data byte 6 under Pretended Networking mode
        constexpr uint32_t Data_byte_5 = (8 << 16);  ///< Received payload corresponding to the data byte 5 under Pretended Networking mode
        constexpr uint32_t Data_byte_4 = (8 << 24);  ///< Received payload corresponding to the data byte 4 under Pretended Networking mode
    }

}

// ============================================================================
// FTM0 Peripheral
// ============================================================================

namespace ftm0 {
    /// Base addresses
    constexpr uint32_t FTM0_BASE = 0x40038000;

    /// FTM0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
    };

    /// Peripheral instances
    inline Registers* FTM0 = reinterpret_cast<Registers*>(FTM0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel Input State
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

}

// ============================================================================
// FTM1 Peripheral
// ============================================================================

namespace ftm1 {
    /// Base addresses
    constexpr uint32_t FTM1_BASE = 0x40039000;

    /// FTM1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
    };

    /// Peripheral instances
    inline Registers* FTM1 = reinterpret_cast<Registers*>(FTM1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel Input State
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

}

// ============================================================================
// FTM2 Peripheral
// ============================================================================

namespace ftm2 {
    /// Base addresses
    constexpr uint32_t FTM2_BASE = 0x4003A000;

    /// FTM2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
    };

    /// Peripheral instances
    inline Registers* FTM2 = reinterpret_cast<Registers*>(FTM2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel Input State
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

}

// ============================================================================
// FTM3 Peripheral
// ============================================================================

namespace ftm3 {
    /// Base addresses
    constexpr uint32_t FTM3_BASE = 0x40026000;

    /// FTM3 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status And Control
        volatile uint32_t CNT;  ///< Offset: 0x04 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x08 - Modulo
        volatile uint32_t C%sSC;  ///< Offset: 0x0C - Channel (n) Status And Control
        volatile uint32_t C%sV;  ///< Offset: 0x10 - Channel (n) Value
        volatile uint32_t CNTIN;  ///< Offset: 0x4C - Counter Initial Value
        volatile uint32_t STATUS;  ///< Offset: 0x50 - Capture And Compare Status
        volatile uint32_t MODE;  ///< Offset: 0x54 - Features Mode Selection
        volatile uint32_t SYNC;  ///< Offset: 0x58 - Synchronization
        volatile uint32_t OUTINIT;  ///< Offset: 0x5C - Initial State For Channels Output
        volatile uint32_t OUTMASK;  ///< Offset: 0x60 - Output Mask
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Function For Linked Channels
        volatile uint32_t DEADTIME;  ///< Offset: 0x68 - Deadtime Insertion Control
        volatile uint32_t EXTTRIG;  ///< Offset: 0x6C - FTM External Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channels Polarity
        volatile uint32_t FMS;  ///< Offset: 0x74 - Fault Mode Status
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Input Capture Filter Control
        volatile uint32_t FLTCTRL;  ///< Offset: 0x7C - Fault Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control And Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
        volatile uint32_t FLTPOL;  ///< Offset: 0x88 - FTM Fault Input Polarity
        volatile uint32_t SYNCONF;  ///< Offset: 0x8C - Synchronization Configuration
        volatile uint32_t INVCTRL;  ///< Offset: 0x90 - FTM Inverting Control
        volatile uint32_t SWOCTRL;  ///< Offset: 0x94 - FTM Software Output Control
        volatile uint32_t PWMLOAD;  ///< Offset: 0x98 - FTM PWM Load
        volatile uint32_t HCR;  ///< Offset: 0x9C - Half Cycle Register
    };

    /// Peripheral instances
    inline Registers* FTM3 = reinterpret_cast<Registers*>(FTM3_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CLKS = (2 << 3);  ///< Clock Source Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t RIE = (1U << 6);  ///< Reload Interrupt Enable
        constexpr uint32_t RF = (1U << 7);  ///< Reload Flag
        constexpr uint32_t TOIE = (1U << 8);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 9);  ///< Timer Overflow Flag
        constexpr uint32_t PWMEN0 = (1U << 16);  ///< Channel 0 PWM enable bit
        constexpr uint32_t PWMEN1 = (1U << 17);  ///< Channel 1 PWM enable bit
        constexpr uint32_t PWMEN2 = (1U << 18);  ///< Channel 2 PWM enable bit
        constexpr uint32_t PWMEN3 = (1U << 19);  ///< Channel 3 PWM enable bit
        constexpr uint32_t PWMEN4 = (1U << 20);  ///< Channel 4 PWM enable bit
        constexpr uint32_t PWMEN5 = (1U << 21);  ///< Channel 5 PWM enable bit
        constexpr uint32_t PWMEN6 = (1U << 22);  ///< Channel 6 PWM enable bit
        constexpr uint32_t PWMEN7 = (1U << 23);  ///< Channel 7 PWM enable bit
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter Value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo Value
    }

    /// C%sSC Register bits
    namespace c%ssc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ICRST = (1U << 1);  ///< FTM counter reset by the selected input capture event.
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
        constexpr uint32_t TRIGMODE = (1U << 8);  ///< Trigger mode control
        constexpr uint32_t CHIS = (1U << 9);  ///< Channel Input State
    }

    /// C%sV Register bits
    namespace c%sv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// CNTIN Register bits
    namespace cntin_bits {
        constexpr uint32_t INIT = (16 << 0);  ///< Initial Value Of The FTM Counter
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t CH6F = (1U << 6);  ///< Channel 6 Flag
        constexpr uint32_t CH7F = (1U << 7);  ///< Channel 7 Flag
    }

    /// MODE Register bits
    namespace mode_bits {
        constexpr uint32_t FTMEN = (1U << 0);  ///< FTM Enable
        constexpr uint32_t INIT = (1U << 1);  ///< Initialize The Channels Output
        constexpr uint32_t WPDIS = (1U << 2);  ///< Write Protection Disable
        constexpr uint32_t PWMSYNC = (1U << 3);  ///< PWM Synchronization Mode
        constexpr uint32_t CAPTEST = (1U << 4);  ///< Capture Test Mode Enable
        constexpr uint32_t FAULTM = (2 << 5);  ///< Fault Control Mode
        constexpr uint32_t FAULTIE = (1U << 7);  ///< Fault Interrupt Enable
    }

    /// SYNC Register bits
    namespace sync_bits {
        constexpr uint32_t CNTMIN = (1U << 0);  ///< Minimum Loading Point Enable
        constexpr uint32_t CNTMAX = (1U << 1);  ///< Maximum Loading Point Enable
        constexpr uint32_t REINIT = (1U << 2);  ///< FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
        constexpr uint32_t SYNCHOM = (1U << 3);  ///< Output Mask Synchronization
        constexpr uint32_t TRIG0 = (1U << 4);  ///< PWM Synchronization Hardware Trigger 0
        constexpr uint32_t TRIG1 = (1U << 5);  ///< PWM Synchronization Hardware Trigger 1
        constexpr uint32_t TRIG2 = (1U << 6);  ///< PWM Synchronization Hardware Trigger 2
        constexpr uint32_t SWSYNC = (1U << 7);  ///< PWM Synchronization Software Trigger
    }

    /// OUTINIT Register bits
    namespace outinit_bits {
        constexpr uint32_t CH0OI = (1U << 0);  ///< Channel 0 Output Initialization Value
        constexpr uint32_t CH1OI = (1U << 1);  ///< Channel 1 Output Initialization Value
        constexpr uint32_t CH2OI = (1U << 2);  ///< Channel 2 Output Initialization Value
        constexpr uint32_t CH3OI = (1U << 3);  ///< Channel 3 Output Initialization Value
        constexpr uint32_t CH4OI = (1U << 4);  ///< Channel 4 Output Initialization Value
        constexpr uint32_t CH5OI = (1U << 5);  ///< Channel 5 Output Initialization Value
        constexpr uint32_t CH6OI = (1U << 6);  ///< Channel 6 Output Initialization Value
        constexpr uint32_t CH7OI = (1U << 7);  ///< Channel 7 Output Initialization Value
    }

    /// OUTMASK Register bits
    namespace outmask_bits {
        constexpr uint32_t CH0OM = (1U << 0);  ///< Channel 0 Output Mask
        constexpr uint32_t CH1OM = (1U << 1);  ///< Channel 1 Output Mask
        constexpr uint32_t CH2OM = (1U << 2);  ///< Channel 2 Output Mask
        constexpr uint32_t CH3OM = (1U << 3);  ///< Channel 3 Output Mask
        constexpr uint32_t CH4OM = (1U << 4);  ///< Channel 4 Output Mask
        constexpr uint32_t CH5OM = (1U << 5);  ///< Channel 5 Output Mask
        constexpr uint32_t CH6OM = (1U << 6);  ///< Channel 6 Output Mask
        constexpr uint32_t CH7OM = (1U << 7);  ///< Channel 7 Output Mask
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels For n = 0
        constexpr uint32_t COMP0 = (1U << 1);  ///< Complement Of Channel (n) For n = 0
        constexpr uint32_t DECAPEN0 = (1U << 2);  ///< Dual Edge Capture Mode Enable For n = 0
        constexpr uint32_t DECAP0 = (1U << 3);  ///< Dual Edge Capture Mode Captures For n = 0
        constexpr uint32_t DTEN0 = (1U << 4);  ///< Deadtime Enable For n = 0
        constexpr uint32_t SYNCEN0 = (1U << 5);  ///< Synchronization Enable For n = 0
        constexpr uint32_t FAULTEN0 = (1U << 6);  ///< Fault Control Enable For n = 0
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels For n = 2
        constexpr uint32_t COMP1 = (1U << 9);  ///< Complement Of Channel (n) For n = 2
        constexpr uint32_t DECAPEN1 = (1U << 10);  ///< Dual Edge Capture Mode Enable For n = 2
        constexpr uint32_t DECAP1 = (1U << 11);  ///< Dual Edge Capture Mode Captures For n = 2
        constexpr uint32_t DTEN1 = (1U << 12);  ///< Deadtime Enable For n = 2
        constexpr uint32_t SYNCEN1 = (1U << 13);  ///< Synchronization Enable For n = 2
        constexpr uint32_t FAULTEN1 = (1U << 14);  ///< Fault Control Enable For n = 2
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels For n = 4
        constexpr uint32_t COMP2 = (1U << 17);  ///< Complement Of Channel (n) For n = 4
        constexpr uint32_t DECAPEN2 = (1U << 18);  ///< Dual Edge Capture Mode Enable For n = 4
        constexpr uint32_t DECAP2 = (1U << 19);  ///< Dual Edge Capture Mode Captures For n = 4
        constexpr uint32_t DTEN2 = (1U << 20);  ///< Deadtime Enable For n = 4
        constexpr uint32_t SYNCEN2 = (1U << 21);  ///< Synchronization Enable For n = 4
        constexpr uint32_t FAULTEN2 = (1U << 22);  ///< Fault Control Enable For n = 4
        constexpr uint32_t COMBINE3 = (1U << 24);  ///< Combine Channels For n = 6
        constexpr uint32_t COMP3 = (1U << 25);  ///< Complement Of Channel (n) for n = 6
        constexpr uint32_t DECAPEN3 = (1U << 26);  ///< Dual Edge Capture Mode Enable For n = 6
        constexpr uint32_t DECAP3 = (1U << 27);  ///< Dual Edge Capture Mode Captures For n = 6
        constexpr uint32_t DTEN3 = (1U << 28);  ///< Deadtime Enable For n = 6
        constexpr uint32_t SYNCEN3 = (1U << 29);  ///< Synchronization Enable For n = 6
        constexpr uint32_t FAULTEN3 = (1U << 30);  ///< Fault Control Enable For n = 6
    }

    /// DEADTIME Register bits
    namespace deadtime_bits {
        constexpr uint32_t DTVAL = (6 << 0);  ///< Deadtime Value
        constexpr uint32_t DTPS = (2 << 6);  ///< Deadtime Prescaler Value
    }

    /// EXTTRIG Register bits
    namespace exttrig_bits {
        constexpr uint32_t CH2TRIG = (1U << 0);  ///< Channel 2 Trigger Enable
        constexpr uint32_t CH3TRIG = (1U << 1);  ///< Channel 3 Trigger Enable
        constexpr uint32_t CH4TRIG = (1U << 2);  ///< Channel 4 Trigger Enable
        constexpr uint32_t CH5TRIG = (1U << 3);  ///< Channel 5 Trigger Enable
        constexpr uint32_t CH0TRIG = (1U << 4);  ///< Channel 0 Trigger Enable
        constexpr uint32_t CH1TRIG = (1U << 5);  ///< Channel 1 Trigger Enable
        constexpr uint32_t INITTRIGEN = (1U << 6);  ///< Initialization Trigger Enable
        constexpr uint32_t TRIGF = (1U << 7);  ///< Channel Trigger Flag
        constexpr uint32_t CH6TRIG = (1U << 8);  ///< Channel 6 Trigger Enable
        constexpr uint32_t CH7TRIG = (1U << 9);  ///< Channel 7 Trigger Enable
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
        constexpr uint32_t POL6 = (1U << 6);  ///< Channel 6 Polarity
        constexpr uint32_t POL7 = (1U << 7);  ///< Channel 7 Polarity
    }

    /// FMS Register bits
    namespace fms_bits {
        constexpr uint32_t FAULTF0 = (1U << 0);  ///< Fault Detection Flag 0
        constexpr uint32_t FAULTF1 = (1U << 1);  ///< Fault Detection Flag 1
        constexpr uint32_t FAULTF2 = (1U << 2);  ///< Fault Detection Flag 2
        constexpr uint32_t FAULTF3 = (1U << 3);  ///< Fault Detection Flag 3
        constexpr uint32_t FAULTIN = (1U << 5);  ///< Fault Inputs
        constexpr uint32_t WPEN = (1U << 6);  ///< Write Protection Enable
        constexpr uint32_t FAULTF = (1U << 7);  ///< Fault Detection Flag
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Input Filter
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Input Filter
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Input Filter
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Input Filter
    }

    /// FLTCTRL Register bits
    namespace fltctrl_bits {
        constexpr uint32_t FAULT0EN = (1U << 0);  ///< Fault Input 0 Enable
        constexpr uint32_t FAULT1EN = (1U << 1);  ///< Fault Input 1 Enable
        constexpr uint32_t FAULT2EN = (1U << 2);  ///< Fault Input 2 Enable
        constexpr uint32_t FAULT3EN = (1U << 3);  ///< Fault Input 3 Enable
        constexpr uint32_t FFLTR0EN = (1U << 4);  ///< Fault Input 0 Filter Enable
        constexpr uint32_t FFLTR1EN = (1U << 5);  ///< Fault Input 1 Filter Enable
        constexpr uint32_t FFLTR2EN = (1U << 6);  ///< Fault Input 2 Filter Enable
        constexpr uint32_t FFLTR3EN = (1U << 7);  ///< Fault Input 3 Filter Enable
        constexpr uint32_t FFVAL = (4 << 8);  ///< Fault Input Filter
        constexpr uint32_t FSTATE = (1U << 15);  ///< Fault output state
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Quadrature Decoder Mode Enable
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Timer Overflow Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADIR = (1U << 2);  ///< FTM Counter Direction In Quadrature Decoder Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
        constexpr uint32_t PHBPOL = (1U << 4);  ///< Phase B Input Polarity
        constexpr uint32_t PHAPOL = (1U << 5);  ///< Phase A Input Polarity
        constexpr uint32_t PHBFLTREN = (1U << 6);  ///< Phase B Input Filter Enable
        constexpr uint32_t PHAFLTREN = (1U << 7);  ///< Phase A Input Filter Enable
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t LDFQ = (5 << 0);  ///< Load Frequency
        constexpr uint32_t BDMMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global Time Base Enable
        constexpr uint32_t GTBEOUT = (1U << 10);  ///< Global Time Base Output
        constexpr uint32_t ITRIGR = (1U << 11);  ///< Initialization trigger on Reload Point
    }

    /// FLTPOL Register bits
    namespace fltpol_bits {
        constexpr uint32_t FLT0POL = (1U << 0);  ///< Fault Input 0 Polarity
        constexpr uint32_t FLT1POL = (1U << 1);  ///< Fault Input 1 Polarity
        constexpr uint32_t FLT2POL = (1U << 2);  ///< Fault Input 2 Polarity
        constexpr uint32_t FLT3POL = (1U << 3);  ///< Fault Input 3 Polarity
    }

    /// SYNCONF Register bits
    namespace synconf_bits {
        constexpr uint32_t HWTRIGMODE = (1U << 0);  ///< Hardware Trigger Mode
        constexpr uint32_t CNTINC = (1U << 2);  ///< CNTIN Register Synchronization
        constexpr uint32_t INVC = (1U << 4);  ///< INVCTRL Register Synchronization
        constexpr uint32_t SWOC = (1U << 5);  ///< SWOCTRL Register Synchronization
        constexpr uint32_t SYNCMODE = (1U << 7);  ///< Synchronization Mode
        constexpr uint32_t SWRSTCNT = (1U << 8);  ///< FTM counter synchronization is activated by the software trigger.
        constexpr uint32_t SWWRBUF = (1U << 9);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger.
        constexpr uint32_t SWOM = (1U << 10);  ///< Output mask synchronization is activated by the software trigger.
        constexpr uint32_t SWINVC = (1U << 11);  ///< Inverting control synchronization is activated by the software trigger.
        constexpr uint32_t SWSOC = (1U << 12);  ///< Software output control synchronization is activated by the software trigger.
        constexpr uint32_t HWRSTCNT = (1U << 16);  ///< FTM counter synchronization is activated by a hardware trigger.
        constexpr uint32_t HWWRBUF = (1U << 17);  ///< MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger.
        constexpr uint32_t HWOM = (1U << 18);  ///< Output mask synchronization is activated by a hardware trigger.
        constexpr uint32_t HWINVC = (1U << 19);  ///< Inverting control synchronization is activated by a hardware trigger.
        constexpr uint32_t HWSOC = (1U << 20);  ///< Software output control synchronization is activated by a hardware trigger.
    }

    /// INVCTRL Register bits
    namespace invctrl_bits {
        constexpr uint32_t INV0EN = (1U << 0);  ///< Pair Channels 0 Inverting Enable
        constexpr uint32_t INV1EN = (1U << 1);  ///< Pair Channels 1 Inverting Enable
        constexpr uint32_t INV2EN = (1U << 2);  ///< Pair Channels 2 Inverting Enable
        constexpr uint32_t INV3EN = (1U << 3);  ///< Pair Channels 3 Inverting Enable
    }

    /// SWOCTRL Register bits
    namespace swoctrl_bits {
        constexpr uint32_t CH0OC = (1U << 0);  ///< Channel 0 Software Output Control Enable
        constexpr uint32_t CH1OC = (1U << 1);  ///< Channel 1 Software Output Control Enable
        constexpr uint32_t CH2OC = (1U << 2);  ///< Channel 2 Software Output Control Enable
        constexpr uint32_t CH3OC = (1U << 3);  ///< Channel 3 Software Output Control Enable
        constexpr uint32_t CH4OC = (1U << 4);  ///< Channel 4 Software Output Control Enable
        constexpr uint32_t CH5OC = (1U << 5);  ///< Channel 5 Software Output Control Enable
        constexpr uint32_t CH6OC = (1U << 6);  ///< Channel 6 Software Output Control Enable
        constexpr uint32_t CH7OC = (1U << 7);  ///< Channel 7 Software Output Control Enable
        constexpr uint32_t CH0OCV = (1U << 8);  ///< Channel 0 Software Output Control Value
        constexpr uint32_t CH1OCV = (1U << 9);  ///< Channel 1 Software Output Control Value
        constexpr uint32_t CH2OCV = (1U << 10);  ///< Channel 2 Software Output Control Value
        constexpr uint32_t CH3OCV = (1U << 11);  ///< Channel 3 Software Output Control Value
        constexpr uint32_t CH4OCV = (1U << 12);  ///< Channel 4 Software Output Control Value
        constexpr uint32_t CH5OCV = (1U << 13);  ///< Channel 5 Software Output Control Value
        constexpr uint32_t CH6OCV = (1U << 14);  ///< Channel 6 Software Output Control Value
        constexpr uint32_t CH7OCV = (1U << 15);  ///< Channel 7 Software Output Control Value
    }

    /// PWMLOAD Register bits
    namespace pwmload_bits {
        constexpr uint32_t CH0SEL = (1U << 0);  ///< Channel 0 Select
        constexpr uint32_t CH1SEL = (1U << 1);  ///< Channel 1 Select
        constexpr uint32_t CH2SEL = (1U << 2);  ///< Channel 2 Select
        constexpr uint32_t CH3SEL = (1U << 3);  ///< Channel 3 Select
        constexpr uint32_t CH4SEL = (1U << 4);  ///< Channel 4 Select
        constexpr uint32_t CH5SEL = (1U << 5);  ///< Channel 5 Select
        constexpr uint32_t CH6SEL = (1U << 6);  ///< Channel 6 Select
        constexpr uint32_t CH7SEL = (1U << 7);  ///< Channel 7 Select
        constexpr uint32_t HCSEL = (1U << 8);  ///< Half Cycle Select
        constexpr uint32_t LDOK = (1U << 9);  ///< Load Enable
        constexpr uint32_t GLEN = (1U << 10);  ///< Global Load Enable
        constexpr uint32_t GLDOK = (1U << 11);  ///< Global Load OK
    }

    /// HCR Register bits
    namespace hcr_bits {
        constexpr uint32_t HCVAL = (16 << 0);  ///< Half Cycle Value
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;
    constexpr uint32_t ADC1_BASE = 0x40027000;
    constexpr uint32_t ADC2_BASE = 0x4003C000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1%s;  ///< Offset: 0x00 - ADC Status and Control Registers 1
        volatile uint32_t CFG1;  ///< Offset: 0x40 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x44 - ADC Configuration Register 2
        volatile uint32_t R%s;  ///< Offset: 0x48 - ADC Data Result Register
        volatile uint32_t CV%s;  ///< Offset: 0x88 - Compare Value Registers
        volatile uint32_t SC2;  ///< Offset: 0x90 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x94 - Status and Control Register 3
        volatile uint32_t BASE_OFS;  ///< Offset: 0x98 - ADC Offset Correction Register
        volatile uint32_t OFS;  ///< Offset: 0x9C - ADC Offset Correction Register
        volatile uint32_t USR_OFS;  ///< Offset: 0xA0 - ADC USER Offset Correction Register
        volatile uint32_t XOFS;  ///< Offset: 0xA4 - ADC X Offset Correction Register
        volatile uint32_t YOFS;  ///< Offset: 0xA8 - ADC Y Offset Correction Register
        volatile uint32_t G;  ///< Offset: 0xAC - ADC Gain Register
        volatile uint32_t UG;  ///< Offset: 0xB0 - ADC User Gain Register
        volatile uint32_t CLPS;  ///< Offset: 0xB4 - ADC General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0xB8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0xBC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0xC0 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0xC4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPX;  ///< Offset: 0xC8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP9;  ///< Offset: 0xCC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS_OFS;  ///< Offset: 0xD0 - ADC General Calibration Value Register
        volatile uint32_t CLP3_OFS;  ///< Offset: 0xD4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2_OFS;  ///< Offset: 0xD8 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1_OFS;  ///< Offset: 0xDC - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0_OFS;  ///< Offset: 0xE0 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPX_OFS;  ///< Offset: 0xE4 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP9_OFS;  ///< Offset: 0xE8 - ADC Plus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);

    // Bit definitions
    /// SC1%s Register bits
    namespace sc1%s_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t SMPLTS = (8 << 0);  ///< Sample Time Select
    }

    /// R%s Register bits
    namespace r%s_bits {
        constexpr uint32_t D = (12 << 0);  ///< Data result
    }

    /// CV%s Register bits
    namespace cv%s_bits {
        constexpr uint32_t CV = (12 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// BASE_OFS Register bits
    namespace base_ofs_bits {
        constexpr uint32_t BA_OFS = (8 << 0);  ///< Base Offset Error Correction Value
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (12 << 0);  ///< Offset Error Correction Value
    }

    /// USR_OFS Register bits
    namespace usr_ofs_bits {
        constexpr uint32_t USR_OFS = (8 << 0);  ///< USER Offset Error Correction Value
    }

    /// XOFS Register bits
    namespace xofs_bits {
        constexpr uint32_t OFS = (6 << 0);  ///< Offset Error Correction Value
    }

    /// YOFS Register bits
    namespace yofs_bits {
        constexpr uint32_t YOFS = (8 << 0);  ///< Y Offset Error Correction Value
    }

    /// G Register bits
    namespace g_bits {
        constexpr uint32_t G = (11 << 0);  ///< Gain
    }

    /// UG Register bits
    namespace ug_bits {
        constexpr uint32_t UG = (10 << 0);  ///< User Gain
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (7 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (10 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (9 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (9 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (8 << 0);  ///< Calibration Value
    }

    /// CLPX Register bits
    namespace clpx_bits {
        constexpr uint32_t CLPX = (7 << 0);  ///< Calibration Value
        constexpr uint32_t CLPXEN = (1U << 7);  ///< CLPX compare bit
    }

    /// CLP9 Register bits
    namespace clp9_bits {
        constexpr uint32_t CLP9 = (7 << 0);  ///< Calibration Value
        constexpr uint32_t CLP9EN = (1U << 7);  ///< CLP9 compare bit
    }

    /// CLPS_OFS Register bits
    namespace clps_ofs_bits {
        constexpr uint32_t CLPS_OFS = (4 << 0);  ///< CLPS Offset
    }

    /// CLP3_OFS Register bits
    namespace clp3_ofs_bits {
        constexpr uint32_t CLP3_OFS = (4 << 0);  ///< CLP3 Offset
    }

    /// CLP2_OFS Register bits
    namespace clp2_ofs_bits {
        constexpr uint32_t CLP2_OFS = (4 << 0);  ///< CLP2 Offset
    }

    /// CLP1_OFS Register bits
    namespace clp1_ofs_bits {
        constexpr uint32_t CLP1_OFS = (4 << 0);  ///< CLP1 Offset
    }

    /// CLP0_OFS Register bits
    namespace clp0_ofs_bits {
        constexpr uint32_t CLP0_OFS = (4 << 0);  ///< CLP0 Offset
    }

    /// CLPX_OFS Register bits
    namespace clpx_ofs_bits {
        constexpr uint32_t CLPX_OFS = (12 << 0);  ///< CLPX Offset
    }

    /// CLP9_OFS Register bits
    namespace clp9_ofs_bits {
        constexpr uint32_t CLP9_OFS = (12 << 0);  ///< CLP9 Offset
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t LPSPI0_BASE = 0x4002C000;
    constexpr uint32_t LPSPI1_BASE = 0x4002D000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - Status Register
        volatile uint32_t IER;  ///< Offset: 0x18 - Interrupt Enable Register
        volatile uint32_t DER;  ///< Offset: 0x1C - DMA Enable Register
        volatile uint32_t CFGR0;  ///< Offset: 0x20 - Configuration Register 0
        volatile uint32_t CFGR1;  ///< Offset: 0x24 - Configuration Register 1
        volatile uint32_t DMR0;  ///< Offset: 0x30 - Data Match Register 0
        volatile uint32_t DMR1;  ///< Offset: 0x34 - Data Match Register 1
        volatile uint32_t CCR;  ///< Offset: 0x40 - Clock Configuration Register
        volatile uint32_t FCR;  ///< Offset: 0x58 - FIFO Control Register
        volatile uint32_t FSR;  ///< Offset: 0x5C - FIFO Status Register
        volatile uint32_t TCR;  ///< Offset: 0x60 - Transmit Command Register
        volatile uint32_t TDR;  ///< Offset: 0x64 - Transmit Data Register
        volatile uint32_t RSR;  ///< Offset: 0x70 - Receive Status Register
        volatile uint32_t RDR;  ///< Offset: 0x74 - Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPSPI0 = reinterpret_cast<Registers*>(LPSPI0_BASE);
    inline Registers* LPSPI1 = reinterpret_cast<Registers*>(LPSPI1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Module Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Module Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t WCF = (1U << 8);  ///< Word Complete Flag
        constexpr uint32_t FCF = (1U << 9);  ///< Frame Complete Flag
        constexpr uint32_t TCF = (1U << 10);  ///< Transfer Complete Flag
        constexpr uint32_t TEF = (1U << 11);  ///< Transmit Error Flag
        constexpr uint32_t REF = (1U << 12);  ///< Receive Error Flag
        constexpr uint32_t DMF = (1U << 13);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Module Busy Flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t WCIE = (1U << 8);  ///< Word Complete Interrupt Enable
        constexpr uint32_t FCIE = (1U << 9);  ///< Frame Complete Interrupt Enable
        constexpr uint32_t TCIE = (1U << 10);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t TEIE = (1U << 11);  ///< Transmit Error Interrupt Enable
        constexpr uint32_t REIE = (1U << 12);  ///< Receive Error Interrupt Enable
        constexpr uint32_t DMIE = (1U << 13);  ///< Data Match Interrupt Enable
    }

    /// DER Register bits
    namespace der_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// CFGR0 Register bits
    namespace cfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t MASTER = (1U << 0);  ///< Master Mode
        constexpr uint32_t SAMPLE = (1U << 1);  ///< Sample Point
        constexpr uint32_t AUTOPCS = (1U << 2);  ///< Automatic PCS
        constexpr uint32_t NOSTALL = (1U << 3);  ///< No Stall
        constexpr uint32_t PCSPOL = (4 << 8);  ///< Peripheral Chip Select Polarity
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (2 << 24);  ///< Pin Configuration
        constexpr uint32_t OUTCFG = (1U << 26);  ///< Output Config
        constexpr uint32_t PCSCFG = (1U << 27);  ///< Peripheral Chip Select Configuration
    }

    /// DMR0 Register bits
    namespace dmr0_bits {
        constexpr uint32_t MATCH0 = (32 << 0);  ///< Match 0 Value
    }

    /// DMR1 Register bits
    namespace dmr1_bits {
        constexpr uint32_t MATCH1 = (32 << 0);  ///< Match 1 Value
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t SCKDIV = (8 << 0);  ///< SCK Divider
        constexpr uint32_t DBT = (8 << 8);  ///< Delay Between Transfers
        constexpr uint32_t PCSSCK = (8 << 16);  ///< PCS to SCK Delay
        constexpr uint32_t SCKPCS = (8 << 24);  ///< SCK to PCS Delay
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// FSR Register bits
    namespace fsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t FRAMESZ = (12 << 0);  ///< Frame Size
        constexpr uint32_t WIDTH = (2 << 16);  ///< Transfer Width
        constexpr uint32_t TXMSK = (1U << 18);  ///< Transmit Data Mask
        constexpr uint32_t RXMSK = (1U << 19);  ///< Receive Data Mask
        constexpr uint32_t CONTC = (1U << 20);  ///< Continuing Command
        constexpr uint32_t CONT = (1U << 21);  ///< Continuous Transfer
        constexpr uint32_t BYSW = (1U << 22);  ///< Byte Swap
        constexpr uint32_t LSBF = (1U << 23);  ///< LSB First
        constexpr uint32_t PCS = (2 << 24);  ///< Peripheral Chip Select
        constexpr uint32_t PRESCALE = (3 << 27);  ///< Prescaler Value
        constexpr uint32_t CPHA = (1U << 30);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 31);  ///< Clock Polarity
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Transmit Data
    }

    /// RSR Register bits
    namespace rsr_bits {
        constexpr uint32_t SOF = (1U << 0);  ///< Start Of Frame
        constexpr uint32_t RXEMPTY = (1U << 1);  ///< RX FIFO Empty
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// PDB0 Peripheral
// ============================================================================

namespace pdb0 {
    /// Base addresses
    constexpr uint32_t PDB0_BASE = 0x40036000;

    /// PDB0 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CH%sC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CH%sS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CH%sDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CH%sDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t CH%sDLY2;  ///< Offset: 0x20 - Channel n Delay 2 register
        volatile uint32_t CH%sDLY3;  ///< Offset: 0x24 - Channel n Delay 3 register
        volatile uint32_t CH%sDLY4;  ///< Offset: 0x28 - Channel n Delay 4 register
        volatile uint32_t CH%sDLY5;  ///< Offset: 0x2C - Channel n Delay 5 register
        volatile uint32_t CH%sDLY6;  ///< Offset: 0x30 - Channel n Delay 6 register
        volatile uint32_t CH%sDLY7;  ///< Offset: 0x34 - Channel n Delay 7 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register
    };

    /// Peripheral instances
    inline Registers* PDB0 = reinterpret_cast<Registers*>(PDB0_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CH%sC1 Register bits
    namespace ch%sc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CH%sS Register bits
    namespace ch%ss_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CH%sDLY0 Register bits
    namespace ch%sdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY1 Register bits
    namespace ch%sdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY2 Register bits
    namespace ch%sdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY3 Register bits
    namespace ch%sdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY4 Register bits
    namespace ch%sdly4_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY5 Register bits
    namespace ch%sdly5_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY6 Register bits
    namespace ch%sdly6_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY7 Register bits
    namespace ch%sdly7_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT = (16 << 0);  ///< DAC Interval
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB1 Peripheral
// ============================================================================

namespace pdb1 {
    /// Base addresses
    constexpr uint32_t PDB1_BASE = 0x40031000;

    /// PDB1 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CH%sC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CH%sS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CH%sDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CH%sDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t CH%sDLY2;  ///< Offset: 0x20 - Channel n Delay 2 register
        volatile uint32_t CH%sDLY3;  ///< Offset: 0x24 - Channel n Delay 3 register
        volatile uint32_t CH%sDLY4;  ///< Offset: 0x28 - Channel n Delay 4 register
        volatile uint32_t CH%sDLY5;  ///< Offset: 0x2C - Channel n Delay 5 register
        volatile uint32_t CH%sDLY6;  ///< Offset: 0x30 - Channel n Delay 6 register
        volatile uint32_t CH%sDLY7;  ///< Offset: 0x34 - Channel n Delay 7 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register
    };

    /// Peripheral instances
    inline Registers* PDB1 = reinterpret_cast<Registers*>(PDB1_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CH%sC1 Register bits
    namespace ch%sc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CH%sS Register bits
    namespace ch%ss_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CH%sDLY0 Register bits
    namespace ch%sdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY1 Register bits
    namespace ch%sdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY2 Register bits
    namespace ch%sdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY3 Register bits
    namespace ch%sdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY4 Register bits
    namespace ch%sdly4_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY5 Register bits
    namespace ch%sdly5_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY6 Register bits
    namespace ch%sdly6_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY7 Register bits
    namespace ch%sdly7_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT = (16 << 0);  ///< DAC Interval
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// PDB2 Peripheral
// ============================================================================

namespace pdb2 {
    /// Base addresses
    constexpr uint32_t PDB2_BASE = 0x40033000;

    /// PDB2 Register structure
    struct Registers {
        volatile uint32_t SC;  ///< Offset: 0x00 - Status and Control register
        volatile uint32_t MOD;  ///< Offset: 0x04 - Modulus register
        volatile uint32_t CNT;  ///< Offset: 0x08 - Counter register
        volatile uint32_t IDLY;  ///< Offset: 0x0C - Interrupt Delay register
        volatile uint32_t CH%sC1;  ///< Offset: 0x10 - Channel n Control register 1
        volatile uint32_t CH%sS;  ///< Offset: 0x14 - Channel n Status register
        volatile uint32_t CH%sDLY0;  ///< Offset: 0x18 - Channel n Delay 0 register
        volatile uint32_t CH%sDLY1;  ///< Offset: 0x1C - Channel n Delay 1 register
        volatile uint32_t CH%sDLY2;  ///< Offset: 0x20 - Channel n Delay 2 register
        volatile uint32_t CH%sDLY3;  ///< Offset: 0x24 - Channel n Delay 3 register
        volatile uint32_t CH%sDLY4;  ///< Offset: 0x28 - Channel n Delay 4 register
        volatile uint32_t CH%sDLY5;  ///< Offset: 0x2C - Channel n Delay 5 register
        volatile uint32_t CH%sDLY6;  ///< Offset: 0x30 - Channel n Delay 6 register
        volatile uint32_t CH%sDLY7;  ///< Offset: 0x34 - Channel n Delay 7 register
        volatile uint32_t DACINTC;  ///< Offset: 0x150 - DAC Interval Trigger n Control register
        volatile uint32_t DACINT;  ///< Offset: 0x154 - DAC Interval n register
        volatile uint32_t POEN;  ///< Offset: 0x190 - Pulse-Out n Enable register
        volatile uint32_t PODLY;  ///< Offset: 0x194 - Pulse-Out n Delay register
    };

    /// Peripheral instances
    inline Registers* PDB2 = reinterpret_cast<Registers*>(PDB2_BASE);

    // Bit definitions
    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LDOK = (1U << 0);  ///< Load OK
        constexpr uint32_t CONT = (1U << 1);  ///< Continuous Mode Enable
        constexpr uint32_t MULT = (2 << 2);  ///< Multiplication Factor Select for Prescaler
        constexpr uint32_t PDBIE = (1U << 5);  ///< PDB Interrupt Enable
        constexpr uint32_t PDBIF = (1U << 6);  ///< PDB Interrupt Flag
        constexpr uint32_t PDBEN = (1U << 7);  ///< PDB Enable
        constexpr uint32_t TRGSEL = (4 << 8);  ///< Trigger Input Source Select
        constexpr uint32_t PRESCALER = (3 << 12);  ///< Prescaler Divider Select
        constexpr uint32_t DMAEN = (1U << 15);  ///< DMA Enable
        constexpr uint32_t SWTRIG = (1U << 16);  ///< Software Trigger
        constexpr uint32_t PDBEIE = (1U << 17);  ///< PDB Sequence Error Interrupt Enable
        constexpr uint32_t LDMOD = (2 << 18);  ///< Load Mode Select
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< PDB Modulus
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< PDB Counter
    }

    /// IDLY Register bits
    namespace idly_bits {
        constexpr uint32_t IDLY = (16 << 0);  ///< PDB Interrupt Delay
    }

    /// CH%sC1 Register bits
    namespace ch%sc1_bits {
        constexpr uint32_t EN = (8 << 0);  ///< PDB Channel Pre-Trigger Enable
        constexpr uint32_t TOS = (8 << 8);  ///< PDB Channel Pre-Trigger Output Select
        constexpr uint32_t BB = (8 << 16);  ///< PDB Channel Pre-Trigger Back-to-Back Operation Enable
    }

    /// CH%sS Register bits
    namespace ch%ss_bits {
        constexpr uint32_t ERR = (8 << 0);  ///< PDB Channel Sequence Error Flags
        constexpr uint32_t CF = (8 << 16);  ///< PDB Channel Flags
    }

    /// CH%sDLY0 Register bits
    namespace ch%sdly0_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY1 Register bits
    namespace ch%sdly1_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY2 Register bits
    namespace ch%sdly2_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY3 Register bits
    namespace ch%sdly3_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY4 Register bits
    namespace ch%sdly4_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY5 Register bits
    namespace ch%sdly5_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY6 Register bits
    namespace ch%sdly6_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// CH%sDLY7 Register bits
    namespace ch%sdly7_bits {
        constexpr uint32_t DLY = (16 << 0);  ///< PDB Channel Delay
    }

    /// DACINTC Register bits
    namespace dacintc_bits {
        constexpr uint32_t TOE = (1U << 0);  ///< DAC Interval Trigger Enable
        constexpr uint32_t EXT = (1U << 1);  ///< DAC External Trigger Input Enable
    }

    /// DACINT Register bits
    namespace dacint_bits {
        constexpr uint32_t INT = (16 << 0);  ///< DAC Interval
    }

    /// POEN Register bits
    namespace poen_bits {
        constexpr uint32_t POEN = (8 << 0);  ///< PDB Pulse-Out Enable
    }

    /// PODLY Register bits
    namespace podly_bits {
        constexpr uint32_t DLY2 = (16 << 0);  ///< PDB Pulse-Out Delay 2
        constexpr uint32_t DLY1 = (16 << 16);  ///< PDB Pulse-Out Delay 1
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPIT0_BASE = 0x40037000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x08 - Module Control Register
        volatile uint32_t MSR;  ///< Offset: 0x0C - Module Status Register
        volatile uint32_t MIER;  ///< Offset: 0x10 - Module Interrupt Enable Register
        volatile uint32_t SETTEN;  ///< Offset: 0x14 - Set Timer Enable Register
        volatile uint32_t CLRTEN;  ///< Offset: 0x18 - Clear Timer Enable Register
        volatile uint32_t TVAL%s;  ///< Offset: 0x20 - Timer Value Register
        volatile uint32_t CVAL%s;  ///< Offset: 0x24 - Current Timer Value
        volatile uint32_t TCTRL%s;  ///< Offset: 0x28 - Timer Control Register
    };

    /// Peripheral instances
    inline Registers* LPIT0 = reinterpret_cast<Registers*>(LPIT0_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CHANNEL = (8 << 0);  ///< Number of Timer Channels
        constexpr uint32_t EXT_TRIG = (8 << 8);  ///< Number of External Trigger Inputs
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t M_CEN = (1U << 0);  ///< Module Clock Enable
        constexpr uint32_t SW_RST = (1U << 1);  ///< Software Reset Bit
        constexpr uint32_t DOZE_EN = (1U << 2);  ///< DOZE Mode Enable Bit
        constexpr uint32_t DBG_EN = (1U << 3);  ///< Debug Enable Bit
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TIF0 = (1U << 0);  ///< Channel 0 Timer Interrupt Flag
        constexpr uint32_t TIF1 = (1U << 1);  ///< Channel 1 Timer Interrupt Flag
        constexpr uint32_t TIF2 = (1U << 2);  ///< Channel 2 Timer Interrupt Flag
        constexpr uint32_t TIF3 = (1U << 3);  ///< Channel 3 Timer Interrupt Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TIE0 = (1U << 0);  ///< Channel 0 Timer Interrupt Enable
        constexpr uint32_t TIE1 = (1U << 1);  ///< Channel 1 Timer Interrupt Enable
        constexpr uint32_t TIE2 = (1U << 2);  ///< Channel 2 Timer Interrupt Enable
        constexpr uint32_t TIE3 = (1U << 3);  ///< Channel 3 Timer Interrupt Enable
    }

    /// SETTEN Register bits
    namespace setten_bits {
        constexpr uint32_t SET_T_EN_0 = (1U << 0);  ///< Set Timer 0 Enable
        constexpr uint32_t SET_T_EN_1 = (1U << 1);  ///< Set Timer 1 Enable
        constexpr uint32_t SET_T_EN_2 = (1U << 2);  ///< Set Timer 2 Enable
        constexpr uint32_t SET_T_EN_3 = (1U << 3);  ///< Set Timer 3 Enable
    }

    /// CLRTEN Register bits
    namespace clrten_bits {
        constexpr uint32_t CLR_T_EN_0 = (1U << 0);  ///< Clear Timer 0 Enable
        constexpr uint32_t CLR_T_EN_1 = (1U << 1);  ///< Clear Timer 1 Enable
        constexpr uint32_t CLR_T_EN_2 = (1U << 2);  ///< Clear Timer 2 Enable
        constexpr uint32_t CLR_T_EN_3 = (1U << 3);  ///< Clear Timer 3 Enable
    }

    /// TVAL%s Register bits
    namespace tval%s_bits {
        constexpr uint32_t TMR_VAL = (32 << 0);  ///< Timer Value
    }

    /// CVAL%s Register bits
    namespace cval%s_bits {
        constexpr uint32_t TMR_CUR_VAL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL%s Register bits
    namespace tctrl%s_bits {
        constexpr uint32_t T_EN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t CHAIN = (1U << 1);  ///< Chain Channel
        constexpr uint32_t MODE = (2 << 2);  ///< Timer Operation Mode
        constexpr uint32_t TSOT = (1U << 16);  ///< Timer Start On Trigger
        constexpr uint32_t TSOI = (1U << 17);  ///< Timer Stop On Interrupt
        constexpr uint32_t TROT = (1U << 18);  ///< Timer Reload On Trigger
        constexpr uint32_t TRG_SRC = (1U << 23);  ///< Trigger Source
        constexpr uint32_t TRG_SEL = (4 << 24);  ///< Trigger Select
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t CPS = (1U << 5);  ///< Clock Pin Select
        constexpr uint32_t LPOS = (1U << 7);  ///< LPO Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t CPE = (2 << 24);  ///< Clock Pin Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
        constexpr uint32_t TSIC = (3 << 16);  ///< Timer Seconds Interrupt Configuration
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAT%s;  ///< Offset: 0x00 - DAC Data Register
        volatile uint32_t STATCTRL;  ///< Offset: 0x20 - DAC Status and Control Register
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DAT%s Register bits
    namespace dat%s_bits {
        constexpr uint32_t DATA0 = (12 << 0);  ///< DATA0
        constexpr uint32_t DATA1 = (12 << 16);  ///< DATA1
    }

    /// STATCTRL Register bits
    namespace statctrl_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
        constexpr uint32_t DACBBIEN = (1U << 8);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 9);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 10);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 11);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 12);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 13);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 14);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t DACBFEN = (1U << 16);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 17);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 19);  ///< DAC Buffer Watermark Select
        constexpr uint32_t TESTOUTEN = (1U << 21);  ///< DAC test output enable
        constexpr uint32_t BFOUTEN = (1U << 22);  ///< DAC output buffer enable
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Enable Select
        constexpr uint32_t DACBFUP = (4 << 24);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 28);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40048000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t CHIPCTL;  ///< Offset: 0x04 - Chip Control register
        volatile uint32_t FTMOPT0;  ///< Offset: 0x0C - FTM Option Register 0
        volatile uint32_t ADCOPT;  ///< Offset: 0x18 - ADC Options Register
        volatile uint32_t FTMOPT1;  ///< Offset: 0x1C - FTM Option Register 1
        volatile uint32_t SDID;  ///< Offset: 0x24 - System Device Identification Register
        volatile uint32_t PLATCGC;  ///< Offset: 0x40 - Platform Clock Gating Control Register
        volatile uint32_t FCFG1;  ///< Offset: 0x4C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x50 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x54 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x58 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x5C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x60 - Unique Identification Register Low
        volatile uint32_t CLKDIV4;  ///< Offset: 0x68 - System Clock Divider Register 4
        volatile uint32_t MISCTRL;  ///< Offset: 0x6C - Miscellaneous Control register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// CHIPCTL Register bits
    namespace chipctl_bits {
        constexpr uint32_t ADC_INTERLEAVE_EN = (4 << 0);  ///< ADC interleave channel enable
        constexpr uint32_t CLKOUTDIV = (2 << 4);  ///< CLKOUT divider
        constexpr uint32_t CLKOUTSEL = (2 << 6);  ///< CLKOUT Select
        constexpr uint32_t TRACECLK_SEL = (1U << 12);  ///< Debug trace clock select
        constexpr uint32_t PDB_BB_SEL = (1U << 13);  ///< PDB back-to-back select
        constexpr uint32_t CAN_FLT_CLK_SEL = (1U << 15);  ///< CAN filter clock select
        constexpr uint32_t PWT_CLKSEL = (2 << 16);  ///< PWT clock select
        constexpr uint32_t RTC_CLKSEL = (2 << 18);  ///< RTC clock select
    }

    /// FTMOPT0 Register bits
    namespace ftmopt0_bits {
        constexpr uint32_t FTM0FLTxSEL = (3 << 0);  ///< FTM0 Fault X Select
        constexpr uint32_t FTM1FLTxSEL = (3 << 4);  ///< FTM1 Fault X Select
        constexpr uint32_t FTM2FLTxSEL = (3 << 8);  ///< FTM2 Fault X Select
        constexpr uint32_t FTM3FLTxSEL = (3 << 12);  ///< FTM3 Fault X Select
        constexpr uint32_t FTM0CLKSEL = (2 << 24);  ///< FTM0 External Clock Pin Select
        constexpr uint32_t FTM1CLKSEL = (2 << 26);  ///< FTM1 External Clock Pin Select
        constexpr uint32_t FTM2CLKSEL = (2 << 28);  ///< FTM2 External Clock Pin Select
        constexpr uint32_t FTM3CLKSEL = (2 << 30);  ///< FTM3 External Clock Pin Select
    }

    /// ADCOPT Register bits
    namespace adcopt_bits {
        constexpr uint32_t ADC0TRGSEL = (1U << 0);  ///< ADC0 trigger source select
        constexpr uint32_t ADC0SWPRETRG = (3 << 1);  ///< ADC0 software pre-trigger sources
        constexpr uint32_t ADC0PRETRGSEL = (2 << 4);  ///< ADC0 pre-trigger source select
        constexpr uint32_t ADC1TRGSEL = (1U << 8);  ///< ADC1 trigger source select
        constexpr uint32_t ADC1SWPRETRG = (3 << 9);  ///< ADC1 software pre-trigger sources
        constexpr uint32_t ADC1PRETRGSEL = (2 << 12);  ///< ADC1 pre-trigger source select
        constexpr uint32_t ADC2TRGSEL = (1U << 16);  ///< ADC2 trigger source select
        constexpr uint32_t ADC2SWPRETRG = (3 << 17);  ///< ADC2 software pre-trigger sources
        constexpr uint32_t ADC2PRETRGSEL = (2 << 20);  ///< ADC2 pre-trigger source select
    }

    /// FTMOPT1 Register bits
    namespace ftmopt1_bits {
        constexpr uint32_t FTM0SYNCBIT = (1U << 0);  ///< FTM0 Sync Bit
        constexpr uint32_t FTM1SYNCBIT = (1U << 1);  ///< FTM1 Sync Bit
        constexpr uint32_t FTM2SYNCBIT = (1U << 2);  ///< FTM2 Sync Bit
        constexpr uint32_t FTM3SYNCBIT = (1U << 3);  ///< FTM3 Sync Bit
        constexpr uint32_t FTM1CH0SEL = (2 << 4);  ///< FTM1 CH0 Select
        constexpr uint32_t FTM2CH0SEL = (2 << 6);  ///< FTM2 CH0 Select
        constexpr uint32_t FTM2CH1SEL = (1U << 8);  ///< FTM2 CH1 Select
        constexpr uint32_t FTM0_OUTSEL = (8 << 16);  ///< FTM0 channel modulation select with FTM1_CH1
        constexpr uint32_t FTM3_OUTSEL = (8 << 24);  ///< FTM3 channel modulation select with FTM2_CH1
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (7 << 0);  ///< Pin identification
        constexpr uint32_t PROJECTID = (5 << 7);  ///< Project ID
        constexpr uint32_t REVID = (4 << 12);  ///< Device revision number
        constexpr uint32_t RAMSIZE = (4 << 16);  ///< RAM size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis E-series Sub-Family ID
        constexpr uint32_t FAMILYID = (4 << 28);  ///< Kinetis E-series Family ID
    }

    /// PLATCGC Register bits
    namespace platcgc_bits {
        constexpr uint32_t CGCMSCM = (1U << 0);  ///< MSCM Clock Gating Control
        constexpr uint32_t CGCMPU = (1U << 1);  ///< MPU Clock Gating Control
        constexpr uint32_t CGCDMA = (1U << 2);  ///< DMA Clock Gating Control
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t DEPART = (4 << 12);  ///< FlexNVM partition
        constexpr uint32_t EEERAMSIZE = (4 << 16);  ///< EEE SRAM SIZE
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
        constexpr uint32_t NVMSIZE = (4 << 28);  ///< FlexNVM size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< Max address block 1
        constexpr uint32_t PFLSHEN = (1U << 23);  ///< Program Flash Enable bit
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
        constexpr uint32_t PFLASHSWAP = (1U << 31);  ///< Program Flash Swap bit
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID127_96 = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID95_64 = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID63_32 = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID31_0 = (32 << 0);  ///< Unique Identification
    }

    /// CLKDIV4 Register bits
    namespace clkdiv4_bits {
        constexpr uint32_t TRACEFRAC = (1U << 0);  ///< Trace clock divider fraction To configure TRACEDIV and TRACEFRAC, the user must clear TRACEDIVEN at first to disable the trace clock divide function.
        constexpr uint32_t TRACEDIV = (3 << 1);  ///< Trace clock divider divisor To configure TRACEDIV, the user must disable TRACEDIVEN at first, and then enable it after setting TRACEDIV.
        constexpr uint32_t TRACEDIVEN = (1U << 28);  ///< Debug Trace Divider Control
    }

    /// MISCTRL Register bits
    namespace misctrl_bits {
        constexpr uint32_t SW_TRG = (1U << 0);  ///< Software Trigger bit to TRGMUX
        constexpr uint32_t SW_INTERRUPT = (1U << 16);  ///< Software Interrupt
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
        volatile uint32_t DFER;  ///< Offset: 0xC0 - Digital Filter Enable Register
        volatile uint32_t DFCR;  ///< Offset: 0xC4 - Digital Filter Clock Register
        volatile uint32_t DFWR;  ///< Offset: 0xC8 - Digital Filter Width Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

    /// DFER Register bits
    namespace dfer_bits {
        constexpr uint32_t DFE = (32 << 0);  ///< Digital Filter Enable
    }

    /// DFCR Register bits
    namespace dfcr_bits {
        constexpr uint32_t CS = (1U << 0);  ///< Clock Source
    }

    /// DFWR Register bits
    namespace dfwr_bits {
        constexpr uint32_t FILT = (5 << 0);  ///< Filter Length
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT = (1U << 6);  ///< Watchdog Interrupt
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t RCS = (1U << 10);  ///< Reconfiguration Success
        constexpr uint32_t ULK = (1U << 11);  ///< Unlock status
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog prescaler
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (or 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// PWT Peripheral
// ============================================================================

namespace pwt {
    /// Base addresses
    constexpr uint32_t PWT_BASE = 0x40056000;

    /// PWT Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Pulse Width Timer Control and Status Register
        volatile uint32_t CR;  ///< Offset: 0x01 - Pulse Width Timer Control Register
        volatile uint32_t PPH;  ///< Offset: 0x02 - Pulse Width Timer Positive Pulse Width Register: High
        volatile uint32_t PPL;  ///< Offset: 0x03 - Pulse Width Timer Positive Pulse Width Register: Loq
        volatile uint32_t NPH;  ///< Offset: 0x04 - Pulse Width Timer Negative Pulse Width Register: High
        volatile uint32_t NPL;  ///< Offset: 0x05 - Pulse Width Timer Negative Pulse Width Register: Low
        volatile uint32_t CNTH;  ///< Offset: 0x06 - Pulse Width Timer Counter Register: High
        volatile uint32_t CNTL;  ///< Offset: 0x07 - Pulse Width Timer Counter Register: Low
    };

    /// Peripheral instances
    inline Registers* PWT = reinterpret_cast<Registers*>(PWT_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t PWTOV = (1U << 0);  ///< PWT Counter Overflow
        constexpr uint32_t PWTRDY = (1U << 1);  ///< PWT Pulse Width Valid
        constexpr uint32_t FCTLE = (1U << 2);  ///< First counter load enable after enable
        constexpr uint32_t PWTSR = (1U << 3);  ///< PWT Soft Reset
        constexpr uint32_t POVIE = (1U << 4);  ///< PWT Counter Overflow Interrupt Enable
        constexpr uint32_t PRDYIE = (1U << 5);  ///< PWT Pulse Width Data Ready Interrupt Enable
        constexpr uint32_t PWTIE = (1U << 6);  ///< PWT Module Interrupt Enable
        constexpr uint32_t PWTEN = (1U << 7);  ///< PWT Module Enable
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t PRE = (3 << 0);  ///< PWT Clock Prescaler (CLKPRE) Setting
        constexpr uint32_t LVL = (1U << 3);  ///< PWTIN Level when Overflows
        constexpr uint32_t TGL = (1U << 4);  ///< PWTIN states Toggled from last state
        constexpr uint32_t PINSEL = (2 << 5);  ///< PWT Pulse Inputs Selection
        constexpr uint32_t PCLKS = (1U << 7);  ///< PWT Clock Source Selection
    }

    /// PPH Register bits
    namespace pph_bits {
        constexpr uint32_t PPWH = (8 << 0);  ///< Positive Pulse Width[15:8]
    }

    /// PPL Register bits
    namespace ppl_bits {
        constexpr uint32_t PPWL = (8 << 0);  ///< Positive Pulse Width[7:0]
    }

    /// NPH Register bits
    namespace nph_bits {
        constexpr uint32_t NPWH = (8 << 0);  ///< Negative Pulse Width[15:8]
    }

    /// NPL Register bits
    namespace npl_bits {
        constexpr uint32_t NPWL = (8 << 0);  ///< Negative Pulse Width[7:0]
    }

    /// CNTH Register bits
    namespace cnth_bits {
        constexpr uint32_t PWTH = (8 << 0);  ///< PWT counter[15:8]
    }

    /// CNTL Register bits
    namespace cntl_bits {
        constexpr uint32_t PWTL = (8 << 0);  ///< PWT counter[7:0]
    }

}

// ============================================================================
// FLEXIO Peripheral
// ============================================================================

namespace flexio {
    /// Base addresses
    constexpr uint32_t FLEXIO_BASE = 0x4005A000;

    /// FLEXIO Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL%s;  ///< Offset: 0x80 - Shifter Control N Register
        volatile uint32_t SHIFTCFG%s;  ///< Offset: 0x100 - Shifter Configuration N Register
        volatile uint32_t SHIFTBUF%s;  ///< Offset: 0x200 - Shifter Buffer N Register
        volatile uint32_t SHIFTBUFBIS%s;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t SHIFTBUFBYS%s;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t SHIFTBUFBBS%s;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t TIMCTL%s;  ///< Offset: 0x400 - Timer Control N Register
        volatile uint32_t TIMCFG%s;  ///< Offset: 0x480 - Timer Configuration N Register
        volatile uint32_t TIMCMP%s;  ///< Offset: 0x500 - Timer Compare N Register
    };

    /// Peripheral instances
    inline Registers* FLEXIO = reinterpret_cast<Registers*>(FLEXIO_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (8 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (4 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (4 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (4 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (4 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (4 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (4 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (4 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL%s Register bits
    namespace shiftctl%s_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (2 << 24);  ///< Timer Select
    }

    /// SHIFTCFG%s Register bits
    namespace shiftcfg%s_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
    }

    /// SHIFTBUF%s Register bits
    namespace shiftbuf%s_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS%s Register bits
    namespace shiftbufbis%s_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS%s Register bits
    namespace shiftbufbys%s_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS%s Register bits
    namespace shiftbufbbs%s_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL%s Register bits
    namespace timctl%s_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (4 << 24);  ///< Trigger Select
    }

    /// TIMCFG%s Register bits
    namespace timcfg%s_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP%s Register bits
    namespace timcmp%s_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

}

// ============================================================================
// OSC32 Peripheral
// ============================================================================

namespace osc32 {
    /// Base addresses
    constexpr uint32_t OSC32_BASE = 0x40060000;

    /// OSC32 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - RTC Oscillator Control Register
    };

    /// Peripheral instances
    inline Registers* OSC32 = reinterpret_cast<Registers*>(OSC32_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ROSCEREFS = (1U << 4);  ///< RTC 32k Oscillator external reference clcok selection
        constexpr uint32_t ROSCSTB = (1U << 5);  ///< RTC 32k Oscillator stable flag
        constexpr uint32_t ROSCSTPEN = (1U << 6);  ///< RTC 32k Oscillator stop mode enable
        constexpr uint32_t ROSCEN = (1U << 7);  ///< RTC 32k Oscillator enable
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM refresh mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum refresh time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum refresh time is required
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power clock source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// TRGMUX0 Peripheral
// ============================================================================

namespace trgmux0 {
    /// Base addresses
    constexpr uint32_t TRGMUX0_BASE = 0x40062000;

    /// TRGMUX0 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_DMAMUX0;  ///< Offset: 0x00 - TRGMUX Register
        volatile uint32_t TRGMUX_EXTOUT0;  ///< Offset: 0x04 - TRGMUX Register
        volatile uint32_t TRGMUX_EXTOUT1;  ///< Offset: 0x08 - TRGMUX Register
        volatile uint32_t TRGMUX_ADC0;  ///< Offset: 0x0C - TRGMUX Register
        volatile uint32_t TRGMUX_ADC1;  ///< Offset: 0x10 - TRGMUX Register
        volatile uint32_t TRGMUX_ADC2;  ///< Offset: 0x14 - TRGMUX Register
        volatile uint32_t TRGMUX_DAC0;  ///< Offset: 0x18 - TRGMUX Register
        volatile uint32_t TRGMUX_CMP0;  ///< Offset: 0x1C - TRGMUX Register
        volatile uint32_t TRGMUX_CMP1;  ///< Offset: 0x20 - TRGMUX Register
        volatile uint32_t TRGMUX_CMP2;  ///< Offset: 0x24 - TRGMUX Register
        volatile uint32_t TRGMUX_FTM0;  ///< Offset: 0x28 - TRGMUX Register
        volatile uint32_t TRGMUX_FTM1;  ///< Offset: 0x2C - TRGMUX Register
        volatile uint32_t TRGMUX_FTM2;  ///< Offset: 0x30 - TRGMUX Register
        volatile uint32_t TRGMUX_FTM3;  ///< Offset: 0x34 - TRGMUX Register
        volatile uint32_t TRGMUX_PDB0;  ///< Offset: 0x38 - TRGMUX Register
        volatile uint32_t TRGMUX_PDB1;  ///< Offset: 0x3C - TRGMUX Register
        volatile uint32_t TRGMUX_PDB2;  ///< Offset: 0x40 - TRGMUX Register
        volatile uint32_t TRGMUX_FLEXIO;  ///< Offset: 0x44 - TRGMUX Register
        volatile uint32_t TRGMUX_LPIT0;  ///< Offset: 0x48 - TRGMUX Register
        volatile uint32_t TRGMUX_LPUART0;  ///< Offset: 0x4C - TRGMUX Register
        volatile uint32_t TRGMUX_LPUART1;  ///< Offset: 0x50 - TRGMUX Register
        volatile uint32_t TRGMUX_LPI2C0;  ///< Offset: 0x54 - TRGMUX Register
        volatile uint32_t TRGMUX_LPI2C1;  ///< Offset: 0x58 - TRGMUX Register
        volatile uint32_t TRGMUX_LPSPI0;  ///< Offset: 0x5C - TRGMUX Register
        volatile uint32_t TRGMUX_LPSPI1;  ///< Offset: 0x60 - TRGMUX Register
        volatile uint32_t TRGMUX_LPTMR0;  ///< Offset: 0x64 - TRGMUX Register
        volatile uint32_t TRGMUX_PWT;  ///< Offset: 0x6C - TRGMUX Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX0 = reinterpret_cast<Registers*>(TRGMUX0_BASE);

    // Bit definitions
    /// TRGMUX_DMAMUX0 Register bits
    namespace trgmux_dmamux0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_EXTOUT0 Register bits
    namespace trgmux_extout0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_EXTOUT1 Register bits
    namespace trgmux_extout1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC0 Register bits
    namespace trgmux_adc0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC1 Register bits
    namespace trgmux_adc1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC2 Register bits
    namespace trgmux_adc2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_DAC0 Register bits
    namespace trgmux_dac0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP0 Register bits
    namespace trgmux_cmp0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP1 Register bits
    namespace trgmux_cmp1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP2 Register bits
    namespace trgmux_cmp2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM0 Register bits
    namespace trgmux_ftm0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM1 Register bits
    namespace trgmux_ftm1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM2 Register bits
    namespace trgmux_ftm2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FTM3 Register bits
    namespace trgmux_ftm3_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PDB0 Register bits
    namespace trgmux_pdb0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PDB1 Register bits
    namespace trgmux_pdb1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PDB2 Register bits
    namespace trgmux_pdb2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FLEXIO Register bits
    namespace trgmux_flexio_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPIT0 Register bits
    namespace trgmux_lpit0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART0 Register bits
    namespace trgmux_lpuart0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART1 Register bits
    namespace trgmux_lpuart1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C0 Register bits
    namespace trgmux_lpi2c0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C1 Register bits
    namespace trgmux_lpi2c1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI0 Register bits
    namespace trgmux_lpspi0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI1 Register bits
    namespace trgmux_lpspi1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPTMR0 Register bits
    namespace trgmux_lptmr0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_PWT Register bits
    namespace trgmux_pwt_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// TRGMUX1 Peripheral
// ============================================================================

namespace trgmux1 {
    /// Base addresses
    constexpr uint32_t TRGMUX1_BASE = 0x40063000;

    /// TRGMUX1 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_CTRL0;  ///< Offset: 0x00 - TRGMUX Register
        volatile uint32_t TRGMUX_CTRL1;  ///< Offset: 0x04 - TRGMUX Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX1 = reinterpret_cast<Registers*>(TRGMUX1_BASE);

    // Bit definitions
    /// TRGMUX_CTRL0 Register bits
    namespace trgmux_ctrl0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CTRL1 Register bits
    namespace trgmux_ctrl1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// SCG Peripheral
// ============================================================================

namespace scg {
    /// Base addresses
    constexpr uint32_t SCG_BASE = 0x40064000;

    /// SCG Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CSR;  ///< Offset: 0x10 - Clock Status Register
        volatile uint32_t RCCR;  ///< Offset: 0x14 - Run Clock Control Register
        volatile uint32_t VCCR;  ///< Offset: 0x18 - VLPR Clock Control Register
        volatile uint32_t HCCR;  ///< Offset: 0x1C - HSRUN Clock Control Register
        volatile uint32_t CLKOUTCNFG;  ///< Offset: 0x20 - SCG CLKOUT Configuration Register
        volatile uint32_t SOSCCSR;  ///< Offset: 0x100 - System OSC Control Status Register
        volatile uint32_t SOSCDIV;  ///< Offset: 0x104 - System OSC Divide Register
        volatile uint32_t SOSCCFG;  ///< Offset: 0x108 - System Oscillator Configuration Register
        volatile uint32_t SIRCCSR;  ///< Offset: 0x200 - Slow IRC Control Status Register
        volatile uint32_t SIRCDIV;  ///< Offset: 0x204 - Slow IRC Divide Register
        volatile uint32_t SIRCCFG;  ///< Offset: 0x208 - Slow IRC Configuration Register
        volatile uint32_t FIRCCSR;  ///< Offset: 0x300 - Fast IRC Control Status Register
        volatile uint32_t FIRCDIV;  ///< Offset: 0x304 - Fast IRC Divide Register
        volatile uint32_t FIRCCFG;  ///< Offset: 0x308 - Fast IRC Configuration Register
        volatile uint32_t FIRCTCFG;  ///< Offset: 0x30C - Fast IRC Trim Configuration Register
        volatile uint32_t FIRCSTAT;  ///< Offset: 0x318 - Fast IRC Status Register
        volatile uint32_t SPLLCSR;  ///< Offset: 0x600 - System PLL Control Status Register
        volatile uint32_t SPLLDIV;  ///< Offset: 0x604 - System PLL Divide Register
        volatile uint32_t SPLLCFG;  ///< Offset: 0x608 - System PLL Configuration Register
    };

    /// Peripheral instances
    inline Registers* SCG = reinterpret_cast<Registers*>(SCG_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSION = (32 << 0);  ///< SCG Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CLKPRES = (8 << 0);  ///< Clock Present
        constexpr uint32_t DIVPRES = (5 << 27);  ///< Divider Present
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVBUS = (4 << 4);  ///< Bus Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVBUS = (4 << 4);  ///< Bus Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// VCCR Register bits
    namespace vccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVBUS = (4 << 4);  ///< Bus Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// HCCR Register bits
    namespace hccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVBUS = (4 << 4);  ///< Bus Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// CLKOUTCNFG Register bits
    namespace clkoutcnfg_bits {
        constexpr uint32_t CLKOUTSEL = (4 << 24);  ///< SCG Clkout Select
    }

    /// SOSCCSR Register bits
    namespace sosccsr_bits {
        constexpr uint32_t SOSCEN = (1U << 0);  ///< System OSC Enable
        constexpr uint32_t SOSCSTEN = (1U << 1);  ///< System OSC Stop Enable
        constexpr uint32_t SOSCLPEN = (1U << 2);  ///< System OSC Low Power Enable
        constexpr uint32_t SOSCERCLKEN = (1U << 3);  ///< System OSC 3V ERCLK Enable
        constexpr uint32_t SOSCCM = (1U << 16);  ///< System OSC Clock Monitor
        constexpr uint32_t SOSCCMRE = (1U << 17);  ///< System OSC Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SOSCVLD = (1U << 24);  ///< System OSC Valid
        constexpr uint32_t SOSCSEL = (1U << 25);  ///< System OSC Selected
        constexpr uint32_t SOSCERR = (1U << 26);  ///< System OSC Clock Error
    }

    /// SOSCDIV Register bits
    namespace soscdiv_bits {
        constexpr uint32_t SOSCDIV1 = (3 << 0);  ///< System OSC Clock Divide 1
        constexpr uint32_t SOSCDIV2 = (3 << 8);  ///< System OSC Clock Divide 2
    }

    /// SOSCCFG Register bits
    namespace sosccfg_bits {
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< System OSC Range Select
    }

    /// SIRCCSR Register bits
    namespace sirccsr_bits {
        constexpr uint32_t SIRCEN = (1U << 0);  ///< Slow IRC Enable
        constexpr uint32_t SIRCSTEN = (1U << 1);  ///< Slow IRC Stop Enable
        constexpr uint32_t SIRCLPEN = (1U << 2);  ///< Slow IRC Low Power Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SIRCVLD = (1U << 24);  ///< Slow IRC Valid
        constexpr uint32_t SIRCSEL = (1U << 25);  ///< Slow IRC Selected
    }

    /// SIRCDIV Register bits
    namespace sircdiv_bits {
        constexpr uint32_t SIRCDIV1 = (3 << 0);  ///< Slow IRC Clock Divide 1
        constexpr uint32_t SIRCDIV2 = (3 << 8);  ///< Slow IRC Clock Divide 2
    }

    /// SIRCCFG Register bits
    namespace sirccfg_bits {
        constexpr uint32_t RANGE = (1U << 0);  ///< Frequency Range
    }

    /// FIRCCSR Register bits
    namespace firccsr_bits {
        constexpr uint32_t FIRCEN = (1U << 0);  ///< Fast IRC Enable
        constexpr uint32_t FIRCSTEN = (1U << 1);  ///< Fast IRC Stop Enable
        constexpr uint32_t FIRCLPEN = (1U << 2);  ///< Fast IRC Low Power Enable
        constexpr uint32_t FIRCREGOFF = (1U << 3);  ///< Fast IRC Regulator Enable
        constexpr uint32_t FIRCTREN = (1U << 8);  ///< Fast IRC Trim Enable
        constexpr uint32_t FIRCTRUP = (1U << 9);  ///< Fast IRC Trim Update
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t FIRCVLD = (1U << 24);  ///< Fast IRC Valid status
        constexpr uint32_t FIRCSEL = (1U << 25);  ///< Fast IRC Selected status
        constexpr uint32_t FIRCERR = (1U << 26);  ///< Fast IRC Clock Error
    }

    /// FIRCDIV Register bits
    namespace fircdiv_bits {
        constexpr uint32_t FIRCDIV1 = (3 << 0);  ///< Fast IRC Clock Divide 1
        constexpr uint32_t FIRCDIV2 = (3 << 8);  ///< Fast IRC Clock Divide 2
    }

    /// FIRCCFG Register bits
    namespace firccfg_bits {
        constexpr uint32_t RANGE = (2 << 0);  ///< Frequency Range
    }

    /// FIRCTCFG Register bits
    namespace firctcfg_bits {
        constexpr uint32_t TRIMSRC = (2 << 0);  ///< Trim Source
        constexpr uint32_t TRIMDIV = (3 << 8);  ///< Fast IRC Trim Predivide
    }

    /// FIRCSTAT Register bits
    namespace fircstat_bits {
        constexpr uint32_t TRIMFINE = (7 << 0);  ///< Trim Fine Status
        constexpr uint32_t TRIMCOAR = (6 << 8);  ///< Trim Coarse
    }

    /// SPLLCSR Register bits
    namespace spllcsr_bits {
        constexpr uint32_t SPLLEN = (1U << 0);  ///< System PLL Enable
        constexpr uint32_t SPLLSTEN = (1U << 1);  ///< System PLL Stop Enable
        constexpr uint32_t SPLLCM = (1U << 16);  ///< System PLL Clock Monitor
        constexpr uint32_t SPLLCMRE = (1U << 17);  ///< System PLL Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SPLLVLD = (1U << 24);  ///< System PLL Valid
        constexpr uint32_t SPLLSEL = (1U << 25);  ///< System PLL Selected
        constexpr uint32_t SPLLERR = (1U << 26);  ///< System PLL Clock Error
    }

    /// SPLLDIV Register bits
    namespace splldiv_bits {
        constexpr uint32_t SPLLDIV1 = (3 << 0);  ///< System PLL Clock Divide 1
        constexpr uint32_t SPLLDIV2 = (3 << 8);  ///< System PLL Clock Divide 2
    }

    /// SPLLCFG Register bits
    namespace spllcfg_bits {
        constexpr uint32_t SOURCE = (1U << 0);  ///< Clock Source
        constexpr uint32_t PREDIV = (3 << 8);  ///< PLL Reference Clock Divider
        constexpr uint32_t MULT = (5 << 16);  ///< System PLL Multiplier
    }

}

// ============================================================================
// PCC Peripheral
// ============================================================================

namespace pcc {
    /// Base addresses
    constexpr uint32_t PCC_BASE = 0x40065000;

    /// PCC Register structure
    struct Registers {
        volatile uint32_t PCC_PCC_DMA0;  ///< Offset: 0x20 - PCC Register
        volatile uint32_t PCC_PCC_MPU;  ///< Offset: 0x34 - PCC Register
        volatile uint32_t PCC_PCC_FLASH;  ///< Offset: 0x80 - PCC Register
        volatile uint32_t PCC_PCC_DMAMUX0;  ///< Offset: 0x84 - PCC Register
        volatile uint32_t PCC_PCC_CAN0;  ///< Offset: 0x90 - PCC Register
        volatile uint32_t PCC_PCC_CAN1;  ///< Offset: 0x94 - PCC Register
        volatile uint32_t PCC_PCC_FLEXTMR3;  ///< Offset: 0x98 - PCC Register
        volatile uint32_t PCC_PCC_ADC1;  ///< Offset: 0x9C - PCC Register
        volatile uint32_t PCC_PCC_LPSPI0;  ///< Offset: 0xB0 - PCC Register
        volatile uint32_t PCC_PCC_LPSPI1;  ///< Offset: 0xB4 - PCC Register
        volatile uint32_t PCC_PCC_PDB1;  ///< Offset: 0xC4 - PCC Register
        volatile uint32_t PCC_PCC_CRC;  ///< Offset: 0xC8 - PCC Register
        volatile uint32_t PCC_PCC_PDB2;  ///< Offset: 0xCC - PCC Register
        volatile uint32_t PCC_PCC_PDB0;  ///< Offset: 0xD8 - PCC Register
        volatile uint32_t PCC_PCC_LPIT0;  ///< Offset: 0xDC - PCC Register
        volatile uint32_t PCC_PCC_FLEXTMR0;  ///< Offset: 0xE0 - PCC Register
        volatile uint32_t PCC_PCC_FLEXTMR1;  ///< Offset: 0xE4 - PCC Register
        volatile uint32_t PCC_PCC_FLEXTMR2;  ///< Offset: 0xE8 - PCC Register
        volatile uint32_t PCC_PCC_ADC0;  ///< Offset: 0xEC - PCC Register
        volatile uint32_t PCC_PCC_ADC2;  ///< Offset: 0xF0 - PCC Register
        volatile uint32_t PCC_PCC_RTC;  ///< Offset: 0xF4 - PCC Register
        volatile uint32_t PCC_PCC_DAC0;  ///< Offset: 0xFC - PCC Register
        volatile uint32_t PCC_PCC_LPTMR0;  ///< Offset: 0x100 - PCC Register
        volatile uint32_t PCC_PCC_PORTA;  ///< Offset: 0x124 - PCC Register
        volatile uint32_t PCC_PCC_PORTB;  ///< Offset: 0x128 - PCC Register
        volatile uint32_t PCC_PCC_PORTC;  ///< Offset: 0x12C - PCC Register
        volatile uint32_t PCC_PCC_PORTD;  ///< Offset: 0x130 - PCC Register
        volatile uint32_t PCC_PCC_PORTE;  ///< Offset: 0x134 - PCC Register
        volatile uint32_t PCC_PCC_PWT;  ///< Offset: 0x158 - PCC Register
        volatile uint32_t PCC_PCC_FLEXIO;  ///< Offset: 0x168 - PCC Register
        volatile uint32_t PCC_PCC_OSC32;  ///< Offset: 0x180 - PCC Register
        volatile uint32_t PCC_PCC_EWM;  ///< Offset: 0x184 - PCC Register
        volatile uint32_t PCC_PCC_LPI2C0;  ///< Offset: 0x198 - PCC Register
        volatile uint32_t PCC_PCC_LPI2C1;  ///< Offset: 0x19C - PCC Register
        volatile uint32_t PCC_PCC_LPUART0;  ///< Offset: 0x1A8 - PCC Register
        volatile uint32_t PCC_PCC_LPUART1;  ///< Offset: 0x1AC - PCC Register
        volatile uint32_t PCC_PCC_LPUART2;  ///< Offset: 0x1B0 - PCC Register
        volatile uint32_t PCC_PCC_CMP0;  ///< Offset: 0x1CC - PCC Register
        volatile uint32_t PCC_PCC_CMP1;  ///< Offset: 0x1D0 - PCC Register
        volatile uint32_t PCC_PCC_CMP2;  ///< Offset: 0x1D4 - PCC Register
    };

    /// Peripheral instances
    inline Registers* PCC = reinterpret_cast<Registers*>(PCC_BASE);

    // Bit definitions
    /// PCC_PCC_DMA0 Register bits
    namespace pcc_pcc_dma0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_MPU Register bits
    namespace pcc_pcc_mpu_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLASH Register bits
    namespace pcc_pcc_flash_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_DMAMUX0 Register bits
    namespace pcc_pcc_dmamux0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CAN0 Register bits
    namespace pcc_pcc_can0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CAN1 Register bits
    namespace pcc_pcc_can1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLEXTMR3 Register bits
    namespace pcc_pcc_flextmr3_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_ADC1 Register bits
    namespace pcc_pcc_adc1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPSPI0 Register bits
    namespace pcc_pcc_lpspi0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPSPI1 Register bits
    namespace pcc_pcc_lpspi1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PDB1 Register bits
    namespace pcc_pcc_pdb1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CRC Register bits
    namespace pcc_pcc_crc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PDB2 Register bits
    namespace pcc_pcc_pdb2_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PDB0 Register bits
    namespace pcc_pcc_pdb0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPIT0 Register bits
    namespace pcc_pcc_lpit0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLEXTMR0 Register bits
    namespace pcc_pcc_flextmr0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLEXTMR1 Register bits
    namespace pcc_pcc_flextmr1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLEXTMR2 Register bits
    namespace pcc_pcc_flextmr2_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_ADC0 Register bits
    namespace pcc_pcc_adc0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_ADC2 Register bits
    namespace pcc_pcc_adc2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_RTC Register bits
    namespace pcc_pcc_rtc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_DAC0 Register bits
    namespace pcc_pcc_dac0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPTMR0 Register bits
    namespace pcc_pcc_lptmr0_bits {
        constexpr uint32_t PCD = (3 << 0);  ///< Peripheral Clock Divider Select
        constexpr uint32_t FRAC = (1U << 3);  ///< Peripheral Clock Divider Fraction
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PORTA Register bits
    namespace pcc_pcc_porta_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PORTB Register bits
    namespace pcc_pcc_portb_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PORTC Register bits
    namespace pcc_pcc_portc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PORTD Register bits
    namespace pcc_pcc_portd_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PORTE Register bits
    namespace pcc_pcc_porte_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_PWT Register bits
    namespace pcc_pcc_pwt_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_FLEXIO Register bits
    namespace pcc_pcc_flexio_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_OSC32 Register bits
    namespace pcc_pcc_osc32_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_EWM Register bits
    namespace pcc_pcc_ewm_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPI2C0 Register bits
    namespace pcc_pcc_lpi2c0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPI2C1 Register bits
    namespace pcc_pcc_lpi2c1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPUART0 Register bits
    namespace pcc_pcc_lpuart0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPUART1 Register bits
    namespace pcc_pcc_lpuart1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_LPUART2 Register bits
    namespace pcc_pcc_lpuart2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CMP0 Register bits
    namespace pcc_pcc_cmp0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CMP1 Register bits
    namespace pcc_pcc_cmp1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PCC_CMP2 Register bits
    namespace pcc_pcc_cmp2_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C0_BASE = 0x40066000;
    constexpr uint32_t LPI2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x10 - Master Control Register
        volatile uint32_t MSR;  ///< Offset: 0x14 - Master Status Register
        volatile uint32_t MIER;  ///< Offset: 0x18 - Master Interrupt Enable Register
        volatile uint32_t MDER;  ///< Offset: 0x1C - Master DMA Enable Register
        volatile uint32_t MCFGR0;  ///< Offset: 0x20 - Master Configuration Register 0
        volatile uint32_t MCFGR1;  ///< Offset: 0x24 - Master Configuration Register 1
        volatile uint32_t MCFGR2;  ///< Offset: 0x28 - Master Configuration Register 2
        volatile uint32_t MCFGR3;  ///< Offset: 0x2C - Master Configuration Register 3
        volatile uint32_t MDMR;  ///< Offset: 0x40 - Master Data Match Register
        volatile uint32_t MCCR0;  ///< Offset: 0x48 - Master Clock Configuration Register 0
        volatile uint32_t MCCR1;  ///< Offset: 0x50 - Master Clock Configuration Register 1
        volatile uint32_t MFCR;  ///< Offset: 0x58 - Master FIFO Control Register
        volatile uint32_t MFSR;  ///< Offset: 0x5C - Master FIFO Status Register
        volatile uint32_t MTDR;  ///< Offset: 0x60 - Master Transmit Data Register
        volatile uint32_t MRDR;  ///< Offset: 0x70 - Master Receive Data Register
        volatile uint32_t SCR;  ///< Offset: 0x110 - Slave Control Register
        volatile uint32_t SSR;  ///< Offset: 0x114 - Slave Status Register
        volatile uint32_t SIER;  ///< Offset: 0x118 - Slave Interrupt Enable Register
        volatile uint32_t SDER;  ///< Offset: 0x11C - Slave DMA Enable Register
        volatile uint32_t SCFGR1;  ///< Offset: 0x124 - Slave Configuration Register 1
        volatile uint32_t SCFGR2;  ///< Offset: 0x128 - Slave Configuration Register 2
        volatile uint32_t SAMR;  ///< Offset: 0x140 - Slave Address Match Register
        volatile uint32_t SASR;  ///< Offset: 0x150 - Slave Address Status Register
        volatile uint32_t STAR;  ///< Offset: 0x154 - Slave Transmit ACK Register
        volatile uint32_t STDR;  ///< Offset: 0x160 - Slave Transmit Data Register
        volatile uint32_t SRDR;  ///< Offset: 0x170 - Slave Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPI2C0 = reinterpret_cast<Registers*>(LPI2C0_BASE);
    inline Registers* LPI2C1 = reinterpret_cast<Registers*>(LPI2C1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t MTXFIFO = (4 << 0);  ///< Master Transmit FIFO Size
        constexpr uint32_t MRXFIFO = (4 << 8);  ///< Master Receive FIFO Size
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Master Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t EPF = (1U << 8);  ///< End Packet Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t NDF = (1U << 10);  ///< NACK Detect Flag
        constexpr uint32_t ALF = (1U << 11);  ///< Arbitration Lost Flag
        constexpr uint32_t FEF = (1U << 12);  ///< FIFO Error Flag
        constexpr uint32_t PLTF = (1U << 13);  ///< Pin Low Timeout Flag
        constexpr uint32_t DMF = (1U << 14);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Master Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t EPIE = (1U << 8);  ///< End Packet Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t NDIE = (1U << 10);  ///< NACK Detect Interrupt Enable
        constexpr uint32_t ALIE = (1U << 11);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t FEIE = (1U << 12);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t PLTIE = (1U << 13);  ///< Pin Low Timeout Interrupt Enable
        constexpr uint32_t DMIE = (1U << 14);  ///< Data Match Interrupt Enable
    }

    /// MDER Register bits
    namespace mder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// MCFGR0 Register bits
    namespace mcfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// MCFGR1 Register bits
    namespace mcfgr1_bits {
        constexpr uint32_t PRESCALE = (3 << 0);  ///< Prescaler
        constexpr uint32_t AUTOSTOP = (1U << 8);  ///< Automatic STOP Generation
        constexpr uint32_t IGNACK = (1U << 9);  ///< When set, the received NACK field is ignored and assumed to be ACK
        constexpr uint32_t TIMECFG = (1U << 10);  ///< Timeout Configuration
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (3 << 24);  ///< Pin Configuration
    }

    /// MCFGR2 Register bits
    namespace mcfgr2_bits {
        constexpr uint32_t BUSIDLE = (12 << 0);  ///< Bus Idle Timeout
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// MCFGR3 Register bits
    namespace mcfgr3_bits {
        constexpr uint32_t PINLOW = (12 << 8);  ///< Pin Low Timeout
    }

    /// MDMR Register bits
    namespace mdmr_bits {
        constexpr uint32_t MATCH0 = (8 << 0);  ///< Match 0 Value
        constexpr uint32_t MATCH1 = (8 << 16);  ///< Match 1 Value
    }

    /// MCCR0 Register bits
    namespace mccr0_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MCCR1 Register bits
    namespace mccr1_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MFCR Register bits
    namespace mfcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// MFSR Register bits
    namespace mfsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// MTDR Register bits
    namespace mtdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
        constexpr uint32_t CMD = (3 << 8);  ///< Command Data
    }

    /// MRDR Register bits
    namespace mrdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEN = (1U << 0);  ///< Slave Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FILTEN = (1U << 4);  ///< Filter Enable
        constexpr uint32_t FILTDZ = (1U << 5);  ///< Filter Doze Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t AVF = (1U << 2);  ///< Address Valid Flag
        constexpr uint32_t TAF = (1U << 3);  ///< Transmit ACK Flag
        constexpr uint32_t RSF = (1U << 8);  ///< Repeated Start Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t BEF = (1U << 10);  ///< Bit Error Flag
        constexpr uint32_t FEF = (1U << 11);  ///< FIFO Error Flag
        constexpr uint32_t AM0F = (1U << 12);  ///< Address Match 0 Flag
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Flag
        constexpr uint32_t GCF = (1U << 14);  ///< General Call Flag
        constexpr uint32_t SARF = (1U << 15);  ///< SMBus Alert Response Flag
        constexpr uint32_t SBF = (1U << 24);  ///< Slave Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// SIER Register bits
    namespace sier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t AVIE = (1U << 2);  ///< Address Valid Interrupt Enable
        constexpr uint32_t TAIE = (1U << 3);  ///< Transmit ACK Interrupt Enable
        constexpr uint32_t RSIE = (1U << 8);  ///< Repeated Start Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t BEIE = (1U << 10);  ///< Bit Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 11);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t AM0IE = (1U << 12);  ///< Address Match 0 Interrupt Enable
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Interrupt Enable
        constexpr uint32_t GCIE = (1U << 14);  ///< General Call Interrupt Enable
        constexpr uint32_t SARIE = (1U << 15);  ///< SMBus Alert Response Interrupt Enable
    }

    /// SDER Register bits
    namespace sder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
        constexpr uint32_t AVDE = (1U << 2);  ///< Address Valid DMA Enable
    }

    /// SCFGR1 Register bits
    namespace scfgr1_bits {
        constexpr uint32_t ADRSTALL = (1U << 0);  ///< Address SCL Stall
        constexpr uint32_t RXSTALL = (1U << 1);  ///< RX SCL Stall
        constexpr uint32_t TXDSTALL = (1U << 2);  ///< TX Data SCL Stall
        constexpr uint32_t ACKSTALL = (1U << 3);  ///< ACK SCL Stall
        constexpr uint32_t GCEN = (1U << 8);  ///< General Call Enable
        constexpr uint32_t SAEN = (1U << 9);  ///< SMBus Alert Enable
        constexpr uint32_t TXCFG = (1U << 10);  ///< Transmit Flag Configuration
        constexpr uint32_t RXCFG = (1U << 11);  ///< Receive Data Configuration
        constexpr uint32_t IGNACK = (1U << 12);  ///< Ignore NACK
        constexpr uint32_t HSMEN = (1U << 13);  ///< High Speed Mode Enable
        constexpr uint32_t ADDRCFG = (3 << 16);  ///< Address Configuration
    }

    /// SCFGR2 Register bits
    namespace scfgr2_bits {
        constexpr uint32_t CLKHOLD = (4 << 0);  ///< Clock Hold Time
        constexpr uint32_t DATAVD = (6 << 8);  ///< Data Valid Delay
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// SAMR Register bits
    namespace samr_bits {
        constexpr uint32_t ADDR0 = (10 << 1);  ///< Address 0 Value
        constexpr uint32_t ADDR1 = (10 << 17);  ///< Address 1 Value
    }

    /// SASR Register bits
    namespace sasr_bits {
        constexpr uint32_t RADDR = (11 << 0);  ///< Received Address
        constexpr uint32_t ANV = (1U << 14);  ///< Address Not Valid
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t TXNACK = (1U << 0);  ///< Transmit NACK
    }

    /// STDR Register bits
    namespace stdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
    }

    /// SRDR Register bits
    namespace srdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
        constexpr uint32_t SOF = (1U << 15);  ///< Start Of Frame
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x4006A000;
    constexpr uint32_t LPUART1_BASE = 0x4006B000;
    constexpr uint32_t LPUART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - LPUART Global Register
        volatile uint32_t PINCFG;  ///< Offset: 0x0C - LPUART Pin Configuration Register
        volatile uint32_t BAUD;  ///< Offset: 0x10 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x14 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x1C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x20 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x24 - LPUART Modem IrDA Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// PINCFG Register bits
    namespace pincfg_bits {
        constexpr uint32_t TRGSEL = (2 << 0);  ///< Trigger Select
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR = (1U << 19);  ///< Receiver Overrun Flag
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t C0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x04 - CMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x08 - CMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control. See chip data sheet to get the actual hystersis value with each level
        constexpr uint32_t OFFSET = (1U << 2);  ///< Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
        constexpr uint32_t EN = (1U << 8);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 9);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 10);  ///< Comparator Output Select
        constexpr uint32_t INVT = (1U << 11);  ///< Comparator invert
        constexpr uint32_t PMODE = (1U << 12);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 14);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 15);  ///< Sample Enable
        constexpr uint32_t FPR = (8 << 16);  ///< Filter Sample Period
        constexpr uint32_t COUT = (1U << 24);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 25);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 26);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 27);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 28);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t VOSEL = (8 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t MSEL = (3 << 8);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 11);  ///< Plus Input MUX Control
        constexpr uint32_t VRSEL = (1U << 14);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t CHN0 = (1U << 16);  ///< Channel 0 input enable
        constexpr uint32_t CHN1 = (1U << 17);  ///< Channel 1 input enable
        constexpr uint32_t CHN2 = (1U << 18);  ///< Channel 2 input enable
        constexpr uint32_t CHN3 = (1U << 19);  ///< Channel 3 input enable
        constexpr uint32_t CHN4 = (1U << 20);  ///< Channel 4 input enable
        constexpr uint32_t CHN5 = (1U << 21);  ///< Channel 5 input enable
        constexpr uint32_t CHN6 = (1U << 22);  ///< Channel 6 input enable
        constexpr uint32_t CHN7 = (1U << 23);  ///< Channel 7 input enable
        constexpr uint32_t INNSEL = (2 << 24);  ///< Selection of the input to the negative port of the comparator
        constexpr uint32_t INPSEL = (2 << 27);  ///< Selection of the input to the positive port of the comparator
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACOn = (8 << 0);  ///< The result of the input comparison for channel n
        constexpr uint32_t INITMOD = (6 << 8);  ///< Comparator and DAC initialization delay modulus.
        constexpr uint32_t NSAM = (2 << 14);  ///< Number of sample clocks
        constexpr uint32_t CH0F = (1U << 16);  ///< Channel 0 input changed flag
        constexpr uint32_t CH1F = (1U << 17);  ///< Channel 1 input changed flag
        constexpr uint32_t CH2F = (1U << 18);  ///< Channel 2 input changed flag
        constexpr uint32_t CH3F = (1U << 19);  ///< Channel 3 input changed flag
        constexpr uint32_t CH4F = (1U << 20);  ///< Channel 4 input changed flag
        constexpr uint32_t CH5F = (1U << 21);  ///< Channel 5 input changed flag
        constexpr uint32_t CH6F = (1U << 22);  ///< Channel 6 input changed flag
        constexpr uint32_t CH7F = (1U << 23);  ///< Channel 7 input changed flag
        constexpr uint32_t FXMXCH = (3 << 25);  ///< Fixed channel selection
        constexpr uint32_t FXMP = (1U << 29);  ///< Fixed MUX Port
        constexpr uint32_t RRIE = (1U << 30);  ///< Round-Robin interrupt enable
        constexpr uint32_t RRE = (1U << 31);  ///< Round-Robin Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x40074000;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t C0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x04 - CMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x08 - CMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control. See chip data sheet to get the actual hystersis value with each level
        constexpr uint32_t OFFSET = (1U << 2);  ///< Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
        constexpr uint32_t EN = (1U << 8);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 9);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 10);  ///< Comparator Output Select
        constexpr uint32_t INVT = (1U << 11);  ///< Comparator invert
        constexpr uint32_t PMODE = (1U << 12);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 14);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 15);  ///< Sample Enable
        constexpr uint32_t FPR = (8 << 16);  ///< Filter Sample Period
        constexpr uint32_t COUT = (1U << 24);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 25);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 26);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 27);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 28);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t VOSEL = (8 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t MSEL = (3 << 8);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 11);  ///< Plus Input MUX Control
        constexpr uint32_t VRSEL = (1U << 14);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t CHN0 = (1U << 16);  ///< Channel 0 input enable
        constexpr uint32_t CHN1 = (1U << 17);  ///< Channel 1 input enable
        constexpr uint32_t CHN2 = (1U << 18);  ///< Channel 2 input enable
        constexpr uint32_t CHN3 = (1U << 19);  ///< Channel 3 input enable
        constexpr uint32_t CHN4 = (1U << 20);  ///< Channel 4 input enable
        constexpr uint32_t CHN5 = (1U << 21);  ///< Channel 5 input enable
        constexpr uint32_t CHN6 = (1U << 22);  ///< Channel 6 input enable
        constexpr uint32_t CHN7 = (1U << 23);  ///< Channel 7 input enable
        constexpr uint32_t INNSEL = (2 << 24);  ///< Selection of the input to the negative port of the comparator
        constexpr uint32_t INPSEL = (2 << 27);  ///< Selection of the input to the positive port of the comparator
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACOn = (8 << 0);  ///< The result of the input comparison for channel n
        constexpr uint32_t INITMOD = (6 << 8);  ///< Comparator and DAC initialization delay modulus.
        constexpr uint32_t NSAM = (2 << 14);  ///< Number of sample clocks
        constexpr uint32_t CH0F = (1U << 16);  ///< Channel 0 input changed flag
        constexpr uint32_t CH1F = (1U << 17);  ///< Channel 1 input changed flag
        constexpr uint32_t CH2F = (1U << 18);  ///< Channel 2 input changed flag
        constexpr uint32_t CH3F = (1U << 19);  ///< Channel 3 input changed flag
        constexpr uint32_t CH4F = (1U << 20);  ///< Channel 4 input changed flag
        constexpr uint32_t CH5F = (1U << 21);  ///< Channel 5 input changed flag
        constexpr uint32_t CH6F = (1U << 22);  ///< Channel 6 input changed flag
        constexpr uint32_t CH7F = (1U << 23);  ///< Channel 7 input changed flag
        constexpr uint32_t FXMXCH = (3 << 25);  ///< Fixed channel selection
        constexpr uint32_t FXMP = (1U << 29);  ///< Fixed MUX Port
        constexpr uint32_t RRIE = (1U << 30);  ///< Round-Robin interrupt enable
        constexpr uint32_t RRE = (1U << 31);  ///< Round-Robin Enable
    }

}

// ============================================================================
// CMP2 Peripheral
// ============================================================================

namespace cmp2 {
    /// Base addresses
    constexpr uint32_t CMP2_BASE = 0x40075000;

    /// CMP2 Register structure
    struct Registers {
        volatile uint32_t C0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t C1;  ///< Offset: 0x04 - CMP Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x08 - CMP Control Register 2
    };

    /// Peripheral instances
    inline Registers* CMP2 = reinterpret_cast<Registers*>(CMP2_BASE);

    // Bit definitions
    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control. See chip data sheet to get the actual hystersis value with each level
        constexpr uint32_t OFFSET = (1U << 2);  ///< Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
        constexpr uint32_t EN = (1U << 8);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 9);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 10);  ///< Comparator Output Select
        constexpr uint32_t INVT = (1U << 11);  ///< Comparator invert
        constexpr uint32_t PMODE = (1U << 12);  ///< Power Mode Select
        constexpr uint32_t WE = (1U << 14);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 15);  ///< Sample Enable
        constexpr uint32_t FPR = (8 << 16);  ///< Filter Sample Period
        constexpr uint32_t COUT = (1U << 24);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 25);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 26);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 27);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 28);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t VOSEL = (8 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t MSEL = (3 << 8);  ///< Minus Input MUX Control
        constexpr uint32_t PSEL = (3 << 11);  ///< Plus Input MUX Control
        constexpr uint32_t VRSEL = (1U << 14);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 15);  ///< DAC Enable
        constexpr uint32_t CHN0 = (1U << 16);  ///< Channel 0 input enable
        constexpr uint32_t CHN1 = (1U << 17);  ///< Channel 1 input enable
        constexpr uint32_t CHN2 = (1U << 18);  ///< Channel 2 input enable
        constexpr uint32_t CHN3 = (1U << 19);  ///< Channel 3 input enable
        constexpr uint32_t CHN4 = (1U << 20);  ///< Channel 4 input enable
        constexpr uint32_t CHN5 = (1U << 21);  ///< Channel 5 input enable
        constexpr uint32_t CHN6 = (1U << 22);  ///< Channel 6 input enable
        constexpr uint32_t CHN7 = (1U << 23);  ///< Channel 7 input enable
        constexpr uint32_t INNSEL = (2 << 24);  ///< Selection of the input to the negative port of the comparator
        constexpr uint32_t INPSEL = (2 << 27);  ///< Selection of the input to the positive port of the comparator
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t ACOn = (8 << 0);  ///< The result of the input comparison for channel n
        constexpr uint32_t INITMOD = (6 << 8);  ///< Comparator and DAC initialization delay modulus.
        constexpr uint32_t NSAM = (2 << 14);  ///< Number of sample clocks
        constexpr uint32_t CH0F = (1U << 16);  ///< Channel 0 input changed flag
        constexpr uint32_t CH1F = (1U << 17);  ///< Channel 1 input changed flag
        constexpr uint32_t CH2F = (1U << 18);  ///< Channel 2 input changed flag
        constexpr uint32_t CH3F = (1U << 19);  ///< Channel 3 input changed flag
        constexpr uint32_t CH4F = (1U << 20);  ///< Channel 4 input changed flag
        constexpr uint32_t CH5F = (1U << 21);  ///< Channel 5 input changed flag
        constexpr uint32_t CH6F = (1U << 22);  ///< Channel 6 input changed flag
        constexpr uint32_t CH7F = (1U << 23);  ///< Channel 7 input changed flag
        constexpr uint32_t FXMXCH = (3 << 25);  ///< Fixed channel selection
        constexpr uint32_t FXMP = (1U << 29);  ///< Fixed MUX Port
        constexpr uint32_t RRIE = (1U << 30);  ///< Round-Robin interrupt enable
        constexpr uint32_t RRE = (1U << 31);  ///< Round-Robin Enable
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status and Control 1 Register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status and Control 2 Register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status and Control Register
        volatile uint32_t LPOTRIM;  ///< Offset: 0x04 - Low Power Oscillator Trim Register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BIASEN = (1U << 0);  ///< Bias Enable Bit
        constexpr uint32_t CLKBIASDIS = (1U << 1);  ///< Clock Bias Disable Bit
        constexpr uint32_t REGFPM = (1U << 2);  ///< Regulator in Full Performance Mode Status Bit
        constexpr uint32_t LPOSTAT = (1U << 6);  ///< LPO Status Bit
        constexpr uint32_t LPODIS = (1U << 7);  ///< LPO Disable Bit
    }

    /// LPOTRIM Register bits
    namespace lpotrim_bits {
        constexpr uint32_t LPOTRIM = (5 << 0);  ///< LPO trimming bits
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - SMC Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - SMC Parameter Register
        volatile uint32_t PMPROT;  ///< Offset: 0x08 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x0C - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x10 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x14 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t EHSRUN = (1U << 0);  ///< Enable HSRUN
        constexpr uint32_t ELLS = (1U << 3);  ///< Enable LLS (if this mode exists on the SOC)
        constexpr uint32_t ELLS2 = (1U << 5);  ///< Enable LLS2 (if this mode exists on the SOC)
        constexpr uint32_t EVLLS0 = (1U << 6);  ///< Enable VLLS0 (if this mode exists on the SOC)
    }

    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t SRS;  ///< Offset: 0x08 - System Reset Status Register
        volatile uint32_t RPC;  ///< Offset: 0x0C - Reset Pin Control register
        volatile uint32_t MR;  ///< Offset: 0x10 - Mode Register
        volatile uint32_t FM;  ///< Offset: 0x14 - Force Mode Register
        volatile uint32_t SSRS;  ///< Offset: 0x18 - Sticky System Reset Status Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RSTSRC = (32 << 0);  ///< Reset Source
    }

    /// SRS Register bits
    namespace srs_bits {
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset or High-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
        constexpr uint32_t JTAG = (1U << 8);  ///< JTAG generated reset
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 10);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Acknowledge Error
    }

    /// RPC Register bits
    namespace rpc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
        constexpr uint32_t RSTFLTSEL = (5 << 8);  ///< Reset Pin Filter Bus Clock Select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// SSRS Register bits
    namespace ssrs_bits {
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
        constexpr uint32_t SJTAG = (1U << 8);  ///< Sticky JTAG generated reset
        constexpr uint32_t SLOCKUP = (1U << 9);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 10);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 11);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 13);  ///< Sticky Stop Acknowledge Error
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xE0080000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t CPCR;  ///< Offset: 0x0C - Core Platform Control Register
        volatile uint32_t ISCR;  ///< Offset: 0x10 - Interrupt Status and Control Register
        volatile uint32_t FADR;  ///< Offset: 0x20 - Store Buffer Fault address register
        volatile uint32_t FATR;  ///< Offset: 0x24 - Store Buffer Fault Attributes register
        volatile uint32_t FDR;  ///< Offset: 0x28 - Store Buffer Fault Data Register
        volatile uint32_t PID;  ///< Offset: 0x30 - Process ID register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
        volatile uint32_t LMDR%s;  ///< Offset: 0x400 - Local Memory Descriptor Register
        volatile uint32_t LMPECR;  ///< Offset: 0x480 - LMEM Parity & ECC Control Register
        volatile uint32_t LMPEIR;  ///< Offset: 0x488 - LMEM Parity & ECC Interrupt Register
        volatile uint32_t LMFAR;  ///< Offset: 0x490 - LMEM Fault Address Register
        volatile uint32_t LMFATR;  ///< Offset: 0x494 - LMEM Fault Attribute Register
        volatile uint32_t LMFDHR;  ///< Offset: 0x4A0 - LMEM Fault Data High Register
        volatile uint32_t LMFDLR;  ///< Offset: 0x4A4 - LMEM Fault Data Low Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// CPCR Register bits
    namespace cpcr_bits {
        constexpr uint32_t CBRR = (1U << 9);  ///< Crossbar round-robin arbitration enable
        constexpr uint32_t SRAMUAP = (2 << 24);  ///< SRAM_U arbitration priority
        constexpr uint32_t SRAMUWP = (1U << 26);  ///< SRAM_U write protect
        constexpr uint32_t SRAMLAP = (2 << 28);  ///< SRAM_L arbitration priority
        constexpr uint32_t SRAMLWP = (1U << 30);  ///< SRAM_L Write Protect
    }

    /// ISCR Register bits
    namespace iscr_bits {
        constexpr uint32_t CWBER = (1U << 4);  ///< Cache write buffer error status
        constexpr uint32_t FIOC = (1U << 8);  ///< FPU invalid operation interrupt status
        constexpr uint32_t FDZC = (1U << 9);  ///< FPU divide-by-zero interrupt status
        constexpr uint32_t FOFC = (1U << 10);  ///< FPU overflow interrupt status
        constexpr uint32_t FUFC = (1U << 11);  ///< FPU underflow interrupt status
        constexpr uint32_t FIXC = (1U << 12);  ///< FPU inexact interrupt status
        constexpr uint32_t FIDC = (1U << 15);  ///< FPU input denormal interrupt status
        constexpr uint32_t CWBEE = (1U << 20);  ///< Cache write buffer error enable
        constexpr uint32_t FIOCE = (1U << 24);  ///< FPU invalid operation interrupt enable
        constexpr uint32_t FDZCE = (1U << 25);  ///< FPU divide-by-zero interrupt enable
        constexpr uint32_t FOFCE = (1U << 26);  ///< FPU overflow interrupt enable
        constexpr uint32_t FUFCE = (1U << 27);  ///< FPU underflow interrupt enable
        constexpr uint32_t FIXCE = (1U << 28);  ///< FPU inexact interrupt enable
        constexpr uint32_t FIDCE = (1U << 31);  ///< FPU input denormal interrupt enable
    }

    /// FADR Register bits
    namespace fadr_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Fault address
    }

    /// FATR Register bits
    namespace fatr_bits {
        constexpr uint32_t BEDA = (1U << 0);  ///< Bus Error Data Access type
        constexpr uint32_t BEMD = (1U << 1);  ///< Bus error privilege level
        constexpr uint32_t BESZ = (2 << 4);  ///< Bus error size
        constexpr uint32_t BEWT = (1U << 7);  ///< Bus error write
        constexpr uint32_t BEMN = (4 << 8);  ///< Bus error master number
        constexpr uint32_t BEOVR = (1U << 31);  ///< Bus error overrun
    }

    /// FDR Register bits
    namespace fdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Fault data
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (8 << 0);  ///< M0_PID And M1_PID For MPU
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation wakeup on interrupt
    }

    /// LMDR%s Register bits
    namespace lmdr%s_bits {
        constexpr uint32_t CF0 = (4 << 0);  ///< Control Field 0
        constexpr uint32_t CF1 = (4 << 4);  ///< Control Field 1 - for Cache Parity control functions
        constexpr uint32_t MT = (3 << 13);  ///< Memory Type
        constexpr uint32_t RO = (1U << 16);  ///< (??TBD?? current content from "MSCM OCMEM Configuration Register Descriptions")
        constexpr uint32_t DPW = (3 << 17);  ///< LMEM Data Path Width. This read-only field defines the width of the local memory.
        constexpr uint32_t WY = (4 << 20);  ///< Level 1 Cache Ways
        constexpr uint32_t LMSZ = (4 << 24);  ///< (??TBD?? current content from "MSCM OCMEM Configuration Register Descriptions")
        constexpr uint32_t LMSZH = (1U << 28);  ///< (??TBD?? current content from "MSCM OCMEM Configuration Register Descriptions")
        constexpr uint32_t V = (1U << 31);  ///< Local memory Valid bit. This read-only field defines the validity (presence) of the local memory.
    }

    /// LMPECR Register bits
    namespace lmpecr_bits {
        constexpr uint32_t ERNCR = (1U << 0);  ///< Enable RAM ECC Noncorrectable Reporting
        constexpr uint32_t ER1BR = (1U << 8);  ///< Enable RAM ECC 1 Bit Reporting
        constexpr uint32_t ERPR = (1U << 16);  ///< Enable RAM Parity Reporting
        constexpr uint32_t ECPR = (1U << 20);  ///< Enable Cache Parity Reporting
    }

    /// LMPEIR Register bits
    namespace lmpeir_bits {
        constexpr uint32_t ENC = (8 << 0);  ///< ENCn = ECC Noncorrectable Error n
        constexpr uint32_t E1B = (8 << 8);  ///< E1Bn = ECC 1-bit Error n
        constexpr uint32_t PE = (8 << 16);  ///< Parity Error
        constexpr uint32_t PEELOC = (5 << 24);  ///< Parity or ECC Error Location 5'h00 - a non-correctable ECC event from SRAM_L 5'h01 - a non-correctable ECC event from SRAM_U 5'h08 - a 1-bit correctable ECC event from SRAM_L 5'h09 - a 1-bit correctable ECC event from SRAM_U 5'h14 - a PC Tag Parity Error 5'h15 - a PC Data Parity Error
        constexpr uint32_t V = (1U << 31);  ///< Valid bit
    }

    /// LMFAR Register bits
    namespace lmfar_bits {
        constexpr uint32_t EFADD = (32 << 0);  ///< ECC Fault Address
    }

    /// LMFATR Register bits
    namespace lmfatr_bits {
        constexpr uint32_t PEFPRT = (4 << 0);  ///< Parity/ECC Fault Protection FATR[3] is Cacheable: 0=Non-cacheable, 1=Cacheable FATR[2] is Bufferable: 0=Non-bufferable, 1=Bufferable FATR[1] is Mode: 0=User mode, 1=Supervisor mode FATR[0] is Type: 0=I-Fetch, 1=Data
        constexpr uint32_t PEFSIZE = (3 << 4);  ///< Parity/ECC Fault Master Size 3'b000 = 8-bit access 3'b001 = 16-bit access 3'b010 = 32-bit access 3'b011 = 64-bit access 3'b1xx = Reserved
        constexpr uint32_t PEFW = (1U << 7);  ///< Parity/ECC Fault Write
        constexpr uint32_t PEFMST = (8 << 8);  ///< Parity/ECC Fault Master Number
        constexpr uint32_t OVR = (1U << 31);  ///< Overrun
    }

    /// LMFDHR Register bits
    namespace lmfdhr_bits {
        constexpr uint32_t PEFDH = (32 << 0);  ///< Parity or ECC Fault Data High
    }

    /// LMFDLR Register bits
    namespace lmfdlr_bits {
        constexpr uint32_t PEFDL = (32 << 0);  ///< Parity or ECC Fault Data Low
    }

}

// ============================================================================
// LMEM Peripheral
// ============================================================================

namespace lmem {
    /// Base addresses
    constexpr uint32_t LMEM_BASE = 0xE0082000;

    /// LMEM Register structure
    struct Registers {
        volatile uint32_t PCCCR;  ///< Offset: 0x00 - Cache control register
        volatile uint32_t PCCLCR;  ///< Offset: 0x04 - Cache line control register
        volatile uint32_t PCCSAR;  ///< Offset: 0x08 - Cache search address register
        volatile uint32_t PCCCVR;  ///< Offset: 0x0C - Cache read/write value register
        volatile uint32_t PCCRMR;  ///< Offset: 0x20 - Cache regions mode register
    };

    /// Peripheral instances
    inline Registers* LMEM = reinterpret_cast<Registers*>(LMEM_BASE);

    // Bit definitions
    /// PCCCR Register bits
    namespace pcccr_bits {
        constexpr uint32_t ENCACHE = (1U << 0);  ///< Cache enable
        constexpr uint32_t ENWRBUF = (1U << 1);  ///< Enable Write Buffer
        constexpr uint32_t PCCR2 = (1U << 2);  ///< Forces all cacheable spaces to write through
        constexpr uint32_t PCCR3 = (1U << 3);  ///< Forces no allocation on cache misses (must also have PCCR2 asserted)
        constexpr uint32_t INVW0 = (1U << 24);  ///< Invalidate Way 0
        constexpr uint32_t PUSHW0 = (1U << 25);  ///< Push Way 0
        constexpr uint32_t INVW1 = (1U << 26);  ///< Invalidate Way 1
        constexpr uint32_t PUSHW1 = (1U << 27);  ///< Push Way 1
        constexpr uint32_t GO = (1U << 31);  ///< Initiate Cache Command
    }

    /// PCCLCR Register bits
    namespace pcclcr_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t CACHEADDR = (12 << 2);  ///< Cache address
        constexpr uint32_t WSEL = (1U << 14);  ///< Way select
        constexpr uint32_t TDSEL = (1U << 16);  ///< Tag/Data Select
        constexpr uint32_t LCIVB = (1U << 20);  ///< Line Command Initial Valid Bit
        constexpr uint32_t LCIMB = (1U << 21);  ///< Line Command Initial Modified Bit
        constexpr uint32_t LCWAY = (1U << 22);  ///< Line Command Way
        constexpr uint32_t LCMD = (2 << 24);  ///< Line Command
        constexpr uint32_t LADSEL = (1U << 26);  ///< Line Address Select
        constexpr uint32_t LACC = (1U << 27);  ///< Line access type
    }

    /// PCCSAR Register bits
    namespace pccsar_bits {
        constexpr uint32_t LGO = (1U << 0);  ///< Initiate Cache Line Command
        constexpr uint32_t PHYADDR = (30 << 2);  ///< Physical Address
    }

    /// PCCCVR Register bits
    namespace pcccvr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Cache read/write Data
    }

    /// PCCRMR Register bits
    namespace pccrmr_bits {
        constexpr uint32_t R15 = (2 << 0);  ///< Region 15 mode
        constexpr uint32_t R14 = (2 << 2);  ///< Region 14 mode
        constexpr uint32_t R13 = (2 << 4);  ///< Region 13 mode
        constexpr uint32_t R12 = (2 << 6);  ///< Region 12 mode
        constexpr uint32_t R11 = (2 << 8);  ///< Region 11 mode
        constexpr uint32_t R10 = (2 << 10);  ///< Region 10 mode
        constexpr uint32_t R9 = (2 << 12);  ///< Region 9 mode
        constexpr uint32_t R8 = (2 << 14);  ///< Region 8 mode
        constexpr uint32_t R7 = (2 << 16);  ///< Region 7 mode
        constexpr uint32_t R6 = (2 << 18);  ///< Region 6 mode
        constexpr uint32_t R5 = (2 << 20);  ///< Region 5 mode
        constexpr uint32_t R4 = (2 << 22);  ///< Region 4 mode
        constexpr uint32_t R3 = (2 << 24);  ///< Region 3 mode
        constexpr uint32_t R2 = (2 << 26);  ///< Region 2 mode
        constexpr uint32_t R1 = (2 << 28);  ///< Region 1 mode
        constexpr uint32_t R0 = (2 << 30);  ///< Region 0 mode
    }

}


} // namespace alloy::generated::mke18f16

#endif // ALLOY_GENERATED_MKE18F16_PERIPHERALS_HPP