/// Auto-generated code for MKL28T7_CORE0
/// Generated by Alloy Code Generator
/// Source: nxp_mkl28.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:52
#ifndef ALLOY_GENERATED_MKL28T7_CORE0_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKL28T7_CORE0_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::mkl28t7_core0 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_mscm = true;
    constexpr uint32_t num_mscm_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 4;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 14;
    constexpr bool has_xrdc = true;
    constexpr uint32_t num_xrdc_instances = 1;
    constexpr bool has_sema420 = true;
    constexpr uint32_t num_sema420_instances = 1;
    constexpr bool has_sema421 = true;
    constexpr uint32_t num_sema421_instances = 1;
    constexpr bool has_mu0 = true;
    constexpr uint32_t num_mu0_instances = 2;
    constexpr bool has_intmux0 = true;
    constexpr uint32_t num_intmux0_instances = 1;
    constexpr bool has_trgmux0 = true;
    constexpr uint32_t num_trgmux0_instances = 1;
    constexpr bool has_trgmux1 = true;
    constexpr uint32_t num_trgmux1_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 7;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 3;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_emvsim0 = true;
    constexpr uint32_t num_emvsim0_instances = 1;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_llwu0 = true;
    constexpr uint32_t num_llwu0_instances = 1;
    constexpr bool has_llwu1 = true;
    constexpr uint32_t num_llwu1_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_cmp1 = true;
    constexpr uint32_t num_cmp1_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_tstmr0 = true;
    constexpr uint32_t num_tstmr0_instances = 1;
    constexpr bool has_tstmr1 = true;
    constexpr uint32_t num_tstmr1_instances = 1;
    constexpr bool has_wdog0 = true;
    constexpr uint32_t num_wdog0_instances = 1;
    constexpr bool has_wdog1 = true;
    constexpr uint32_t num_wdog1_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_pcc0 = true;
    constexpr uint32_t num_pcc0_instances = 1;
    constexpr bool has_pcc1 = true;
    constexpr uint32_t num_pcc1_instances = 1;
    constexpr bool has_scg = true;
    constexpr uint32_t num_scg_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_flexio0 = true;
    constexpr uint32_t num_flexio0_instances = 1;
    constexpr bool has_asmc = true;
    constexpr uint32_t num_asmc_instances = 1;
    constexpr bool has_mtb0 = true;
    constexpr uint32_t num_mtb0_instances = 3;
    constexpr bool has_mtb1 = true;
    constexpr uint32_t num_mtb1_instances = 1;
    constexpr bool has_mcm0 = true;
    constexpr uint32_t num_mcm0_instances = 1;
    constexpr bool has_mcm1 = true;
    constexpr uint32_t num_mcm1_instances = 1;
    constexpr bool has_mmdvsq0 = true;
    constexpr uint32_t num_mmdvsq0_instances = 1;
    constexpr bool has_mmdvsq1 = true;
    constexpr uint32_t num_mmdvsq1_instances = 1;
    constexpr bool has_cau0 = true;
    constexpr uint32_t num_cau0_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mscm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 14;
    };
    template<>
    struct peripheral_count<struct xrdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sema420_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sema421_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mu0_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct intmux0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct trgmux1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct emvsim0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tstmr0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tstmr1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pcc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct scg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flexio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct asmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb0_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct mtb1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmdvsq0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mmdvsq1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cau0_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 14;
    constexpr uint32_t max_gpio_pins = 224;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT0 = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t RESET_PIN_CFG = (1U << 3);  ///< no description available
        constexpr uint32_t LPBOOT1 = (1U << 4);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

}

// ============================================================================
// MSCM Peripheral
// ============================================================================

namespace mscm {
    /// Base addresses
    constexpr uint32_t MSCM_BASE = 0x40001000;

    /// MSCM Register structure
    struct Registers {
        volatile uint32_t CPxTYPE;  ///< Offset: 0x00 - Processor X Type Register
        volatile uint32_t CPxNUM;  ///< Offset: 0x04 - Processor X Number Register
        volatile uint32_t CPxMASTER;  ///< Offset: 0x08 - Processor X Master Register
        volatile uint32_t CPxCOUNT;  ///< Offset: 0x0C - Processor X Count Register
        volatile uint32_t CPxCFG;  ///< Offset: 0x10 - Processor X Configuration Register (renamed from CPxCFG)
        volatile uint32_t CP0TYPE;  ///< Offset: 0x20 - Processor 0 Type Register
        volatile uint32_t CP0NUM;  ///< Offset: 0x24 - Processor 0 Number Register
        volatile uint32_t CP0MASTER;  ///< Offset: 0x28 - Processor 0 Master Register
        volatile uint32_t CP0COUNT;  ///< Offset: 0x2C - Processor 0 Count Register
        volatile uint32_t CP0CFG;  ///< Offset: 0x30 - Processor 0 Configuration Register (renamed from CP0CFG)
        volatile uint32_t CP1TYPE;  ///< Offset: 0x40 - Processor 1 Type Register
        volatile uint32_t CP1NUM;  ///< Offset: 0x44 - Processor 1 Number Register
        volatile uint32_t CP1MASTER;  ///< Offset: 0x48 - Processor 1 Master Register
        volatile uint32_t CP1COUNT;  ///< Offset: 0x4C - Processor 1 Count Register
        volatile uint32_t CP1CFG;  ///< Offset: 0x50 - Processor 1 Configuration Register (renamed from CP1CFG)
        volatile uint32_t OCMDR;  ///< Offset: 0x400 - On-Chip Memory Descriptor Register (renamed from OCMDR)
    };

    /// Peripheral instances
    inline Registers* MSCM = reinterpret_cast<Registers*>(MSCM_BASE);

    // Bit definitions
    /// CPxTYPE Register bits
    namespace cpxtype_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CPxNUM Register bits
    namespace cpxnum_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CPxMASTER Register bits
    namespace cpxmaster_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CPxCOUNT Register bits
    namespace cpxcount_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CPxCFG Register bits
    namespace cpxcfg_bits {
        constexpr uint32_t DCWY = (8 << 0);  ///< Level 1 Data Cache Ways
        constexpr uint32_t DCSZ = (8 << 8);  ///< Level 1 Data Cache Size
        constexpr uint32_t ICWY = (8 << 16);  ///< Level 1 Instruction Cache Ways
        constexpr uint32_t ICSZ = (8 << 24);  ///< Level 1 Instruction Cache Size
    }

    /// CP0TYPE Register bits
    namespace cp0type_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CP0NUM Register bits
    namespace cp0num_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CP0MASTER Register bits
    namespace cp0master_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CP0COUNT Register bits
    namespace cp0count_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CP0CFG Register bits
    namespace cp0cfg_bits {
        constexpr uint32_t DCWY = (8 << 0);  ///< Level 1 Data Cache Ways
        constexpr uint32_t DCSZ = (8 << 8);  ///< Level 1 Data Cache Size
        constexpr uint32_t ICWY = (8 << 16);  ///< Level 1 Instruction Cache Ways
        constexpr uint32_t ICSZ = (8 << 24);  ///< Level 1 Instruction Cache Size
    }

    /// CP1TYPE Register bits
    namespace cp1type_bits {
        constexpr uint32_t RYPZ = (8 << 0);  ///< Processor x Revision
        constexpr uint32_t PERSONALITY = (24 << 8);  ///< Processor x Personality
    }

    /// CP1NUM Register bits
    namespace cp1num_bits {
        constexpr uint32_t CPN = (1U << 0);  ///< Processor x Number
    }

    /// CP1MASTER Register bits
    namespace cp1master_bits {
        constexpr uint32_t PPN = (6 << 0);  ///< Processor x Physical Port Number
    }

    /// CP1COUNT Register bits
    namespace cp1count_bits {
        constexpr uint32_t PCNT = (2 << 0);  ///< Processor Count
    }

    /// CP1CFG Register bits
    namespace cp1cfg_bits {
        constexpr uint32_t DCWY = (8 << 0);  ///< Level 1 Data Cache Ways
        constexpr uint32_t DCSZ = (8 << 8);  ///< Level 1 Data Cache Size
        constexpr uint32_t ICWY = (8 << 16);  ///< Level 1 Instruction Cache Ways
        constexpr uint32_t ICSZ = (8 << 24);  ///< Level 1 Instruction Cache Size
    }

    /// OCMDR Register bits
    namespace ocmdr_bits {
        constexpr uint32_t OCMPU = (1U << 12);  ///< OCMEM Memory Protection Unit. This read-only field identifies a memory protected by an XRDC module.
        constexpr uint32_t OCMT = (3 << 13);  ///< OCMEM Type. This field defines the type of the on-chip memory:
        constexpr uint32_t RO = (1U << 16);  ///< Read-Only
        constexpr uint32_t OCMW = (3 << 17);  ///< OCMEM datapath Width. This read-only field defines the width of the on-chip memory:
        constexpr uint32_t OCMSZ = (4 << 24);  ///< OCMEM Size
        constexpr uint32_t OCMSZH = (1U << 28);  ///< OCMEM Size "Hole"
        constexpr uint32_t V = (1U << 31);  ///< OCMEM Valid bit. This read-only field defines the validity (presence) of the on-chip memory
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA0_BASE = 0x40008000;
    constexpr uint32_t DMA1_BASE = 0x40088000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;
    constexpr uint32_t DMAMUX1_BASE = 0x400A1000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and... (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA0 = reinterpret_cast<Registers*>(DMA0_BASE);
    inline Registers* DMA1 = reinterpret_cast<Registers*>(DMA1_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);
    inline Registers* DMAMUX1 = reinterpret_cast<Registers*>(DMAMUX1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (3 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (3 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (3 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (3 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (3 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (3 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (3 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (3 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (3 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (3 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (3 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x4000F000;
    constexpr uint32_t GPIOB_BASE = 0x4000F040;
    constexpr uint32_t GPIOC_BASE = 0x4000F080;
    constexpr uint32_t GPIOD_BASE = 0x4000F0C0;
    constexpr uint32_t GPIOE_BASE = 0x4000F100;
    constexpr uint32_t GPIOM_BASE = 0x4008F000;
    constexpr uint32_t PORTA_BASE = 0x4005A000;
    constexpr uint32_t PORTB_BASE = 0x4005B000;
    constexpr uint32_t PORTC_BASE = 0x4005C000;
    constexpr uint32_t PORTD_BASE = 0x4005D000;
    constexpr uint32_t PORTE_BASE = 0x4005E000;
    constexpr uint32_t PORTM_BASE = 0x400E0000;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOM_BASE = 0xF9000000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PDOR;  ///< Offset: 0x00 - Port Data Output Register
        volatile uint32_t PSOR;  ///< Offset: 0x04 - Port Set Output Register
        volatile uint32_t PCOR;  ///< Offset: 0x08 - Port Clear Output Register
        volatile uint32_t PTOR;  ///< Offset: 0x0C - Port Toggle Output Register
        volatile uint32_t PDIR;  ///< Offset: 0x10 - Port Data Input Register
        volatile uint32_t PDDR;  ///< Offset: 0x14 - Port Data Direction Register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* GPIOM = reinterpret_cast<Registers*>(GPIOM_BASE);
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* PORTM = reinterpret_cast<Registers*>(PORTM_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOM = reinterpret_cast<Registers*>(FGPIOM_BASE);

    // Bit definitions
    /// PDOR Register bits
    namespace pdor_bits {
        constexpr uint32_t PDO = (32 << 0);  ///< Port Data Output
    }

    /// PSOR Register bits
    namespace psor_bits {
        constexpr uint32_t PTSO = (32 << 0);  ///< Port Set Output
    }

    /// PCOR Register bits
    namespace pcor_bits {
        constexpr uint32_t PTCO = (32 << 0);  ///< Port Clear Output
    }

    /// PTOR Register bits
    namespace ptor_bits {
        constexpr uint32_t PTTO = (32 << 0);  ///< Port Toggle Output
    }

    /// PDIR Register bits
    namespace pdir_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Port Data Input
    }

    /// PDDR Register bits
    namespace pddr_bits {
        constexpr uint32_t PDD = (32 << 0);  ///< Port Data Direction
    }

}

// ============================================================================
// XRDC Peripheral
// ============================================================================

namespace xrdc {
    /// Base addresses
    constexpr uint32_t XRDC_BASE = 0x40014000;

    /// XRDC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t HWCFG0;  ///< Offset: 0xF0 - Hardware Configuration Register 0
        volatile uint32_t HWCFG1;  ///< Offset: 0xF4 - Hardware Configuration Register 1
        volatile uint32_t HWCFG2;  ///< Offset: 0xF8 - Hardware Configuration Register 2
        volatile uint32_t HWCFG3;  ///< Offset: 0xFC - Hardware Configuration Register 3
        volatile uint32_t MDACFG;  ///< Offset: 0x100 - Master Domain Assignment Configuration Register (renamed from MDACFG)
        volatile uint32_t MRCFG;  ///< Offset: 0x140 - Memory Region Configuration Register (renamed from MRCFG)
        volatile uint32_t DERRLOC;  ///< Offset: 0x200 - Domain Error Location Register (renamed from DERRLOC)
        volatile uint32_t DERR_W0_;  ///< Offset: 0x400 - Domain Error Word0 Register (renamed from DERR_W0_)
        volatile uint32_t DERR_W1_;  ///< Offset: 0x404 - Domain Error Word1 Register (renamed from DERR_W1_)
        volatile uint32_t DERR_W2_;  ///< Offset: 0x408 - Domain Error Word2 Register (renamed from DERR_W2_)
        volatile uint32_t DERR_W3_;  ///< Offset: 0x40C - Domain Error Word3 Register (renamed from DERR_W3_)
        volatile uint32_t PID;  ///< Offset: 0x700 - Process Identifier (renamed from PID)
        volatile uint32_t MDA_W0_0;  ///< Offset: 0x800 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_0;  ///< Offset: 0x804 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_1;  ///< Offset: 0x820 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_1;  ///< Offset: 0x824 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_2;  ///< Offset: 0x840 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_2;  ///< Offset: 0x844 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_3;  ///< Offset: 0x860 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_3;  ///< Offset: 0x864 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_4;  ///< Offset: 0x880 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_4;  ///< Offset: 0x884 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_5;  ///< Offset: 0x8A0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_5;  ///< Offset: 0x8A4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_6;  ///< Offset: 0x8C0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_6;  ///< Offset: 0x8C4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_7;  ///< Offset: 0x8E0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_7;  ///< Offset: 0x8E4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_8;  ///< Offset: 0x900 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_8;  ///< Offset: 0x904 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_9;  ///< Offset: 0x920 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_9;  ///< Offset: 0x924 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_10;  ///< Offset: 0x940 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_10;  ///< Offset: 0x944 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_11;  ///< Offset: 0x960 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_11;  ///< Offset: 0x964 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_12;  ///< Offset: 0x980 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_12;  ///< Offset: 0x984 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_13;  ///< Offset: 0x9A0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_13;  ///< Offset: 0x9A4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_14;  ///< Offset: 0x9C0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_14;  ///< Offset: 0x9C4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_15;  ///< Offset: 0x9E0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_15;  ///< Offset: 0x9E4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_16;  ///< Offset: 0xA00 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_16;  ///< Offset: 0xA04 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_17;  ///< Offset: 0xA20 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_17;  ///< Offset: 0xA24 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_18;  ///< Offset: 0xA40 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_18;  ///< Offset: 0xA44 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_19;  ///< Offset: 0xA60 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_19;  ///< Offset: 0xA64 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_20;  ///< Offset: 0xA80 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_20;  ///< Offset: 0xA84 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_21;  ///< Offset: 0xAA0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_21;  ///< Offset: 0xAA4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_22;  ///< Offset: 0xAC0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_22;  ///< Offset: 0xAC4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_23;  ///< Offset: 0xAE0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_23;  ///< Offset: 0xAE4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_24;  ///< Offset: 0xB00 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_24;  ///< Offset: 0xB04 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_25;  ///< Offset: 0xB20 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_25;  ///< Offset: 0xB24 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_26;  ///< Offset: 0xB40 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_26;  ///< Offset: 0xB44 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_27;  ///< Offset: 0xB60 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_27;  ///< Offset: 0xB64 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_28;  ///< Offset: 0xB80 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_28;  ///< Offset: 0xB84 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_29;  ///< Offset: 0xBA0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_29;  ///< Offset: 0xBA4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_30;  ///< Offset: 0xBC0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_30;  ///< Offset: 0xBC4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_31;  ///< Offset: 0xBE0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_31;  ///< Offset: 0xBE4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_32;  ///< Offset: 0xC00 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_32;  ///< Offset: 0xC04 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_33;  ///< Offset: 0xC20 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_33;  ///< Offset: 0xC24 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_34;  ///< Offset: 0xC40 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_34;  ///< Offset: 0xC44 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_35;  ///< Offset: 0xC60 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_35;  ///< Offset: 0xC64 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_36;  ///< Offset: 0xC80 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_36;  ///< Offset: 0xC84 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W0_37;  ///< Offset: 0xCA0 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t MDA_W1_37;  ///< Offset: 0xCA4 - Master Domain Assignment Wm,n (DFMT=0)
        volatile uint32_t PDAC_W0_;  ///< Offset: 0x1000 - Peripheral Domain Access Control W0 (renamed from PDAC_W0_)
        volatile uint32_t PDAC_W1_;  ///< Offset: 0x1004 - Peripheral Domain Access Control W1 (renamed from PDAC_W1_)
        volatile uint32_t MRGD_W0_;  ///< Offset: 0x2000 - Memory Region Descriptor W0 (renamed from MRGD_W0_)
        volatile uint32_t MRGD_W1_;  ///< Offset: 0x2004 - Memory Region Descriptor W1 (renamed from MRGD_W1_)
        volatile uint32_t MRGD_W2_;  ///< Offset: 0x2008 - Memory Region Descriptor W2 (renamed from MRGD_W2_)
        volatile uint32_t MRGD_W3_;  ///< Offset: 0x200C - Memory Region Descriptor W3 (renamed from MRGD_W3_)
        volatile uint32_t MRGD_W4_;  ///< Offset: 0x2010 - Memory Region Descriptor W4 (renamed from MRGD_W4_)
        volatile uint32_t MRGD_W5_;  ///< Offset: 0x2014 - Memory Region Descriptor W5 (renamed from MRGD_W5_)
        volatile uint32_t MRGD_W6_;  ///< Offset: 0x2018 - Memory Region Descriptor W6 (renamed from MRGD_W6_)
        volatile uint32_t MRGD_W7_;  ///< Offset: 0x201C - Memory Region Descriptor W7 (renamed from MRGD_W7_)
    };

    /// Peripheral instances
    inline Registers* XRDC = reinterpret_cast<Registers*>(XRDC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t GVLD = (1U << 0);  ///< Global Valid (XRDC global enable/disable).
        constexpr uint32_t HRL = (4 << 1);  ///< Hardware Revision Level
        constexpr uint32_t MRF = (1U << 7);  ///< Memory Region Format
        constexpr uint32_t VAW = (1U << 8);  ///< Virtualization aware
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
    }

    /// HWCFG0 Register bits
    namespace hwcfg0_bits {
        constexpr uint32_t NDID = (8 << 0);  ///< Number of domains
        constexpr uint32_t NMSTR = (8 << 8);  ///< Number of bus masters
        constexpr uint32_t NMRC = (8 << 16);  ///< Number of MRCs
        constexpr uint32_t NPAC = (4 << 24);  ///< Number of PACs
    }

    /// HWCFG1 Register bits
    namespace hwcfg1_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier number
    }

    /// HWCFG2 Register bits
    namespace hwcfg2_bits {
        constexpr uint32_t PIDP0 = (1U << 0);  ///< Process identifier present from bus master 0
        constexpr uint32_t PIDP1 = (1U << 1);  ///< Process identifier present from bus master 1
        constexpr uint32_t PIDP2 = (1U << 2);  ///< Process identifier present from bus master 2
        constexpr uint32_t PIDP3 = (1U << 3);  ///< Process identifier present from bus master 3
        constexpr uint32_t PIDP4 = (1U << 4);  ///< Process identifier present from bus master 4
        constexpr uint32_t PIDP5 = (1U << 5);  ///< Process identifier present from bus master 5
        constexpr uint32_t PIDP6 = (1U << 6);  ///< Process identifier present from bus master 6
        constexpr uint32_t PIDP7 = (1U << 7);  ///< Process identifier present from bus master 7
        constexpr uint32_t PIDP8 = (1U << 8);  ///< Process identifier present from bus master 8
        constexpr uint32_t PIDP9 = (1U << 9);  ///< Process identifier present from bus master 9
        constexpr uint32_t PIDP10 = (1U << 10);  ///< Process identifier present from bus master 10
        constexpr uint32_t PIDP11 = (1U << 11);  ///< Process identifier present from bus master 11
        constexpr uint32_t PIDP12 = (1U << 12);  ///< Process identifier present from bus master 12
        constexpr uint32_t PIDP13 = (1U << 13);  ///< Process identifier present from bus master 13
        constexpr uint32_t PIDP14 = (1U << 14);  ///< Process identifier present from bus master 14
        constexpr uint32_t PIDP15 = (1U << 15);  ///< Process identifier present from bus master 15
        constexpr uint32_t PIDP16 = (1U << 16);  ///< Process identifier present from bus master 16
        constexpr uint32_t PIDP17 = (1U << 17);  ///< Process identifier present from bus master 17
        constexpr uint32_t PIDP18 = (1U << 18);  ///< Process identifier present from bus master 18
        constexpr uint32_t PIDP19 = (1U << 19);  ///< Process identifier present from bus master 19
        constexpr uint32_t PIDP20 = (1U << 20);  ///< Process identifier present from bus master 20
        constexpr uint32_t PIDP21 = (1U << 21);  ///< Process identifier present from bus master 21
        constexpr uint32_t PIDP22 = (1U << 22);  ///< Process identifier present from bus master 22
        constexpr uint32_t PIDP23 = (1U << 23);  ///< Process identifier present from bus master 23
        constexpr uint32_t PIDP24 = (1U << 24);  ///< Process identifier present from bus master 24
        constexpr uint32_t PIDP25 = (1U << 25);  ///< Process identifier present from bus master 25
        constexpr uint32_t PIDP26 = (1U << 26);  ///< Process identifier present from bus master 26
        constexpr uint32_t PIDP27 = (1U << 27);  ///< Process identifier present from bus master 27
        constexpr uint32_t PIDP28 = (1U << 28);  ///< Process identifier present from bus master 28
        constexpr uint32_t PIDP29 = (1U << 29);  ///< Process identifier present from bus master 29
        constexpr uint32_t PIDP30 = (1U << 30);  ///< Process identifier present from bus master 30
        constexpr uint32_t PIDP31 = (1U << 31);  ///< Process identifier present from bus master 31
    }

    /// HWCFG3 Register bits
    namespace hwcfg3_bits {
        constexpr uint32_t PIDP32 = (1U << 0);  ///< Process identifier present from bus master 32
        constexpr uint32_t PIDP33 = (1U << 1);  ///< Process identifier present from bus master 33
        constexpr uint32_t PIDP34 = (1U << 2);  ///< Process identifier present from bus master 34
        constexpr uint32_t PIDP35 = (1U << 3);  ///< Process identifier present from bus master 35
        constexpr uint32_t PIDP36 = (1U << 4);  ///< Process identifier present from bus master 36
        constexpr uint32_t PIDP37 = (1U << 5);  ///< Process identifier present from bus master 37
        constexpr uint32_t PIDP38 = (1U << 6);  ///< Process identifier present from bus master 38
        constexpr uint32_t PIDP39 = (1U << 7);  ///< Process identifier present from bus master 39
        constexpr uint32_t PIDP40 = (1U << 8);  ///< Process identifier present from bus master 40
        constexpr uint32_t PIDP41 = (1U << 9);  ///< Process identifier present from bus master 41
        constexpr uint32_t PIDP42 = (1U << 10);  ///< Process identifier present from bus master 42
        constexpr uint32_t PIDP43 = (1U << 11);  ///< Process identifier present from bus master 43
        constexpr uint32_t PIDP44 = (1U << 12);  ///< Process identifier present from bus master 44
        constexpr uint32_t PIDP45 = (1U << 13);  ///< Process identifier present from bus master 45
        constexpr uint32_t PIDP46 = (1U << 14);  ///< Process identifier present from bus master 46
        constexpr uint32_t PIDP47 = (1U << 15);  ///< Process identifier present from bus master 47
        constexpr uint32_t PIDP48 = (1U << 16);  ///< Process identifier present from bus master 48
        constexpr uint32_t PIDP49 = (1U << 17);  ///< Process identifier present from bus master 49
        constexpr uint32_t PIDP50 = (1U << 18);  ///< Process identifier present from bus master 50
        constexpr uint32_t PIDP51 = (1U << 19);  ///< Process identifier present from bus master 51
        constexpr uint32_t PIDP52 = (1U << 20);  ///< Process identifier present from bus master 52
        constexpr uint32_t PIDP53 = (1U << 21);  ///< Process identifier present from bus master 53
        constexpr uint32_t PIDP54 = (1U << 22);  ///< Process identifier present from bus master 54
        constexpr uint32_t PIDP55 = (1U << 23);  ///< Process identifier present from bus master 55
        constexpr uint32_t PIDP56 = (1U << 24);  ///< Process identifier present from bus master 56
        constexpr uint32_t PIDP57 = (1U << 25);  ///< Process identifier present from bus master 57
        constexpr uint32_t PIDP58 = (1U << 26);  ///< Process identifier present from bus master 58
        constexpr uint32_t PIDP59 = (1U << 27);  ///< Process identifier present from bus master 59
        constexpr uint32_t PIDP60 = (1U << 28);  ///< Process identifier present from bus master 60
        constexpr uint32_t PIDP61 = (1U << 29);  ///< Process identifier present from bus master 61
        constexpr uint32_t PIDP62 = (1U << 30);  ///< Process identifier present from bus master 62
        constexpr uint32_t PIDP63 = (1U << 31);  ///< Process identifier present from bus master 63
    }

    /// MDACFG Register bits
    namespace mdacfg_bits {
        constexpr uint32_t NMDAR = (4 << 0);  ///< Number of master domain assignment registers for bus master n
        constexpr uint32_t NCM = (1U << 7);  ///< Non-CPU Master
    }

    /// MRCFG Register bits
    namespace mrcfg_bits {
        constexpr uint32_t NMGD = (5 << 0);  ///< Number of memory region descriptors for MRC i
    }

    /// DERRLOC Register bits
    namespace derrloc_bits {
        constexpr uint32_t MRCINST = (16 << 0);  ///< MRC instance
        constexpr uint32_t PACINST = (4 << 16);  ///< PAC instance
    }

    /// DERR_W0_ Register bits
    namespace derr_w0__bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error address. This is the access address that generated an access violation.
    }

    /// DERR_W1_ Register bits
    namespace derr_w1__bits {
        constexpr uint32_t EDID = (4 << 0);  ///< Error domain identifier. This field captures the domain identifier of the access violation.
        constexpr uint32_t EATR = (3 << 8);  ///< Error attributes. This field captures certain attributes of the access violation.
        constexpr uint32_t ERW = (1U << 11);  ///< Error read/write
        constexpr uint32_t EPORT = (3 << 24);  ///< Error port
        constexpr uint32_t EST = (2 << 30);  ///< Error state
    }

    /// DERR_W3_ Register bits
    namespace derr_w3__bits {
        constexpr uint32_t RECR = (2 << 30);  ///< Rearm Error Capture Registers
    }

    /// PID Register bits
    namespace pid_bits {
        constexpr uint32_t PID = (6 << 0);  ///< Process identifier
        constexpr uint32_t TSM = (1U << 28);  ///< Three-state model
        constexpr uint32_t LK2 = (2 << 29);  ///< Lock
    }

    /// MDA_W0_0 Register bits
    namespace mda_w0_0_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_0 Register bits
    namespace mda_w1_0_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_1 Register bits
    namespace mda_w0_1_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_1 Register bits
    namespace mda_w1_1_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_2 Register bits
    namespace mda_w0_2_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_2 Register bits
    namespace mda_w1_2_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_3 Register bits
    namespace mda_w0_3_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_3 Register bits
    namespace mda_w1_3_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_4 Register bits
    namespace mda_w0_4_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_4 Register bits
    namespace mda_w1_4_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_5 Register bits
    namespace mda_w0_5_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_5 Register bits
    namespace mda_w1_5_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_6 Register bits
    namespace mda_w0_6_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_6 Register bits
    namespace mda_w1_6_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_7 Register bits
    namespace mda_w0_7_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_7 Register bits
    namespace mda_w1_7_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_8 Register bits
    namespace mda_w0_8_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_8 Register bits
    namespace mda_w1_8_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_9 Register bits
    namespace mda_w0_9_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_9 Register bits
    namespace mda_w1_9_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_10 Register bits
    namespace mda_w0_10_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_10 Register bits
    namespace mda_w1_10_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_11 Register bits
    namespace mda_w0_11_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_11 Register bits
    namespace mda_w1_11_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_12 Register bits
    namespace mda_w0_12_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_12 Register bits
    namespace mda_w1_12_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_13 Register bits
    namespace mda_w0_13_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_13 Register bits
    namespace mda_w1_13_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_14 Register bits
    namespace mda_w0_14_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_14 Register bits
    namespace mda_w1_14_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_15 Register bits
    namespace mda_w0_15_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_15 Register bits
    namespace mda_w1_15_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_16 Register bits
    namespace mda_w0_16_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_16 Register bits
    namespace mda_w1_16_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_17 Register bits
    namespace mda_w0_17_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_17 Register bits
    namespace mda_w1_17_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_18 Register bits
    namespace mda_w0_18_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_18 Register bits
    namespace mda_w1_18_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_19 Register bits
    namespace mda_w0_19_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_19 Register bits
    namespace mda_w1_19_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_20 Register bits
    namespace mda_w0_20_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_20 Register bits
    namespace mda_w1_20_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_21 Register bits
    namespace mda_w0_21_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_21 Register bits
    namespace mda_w1_21_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_22 Register bits
    namespace mda_w0_22_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_22 Register bits
    namespace mda_w1_22_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_23 Register bits
    namespace mda_w0_23_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_23 Register bits
    namespace mda_w1_23_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_24 Register bits
    namespace mda_w0_24_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_24 Register bits
    namespace mda_w1_24_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_25 Register bits
    namespace mda_w0_25_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_25 Register bits
    namespace mda_w1_25_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_26 Register bits
    namespace mda_w0_26_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_26 Register bits
    namespace mda_w1_26_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_27 Register bits
    namespace mda_w0_27_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_27 Register bits
    namespace mda_w1_27_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_28 Register bits
    namespace mda_w0_28_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_28 Register bits
    namespace mda_w1_28_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_29 Register bits
    namespace mda_w0_29_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_29 Register bits
    namespace mda_w1_29_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_30 Register bits
    namespace mda_w0_30_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_30 Register bits
    namespace mda_w1_30_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_31 Register bits
    namespace mda_w0_31_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_31 Register bits
    namespace mda_w1_31_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_32 Register bits
    namespace mda_w0_32_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_32 Register bits
    namespace mda_w1_32_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_33 Register bits
    namespace mda_w0_33_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_33 Register bits
    namespace mda_w1_33_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_34 Register bits
    namespace mda_w0_34_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_34 Register bits
    namespace mda_w1_34_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_35 Register bits
    namespace mda_w0_35_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_35 Register bits
    namespace mda_w1_35_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_36 Register bits
    namespace mda_w0_36_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_36 Register bits
    namespace mda_w1_36_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W0_37 Register bits
    namespace mda_w0_37_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MDA_W1_37 Register bits
    namespace mda_w1_37_bits {
        constexpr uint32_t DID = (4 << 0);  ///< Domain identifier
        constexpr uint32_t DIDS = (2 << 4);  ///< DID Select
        constexpr uint32_t PE = (2 << 6);  ///< Process identifier enable
        constexpr uint32_t PIDM = (6 << 8);  ///< Process Identifier Mask
        constexpr uint32_t PID = (6 << 16);  ///< Process Identifier
        constexpr uint32_t LPID = (4 << 24);  ///< Logical partition Identifier
        constexpr uint32_t LPE = (1U << 28);  ///< Logical partition enable
        constexpr uint32_t DFMT = (1U << 29);  ///< Domain format
        constexpr uint32_t LK1 = (1U << 30);  ///< 1-bit Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// PDAC_W0_ Register bits
    namespace pdac_w0__bits {
        constexpr uint32_t D0ACP = (3 << 0);  ///< Domain 0 access control policy. See description for D7ACP .
        constexpr uint32_t D1ACP = (3 << 3);  ///< Domain 1 access control policy. See description for D7ACP .
        constexpr uint32_t D2ACP = (3 << 6);  ///< Domain 2 access control policy. See description for D7ACP .
        constexpr uint32_t D3ACP = (3 << 9);  ///< Domain 3 access control policy. See description for D7ACP .
        constexpr uint32_t D4ACP = (3 << 12);  ///< Domain 4 access control policy. See description for D7ACP .
        constexpr uint32_t D5ACP = (3 << 15);  ///< Domain 5 access control policy. See description for D7ACP .
        constexpr uint32_t D6ACP = (3 << 18);  ///< Domain 6 access control policy. See description for D7ACP .
        constexpr uint32_t D7ACP = (3 << 21);  ///< Domain 7 access control policy
        constexpr uint32_t SNUM = (6 << 24);  ///< Semaphore number. Include this hardware semaphore in the DxACP access evaluation.
        constexpr uint32_t SE = (1U << 30);  ///< Semaphore enable
    }

    /// PDAC_W1_ Register bits
    namespace pdac_w1__bits {
        constexpr uint32_t D8ACP = (3 << 0);  ///< Domain 8 access control policy. See description for D7ACP .
        constexpr uint32_t D9ACP = (3 << 3);  ///< Domain 9 access control policy. See description for D7ACP .
        constexpr uint32_t D10ACP = (3 << 6);  ///< Domain 10 access control policy. See description for D7ACP .
        constexpr uint32_t D11ACP = (3 << 9);  ///< Domain 11 access control policy. See description for D7ACP .
        constexpr uint32_t D12ACP = (3 << 12);  ///< Domain 12 access control policy. See description for D7ACP .
        constexpr uint32_t D13ACP = (3 << 15);  ///< Domain 13 access control policy. See description for D7ACP .
        constexpr uint32_t D14ACP = (3 << 18);  ///< Domain 14 access control policy. See description for D7ACP .
        constexpr uint32_t D15ACP = (3 << 21);  ///< Domain 15 access control policy. See description for D7ACP .
        constexpr uint32_t LK2 = (2 << 29);  ///< Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

    /// MRGD_W0_ Register bits
    namespace mrgd_w0__bits {
        constexpr uint32_t BASEADDR = (27 << 5);  ///< Base Address
    }

    /// MRGD_W1_ Register bits
    namespace mrgd_w1__bits {
        constexpr uint32_t SRD = (8 << 0);  ///< Subregion disable
        constexpr uint32_t SZ = (5 << 8);  ///< Region size
    }

    /// MRGD_W2_ Register bits
    namespace mrgd_w2__bits {
        constexpr uint32_t D0ACP = (3 << 0);  ///< Domain 0 access control policy. See description for D7ACP .
        constexpr uint32_t D1ACP = (3 << 3);  ///< Domain 1 access control policy. See description for D7ACP .
        constexpr uint32_t D2ACP = (3 << 6);  ///< Domain 2 access control policy. See description for D7ACP .
        constexpr uint32_t D3ACP = (3 << 9);  ///< Domain 3 access control policy. See description for D7ACP .
        constexpr uint32_t D4ACP = (3 << 12);  ///< Domain 4 access control policy. See description for D7ACP .
        constexpr uint32_t D5ACP = (3 << 15);  ///< Domain 5 access control policy. See description for D7ACP .
        constexpr uint32_t D6ACP = (3 << 18);  ///< Domain 6 access control policy. See description for D7ACP .
        constexpr uint32_t D7ACP = (3 << 21);  ///< Domain 7 access control policy
        constexpr uint32_t SNUM = (6 << 24);  ///< Semaphore number. Include this hardware semaphore in the DxACP access evaluation.
        constexpr uint32_t SE = (1U << 30);  ///< Semaphore enable
    }

    /// MRGD_W3_ Register bits
    namespace mrgd_w3__bits {
        constexpr uint32_t D8ACP = (3 << 0);  ///< Domain 8 access control policy. See description for D7ACP .
        constexpr uint32_t D9ACP = (3 << 3);  ///< Domain 9 access control policy. See description for D7ACP .
        constexpr uint32_t D10ACP = (3 << 6);  ///< Domain 10 access control policy. See description for D7ACP .
        constexpr uint32_t D11ACP = (3 << 9);  ///< Domain 11 access control policy. See description for D7ACP .
        constexpr uint32_t D12ACP = (3 << 12);  ///< Domain 12 access control policy. See description for D7ACP .
        constexpr uint32_t D13ACP = (3 << 15);  ///< Domain 13 access control policy. See description for D7ACP .
        constexpr uint32_t D14ACP = (3 << 18);  ///< Domain 14 access control policy. See description for D7ACP .
        constexpr uint32_t D15ACP = (3 << 21);  ///< Domain 15 access control policy. See description for D7ACP .
        constexpr uint32_t LK2 = (2 << 29);  ///< Lock
        constexpr uint32_t VLD = (1U << 31);  ///< Valid
    }

}

// ============================================================================
// SEMA420 Peripheral
// ============================================================================

namespace sema420 {
    /// Base addresses
    constexpr uint32_t SEMA420_BASE = 0x4001B000;

    /// SEMA420 Register structure
    struct Registers {
        volatile uint32_t GATE;  ///< Offset: 0x00 - Gate Register (renamed from GATE)
        volatile uint32_t RSTGT_R;  ///< Offset: 0x42 - Reset Gate Read
        volatile uint32_t RSTGT_W;  ///< Offset: 0x42 - Reset Gate Write
    };

    /// Peripheral instances
    inline Registers* SEMA420 = reinterpret_cast<Registers*>(SEMA420_BASE);

    // Bit definitions
    /// GATE Register bits
    namespace gate_bits {
        constexpr uint32_t GTFSM = (4 << 0);  ///< Gate Finite State Machine.
    }

    /// RSTGT_R Register bits
    namespace rstgt_r_bits {
        constexpr uint32_t RSTGTN = (8 << 0);  ///< Reset Gate Number
        constexpr uint32_t RSTGMS = (4 << 8);  ///< Reset Gate Bus Master
        constexpr uint32_t RSTGSM = (2 << 12);  ///< Reset Gate Finite State Machine
        constexpr uint32_t ROZ = (2 << 14);  ///< This field always returns the value 0 when read.
    }

    /// RSTGT_W Register bits
    namespace rstgt_w_bits {
        constexpr uint32_t RSTGTN = (8 << 0);  ///< Reset Gate Number
        constexpr uint32_t RSTGDP = (8 << 8);  ///< Reset Gate Data Pattern
    }

}

// ============================================================================
// SEMA421 Peripheral
// ============================================================================

namespace sema421 {
    /// Base addresses
    constexpr uint32_t SEMA421_BASE = 0x4009B000;

    /// SEMA421 Register structure
    struct Registers {
        volatile uint32_t GATE;  ///< Offset: 0x00 - Gate Register (renamed from GATE)
        volatile uint32_t RSTGT_R;  ///< Offset: 0x42 - Reset Gate Read
        volatile uint32_t RSTGT_W;  ///< Offset: 0x42 - Reset Gate Write
    };

    /// Peripheral instances
    inline Registers* SEMA421 = reinterpret_cast<Registers*>(SEMA421_BASE);

    // Bit definitions
    /// GATE Register bits
    namespace gate_bits {
        constexpr uint32_t GTFSM = (4 << 0);  ///< Gate Finite State Machine.
    }

    /// RSTGT_R Register bits
    namespace rstgt_r_bits {
        constexpr uint32_t RSTGTN = (8 << 0);  ///< Reset Gate Number
        constexpr uint32_t RSTGMS = (4 << 8);  ///< Reset Gate Bus Master
        constexpr uint32_t RSTGSM = (2 << 12);  ///< Reset Gate Finite State Machine
        constexpr uint32_t ROZ = (2 << 14);  ///< This field always returns the value 0 when read.
    }

    /// RSTGT_W Register bits
    namespace rstgt_w_bits {
        constexpr uint32_t RSTGTN = (8 << 0);  ///< Reset Gate Number
        constexpr uint32_t RSTGDP = (8 << 8);  ///< Reset Gate Data Pattern
    }

}

// ============================================================================
// MU0 Peripheral
// ============================================================================

namespace mu0 {
    /// Base addresses
    constexpr uint32_t MU0_A_BASE = 0x40023000;
    constexpr uint32_t MU0_B_BASE = 0x400A3000;

    /// MU0 Register structure
    struct Registers {
        volatile uint32_t VER;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t TR;  ///< Offset: 0x20 - Transmit Register (renamed from TR)
        volatile uint32_t RR;  ///< Offset: 0x40 - Receive Register (renamed from RR)
        volatile uint32_t SR;  ///< Offset: 0x60 - Status Register
        volatile uint32_t CR;  ///< Offset: 0x64 - Control Register
    };

    /// Peripheral instances
    inline Registers* MU0_A = reinterpret_cast<Registers*>(MU0_A_BASE);
    inline Registers* MU0_B = reinterpret_cast<Registers*>(MU0_B_BASE);

    // Bit definitions
    /// VER Register bits
    namespace ver_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Processor A/B Transmit Register Data
    }

    /// RR Register bits
    namespace rr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Processor A/B Receive Register
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t Fn = (3 << 0);  ///< For n = {0, 1, 2} Processor A/B Side Flag n
        constexpr uint32_t NMIC = (1U << 3);  ///< Processor A/B Non-Maskable-Interrupt Clear
        constexpr uint32_t EP = (1U << 4);  ///< Processor A/B Side Event Pending
        constexpr uint32_t PM = (2 << 5);  ///< Processor B/A Power Mode
        constexpr uint32_t FUP = (1U << 8);  ///< Processor A/B Flags Update Pending
        constexpr uint32_t TEn = (4 << 20);  ///< For n = {0, 1, 2, 3} Processor A/B Transmit Register n Empty
        constexpr uint32_t RFn = (4 << 24);  ///< For n = {0, 1, 2, 3} Processor A/B Receive Register n Full
        constexpr uint32_t GIPn = (4 << 28);  ///< For n = {0, 1, 2, 3} Processor A/B General Interrupt Request n Pending
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t Fn = (3 << 0);  ///< For n = {0, 1, 2} Processor A/B to Processor B/A Flag n
        constexpr uint32_t NMI = (1U << 3);  ///< Processor B/A Non-maskable Interrupt
        constexpr uint32_t MUR = (1U << 5);  ///< Processor A MU Reset
        constexpr uint32_t BRSTH = (1U << 7);  ///< Processor B Reset Hold
        constexpr uint32_t CLKE = (1U << 8);  ///< Processor B/A clock enable
        constexpr uint32_t BBOOT = (2 << 9);  ///< Processor B Boot Config.
        constexpr uint32_t GIRn = (4 << 16);  ///< For n = {0, 1, 2, 3} Processor A/B General Purpose Interrupt Request n
        constexpr uint32_t TIEn = (4 << 20);  ///< For n = {0, 1, 2, 3} Processor A/B Transmit Interrupt Enable n
        constexpr uint32_t RIEn = (4 << 24);  ///< For n = {0, 1, 2, 3} Processor A/B Receive Interrupt Enable n
        constexpr uint32_t GIEn = (4 << 28);  ///< For n = {0, 1, 2, 3} Processor A/B General Purpose Interrupt Enable n
    }

}

// ============================================================================
// INTMUX0 Peripheral
// ============================================================================

namespace intmux0 {
    /// Base addresses
    constexpr uint32_t INTMUX0_BASE = 0x40024000;

    /// INTMUX0 Register structure
    struct Registers {
        volatile uint32_t CH_CSR;  ///< Offset: 0x00 - Channel n Control Status Register (renamed from CH_CSR)
        volatile uint32_t CH_VEC;  ///< Offset: 0x04 - Channel n Vector Number Register (renamed from CH_VEC)
        volatile uint32_t CH_IER_31_0;  ///< Offset: 0x10 - Channel n Interrupt Enable Register (renamed from CH_IER_31_0)
        volatile uint32_t CH_IPR_31_0;  ///< Offset: 0x20 - Channel n Interrupt Pending Register (renamed from CH_IPR_31_0)
    };

    /// Peripheral instances
    inline Registers* INTMUX0 = reinterpret_cast<Registers*>(INTMUX0_BASE);

    // Bit definitions
    /// CH_CSR Register bits
    namespace ch_csr_bits {
        constexpr uint32_t RST = (1U << 0);  ///< Software Reset
        constexpr uint32_t AND_ = (1U << 1);  ///< Logic AND (renamed from AND_)
        constexpr uint32_t IRQN = (2 << 4);  ///< Channel Input Number
        constexpr uint32_t CHIN = (4 << 8);  ///< Channel Instance Number
        constexpr uint32_t IRQP = (1U << 31);  ///< Channel Interrupt Request Pending
    }

    /// CH_VEC Register bits
    namespace ch_vec_bits {
        constexpr uint32_t VECN = (12 << 2);  ///< Vector Number
    }

    /// CH_IER_31_0 Register bits
    namespace ch_ier_31_0_bits {
        constexpr uint32_t INTE = (32 << 0);  ///< Interrupt Enable
    }

    /// CH_IPR_31_0 Register bits
    namespace ch_ipr_31_0_bits {
        constexpr uint32_t INTP = (32 << 0);  ///< Interrupt Pending
    }

}

// ============================================================================
// TRGMUX0 Peripheral
// ============================================================================

namespace trgmux0 {
    /// Base addresses
    constexpr uint32_t TRGMUX0_BASE = 0x40027000;

    /// TRGMUX0 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_DMAMUX0;  ///< Offset: 0x00 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPIT0;  ///< Offset: 0x04 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_TPM2;  ///< Offset: 0x08 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_ADC0;  ///< Offset: 0x10 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPUART2;  ///< Offset: 0x14 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPI2C2;  ///< Offset: 0x1C - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPSPI2;  ///< Offset: 0x24 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_CMP0;  ///< Offset: 0x2C - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_CMP1;  ///< Offset: 0x30 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_DAC0;  ///< Offset: 0x34 - TRGMUX TRGCFG Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX0 = reinterpret_cast<Registers*>(TRGMUX0_BASE);

    // Bit definitions
    /// TRGMUX_DMAMUX0 Register bits
    namespace trgmux_dmamux0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPIT0 Register bits
    namespace trgmux_lpit0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_TPM2 Register bits
    namespace trgmux_tpm2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_ADC0 Register bits
    namespace trgmux_adc0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART2 Register bits
    namespace trgmux_lpuart2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C2 Register bits
    namespace trgmux_lpi2c2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI2 Register bits
    namespace trgmux_lpspi2_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP0 Register bits
    namespace trgmux_cmp0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_CMP1 Register bits
    namespace trgmux_cmp1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_DAC0 Register bits
    namespace trgmux_dac0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// TRGMUX1 Peripheral
// ============================================================================

namespace trgmux1 {
    /// Base addresses
    constexpr uint32_t TRGMUX1_BASE = 0x400A7000;

    /// TRGMUX1 Register structure
    struct Registers {
        volatile uint32_t TRGMUX_DMAMUX1;  ///< Offset: 0x00 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPIT1;  ///< Offset: 0x04 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_TPM0;  ///< Offset: 0x08 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_TPM1;  ///< Offset: 0x0C - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_FLEXIO;  ///< Offset: 0x10 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPUART0;  ///< Offset: 0x14 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPUART1;  ///< Offset: 0x18 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPI2C0;  ///< Offset: 0x1C - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPI2C1;  ///< Offset: 0x20 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPSPI0;  ///< Offset: 0x24 - TRGMUX TRGCFG Register
        volatile uint32_t TRGMUX_LPSPI1;  ///< Offset: 0x28 - TRGMUX TRGCFG Register
    };

    /// Peripheral instances
    inline Registers* TRGMUX1 = reinterpret_cast<Registers*>(TRGMUX1_BASE);

    // Bit definitions
    /// TRGMUX_DMAMUX1 Register bits
    namespace trgmux_dmamux1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPIT1 Register bits
    namespace trgmux_lpit1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_TPM0 Register bits
    namespace trgmux_tpm0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_TPM1 Register bits
    namespace trgmux_tpm1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_FLEXIO Register bits
    namespace trgmux_flexio_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t SEL1 = (6 << 8);  ///< Trigger MUX Input 1 Source Select
        constexpr uint32_t SEL2 = (6 << 16);  ///< Trigger MUX Input 2 Source Select
        constexpr uint32_t SEL3 = (6 << 24);  ///< Trigger MUX Input 3 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART0 Register bits
    namespace trgmux_lpuart0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPUART1 Register bits
    namespace trgmux_lpuart1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C0 Register bits
    namespace trgmux_lpi2c0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPI2C1 Register bits
    namespace trgmux_lpi2c1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI0 Register bits
    namespace trgmux_lpspi0_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

    /// TRGMUX_LPSPI1 Register bits
    namespace trgmux_lpspi1_bits {
        constexpr uint32_t SEL0 = (6 << 0);  ///< Trigger MUX Input 0 Source Select
        constexpr uint32_t LK = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TPM0_BASE = 0x400AC000;
    constexpr uint32_t TPM1_BASE = 0x400AD000;
    constexpr uint32_t TPM2_BASE = 0x4002E000;
    constexpr uint32_t LPIT0_BASE = 0x40030000;
    constexpr uint32_t LPIT1_BASE = 0x400B1000;
    constexpr uint32_t LPTMR0_BASE = 0x40034000;
    constexpr uint32_t LPTMR1_BASE = 0x400B5000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - TPM Global Register
        volatile uint32_t SC;  ///< Offset: 0x10 - Status and Control
        volatile uint32_t CNT;  ///< Offset: 0x14 - Counter
        volatile uint32_t MOD;  ///< Offset: 0x18 - Modulo
        volatile uint32_t STATUS;  ///< Offset: 0x1C - Capture and Compare Status
        volatile uint32_t CSC;  ///< Offset: 0x20 - Channel (n) Status and Control (renamed from CSC)
        volatile uint32_t CV;  ///< Offset: 0x24 - Channel (n) Value (renamed from CV)
        volatile uint32_t COMBINE;  ///< Offset: 0x64 - Combine Channel Register
        volatile uint32_t TRIG;  ///< Offset: 0x6C - Channel Trigger
        volatile uint32_t POL;  ///< Offset: 0x70 - Channel Polarity
        volatile uint32_t FILTER;  ///< Offset: 0x78 - Filter Control
        volatile uint32_t QDCTRL;  ///< Offset: 0x80 - Quadrature Decoder Control and Status
        volatile uint32_t CONF;  ///< Offset: 0x84 - Configuration
    };

    /// Peripheral instances
    inline Registers* TPM0 = reinterpret_cast<Registers*>(TPM0_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);
    inline Registers* LPIT0 = reinterpret_cast<Registers*>(LPIT0_BASE);
    inline Registers* LPIT1 = reinterpret_cast<Registers*>(LPIT1_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);
    inline Registers* LPTMR1 = reinterpret_cast<Registers*>(LPTMR1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CHAN = (8 << 0);  ///< Channel Count
        constexpr uint32_t TRIG = (8 << 8);  ///< Trigger Count
        constexpr uint32_t WIDTH = (8 << 16);  ///< Counter Width
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t PS = (3 << 0);  ///< Prescale Factor Selection
        constexpr uint32_t CMOD = (2 << 3);  ///< Clock Mode Selection
        constexpr uint32_t CPWMS = (1U << 5);  ///< Center-Aligned PWM Select
        constexpr uint32_t TOIE = (1U << 6);  ///< Timer Overflow Interrupt Enable
        constexpr uint32_t TOF = (1U << 7);  ///< Timer Overflow Flag
        constexpr uint32_t DMA = (1U << 8);  ///< DMA Enable
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t COUNT = (16 << 0);  ///< Counter value
    }

    /// MOD Register bits
    namespace mod_bits {
        constexpr uint32_t MOD = (16 << 0);  ///< Modulo value
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t CH0F = (1U << 0);  ///< Channel 0 Flag
        constexpr uint32_t CH1F = (1U << 1);  ///< Channel 1 Flag
        constexpr uint32_t CH2F = (1U << 2);  ///< Channel 2 Flag
        constexpr uint32_t CH3F = (1U << 3);  ///< Channel 3 Flag
        constexpr uint32_t CH4F = (1U << 4);  ///< Channel 4 Flag
        constexpr uint32_t CH5F = (1U << 5);  ///< Channel 5 Flag
        constexpr uint32_t TOF = (1U << 8);  ///< Timer Overflow Flag
    }

    /// CSC Register bits
    namespace csc_bits {
        constexpr uint32_t DMA = (1U << 0);  ///< DMA Enable
        constexpr uint32_t ELSA = (1U << 2);  ///< Edge or Level Select
        constexpr uint32_t ELSB = (1U << 3);  ///< Edge or Level Select
        constexpr uint32_t MSA = (1U << 4);  ///< Channel Mode Select
        constexpr uint32_t MSB = (1U << 5);  ///< Channel Mode Select
        constexpr uint32_t CHIE = (1U << 6);  ///< Channel Interrupt Enable
        constexpr uint32_t CHF = (1U << 7);  ///< Channel Flag
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t VAL = (16 << 0);  ///< Channel Value
    }

    /// COMBINE Register bits
    namespace combine_bits {
        constexpr uint32_t COMBINE0 = (1U << 0);  ///< Combine Channels 0 and 1
        constexpr uint32_t COMSWAP0 = (1U << 1);  ///< Combine Channel 0 and 1 Swap
        constexpr uint32_t COMBINE1 = (1U << 8);  ///< Combine Channels 2 and 3
        constexpr uint32_t COMSWAP1 = (1U << 9);  ///< Combine Channels 2 and 3 Swap
        constexpr uint32_t COMBINE2 = (1U << 16);  ///< Combine Channels 4 and 5
        constexpr uint32_t COMSWAP2 = (1U << 17);  ///< Combine Channels 4 and 5 Swap
    }

    /// TRIG Register bits
    namespace trig_bits {
        constexpr uint32_t TRIG0 = (1U << 0);  ///< Channel 0 Trigger
        constexpr uint32_t TRIG1 = (1U << 1);  ///< Channel 1 Trigger
        constexpr uint32_t TRIG2 = (1U << 2);  ///< Channel 2 Trigger
        constexpr uint32_t TRIG3 = (1U << 3);  ///< Channel 3 Trigger
        constexpr uint32_t TRIG4 = (1U << 4);  ///< Channel 4 Trigger
        constexpr uint32_t TRIG5 = (1U << 5);  ///< Channel 5 Trigger
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL0 = (1U << 0);  ///< Channel 0 Polarity
        constexpr uint32_t POL1 = (1U << 1);  ///< Channel 1 Polarity
        constexpr uint32_t POL2 = (1U << 2);  ///< Channel 2 Polarity
        constexpr uint32_t POL3 = (1U << 3);  ///< Channel 3 Polarity
        constexpr uint32_t POL4 = (1U << 4);  ///< Channel 4 Polarity
        constexpr uint32_t POL5 = (1U << 5);  ///< Channel 5 Polarity
    }

    /// FILTER Register bits
    namespace filter_bits {
        constexpr uint32_t CH0FVAL = (4 << 0);  ///< Channel 0 Filter Value
        constexpr uint32_t CH1FVAL = (4 << 4);  ///< Channel 1 Filter Value
        constexpr uint32_t CH2FVAL = (4 << 8);  ///< Channel 2 Filter Value
        constexpr uint32_t CH3FVAL = (4 << 12);  ///< Channel 3 Filter Value
        constexpr uint32_t CH4FVAL = (4 << 16);  ///< Channel 4 Filter Value
        constexpr uint32_t CH5FVAL = (4 << 20);  ///< Channel 5 Filter Value
    }

    /// QDCTRL Register bits
    namespace qdctrl_bits {
        constexpr uint32_t QUADEN = (1U << 0);  ///< Enables the quadrature decoder mode
        constexpr uint32_t TOFDIR = (1U << 1);  ///< Indicates if the TOF bit was set on the top or the bottom of counting.
        constexpr uint32_t QUADIR = (1U << 2);  ///< Counter Direction in Quadrature Decode Mode
        constexpr uint32_t QUADMODE = (1U << 3);  ///< Quadrature Decoder Mode
    }

    /// CONF Register bits
    namespace conf_bits {
        constexpr uint32_t DOZEEN = (1U << 5);  ///< Doze Enable
        constexpr uint32_t DBGMODE = (2 << 6);  ///< Debug Mode
        constexpr uint32_t GTBSYNC = (1U << 8);  ///< Global Time Base Synchronization
        constexpr uint32_t GTBEEN = (1U << 9);  ///< Global time base enable
        constexpr uint32_t CSOT = (1U << 16);  ///< Counter Start on Trigger
        constexpr uint32_t CSOO = (1U << 17);  ///< Counter Stop On Overflow
        constexpr uint32_t CROT = (1U << 18);  ///< Counter Reload On Trigger
        constexpr uint32_t CPOT = (1U << 19);  ///< Counter Pause On Trigger
        constexpr uint32_t TRGPOL = (1U << 22);  ///< Trigger Polarity
        constexpr uint32_t TRGSRC = (1U << 23);  ///< Trigger Source
        constexpr uint32_t TRGSEL = (2 << 24);  ///< Trigger Select
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x40038000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t CPS = (1U << 5);  ///< Clock Pin Select
        constexpr uint32_t LPOS = (1U << 7);  ///< LPO Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
        constexpr uint32_t CPE = (2 << 24);  ///< Clock Pin Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
        constexpr uint32_t TSIC = (3 << 16);  ///< Timer Seconds Interrupt Configuration
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t LPSPI0_BASE = 0x400BC000;
    constexpr uint32_t LPSPI1_BASE = 0x400BD000;
    constexpr uint32_t LPSPI2_BASE = 0x4003E000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - Status Register
        volatile uint32_t IER;  ///< Offset: 0x18 - Interrupt Enable Register
        volatile uint32_t DER;  ///< Offset: 0x1C - DMA Enable Register
        volatile uint32_t CFGR0;  ///< Offset: 0x20 - Configuration Register 0
        volatile uint32_t CFGR1;  ///< Offset: 0x24 - Configuration Register 1
        volatile uint32_t DMR0;  ///< Offset: 0x30 - Data Match Register 0
        volatile uint32_t DMR1;  ///< Offset: 0x34 - Data Match Register 1
        volatile uint32_t CCR;  ///< Offset: 0x40 - Clock Configuration Register
        volatile uint32_t FCR;  ///< Offset: 0x58 - FIFO Control Register
        volatile uint32_t FSR;  ///< Offset: 0x5C - FIFO Status Register
        volatile uint32_t TCR;  ///< Offset: 0x60 - Transmit Command Register
        volatile uint32_t TDR;  ///< Offset: 0x64 - Transmit Data Register
        volatile uint32_t RSR;  ///< Offset: 0x70 - Receive Status Register
        volatile uint32_t RDR;  ///< Offset: 0x74 - Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPSPI0 = reinterpret_cast<Registers*>(LPSPI0_BASE);
    inline Registers* LPSPI1 = reinterpret_cast<Registers*>(LPSPI1_BASE);
    inline Registers* LPSPI2 = reinterpret_cast<Registers*>(LPSPI2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Module Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Module Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t WCF = (1U << 8);  ///< Word Complete Flag
        constexpr uint32_t FCF = (1U << 9);  ///< Frame Complete Flag
        constexpr uint32_t TCF = (1U << 10);  ///< Transfer Complete Flag
        constexpr uint32_t TEF = (1U << 11);  ///< Transmit Error Flag
        constexpr uint32_t REF = (1U << 12);  ///< Receive Error Flag
        constexpr uint32_t DMF = (1U << 13);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Module Busy Flag
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t WCIE = (1U << 8);  ///< Word Complete Interrupt Enable
        constexpr uint32_t FCIE = (1U << 9);  ///< Frame Complete Interrupt Enable
        constexpr uint32_t TCIE = (1U << 10);  ///< Transfer Complete Interrupt Enable
        constexpr uint32_t TEIE = (1U << 11);  ///< Transmit Error Interrupt Enable
        constexpr uint32_t REIE = (1U << 12);  ///< Receive Error Interrupt Enable
        constexpr uint32_t DMIE = (1U << 13);  ///< Data Match Interrupt Enable
    }

    /// DER Register bits
    namespace der_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// CFGR0 Register bits
    namespace cfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t MASTER = (1U << 0);  ///< Master Mode
        constexpr uint32_t SAMPLE = (1U << 1);  ///< Sample Point
        constexpr uint32_t AUTOPCS = (1U << 2);  ///< Automatic PCS
        constexpr uint32_t NOSTALL = (1U << 3);  ///< No Stall
        constexpr uint32_t PCSPOL = (4 << 8);  ///< Peripheral Chip Select Polarity
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (2 << 24);  ///< Pin Configuration
        constexpr uint32_t OUTCFG = (1U << 26);  ///< Output Config
        constexpr uint32_t PCSCFG = (1U << 27);  ///< Peripheral Chip Select Configuration
    }

    /// DMR0 Register bits
    namespace dmr0_bits {
        constexpr uint32_t MATCH0 = (32 << 0);  ///< Match 0 Value
    }

    /// DMR1 Register bits
    namespace dmr1_bits {
        constexpr uint32_t MATCH1 = (32 << 0);  ///< Match 1 Value
    }

    /// CCR Register bits
    namespace ccr_bits {
        constexpr uint32_t SCKDIV = (8 << 0);  ///< SCK Divider
        constexpr uint32_t DBT = (8 << 8);  ///< Delay Between Transfers
        constexpr uint32_t PCSSCK = (8 << 16);  ///< PCS to SCK Delay
        constexpr uint32_t SCKPCS = (8 << 24);  ///< SCK to PCS Delay
    }

    /// FCR Register bits
    namespace fcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// FSR Register bits
    namespace fsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t FRAMESZ = (12 << 0);  ///< Frame Size
        constexpr uint32_t WIDTH = (2 << 16);  ///< Transfer Width
        constexpr uint32_t TXMSK = (1U << 18);  ///< Transmit Data Mask
        constexpr uint32_t RXMSK = (1U << 19);  ///< Receive Data Mask
        constexpr uint32_t CONTC = (1U << 20);  ///< Continuing Command
        constexpr uint32_t CONT = (1U << 21);  ///< Continuous Transfer
        constexpr uint32_t BYSW = (1U << 22);  ///< Byte Swap
        constexpr uint32_t LSBF = (1U << 23);  ///< LSB First
        constexpr uint32_t PCS = (2 << 24);  ///< Peripheral Chip Select
        constexpr uint32_t PRESCALE = (3 << 27);  ///< Prescaler Value
        constexpr uint32_t CPHA = (1U << 30);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 31);  ///< Clock Polarity
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Transmit Data
    }

    /// RSR Register bits
    namespace rsr_bits {
        constexpr uint32_t SOF = (1U << 0);  ///< Start Of Frame
        constexpr uint32_t RXEMPTY = (1U << 1);  ///< RX FIFO Empty
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t LPI2C0_BASE = 0x400C0000;
    constexpr uint32_t LPI2C1_BASE = 0x400C1000;
    constexpr uint32_t LPI2C2_BASE = 0x40042000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t MCR;  ///< Offset: 0x10 - Master Control Register
        volatile uint32_t MSR;  ///< Offset: 0x14 - Master Status Register
        volatile uint32_t MIER;  ///< Offset: 0x18 - Master Interrupt Enable Register
        volatile uint32_t MDER;  ///< Offset: 0x1C - Master DMA Enable Register
        volatile uint32_t MCFGR0;  ///< Offset: 0x20 - Master Configuration Register 0
        volatile uint32_t MCFGR1;  ///< Offset: 0x24 - Master Configuration Register 1
        volatile uint32_t MCFGR2;  ///< Offset: 0x28 - Master Configuration Register 2
        volatile uint32_t MCFGR3;  ///< Offset: 0x2C - Master Configuration Register 3
        volatile uint32_t MDMR;  ///< Offset: 0x40 - Master Data Match Register
        volatile uint32_t MCCR0;  ///< Offset: 0x48 - Master Clock Configuration Register 0
        volatile uint32_t MCCR1;  ///< Offset: 0x50 - Master Clock Configuration Register 1
        volatile uint32_t MFCR;  ///< Offset: 0x58 - Master FIFO Control Register
        volatile uint32_t MFSR;  ///< Offset: 0x5C - Master FIFO Status Register
        volatile uint32_t MTDR;  ///< Offset: 0x60 - Master Transmit Data Register
        volatile uint32_t MRDR;  ///< Offset: 0x70 - Master Receive Data Register
        volatile uint32_t SCR;  ///< Offset: 0x110 - Slave Control Register
        volatile uint32_t SSR;  ///< Offset: 0x114 - Slave Status Register
        volatile uint32_t SIER;  ///< Offset: 0x118 - Slave Interrupt Enable Register
        volatile uint32_t SDER;  ///< Offset: 0x11C - Slave DMA Enable Register
        volatile uint32_t SCFGR1;  ///< Offset: 0x124 - Slave Configuration Register 1
        volatile uint32_t SCFGR2;  ///< Offset: 0x128 - Slave Configuration Register 2
        volatile uint32_t SAMR;  ///< Offset: 0x140 - Slave Address Match Register
        volatile uint32_t SASR;  ///< Offset: 0x150 - Slave Address Status Register
        volatile uint32_t STAR;  ///< Offset: 0x154 - Slave Transmit ACK Register
        volatile uint32_t STDR;  ///< Offset: 0x160 - Slave Transmit Data Register
        volatile uint32_t SRDR;  ///< Offset: 0x170 - Slave Receive Data Register
    };

    /// Peripheral instances
    inline Registers* LPI2C0 = reinterpret_cast<Registers*>(LPI2C0_BASE);
    inline Registers* LPI2C1 = reinterpret_cast<Registers*>(LPI2C1_BASE);
    inline Registers* LPI2C2 = reinterpret_cast<Registers*>(LPI2C2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t MTXFIFO = (4 << 0);  ///< Master Transmit FIFO Size
        constexpr uint32_t MRXFIFO = (4 << 8);  ///< Master Receive FIFO Size
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MEN = (1U << 0);  ///< Master Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t DOZEN = (1U << 2);  ///< Doze mode enable
        constexpr uint32_t DBGEN = (1U << 3);  ///< Debug Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// MSR Register bits
    namespace msr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t EPF = (1U << 8);  ///< End Packet Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t NDF = (1U << 10);  ///< NACK Detect Flag
        constexpr uint32_t ALF = (1U << 11);  ///< Arbitration Lost Flag
        constexpr uint32_t FEF = (1U << 12);  ///< FIFO Error Flag
        constexpr uint32_t PLTF = (1U << 13);  ///< Pin Low Timeout Flag
        constexpr uint32_t DMF = (1U << 14);  ///< Data Match Flag
        constexpr uint32_t MBF = (1U << 24);  ///< Master Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// MIER Register bits
    namespace mier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t EPIE = (1U << 8);  ///< End Packet Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t NDIE = (1U << 10);  ///< NACK Detect Interrupt Enable
        constexpr uint32_t ALIE = (1U << 11);  ///< Arbitration Lost Interrupt Enable
        constexpr uint32_t FEIE = (1U << 12);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t PLTIE = (1U << 13);  ///< Pin Low Timeout Interrupt Enable
        constexpr uint32_t DMIE = (1U << 14);  ///< Data Match Interrupt Enable
    }

    /// MDER Register bits
    namespace mder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
    }

    /// MCFGR0 Register bits
    namespace mcfgr0_bits {
        constexpr uint32_t HREN = (1U << 0);  ///< Host Request Enable
        constexpr uint32_t HRPOL = (1U << 1);  ///< Host Request Polarity
        constexpr uint32_t HRSEL = (1U << 2);  ///< Host Request Select
        constexpr uint32_t CIRFIFO = (1U << 8);  ///< Circular FIFO Enable
        constexpr uint32_t RDMO = (1U << 9);  ///< Receive Data Match Only
    }

    /// MCFGR1 Register bits
    namespace mcfgr1_bits {
        constexpr uint32_t PRESCALE = (3 << 0);  ///< Prescaler
        constexpr uint32_t AUTOSTOP = (1U << 8);  ///< Automatic STOP Generation
        constexpr uint32_t IGNACK = (1U << 9);  ///< When set, the received NACK field is ignored and assumed to be ACK
        constexpr uint32_t TIMECFG = (1U << 10);  ///< Timeout Configuration
        constexpr uint32_t MATCFG = (3 << 16);  ///< Match Configuration
        constexpr uint32_t PINCFG = (3 << 24);  ///< Pin Configuration
    }

    /// MCFGR2 Register bits
    namespace mcfgr2_bits {
        constexpr uint32_t BUSIDLE = (12 << 0);  ///< Bus Idle Timeout
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// MCFGR3 Register bits
    namespace mcfgr3_bits {
        constexpr uint32_t PINLOW = (12 << 8);  ///< Pin Low Timeout
    }

    /// MDMR Register bits
    namespace mdmr_bits {
        constexpr uint32_t MATCH0 = (8 << 0);  ///< Match 0 Value
        constexpr uint32_t MATCH1 = (8 << 16);  ///< Match 1 Value
    }

    /// MCCR0 Register bits
    namespace mccr0_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MCCR1 Register bits
    namespace mccr1_bits {
        constexpr uint32_t CLKLO = (6 << 0);  ///< Clock Low Period
        constexpr uint32_t CLKHI = (6 << 8);  ///< Clock High Period
        constexpr uint32_t SETHOLD = (6 << 16);  ///< Setup Hold Delay
        constexpr uint32_t DATAVD = (6 << 24);  ///< Data Valid Delay
    }

    /// MFCR Register bits
    namespace mfcr_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit FIFO Watermark
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive FIFO Watermark
    }

    /// MFSR Register bits
    namespace mfsr_bits {
        constexpr uint32_t TXCOUNT = (8 << 0);  ///< Transmit FIFO Count
        constexpr uint32_t RXCOUNT = (8 << 16);  ///< Receive FIFO Count
    }

    /// MTDR Register bits
    namespace mtdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
        constexpr uint32_t CMD = (3 << 8);  ///< Command Data
    }

    /// MRDR Register bits
    namespace mrdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t SEN = (1U << 0);  ///< Slave Enable
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FILTEN = (1U << 4);  ///< Filter Enable
        constexpr uint32_t FILTDZ = (1U << 5);  ///< Filter Doze Enable
        constexpr uint32_t RTF = (1U << 8);  ///< Reset Transmit FIFO
        constexpr uint32_t RRF = (1U << 9);  ///< Reset Receive FIFO
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t TDF = (1U << 0);  ///< Transmit Data Flag
        constexpr uint32_t RDF = (1U << 1);  ///< Receive Data Flag
        constexpr uint32_t AVF = (1U << 2);  ///< Address Valid Flag
        constexpr uint32_t TAF = (1U << 3);  ///< Transmit ACK Flag
        constexpr uint32_t RSF = (1U << 8);  ///< Repeated Start Flag
        constexpr uint32_t SDF = (1U << 9);  ///< STOP Detect Flag
        constexpr uint32_t BEF = (1U << 10);  ///< Bit Error Flag
        constexpr uint32_t FEF = (1U << 11);  ///< FIFO Error Flag
        constexpr uint32_t AM0F = (1U << 12);  ///< Address Match 0 Flag
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Flag
        constexpr uint32_t GCF = (1U << 14);  ///< General Call Flag
        constexpr uint32_t SARF = (1U << 15);  ///< SMBus Alert Response Flag
        constexpr uint32_t SBF = (1U << 24);  ///< Slave Busy Flag
        constexpr uint32_t BBF = (1U << 25);  ///< Bus Busy Flag
    }

    /// SIER Register bits
    namespace sier_bits {
        constexpr uint32_t TDIE = (1U << 0);  ///< Transmit Data Interrupt Enable
        constexpr uint32_t RDIE = (1U << 1);  ///< Receive Data Interrupt Enable
        constexpr uint32_t AVIE = (1U << 2);  ///< Address Valid Interrupt Enable
        constexpr uint32_t TAIE = (1U << 3);  ///< Transmit ACK Interrupt Enable
        constexpr uint32_t RSIE = (1U << 8);  ///< Repeated Start Interrupt Enable
        constexpr uint32_t SDIE = (1U << 9);  ///< STOP Detect Interrupt Enable
        constexpr uint32_t BEIE = (1U << 10);  ///< Bit Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 11);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t AM0IE = (1U << 12);  ///< Address Match 0 Interrupt Enable
        constexpr uint32_t AM1F = (1U << 13);  ///< Address Match 1 Interrupt Enable
        constexpr uint32_t GCIE = (1U << 14);  ///< General Call Interrupt Enable
        constexpr uint32_t SARIE = (1U << 15);  ///< SMBus Alert Response Interrupt Enable
    }

    /// SDER Register bits
    namespace sder_bits {
        constexpr uint32_t TDDE = (1U << 0);  ///< Transmit Data DMA Enable
        constexpr uint32_t RDDE = (1U << 1);  ///< Receive Data DMA Enable
        constexpr uint32_t AVDE = (1U << 2);  ///< Address Valid DMA Enable
    }

    /// SCFGR1 Register bits
    namespace scfgr1_bits {
        constexpr uint32_t ADRSTALL = (1U << 0);  ///< Address SCL Stall
        constexpr uint32_t RXSTALL = (1U << 1);  ///< RX SCL Stall
        constexpr uint32_t TXDSTALL = (1U << 2);  ///< TX Data SCL Stall
        constexpr uint32_t ACKSTALL = (1U << 3);  ///< ACK SCL Stall
        constexpr uint32_t GCEN = (1U << 8);  ///< General Call Enable
        constexpr uint32_t SAEN = (1U << 9);  ///< SMBus Alert Enable
        constexpr uint32_t TXCFG = (1U << 10);  ///< Transmit Flag Configuration
        constexpr uint32_t RXCFG = (1U << 11);  ///< Receive Data Configuration
        constexpr uint32_t IGNACK = (1U << 12);  ///< Ignore NACK
        constexpr uint32_t HSMEN = (1U << 13);  ///< High Speed Mode Enable
        constexpr uint32_t ADDRCFG = (3 << 16);  ///< Address Configuration
    }

    /// SCFGR2 Register bits
    namespace scfgr2_bits {
        constexpr uint32_t CLKHOLD = (4 << 0);  ///< Clock Hold Time
        constexpr uint32_t DATAVD = (6 << 8);  ///< Data Valid Delay
        constexpr uint32_t FILTSCL = (4 << 16);  ///< Glitch Filter SCL
        constexpr uint32_t FILTSDA = (4 << 24);  ///< Glitch Filter SDA
    }

    /// SAMR Register bits
    namespace samr_bits {
        constexpr uint32_t ADDR0 = (10 << 1);  ///< Address 0 Value
        constexpr uint32_t ADDR1 = (10 << 17);  ///< Address 1 Value
    }

    /// SASR Register bits
    namespace sasr_bits {
        constexpr uint32_t RADDR = (11 << 0);  ///< Received Address
        constexpr uint32_t ANV = (1U << 14);  ///< Address Not Valid
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t TXNACK = (1U << 0);  ///< Transmit NACK
    }

    /// STDR Register bits
    namespace stdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Transmit Data
    }

    /// SRDR Register bits
    namespace srdr_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Receive Data
        constexpr uint32_t RXEMPTY = (1U << 14);  ///< RX Empty
        constexpr uint32_t SOF = (1U << 15);  ///< Start Of Frame
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x400C4000;
    constexpr uint32_t LPUART1_BASE = 0x400C5000;
    constexpr uint32_t LPUART2_BASE = 0x40046000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t GLOBAL;  ///< Offset: 0x08 - LPUART Global Register
        volatile uint32_t PINCFG;  ///< Offset: 0x0C - LPUART Pin Configuration Register
        volatile uint32_t BAUD;  ///< Offset: 0x10 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x14 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x18 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x1C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x20 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x24 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x28 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x2C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Identification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t TXFIFO = (8 << 0);  ///< Transmit FIFO Size
        constexpr uint32_t RXFIFO = (8 << 8);  ///< Receive FIFO Size
    }

    /// GLOBAL Register bits
    namespace global_bits {
        constexpr uint32_t RST = (1U << 1);  ///< Software Reset
    }

    /// PINCFG Register bits
    namespace pincfg_bits {
        constexpr uint32_t TRGSEL = (2 << 0);  ///< Trigger Select
    }

    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (8 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (8 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (8 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4004C000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR1;  ///< Offset: 0x04 - SAI Transmit Configuration 1 Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register
        volatile uint32_t TFR;  ///< Offset: 0x40 - SAI Transmit FIFO Register
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR1;  ///< Offset: 0x84 - SAI Receive Configuration 1 Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register
        volatile uint32_t RFR;  ///< Offset: 0xC0 - SAI Receive FIFO Register
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR1 Register bits
    namespace tcr1_bits {
        constexpr uint32_t TFW = (2 << 0);  ///< Transmit FIFO Watermark
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (4 << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (1U << 16);  ///< Transmit Channel Enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (4 << 16);  ///< Frame size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TFR Register bits
    namespace tfr_bits {
        constexpr uint32_t RFP = (3 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (3 << 16);  ///< Write FIFO Pointer
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (16 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FRDE = (1U << 0);  ///< FIFO Request DMA Enable
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FRIE = (1U << 8);  ///< FIFO Request Interrupt Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FRF = (1U << 16);  ///< FIFO Request Flag
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR1 Register bits
    namespace rcr1_bits {
        constexpr uint32_t RFW = (2 << 0);  ///< Receive FIFO Watermark
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (4 << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (1U << 16);  ///< Receive Channel Enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (4 << 16);  ///< Frame Size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RFR Register bits
    namespace rfr_bits {
        constexpr uint32_t RFP = (3 << 0);  ///< Read FIFO Pointer
        constexpr uint32_t WFP = (3 << 16);  ///< Write FIFO Pointer
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (16 << 0);  ///< Receive Word Mask
    }

}

// ============================================================================
// EMVSIM0 Peripheral
// ============================================================================

namespace emvsim0 {
    /// Base addresses
    constexpr uint32_t EMVSIM0_BASE = 0x4004E000;

    /// EMVSIM0 Register structure
    struct Registers {
        volatile uint32_t VER_ID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CLKCFG;  ///< Offset: 0x08 - Clock Configuration Register
        volatile uint32_t DIVISOR;  ///< Offset: 0x0C - Baud Rate Divisor Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0x14 - Interrupt Mask Register
        volatile uint32_t RX_THD;  ///< Offset: 0x18 - Receiver Threshold Register
        volatile uint32_t TX_THD;  ///< Offset: 0x1C - Transmitter Threshold Register
        volatile uint32_t RX_STATUS;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t TX_STATUS;  ///< Offset: 0x24 - Transmitter Status Register
        volatile uint32_t PCSR;  ///< Offset: 0x28 - Port Control and Status Register
        volatile uint32_t RX_BUF;  ///< Offset: 0x2C - Receive Data Read Buffer
        volatile uint32_t TX_BUF;  ///< Offset: 0x30 - Transmit Data Buffer
        volatile uint32_t TX_GETU;  ///< Offset: 0x34 - Transmitter Guard ETU Value Register
        volatile uint32_t CWT_VAL;  ///< Offset: 0x38 - Character Wait Time Value Register
        volatile uint32_t BWT_VAL;  ///< Offset: 0x3C - Block Wait Time Value Register
        volatile uint32_t BGT_VAL;  ///< Offset: 0x40 - Block Guard Time Value Register
        volatile uint32_t GPCNT0_VAL;  ///< Offset: 0x44 - General Purpose Counter 0 Timeout Value Register
        volatile uint32_t GPCNT1_VAL;  ///< Offset: 0x48 - General Purpose Counter 1 Timeout Value
    };

    /// Peripheral instances
    inline Registers* EMVSIM0 = reinterpret_cast<Registers*>(EMVSIM0_BASE);

    // Bit definitions
    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t VER = (32 << 0);  ///< Version ID of the module
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RX_FIFO_DEPTH = (8 << 0);  ///< Receive FIFO Depth
        constexpr uint32_t TX_FIFO_DEPTH = (8 << 8);  ///< Transmit FIFO Depth
    }

    /// CLKCFG Register bits
    namespace clkcfg_bits {
        constexpr uint32_t CLK_PRSC = (8 << 0);  ///< Clock Prescaler Value
        constexpr uint32_t GPCNT1_CLK_SEL = (2 << 8);  ///< General Purpose Counter 1 Clock Select
        constexpr uint32_t GPCNT0_CLK_SEL = (2 << 10);  ///< General Purpose Counter 0 Clock Select
    }

    /// DIVISOR Register bits
    namespace divisor_bits {
        constexpr uint32_t DIVISOR_VALUE = (9 << 0);  ///< Divisor (F/D) Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t IC = (1U << 0);  ///< Inverse Convention
        constexpr uint32_t ICM = (1U << 1);  ///< Initial Character Mode
        constexpr uint32_t ANACK = (1U << 2);  ///< Auto NACK Enable
        constexpr uint32_t ONACK = (1U << 3);  ///< Overrun NACK Enable
        constexpr uint32_t FLSH_RX = (1U << 8);  ///< Flush Receiver Bit
        constexpr uint32_t FLSH_TX = (1U << 9);  ///< Flush Transmitter Bit
        constexpr uint32_t SW_RST = (1U << 10);  ///< Software Reset Bit
        constexpr uint32_t KILL_CLOCKS = (1U << 11);  ///< Kill all internal clocks
        constexpr uint32_t DOZE_EN = (1U << 12);  ///< Doze Enable
        constexpr uint32_t STOP_EN = (1U << 13);  ///< STOP Enable
        constexpr uint32_t RCV_EN = (1U << 16);  ///< Receiver Enable
        constexpr uint32_t XMT_EN = (1U << 17);  ///< Transmitter Enable
        constexpr uint32_t RCVR_11 = (1U << 18);  ///< Receiver 11 ETU Mode Enable
        constexpr uint32_t RX_DMA_EN = (1U << 19);  ///< Receive DMA Enable
        constexpr uint32_t TX_DMA_EN = (1U << 20);  ///< Transmit DMA Enable
        constexpr uint32_t INV_CRC_VAL = (1U << 24);  ///< Invert bits in the CRC Output Value
        constexpr uint32_t CRC_OUT_FLIP = (1U << 25);  ///< CRC Output Value Bit Reversal or Flip
        constexpr uint32_t CRC_IN_FLIP = (1U << 26);  ///< CRC Input Byte's Bit Reversal or Flip Control
        constexpr uint32_t CWT_EN = (1U << 27);  ///< Character Wait Time Counter Enable
        constexpr uint32_t LRC_EN = (1U << 28);  ///< LRC Enable
        constexpr uint32_t CRC_EN = (1U << 29);  ///< CRC Enable
        constexpr uint32_t XMT_CRC_LRC = (1U << 30);  ///< Transmit CRC or LRC Enable
        constexpr uint32_t BWT_EN = (1U << 31);  ///< Block Wait Time Counter Enable
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t RDT_IM = (1U << 0);  ///< Receive Data Threshold Interrupt Mask
        constexpr uint32_t TC_IM = (1U << 1);  ///< Transmit Complete Interrupt Mask
        constexpr uint32_t RFO_IM = (1U << 2);  ///< Receive FIFO Overflow Interrupt Mask
        constexpr uint32_t ETC_IM = (1U << 3);  ///< Early Transmit Complete Interrupt Mask
        constexpr uint32_t TFE_IM = (1U << 4);  ///< Transmit FIFO Empty Interrupt Mask
        constexpr uint32_t TNACK_IM = (1U << 5);  ///< Transmit NACK Threshold Interrupt Mask
        constexpr uint32_t TFF_IM = (1U << 6);  ///< Transmit FIFO Full Interrupt Mask
        constexpr uint32_t TDT_IM = (1U << 7);  ///< Transmit Data Threshold Interrupt Mask
        constexpr uint32_t GPCNT0_IM = (1U << 8);  ///< General Purpose Timer 0 Timeout Interrupt Mask
        constexpr uint32_t CWT_ERR_IM = (1U << 9);  ///< Character Wait Time Error Interrupt Mask
        constexpr uint32_t RNACK_IM = (1U << 10);  ///< Receiver NACK Threshold Interrupt Mask
        constexpr uint32_t BWT_ERR_IM = (1U << 11);  ///< Block Wait Time Error Interrupt Mask
        constexpr uint32_t BGT_ERR_IM = (1U << 12);  ///< Block Guard Time Error Interrupt
        constexpr uint32_t GPCNT1_IM = (1U << 13);  ///< General Purpose Counter 1 Timeout Interrupt Mask
        constexpr uint32_t RX_DATA_IM = (1U << 14);  ///< Receive Data Interrupt Mask
        constexpr uint32_t PEF_IM = (1U << 15);  ///< Parity Error Interrupt Mask
    }

    /// RX_THD Register bits
    namespace rx_thd_bits {
        constexpr uint32_t RDT = (4 << 0);  ///< Receiver Data Threshold Value
        constexpr uint32_t RNCK_THD = (4 << 8);  ///< Receiver NACK Threshold Value
    }

    /// TX_THD Register bits
    namespace tx_thd_bits {
        constexpr uint32_t TDT = (4 << 0);  ///< Transmitter Data Threshold Value
        constexpr uint32_t TNCK_THD = (4 << 8);  ///< Transmitter NACK Threshold Value
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t RFO = (1U << 0);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t RX_DATA = (1U << 4);  ///< Receive Data Interrupt Flag
        constexpr uint32_t RDTF = (1U << 5);  ///< Receive Data Threshold Interrupt Flag
        constexpr uint32_t LRC_OK = (1U << 6);  ///< LRC Check OK Flag
        constexpr uint32_t CRC_OK = (1U << 7);  ///< CRC Check OK Flag
        constexpr uint32_t CWT_ERR = (1U << 8);  ///< Character Wait Time Error Flag
        constexpr uint32_t RTE = (1U << 9);  ///< Received NACK Threshold Error Flag
        constexpr uint32_t BWT_ERR = (1U << 10);  ///< Block Wait Time Error Flag
        constexpr uint32_t BGT_ERR = (1U << 11);  ///< Block Guard Time Error Flag
        constexpr uint32_t PEF = (1U << 12);  ///< Parity Error Flag
        constexpr uint32_t FEF = (1U << 13);  ///< Frame Error Flag
        constexpr uint32_t RX_WPTR = (2 << 16);  ///< Receive FIFO Write Pointer Value
        constexpr uint32_t RX_CNT = (3 << 22);  ///< Receive FIFO Byte Count
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t TNTE = (1U << 0);  ///< Transmit NACK Threshold Error Flag
        constexpr uint32_t TFE = (1U << 3);  ///< Transmit FIFO Empty Flag
        constexpr uint32_t ETCF = (1U << 4);  ///< Early Transmit Complete Flag
        constexpr uint32_t TCF = (1U << 5);  ///< Transmit Complete Flag
        constexpr uint32_t TFF = (1U << 6);  ///< Transmit FIFO Full Flag
        constexpr uint32_t TDTF = (1U << 7);  ///< Transmit Data Threshold Flag
        constexpr uint32_t GPCNT0_TO = (1U << 8);  ///< General Purpose Counter 0 Timeout Flag
        constexpr uint32_t GPCNT1_TO = (1U << 9);  ///< General Purpose Counter 1 Timeout Flag
        constexpr uint32_t TX_RPTR = (2 << 16);  ///< Transmit FIFO Read Pointer
        constexpr uint32_t TX_CNT = (3 << 22);  ///< Transmit FIFO Byte Count
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t SAPD = (1U << 0);  ///< Auto Power Down Enable
        constexpr uint32_t SVCC_EN = (1U << 1);  ///< Vcc Enable for Smart Card
        constexpr uint32_t VCCENP = (1U << 2);  ///< VCC Enable Polarity Control
        constexpr uint32_t SRST = (1U << 3);  ///< Reset to Smart Card
        constexpr uint32_t SCEN = (1U << 4);  ///< Clock Enable for Smart Card
        constexpr uint32_t SCSP = (1U << 5);  ///< Smart Card Clock Stop Polarity
        constexpr uint32_t SPD = (1U << 7);  ///< Auto Power Down Control
        constexpr uint32_t SPDIM = (1U << 24);  ///< Smart Card Presence Detect Interrupt Mask
        constexpr uint32_t SPDIF = (1U << 25);  ///< Smart Card Presence Detect Interrupt Flag
        constexpr uint32_t SPDP = (1U << 26);  ///< Smart Card Presence Detect Pin Status
        constexpr uint32_t SPDES = (1U << 27);  ///< SIM Presence Detect Edge Select
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BYTE = (8 << 0);  ///< Receive Data Byte Read
    }

    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BYTE = (8 << 0);  ///< Transmit Data Byte
    }

    /// TX_GETU Register bits
    namespace tx_getu_bits {
        constexpr uint32_t GETU = (8 << 0);  ///< Transmitter Guard Time Value in ETU
    }

    /// CWT_VAL Register bits
    namespace cwt_val_bits {
        constexpr uint32_t CWT = (16 << 0);  ///< Character Wait Time Value
    }

    /// BWT_VAL Register bits
    namespace bwt_val_bits {
        constexpr uint32_t BWT = (32 << 0);  ///< Block Wait Time Value
    }

    /// BGT_VAL Register bits
    namespace bgt_val_bits {
        constexpr uint32_t BGT = (16 << 0);  ///< Block Guard Time Value
    }

    /// GPCNT0_VAL Register bits
    namespace gpcnt0_val_bits {
        constexpr uint32_t GPCNT0 = (16 << 0);  ///< General Purpose Counter 0 Timeout Value
    }

    /// GPCNT1_VAL Register bits
    namespace gpcnt1_val_bits {
        constexpr uint32_t GPCNT1 = (16 << 0);  ///< General Purpose Counter 1 Timeout Value
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40055000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t PERID;  ///< Offset: 0x00 - Peripheral ID register
        volatile uint32_t IDCOMP;  ///< Offset: 0x04 - Peripheral ID Complement register
        volatile uint32_t REV;  ///< Offset: 0x08 - Peripheral Revision register
        volatile uint32_t ADDINFO;  ///< Offset: 0x0C - Peripheral Additional Info register
        volatile uint32_t OTGISTAT;  ///< Offset: 0x10 - OTG Interrupt Status register
        volatile uint32_t OTGICR;  ///< Offset: 0x14 - OTG Interrupt Control register
        volatile uint32_t OTGSTAT;  ///< Offset: 0x18 - OTG Status register
        volatile uint32_t OTGCTL;  ///< Offset: 0x1C - OTG Control register
        volatile uint32_t ISTAT;  ///< Offset: 0x80 - Interrupt Status register
        volatile uint32_t INTEN;  ///< Offset: 0x84 - Interrupt Enable register
        volatile uint32_t ERRSTAT;  ///< Offset: 0x88 - Error Interrupt Status register
        volatile uint32_t ERREN;  ///< Offset: 0x8C - Error Interrupt Enable register
        volatile uint32_t STAT;  ///< Offset: 0x90 - Status register
        volatile uint32_t CTL;  ///< Offset: 0x94 - Control register
        volatile uint32_t ADDR;  ///< Offset: 0x98 - Address register
        volatile uint32_t BDTPAGE1;  ///< Offset: 0x9C - BDT Page register 1
        volatile uint32_t FRMNUML;  ///< Offset: 0xA0 - Frame Number register Low
        volatile uint32_t FRMNUMH;  ///< Offset: 0xA4 - Frame Number register High
        volatile uint32_t TOKEN;  ///< Offset: 0xA8 - Token register
        volatile uint32_t SOFTHLD;  ///< Offset: 0xAC - SOF Threshold register
        volatile uint32_t BDTPAGE2;  ///< Offset: 0xB0 - BDT Page Register 2
        volatile uint32_t BDTPAGE3;  ///< Offset: 0xB4 - BDT Page Register 3
        volatile uint32_t ENDPT;  ///< Offset: 0xC0 - Endpoint Control register (renamed from ENDPT)
        volatile uint32_t USBCTRL;  ///< Offset: 0x100 - USB Control register
        volatile uint32_t OBSERVE;  ///< Offset: 0x104 - USB OTG Observe register
        volatile uint32_t CONTROL;  ///< Offset: 0x108 - USB OTG Control register
        volatile uint32_t USBTRC0;  ///< Offset: 0x10C - USB Transceiver Control register 0
        volatile uint32_t USBFRMADJUST;  ///< Offset: 0x114 - Frame Adjust Register
        volatile uint32_t KEEP_ALIVE_CTRL;  ///< Offset: 0x124 - Keep Alive mode control
        volatile uint32_t KEEP_ALIVE_WKCTRL;  ///< Offset: 0x128 - Keep Alive mode wakeup control
        volatile uint32_t MISCCTRL;  ///< Offset: 0x12C - Miscellaneous Control register
        volatile uint32_t CLK_RECOVER_CTRL;  ///< Offset: 0x140 - USB Clock recovery control
        volatile uint32_t CLK_RECOVER_INT_EN;  ///< Offset: 0x154 - Clock recovery combined interrupt enable
        volatile uint32_t CLK_RECOVER_INT_STATUS;  ///< Offset: 0x15C - Clock recovery separated interrupt status
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// PERID Register bits
    namespace perid_bits {
        constexpr uint32_t ID = (6 << 0);  ///< Peripheral Identification
    }

    /// IDCOMP Register bits
    namespace idcomp_bits {
        constexpr uint32_t NID = (6 << 0);  ///< Ones' complement of PERID[ID] bits.
    }

    /// REV Register bits
    namespace rev_bits {
        constexpr uint32_t REV = (8 << 0);  ///< Revision
    }

    /// ADDINFO Register bits
    namespace addinfo_bits {
        constexpr uint32_t IEHOST = (1U << 0);  ///< This bit is set if host mode is enabled.
    }

    /// OTGISTAT Register bits
    namespace otgistat_bits {
        constexpr uint32_t LINE_STATE_CHG = (1U << 5);  ///< This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable
        constexpr uint32_t ONEMSEC = (1U << 6);  ///< This bit is set when the 1 millisecond timer expires
    }

    /// OTGICR Register bits
    namespace otgicr_bits {
        constexpr uint32_t LINESTATEEN = (1U << 5);  ///< Line State Change Interrupt Enable
        constexpr uint32_t ONEMSECEN = (1U << 6);  ///< One Millisecond Interrupt Enable
    }

    /// OTGSTAT Register bits
    namespace otgstat_bits {
        constexpr uint32_t LINESTATESTABLE = (1U << 5);  ///< Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 ms
        constexpr uint32_t ONEMSECEN = (1U << 6);  ///< This bit is reserved for the 1ms count, but it is not useful to software.
    }

    /// OTGCTL Register bits
    namespace otgctl_bits {
        constexpr uint32_t OTGEN = (1U << 2);  ///< On-The-Go pullup/pulldown resistor enable
        constexpr uint32_t DMLOW = (1U << 4);  ///< D- Data Line pull-down resistor enable
        constexpr uint32_t DPLOW = (1U << 5);  ///< D+ Data Line pull-down resistor enable
        constexpr uint32_t DPHIGH = (1U << 7);  ///< D+ Data Line pullup resistor enable
    }

    /// ISTAT Register bits
    namespace istat_bits {
        constexpr uint32_t USBRST = (1U << 0);  ///< This bit is set when the USB Module has decoded a valid USB reset
        constexpr uint32_t ERROR = (1U << 1);  ///< This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
        constexpr uint32_t SOFTOK = (1U << 2);  ///< This bit is set when the USB Module receives a Start Of Frame (SOF) token
        constexpr uint32_t TOKDNE = (1U << 3);  ///< This bit is set when the current token being processed has completed
        constexpr uint32_t SLEEP = (1U << 4);  ///< This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
        constexpr uint32_t RESUME = (1U << 5);  ///< This bit is set when a K-state is observed on the DP/DM signals for 2
        constexpr uint32_t ATTACH = (1U << 6);  ///< Attach Interrupt
        constexpr uint32_t STALL = (1U << 7);  ///< Stall Interrupt
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t USBRSTEN = (1U << 0);  ///< USBRST Interrupt Enable
        constexpr uint32_t ERROREN = (1U << 1);  ///< ERROR Interrupt Enable
        constexpr uint32_t SOFTOKEN = (1U << 2);  ///< SOFTOK Interrupt Enable
        constexpr uint32_t TOKDNEEN = (1U << 3);  ///< TOKDNE Interrupt Enable
        constexpr uint32_t SLEEPEN = (1U << 4);  ///< SLEEP Interrupt Enable
        constexpr uint32_t RESUMEEN = (1U << 5);  ///< RESUME Interrupt Enable
        constexpr uint32_t ATTACHEN = (1U << 6);  ///< ATTACH Interrupt Enable
        constexpr uint32_t STALLEN = (1U << 7);  ///< STALL Interrupt Enable
    }

    /// ERRSTAT Register bits
    namespace errstat_bits {
        constexpr uint32_t PIDERR = (1U << 0);  ///< This bit is set when the PID check field fails.
        constexpr uint32_t CRC5EOF = (1U << 1);  ///< This error interrupt has two functions
        constexpr uint32_t CRC16 = (1U << 2);  ///< This bit is set when a data packet is rejected due to a CRC16 error.
        constexpr uint32_t DFN8 = (1U << 3);  ///< This bit is set if the data field received was not 8 bits in length
        constexpr uint32_t BTOERR = (1U << 4);  ///< This bit is set when a bus turnaround timeout error occurs
        constexpr uint32_t DMAERR = (1U << 5);  ///< This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
        constexpr uint32_t OWNERR = (1U << 6);  ///< This field is valid when the USB Module is operating in peripheral mode (CTL[HOSTMODEEN]=0)
        constexpr uint32_t BTSERR = (1U << 7);  ///< This bit is set when a bit stuff error is detected
    }

    /// ERREN Register bits
    namespace erren_bits {
        constexpr uint32_t PIDERREN = (1U << 0);  ///< PIDERR Interrupt Enable
        constexpr uint32_t CRC5EOFEN = (1U << 1);  ///< CRC5/EOF Interrupt Enable
        constexpr uint32_t CRC16EN = (1U << 2);  ///< CRC16 Interrupt Enable
        constexpr uint32_t DFN8EN = (1U << 3);  ///< DFN8 Interrupt Enable
        constexpr uint32_t BTOERREN = (1U << 4);  ///< BTOERR Interrupt Enable
        constexpr uint32_t DMAERREN = (1U << 5);  ///< DMAERR Interrupt Enable
        constexpr uint32_t OWNERREN = (1U << 6);  ///< OWNERR Interrupt Enable
        constexpr uint32_t BTSERREN = (1U << 7);  ///< BTSERR Interrupt Enable
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t ODD = (1U << 2);  ///< This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
        constexpr uint32_t TX = (1U << 3);  ///< Transmit Indicator
        constexpr uint32_t ENDP = (4 << 4);  ///< This four-bit field encodes the endpoint address that received or transmitted the previous token
    }

    /// CTL Register bits
    namespace ctl_bits {
        constexpr uint32_t USBENSOFEN = (1U << 0);  ///< USB Enable
        constexpr uint32_t ODDRST = (1U << 1);  ///< Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
        constexpr uint32_t RESUME = (1U << 2);  ///< When set to 1 this bit enables the USB Module to execute resume signaling
        constexpr uint32_t HOSTMODEEN = (1U << 3);  ///< When set to 1, this bit enables the USB Module to operate in Host mode
        constexpr uint32_t RESET = (1U << 4);  ///< Setting this bit enables the USB Module to generate USB reset signaling
        constexpr uint32_t TXSUSPENDTOKENBUSY = (1U << 5);  ///< In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token
        constexpr uint32_t SE0 = (1U << 6);  ///< Live USB Single Ended Zero signal
        constexpr uint32_t JSTATE = (1U << 7);  ///< Live USB differential receiver JSTATE signal
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (7 << 0);  ///< USB Address
        constexpr uint32_t LSEN = (1U << 7);  ///< Low Speed Enable bit
    }

    /// BDTPAGE1 Register bits
    namespace bdtpage1_bits {
        constexpr uint32_t BDTBA = (7 << 1);  ///< Provides address bits 15 through 9 of the BDT base address.
    }

    /// FRMNUML Register bits
    namespace frmnuml_bits {
        constexpr uint32_t FRM = (8 << 0);  ///< This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// FRMNUMH Register bits
    namespace frmnumh_bits {
        constexpr uint32_t FRM = (3 << 0);  ///< This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// TOKEN Register bits
    namespace token_bits {
        constexpr uint32_t TOKENENDPT = (4 << 0);  ///< Holds the Endpoint address for the token command
        constexpr uint32_t TOKENPID = (4 << 4);  ///< Contains the token type executed by the USB module.
    }

    /// SOFTHLD Register bits
    namespace softhld_bits {
        constexpr uint32_t CNT = (8 << 0);  ///< Represents the SOF count threshold in byte times when SOFDYNTHLD=0 or 8 byte times when SOFDYNTHLD=1
    }

    /// BDTPAGE2 Register bits
    namespace bdtpage2_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// BDTPAGE3 Register bits
    namespace bdtpage3_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// ENDPT Register bits
    namespace endpt_bits {
        constexpr uint32_t EPHSHK = (1U << 0);  ///< When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
        constexpr uint32_t EPSTALL = (1U << 1);  ///< When set, this bit indicates that the endpoint is stalled
        constexpr uint32_t EPTXEN = (1U << 2);  ///< This bit, when set, enables the endpoint for TX transfers. See
        constexpr uint32_t EPRXEN = (1U << 3);  ///< This bit, when set, enables the endpoint for RX transfers. See
        constexpr uint32_t EPCTLDIS = (1U << 4);  ///< This bit, when set, disables control (SETUP) transfers
        constexpr uint32_t RETRYDIS = (1U << 6);  ///< This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only
        constexpr uint32_t HOSTWOHUB = (1U << 7);  ///< Host without a hub This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only
    }

    /// USBCTRL Register bits
    namespace usbctrl_bits {
        constexpr uint32_t UARTSEL = (1U << 4);  ///< Selects USB signals to be used as UART signals.
        constexpr uint32_t UARTCHLS = (1U << 5);  ///< UART Signal Channel Select
        constexpr uint32_t PDE = (1U << 6);  ///< Enables the weak pulldowns on the USB transceiver.
        constexpr uint32_t SUSP = (1U << 7);  ///< Places the USB transceiver into the suspend state.
    }

    /// OBSERVE Register bits
    namespace observe_bits {
        constexpr uint32_t DMPD = (1U << 4);  ///< Provides observability of the D- Pulldown enable at the USB transceiver.
        constexpr uint32_t DPPD = (1U << 6);  ///< Provides observability of the D+ Pulldown enable at the USB transceiver.
        constexpr uint32_t DPPU = (1U << 7);  ///< Provides observability of the D+ Pullup enable at the USB transceiver.
    }

    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t DPPULLUPNONOTG = (1U << 4);  ///< Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.
    }

    /// USBTRC0 Register bits
    namespace usbtrc0_bits {
        constexpr uint32_t USB_RESUME_INT = (1U << 0);  ///< USB Asynchronous Interrupt
        constexpr uint32_t SYNC_DET = (1U << 1);  ///< Synchronous USB Interrupt Detect
        constexpr uint32_t USB_CLK_RECOVERY_INT = (1U << 2);  ///< Combined USB Clock Recovery interrupt status
        constexpr uint32_t VREDG_DET = (1U << 3);  ///< VREGIN Rising Edge Interrupt Detect
        constexpr uint32_t VFEDG_DET = (1U << 4);  ///< VREGIN Falling Edge Interrupt Detect
        constexpr uint32_t USBRESMEN = (1U << 5);  ///< Asynchronous Resume Interrupt Enable
        constexpr uint32_t USBRESET = (1U << 7);  ///< USB Reset
    }

    /// USBFRMADJUST Register bits
    namespace usbfrmadjust_bits {
        constexpr uint32_t ADJ = (8 << 0);  ///< Frame Adjustment
    }

    /// KEEP_ALIVE_CTRL Register bits
    namespace keep_alive_ctrl_bits {
        constexpr uint32_t KEEP_ALIVE_EN = (1U << 0);  ///< Global enable for USB_KEEP_ALIVE mode
        constexpr uint32_t OWN_OVERRD_EN = (1U << 1);  ///< When set to 1, during KEEP_ALIVE mode, if received token is not SETUP, the OWN bit of current BD will be forced to 0, so usb core will respond with NAK
        constexpr uint32_t WAKE_REQ_EN = (1U << 3);  ///< During KEEP_ALIVE mode, a bus access by the USB controller to a memory location outside the USB SRAM will cause the bus access to stall until KEEP_ALIVE mode is exited
        constexpr uint32_t WAKE_INT_EN = (1U << 4);  ///< Wakeup Interrupt Enable.
        constexpr uint32_t WAKE_INT_STS = (1U << 7);  ///< Wakeup Interrupt Status.
    }

    /// KEEP_ALIVE_WKCTRL Register bits
    namespace keep_alive_wkctrl_bits {
        constexpr uint32_t WAKE_ON_THIS = (4 << 0);  ///< Software configure it to which token can wakeup usb during KEEP_ALIVE mode
        constexpr uint32_t WAKE_ENDPT = (4 << 4);  ///< Indicates which endpoint causes the wakeup interrupt. Reset to 0, software read only.
    }

    /// MISCCTRL Register bits
    namespace miscctrl_bits {
        constexpr uint32_t SOFDYNTHLD = (1U << 0);  ///< Dynamic SOF Threshold Compare mode
        constexpr uint32_t SOFBUSSET = (1U << 1);  ///< SOF_TOK Interrupt Generation Mode Select
        constexpr uint32_t OWNERRISODIS = (1U << 2);  ///< OWN Error Detect for ISO IN / ISO OUT Disable
        constexpr uint32_t VREDG_EN = (1U << 3);  ///< VREGIN Rising Edge Interrupt Enable
        constexpr uint32_t VFEDG_EN = (1U << 4);  ///< VREGIN Falling Edge Interrupt Enable
    }

    /// CLK_RECOVER_CTRL Register bits
    namespace clk_recover_ctrl_bits {
        constexpr uint32_t RESTART_IFRTRIM_EN = (1U << 5);  ///< Restart from IFR trim value
        constexpr uint32_t RESET_RESUME_ROUGH_EN = (1U << 6);  ///< Reset/resume to rough phase enable
        constexpr uint32_t CLOCK_RECOVER_EN = (1U << 7);  ///< Crystal-less USB enable
    }

    /// CLK_RECOVER_INT_EN Register bits
    namespace clk_recover_int_en_bits {
        constexpr uint32_t OVF_ERROR_EN = (1U << 4);  ///< Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.
    }

    /// CLK_RECOVER_INT_STATUS Register bits
    namespace clk_recover_int_status_bits {
        constexpr uint32_t OVF_ERROR = (1U << 4);  ///< Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the FIRC output clock is outside the available TRIM_FINE adjustment range for the FIRC module
    }

}

// ============================================================================
// LLWU0 Peripheral
// ============================================================================

namespace llwu0 {
    /// Base addresses
    constexpr uint32_t LLWU0_BASE = 0x40061000;

    /// LLWU0 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t PE1;  ///< Offset: 0x08 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x0C - LLWU Pin Enable 2 register
        volatile uint32_t ME;  ///< Offset: 0x18 - LLWU Module Interrupt Enable register
        volatile uint32_t DE;  ///< Offset: 0x1C - LLWU Module DMA Enable register
        volatile uint32_t PF;  ///< Offset: 0x20 - LLWU Pin Flag register
        volatile uint32_t MF;  ///< Offset: 0x28 - LLWU Module Interrupt Flag register
        volatile uint32_t FILT;  ///< Offset: 0x30 - LLWU Pin Filter register
    };

    /// Peripheral instances
    inline Registers* LLWU0 = reinterpret_cast<Registers*>(LLWU0_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t FILTERS = (8 << 0);  ///< Filter Number
        constexpr uint32_t DMAS = (8 << 8);  ///< DMA Number
        constexpr uint32_t MODULES = (8 << 16);  ///< Module Number
        constexpr uint32_t PINS = (8 << 24);  ///< Pin Number
    }

    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
        constexpr uint32_t WUPE4 = (2 << 8);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 10);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 12);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 14);  ///< Wakeup Pin Enable For LLWU_P7
        constexpr uint32_t WUPE8 = (2 << 16);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 18);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 20);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 22);  ///< Wakeup Pin Enable For LLWU_P11
        constexpr uint32_t WUPE12 = (2 << 24);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 26);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 28);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 30);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE16 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P16
        constexpr uint32_t WUPE17 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P17
        constexpr uint32_t WUPE18 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P18
        constexpr uint32_t WUPE19 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P19
        constexpr uint32_t WUPE20 = (2 << 8);  ///< Wakeup Pin Enable For LLWU_P20
        constexpr uint32_t WUPE21 = (2 << 10);  ///< Wakeup Pin Enable For LLWU_P21
        constexpr uint32_t WUPE22 = (2 << 12);  ///< Wakeup Pin Enable For LLWU_P22
        constexpr uint32_t WUPE23 = (2 << 14);  ///< Wakeup Pin Enable For LLWU_P23
        constexpr uint32_t WUPE24 = (2 << 16);  ///< Wakeup Pin Enable For LLWU_P24
        constexpr uint32_t WUPE25 = (2 << 18);  ///< Wakeup Pin Enable For LLWU_P25
        constexpr uint32_t WUPE26 = (2 << 20);  ///< Wakeup Pin Enable For LLWU_P26
        constexpr uint32_t WUPE27 = (2 << 22);  ///< Wakeup Pin Enable For LLWU_P27
        constexpr uint32_t WUPE28 = (2 << 24);  ///< Wakeup Pin Enable For LLWU_P28
        constexpr uint32_t WUPE29 = (2 << 26);  ///< Wakeup Pin Enable For LLWU_P29
        constexpr uint32_t WUPE30 = (2 << 28);  ///< Wakeup Pin Enable For LLWU_P30
        constexpr uint32_t WUPE31 = (2 << 30);  ///< Wakeup Pin Enable For LLWU_P31
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// DE Register bits
    namespace de_bits {
        constexpr uint32_t WUDE0 = (1U << 0);  ///< DMA Wakeup Enable For Module 0
        constexpr uint32_t WUDE1 = (1U << 1);  ///< DMA Wakeup Enable for Module 1
        constexpr uint32_t WUDE2 = (1U << 2);  ///< DMA Wakeup Enable For Module 2
        constexpr uint32_t WUDE3 = (1U << 3);  ///< DMA Wakeup Enable For Module 3
        constexpr uint32_t WUDE4 = (1U << 4);  ///< DMA Wakeup Enable For Module 4
        constexpr uint32_t WUDE5 = (1U << 5);  ///< DMA Wakeup Enable For Module 5
        constexpr uint32_t WUDE6 = (1U << 6);  ///< DMA Wakeup Enable For Module 6
        constexpr uint32_t WUDE7 = (1U << 7);  ///< DMA Wakeup Enable For Module 7
    }

    /// PF Register bits
    namespace pf_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
        constexpr uint32_t WUF8 = (1U << 8);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 9);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 10);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 11);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 12);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 13);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 14);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 15);  ///< Wakeup Flag For LLWU_P15
        constexpr uint32_t WUF16 = (1U << 16);  ///< Wakeup Flag For LLWU_P16
        constexpr uint32_t WUF17 = (1U << 17);  ///< Wakeup Flag For LLWU_P17
        constexpr uint32_t WUF18 = (1U << 18);  ///< Wakeup Flag For LLWU_P18
        constexpr uint32_t WUF19 = (1U << 19);  ///< Wakeup Flag For LLWU_P19
        constexpr uint32_t WUF20 = (1U << 20);  ///< Wakeup Flag For LLWU_P20
        constexpr uint32_t WUF21 = (1U << 21);  ///< Wakeup Flag For LLWU_P21
        constexpr uint32_t WUF22 = (1U << 22);  ///< Wakeup Flag For LLWU_P22
        constexpr uint32_t WUF23 = (1U << 23);  ///< Wakeup Flag For LLWU_P23
        constexpr uint32_t WUF24 = (1U << 24);  ///< Wakeup Flag For LLWU_P24
        constexpr uint32_t WUF25 = (1U << 25);  ///< Wakeup Flag For LLWU_P25
        constexpr uint32_t WUF26 = (1U << 26);  ///< Wakeup Flag For LLWU_P26
        constexpr uint32_t WUF27 = (1U << 27);  ///< Wakeup Flag For LLWU_P27
        constexpr uint32_t WUF28 = (1U << 28);  ///< Wakeup Flag For LLWU_P28
        constexpr uint32_t WUF29 = (1U << 29);  ///< Wakeup Flag For LLWU_P29
        constexpr uint32_t WUF30 = (1U << 30);  ///< Wakeup Flag For LLWU_P30
        constexpr uint32_t WUF31 = (1U << 31);  ///< Wakeup Flag For LLWU_P31
    }

    /// MF Register bits
    namespace mf_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILTSEL1 = (5 << 0);  ///< Filter 1 Pin Select
        constexpr uint32_t FILTE1 = (2 << 5);  ///< Filter 1 Enable
        constexpr uint32_t FILTF1 = (1U << 7);  ///< Filter 1 Flag
        constexpr uint32_t FILTSEL2 = (5 << 8);  ///< Filter 2 Pin Select
        constexpr uint32_t FILTE2 = (2 << 13);  ///< Filter 2 Enable
        constexpr uint32_t FILTF2 = (1U << 15);  ///< Filter 2 Flag
        constexpr uint32_t FILTSEL3 = (5 << 16);  ///< Filter 3 Pin Select
        constexpr uint32_t FILTE3 = (2 << 21);  ///< Filter 3 Enable
        constexpr uint32_t FILTF3 = (1U << 23);  ///< Filter 3 Flag
        constexpr uint32_t FILTSEL4 = (5 << 24);  ///< Filter 4 Pin Select
        constexpr uint32_t FILTE4 = (2 << 29);  ///< Filter 4 Enable
        constexpr uint32_t FILTF4 = (1U << 31);  ///< Filter 4 Flag
    }

}

// ============================================================================
// LLWU1 Peripheral
// ============================================================================

namespace llwu1 {
    /// Base addresses
    constexpr uint32_t LLWU1_BASE = 0x400E1000;

    /// LLWU1 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t PE1;  ///< Offset: 0x08 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x0C - LLWU Pin Enable 2 register
        volatile uint32_t ME;  ///< Offset: 0x18 - LLWU Module Interrupt Enable register
        volatile uint32_t DE;  ///< Offset: 0x1C - LLWU Module DMA Enable register
        volatile uint32_t PF;  ///< Offset: 0x20 - LLWU Pin Flag register
        volatile uint32_t MF;  ///< Offset: 0x28 - LLWU Module Interrupt Flag register
        volatile uint32_t FILT;  ///< Offset: 0x30 - LLWU Pin Filter register
    };

    /// Peripheral instances
    inline Registers* LLWU1 = reinterpret_cast<Registers*>(LLWU1_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t FILTERS = (8 << 0);  ///< Filter Number
        constexpr uint32_t DMAS = (8 << 8);  ///< DMA Number
        constexpr uint32_t MODULES = (8 << 16);  ///< Module Number
        constexpr uint32_t PINS = (8 << 24);  ///< Pin Number
    }

    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
        constexpr uint32_t WUPE4 = (2 << 8);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 10);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 12);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 14);  ///< Wakeup Pin Enable For LLWU_P7
        constexpr uint32_t WUPE8 = (2 << 16);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 18);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 20);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 22);  ///< Wakeup Pin Enable For LLWU_P11
        constexpr uint32_t WUPE12 = (2 << 24);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 26);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 28);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 30);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE16 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P16
        constexpr uint32_t WUPE17 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P17
        constexpr uint32_t WUPE18 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P18
        constexpr uint32_t WUPE19 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P19
        constexpr uint32_t WUPE20 = (2 << 8);  ///< Wakeup Pin Enable For LLWU_P20
        constexpr uint32_t WUPE21 = (2 << 10);  ///< Wakeup Pin Enable For LLWU_P21
        constexpr uint32_t WUPE22 = (2 << 12);  ///< Wakeup Pin Enable For LLWU_P22
        constexpr uint32_t WUPE23 = (2 << 14);  ///< Wakeup Pin Enable For LLWU_P23
        constexpr uint32_t WUPE24 = (2 << 16);  ///< Wakeup Pin Enable For LLWU_P24
        constexpr uint32_t WUPE25 = (2 << 18);  ///< Wakeup Pin Enable For LLWU_P25
        constexpr uint32_t WUPE26 = (2 << 20);  ///< Wakeup Pin Enable For LLWU_P26
        constexpr uint32_t WUPE27 = (2 << 22);  ///< Wakeup Pin Enable For LLWU_P27
        constexpr uint32_t WUPE28 = (2 << 24);  ///< Wakeup Pin Enable For LLWU_P28
        constexpr uint32_t WUPE29 = (2 << 26);  ///< Wakeup Pin Enable For LLWU_P29
        constexpr uint32_t WUPE30 = (2 << 28);  ///< Wakeup Pin Enable For LLWU_P30
        constexpr uint32_t WUPE31 = (2 << 30);  ///< Wakeup Pin Enable For LLWU_P31
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// DE Register bits
    namespace de_bits {
        constexpr uint32_t WUDE0 = (1U << 0);  ///< DMA Wakeup Enable For Module 0
        constexpr uint32_t WUDE1 = (1U << 1);  ///< DMA Wakeup Enable for Module 1
        constexpr uint32_t WUDE2 = (1U << 2);  ///< DMA Wakeup Enable For Module 2
        constexpr uint32_t WUDE3 = (1U << 3);  ///< DMA Wakeup Enable For Module 3
        constexpr uint32_t WUDE4 = (1U << 4);  ///< DMA Wakeup Enable For Module 4
        constexpr uint32_t WUDE5 = (1U << 5);  ///< DMA Wakeup Enable For Module 5
        constexpr uint32_t WUDE6 = (1U << 6);  ///< DMA Wakeup Enable For Module 6
        constexpr uint32_t WUDE7 = (1U << 7);  ///< DMA Wakeup Enable For Module 7
    }

    /// PF Register bits
    namespace pf_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
        constexpr uint32_t WUF8 = (1U << 8);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 9);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 10);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 11);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 12);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 13);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 14);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 15);  ///< Wakeup Flag For LLWU_P15
        constexpr uint32_t WUF16 = (1U << 16);  ///< Wakeup Flag For LLWU_P16
        constexpr uint32_t WUF17 = (1U << 17);  ///< Wakeup Flag For LLWU_P17
        constexpr uint32_t WUF18 = (1U << 18);  ///< Wakeup Flag For LLWU_P18
        constexpr uint32_t WUF19 = (1U << 19);  ///< Wakeup Flag For LLWU_P19
        constexpr uint32_t WUF20 = (1U << 20);  ///< Wakeup Flag For LLWU_P20
        constexpr uint32_t WUF21 = (1U << 21);  ///< Wakeup Flag For LLWU_P21
        constexpr uint32_t WUF22 = (1U << 22);  ///< Wakeup Flag For LLWU_P22
        constexpr uint32_t WUF23 = (1U << 23);  ///< Wakeup Flag For LLWU_P23
        constexpr uint32_t WUF24 = (1U << 24);  ///< Wakeup Flag For LLWU_P24
        constexpr uint32_t WUF25 = (1U << 25);  ///< Wakeup Flag For LLWU_P25
        constexpr uint32_t WUF26 = (1U << 26);  ///< Wakeup Flag For LLWU_P26
        constexpr uint32_t WUF27 = (1U << 27);  ///< Wakeup Flag For LLWU_P27
        constexpr uint32_t WUF28 = (1U << 28);  ///< Wakeup Flag For LLWU_P28
        constexpr uint32_t WUF29 = (1U << 29);  ///< Wakeup Flag For LLWU_P29
        constexpr uint32_t WUF30 = (1U << 30);  ///< Wakeup Flag For LLWU_P30
        constexpr uint32_t WUF31 = (1U << 31);  ///< Wakeup Flag For LLWU_P31
    }

    /// MF Register bits
    namespace mf_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT Register bits
    namespace filt_bits {
        constexpr uint32_t FILTSEL1 = (5 << 0);  ///< Filter 1 Pin Select
        constexpr uint32_t FILTE1 = (2 << 5);  ///< Filter 1 Enable
        constexpr uint32_t FILTF1 = (1U << 7);  ///< Filter 1 Flag
        constexpr uint32_t FILTSEL2 = (5 << 8);  ///< Filter 2 Pin Select
        constexpr uint32_t FILTE2 = (2 << 13);  ///< Filter 2 Enable
        constexpr uint32_t FILTF2 = (1U << 15);  ///< Filter 2 Flag
        constexpr uint32_t FILTSEL3 = (5 << 16);  ///< Filter 3 Pin Select
        constexpr uint32_t FILTE3 = (2 << 21);  ///< Filter 3 Enable
        constexpr uint32_t FILTF3 = (1U << 23);  ///< Filter 3 Flag
        constexpr uint32_t FILTSEL4 = (5 << 24);  ///< Filter 4 Pin Select
        constexpr uint32_t FILTE4 = (2 << 29);  ///< Filter 4 Enable
        constexpr uint32_t FILTF4 = (1U << 31);  ///< Filter 4 Flag
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40062000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - TSI General Control and Status Register
        volatile uint32_t DATA;  ///< Offset: 0x04 - TSI DATA Register
        volatile uint32_t TSHD;  ///< Offset: 0x08 - TSI Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t EOSDMEO = (1U << 0);  ///< End-of-Scan DMA Transfer Request Enable Only
        constexpr uint32_t CURSW = (1U << 1);  ///< CURSW
        constexpr uint32_t EOSF = (1U << 2);  ///< End of Scan Flag
        constexpr uint32_t SCNIP = (1U << 3);  ///< Scan In Progress Status
        constexpr uint32_t STM = (1U << 4);  ///< Scan Trigger Mode
        constexpr uint32_t STPE = (1U << 5);  ///< TSI STOP Enable
        constexpr uint32_t TSIIEN = (1U << 6);  ///< Touch Sensing Input Interrupt Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t NSCN = (5 << 8);  ///< NSCN
        constexpr uint32_t PS = (3 << 13);  ///< PS
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< EXTCHRG
        constexpr uint32_t DVOLT = (2 << 19);  ///< DVOLT
        constexpr uint32_t REFCHRG = (3 << 21);  ///< REFCHRG
        constexpr uint32_t MODE = (4 << 24);  ///< TSI analog modes setup and status bits.
        constexpr uint32_t ESOR = (1U << 28);  ///< End-of-scan or Out-of-Range Interrupt Selection
        constexpr uint32_t OUTRGF = (1U << 31);  ///< Out of Range Flag.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t TSICNT = (16 << 0);  ///< TSI Conversion Counter Value
        constexpr uint32_t SWTS = (1U << 22);  ///< Software Trigger Start
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Transfer Enabled
        constexpr uint32_t TSICH = (4 << 28);  ///< TSICH
    }

    /// TSHD Register bits
    namespace tshd_bits {
        constexpr uint32_t THRESL = (16 << 0);  ///< TSI Wakeup Channel Low-threshold
        constexpr uint32_t THRESH = (16 << 16);  ///< TSI Wakeup Channel High-threshold
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x40066000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4006A000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x4006E000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// CMP1 Peripheral
// ============================================================================

namespace cmp1 {
    /// Base addresses
    constexpr uint32_t CMP1_BASE = 0x400EF000;

    /// CMP1 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP1 = reinterpret_cast<Registers*>(CMP1_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40072000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
        volatile uint32_t TRM4;  ///< Offset: 0x05 - VREF Trim Register 4
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, the internal chopping operation is enabled and the internal analog offset will be minimized.
        constexpr uint32_t FLIP = (1U << 7);  ///< Reverses the amplifier polarity
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t TMUXEN = (1U << 3);  ///< Test MUX enable
        constexpr uint32_t TRESEN = (1U << 4);  ///< Test second order curvature compensation enable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

    /// TRM4 Register bits
    namespace trm4_bits {
        constexpr uint32_t VREF2V1_EN = (1U << 7);  ///< Internal Voltage Reference (2.1V) Enable
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40074000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t PCSR;  ///< Offset: 0x10EC - Peripheral Clock Status Register
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pin count identification
        constexpr uint32_t KEYATT = (3 << 4);  ///< Core configuration of the device.
        constexpr uint32_t DIEID = (5 << 7);  ///< Device Die Number
        constexpr uint32_t REVID = (4 << 12);  ///< Device Revision Number
        constexpr uint32_t SRAMSIZE = (4 << 16);  ///< System SRAM Size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis Sub-Family ID
        constexpr uint32_t FAMID = (4 << 28);  ///< Kinetis family ID
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program Flash Size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max Address lock
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (16 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t CS1 = (1U << 1);  ///< Clock Source 1
        constexpr uint32_t CS2 = (1U << 2);  ///< Clock Source 2
        constexpr uint32_t CS3 = (1U << 3);  ///< Clock Source 3
        constexpr uint32_t CS4 = (1U << 4);  ///< Clock Source 4
        constexpr uint32_t CS5 = (1U << 5);  ///< Clock Source 5
        constexpr uint32_t CS6 = (1U << 6);  ///< Clock Source 6
        constexpr uint32_t CS7 = (1U << 7);  ///< Clock Source 7
    }

}

// ============================================================================
// TSTMR0 Peripheral
// ============================================================================

namespace tstmr0 {
    /// Base addresses
    constexpr uint32_t TSTMR0_BASE = 0x400750F0;

    /// TSTMR0 Register structure
    struct Registers {
        volatile uint32_t L;  ///< Offset: 0x00 - Time Stamp Timer Register Low
        volatile uint32_t H;  ///< Offset: 0x04 - Time Stamp Timer Register High
    };

    /// Peripheral instances
    inline Registers* TSTMR0 = reinterpret_cast<Registers*>(TSTMR0_BASE);

    // Bit definitions
    /// L Register bits
    namespace l_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Time Stamp Timer Low
    }

    /// H Register bits
    namespace h_bits {
        constexpr uint32_t VALUE = (24 << 0);  ///< Time Stamp Timer High
    }

}

// ============================================================================
// TSTMR1 Peripheral
// ============================================================================

namespace tstmr1 {
    /// Base addresses
    constexpr uint32_t TSTMR1_BASE = 0x400F50F0;

    /// TSTMR1 Register structure
    struct Registers {
        volatile uint32_t L;  ///< Offset: 0x00 - Time Stamp Timer Register Low
        volatile uint32_t H;  ///< Offset: 0x04 - Time Stamp Timer Register High
    };

    /// Peripheral instances
    inline Registers* TSTMR1 = reinterpret_cast<Registers*>(TSTMR1_BASE);

    // Bit definitions
    /// L Register bits
    namespace l_bits {
        constexpr uint32_t VALUE = (32 << 0);  ///< Time Stamp Timer Low
    }

    /// H Register bits
    namespace h_bits {
        constexpr uint32_t VALUE = (24 << 0);  ///< Time Stamp Timer High
    }

}

// ============================================================================
// WDOG0 Peripheral
// ============================================================================

namespace wdog0 {
    /// Base addresses
    constexpr uint32_t WDOG0_BASE = 0x40076000;

    /// WDOG0 Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* WDOG0 = reinterpret_cast<Registers*>(WDOG0_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT_ = (1U << 6);  ///< Watchdog Interrupt (renamed from INT_)
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog Prescalar
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (or 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value;
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// WDOG1 Peripheral
// ============================================================================

namespace wdog1 {
    /// Base addresses
    constexpr uint32_t WDOG1_BASE = 0x400F6000;

    /// WDOG1 Register structure
    struct Registers {
        volatile uint32_t CS;  ///< Offset: 0x00 - Watchdog Control and Status Register
        volatile uint32_t CNT;  ///< Offset: 0x04 - Watchdog Counter Register
        volatile uint32_t TOVAL;  ///< Offset: 0x08 - Watchdog Timeout Value Register
        volatile uint32_t WIN;  ///< Offset: 0x0C - Watchdog Window Register
    };

    /// Peripheral instances
    inline Registers* WDOG1 = reinterpret_cast<Registers*>(WDOG1_BASE);

    // Bit definitions
    /// CS Register bits
    namespace cs_bits {
        constexpr uint32_t STOP = (1U << 0);  ///< Stop Enable
        constexpr uint32_t WAIT = (1U << 1);  ///< Wait Enable
        constexpr uint32_t DBG = (1U << 2);  ///< Debug Enable
        constexpr uint32_t TST = (2 << 3);  ///< Watchdog Test
        constexpr uint32_t UPDATE = (1U << 5);  ///< Allow updates
        constexpr uint32_t INT_ = (1U << 6);  ///< Watchdog Interrupt (renamed from INT_)
        constexpr uint32_t EN = (1U << 7);  ///< Watchdog Enable
        constexpr uint32_t CLK = (2 << 8);  ///< Watchdog Clock
        constexpr uint32_t PRES = (1U << 12);  ///< Watchdog Prescalar
        constexpr uint32_t CMD32EN = (1U << 13);  ///< Enables or disables WDOG support for 32-bit (or 16-bit or 8-bit) refresh/unlock command write words
        constexpr uint32_t FLG = (1U << 14);  ///< Watchdog Interrupt Flag
        constexpr uint32_t WIN = (1U << 15);  ///< Watchdog Window
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNTLOW = (8 << 0);  ///< Low byte of the Watchdog Counter
        constexpr uint32_t CNTHIGH = (8 << 8);  ///< High byte of the Watchdog Counter
    }

    /// TOVAL Register bits
    namespace toval_bits {
        constexpr uint32_t TOVALLOW = (8 << 0);  ///< Low byte of the timeout value
        constexpr uint32_t TOVALHIGH = (8 << 8);  ///< High byte of the timeout value;
    }

    /// WIN Register bits
    namespace win_bits {
        constexpr uint32_t WINLOW = (8 << 0);  ///< Low byte of Watchdog Window
        constexpr uint32_t WINHIGH = (8 << 8);  ///< High byte of Watchdog Window
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40078000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t DATAL;  ///< Offset: 0x00 - CRC_DATAL register.
        volatile uint32_t DATALL;  ///< Offset: 0x00 - CRC_DATALL register.
        volatile uint32_t DATALU;  ///< Offset: 0x01 - CRC_DATALU register.
        volatile uint32_t DATAH;  ///< Offset: 0x02 - CRC_DATAH register.
        volatile uint32_t DATAHL;  ///< Offset: 0x02 - CRC_DATAHL register.
        volatile uint32_t DATAHU;  ///< Offset: 0x03 - CRC_DATAHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// DATAL Register bits
    namespace datal_bits {
        constexpr uint32_t DATAL = (16 << 0);  ///< DATAL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// DATALL Register bits
    namespace datall_bits {
        constexpr uint32_t DATALL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit DATA
    }

    /// DATALU Register bits
    namespace datalu_bits {
        constexpr uint32_t DATALU = (8 << 0);  ///< DATALL stores the second 8 bits of the 32 bit CRC
    }

    /// DATAH Register bits
    namespace datah_bits {
        constexpr uint32_t DATAH = (16 << 0);  ///< DATAH stores the high 16 bits of the 16/32 bit CRC
    }

    /// DATAHL Register bits
    namespace datahl_bits {
        constexpr uint32_t DATAHL = (8 << 0);  ///< DATAHL stores the third 8 bits of the 32 bit CRC
    }

    /// DATAHU Register bits
    namespace datahu_bits {
        constexpr uint32_t DATAHU = (8 << 0);  ///< DATAHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// PCC0 Peripheral
// ============================================================================

namespace pcc0 {
    /// Base addresses
    constexpr uint32_t PCC0_BASE = 0x4007A000;

    /// PCC0 Register structure
    struct Registers {
        volatile uint32_t PCC_DMA0;  ///< Offset: 0x20 - PCC CLKCFG Register
        volatile uint32_t PCC_XRDC;  ///< Offset: 0x50 - PCC CLKCFG Register
        volatile uint32_t PCC_SEMA42_0;  ///< Offset: 0x6C - PCC CLKCFG Register
        volatile uint32_t PCC_FLASH;  ///< Offset: 0x80 - PCC CLKCFG Register
        volatile uint32_t PCC_DMAMUX0;  ///< Offset: 0x84 - PCC CLKCFG Register
        volatile uint32_t PCC_MU0_A;  ///< Offset: 0x8C - PCC CLKCFG Register
        volatile uint32_t PCC_INTMUX0;  ///< Offset: 0x90 - PCC CLKCFG Register
        volatile uint32_t PCC_TPM2;  ///< Offset: 0xB8 - PCC CLKCFG Register
        volatile uint32_t PCC_LPIT0;  ///< Offset: 0xC0 - PCC CLKCFG Register
        volatile uint32_t PCC_LPTMR0;  ///< Offset: 0xD0 - PCC CLKCFG Register
        volatile uint32_t PCC_RTC;  ///< Offset: 0xE0 - PCC CLKCFG Register
        volatile uint32_t PCC_LPSPI2;  ///< Offset: 0xF8 - PCC CLKCFG Register
        volatile uint32_t PCC_LPI2C2;  ///< Offset: 0x108 - PCC CLKCFG Register
        volatile uint32_t PCC_LPUART2;  ///< Offset: 0x118 - PCC CLKCFG Register
        volatile uint32_t PCC_SAI0;  ///< Offset: 0x130 - PCC CLKCFG Register
        volatile uint32_t PCC_EMVSIM0;  ///< Offset: 0x138 - PCC CLKCFG Register
        volatile uint32_t PCC_USB0FS;  ///< Offset: 0x154 - PCC CLKCFG Register
        volatile uint32_t PCC_PORTA;  ///< Offset: 0x168 - PCC CLKCFG Register
        volatile uint32_t PCC_PORTB;  ///< Offset: 0x16C - PCC CLKCFG Register
        volatile uint32_t PCC_PORTC;  ///< Offset: 0x170 - PCC CLKCFG Register
        volatile uint32_t PCC_PORTD;  ///< Offset: 0x174 - PCC CLKCFG Register
        volatile uint32_t PCC_PORTE;  ///< Offset: 0x178 - PCC CLKCFG Register
        volatile uint32_t PCC_TSI0;  ///< Offset: 0x188 - PCC CLKCFG Register
        volatile uint32_t PCC_ADC0;  ///< Offset: 0x198 - PCC CLKCFG Register
        volatile uint32_t PCC_DAC0;  ///< Offset: 0x1A8 - PCC CLKCFG Register
        volatile uint32_t PCC_CMP0;  ///< Offset: 0x1B8 - PCC CLKCFG Register
        volatile uint32_t PCC_VREF;  ///< Offset: 0x1C8 - PCC CLKCFG Register
        volatile uint32_t PCC_CRC;  ///< Offset: 0x1E0 - PCC CLKCFG Register
    };

    /// Peripheral instances
    inline Registers* PCC0 = reinterpret_cast<Registers*>(PCC0_BASE);

    // Bit definitions
    /// PCC_DMA0 Register bits
    namespace pcc_dma0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_XRDC Register bits
    namespace pcc_xrdc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_SEMA42_0 Register bits
    namespace pcc_sema42_0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLASH Register bits
    namespace pcc_flash_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_DMAMUX0 Register bits
    namespace pcc_dmamux0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_MU0_A Register bits
    namespace pcc_mu0_a_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_INTMUX0 Register bits
    namespace pcc_intmux0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_TPM2 Register bits
    namespace pcc_tpm2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPIT0 Register bits
    namespace pcc_lpit0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPTMR0 Register bits
    namespace pcc_lptmr0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_RTC Register bits
    namespace pcc_rtc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPSPI2 Register bits
    namespace pcc_lpspi2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPI2C2 Register bits
    namespace pcc_lpi2c2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART2 Register bits
    namespace pcc_lpuart2_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_SAI0 Register bits
    namespace pcc_sai0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_EMVSIM0 Register bits
    namespace pcc_emvsim0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_USB0FS Register bits
    namespace pcc_usb0fs_bits {
        constexpr uint32_t PCD = (3 << 0);  ///< Peripheral Clock Divider Select
        constexpr uint32_t FRAC = (1U << 3);  ///< Peripheral Clock Divider Fraction
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTA Register bits
    namespace pcc_porta_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTB Register bits
    namespace pcc_portb_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTC Register bits
    namespace pcc_portc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTD Register bits
    namespace pcc_portd_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTE Register bits
    namespace pcc_porte_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_TSI0 Register bits
    namespace pcc_tsi0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_ADC0 Register bits
    namespace pcc_adc0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_DAC0 Register bits
    namespace pcc_dac0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CMP0 Register bits
    namespace pcc_cmp0_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_VREF Register bits
    namespace pcc_vref_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CRC Register bits
    namespace pcc_crc_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// PCC1 Peripheral
// ============================================================================

namespace pcc1 {
    /// Base addresses
    constexpr uint32_t PCC1_BASE = 0x400FA000;

    /// PCC1 Register structure
    struct Registers {
        volatile uint32_t PCC_DMA1;  ///< Offset: 0x20 - PCC CLKCFG Register
        volatile uint32_t PCC_SEMA42_1;  ///< Offset: 0x6C - PCC CLKCFG Register
        volatile uint32_t PCC_DMAMUX1;  ///< Offset: 0x84 - PCC CLKCFG Register
        volatile uint32_t PCC_MU0_B;  ///< Offset: 0x8C - PCC CLKCFG Register
        volatile uint32_t PCC_INTMUX1;  ///< Offset: 0x90 - PCC CLKCFG Register
        volatile uint32_t PCC_TRNG;  ///< Offset: 0x94 - PCC CLKCFG Register
        volatile uint32_t PCC_TPM0;  ///< Offset: 0xB0 - PCC CLKCFG Register
        volatile uint32_t PCC_TPM1;  ///< Offset: 0xB4 - PCC CLKCFG Register
        volatile uint32_t PCC_LPIT1;  ///< Offset: 0xC4 - PCC CLKCFG Register
        volatile uint32_t PCC_LPTMR1;  ///< Offset: 0xD4 - PCC CLKCFG Register
        volatile uint32_t PCC_LPSPI0;  ///< Offset: 0xF0 - PCC CLKCFG Register
        volatile uint32_t PCC_LPSPI1;  ///< Offset: 0xF4 - PCC CLKCFG Register
        volatile uint32_t PCC_LPI2C0;  ///< Offset: 0x100 - PCC CLKCFG Register
        volatile uint32_t PCC_LPI2C1;  ///< Offset: 0x104 - PCC CLKCFG Register
        volatile uint32_t PCC_LPUART0;  ///< Offset: 0x110 - PCC CLKCFG Register
        volatile uint32_t PCC_LPUART1;  ///< Offset: 0x114 - PCC CLKCFG Register
        volatile uint32_t PCC_FLEXIO0;  ///< Offset: 0x128 - PCC CLKCFG Register
        volatile uint32_t PCC_PORTM;  ///< Offset: 0x180 - PCC CLKCFG Register
        volatile uint32_t PCC_CMP1;  ///< Offset: 0x1BC - PCC CLKCFG Register
    };

    /// Peripheral instances
    inline Registers* PCC1 = reinterpret_cast<Registers*>(PCC1_BASE);

    // Bit definitions
    /// PCC_DMA1 Register bits
    namespace pcc_dma1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_SEMA42_1 Register bits
    namespace pcc_sema42_1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_DMAMUX1 Register bits
    namespace pcc_dmamux1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_MU0_B Register bits
    namespace pcc_mu0_b_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_INTMUX1 Register bits
    namespace pcc_intmux1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_TRNG Register bits
    namespace pcc_trng_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_TPM0 Register bits
    namespace pcc_tpm0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_TPM1 Register bits
    namespace pcc_tpm1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPIT1 Register bits
    namespace pcc_lpit1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPTMR1 Register bits
    namespace pcc_lptmr1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPSPI0 Register bits
    namespace pcc_lpspi0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPSPI1 Register bits
    namespace pcc_lpspi1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPI2C0 Register bits
    namespace pcc_lpi2c0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPI2C1 Register bits
    namespace pcc_lpi2c1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART0 Register bits
    namespace pcc_lpuart0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_LPUART1 Register bits
    namespace pcc_lpuart1_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_FLEXIO0 Register bits
    namespace pcc_flexio0_bits {
        constexpr uint32_t PCS = (3 << 24);  ///< Peripheral Clock Source Select
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_PORTM Register bits
    namespace pcc_portm_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

    /// PCC_CMP1 Register bits
    namespace pcc_cmp1_bits {
        constexpr uint32_t INUSE = (1U << 29);  ///< Clock Gate Control
        constexpr uint32_t CGC = (1U << 30);  ///< Clock Gate Control
        constexpr uint32_t PR = (1U << 31);  ///< Enable
    }

}

// ============================================================================
// SCG Peripheral
// ============================================================================

namespace scg {
    /// Base addresses
    constexpr uint32_t SCG_BASE = 0x4007B000;

    /// SCG Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CSR;  ///< Offset: 0x10 - Clock Status Register
        volatile uint32_t RCCR;  ///< Offset: 0x14 - Run Clock Control Register
        volatile uint32_t VCCR;  ///< Offset: 0x18 - VLPR Clock Control Register
        volatile uint32_t HCCR;  ///< Offset: 0x1C - HSRUN Clock Control Register
        volatile uint32_t CLKOUTCNFG;  ///< Offset: 0x20 - SCG CLKOUT Configuration Register
        volatile uint32_t SOSCCSR;  ///< Offset: 0x100 - System OSC Control Status Register
        volatile uint32_t SOSCDIV;  ///< Offset: 0x104 - System OSC Divide Register
        volatile uint32_t SOSCCFG;  ///< Offset: 0x108 - System Oscillator Configuration Register
        volatile uint32_t SIRCCSR;  ///< Offset: 0x200 - Slow IRC Control Status Register
        volatile uint32_t SIRCDIV;  ///< Offset: 0x204 - Slow IRC Divide Register
        volatile uint32_t SIRCCFG;  ///< Offset: 0x208 - Slow IRC Configuration Register
        volatile uint32_t FIRCCSR;  ///< Offset: 0x300 - Fast IRC Control Status Register
        volatile uint32_t FIRCDIV;  ///< Offset: 0x304 - Fast IRC Divide Register
        volatile uint32_t FIRCCFG;  ///< Offset: 0x308 - Fast IRC Configuration Register
        volatile uint32_t FIRCTCFG;  ///< Offset: 0x30C - Fast IRC Trim Configuration Register
        volatile uint32_t FIRCSTAT;  ///< Offset: 0x318 - Fast IRC Status Register
        volatile uint32_t SPLLCSR;  ///< Offset: 0x600 - System PLL Control Status Register
        volatile uint32_t SPLLDIV;  ///< Offset: 0x604 - System PLL Divide Register
        volatile uint32_t SPLLCFG;  ///< Offset: 0x608 - System PLL Configuration Register
    };

    /// Peripheral instances
    inline Registers* SCG = reinterpret_cast<Registers*>(SCG_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t VERSION = (32 << 0);  ///< SCG Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t CLKPRES = (8 << 0);  ///< Clock Present
        constexpr uint32_t DIVPRES = (5 << 27);  ///< Divider Present
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// RCCR Register bits
    namespace rccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// VCCR Register bits
    namespace vccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// HCCR Register bits
    namespace hccr_bits {
        constexpr uint32_t DIVSLOW = (4 << 0);  ///< Slow Clock Divide Ratio
        constexpr uint32_t DIVCORE = (4 << 16);  ///< Core Clock Divide Ratio
        constexpr uint32_t SCS = (4 << 24);  ///< System Clock Source
    }

    /// CLKOUTCNFG Register bits
    namespace clkoutcnfg_bits {
        constexpr uint32_t CLKOUTSEL = (4 << 24);  ///< SCG Clkout Select
    }

    /// SOSCCSR Register bits
    namespace sosccsr_bits {
        constexpr uint32_t SOSCEN = (1U << 0);  ///< System OSC Enable
        constexpr uint32_t SOSCSTEN = (1U << 1);  ///< System OSC Stop Enable
        constexpr uint32_t SOSCLPEN = (1U << 2);  ///< System OSC Low Power Enable
        constexpr uint32_t SOSCERCLKEN = (1U << 3);  ///< System OSC 3V ERCLK Enable
        constexpr uint32_t SOSCCM = (1U << 16);  ///< System OSC Clock Monitor
        constexpr uint32_t SOSCCMRE = (1U << 17);  ///< System OSC Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SOSCVLD = (1U << 24);  ///< System OSC Valid
        constexpr uint32_t SOSCSEL = (1U << 25);  ///< System OSC Selected
        constexpr uint32_t SOSCERR = (1U << 26);  ///< System OSC Clock Error
    }

    /// SOSCDIV Register bits
    namespace soscdiv_bits {
        constexpr uint32_t SOSCDIV1 = (3 << 0);  ///< System OSC Clock Divide 1
        constexpr uint32_t SOSCDIV2 = (3 << 8);  ///< System OSC Clock Divide 2
        constexpr uint32_t SOSCDIV3 = (3 << 16);  ///< System OSC Clock Divide 3
    }

    /// SOSCCFG Register bits
    namespace sosccfg_bits {
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< System OSC Range Select
        constexpr uint32_t SC16P = (1U << 8);  ///< Oscillator 16 pF Capacitor Load
        constexpr uint32_t SC8P = (1U << 9);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 10);  ///< Oscillator 4 pF Capacitor Load
        constexpr uint32_t SC2P = (1U << 11);  ///< Oscillator 2 pF Capacitor Load
    }

    /// SIRCCSR Register bits
    namespace sirccsr_bits {
        constexpr uint32_t SIRCEN = (1U << 0);  ///< Slow IRC Enable
        constexpr uint32_t SIRCSTEN = (1U << 1);  ///< Slow IRC Stop Enable
        constexpr uint32_t SIRCLPEN = (1U << 2);  ///< Slow IRC Low Power Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SIRCVLD = (1U << 24);  ///< Slow IRC Valid
        constexpr uint32_t SIRCSEL = (1U << 25);  ///< Slow IRC Selected
    }

    /// SIRCDIV Register bits
    namespace sircdiv_bits {
        constexpr uint32_t SIRCDIV1 = (3 << 0);  ///< Slow IRC Clock Divide 1
        constexpr uint32_t SIRCDIV2 = (3 << 8);  ///< Slow IRC Clock Divide 2
        constexpr uint32_t SIRCDIV3 = (3 << 16);  ///< Slow IRC Clock Divider 3
    }

    /// SIRCCFG Register bits
    namespace sirccfg_bits {
        constexpr uint32_t RANGE = (1U << 0);  ///< Frequency Range
    }

    /// FIRCCSR Register bits
    namespace firccsr_bits {
        constexpr uint32_t FIRCEN = (1U << 0);  ///< Fast IRC Enable
        constexpr uint32_t FIRCSTEN = (1U << 1);  ///< Fast IRC Stop Enable
        constexpr uint32_t FIRCLPEN = (1U << 2);  ///< Fast IRC Low Power Enable
        constexpr uint32_t FIRCREGOFF = (1U << 3);  ///< Fast IRC Regulator Enable
        constexpr uint32_t FIRCTREN = (1U << 8);  ///< Fast IRC Trim Enable
        constexpr uint32_t FIRCTRUP = (1U << 9);  ///< Fast IRC Trim Update
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t FIRCVLD = (1U << 24);  ///< Fast IRC Valid
        constexpr uint32_t FIRCSEL = (1U << 25);  ///< Fast IRC Selected
        constexpr uint32_t FIRCERR = (1U << 26);  ///< Fast IRC Clock Error
    }

    /// FIRCDIV Register bits
    namespace fircdiv_bits {
        constexpr uint32_t FIRCDIV1 = (3 << 0);  ///< Fast IRC Clock Divide 1
        constexpr uint32_t FIRCDIV2 = (3 << 8);  ///< Fast IRC Clock Divide 2
        constexpr uint32_t FIRCDIV3 = (3 << 16);  ///< Fast IRC Clock Divider 3
    }

    /// FIRCCFG Register bits
    namespace firccfg_bits {
        constexpr uint32_t RANGE = (2 << 0);  ///< Frequency Range
    }

    /// FIRCTCFG Register bits
    namespace firctcfg_bits {
        constexpr uint32_t TRIMSRC = (2 << 0);  ///< Trim Source
        constexpr uint32_t TRIMDIV = (3 << 8);  ///< Fast IRC Trim Predivide
    }

    /// FIRCSTAT Register bits
    namespace fircstat_bits {
        constexpr uint32_t TRIMFINE = (7 << 0);  ///< Trim Fine Status
        constexpr uint32_t TRIMCOAR = (6 << 8);  ///< Trim Coarse
    }

    /// SPLLCSR Register bits
    namespace spllcsr_bits {
        constexpr uint32_t SPLLEN = (1U << 0);  ///< System PLL Enable
        constexpr uint32_t SPLLSTEN = (1U << 1);  ///< System PLL Stop Enable
        constexpr uint32_t SPLLCM = (1U << 16);  ///< System PLL Clock Monitor
        constexpr uint32_t SPLLCMRE = (1U << 17);  ///< System PLL Clock Monitor Reset Enable
        constexpr uint32_t LK = (1U << 23);  ///< Lock Register
        constexpr uint32_t SPLLVLD = (1U << 24);  ///< System PLL Valid
        constexpr uint32_t SPLLSEL = (1U << 25);  ///< System PLL Selected
        constexpr uint32_t SPLLERR = (1U << 26);  ///< System PLL Clock Error
    }

    /// SPLLDIV Register bits
    namespace splldiv_bits {
        constexpr uint32_t SPLLDIV1 = (3 << 0);  ///< System PLL Clock Divide 1
        constexpr uint32_t SPLLDIV2 = (3 << 8);  ///< System PLL Clock Divide 2
        constexpr uint32_t SPLLDIV3 = (3 << 16);  ///< System PLL Clock Divide 3
    }

    /// SPLLCFG Register bits
    namespace spllcfg_bits {
        constexpr uint32_t SOURCE = (1U << 0);  ///< Clock Source
        constexpr uint32_t PREDIV = (3 << 8);  ///< PLL Reference Clock Divider
        constexpr uint32_t MULT = (5 << 16);  ///< System PLL Multiplier
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x4007C000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter register
        volatile uint32_t LVDSC1;  ///< Offset: 0x08 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x0C - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x10 - Regulator Status And Control register
        volatile uint32_t HVDSC1;  ///< Offset: 0x34 - High Voltage Detect Status And Control 1 register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t VLPOE = (1U << 0);  ///< VLPO Enable
        constexpr uint32_t HVDE = (1U << 1);  ///< HVD Enabled
    }

    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
        constexpr uint32_t VLPO = (1U << 6);  ///< VLPx Option
    }

    /// HVDSC1 Register bits
    namespace hvdsc1_bits {
        constexpr uint32_t HVDV = (1U << 0);  ///< High-Voltage Detect Voltage Select
        constexpr uint32_t HVDRE = (1U << 4);  ///< High-Voltage Detect Reset Enable
        constexpr uint32_t HVDIE = (1U << 5);  ///< High-Voltage Detect Interrupt Enable
        constexpr uint32_t HVDACK = (1U << 6);  ///< High-Voltage Detect Acknowledge
        constexpr uint32_t HVDF = (1U << 7);  ///< High-Voltage Detect Flag
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - SMC Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - SMC Parameter Register
        volatile uint32_t PMPROT;  ///< Offset: 0x08 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x0C - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x10 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x14 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t EHSRUN = (1U << 0);  ///< Enable HSRUN
        constexpr uint32_t ELLS = (1U << 3);  ///< Enable LLS (if this mode exists on the SOC)
        constexpr uint32_t ELLS2 = (1U << 5);  ///< Enable LLS2 (if this mode exists on the SOC)
        constexpr uint32_t EVLLS0 = (1U << 6);  ///< Enable VLLS0 (if this mode exists on the SOC)
    }

    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t LLSM = (3 << 0);  ///< LLS or VLLS Mode Control
        constexpr uint32_t LPOPO = (1U << 3);  ///< LPO Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t SRS;  ///< Offset: 0x08 - System Reset Status Register
        volatile uint32_t RPC;  ///< Offset: 0x0C - Reset Pin Control register
        volatile uint32_t MR;  ///< Offset: 0x10 - Mode Register
        volatile uint32_t FM;  ///< Offset: 0x14 - Force Mode Register
        volatile uint32_t SSRS;  ///< Offset: 0x18 - Sticky System Reset Status Register
        volatile uint32_t SRIE;  ///< Offset: 0x1C - System Reset Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RSTSRC = (32 << 0);  ///< Reset Source
    }

    /// SRS Register bits
    namespace srs_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< VLLS Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset or High-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 10);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Acknowledge Error
        constexpr uint32_t CORE1 = (1U << 16);  ///< Core 1 Reset
    }

    /// RPC Register bits
    namespace rpc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
        constexpr uint32_t RSTFLTSEL = (5 << 8);  ///< Reset Pin Filter Bus Clock Select
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// SSRS Register bits
    namespace ssrs_bits {
        constexpr uint32_t SWAKEUP = (1U << 0);  ///< Sticky VLLS Wakeup Reset
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
        constexpr uint32_t SLOCKUP = (1U << 9);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 10);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 11);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 13);  ///< Sticky Stop Acknowledge Error
        constexpr uint32_t SCORE1 = (1U << 16);  ///< Sticky Core 1 Reset
    }

    /// SRIE Register bits
    namespace srie_bits {
        constexpr uint32_t DELAY = (2 << 0);  ///< Reset Delay Time
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Interrupt
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Interrupt
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog Interrupt
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin Interrupt
        constexpr uint32_t GIE = (1U << 7);  ///< Global Interrupt Enable
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core Lockup Interrupt
        constexpr uint32_t SW = (1U << 10);  ///< Software Interrupt
        constexpr uint32_t MDM_AP = (1U << 11);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 13);  ///< Stop Acknowledge Error Interrupt
        constexpr uint32_t CORE1 = (1U << 16);  ///< Core 1 Interrupt
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG_BASE = 0x400A5000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t MCTL;  ///< Offset: 0x00 - TRNG Miscellaneous Control Register
        volatile uint32_t SCMISC;  ///< Offset: 0x04 - TRNG Statistical Check Miscellaneous Register
        volatile uint32_t PKRRNG;  ///< Offset: 0x08 - TRNG Poker Range Register
        volatile uint32_t PKRMAX;  ///< Offset: 0x0C - TRNG Poker Maximum Limit Register
        volatile uint32_t PKRSQ;  ///< Offset: 0x0C - TRNG Poker Square Calculation Result Register
        volatile uint32_t SDCTL;  ///< Offset: 0x10 - TRNG Seed Control Register
        volatile uint32_t SBLIM;  ///< Offset: 0x14 - TRNG Sparse Bit Limit Register
        volatile uint32_t TOTSAM;  ///< Offset: 0x14 - TRNG Total Samples Register
        volatile uint32_t FRQMIN;  ///< Offset: 0x18 - TRNG Frequency Count Minimum Limit Register
        volatile uint32_t FRQCNT;  ///< Offset: 0x1C - TRNG Frequency Count Register
        volatile uint32_t FRQMAX;  ///< Offset: 0x1C - TRNG Frequency Count Maximum Limit Register
        volatile uint32_t SCMC;  ///< Offset: 0x20 - TRNG Statistical Check Monobit Count Register
        volatile uint32_t SCML;  ///< Offset: 0x20 - TRNG Statistical Check Monobit Limit Register
        volatile uint32_t SCR1C;  ///< Offset: 0x24 - TRNG Statistical Check Run Length 1 Count Register
        volatile uint32_t SCR1L;  ///< Offset: 0x24 - TRNG Statistical Check Run Length 1 Limit Register
        volatile uint32_t SCR2C;  ///< Offset: 0x28 - TRNG Statistical Check Run Length 2 Count Register
        volatile uint32_t SCR2L;  ///< Offset: 0x28 - TRNG Statistical Check Run Length 2 Limit Register
        volatile uint32_t SCR3C;  ///< Offset: 0x2C - TRNG Statistical Check Run Length 3 Count Register
        volatile uint32_t SCR3L;  ///< Offset: 0x2C - TRNG Statistical Check Run Length 3 Limit Register
        volatile uint32_t SCR4C;  ///< Offset: 0x30 - TRNG Statistical Check Run Length 4 Count Register
        volatile uint32_t SCR4L;  ///< Offset: 0x30 - TRNG Statistical Check Run Length 4 Limit Register
        volatile uint32_t SCR5C;  ///< Offset: 0x34 - TRNG Statistical Check Run Length 5 Count Register
        volatile uint32_t SCR5L;  ///< Offset: 0x34 - TRNG Statistical Check Run Length 5 Limit Register
        volatile uint32_t SCR6PC;  ///< Offset: 0x38 - TRNG Statistical Check Run Length 6+ Count Register
        volatile uint32_t SCR6PL;  ///< Offset: 0x38 - TRNG Statistical Check Run Length 6+ Limit Register
        volatile uint32_t STATUS;  ///< Offset: 0x3C - TRNG Status Register
        volatile uint32_t ENT0;  ///< Offset: 0x40 - TRNG Entropy Read Register
        volatile uint32_t ENT1;  ///< Offset: 0x44 - TRNG Entropy Read Register
        volatile uint32_t ENT2;  ///< Offset: 0x48 - TRNG Entropy Read Register
        volatile uint32_t ENT3;  ///< Offset: 0x4C - TRNG Entropy Read Register
        volatile uint32_t ENT4;  ///< Offset: 0x50 - TRNG Entropy Read Register
        volatile uint32_t ENT5;  ///< Offset: 0x54 - TRNG Entropy Read Register
        volatile uint32_t ENT6;  ///< Offset: 0x58 - TRNG Entropy Read Register
        volatile uint32_t ENT7;  ///< Offset: 0x5C - TRNG Entropy Read Register
        volatile uint32_t ENT8;  ///< Offset: 0x60 - TRNG Entropy Read Register
        volatile uint32_t ENT9;  ///< Offset: 0x64 - TRNG Entropy Read Register
        volatile uint32_t ENT10;  ///< Offset: 0x68 - TRNG Entropy Read Register
        volatile uint32_t ENT11;  ///< Offset: 0x6C - TRNG Entropy Read Register
        volatile uint32_t ENT12;  ///< Offset: 0x70 - TRNG Entropy Read Register
        volatile uint32_t ENT13;  ///< Offset: 0x74 - TRNG Entropy Read Register
        volatile uint32_t ENT14;  ///< Offset: 0x78 - TRNG Entropy Read Register
        volatile uint32_t ENT15;  ///< Offset: 0x7C - TRNG Entropy Read Register
        volatile uint32_t PKRCNT10;  ///< Offset: 0x80 - TRNG Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t PKRCNT32;  ///< Offset: 0x84 - TRNG Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t PKRCNT54;  ///< Offset: 0x88 - TRNG Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t PKRCNT76;  ///< Offset: 0x8C - TRNG Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t PKRCNT98;  ///< Offset: 0x90 - TRNG Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t PKRCNTBA;  ///< Offset: 0x94 - TRNG Statistical Check Poker Count B and A Register
        volatile uint32_t PKRCNTDC;  ///< Offset: 0x98 - TRNG Statistical Check Poker Count D and C Register
        volatile uint32_t PKRCNTFE;  ///< Offset: 0x9C - TRNG Statistical Check Poker Count F and E Register
        volatile uint32_t SEC_CFG;  ///< Offset: 0xA0 - TRNG Security Configuration Register
        volatile uint32_t INT_CTRL;  ///< Offset: 0xA4 - TRNG Interrupt Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0xA8 - TRNG Mask Register
        volatile uint32_t INT_STATUS;  ///< Offset: 0xAC - TRNG Interrupt Status Register
        volatile uint32_t VID1;  ///< Offset: 0xF0 - TRNG Version ID Register (MS)
        volatile uint32_t VID2;  ///< Offset: 0xF4 - TRNG Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG = reinterpret_cast<Registers*>(TRNG_BASE);

    // Bit definitions
    /// MCTL Register bits
    namespace mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// SCMISC Register bits
    namespace scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// PKRRNG Register bits
    namespace pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// PKRMAX Register bits
    namespace pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit
    }

    /// PKRSQ Register bits
    namespace pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result
    }

    /// SDCTL Register bits
    namespace sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// SBLIM Register bits
    namespace sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TOTSAM Register bits
    namespace totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// FRQMIN Register bits
    namespace frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// FRQCNT Register bits
    namespace frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// FRQMAX Register bits
    namespace frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// SCMC Register bits
    namespace scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// SCML Register bits
    namespace scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// SCR1C Register bits
    namespace scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// SCR1L Register bits
    namespace scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// SCR2C Register bits
    namespace scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// SCR2L Register bits
    namespace scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// SCR3C Register bits
    namespace scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// SCR3L Register bits
    namespace scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// SCR4C Register bits
    namespace scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// SCR4L Register bits
    namespace scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// SCR5C Register bits
    namespace scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// SCR5L Register bits
    namespace scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// SCR6PC Register bits
    namespace scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// SCR6PL Register bits
    namespace scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// STATUS Register bits
    namespace status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// ENT0 Register bits
    namespace ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT1 Register bits
    namespace ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT2 Register bits
    namespace ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT3 Register bits
    namespace ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT4 Register bits
    namespace ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT5 Register bits
    namespace ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT6 Register bits
    namespace ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT7 Register bits
    namespace ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT8 Register bits
    namespace ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT9 Register bits
    namespace ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT10 Register bits
    namespace ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT11 Register bits
    namespace ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT12 Register bits
    namespace ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT13 Register bits
    namespace ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT14 Register bits
    namespace ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// ENT15 Register bits
    namespace ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// PKRCNT10 Register bits
    namespace pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// PKRCNT32 Register bits
    namespace pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// PKRCNT54 Register bits
    namespace pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// PKRCNT76 Register bits
    namespace pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// PKRCNT98 Register bits
    namespace pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// PKRCNTBA Register bits
    namespace pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// PKRCNTDC Register bits
    namespace pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// PKRCNTFE Register bits
    namespace pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// SEC_CFG Register bits
    namespace sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set, the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// INT_CTRL Register bits
    namespace int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// INT_STATUS Register bits
    namespace int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// VID1 Register bits
    namespace vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// VID2 Register bits
    namespace vid2_bits {
        constexpr uint32_t CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// FLEXIO0 Peripheral
// ============================================================================

namespace flexio0 {
    /// Base addresses
    constexpr uint32_t FLEXIO0_BASE = 0x400CA000;

    /// FLEXIO0 Register structure
    struct Registers {
        volatile uint32_t FLEXIO0_VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t FLEXIO0_PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t FLEXIO0_CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t FLEXIO0_PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t FLEXIO0_SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t FLEXIO0_SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t FLEXIO0_TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t FLEXIO0_SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t FLEXIO0_SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t FLEXIO0_TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t FLEXIO0_SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t FLEXIO0_SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t FLEXIO0_SHIFTCTL0;  ///< Offset: 0x80 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL1;  ///< Offset: 0x84 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL2;  ///< Offset: 0x88 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL3;  ///< Offset: 0x8C - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL4;  ///< Offset: 0x90 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL5;  ///< Offset: 0x94 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL6;  ///< Offset: 0x98 - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCTL7;  ///< Offset: 0x9C - Shifter Control N Register
        volatile uint32_t FLEXIO0_SHIFTCFG0;  ///< Offset: 0x100 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG1;  ///< Offset: 0x104 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG2;  ///< Offset: 0x108 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG3;  ///< Offset: 0x10C - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG4;  ///< Offset: 0x110 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG5;  ///< Offset: 0x114 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG6;  ///< Offset: 0x118 - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTCFG7;  ///< Offset: 0x11C - Shifter Configuration N Register
        volatile uint32_t FLEXIO0_SHIFTBUF0;  ///< Offset: 0x200 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF1;  ///< Offset: 0x204 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF2;  ///< Offset: 0x208 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF3;  ///< Offset: 0x20C - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF4;  ///< Offset: 0x210 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF5;  ///< Offset: 0x214 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF6;  ///< Offset: 0x218 - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUF7;  ///< Offset: 0x21C - Shifter Buffer N Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS0;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS1;  ///< Offset: 0x284 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS2;  ///< Offset: 0x288 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS3;  ///< Offset: 0x28C - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS4;  ///< Offset: 0x290 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS5;  ///< Offset: 0x294 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS6;  ///< Offset: 0x298 - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBIS7;  ///< Offset: 0x29C - Shifter Buffer N Bit Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS0;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS1;  ///< Offset: 0x304 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS2;  ///< Offset: 0x308 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS3;  ///< Offset: 0x30C - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS4;  ///< Offset: 0x310 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS5;  ///< Offset: 0x314 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS6;  ///< Offset: 0x318 - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBYS7;  ///< Offset: 0x31C - Shifter Buffer N Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS0;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS1;  ///< Offset: 0x384 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS2;  ///< Offset: 0x388 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS3;  ///< Offset: 0x38C - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS4;  ///< Offset: 0x390 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS5;  ///< Offset: 0x394 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS6;  ///< Offset: 0x398 - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFBBS7;  ///< Offset: 0x39C - Shifter Buffer N Bit Byte Swapped Register
        volatile uint32_t FLEXIO0_TIMCTL0;  ///< Offset: 0x400 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL1;  ///< Offset: 0x404 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL2;  ///< Offset: 0x408 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL3;  ///< Offset: 0x40C - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL4;  ///< Offset: 0x410 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL5;  ///< Offset: 0x414 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL6;  ///< Offset: 0x418 - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCTL7;  ///< Offset: 0x41C - Timer Control N Register
        volatile uint32_t FLEXIO0_TIMCFG0;  ///< Offset: 0x480 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG1;  ///< Offset: 0x484 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG2;  ///< Offset: 0x488 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG3;  ///< Offset: 0x48C - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG4;  ///< Offset: 0x490 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG5;  ///< Offset: 0x494 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG6;  ///< Offset: 0x498 - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCFG7;  ///< Offset: 0x49C - Timer Configuration N Register
        volatile uint32_t FLEXIO0_TIMCMP0;  ///< Offset: 0x500 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP1;  ///< Offset: 0x504 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP2;  ///< Offset: 0x508 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP3;  ///< Offset: 0x50C - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP4;  ///< Offset: 0x510 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP5;  ///< Offset: 0x514 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP6;  ///< Offset: 0x518 - Timer Compare N Register
        volatile uint32_t FLEXIO0_TIMCMP7;  ///< Offset: 0x51C - Timer Compare N Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS0;  ///< Offset: 0x680 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS1;  ///< Offset: 0x684 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS2;  ///< Offset: 0x688 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS3;  ///< Offset: 0x68C - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS4;  ///< Offset: 0x690 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS5;  ///< Offset: 0x694 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS6;  ///< Offset: 0x698 - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNBS7;  ///< Offset: 0x69C - Shifter Buffer N Nibble Byte Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS0;  ///< Offset: 0x700 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS1;  ///< Offset: 0x704 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS2;  ///< Offset: 0x708 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS3;  ///< Offset: 0x70C - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS4;  ///< Offset: 0x710 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS5;  ///< Offset: 0x714 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS6;  ///< Offset: 0x718 - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFHWS7;  ///< Offset: 0x71C - Shifter Buffer N Half Word Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS0;  ///< Offset: 0x780 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS1;  ///< Offset: 0x784 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS2;  ///< Offset: 0x788 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS3;  ///< Offset: 0x78C - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS4;  ///< Offset: 0x790 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS5;  ///< Offset: 0x794 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS6;  ///< Offset: 0x798 - Shifter Buffer N Nibble Swapped Register
        volatile uint32_t FLEXIO0_SHIFTBUFNIS7;  ///< Offset: 0x79C - Shifter Buffer N Nibble Swapped Register
    };

    /// Peripheral instances
    inline Registers* FLEXIO0 = reinterpret_cast<Registers*>(FLEXIO0_BASE);

    // Bit definitions
    /// FLEXIO0_VERID Register bits
    namespace flexio0_verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// FLEXIO0_PARAM Register bits
    namespace flexio0_param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// FLEXIO0_CTRL Register bits
    namespace flexio0_ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// FLEXIO0_PIN Register bits
    namespace flexio0_pin_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Pin Data Input
    }

    /// FLEXIO0_SHIFTSTAT Register bits
    namespace flexio0_shiftstat_bits {
        constexpr uint32_t SSF = (8 << 0);  ///< Shifter Status Flag
    }

    /// FLEXIO0_SHIFTERR Register bits
    namespace flexio0_shifterr_bits {
        constexpr uint32_t SEF = (8 << 0);  ///< Shifter Error Flags
    }

    /// FLEXIO0_TIMSTAT Register bits
    namespace flexio0_timstat_bits {
        constexpr uint32_t TSF = (8 << 0);  ///< Timer Status Flags
    }

    /// FLEXIO0_SHIFTSIEN Register bits
    namespace flexio0_shiftsien_bits {
        constexpr uint32_t SSIE = (8 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// FLEXIO0_SHIFTEIEN Register bits
    namespace flexio0_shifteien_bits {
        constexpr uint32_t SEIE = (8 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// FLEXIO0_TIMIEN Register bits
    namespace flexio0_timien_bits {
        constexpr uint32_t TEIE = (8 << 0);  ///< Timer Status Interrupt Enable
    }

    /// FLEXIO0_SHIFTSDEN Register bits
    namespace flexio0_shiftsden_bits {
        constexpr uint32_t SSDE = (8 << 0);  ///< Shifter Status DMA Enable
    }

    /// FLEXIO0_SHIFTSTATE Register bits
    namespace flexio0_shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// FLEXIO0_SHIFTCTL0 Register bits
    namespace flexio0_shiftctl0_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL1 Register bits
    namespace flexio0_shiftctl1_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL2 Register bits
    namespace flexio0_shiftctl2_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL3 Register bits
    namespace flexio0_shiftctl3_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL4 Register bits
    namespace flexio0_shiftctl4_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL5 Register bits
    namespace flexio0_shiftctl5_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL6 Register bits
    namespace flexio0_shiftctl6_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCTL7 Register bits
    namespace flexio0_shiftctl7_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// FLEXIO0_SHIFTCFG0 Register bits
    namespace flexio0_shiftcfg0_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG1 Register bits
    namespace flexio0_shiftcfg1_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG2 Register bits
    namespace flexio0_shiftcfg2_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG3 Register bits
    namespace flexio0_shiftcfg3_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG4 Register bits
    namespace flexio0_shiftcfg4_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG5 Register bits
    namespace flexio0_shiftcfg5_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG6 Register bits
    namespace flexio0_shiftcfg6_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTCFG7 Register bits
    namespace flexio0_shiftcfg7_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// FLEXIO0_SHIFTBUF0 Register bits
    namespace flexio0_shiftbuf0_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF1 Register bits
    namespace flexio0_shiftbuf1_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF2 Register bits
    namespace flexio0_shiftbuf2_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF3 Register bits
    namespace flexio0_shiftbuf3_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF4 Register bits
    namespace flexio0_shiftbuf4_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF5 Register bits
    namespace flexio0_shiftbuf5_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF6 Register bits
    namespace flexio0_shiftbuf6_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUF7 Register bits
    namespace flexio0_shiftbuf7_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS0 Register bits
    namespace flexio0_shiftbufbis0_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS1 Register bits
    namespace flexio0_shiftbufbis1_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS2 Register bits
    namespace flexio0_shiftbufbis2_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS3 Register bits
    namespace flexio0_shiftbufbis3_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS4 Register bits
    namespace flexio0_shiftbufbis4_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS5 Register bits
    namespace flexio0_shiftbufbis5_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS6 Register bits
    namespace flexio0_shiftbufbis6_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBIS7 Register bits
    namespace flexio0_shiftbufbis7_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS0 Register bits
    namespace flexio0_shiftbufbys0_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS1 Register bits
    namespace flexio0_shiftbufbys1_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS2 Register bits
    namespace flexio0_shiftbufbys2_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS3 Register bits
    namespace flexio0_shiftbufbys3_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS4 Register bits
    namespace flexio0_shiftbufbys4_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS5 Register bits
    namespace flexio0_shiftbufbys5_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS6 Register bits
    namespace flexio0_shiftbufbys6_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBYS7 Register bits
    namespace flexio0_shiftbufbys7_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS0 Register bits
    namespace flexio0_shiftbufbbs0_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS1 Register bits
    namespace flexio0_shiftbufbbs1_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS2 Register bits
    namespace flexio0_shiftbufbbs2_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS3 Register bits
    namespace flexio0_shiftbufbbs3_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS4 Register bits
    namespace flexio0_shiftbufbbs4_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS5 Register bits
    namespace flexio0_shiftbufbbs5_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS6 Register bits
    namespace flexio0_shiftbufbbs6_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFBBS7 Register bits
    namespace flexio0_shiftbufbbs7_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_TIMCTL0 Register bits
    namespace flexio0_timctl0_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL1 Register bits
    namespace flexio0_timctl1_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL2 Register bits
    namespace flexio0_timctl2_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL3 Register bits
    namespace flexio0_timctl3_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL4 Register bits
    namespace flexio0_timctl4_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL5 Register bits
    namespace flexio0_timctl5_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL6 Register bits
    namespace flexio0_timctl6_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCTL7 Register bits
    namespace flexio0_timctl7_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// FLEXIO0_TIMCFG0 Register bits
    namespace flexio0_timcfg0_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG1 Register bits
    namespace flexio0_timcfg1_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG2 Register bits
    namespace flexio0_timcfg2_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG3 Register bits
    namespace flexio0_timcfg3_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG4 Register bits
    namespace flexio0_timcfg4_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG5 Register bits
    namespace flexio0_timcfg5_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG6 Register bits
    namespace flexio0_timcfg6_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCFG7 Register bits
    namespace flexio0_timcfg7_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// FLEXIO0_TIMCMP0 Register bits
    namespace flexio0_timcmp0_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP1 Register bits
    namespace flexio0_timcmp1_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP2 Register bits
    namespace flexio0_timcmp2_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP3 Register bits
    namespace flexio0_timcmp3_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP4 Register bits
    namespace flexio0_timcmp4_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP5 Register bits
    namespace flexio0_timcmp5_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP6 Register bits
    namespace flexio0_timcmp6_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_TIMCMP7 Register bits
    namespace flexio0_timcmp7_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// FLEXIO0_SHIFTBUFNBS0 Register bits
    namespace flexio0_shiftbufnbs0_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS1 Register bits
    namespace flexio0_shiftbufnbs1_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS2 Register bits
    namespace flexio0_shiftbufnbs2_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS3 Register bits
    namespace flexio0_shiftbufnbs3_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS4 Register bits
    namespace flexio0_shiftbufnbs4_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS5 Register bits
    namespace flexio0_shiftbufnbs5_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS6 Register bits
    namespace flexio0_shiftbufnbs6_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNBS7 Register bits
    namespace flexio0_shiftbufnbs7_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS0 Register bits
    namespace flexio0_shiftbufhws0_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS1 Register bits
    namespace flexio0_shiftbufhws1_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS2 Register bits
    namespace flexio0_shiftbufhws2_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS3 Register bits
    namespace flexio0_shiftbufhws3_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS4 Register bits
    namespace flexio0_shiftbufhws4_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS5 Register bits
    namespace flexio0_shiftbufhws5_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS6 Register bits
    namespace flexio0_shiftbufhws6_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFHWS7 Register bits
    namespace flexio0_shiftbufhws7_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS0 Register bits
    namespace flexio0_shiftbufnis0_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS1 Register bits
    namespace flexio0_shiftbufnis1_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS2 Register bits
    namespace flexio0_shiftbufnis2_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS3 Register bits
    namespace flexio0_shiftbufnis3_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS4 Register bits
    namespace flexio0_shiftbufnis4_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS5 Register bits
    namespace flexio0_shiftbufnis5_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS6 Register bits
    namespace flexio0_shiftbufnis6_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

    /// FLEXIO0_SHIFTBUFNIS7 Register bits
    namespace flexio0_shiftbufnis7_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

}

// ============================================================================
// ASMC Peripheral
// ============================================================================

namespace asmc {
    /// Base addresses
    constexpr uint32_t ASMC_BASE = 0x400F5000;

    /// ASMC Register structure
    struct Registers {
        volatile uint32_t SRS;  ///< Offset: 0x00 - System Reset Status Register
        volatile uint32_t PMPROT;  ///< Offset: 0x08 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x0C - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x10 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x14 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* ASMC = reinterpret_cast<Registers*>(ASMC_BASE);

    // Bit definitions
    /// SRS Register bits
    namespace srs_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t WDOG1 = (1U << 5);  ///< Watchdog
        constexpr uint32_t RES = (1U << 6);  ///< Chip Reset not POR
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
        constexpr uint32_t LOCKUP = (1U << 9);  ///< Core 1 Lockup
        constexpr uint32_t SW = (1U << 10);  ///< Software
        constexpr uint32_t SACKERR = (1U << 12);  ///< Stop Mode Acknowledge Error Reset
    }

    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// MTB0 Peripheral
// ============================================================================

namespace mtb0 {
    /// Base addresses
    constexpr uint32_t MTB0_BASE = 0xF0000000;
    constexpr uint32_t MTB0_DWT_BASE = 0xF0001000;
    constexpr uint32_t MTB0_ROM_BASE = 0xF0002000;

    /// MTB0 Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB0 = reinterpret_cast<Registers*>(MTB0_BASE);
    inline Registers* MTB0_DWT = reinterpret_cast<Registers*>(MTB0_DWT_BASE);
    inline Registers* MTB0_ROM = reinterpret_cast<Registers*>(MTB0_ROM_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTB1 Peripheral
// ============================================================================

namespace mtb1 {
    /// Base addresses
    constexpr uint32_t MTB1_BASE = 0xF1000000;

    /// MTB1 Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB1 = reinterpret_cast<Registers*>(MTB1_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM0 Peripheral
// ============================================================================

namespace mcm0 {
    /// Base addresses
    constexpr uint32_t MCM0_BASE = 0xF0003000;

    /// MCM0 Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM0 = reinterpret_cast<Registers*>(MCM0_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t MMCAU = (1U << 8);  ///< MMCAU Present
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}

// ============================================================================
// MCM1 Peripheral
// ============================================================================

namespace mcm1 {
    /// Base addresses
    constexpr uint32_t MCM1_BASE = 0xF1003000;

    /// MCM1 Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM1 = reinterpret_cast<Registers*>(MCM1_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t MMCAU = (1U << 8);  ///< MMCAU Present
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}

// ============================================================================
// MMDVSQ0 Peripheral
// ============================================================================

namespace mmdvsq0 {
    /// Base addresses
    constexpr uint32_t MMDVSQ0_BASE = 0xF0004000;

    /// MMDVSQ0 Register structure
    struct Registers {
        volatile uint32_t DEND;  ///< Offset: 0x00 - Dividend Register
        volatile uint32_t DSOR;  ///< Offset: 0x04 - Divisor Register
        volatile uint32_t CSR;  ///< Offset: 0x08 - Control/Status Register
        volatile uint32_t RES;  ///< Offset: 0x0C - Result Register
        volatile uint32_t RCND;  ///< Offset: 0x10 - Radicand Register
    };

    /// Peripheral instances
    inline Registers* MMDVSQ0 = reinterpret_cast<Registers*>(MMDVSQ0_BASE);

    // Bit definitions
    /// DEND Register bits
    namespace dend_bits {
        constexpr uint32_t DIVIDEND = (32 << 0);  ///< Dividend
    }

    /// DSOR Register bits
    namespace dsor_bits {
        constexpr uint32_t DIVISOR = (32 << 0);  ///< Divisor
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t SRT = (1U << 0);  ///< Start
        constexpr uint32_t USGN = (1U << 1);  ///< Unsigned calculation
        constexpr uint32_t REM = (1U << 2);  ///< REMainder calculation
        constexpr uint32_t DZE = (1U << 3);  ///< Divide-by-Zero-Enable
        constexpr uint32_t DZ = (1U << 4);  ///< Divide-by-Zero
        constexpr uint32_t DFS = (1U << 5);  ///< Disable Fast Start
        constexpr uint32_t SQRT = (1U << 29);  ///< SQUARE ROOT
        constexpr uint32_t DIV = (1U << 30);  ///< DIVIDE
        constexpr uint32_t BUSY = (1U << 31);  ///< BUSY
    }

    /// RES Register bits
    namespace res_bits {
        constexpr uint32_t RESULT = (32 << 0);  ///< Result
    }

    /// RCND Register bits
    namespace rcnd_bits {
        constexpr uint32_t RADICAND = (32 << 0);  ///< Radicand
    }

}

// ============================================================================
// MMDVSQ1 Peripheral
// ============================================================================

namespace mmdvsq1 {
    /// Base addresses
    constexpr uint32_t MMDVSQ1_BASE = 0xF1004000;

    /// MMDVSQ1 Register structure
    struct Registers {
        volatile uint32_t DEND;  ///< Offset: 0x00 - Dividend Register
        volatile uint32_t DSOR;  ///< Offset: 0x04 - Divisor Register
        volatile uint32_t CSR;  ///< Offset: 0x08 - Control/Status Register
        volatile uint32_t RES;  ///< Offset: 0x0C - Result Register
        volatile uint32_t RCND;  ///< Offset: 0x10 - Radicand Register
    };

    /// Peripheral instances
    inline Registers* MMDVSQ1 = reinterpret_cast<Registers*>(MMDVSQ1_BASE);

    // Bit definitions
    /// DEND Register bits
    namespace dend_bits {
        constexpr uint32_t DIVIDEND = (32 << 0);  ///< Dividend
    }

    /// DSOR Register bits
    namespace dsor_bits {
        constexpr uint32_t DIVISOR = (32 << 0);  ///< Divisor
    }

    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t SRT = (1U << 0);  ///< Start
        constexpr uint32_t USGN = (1U << 1);  ///< Unsigned calculation
        constexpr uint32_t REM = (1U << 2);  ///< REMainder calculation
        constexpr uint32_t DZE = (1U << 3);  ///< Divide-by-Zero-Enable
        constexpr uint32_t DZ = (1U << 4);  ///< Divide-by-Zero
        constexpr uint32_t DFS = (1U << 5);  ///< Disable Fast Start
        constexpr uint32_t SQRT = (1U << 29);  ///< SQUARE ROOT
        constexpr uint32_t DIV = (1U << 30);  ///< DIVIDE
        constexpr uint32_t BUSY = (1U << 31);  ///< BUSY
    }

    /// RES Register bits
    namespace res_bits {
        constexpr uint32_t RESULT = (32 << 0);  ///< Result
    }

    /// RCND Register bits
    namespace rcnd_bits {
        constexpr uint32_t RADICAND = (32 << 0);  ///< Radicand
    }

}

// ============================================================================
// CAU0 Peripheral
// ============================================================================

namespace cau0 {
    /// Base addresses
    constexpr uint32_t CAU0_BASE = 0xF0005000;

    /// CAU0 Register structure
    struct Registers {
        volatile uint32_t CAU_DIRECT0;  ///< Offset: 0x00 - Direct access register 0
        volatile uint32_t CAU_DIRECT1;  ///< Offset: 0x04 - Direct access register 1
        volatile uint32_t CAU_DIRECT2;  ///< Offset: 0x08 - Direct access register 2
        volatile uint32_t CAU_DIRECT3;  ///< Offset: 0x0C - Direct access register 3
        volatile uint32_t CAU_DIRECT4;  ///< Offset: 0x10 - Direct access register 4
        volatile uint32_t CAU_DIRECT5;  ///< Offset: 0x14 - Direct access register 5
        volatile uint32_t CAU_DIRECT6;  ///< Offset: 0x18 - Direct access register 6
        volatile uint32_t CAU_DIRECT7;  ///< Offset: 0x1C - Direct access register 7
        volatile uint32_t CAU_DIRECT8;  ///< Offset: 0x20 - Direct access register 8
        volatile uint32_t CAU_DIRECT9;  ///< Offset: 0x24 - Direct access register 9
        volatile uint32_t CAU_DIRECT10;  ///< Offset: 0x28 - Direct access register 10
        volatile uint32_t CAU_DIRECT11;  ///< Offset: 0x2C - Direct access register 11
        volatile uint32_t CAU_DIRECT12;  ///< Offset: 0x30 - Direct access register 12
        volatile uint32_t CAU_DIRECT13;  ///< Offset: 0x34 - Direct access register 13
        volatile uint32_t CAU_DIRECT14;  ///< Offset: 0x38 - Direct access register 14
        volatile uint32_t CAU_DIRECT15;  ///< Offset: 0x3C - Direct access register 15
        volatile uint32_t CAU_LDR_CASR;  ///< Offset: 0x840 - Status register - Load Register command
        volatile uint32_t CAU_LDR_CAA;  ///< Offset: 0x844 - Accumulator register - Load Register command
        volatile uint32_t CAU_LDR_CA0;  ///< Offset: 0x848 - General Purpose Register 0 - Load Register command
        volatile uint32_t CAU_LDR_CA1;  ///< Offset: 0x84C - General Purpose Register 1 - Load Register command
        volatile uint32_t CAU_LDR_CA2;  ///< Offset: 0x850 - General Purpose Register 2 - Load Register command
        volatile uint32_t CAU_LDR_CA3;  ///< Offset: 0x854 - General Purpose Register 3 - Load Register command
        volatile uint32_t CAU_LDR_CA4;  ///< Offset: 0x858 - General Purpose Register 4 - Load Register command
        volatile uint32_t CAU_LDR_CA5;  ///< Offset: 0x85C - General Purpose Register 5 - Load Register command
        volatile uint32_t CAU_LDR_CA6;  ///< Offset: 0x860 - General Purpose Register 6 - Load Register command
        volatile uint32_t CAU_LDR_CA7;  ///< Offset: 0x864 - General Purpose Register 7 - Load Register command
        volatile uint32_t CAU_LDR_CA8;  ///< Offset: 0x868 - General Purpose Register 8 - Load Register command
        volatile uint32_t CAU_STR_CASR;  ///< Offset: 0x880 - Status register - Store Register command
        volatile uint32_t CAU_STR_CAA;  ///< Offset: 0x884 - Accumulator register - Store Register command
        volatile uint32_t CAU_STR_CA0;  ///< Offset: 0x888 - General Purpose Register 0 - Store Register command
        volatile uint32_t CAU_STR_CA1;  ///< Offset: 0x88C - General Purpose Register 1 - Store Register command
        volatile uint32_t CAU_STR_CA2;  ///< Offset: 0x890 - General Purpose Register 2 - Store Register command
        volatile uint32_t CAU_STR_CA3;  ///< Offset: 0x894 - General Purpose Register 3 - Store Register command
        volatile uint32_t CAU_STR_CA4;  ///< Offset: 0x898 - General Purpose Register 4 - Store Register command
        volatile uint32_t CAU_STR_CA5;  ///< Offset: 0x89C - General Purpose Register 5 - Store Register command
        volatile uint32_t CAU_STR_CA6;  ///< Offset: 0x8A0 - General Purpose Register 6 - Store Register command
        volatile uint32_t CAU_STR_CA7;  ///< Offset: 0x8A4 - General Purpose Register 7 - Store Register command
        volatile uint32_t CAU_STR_CA8;  ///< Offset: 0x8A8 - General Purpose Register 8 - Store Register command
        volatile uint32_t CAU_ADR_CASR;  ///< Offset: 0x8C0 - Status register - Add Register command
        volatile uint32_t CAU_ADR_CAA;  ///< Offset: 0x8C4 - Accumulator register - Add to register command
        volatile uint32_t CAU_ADR_CA0;  ///< Offset: 0x8C8 - General Purpose Register 0 - Add to register command
        volatile uint32_t CAU_ADR_CA1;  ///< Offset: 0x8CC - General Purpose Register 1 - Add to register command
        volatile uint32_t CAU_ADR_CA2;  ///< Offset: 0x8D0 - General Purpose Register 2 - Add to register command
        volatile uint32_t CAU_ADR_CA3;  ///< Offset: 0x8D4 - General Purpose Register 3 - Add to register command
        volatile uint32_t CAU_ADR_CA4;  ///< Offset: 0x8D8 - General Purpose Register 4 - Add to register command
        volatile uint32_t CAU_ADR_CA5;  ///< Offset: 0x8DC - General Purpose Register 5 - Add to register command
        volatile uint32_t CAU_ADR_CA6;  ///< Offset: 0x8E0 - General Purpose Register 6 - Add to register command
        volatile uint32_t CAU_ADR_CA7;  ///< Offset: 0x8E4 - General Purpose Register 7 - Add to register command
        volatile uint32_t CAU_ADR_CA8;  ///< Offset: 0x8E8 - General Purpose Register 8 - Add to register command
        volatile uint32_t CAU_RADR_CASR;  ///< Offset: 0x900 - Status register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CAA;  ///< Offset: 0x904 - Accumulator register - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA0;  ///< Offset: 0x908 - General Purpose Register 0 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA1;  ///< Offset: 0x90C - General Purpose Register 1 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA2;  ///< Offset: 0x910 - General Purpose Register 2 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA3;  ///< Offset: 0x914 - General Purpose Register 3 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA4;  ///< Offset: 0x918 - General Purpose Register 4 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA5;  ///< Offset: 0x91C - General Purpose Register 5 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA6;  ///< Offset: 0x920 - General Purpose Register 6 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA7;  ///< Offset: 0x924 - General Purpose Register 7 - Reverse and Add to Register command
        volatile uint32_t CAU_RADR_CA8;  ///< Offset: 0x928 - General Purpose Register 8 - Reverse and Add to Register command
        volatile uint32_t CAU_XOR_CASR;  ///< Offset: 0x980 - Status register - Exclusive Or command
        volatile uint32_t CAU_XOR_CAA;  ///< Offset: 0x984 - Accumulator register - Exclusive Or command
        volatile uint32_t CAU_XOR_CA0;  ///< Offset: 0x988 - General Purpose Register 0 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA1;  ///< Offset: 0x98C - General Purpose Register 1 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA2;  ///< Offset: 0x990 - General Purpose Register 2 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA3;  ///< Offset: 0x994 - General Purpose Register 3 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA4;  ///< Offset: 0x998 - General Purpose Register 4 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA5;  ///< Offset: 0x99C - General Purpose Register 5 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA6;  ///< Offset: 0x9A0 - General Purpose Register 6 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA7;  ///< Offset: 0x9A4 - General Purpose Register 7 - Exclusive Or command
        volatile uint32_t CAU_XOR_CA8;  ///< Offset: 0x9A8 - General Purpose Register 8 - Exclusive Or command
        volatile uint32_t CAU_ROTL_CASR;  ///< Offset: 0x9C0 - Status register - Rotate Left command
        volatile uint32_t CAU_ROTL_CAA;  ///< Offset: 0x9C4 - Accumulator register - Rotate Left command
        volatile uint32_t CAU_ROTL_CA0;  ///< Offset: 0x9C8 - General Purpose Register 0 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA1;  ///< Offset: 0x9CC - General Purpose Register 1 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA2;  ///< Offset: 0x9D0 - General Purpose Register 2 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA3;  ///< Offset: 0x9D4 - General Purpose Register 3 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA4;  ///< Offset: 0x9D8 - General Purpose Register 4 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA5;  ///< Offset: 0x9DC - General Purpose Register 5 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA6;  ///< Offset: 0x9E0 - General Purpose Register 6 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA7;  ///< Offset: 0x9E4 - General Purpose Register 7 - Rotate Left command
        volatile uint32_t CAU_ROTL_CA8;  ///< Offset: 0x9E8 - General Purpose Register 8 - Rotate Left command
        volatile uint32_t CAU_AESC_CASR;  ///< Offset: 0xB00 - Status register - AES Column Operation command
        volatile uint32_t CAU_AESC_CAA;  ///< Offset: 0xB04 - Accumulator register - AES Column Operation command
        volatile uint32_t CAU_AESC_CA0;  ///< Offset: 0xB08 - General Purpose Register 0 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA1;  ///< Offset: 0xB0C - General Purpose Register 1 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA2;  ///< Offset: 0xB10 - General Purpose Register 2 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA3;  ///< Offset: 0xB14 - General Purpose Register 3 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA4;  ///< Offset: 0xB18 - General Purpose Register 4 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA5;  ///< Offset: 0xB1C - General Purpose Register 5 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA6;  ///< Offset: 0xB20 - General Purpose Register 6 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA7;  ///< Offset: 0xB24 - General Purpose Register 7 - AES Column Operation command
        volatile uint32_t CAU_AESC_CA8;  ///< Offset: 0xB28 - General Purpose Register 8 - AES Column Operation command
        volatile uint32_t CAU_AESIC_CASR;  ///< Offset: 0xB40 - Status register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CAA;  ///< Offset: 0xB44 - Accumulator register - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA0;  ///< Offset: 0xB48 - General Purpose Register 0 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA1;  ///< Offset: 0xB4C - General Purpose Register 1 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA2;  ///< Offset: 0xB50 - General Purpose Register 2 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA3;  ///< Offset: 0xB54 - General Purpose Register 3 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA4;  ///< Offset: 0xB58 - General Purpose Register 4 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA5;  ///< Offset: 0xB5C - General Purpose Register 5 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA6;  ///< Offset: 0xB60 - General Purpose Register 6 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA7;  ///< Offset: 0xB64 - General Purpose Register 7 - AES Inverse Column Operation command
        volatile uint32_t CAU_AESIC_CA8;  ///< Offset: 0xB68 - General Purpose Register 8 - AES Inverse Column Operation command
    };

    /// Peripheral instances
    inline Registers* CAU0 = reinterpret_cast<Registers*>(CAU0_BASE);

    // Bit definitions
    /// CAU_DIRECT0 Register bits
    namespace cau_direct0_bits {
        constexpr uint32_t CAU_DIRECT0 = (32 << 0);  ///< Direct register 0
    }

    /// CAU_DIRECT1 Register bits
    namespace cau_direct1_bits {
        constexpr uint32_t CAU_DIRECT1 = (32 << 0);  ///< Direct register 1
    }

    /// CAU_DIRECT2 Register bits
    namespace cau_direct2_bits {
        constexpr uint32_t CAU_DIRECT2 = (32 << 0);  ///< Direct register 2
    }

    /// CAU_DIRECT3 Register bits
    namespace cau_direct3_bits {
        constexpr uint32_t CAU_DIRECT3 = (32 << 0);  ///< Direct register 3
    }

    /// CAU_DIRECT4 Register bits
    namespace cau_direct4_bits {
        constexpr uint32_t CAU_DIRECT4 = (32 << 0);  ///< Direct register 4
    }

    /// CAU_DIRECT5 Register bits
    namespace cau_direct5_bits {
        constexpr uint32_t CAU_DIRECT5 = (32 << 0);  ///< Direct register 5
    }

    /// CAU_DIRECT6 Register bits
    namespace cau_direct6_bits {
        constexpr uint32_t CAU_DIRECT6 = (32 << 0);  ///< Direct register 6
    }

    /// CAU_DIRECT7 Register bits
    namespace cau_direct7_bits {
        constexpr uint32_t CAU_DIRECT7 = (32 << 0);  ///< Direct register 7
    }

    /// CAU_DIRECT8 Register bits
    namespace cau_direct8_bits {
        constexpr uint32_t CAU_DIRECT8 = (32 << 0);  ///< Direct register 8
    }

    /// CAU_DIRECT9 Register bits
    namespace cau_direct9_bits {
        constexpr uint32_t CAU_DIRECT9 = (32 << 0);  ///< Direct register 9
    }

    /// CAU_DIRECT10 Register bits
    namespace cau_direct10_bits {
        constexpr uint32_t CAU_DIRECT10 = (32 << 0);  ///< Direct register 10
    }

    /// CAU_DIRECT11 Register bits
    namespace cau_direct11_bits {
        constexpr uint32_t CAU_DIRECT11 = (32 << 0);  ///< Direct register 11
    }

    /// CAU_DIRECT12 Register bits
    namespace cau_direct12_bits {
        constexpr uint32_t CAU_DIRECT12 = (32 << 0);  ///< Direct register 12
    }

    /// CAU_DIRECT13 Register bits
    namespace cau_direct13_bits {
        constexpr uint32_t CAU_DIRECT13 = (32 << 0);  ///< Direct register 13
    }

    /// CAU_DIRECT14 Register bits
    namespace cau_direct14_bits {
        constexpr uint32_t CAU_DIRECT14 = (32 << 0);  ///< Direct register 14
    }

    /// CAU_DIRECT15 Register bits
    namespace cau_direct15_bits {
        constexpr uint32_t CAU_DIRECT15 = (32 << 0);  ///< Direct register 15
    }

    /// CAU_LDR_CASR Register bits
    namespace cau_ldr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_LDR_CAA Register bits
    namespace cau_ldr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_LDR_CA0 Register bits
    namespace cau_ldr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_LDR_CA1 Register bits
    namespace cau_ldr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_LDR_CA2 Register bits
    namespace cau_ldr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_LDR_CA3 Register bits
    namespace cau_ldr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_LDR_CA4 Register bits
    namespace cau_ldr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_LDR_CA5 Register bits
    namespace cau_ldr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_LDR_CA6 Register bits
    namespace cau_ldr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_LDR_CA7 Register bits
    namespace cau_ldr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_LDR_CA8 Register bits
    namespace cau_ldr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_STR_CASR Register bits
    namespace cau_str_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_STR_CAA Register bits
    namespace cau_str_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_STR_CA0 Register bits
    namespace cau_str_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_STR_CA1 Register bits
    namespace cau_str_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_STR_CA2 Register bits
    namespace cau_str_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_STR_CA3 Register bits
    namespace cau_str_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_STR_CA4 Register bits
    namespace cau_str_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_STR_CA5 Register bits
    namespace cau_str_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_STR_CA6 Register bits
    namespace cau_str_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_STR_CA7 Register bits
    namespace cau_str_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_STR_CA8 Register bits
    namespace cau_str_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ADR_CASR Register bits
    namespace cau_adr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ADR_CAA Register bits
    namespace cau_adr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ADR_CA0 Register bits
    namespace cau_adr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ADR_CA1 Register bits
    namespace cau_adr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ADR_CA2 Register bits
    namespace cau_adr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ADR_CA3 Register bits
    namespace cau_adr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ADR_CA4 Register bits
    namespace cau_adr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ADR_CA5 Register bits
    namespace cau_adr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ADR_CA6 Register bits
    namespace cau_adr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ADR_CA7 Register bits
    namespace cau_adr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ADR_CA8 Register bits
    namespace cau_adr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_RADR_CASR Register bits
    namespace cau_radr_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_RADR_CAA Register bits
    namespace cau_radr_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_RADR_CA0 Register bits
    namespace cau_radr_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_RADR_CA1 Register bits
    namespace cau_radr_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_RADR_CA2 Register bits
    namespace cau_radr_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_RADR_CA3 Register bits
    namespace cau_radr_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_RADR_CA4 Register bits
    namespace cau_radr_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_RADR_CA5 Register bits
    namespace cau_radr_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_RADR_CA6 Register bits
    namespace cau_radr_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_RADR_CA7 Register bits
    namespace cau_radr_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_RADR_CA8 Register bits
    namespace cau_radr_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_XOR_CASR Register bits
    namespace cau_xor_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_XOR_CAA Register bits
    namespace cau_xor_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_XOR_CA0 Register bits
    namespace cau_xor_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_XOR_CA1 Register bits
    namespace cau_xor_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_XOR_CA2 Register bits
    namespace cau_xor_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_XOR_CA3 Register bits
    namespace cau_xor_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_XOR_CA4 Register bits
    namespace cau_xor_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_XOR_CA5 Register bits
    namespace cau_xor_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_XOR_CA6 Register bits
    namespace cau_xor_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_XOR_CA7 Register bits
    namespace cau_xor_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_XOR_CA8 Register bits
    namespace cau_xor_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_ROTL_CASR Register bits
    namespace cau_rotl_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_ROTL_CAA Register bits
    namespace cau_rotl_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_ROTL_CA0 Register bits
    namespace cau_rotl_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_ROTL_CA1 Register bits
    namespace cau_rotl_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_ROTL_CA2 Register bits
    namespace cau_rotl_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_ROTL_CA3 Register bits
    namespace cau_rotl_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_ROTL_CA4 Register bits
    namespace cau_rotl_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_ROTL_CA5 Register bits
    namespace cau_rotl_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_ROTL_CA6 Register bits
    namespace cau_rotl_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_ROTL_CA7 Register bits
    namespace cau_rotl_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_ROTL_CA8 Register bits
    namespace cau_rotl_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESC_CASR Register bits
    namespace cau_aesc_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESC_CAA Register bits
    namespace cau_aesc_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESC_CA0 Register bits
    namespace cau_aesc_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESC_CA1 Register bits
    namespace cau_aesc_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESC_CA2 Register bits
    namespace cau_aesc_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESC_CA3 Register bits
    namespace cau_aesc_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESC_CA4 Register bits
    namespace cau_aesc_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESC_CA5 Register bits
    namespace cau_aesc_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESC_CA6 Register bits
    namespace cau_aesc_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESC_CA7 Register bits
    namespace cau_aesc_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESC_CA8 Register bits
    namespace cau_aesc_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

    /// CAU_AESIC_CASR Register bits
    namespace cau_aesic_casr_bits {
        constexpr uint32_t IC = (1U << 0);  ///< no description available
        constexpr uint32_t DPE = (1U << 1);  ///< no description available
        constexpr uint32_t VER = (4 << 28);  ///< CAU version
    }

    /// CAU_AESIC_CAA Register bits
    namespace cau_aesic_caa_bits {
        constexpr uint32_t ACC = (32 << 0);  ///< ACC
    }

    /// CAU_AESIC_CA0 Register bits
    namespace cau_aesic_ca0_bits {
        constexpr uint32_t CA0 = (32 << 0);  ///< CA0
    }

    /// CAU_AESIC_CA1 Register bits
    namespace cau_aesic_ca1_bits {
        constexpr uint32_t CA1 = (32 << 0);  ///< CA1
    }

    /// CAU_AESIC_CA2 Register bits
    namespace cau_aesic_ca2_bits {
        constexpr uint32_t CA2 = (32 << 0);  ///< CA2
    }

    /// CAU_AESIC_CA3 Register bits
    namespace cau_aesic_ca3_bits {
        constexpr uint32_t CA3 = (32 << 0);  ///< CA3
    }

    /// CAU_AESIC_CA4 Register bits
    namespace cau_aesic_ca4_bits {
        constexpr uint32_t CA4 = (32 << 0);  ///< CA4
    }

    /// CAU_AESIC_CA5 Register bits
    namespace cau_aesic_ca5_bits {
        constexpr uint32_t CA5 = (32 << 0);  ///< CA5
    }

    /// CAU_AESIC_CA6 Register bits
    namespace cau_aesic_ca6_bits {
        constexpr uint32_t CA6 = (32 << 0);  ///< CA6
    }

    /// CAU_AESIC_CA7 Register bits
    namespace cau_aesic_ca7_bits {
        constexpr uint32_t CA7 = (32 << 0);  ///< CA7
    }

    /// CAU_AESIC_CA8 Register bits
    namespace cau_aesic_ca8_bits {
        constexpr uint32_t CA8 = (32 << 0);  ///< CA8
    }

}


} // namespace alloy::generated::mkl28t7_core0

#endif // ALLOY_GENERATED_MKL28T7_CORE0_PERIPHERALS_HPP