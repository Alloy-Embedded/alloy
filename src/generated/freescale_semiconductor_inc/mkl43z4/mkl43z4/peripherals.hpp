/// Auto-generated code for MKL43Z4
/// Generated by Alloy Code Generator
/// Source: nxp_mkl43.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:40
#ifndef ALLOY_GENERATED_MKL43Z4_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKL43Z4_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkl43z4 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_i2s = true;
    constexpr uint32_t num_i2s_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 5;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 15;
    constexpr bool has_lcd = true;
    constexpr uint32_t num_lcd_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_flexio = true;
    constexpr uint32_t num_flexio_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc0 = true;
    constexpr uint32_t num_osc0_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct i2s_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 15;
    };
    template<>
    struct peripheral_count<struct lcd_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct flexio_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 15;
    constexpr uint32_t max_gpio_pins = 240;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_uart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT0 = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t RESET_PIN_CFG = (1U << 3);  ///< no description available
        constexpr uint32_t LPBOOT1 = (1U << 4);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX0_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t SAR0;  ///< Offset: 0x100 - Source Address Register
        volatile uint32_t DAR0;  ///< Offset: 0x104 - Destination Address Register
        volatile uint32_t DSR_BCR0;  ///< Offset: 0x108 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR0;  ///< Offset: 0x10B - DMA_DSR0 register.
        volatile uint32_t DCR0;  ///< Offset: 0x10C - DMA Control Register
        volatile uint32_t SAR1;  ///< Offset: 0x110 - Source Address Register
        volatile uint32_t DAR1;  ///< Offset: 0x114 - Destination Address Register
        volatile uint32_t DSR_BCR1;  ///< Offset: 0x118 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR1;  ///< Offset: 0x11B - DMA_DSR1 register.
        volatile uint32_t DCR1;  ///< Offset: 0x11C - DMA Control Register
        volatile uint32_t SAR2;  ///< Offset: 0x120 - Source Address Register
        volatile uint32_t DAR2;  ///< Offset: 0x124 - Destination Address Register
        volatile uint32_t DSR_BCR2;  ///< Offset: 0x128 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR2;  ///< Offset: 0x12B - DMA_DSR2 register.
        volatile uint32_t DCR2;  ///< Offset: 0x12C - DMA Control Register
        volatile uint32_t SAR3;  ///< Offset: 0x130 - Source Address Register
        volatile uint32_t DAR3;  ///< Offset: 0x134 - Destination Address Register
        volatile uint32_t DSR_BCR3;  ///< Offset: 0x138 - DMA Status Register / Byte Count Register
        volatile uint32_t DSR3;  ///< Offset: 0x13B - DMA_DSR3 register.
        volatile uint32_t DCR3;  ///< Offset: 0x13C - DMA Control Register
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX0 = reinterpret_cast<Registers*>(DMAMUX0_BASE);

    // Bit definitions
    /// SAR0 Register bits
    namespace sar0_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR0 Register bits
    namespace dar0_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR0 Register bits
    namespace dsr_bcr0_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR0 Register bits
    namespace dcr0_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR1 Register bits
    namespace sar1_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR1 Register bits
    namespace dar1_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR1 Register bits
    namespace dsr_bcr1_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR1 Register bits
    namespace dcr1_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR2 Register bits
    namespace sar2_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR2 Register bits
    namespace dar2_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR2 Register bits
    namespace dsr_bcr2_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR2 Register bits
    namespace dcr2_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

    /// SAR3 Register bits
    namespace sar3_bits {
        constexpr uint32_t SAR = (32 << 0);  ///< SAR
    }

    /// DAR3 Register bits
    namespace dar3_bits {
        constexpr uint32_t DAR = (32 << 0);  ///< DAR
    }

    /// DSR_BCR3 Register bits
    namespace dsr_bcr3_bits {
        constexpr uint32_t BCR = (24 << 0);  ///< BCR
        constexpr uint32_t DONE = (1U << 24);  ///< Transactions Done
        constexpr uint32_t BSY = (1U << 25);  ///< Busy
        constexpr uint32_t REQ = (1U << 26);  ///< Request
        constexpr uint32_t BED = (1U << 28);  ///< Bus Error on Destination
        constexpr uint32_t BES = (1U << 29);  ///< Bus Error on Source
        constexpr uint32_t CE = (1U << 30);  ///< Configuration Error
    }

    /// DCR3 Register bits
    namespace dcr3_bits {
        constexpr uint32_t LCH2 = (2 << 0);  ///< Link Channel 2
        constexpr uint32_t LCH1 = (2 << 2);  ///< Link Channel 1
        constexpr uint32_t LINKCC = (2 << 4);  ///< Link Channel Control
        constexpr uint32_t D_REQ = (1U << 7);  ///< Disable Request
        constexpr uint32_t DMOD = (4 << 8);  ///< Destination Address Modulo
        constexpr uint32_t SMOD = (4 << 12);  ///< Source Address Modulo
        constexpr uint32_t START = (1U << 16);  ///< Start Transfer
        constexpr uint32_t DSIZE = (2 << 17);  ///< Destination Size
        constexpr uint32_t DINC = (1U << 19);  ///< Destination Increment
        constexpr uint32_t SSIZE = (2 << 20);  ///< Source Size
        constexpr uint32_t SINC = (1U << 22);  ///< Source Increment
        constexpr uint32_t EADREQ = (1U << 23);  ///< Enable asynchronous DMA requests
        constexpr uint32_t AA = (1U << 28);  ///< Auto-align
        constexpr uint32_t CS = (1U << 29);  ///< Cycle Steal
        constexpr uint32_t ERQ = (1U << 30);  ///< Enable Peripheral Request
        constexpr uint32_t EINT = (1U << 31);  ///< Enable Interrupt on Completion of Transfer
    }

}

// ============================================================================
// I2S Peripheral
// ============================================================================

namespace i2s {
    /// Base addresses
    constexpr uint32_t I2S0_BASE = 0x4002F000;

    /// I2S Register structure
    struct Registers {
        volatile uint32_t TCSR;  ///< Offset: 0x00 - SAI Transmit Control Register
        volatile uint32_t TCR2;  ///< Offset: 0x08 - SAI Transmit Configuration 2 Register
        volatile uint32_t TCR3;  ///< Offset: 0x0C - SAI Transmit Configuration 3 Register
        volatile uint32_t TCR4;  ///< Offset: 0x10 - SAI Transmit Configuration 4 Register
        volatile uint32_t TCR5;  ///< Offset: 0x14 - SAI Transmit Configuration 5 Register
        volatile uint32_t TDR;  ///< Offset: 0x20 - SAI Transmit Data Register
        volatile uint32_t TMR;  ///< Offset: 0x60 - SAI Transmit Mask Register
        volatile uint32_t RCSR;  ///< Offset: 0x80 - SAI Receive Control Register
        volatile uint32_t RCR2;  ///< Offset: 0x88 - SAI Receive Configuration 2 Register
        volatile uint32_t RCR3;  ///< Offset: 0x8C - SAI Receive Configuration 3 Register
        volatile uint32_t RCR4;  ///< Offset: 0x90 - SAI Receive Configuration 4 Register
        volatile uint32_t RCR5;  ///< Offset: 0x94 - SAI Receive Configuration 5 Register
        volatile uint32_t RDR;  ///< Offset: 0xA0 - SAI Receive Data Register
        volatile uint32_t RMR;  ///< Offset: 0xE0 - SAI Receive Mask Register
        volatile uint32_t MCR;  ///< Offset: 0x100 - SAI MCLK Control Register
    };

    /// Peripheral instances
    inline Registers* I2S0 = reinterpret_cast<Registers*>(I2S0_BASE);

    // Bit definitions
    /// TCSR Register bits
    namespace tcsr_bits {
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t TE = (1U << 31);  ///< Transmitter Enable
    }

    /// TCR2 Register bits
    namespace tcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// TCR3 Register bits
    namespace tcr3_bits {
        constexpr uint32_t WDFL = (1U << 0);  ///< Word Flag Configuration
        constexpr uint32_t TCE = (1U << 16);  ///< Transmit Channel Enable
    }

    /// TCR4 Register bits
    namespace tcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (1U << 16);  ///< Frame size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// TCR5 Register bits
    namespace tcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (32 << 0);  ///< Transmit Data Register
    }

    /// TMR Register bits
    namespace tmr_bits {
        constexpr uint32_t TWM = (2 << 0);  ///< Transmit Word Mask
    }

    /// RCSR Register bits
    namespace rcsr_bits {
        constexpr uint32_t FWDE = (1U << 1);  ///< FIFO Warning DMA Enable
        constexpr uint32_t FWIE = (1U << 9);  ///< FIFO Warning Interrupt Enable
        constexpr uint32_t FEIE = (1U << 10);  ///< FIFO Error Interrupt Enable
        constexpr uint32_t SEIE = (1U << 11);  ///< Sync Error Interrupt Enable
        constexpr uint32_t WSIE = (1U << 12);  ///< Word Start Interrupt Enable
        constexpr uint32_t FWF = (1U << 17);  ///< FIFO Warning Flag
        constexpr uint32_t FEF = (1U << 18);  ///< FIFO Error Flag
        constexpr uint32_t SEF = (1U << 19);  ///< Sync Error Flag
        constexpr uint32_t WSF = (1U << 20);  ///< Word Start Flag
        constexpr uint32_t SR = (1U << 24);  ///< Software Reset
        constexpr uint32_t FR = (1U << 25);  ///< FIFO Reset
        constexpr uint32_t BCE = (1U << 28);  ///< Bit Clock Enable
        constexpr uint32_t DBGE = (1U << 29);  ///< Debug Enable
        constexpr uint32_t STOPE = (1U << 30);  ///< Stop Enable
        constexpr uint32_t RE = (1U << 31);  ///< Receiver Enable
    }

    /// RCR2 Register bits
    namespace rcr2_bits {
        constexpr uint32_t DIV = (8 << 0);  ///< Bit Clock Divide
        constexpr uint32_t BCD = (1U << 24);  ///< Bit Clock Direction
        constexpr uint32_t BCP = (1U << 25);  ///< Bit Clock Polarity
        constexpr uint32_t MSEL = (2 << 26);  ///< MCLK Select
        constexpr uint32_t BCI = (1U << 28);  ///< Bit Clock Input
        constexpr uint32_t BCS = (1U << 29);  ///< Bit Clock Swap
        constexpr uint32_t SYNC = (2 << 30);  ///< Synchronous Mode
    }

    /// RCR3 Register bits
    namespace rcr3_bits {
        constexpr uint32_t WDFL = (1U << 0);  ///< Word Flag Configuration
        constexpr uint32_t RCE = (1U << 16);  ///< Receive Channel Enable
    }

    /// RCR4 Register bits
    namespace rcr4_bits {
        constexpr uint32_t FSD = (1U << 0);  ///< Frame Sync Direction
        constexpr uint32_t FSP = (1U << 1);  ///< Frame Sync Polarity
        constexpr uint32_t ONDEM = (1U << 2);  ///< On Demand Mode
        constexpr uint32_t FSE = (1U << 3);  ///< Frame Sync Early
        constexpr uint32_t MF = (1U << 4);  ///< MSB First
        constexpr uint32_t SYWD = (5 << 8);  ///< Sync Width
        constexpr uint32_t FRSZ = (1U << 16);  ///< Frame Size
        constexpr uint32_t FPACK = (2 << 24);  ///< FIFO Packing Mode
        constexpr uint32_t FCONT = (1U << 28);  ///< FIFO Continue on Error
    }

    /// RCR5 Register bits
    namespace rcr5_bits {
        constexpr uint32_t FBT = (5 << 8);  ///< First Bit Shifted
        constexpr uint32_t W0W = (5 << 16);  ///< Word 0 Width
        constexpr uint32_t WNW = (5 << 24);  ///< Word N Width
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (32 << 0);  ///< Receive Data Register
    }

    /// RMR Register bits
    namespace rmr_bits {
        constexpr uint32_t RWM = (2 << 0);  ///< Receive Word Mask
    }

    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t MICS = (2 << 24);  ///< MCLK Input Clock Select
        constexpr uint32_t MOE = (1U << 30);  ///< MCLK Output Enable
        constexpr uint32_t DUF = (1U << 31);  ///< Divider Update Flag
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT_BASE = 0x40037000;
    constexpr uint32_t TPM0_BASE = 0x40038000;
    constexpr uint32_t TPM1_BASE = 0x40039000;
    constexpr uint32_t TPM2_BASE = 0x4003A000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT = reinterpret_cast<Registers*>(PIT_BASE);
    inline Registers* TPM0 = reinterpret_cast<Registers*>(TPM0_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (1U << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (1U << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT1CFG;  ///< Offset: 0x04 - SOPT1 Configuration Register
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT4;  ///< Offset: 0x100C - System Options Register 4
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t COPC;  ///< Offset: 0x1100 - COP Control Register
        volatile uint32_t SRVCOP;  ///< Offset: 0x1104 - Service COP
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t OSC32KOUT = (2 << 16);  ///< 32K oscillator clock output
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K Oscillator Clock Select
        constexpr uint32_t USBVSTBY = (1U << 29);  ///< USB voltage regulator in standby mode during VLPR and VLPW modes
        constexpr uint32_t USBSSTBY = (1U << 30);  ///< USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
        constexpr uint32_t USBREGEN = (1U << 31);  ///< USB voltage regulator enable
    }

    /// SOPT1CFG Register bits
    namespace sopt1cfg_bits {
        constexpr uint32_t URWE = (1U << 24);  ///< USB voltage regulator enable write enable
        constexpr uint32_t UVSWE = (1U << 25);  ///< USB voltage regulator VLP standby write enable
        constexpr uint32_t USSWE = (1U << 26);  ///< USB voltage regulator stop standby write enable
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTSEL = (1U << 4);  ///< RTC Clock Out Select
        constexpr uint32_t CLKOUTSEL = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
        constexpr uint32_t FLEXIOSRC = (2 << 22);  ///< FlexIO Module Clock Source Select
        constexpr uint32_t TPMSRC = (2 << 24);  ///< TPM Clock Source Select
        constexpr uint32_t LPUART0SRC = (2 << 26);  ///< LPUART0 Clock Source Select
        constexpr uint32_t LPUART1SRC = (2 << 28);  ///< LPUART1 Clock Source Select
    }

    /// SOPT4 Register bits
    namespace sopt4_bits {
        constexpr uint32_t TPM1CH0SRC = (2 << 18);  ///< TPM1 channel 0 input capture source select
        constexpr uint32_t TPM2CH0SRC = (1U << 20);  ///< TPM2 Channel 0 Input Capture Source Select
        constexpr uint32_t TPM0CLKSEL = (1U << 24);  ///< TPM0 External Clock Pin Select
        constexpr uint32_t TPM1CLKSEL = (1U << 25);  ///< TPM1 External Clock Pin Select
        constexpr uint32_t TPM2CLKSEL = (1U << 26);  ///< TPM2 External Clock Pin Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t LPUART0TXSRC = (2 << 0);  ///< LPUART0 Transmit Data Source Select
        constexpr uint32_t LPUART0RXSRC = (1U << 2);  ///< LPUART0 Receive Data Source Select
        constexpr uint32_t LPUART1TXSRC = (2 << 4);  ///< LPUART1 Transmit Data Source Select
        constexpr uint32_t LPUART1RXSRC = (1U << 6);  ///< LPUART1 Receive Data Source Select
        constexpr uint32_t LPUART0ODE = (1U << 16);  ///< LPUART0 Open Drain Enable
        constexpr uint32_t LPUART1ODE = (1U << 17);  ///< LPUART1 Open Drain Enable
        constexpr uint32_t UART2ODE = (1U << 18);  ///< UART2 Open Drain Enable
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 Trigger Select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 Pretrigger Select
        constexpr uint32_t ADC0ALTTRGEN = (1U << 7);  ///< ADC0 Alternate Trigger Enable
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount Identification
        constexpr uint32_t REVID = (4 << 12);  ///< Device Revision Number
        constexpr uint32_t SRAMSIZE = (4 << 16);  ///< System SRAM Size
        constexpr uint32_t SERIESID = (4 << 20);  ///< Kinetis Series ID
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis Sub-Family ID
        constexpr uint32_t FAMID = (4 << 28);  ///< Family ID
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t UART2 = (1U << 12);  ///< UART2 Clock Gate Control
        constexpr uint32_t USBFS = (1U << 18);  ///< USB Clock Gate Control
        constexpr uint32_t CMP0 = (1U << 19);  ///< Comparator Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 22);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 23);  ///< SPI1 Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR = (1U << 0);  ///< Low Power Timer Access Control
        constexpr uint32_t PORTA = (1U << 9);  ///< Port A Clock Gate Control
        constexpr uint32_t PORTB = (1U << 10);  ///< Port B Clock Gate Control
        constexpr uint32_t PORTC = (1U << 11);  ///< Port C Clock Gate Control
        constexpr uint32_t PORTD = (1U << 12);  ///< Port D Clock Gate Control
        constexpr uint32_t PORTE = (1U << 13);  ///< Port E Clock Gate Control
        constexpr uint32_t SLCD = (1U << 19);  ///< Segment LCD Clock Gate Control
        constexpr uint32_t LPUART0 = (1U << 20);  ///< LPUART0 Clock Gate Control
        constexpr uint32_t LPUART1 = (1U << 21);  ///< LPUART1 Clock Gate Control
        constexpr uint32_t FLEXIO = (1U << 31);  ///< FlexIO Module
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t FTF = (1U << 0);  ///< Flash Memory Clock Gate Control
        constexpr uint32_t DMAMUX = (1U << 1);  ///< DMA Mux Clock Gate Control
        constexpr uint32_t I2S = (1U << 15);  ///< I2S Clock Gate Control
        constexpr uint32_t PIT = (1U << 23);  ///< PIT Clock Gate Control
        constexpr uint32_t TPM0 = (1U << 24);  ///< TPM0 Clock Gate Control
        constexpr uint32_t TPM1 = (1U << 25);  ///< TPM1 Clock Gate Control
        constexpr uint32_t TPM2 = (1U << 26);  ///< TPM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Access Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t DMA = (1U << 8);  ///< DMA Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV4 = (3 << 16);  ///< Clock 4 Output Divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 Output Divider value
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program Flash Size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR1 = (7 << 16);  ///< This field concatenated with leading zeros plus the value of the MAXADDR0 field indicates the first invalid address of the second program flash block (flash block 1)
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max Address lock
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (16 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// COPC Register bits
    namespace copc_bits {
        constexpr uint32_t COPW = (1U << 0);  ///< COP Windowed Mode
        constexpr uint32_t COPCLKS = (1U << 1);  ///< COP Clock Select
        constexpr uint32_t COPT = (2 << 2);  ///< COP Watchdog Timeout
        constexpr uint32_t COPSTPEN = (1U << 4);  ///< COP Stop Enable
        constexpr uint32_t COPDBGEN = (1U << 5);  ///< COP Debug Enable
        constexpr uint32_t COPCLKSEL = (2 << 6);  ///< COP Clock Select
    }

    /// SRVCOP Register bits
    namespace srvcop_bits {
        constexpr uint32_t SRVCOP = (8 << 0);  ///< Service COP Register
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOB_BASE = 0xF8000040;
    constexpr uint32_t FGPIOC_BASE = 0xF8000080;
    constexpr uint32_t FGPIOD_BASE = 0xF80000C0;
    constexpr uint32_t FGPIOE_BASE = 0xF8000100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOB = reinterpret_cast<Registers*>(FGPIOB_BASE);
    inline Registers* FGPIOC = reinterpret_cast<Registers*>(FGPIOC_BASE);
    inline Registers* FGPIOD = reinterpret_cast<Registers*>(FGPIOD_BASE);
    inline Registers* FGPIOE = reinterpret_cast<Registers*>(FGPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t DSE = (1U << 6);  ///< Drive Strength Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// LCD Peripheral
// ============================================================================

namespace lcd {
    /// Base addresses
    constexpr uint32_t LCD_BASE = 0x40053000;

    /// LCD Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - LCD General Control Register
        volatile uint32_t AR;  ///< Offset: 0x04 - LCD Auxiliary Register
        volatile uint32_t FDCR;  ///< Offset: 0x08 - LCD Fault Detect Control Register
        volatile uint32_t FDSR;  ///< Offset: 0x0C - LCD Fault Detect Status Register
        volatile uint32_t PEN;  ///< Offset: 0x10 - LCD Pin Enable register (renamed from PEN)
        volatile uint32_t BPEN;  ///< Offset: 0x18 - LCD Back Plane Enable register (renamed from BPEN)
        volatile uint32_t WF3TO0;  ///< Offset: 0x20 - LCD Waveform register
        volatile uint32_t WF0;  ///< Offset: 0x20 - LCD Waveform Register 0.
        volatile uint32_t WF1;  ///< Offset: 0x21 - LCD Waveform Register 1.
        volatile uint32_t WF2;  ///< Offset: 0x22 - LCD Waveform Register 2.
        volatile uint32_t WF3;  ///< Offset: 0x23 - LCD Waveform Register 3.
        volatile uint32_t WF7TO4;  ///< Offset: 0x24 - LCD Waveform register
        volatile uint32_t WF4;  ///< Offset: 0x24 - LCD Waveform Register 4.
        volatile uint32_t WF5;  ///< Offset: 0x25 - LCD Waveform Register 5.
        volatile uint32_t WF6;  ///< Offset: 0x26 - LCD Waveform Register 6.
        volatile uint32_t WF7;  ///< Offset: 0x27 - LCD Waveform Register 7.
        volatile uint32_t WF11TO8;  ///< Offset: 0x28 - LCD Waveform register
        volatile uint32_t WF8;  ///< Offset: 0x28 - LCD Waveform Register 8.
        volatile uint32_t WF9;  ///< Offset: 0x29 - LCD Waveform Register 9.
        volatile uint32_t WF10;  ///< Offset: 0x2A - LCD Waveform Register 10.
        volatile uint32_t WF11;  ///< Offset: 0x2B - LCD Waveform Register 11.
        volatile uint32_t WF15TO12;  ///< Offset: 0x2C - LCD Waveform register
        volatile uint32_t WF12;  ///< Offset: 0x2C - LCD Waveform Register 12.
        volatile uint32_t WF13;  ///< Offset: 0x2D - LCD Waveform Register 13.
        volatile uint32_t WF14;  ///< Offset: 0x2E - LCD Waveform Register 14.
        volatile uint32_t WF15;  ///< Offset: 0x2F - LCD Waveform Register 15.
        volatile uint32_t WF19TO16;  ///< Offset: 0x30 - LCD Waveform register
        volatile uint32_t WF16;  ///< Offset: 0x30 - LCD Waveform Register 16.
        volatile uint32_t WF17;  ///< Offset: 0x31 - LCD Waveform Register 17.
        volatile uint32_t WF18;  ///< Offset: 0x32 - LCD Waveform Register 18.
        volatile uint32_t WF19;  ///< Offset: 0x33 - LCD Waveform Register 19.
        volatile uint32_t WF23TO20;  ///< Offset: 0x34 - LCD Waveform register
        volatile uint32_t WF20;  ///< Offset: 0x34 - LCD Waveform Register 20.
        volatile uint32_t WF21;  ///< Offset: 0x35 - LCD Waveform Register 21.
        volatile uint32_t WF22;  ///< Offset: 0x36 - LCD Waveform Register 22.
        volatile uint32_t WF23;  ///< Offset: 0x37 - LCD Waveform Register 23.
        volatile uint32_t WF27TO24;  ///< Offset: 0x38 - LCD Waveform register
        volatile uint32_t WF24;  ///< Offset: 0x38 - LCD Waveform Register 24.
        volatile uint32_t WF25;  ///< Offset: 0x39 - LCD Waveform Register 25.
        volatile uint32_t WF26;  ///< Offset: 0x3A - LCD Waveform Register 26.
        volatile uint32_t WF27;  ///< Offset: 0x3B - LCD Waveform Register 27.
        volatile uint32_t WF31TO28;  ///< Offset: 0x3C - LCD Waveform register
        volatile uint32_t WF28;  ///< Offset: 0x3C - LCD Waveform Register 28.
        volatile uint32_t WF29;  ///< Offset: 0x3D - LCD Waveform Register 29.
        volatile uint32_t WF30;  ///< Offset: 0x3E - LCD Waveform Register 30.
        volatile uint32_t WF31;  ///< Offset: 0x3F - LCD Waveform Register 31.
        volatile uint32_t WF35TO32;  ///< Offset: 0x40 - LCD Waveform register
        volatile uint32_t WF32;  ///< Offset: 0x40 - LCD Waveform Register 32.
        volatile uint32_t WF33;  ///< Offset: 0x41 - LCD Waveform Register 33.
        volatile uint32_t WF34;  ///< Offset: 0x42 - LCD Waveform Register 34.
        volatile uint32_t WF35;  ///< Offset: 0x43 - LCD Waveform Register 35.
        volatile uint32_t WF39TO36;  ///< Offset: 0x44 - LCD Waveform register
        volatile uint32_t WF36;  ///< Offset: 0x44 - LCD Waveform Register 36.
        volatile uint32_t WF37;  ///< Offset: 0x45 - LCD Waveform Register 37.
        volatile uint32_t WF38;  ///< Offset: 0x46 - LCD Waveform Register 38.
        volatile uint32_t WF39;  ///< Offset: 0x47 - LCD Waveform Register 39.
        volatile uint32_t WF43TO40;  ///< Offset: 0x48 - LCD Waveform register
        volatile uint32_t WF40;  ///< Offset: 0x48 - LCD Waveform Register 40.
        volatile uint32_t WF41;  ///< Offset: 0x49 - LCD Waveform Register 41.
        volatile uint32_t WF42;  ///< Offset: 0x4A - LCD Waveform Register 42.
        volatile uint32_t WF43;  ///< Offset: 0x4B - LCD Waveform Register 43.
        volatile uint32_t WF47TO44;  ///< Offset: 0x4C - LCD Waveform register
        volatile uint32_t WF44;  ///< Offset: 0x4C - LCD Waveform Register 44.
        volatile uint32_t WF45;  ///< Offset: 0x4D - LCD Waveform Register 45.
        volatile uint32_t WF46;  ///< Offset: 0x4E - LCD Waveform Register 46.
        volatile uint32_t WF47;  ///< Offset: 0x4F - LCD Waveform Register 47.
        volatile uint32_t WF51TO48;  ///< Offset: 0x50 - LCD Waveform register
        volatile uint32_t WF48;  ///< Offset: 0x50 - LCD Waveform Register 48.
        volatile uint32_t WF49;  ///< Offset: 0x51 - LCD Waveform Register 49.
        volatile uint32_t WF50;  ///< Offset: 0x52 - LCD Waveform Register 50.
        volatile uint32_t WF51;  ///< Offset: 0x53 - LCD Waveform Register 51.
        volatile uint32_t WF55TO52;  ///< Offset: 0x54 - LCD Waveform register
        volatile uint32_t WF52;  ///< Offset: 0x54 - LCD Waveform Register 52.
        volatile uint32_t WF53;  ///< Offset: 0x55 - LCD Waveform Register 53.
        volatile uint32_t WF54;  ///< Offset: 0x56 - LCD Waveform Register 54.
        volatile uint32_t WF55;  ///< Offset: 0x57 - LCD Waveform Register 55.
        volatile uint32_t WF59TO56;  ///< Offset: 0x58 - LCD Waveform register
        volatile uint32_t WF56;  ///< Offset: 0x58 - LCD Waveform Register 56.
        volatile uint32_t WF57;  ///< Offset: 0x59 - LCD Waveform Register 57.
        volatile uint32_t WF58;  ///< Offset: 0x5A - LCD Waveform Register 58.
        volatile uint32_t WF59;  ///< Offset: 0x5B - LCD Waveform Register 59.
        volatile uint32_t WF63TO60;  ///< Offset: 0x5C - LCD Waveform register
        volatile uint32_t WF60;  ///< Offset: 0x5C - LCD Waveform Register 60.
        volatile uint32_t WF61;  ///< Offset: 0x5D - LCD Waveform Register 61.
        volatile uint32_t WF62;  ///< Offset: 0x5E - LCD Waveform Register 62.
        volatile uint32_t WF63;  ///< Offset: 0x5F - LCD Waveform Register 63.
    };

    /// Peripheral instances
    inline Registers* LCD = reinterpret_cast<Registers*>(LCD_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t DUTY = (3 << 0);  ///< LCD duty select
        constexpr uint32_t LCLK = (3 << 3);  ///< LCD Clock Prescaler
        constexpr uint32_t SOURCE = (1U << 6);  ///< LCD Clock Source Select
        constexpr uint32_t LCDEN = (1U << 7);  ///< LCD Driver Enable
        constexpr uint32_t LCDSTP = (1U << 8);  ///< LCD Stop
        constexpr uint32_t LCDDOZE = (1U << 9);  ///< LCD Doze enable
        constexpr uint32_t FFR = (1U << 10);  ///< Fast Frame Rate Select
        constexpr uint32_t ALTSOURCE = (1U << 11);  ///< Selects the alternate clock source
        constexpr uint32_t ALTDIV = (2 << 12);  ///< LCD AlternateClock Divider
        constexpr uint32_t FDCIEN = (1U << 14);  ///< LCD Fault Detection Complete Interrupt Enable
        constexpr uint32_t PADSAFE = (1U << 15);  ///< Pad Safe State Enable
        constexpr uint32_t VSUPPLY = (1U << 17);  ///< Voltage Supply Control
        constexpr uint32_t LADJ = (2 << 20);  ///< Load Adjust
        constexpr uint32_t CPSEL = (1U << 23);  ///< Charge Pump or Resistor Bias Select
        constexpr uint32_t RVTRIM = (4 << 24);  ///< Regulated Voltage Trim
        constexpr uint32_t RVEN = (1U << 31);  ///< Regulated Voltage Enable
    }

    /// AR Register bits
    namespace ar_bits {
        constexpr uint32_t BRATE = (3 << 0);  ///< Blink-rate configuration
        constexpr uint32_t BMODE = (1U << 3);  ///< Blink mode
        constexpr uint32_t BLANK = (1U << 5);  ///< Blank display mode
        constexpr uint32_t ALT = (1U << 6);  ///< Alternate display mode
        constexpr uint32_t BLINK = (1U << 7);  ///< Blink command
    }

    /// FDCR Register bits
    namespace fdcr_bits {
        constexpr uint32_t FDPINID = (6 << 0);  ///< Fault Detect Pin ID
        constexpr uint32_t FDBPEN = (1U << 6);  ///< Fault Detect Back Plane Enable
        constexpr uint32_t FDEN = (1U << 7);  ///< Fault Detect Enable
        constexpr uint32_t FDSWW = (3 << 9);  ///< Fault Detect Sample Window Width
        constexpr uint32_t FDPRS = (3 << 12);  ///< Fault Detect Clock Prescaler
    }

    /// FDSR Register bits
    namespace fdsr_bits {
        constexpr uint32_t FDCNT = (8 << 0);  ///< Fault Detect Counter
        constexpr uint32_t FDCF = (1U << 15);  ///< Fault Detection Complete Flag
    }

    /// PEN Register bits
    namespace pen_bits {
        constexpr uint32_t PEN = (32 << 0);  ///< LCD Pin Enable
    }

    /// BPEN Register bits
    namespace bpen_bits {
        constexpr uint32_t BPEN = (32 << 0);  ///< Back Plane Enable
    }

    /// WF3TO0 Register bits
    namespace wf3to0_bits {
        constexpr uint32_t WF0 = (8 << 0);  ///< Controls segments or phases connected to LCD_P0 as described above for WF3.
        constexpr uint32_t WF1 = (8 << 8);  ///< Controls segments or phases connected to LCD_P1 as described above for WF3.
        constexpr uint32_t WF2 = (8 << 16);  ///< Controls segments or phases connected to LCD_P2 as described above for WF3.
        constexpr uint32_t WF3 = (8 << 24);  ///< Segment-on front plane operation - Each bit turns on or off the segments associated with LCD_P3 in the following pattern: HGFEDCBA (most significant bit controls segment H and least significant bit controls segment A)
    }

    /// WF0 Register bits
    namespace wf0_bits {
        constexpr uint32_t BPALCD0 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD0 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD0 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD0 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD0 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD0 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD0 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD0 = (1U << 7);  ///< no description available
    }

    /// WF1 Register bits
    namespace wf1_bits {
        constexpr uint32_t BPALCD1 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD1 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD1 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD1 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD1 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD1 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD1 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD1 = (1U << 7);  ///< no description available
    }

    /// WF2 Register bits
    namespace wf2_bits {
        constexpr uint32_t BPALCD2 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD2 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD2 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD2 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD2 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD2 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD2 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD2 = (1U << 7);  ///< no description available
    }

    /// WF3 Register bits
    namespace wf3_bits {
        constexpr uint32_t BPALCD3 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD3 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD3 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD3 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD3 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD3 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD3 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD3 = (1U << 7);  ///< no description available
    }

    /// WF7TO4 Register bits
    namespace wf7to4_bits {
        constexpr uint32_t WF4 = (8 << 0);  ///< Controls segments or phases connected to LCD_P4 as described above for WF3TO0[WF3].
        constexpr uint32_t WF5 = (8 << 8);  ///< Controls segments or phases connected to LCD_P5 as described above for WF3TO0[WF3].
        constexpr uint32_t WF6 = (8 << 16);  ///< Controls segments or phases connected to LCD_P6 as described above for WF3TO0[WF3].
        constexpr uint32_t WF7 = (8 << 24);  ///< Controls segments or phases connected to LCD_P7 as described above for WF3TO0[WF3].
    }

    /// WF4 Register bits
    namespace wf4_bits {
        constexpr uint32_t BPALCD4 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD4 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD4 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD4 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD4 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD4 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD4 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD4 = (1U << 7);  ///< no description available
    }

    /// WF5 Register bits
    namespace wf5_bits {
        constexpr uint32_t BPALCD5 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD5 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD5 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD5 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD5 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD5 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD5 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD5 = (1U << 7);  ///< no description available
    }

    /// WF6 Register bits
    namespace wf6_bits {
        constexpr uint32_t BPALCD6 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD6 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD6 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD6 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD6 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD6 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD6 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD6 = (1U << 7);  ///< no description available
    }

    /// WF7 Register bits
    namespace wf7_bits {
        constexpr uint32_t BPALCD7 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD7 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD7 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD7 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD7 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD7 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD7 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD7 = (1U << 7);  ///< no description available
    }

    /// WF11TO8 Register bits
    namespace wf11to8_bits {
        constexpr uint32_t WF8 = (8 << 0);  ///< Controls segments or phases connected to LCD_P8 as described above for WF3TO0[WF3].
        constexpr uint32_t WF9 = (8 << 8);  ///< Controls segments or phases connected to LCD_P9 as described above for WF3TO0[WF3].
        constexpr uint32_t WF10 = (8 << 16);  ///< Controls segments or phases connected to LCD_P10 as described above for WF3TO0[WF3].
        constexpr uint32_t WF11 = (8 << 24);  ///< Controls segments or phases connected to LCD_P11 as described above for WF3TO0[WF3].
    }

    /// WF8 Register bits
    namespace wf8_bits {
        constexpr uint32_t BPALCD8 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD8 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD8 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD8 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD8 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD8 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD8 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD8 = (1U << 7);  ///< no description available
    }

    /// WF9 Register bits
    namespace wf9_bits {
        constexpr uint32_t BPALCD9 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD9 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD9 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD9 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD9 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD9 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD9 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD9 = (1U << 7);  ///< no description available
    }

    /// WF10 Register bits
    namespace wf10_bits {
        constexpr uint32_t BPALCD10 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD10 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD10 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD10 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD10 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD10 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD10 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD10 = (1U << 7);  ///< no description available
    }

    /// WF11 Register bits
    namespace wf11_bits {
        constexpr uint32_t BPALCD11 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD11 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD11 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD11 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD11 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD11 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD11 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD11 = (1U << 7);  ///< no description available
    }

    /// WF15TO12 Register bits
    namespace wf15to12_bits {
        constexpr uint32_t WF12 = (8 << 0);  ///< Controls segments or phases connected to LCD_P12 as described above for WF3TO0[WF3].
        constexpr uint32_t WF13 = (8 << 8);  ///< Controls segments or phases connected to LCD_P13 as described above for WF3TO0[WF3].
        constexpr uint32_t WF14 = (8 << 16);  ///< Controls segments or phases connected to LCD_P14 as described above for WF3TO0[WF3].
        constexpr uint32_t WF15 = (8 << 24);  ///< Controls segments or phases connected to LCD_P15 as described above for WF3TO0[WF3].
    }

    /// WF12 Register bits
    namespace wf12_bits {
        constexpr uint32_t BPALCD12 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD12 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD12 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD12 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD12 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD12 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD12 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD12 = (1U << 7);  ///< no description available
    }

    /// WF13 Register bits
    namespace wf13_bits {
        constexpr uint32_t BPALCD13 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD13 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD13 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD13 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD13 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD13 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD13 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD13 = (1U << 7);  ///< no description available
    }

    /// WF14 Register bits
    namespace wf14_bits {
        constexpr uint32_t BPALCD14 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD14 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD14 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD14 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD14 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD14 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD14 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD14 = (1U << 7);  ///< no description available
    }

    /// WF15 Register bits
    namespace wf15_bits {
        constexpr uint32_t BPALCD15 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD15 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD15 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD15 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD15 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD15 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD15 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD15 = (1U << 7);  ///< no description available
    }

    /// WF19TO16 Register bits
    namespace wf19to16_bits {
        constexpr uint32_t WF16 = (8 << 0);  ///< Controls segments or phases connected to LCD_P16 as described above for WF3TO0[WF3].
        constexpr uint32_t WF17 = (8 << 8);  ///< Controls segments or phases connected to LCD_P17 as described above for WF3TO0[WF3].
        constexpr uint32_t WF18 = (8 << 16);  ///< Controls segments or phases connected to LCD_P18 as described above for WF3TO0[WF3].
        constexpr uint32_t WF19 = (8 << 24);  ///< Controls segments or phases connected to LCD_P19 as described above for WF3TO0[WF3].
    }

    /// WF16 Register bits
    namespace wf16_bits {
        constexpr uint32_t BPALCD16 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD16 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD16 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD16 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD16 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD16 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD16 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD16 = (1U << 7);  ///< no description available
    }

    /// WF17 Register bits
    namespace wf17_bits {
        constexpr uint32_t BPALCD17 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD17 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD17 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD17 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD17 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD17 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD17 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD17 = (1U << 7);  ///< no description available
    }

    /// WF18 Register bits
    namespace wf18_bits {
        constexpr uint32_t BPALCD18 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD18 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD18 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD18 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD18 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD18 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD18 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD18 = (1U << 7);  ///< no description available
    }

    /// WF19 Register bits
    namespace wf19_bits {
        constexpr uint32_t BPALCD19 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD19 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD19 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD19 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD19 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD19 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD19 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD19 = (1U << 7);  ///< no description available
    }

    /// WF23TO20 Register bits
    namespace wf23to20_bits {
        constexpr uint32_t WF20 = (8 << 0);  ///< Controls segments or phases connected to LCD_P20 as described above for WF3TO0[WF3].
        constexpr uint32_t WF21 = (8 << 8);  ///< Controls segments or phases connected to LCD_P21 as described above for WF3TO0[WF3].
        constexpr uint32_t WF22 = (8 << 16);  ///< Controls segments or phases connected to LCD_P22 as described above for WF3TO0[WF3].
        constexpr uint32_t WF23 = (8 << 24);  ///< Controls segments or phases connected to LCD_P23 as described above for WF3TO0[WF3].
    }

    /// WF20 Register bits
    namespace wf20_bits {
        constexpr uint32_t BPALCD20 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD20 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD20 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD20 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD20 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD20 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD20 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD20 = (1U << 7);  ///< no description available
    }

    /// WF21 Register bits
    namespace wf21_bits {
        constexpr uint32_t BPALCD21 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD21 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD21 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD21 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD21 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD21 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD21 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD21 = (1U << 7);  ///< no description available
    }

    /// WF22 Register bits
    namespace wf22_bits {
        constexpr uint32_t BPALCD22 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD22 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD22 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD22 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD22 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD22 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD22 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD22 = (1U << 7);  ///< no description available
    }

    /// WF23 Register bits
    namespace wf23_bits {
        constexpr uint32_t BPALCD23 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD23 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD23 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD23 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD23 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD23 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD23 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD23 = (1U << 7);  ///< no description available
    }

    /// WF27TO24 Register bits
    namespace wf27to24_bits {
        constexpr uint32_t WF24 = (8 << 0);  ///< Controls segments or phases connected to LCD_P24 as described above for WF3TO0[WF3].
        constexpr uint32_t WF25 = (8 << 8);  ///< Controls segments or phases connected to LCD_P25 as described above for WF3TO0[WF3].
        constexpr uint32_t WF26 = (8 << 16);  ///< Controls segments or phases connected to LCD_P26 as described above for WF3TO0[WF3].
        constexpr uint32_t WF27 = (8 << 24);  ///< Controls segments or phases connected to LCD_P27 as described above for WF3TO0[WF3].
    }

    /// WF24 Register bits
    namespace wf24_bits {
        constexpr uint32_t BPALCD24 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD24 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD24 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD24 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD24 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD24 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD24 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD24 = (1U << 7);  ///< no description available
    }

    /// WF25 Register bits
    namespace wf25_bits {
        constexpr uint32_t BPALCD25 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD25 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD25 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD25 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD25 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD25 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD25 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD25 = (1U << 7);  ///< no description available
    }

    /// WF26 Register bits
    namespace wf26_bits {
        constexpr uint32_t BPALCD26 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD26 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD26 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD26 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD26 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD26 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD26 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD26 = (1U << 7);  ///< no description available
    }

    /// WF27 Register bits
    namespace wf27_bits {
        constexpr uint32_t BPALCD27 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD27 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD27 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD27 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD27 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD27 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD27 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD27 = (1U << 7);  ///< no description available
    }

    /// WF31TO28 Register bits
    namespace wf31to28_bits {
        constexpr uint32_t WF28 = (8 << 0);  ///< Controls segments or phases connected to LCD_P28 as described above for WF3TO0[WF3].
        constexpr uint32_t WF29 = (8 << 8);  ///< Controls segments or phases connected to LCD_P29 as described above for WF3TO0[WF3].
        constexpr uint32_t WF30 = (8 << 16);  ///< Controls segments or phases connected to LCD_P30 as described above for WF3TO0[WF3].
        constexpr uint32_t WF31 = (8 << 24);  ///< Controls segments or phases connected to LCD_P31 as described above for WF3TO0[WF3].
    }

    /// WF28 Register bits
    namespace wf28_bits {
        constexpr uint32_t BPALCD28 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD28 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD28 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD28 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD28 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD28 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD28 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD28 = (1U << 7);  ///< no description available
    }

    /// WF29 Register bits
    namespace wf29_bits {
        constexpr uint32_t BPALCD29 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD29 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD29 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD29 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD29 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD29 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD29 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD29 = (1U << 7);  ///< no description available
    }

    /// WF30 Register bits
    namespace wf30_bits {
        constexpr uint32_t BPALCD30 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD30 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD30 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD30 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD30 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD30 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD30 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD30 = (1U << 7);  ///< no description available
    }

    /// WF31 Register bits
    namespace wf31_bits {
        constexpr uint32_t BPALCD31 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD31 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD31 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD31 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD31 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD31 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD31 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD31 = (1U << 7);  ///< no description available
    }

    /// WF35TO32 Register bits
    namespace wf35to32_bits {
        constexpr uint32_t WF32 = (8 << 0);  ///< Controls segments or phases connected to LCD_P32 as described above for WF3TO0[WF3].
        constexpr uint32_t WF33 = (8 << 8);  ///< Controls segments or phases connected to LCD_P33 as described above for WF3TO0[WF3].
        constexpr uint32_t WF34 = (8 << 16);  ///< Controls segments or phases connected to LCD_P34 as described above for WF3TO0[WF3].
        constexpr uint32_t WF35 = (8 << 24);  ///< Controls segments or phases connected to LCD_P35 as described above for WF3TO0[WF3].
    }

    /// WF32 Register bits
    namespace wf32_bits {
        constexpr uint32_t BPALCD32 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD32 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD32 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD32 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD32 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD32 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD32 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD32 = (1U << 7);  ///< no description available
    }

    /// WF33 Register bits
    namespace wf33_bits {
        constexpr uint32_t BPALCD33 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD33 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD33 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD33 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD33 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD33 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD33 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD33 = (1U << 7);  ///< no description available
    }

    /// WF34 Register bits
    namespace wf34_bits {
        constexpr uint32_t BPALCD34 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD34 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD34 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD34 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD34 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD34 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD34 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD34 = (1U << 7);  ///< no description available
    }

    /// WF35 Register bits
    namespace wf35_bits {
        constexpr uint32_t BPALCD35 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD35 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD35 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD35 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD35 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD35 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD35 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD35 = (1U << 7);  ///< no description available
    }

    /// WF39TO36 Register bits
    namespace wf39to36_bits {
        constexpr uint32_t WF36 = (8 << 0);  ///< Controls segments or phases connected to LCD_P36 as described above for WF3TO0[WF3].
        constexpr uint32_t WF37 = (8 << 8);  ///< Controls segments or phases connected to LCD_P37 as described above for WF3TO0[WF3].
        constexpr uint32_t WF38 = (8 << 16);  ///< Controls segments or phases connected to LCD_P38 as described above for WF3TO0[WF3].
        constexpr uint32_t WF39 = (8 << 24);  ///< Controls segments or phases connected to LCD_P39 as described above for WF3TO0[WF3].
    }

    /// WF36 Register bits
    namespace wf36_bits {
        constexpr uint32_t BPALCD36 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD36 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD36 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD36 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD36 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD36 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD36 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD36 = (1U << 7);  ///< no description available
    }

    /// WF37 Register bits
    namespace wf37_bits {
        constexpr uint32_t BPALCD37 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD37 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD37 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD37 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD37 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD37 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD37 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD37 = (1U << 7);  ///< no description available
    }

    /// WF38 Register bits
    namespace wf38_bits {
        constexpr uint32_t BPALCD38 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD38 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD38 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD38 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD38 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD38 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD38 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD38 = (1U << 7);  ///< no description available
    }

    /// WF39 Register bits
    namespace wf39_bits {
        constexpr uint32_t BPALCD39 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD39 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD39 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD39 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD39 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD39 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD39 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD39 = (1U << 7);  ///< no description available
    }

    /// WF43TO40 Register bits
    namespace wf43to40_bits {
        constexpr uint32_t WF40 = (8 << 0);  ///< Controls segments or phases connected to LCD_P40 as described above for WF3TO0[WF3].
        constexpr uint32_t WF41 = (8 << 8);  ///< Controls segments or phases connected to LCD_P41 as described above for WF3TO0[WF3].
        constexpr uint32_t WF42 = (8 << 16);  ///< Controls segments or phases connected to LCD_P42 as described above for WF3TO0[WF3].
        constexpr uint32_t WF43 = (8 << 24);  ///< Controls segments or phases connected to LCD_P43 as described above for WF3TO0[WF3].
    }

    /// WF40 Register bits
    namespace wf40_bits {
        constexpr uint32_t BPALCD40 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD40 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD40 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD40 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD40 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD40 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD40 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD40 = (1U << 7);  ///< no description available
    }

    /// WF41 Register bits
    namespace wf41_bits {
        constexpr uint32_t BPALCD41 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD41 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD41 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD41 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD41 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD41 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD41 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD41 = (1U << 7);  ///< no description available
    }

    /// WF42 Register bits
    namespace wf42_bits {
        constexpr uint32_t BPALCD42 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD42 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD42 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD42 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD42 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD42 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD42 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD42 = (1U << 7);  ///< no description available
    }

    /// WF43 Register bits
    namespace wf43_bits {
        constexpr uint32_t BPALCD43 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD43 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD43 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD43 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD43 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD43 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD43 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD43 = (1U << 7);  ///< no description available
    }

    /// WF47TO44 Register bits
    namespace wf47to44_bits {
        constexpr uint32_t WF44 = (8 << 0);  ///< Controls segments or phases connected to LCD_P44 as described above for WF3TO0[WF3].
        constexpr uint32_t WF45 = (8 << 8);  ///< Controls segments or phases connected to LCD_P45 as described above for WF3TO0[WF3].
        constexpr uint32_t WF46 = (8 << 16);  ///< Controls segments or phases connected to LCD_P46 as described above for WF3TO0[WF3].
        constexpr uint32_t WF47 = (8 << 24);  ///< Controls segments or phases connected to LCD_P47 as described above for WF3TO0[WF3].
    }

    /// WF44 Register bits
    namespace wf44_bits {
        constexpr uint32_t BPALCD44 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD44 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD44 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD44 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD44 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD44 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD44 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD44 = (1U << 7);  ///< no description available
    }

    /// WF45 Register bits
    namespace wf45_bits {
        constexpr uint32_t BPALCD45 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD45 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD45 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD45 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD45 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD45 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD45 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD45 = (1U << 7);  ///< no description available
    }

    /// WF46 Register bits
    namespace wf46_bits {
        constexpr uint32_t BPALCD46 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD46 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD46 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD46 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD46 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD46 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD46 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD46 = (1U << 7);  ///< no description available
    }

    /// WF47 Register bits
    namespace wf47_bits {
        constexpr uint32_t BPALCD47 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD47 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD47 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD47 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD47 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD47 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD47 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD47 = (1U << 7);  ///< no description available
    }

    /// WF51TO48 Register bits
    namespace wf51to48_bits {
        constexpr uint32_t WF48 = (8 << 0);  ///< Controls segments or phases connected to LCD_P48 as described above for WF3TO0[WF3].
        constexpr uint32_t WF49 = (8 << 8);  ///< Controls segments or phases connected to LCD_P49 as described above for WF3TO0[WF3].
        constexpr uint32_t WF50 = (8 << 16);  ///< Controls segments or phases connected to LCD_P50 as described above for WF3TO0[WF3].
        constexpr uint32_t WF51 = (8 << 24);  ///< Controls segments or phases connected to LCD_P51 as described above for WF3TO0[WF3].
    }

    /// WF48 Register bits
    namespace wf48_bits {
        constexpr uint32_t BPALCD48 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD48 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD48 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD48 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD48 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD48 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD48 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD48 = (1U << 7);  ///< no description available
    }

    /// WF49 Register bits
    namespace wf49_bits {
        constexpr uint32_t BPALCD49 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD49 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD49 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD49 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD49 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD49 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD49 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD49 = (1U << 7);  ///< no description available
    }

    /// WF50 Register bits
    namespace wf50_bits {
        constexpr uint32_t BPALCD50 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD50 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD50 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD50 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD50 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD50 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD50 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD50 = (1U << 7);  ///< no description available
    }

    /// WF51 Register bits
    namespace wf51_bits {
        constexpr uint32_t BPALCD51 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD51 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD51 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD51 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD51 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD51 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD51 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD51 = (1U << 7);  ///< no description available
    }

    /// WF55TO52 Register bits
    namespace wf55to52_bits {
        constexpr uint32_t WF52 = (8 << 0);  ///< Controls segments or phases connected to LCD_P52 as described above for WF3TO0[WF3].
        constexpr uint32_t WF53 = (8 << 8);  ///< Controls segments or phases connected to LCD_P53 as described above for WF3TO0[WF3].
        constexpr uint32_t WF54 = (8 << 16);  ///< Controls segments or phases connected to LCD_P54 as described above for WF3TO0[WF3].
        constexpr uint32_t WF55 = (8 << 24);  ///< Controls segments or phases connected to LCD_P55 as described above for WF3TO0[WF3].
    }

    /// WF52 Register bits
    namespace wf52_bits {
        constexpr uint32_t BPALCD52 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD52 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD52 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD52 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD52 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD52 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD52 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD52 = (1U << 7);  ///< no description available
    }

    /// WF53 Register bits
    namespace wf53_bits {
        constexpr uint32_t BPALCD53 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD53 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD53 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD53 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD53 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD53 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD53 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD53 = (1U << 7);  ///< no description available
    }

    /// WF54 Register bits
    namespace wf54_bits {
        constexpr uint32_t BPALCD54 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD54 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD54 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD54 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD54 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD54 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD54 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD54 = (1U << 7);  ///< no description available
    }

    /// WF55 Register bits
    namespace wf55_bits {
        constexpr uint32_t BPALCD55 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD55 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD55 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD55 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD55 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD55 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD55 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD55 = (1U << 7);  ///< no description available
    }

    /// WF59TO56 Register bits
    namespace wf59to56_bits {
        constexpr uint32_t WF56 = (8 << 0);  ///< Controls segments or phases connected to LCD_P56 as described above for WF3TO0[WF3].
        constexpr uint32_t WF57 = (8 << 8);  ///< Controls segments or phases connected to LCD_P57 as described above for WF3TO0[WF3].
        constexpr uint32_t WF58 = (8 << 16);  ///< Controls segments or phases connected to LCD_P58 as described above for WF3TO0[WF3].
        constexpr uint32_t WF59 = (8 << 24);  ///< Controls segments or phases connected to LCD_P59 as described above for WF3TO0[WF3].
    }

    /// WF56 Register bits
    namespace wf56_bits {
        constexpr uint32_t BPALCD56 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD56 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD56 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD56 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD56 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD56 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD56 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD56 = (1U << 7);  ///< no description available
    }

    /// WF57 Register bits
    namespace wf57_bits {
        constexpr uint32_t BPALCD57 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD57 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD57 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD57 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD57 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD57 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD57 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD57 = (1U << 7);  ///< no description available
    }

    /// WF58 Register bits
    namespace wf58_bits {
        constexpr uint32_t BPALCD58 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD58 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD58 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD58 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD58 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD58 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD58 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD58 = (1U << 7);  ///< no description available
    }

    /// WF59 Register bits
    namespace wf59_bits {
        constexpr uint32_t BPALCD59 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD59 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD59 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD59 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD59 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD59 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD59 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD59 = (1U << 7);  ///< no description available
    }

    /// WF63TO60 Register bits
    namespace wf63to60_bits {
        constexpr uint32_t WF60 = (8 << 0);  ///< Controls segments or phases connected to LCD_P60 as described above for WF3TO0[WF3].
        constexpr uint32_t WF61 = (8 << 8);  ///< Controls segments or phases connected to LCD_P61 as described above for WF3TO0[WF3].
        constexpr uint32_t WF62 = (8 << 16);  ///< Controls segments or phases connected to LCD_P62 as described above for WF3TO0[WF3].
        constexpr uint32_t WF63 = (8 << 24);  ///< Controls segments or phases connected to LCD_P63 as described above for WF3TO0[WF3].
    }

    /// WF60 Register bits
    namespace wf60_bits {
        constexpr uint32_t BPALCD60 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD60 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD60 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD60 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD60 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD60 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD60 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD60 = (1U << 7);  ///< no description available
    }

    /// WF61 Register bits
    namespace wf61_bits {
        constexpr uint32_t BPALCD61 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD61 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD61 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD61 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD61 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD61 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD61 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD61 = (1U << 7);  ///< no description available
    }

    /// WF62 Register bits
    namespace wf62_bits {
        constexpr uint32_t BPALCD62 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD62 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD62 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD62 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD62 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD62 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD62 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD62 = (1U << 7);  ///< no description available
    }

    /// WF63 Register bits
    namespace wf63_bits {
        constexpr uint32_t BPALCD63 = (1U << 0);  ///< no description available
        constexpr uint32_t BPBLCD63 = (1U << 1);  ///< no description available
        constexpr uint32_t BPCLCD63 = (1U << 2);  ///< no description available
        constexpr uint32_t BPDLCD63 = (1U << 3);  ///< no description available
        constexpr uint32_t BPELCD63 = (1U << 4);  ///< no description available
        constexpr uint32_t BPFLCD63 = (1U << 5);  ///< no description available
        constexpr uint32_t BPGLCD63 = (1U << 6);  ///< no description available
        constexpr uint32_t BPHLCD63 = (1U << 7);  ///< no description available
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x40054000;
    constexpr uint32_t LPUART1_BASE = 0x40055000;
    constexpr uint32_t UART2_BASE = 0x4006C000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BAUD;  ///< Offset: 0x00 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x04 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x0C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x10 - LPUART Match Address Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* UART2 = reinterpret_cast<Registers*>(UART2_BASE);

    // Bit definitions
    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Over Sampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

}

// ============================================================================
// FLEXIO Peripheral
// ============================================================================

namespace flexio {
    /// Base addresses
    constexpr uint32_t FLEXIO_BASE = 0x4005F000;

    /// FLEXIO Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTCTL;  ///< Offset: 0x80 - Shifter Control N Register (renamed from SHIFTCTL)
        volatile uint32_t SHIFTCFG;  ///< Offset: 0x100 - Shifter Configuration N Register (renamed from SHIFTCFG)
        volatile uint32_t SHIFTBUF;  ///< Offset: 0x200 - Shifter Buffer N Register (renamed from SHIFTBUF)
        volatile uint32_t SHIFTBUFBIS;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register (renamed from SHIFTBUFBIS)
        volatile uint32_t SHIFTBUFBYS;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register (renamed from SHIFTBUFBYS)
        volatile uint32_t SHIFTBUFBBS;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register (renamed from SHIFTBUFBBS)
        volatile uint32_t TIMCTL;  ///< Offset: 0x400 - Timer Control N Register (renamed from TIMCTL)
        volatile uint32_t TIMCFG;  ///< Offset: 0x480 - Timer Configuration N Register (renamed from TIMCFG)
        volatile uint32_t TIMCMP;  ///< Offset: 0x500 - Timer Compare N Register (renamed from TIMCMP)
    };

    /// Peripheral instances
    inline Registers* FLEXIO = reinterpret_cast<Registers*>(FLEXIO_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (4 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (4 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (4 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (4 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (4 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (4 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (4 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTCTL Register bits
    namespace shiftctl_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (2 << 24);  ///< Timer Select
    }

    /// SHIFTCFG Register bits
    namespace shiftcfg_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
    }

    /// SHIFTBUF Register bits
    namespace shiftbuf_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS Register bits
    namespace shiftbufbis_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS Register bits
    namespace shiftbufbys_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS Register bits
    namespace shiftbufbbs_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL Register bits
    namespace timctl_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (3 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (4 << 24);  ///< Trigger Select
    }

    /// TIMCFG Register bits
    namespace timcfg_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP Register bits
    namespace timcmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control Register 2
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t HCTRIM;  ///< Offset: 0x14 - MCG High-frequency IRC Coarse Trim Register
        volatile uint32_t HTTRIM;  ///< Offset: 0x15 - MCG High-frequency IRC Tempco (Temperature Coefficient)...
        volatile uint32_t HFTRIM;  ///< Offset: 0x16 - MCG High-frequency IRC Fine Trim Register
        volatile uint32_t MC;  ///< Offset: 0x18 - MCG Miscellaneous Control Register
        volatile uint32_t LTRIMRNG;  ///< Offset: 0x19 - MCG Low-frequency IRC Trim Range Register
        volatile uint32_t LFTRIM;  ///< Offset: 0x1A - MCG Low-frequency IRC8M Trim Register
        volatile uint32_t LSTRIM;  ///< Offset: 0x1B - MCG Low-frequency IRC2M Trim Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Low-frequency Internal Reference Clock Select
        constexpr uint32_t EREFS0 = (1U << 2);  ///< External Clock Source Select
        constexpr uint32_t HGO0 = (1U << 3);  ///< Crystal Oscillator Operation Mode Select
        constexpr uint32_t RANGE0 = (2 << 4);  ///< External Clock Source Frequency Range Select
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization Status
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Low-frequency Internal Reference Clock Divider
    }

    /// HCTRIM Register bits
    namespace hctrim_bits {
        constexpr uint32_t COARSE_TRIM = (6 << 0);  ///< High-frequency IRC Coarse Trim
    }

    /// HTTRIM Register bits
    namespace httrim_bits {
        constexpr uint32_t TEMPCO_TRIM = (5 << 0);  ///< High-frequency IRC Tempco Trim
    }

    /// HFTRIM Register bits
    namespace hftrim_bits {
        constexpr uint32_t FINE_TRIM = (7 << 0);  ///< High-frequency IRC Fine Trim
    }

    /// MC Register bits
    namespace mc_bits {
        constexpr uint32_t LIRC_DIV2 = (3 << 0);  ///< Second Low-frequency Internal Reference Clock Divider
        constexpr uint32_t HIRCEN = (1U << 7);  ///< High-frequency IRC Enable
    }

    /// LTRIMRNG Register bits
    namespace ltrimrng_bits {
        constexpr uint32_t STRIMRNG = (2 << 0);  ///< LIRC Slow TRIM (2 MHz) Range
        constexpr uint32_t FTRIMRNG = (2 << 2);  ///< LIRC Fast TRIM (8 MHz) Range
    }

    /// LFTRIM Register bits
    namespace lftrim_bits {
        constexpr uint32_t LIRC_FTRIM = (7 << 0);  ///< LIRC8M TRIM
    }

    /// LSTRIM Register bits
    namespace lstrim_bits {
        constexpr uint32_t LIRC_STRIM = (7 << 0);  ///< LIRC2M TRIM
    }

}

// ============================================================================
// OSC0 Peripheral
// ============================================================================

namespace osc0 {
    /// Base addresses
    constexpr uint32_t OSC0_BASE = 0x40065000;

    /// OSC0 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
    };

    /// Peripheral instances
    inline Registers* OSC0 = reinterpret_cast<Registers*>(OSC0_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
        volatile uint32_t S2;  ///< Offset: 0x0C - I2C Status register 2
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t EMPTY = (1U << 0);  ///< Empty flag
        constexpr uint32_t ERROR = (1U << 1);  ///< Error flag
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t PERID;  ///< Offset: 0x00 - Peripheral ID register
        volatile uint32_t IDCOMP;  ///< Offset: 0x04 - Peripheral ID Complement register
        volatile uint32_t REV;  ///< Offset: 0x08 - Peripheral Revision register
        volatile uint32_t ADDINFO;  ///< Offset: 0x0C - Peripheral Additional Info register
        volatile uint32_t OTGCTL;  ///< Offset: 0x1C - OTG Control register
        volatile uint32_t ISTAT;  ///< Offset: 0x80 - Interrupt Status register
        volatile uint32_t INTEN;  ///< Offset: 0x84 - Interrupt Enable register
        volatile uint32_t ERRSTAT;  ///< Offset: 0x88 - Error Interrupt Status register
        volatile uint32_t ERREN;  ///< Offset: 0x8C - Error Interrupt Enable register
        volatile uint32_t STAT;  ///< Offset: 0x90 - Status register
        volatile uint32_t CTL;  ///< Offset: 0x94 - Control register
        volatile uint32_t ADDR;  ///< Offset: 0x98 - Address register
        volatile uint32_t BDTPAGE1;  ///< Offset: 0x9C - BDT Page register 1
        volatile uint32_t FRMNUML;  ///< Offset: 0xA0 - Frame Number register Low
        volatile uint32_t FRMNUMH;  ///< Offset: 0xA4 - Frame Number register High
        volatile uint32_t BDTPAGE2;  ///< Offset: 0xB0 - BDT Page Register 2
        volatile uint32_t BDTPAGE3;  ///< Offset: 0xB4 - BDT Page Register 3
        volatile uint32_t ENDPT;  ///< Offset: 0xC0 - Endpoint Control register (renamed from ENDPT)
        volatile uint32_t USBCTRL;  ///< Offset: 0x100 - USB Control register
        volatile uint32_t OBSERVE;  ///< Offset: 0x104 - USB OTG Observe register
        volatile uint32_t CONTROL;  ///< Offset: 0x108 - USB OTG Control register
        volatile uint32_t USBTRC0;  ///< Offset: 0x10C - USB Transceiver Control register 0
        volatile uint32_t USBFRMADJUST;  ///< Offset: 0x114 - Frame Adjust Register
        volatile uint32_t CLK_RECOVER_CTRL;  ///< Offset: 0x140 - USB Clock recovery control
        volatile uint32_t CLK_RECOVER_IRC_EN;  ///< Offset: 0x144 - IRC48M oscillator enable register
        volatile uint32_t CLK_RECOVER_INT_EN;  ///< Offset: 0x154 - Clock recovery combined interrupt enable
        volatile uint32_t CLK_RECOVER_INT_STATUS;  ///< Offset: 0x15C - Clock recovery separated interrupt status
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// PERID Register bits
    namespace perid_bits {
        constexpr uint32_t ID = (6 << 0);  ///< Peripheral Identification
    }

    /// IDCOMP Register bits
    namespace idcomp_bits {
        constexpr uint32_t NID = (6 << 0);  ///< Ones' complement of PERID[ID]. bits.
    }

    /// REV Register bits
    namespace rev_bits {
        constexpr uint32_t REV = (8 << 0);  ///< Revision
    }

    /// ADDINFO Register bits
    namespace addinfo_bits {
        constexpr uint32_t IEHOST = (1U << 0);  ///< This bit is set if host mode is enabled.
    }

    /// OTGCTL Register bits
    namespace otgctl_bits {
        constexpr uint32_t DPHIGH = (1U << 7);  ///< D+ Data Line pullup resistor enable
    }

    /// ISTAT Register bits
    namespace istat_bits {
        constexpr uint32_t USBRST = (1U << 0);  ///< This bit is set when the USB Module has decoded a valid USB reset
        constexpr uint32_t ERROR = (1U << 1);  ///< This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
        constexpr uint32_t SOFTOK = (1U << 2);  ///< This bit is set when the USB Module receives a Start Of Frame (SOF) token.
        constexpr uint32_t TOKDNE = (1U << 3);  ///< This bit is set when the current token being processed has completed
        constexpr uint32_t SLEEP = (1U << 4);  ///< This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
        constexpr uint32_t RESUME = (1U << 5);  ///< This bit is set when a K-state is observed on the DP/DM signals for 2
        constexpr uint32_t STALL = (1U << 7);  ///< Stall Interrupt
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t USBRSTEN = (1U << 0);  ///< USBRST Interrupt Enable
        constexpr uint32_t ERROREN = (1U << 1);  ///< ERROR Interrupt Enable
        constexpr uint32_t SOFTOKEN = (1U << 2);  ///< SOFTOK Interrupt Enable
        constexpr uint32_t TOKDNEEN = (1U << 3);  ///< TOKDNE Interrupt Enable
        constexpr uint32_t SLEEPEN = (1U << 4);  ///< SLEEP Interrupt Enable
        constexpr uint32_t RESUMEEN = (1U << 5);  ///< RESUME Interrupt Enable
        constexpr uint32_t STALLEN = (1U << 7);  ///< STALL Interrupt Enable
    }

    /// ERRSTAT Register bits
    namespace errstat_bits {
        constexpr uint32_t PIDERR = (1U << 0);  ///< This bit is set when the PID check field fails.
        constexpr uint32_t CRC5 = (1U << 1);  ///< This error interrupt has two functions
        constexpr uint32_t CRC16 = (1U << 2);  ///< This bit is set when a data packet is rejected due to a CRC16 error.
        constexpr uint32_t DFN8 = (1U << 3);  ///< This bit is set if the data field received was not 8 bits in length
        constexpr uint32_t BTOERR = (1U << 4);  ///< This bit is set when a bus turnaround timeout error occurs
        constexpr uint32_t DMAERR = (1U << 5);  ///< This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
        constexpr uint32_t BTSERR = (1U << 7);  ///< This bit is set when a bit stuff error is detected
    }

    /// ERREN Register bits
    namespace erren_bits {
        constexpr uint32_t PIDERREN = (1U << 0);  ///< PIDERR Interrupt Enable
        constexpr uint32_t CRC5EOFEN = (1U << 1);  ///< CRC5/EOF Interrupt Enable
        constexpr uint32_t CRC16EN = (1U << 2);  ///< CRC16 Interrupt Enable
        constexpr uint32_t DFN8EN = (1U << 3);  ///< DFN8 Interrupt Enable
        constexpr uint32_t BTOERREN = (1U << 4);  ///< BTOERR Interrupt Enable
        constexpr uint32_t DMAERREN = (1U << 5);  ///< DMAERR Interrupt Enable
        constexpr uint32_t BTSERREN = (1U << 7);  ///< BTSERR Interrupt Enable
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t ODD = (1U << 2);  ///< This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
        constexpr uint32_t TX = (1U << 3);  ///< Transmit Indicator
        constexpr uint32_t ENDP = (4 << 4);  ///< This four-bit field encodes the endpoint address that received or transmitted the previous token
    }

    /// CTL Register bits
    namespace ctl_bits {
        constexpr uint32_t USBENSOFEN = (1U << 0);  ///< USB Enable
        constexpr uint32_t ODDRST = (1U << 1);  ///< Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
        constexpr uint32_t TXSUSPENDTOKENBUSY = (1U << 5);  ///< In Target mode, TXD_SUSPEND is set when the SIE has disabled packet transmission and reception
        constexpr uint32_t SE0 = (1U << 6);  ///< Live USB Single Ended Zero signal
        constexpr uint32_t JSTATE = (1U << 7);  ///< Live USB differential receiver JSTATE signal
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (7 << 0);  ///< USB Address
    }

    /// BDTPAGE1 Register bits
    namespace bdtpage1_bits {
        constexpr uint32_t BDTBA = (7 << 1);  ///< Provides address bits 15 through 9 of the BDT base address.
    }

    /// FRMNUML Register bits
    namespace frmnuml_bits {
        constexpr uint32_t FRM = (8 << 0);  ///< This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// FRMNUMH Register bits
    namespace frmnumh_bits {
        constexpr uint32_t FRM = (3 << 0);  ///< This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// BDTPAGE2 Register bits
    namespace bdtpage2_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// BDTPAGE3 Register bits
    namespace bdtpage3_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// ENDPT Register bits
    namespace endpt_bits {
        constexpr uint32_t EPHSHK = (1U << 0);  ///< When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
        constexpr uint32_t EPSTALL = (1U << 1);  ///< When set this bit indicates that the endpoint is called
        constexpr uint32_t EPTXEN = (1U << 2);  ///< This bit, when set, enables the endpoint for TX transfers. See #aal353jj
        constexpr uint32_t EPRXEN = (1U << 3);  ///< This bit, when set, enables the endpoint for RX transfers. See #aal353jj
        constexpr uint32_t EPCTLDIS = (1U << 4);  ///< This bit, when set, disables control (SETUP) transfers
    }

    /// USBCTRL Register bits
    namespace usbctrl_bits {
        constexpr uint32_t PDE = (1U << 6);  ///< Enables the weak pulldowns on the USB transceiver.
        constexpr uint32_t SUSP = (1U << 7);  ///< Places the USB transceiver into the suspend state.
    }

    /// OBSERVE Register bits
    namespace observe_bits {
        constexpr uint32_t DMPD = (1U << 4);  ///< Provides observability of the D- Pulldown signal output from USB.
        constexpr uint32_t DPPD = (1U << 6);  ///< Provides observability of the D+ Pulldown signal output from USB.
        constexpr uint32_t DPPU = (1U << 7);  ///< Provides observability of the D+ Pullup signal output from USB .
    }

    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t DPPULLUPNONOTG = (1U << 4);  ///< Provides control of the DP Pullup in USB, if USB is configured in non-OTG device mode.
    }

    /// USBTRC0 Register bits
    namespace usbtrc0_bits {
        constexpr uint32_t USB_RESUME_INT = (1U << 0);  ///< USB Asynchronous Interrupt
        constexpr uint32_t SYNC_DET = (1U << 1);  ///< Synchronous USB Interrupt Detect
        constexpr uint32_t USB_CLK_RECOVERY_INT = (1U << 2);  ///< Combined USB Clock Recovery interrupt status
        constexpr uint32_t USBRESMEN = (1U << 5);  ///< Asynchronous Resume Interrupt Enable
        constexpr uint32_t USBRESET = (1U << 7);  ///< USB Reset
    }

    /// USBFRMADJUST Register bits
    namespace usbfrmadjust_bits {
        constexpr uint32_t ADJ = (8 << 0);  ///< Frame Adjustment
    }

    /// CLK_RECOVER_CTRL Register bits
    namespace clk_recover_ctrl_bits {
        constexpr uint32_t RESTART_IFRTRIM_EN = (1U << 5);  ///< Restart from IFR trim value
        constexpr uint32_t RESET_RESUME_ROUGH_EN = (1U << 6);  ///< Reset/resume to rough phase enable
        constexpr uint32_t CLOCK_RECOVER_EN = (1U << 7);  ///< Crystal-less USB enable
    }

    /// CLK_RECOVER_IRC_EN Register bits
    namespace clk_recover_irc_en_bits {
        constexpr uint32_t IRC_EN = (1U << 1);  ///< IRC48M enable
    }

    /// CLK_RECOVER_INT_EN Register bits
    namespace clk_recover_int_en_bits {
        constexpr uint32_t OVF_ERROR_EN = (1U << 4);  ///< Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.
    }

    /// CLK_RECOVER_INT_STATUS Register bits
    namespace clk_recover_int_status_bits {
        constexpr uint32_t OVF_ERROR = (1U << 4);  ///< Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
        constexpr uint32_t PSTM = (1U << 7);  ///< Pass Through Mode Enable
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x40076000;
    constexpr uint32_t SPI1_BASE = 0x40077000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t S;  ///< Offset: 0x00 - SPI Status Register
        volatile uint32_t BR;  ///< Offset: 0x01 - SPI Baud Rate Register
        volatile uint32_t C2;  ///< Offset: 0x02 - SPI Control Register 2
        volatile uint32_t C1;  ///< Offset: 0x03 - SPI Control Register 1
        volatile uint32_t ML;  ///< Offset: 0x04 - SPI Match Register low
        volatile uint32_t MH;  ///< Offset: 0x05 - SPI match register high
        volatile uint32_t DL;  ///< Offset: 0x06 - SPI Data Register low
        volatile uint32_t DH;  ///< Offset: 0x07 - SPI data register high
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);

    // Bit definitions
    /// S Register bits
    namespace s_bits {
        constexpr uint32_t MODF = (1U << 4);  ///< Master Mode Fault Flag
        constexpr uint32_t SPTEF = (1U << 5);  ///< SPI Transmit Buffer Empty Flag (when FIFO is not supported or not enabled) or SPI transmit FIFO empty flag (when FIFO is supported and enabled)
        constexpr uint32_t SPMF = (1U << 6);  ///< SPI Match Flag
        constexpr uint32_t SPRF = (1U << 7);  ///< SPI Read Buffer Full Flag (when FIFO is not supported or not enabled) or SPI read FIFO FULL flag (when FIFO is supported and enabled)
    }

    /// BR Register bits
    namespace br_bits {
        constexpr uint32_t SPR = (4 << 0);  ///< SPI Baud Rate Divisor
        constexpr uint32_t SPPR = (3 << 4);  ///< SPI Baud Rate Prescale Divisor
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t SPC0 = (1U << 0);  ///< SPI Pin Control 0
        constexpr uint32_t SPISWAI = (1U << 1);  ///< SPI Stop in Wait Mode
        constexpr uint32_t RXDMAE = (1U << 2);  ///< Receive DMA enable
        constexpr uint32_t BIDIROE = (1U << 3);  ///< Bidirectional Mode Output Enable
        constexpr uint32_t MODFEN = (1U << 4);  ///< Master Mode-Fault Function Enable
        constexpr uint32_t TXDMAE = (1U << 5);  ///< Transmit DMA enable
        constexpr uint32_t SPIMODE = (1U << 6);  ///< SPI 8-bit or 16-bit mode
        constexpr uint32_t SPMIE = (1U << 7);  ///< SPI Match Interrupt Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t LSBFE = (1U << 0);  ///< LSB First (shifter direction)
        constexpr uint32_t SSOE = (1U << 1);  ///< Slave Select Output Enable
        constexpr uint32_t CPHA = (1U << 2);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 3);  ///< Clock Polarity
        constexpr uint32_t MSTR = (1U << 4);  ///< Master/Slave Mode Select
        constexpr uint32_t SPTIE = (1U << 5);  ///< SPI Transmit Interrupt Enable
        constexpr uint32_t SPE = (1U << 6);  ///< SPI System Enable
        constexpr uint32_t SPIE = (1U << 7);  ///< SPI Interrupt Enable: for SPRF and MODF (when FIFO is not supported or not enabled) or for read FIFO (when FIFO is supported and enabled)
    }

    /// ML Register bits
    namespace ml_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (low byte)
    }

    /// MH Register bits
    namespace mh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Hardware compare value (high byte)
    }

    /// DL Register bits
    namespace dl_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (low byte)
    }

    /// DH Register bits
    namespace dh_bits {
        constexpr uint32_t Bits = (8 << 0);  ///< Data (high byte)
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t ME;  ///< Offset: 0x04 - LLWU Module Enable register
        volatile uint32_t F1;  ///< Offset: 0x05 - LLWU Flag 1 register
        volatile uint32_t F2;  ///< Offset: 0x06 - LLWU Flag 2 register
        volatile uint32_t F3;  ///< Offset: 0x07 - LLWU Flag 3 register
        volatile uint32_t FILT1;  ///< Offset: 0x08 - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x09 - LLWU Pin Filter 2 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// F1 Register bits
    namespace f1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// F2 Register bits
    namespace f2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// F3 Register bits
    namespace f3_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (4 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t VLLSM = (3 << 0);  ///< VLLS Mode Control
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t FM;  ///< Offset: 0x06 - Force Mode Register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
        volatile uint32_t SSRS0;  ///< Offset: 0x08 - Sticky System Reset Status Register 0
        volatile uint32_t SSRS1;  ///< Offset: 0x09 - Sticky System Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// SSRS0 Register bits
    namespace ssrs0_bits {
        constexpr uint32_t SWAKEUP = (1U << 0);  ///< Sticky Low Leakage Wakeup Reset
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
    }

    /// SSRS1 Register bits
    namespace ssrs1_bits {
        constexpr uint32_t SLOCKUP = (1U << 1);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 2);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 3);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 5);  ///< Sticky Stop Mode Acknowledge Error Reset
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT1 = (1U << 1);  ///< BIT1
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
        constexpr uint32_t BIT3 = (1U << 3);  ///< BIT3
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP;  ///< Offset: 0x20 - MTB_DWT Comparator Register (renamed from COMP)
        volatile uint32_t MASK;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register (renamed from MASK)
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP Register bits
    namespace comp_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY;  ///< Offset: 0x00 - Entry (renamed from ENTRY)
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}


} // namespace alloy::generated::mkl43z4

#endif // ALLOY_GENERATED_MKL43Z4_PERIPHERALS_HPP