/// Auto-generated code for MKL81Z7
/// Generated by Alloy Code Generator
/// Source: nxp_mkl81.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:44
#ifndef ALLOY_GENERATED_MKL81Z7_PERIPHERALS_HPP
#define ALLOY_GENERATED_MKL81Z7_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::mkl81z7 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_aips = true;
    constexpr uint32_t num_aips_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_mpu = true;
    constexpr uint32_t num_mpu_instances = 1;
    constexpr bool has_intmux0 = true;
    constexpr uint32_t num_intmux0_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 3;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 6;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 1;
    constexpr bool has_rfvbat = true;
    constexpr uint32_t num_rfvbat_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 1;
    constexpr bool has_rfsys = true;
    constexpr uint32_t num_rfsys_instances = 1;
    constexpr bool has_dry = true;
    constexpr uint32_t num_dry_instances = 1;
    constexpr bool has_tsi0 = true;
    constexpr uint32_t num_tsi0_instances = 1;
    constexpr bool has_sim = true;
    constexpr uint32_t num_sim_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 15;
    constexpr bool has_emvsim0 = true;
    constexpr uint32_t num_emvsim0_instances = 1;
    constexpr bool has_emvsim1 = true;
    constexpr uint32_t num_emvsim1_instances = 1;
    constexpr bool has_ltc0 = true;
    constexpr uint32_t num_ltc0_instances = 1;
    constexpr bool has_wdog = true;
    constexpr uint32_t num_wdog_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 3;
    constexpr bool has_flexio0 = true;
    constexpr uint32_t num_flexio0_instances = 1;
    constexpr bool has_ewm = true;
    constexpr uint32_t num_ewm_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 1;
    constexpr bool has_osc = true;
    constexpr uint32_t num_osc_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_usb = true;
    constexpr uint32_t num_usb_instances = 1;
    constexpr bool has_cmp0 = true;
    constexpr uint32_t num_cmp0_instances = 1;
    constexpr bool has_vref = true;
    constexpr uint32_t num_vref_instances = 1;
    constexpr bool has_llwu = true;
    constexpr uint32_t num_llwu_instances = 1;
    constexpr bool has_pmc = true;
    constexpr uint32_t num_pmc_instances = 1;
    constexpr bool has_smc = true;
    constexpr uint32_t num_smc_instances = 1;
    constexpr bool has_rcm = true;
    constexpr uint32_t num_rcm_instances = 1;
    constexpr bool has_mtb = true;
    constexpr uint32_t num_mtb_instances = 1;
    constexpr bool has_mtbdwt = true;
    constexpr uint32_t num_mtbdwt_instances = 1;
    constexpr bool has_rom = true;
    constexpr uint32_t num_rom_instances = 1;
    constexpr bool has_mcm = true;
    constexpr uint32_t num_mcm_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct aips_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct mpu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct intmux0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfvbat_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rfsys_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dry_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsi0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sim_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 15;
    };
    template<>
    struct peripheral_count<struct emvsim0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct emvsim1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ltc0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdog_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct flexio0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ewm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct osc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cmp0_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vref_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct llwu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct smc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcm_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtb_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mtbdwt_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rom_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mcm_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 15;
    constexpr uint32_t max_gpio_pins = 240;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart0 = true;
    constexpr bool has_lpuart1 = true;
    constexpr bool has_lpuart2 = true;
}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FTFA_FlashConfig_BASE = 0x00000400;
    constexpr uint32_t FTFA_BASE = 0x40020000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t BACKKEY3;  ///< Offset: 0x00 - Backdoor Comparison Key 3.
        volatile uint32_t BACKKEY2;  ///< Offset: 0x01 - Backdoor Comparison Key 2.
        volatile uint32_t BACKKEY1;  ///< Offset: 0x02 - Backdoor Comparison Key 1.
        volatile uint32_t BACKKEY0;  ///< Offset: 0x03 - Backdoor Comparison Key 0.
        volatile uint32_t BACKKEY7;  ///< Offset: 0x04 - Backdoor Comparison Key 7.
        volatile uint32_t BACKKEY6;  ///< Offset: 0x05 - Backdoor Comparison Key 6.
        volatile uint32_t BACKKEY5;  ///< Offset: 0x06 - Backdoor Comparison Key 5.
        volatile uint32_t BACKKEY4;  ///< Offset: 0x07 - Backdoor Comparison Key 4.
        volatile uint32_t FPROT3;  ///< Offset: 0x08 - Non-volatile P-Flash Protection 1 - Low Register
        volatile uint32_t FPROT2;  ///< Offset: 0x09 - Non-volatile P-Flash Protection 1 - High Register
        volatile uint32_t FPROT1;  ///< Offset: 0x0A - Non-volatile P-Flash Protection 0 - Low Register
        volatile uint32_t FPROT0;  ///< Offset: 0x0B - Non-volatile P-Flash Protection 0 - High Register
        volatile uint32_t FSEC;  ///< Offset: 0x0C - Non-volatile Flash Security Register
        volatile uint32_t FOPT;  ///< Offset: 0x0D - Non-volatile Flash Option Register
    };

    /// Peripheral instances
    inline Registers* FTFA_FlashConfig = reinterpret_cast<Registers*>(FTFA_FlashConfig_BASE);
    inline Registers* FTFA = reinterpret_cast<Registers*>(FTFA_BASE);

    // Bit definitions
    /// BACKKEY3 Register bits
    namespace backkey3_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY2 Register bits
    namespace backkey2_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY1 Register bits
    namespace backkey1_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY0 Register bits
    namespace backkey0_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY7 Register bits
    namespace backkey7_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY6 Register bits
    namespace backkey6_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY5 Register bits
    namespace backkey5_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// BACKKEY4 Register bits
    namespace backkey4_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Backdoor Comparison Key.
    }

    /// FPROT3 Register bits
    namespace fprot3_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT2 Register bits
    namespace fprot2_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT1 Register bits
    namespace fprot1_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FPROT0 Register bits
    namespace fprot0_bits {
        constexpr uint32_t PROT = (8 << 0);  ///< P-Flash Region Protect
    }

    /// FSEC Register bits
    namespace fsec_bits {
        constexpr uint32_t SEC = (2 << 0);  ///< Flash Security
        constexpr uint32_t FSLACC = (2 << 2);  ///< Freescale Failure Analysis Access Code
        constexpr uint32_t MEEN = (2 << 4);  ///< no description available
        constexpr uint32_t KEYEN = (2 << 6);  ///< Backdoor Key Security Enable
    }

    /// FOPT Register bits
    namespace fopt_bits {
        constexpr uint32_t LPBOOT = (1U << 0);  ///< no description available
        constexpr uint32_t BOOTPIN_OPT = (1U << 1);  ///< no description available
        constexpr uint32_t NMI_DIS = (1U << 2);  ///< no description available
        constexpr uint32_t FAST_INIT = (1U << 5);  ///< no description available
        constexpr uint32_t BOOTSRC_SEL = (2 << 6);  ///< Boot source selection
    }

}

// ============================================================================
// AIPS Peripheral
// ============================================================================

namespace aips {
    /// Base addresses
    constexpr uint32_t AIPS_BASE = 0x40000000;

    /// AIPS Register structure
    struct Registers {
        volatile uint32_t MPRA;  ///< Offset: 0x00 - Master Privilege Register A
        volatile uint32_t PACRA;  ///< Offset: 0x20 - Peripheral Access Control Register
        volatile uint32_t PACRB;  ///< Offset: 0x24 - Peripheral Access Control Register
        volatile uint32_t PACRC;  ///< Offset: 0x28 - Peripheral Access Control Register
        volatile uint32_t PACRD;  ///< Offset: 0x2C - Peripheral Access Control Register
        volatile uint32_t PACRE;  ///< Offset: 0x40 - Peripheral Access Control Register
        volatile uint32_t PACRF;  ///< Offset: 0x44 - Peripheral Access Control Register
        volatile uint32_t PACRG;  ///< Offset: 0x48 - Peripheral Access Control Register
        volatile uint32_t PACRH;  ///< Offset: 0x4C - Peripheral Access Control Register
        volatile uint32_t PACRI;  ///< Offset: 0x50 - Peripheral Access Control Register
        volatile uint32_t PACRJ;  ///< Offset: 0x54 - Peripheral Access Control Register
        volatile uint32_t PACRK;  ///< Offset: 0x58 - Peripheral Access Control Register
        volatile uint32_t PACRL;  ///< Offset: 0x5C - Peripheral Access Control Register
        volatile uint32_t PACRM;  ///< Offset: 0x60 - Peripheral Access Control Register
        volatile uint32_t PACRN;  ///< Offset: 0x64 - Peripheral Access Control Register
        volatile uint32_t PACRO;  ///< Offset: 0x68 - Peripheral Access Control Register
        volatile uint32_t PACRP;  ///< Offset: 0x6C - Peripheral Access Control Register
    };

    /// Peripheral instances
    inline Registers* AIPS = reinterpret_cast<Registers*>(AIPS_BASE);

    // Bit definitions
    /// MPRA Register bits
    namespace mpra_bits {
        constexpr uint32_t MPL4 = (1U << 12);  ///< Master 4 Privilege Level
        constexpr uint32_t MTW4 = (1U << 13);  ///< Master 4 Trusted For Writes
        constexpr uint32_t MTR4 = (1U << 14);  ///< Master 4 Trusted For Read
        constexpr uint32_t MPL3 = (1U << 16);  ///< Master 3 Privilege Level
        constexpr uint32_t MTW3 = (1U << 17);  ///< Master 3 Trusted For Writes
        constexpr uint32_t MTR3 = (1U << 18);  ///< Master 3 Trusted For Read
        constexpr uint32_t MPL2 = (1U << 20);  ///< Master 2 Privilege Level
        constexpr uint32_t MTW2 = (1U << 21);  ///< Master 2 Trusted For Writes
        constexpr uint32_t MTR2 = (1U << 22);  ///< Master 2 Trusted For Read
        constexpr uint32_t MPL1 = (1U << 24);  ///< Master 1 Privilege Level
        constexpr uint32_t MTW1 = (1U << 25);  ///< Master 1 Trusted for Writes
        constexpr uint32_t MTR1 = (1U << 26);  ///< Master 1 Trusted for Read
        constexpr uint32_t MPL0 = (1U << 28);  ///< Master 0 Privilege Level
        constexpr uint32_t MTW0 = (1U << 29);  ///< Master 0 Trusted For Writes
        constexpr uint32_t MTR0 = (1U << 30);  ///< Master 0 Trusted For Read
    }

    /// PACRA Register bits
    namespace pacra_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRB Register bits
    namespace pacrb_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRC Register bits
    namespace pacrc_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRD Register bits
    namespace pacrd_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRE Register bits
    namespace pacre_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRF Register bits
    namespace pacrf_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRG Register bits
    namespace pacrg_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRH Register bits
    namespace pacrh_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRI Register bits
    namespace pacri_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRJ Register bits
    namespace pacrj_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRK Register bits
    namespace pacrk_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRL Register bits
    namespace pacrl_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRM Register bits
    namespace pacrm_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRN Register bits
    namespace pacrn_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRO Register bits
    namespace pacro_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

    /// PACRP Register bits
    namespace pacrp_bits {
        constexpr uint32_t TP7 = (1U << 0);  ///< Trusted Protect
        constexpr uint32_t WP7 = (1U << 1);  ///< Write Protect
        constexpr uint32_t SP7 = (1U << 2);  ///< Supervisor Protect
        constexpr uint32_t TP6 = (1U << 4);  ///< Trusted Protect
        constexpr uint32_t WP6 = (1U << 5);  ///< Write Protect
        constexpr uint32_t SP6 = (1U << 6);  ///< Supervisor Protect
        constexpr uint32_t TP5 = (1U << 8);  ///< Trusted Protect
        constexpr uint32_t WP5 = (1U << 9);  ///< Write Protect
        constexpr uint32_t SP5 = (1U << 10);  ///< Supervisor Protect
        constexpr uint32_t TP4 = (1U << 12);  ///< Trusted Protect
        constexpr uint32_t WP4 = (1U << 13);  ///< Write Protect
        constexpr uint32_t SP4 = (1U << 14);  ///< Supervisor Protect
        constexpr uint32_t TP3 = (1U << 16);  ///< Trusted Protect
        constexpr uint32_t WP3 = (1U << 17);  ///< Write Protect
        constexpr uint32_t SP3 = (1U << 18);  ///< Supervisor Protect
        constexpr uint32_t TP2 = (1U << 20);  ///< Trusted Protect
        constexpr uint32_t WP2 = (1U << 21);  ///< Write Protect
        constexpr uint32_t SP2 = (1U << 22);  ///< Supervisor Protect
        constexpr uint32_t TP1 = (1U << 24);  ///< Trusted Protect
        constexpr uint32_t WP1 = (1U << 25);  ///< Write Protect
        constexpr uint32_t SP1 = (1U << 26);  ///< Supervisor Protect
        constexpr uint32_t TP0 = (1U << 28);  ///< Trusted Protect
        constexpr uint32_t WP0 = (1U << 29);  ///< Write Protect
        constexpr uint32_t SP0 = (1U << 30);  ///< Supervisor Protect
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA_BASE = 0x40008000;
    constexpr uint32_t DMAMUX_BASE = 0x40021000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control Register
        volatile uint32_t ES;  ///< Offset: 0x04 - Error Status Register
        volatile uint32_t ERQ;  ///< Offset: 0x0C - Enable Request Register
        volatile uint32_t EEI;  ///< Offset: 0x14 - Enable Error Interrupt Register
        volatile uint32_t CEEI;  ///< Offset: 0x18 - Clear Enable Error Interrupt Register
        volatile uint32_t SEEI;  ///< Offset: 0x19 - Set Enable Error Interrupt Register
        volatile uint32_t CERQ;  ///< Offset: 0x1A - Clear Enable Request Register
        volatile uint32_t SERQ;  ///< Offset: 0x1B - Set Enable Request Register
        volatile uint32_t CDNE;  ///< Offset: 0x1C - Clear DONE Status Bit Register
        volatile uint32_t SSRT;  ///< Offset: 0x1D - Set START Bit Register
        volatile uint32_t CERR;  ///< Offset: 0x1E - Clear Error Register
        volatile uint32_t CINT;  ///< Offset: 0x1F - Clear Interrupt Request Register
        volatile uint32_t INT_;  ///< Offset: 0x24 - Interrupt Request Register (renamed from INT_)
        volatile uint32_t ERR;  ///< Offset: 0x2C - Error Register
        volatile uint32_t HRS;  ///< Offset: 0x34 - Hardware Request Status Register
        volatile uint32_t EARS;  ///< Offset: 0x44 - Enable Asynchronous Request in Stop Register
        volatile uint32_t DCHPRI;  ///< Offset: 0x100 - Channel n Priority Register (renamed from DCHPRI)
        volatile uint32_t TCD_SADDR;  ///< Offset: 0x1000 - TCD Source Address (renamed from TCD_SADDR)
        volatile uint32_t TCD_SOFF;  ///< Offset: 0x1004 - TCD Signed Source Address Offset (renamed from TCD_SOFF)
        volatile uint32_t TCD_ATTR;  ///< Offset: 0x1006 - TCD Transfer Attributes (renamed from TCD_ATTR)
        volatile uint32_t TCD_NBYTES_MLNO;  ///< Offset: 0x1008 - TCD Minor Byte Count (Minor Loop Mapping Disabled) (renamed from TCD_NBYTES_MLNO)
        volatile uint32_t TCD_NBYTES_MLOFFNO;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled... (renamed from TCD_NBYTES_MLOFFNO)
        volatile uint32_t TCD_NBYTES_MLOFFYES;  ///< Offset: 0x1008 - TCD Signed Minor Loop Offset (Minor Loop Mapping and... (renamed from TCD_NBYTES_MLOFFYES)
        volatile uint32_t TCD_SLAST;  ///< Offset: 0x100C - TCD Last Source Address Adjustment (renamed from TCD_SLAST)
        volatile uint32_t TCD_DADDR;  ///< Offset: 0x1010 - TCD Destination Address (renamed from TCD_DADDR)
        volatile uint32_t TCD_DOFF;  ///< Offset: 0x1014 - TCD Signed Destination Address Offset (renamed from TCD_DOFF)
        volatile uint32_t TCD_CITER_ELINKNO;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKNO)
        volatile uint32_t TCD_CITER_ELINKYES;  ///< Offset: 0x1016 - TCD Current Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_CITER_ELINKYES)
        volatile uint32_t TCD_DLASTSGA;  ///< Offset: 0x1018 - TCD Last Destination Address Adjustment/Scatter Gather Address (renamed from TCD_DLASTSGA)
        volatile uint32_t TCD_CSR;  ///< Offset: 0x101C - TCD Control and Status (renamed from TCD_CSR)
        volatile uint32_t TCD_BITER_ELINKNO;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKNO)
        volatile uint32_t TCD_BITER_ELINKYES;  ///< Offset: 0x101E - TCD Beginning Minor Loop Link, Major Loop Count (Channel... (renamed from TCD_BITER_ELINKYES)
    };

    /// Peripheral instances
    inline Registers* DMA = reinterpret_cast<Registers*>(DMA_BASE);
    inline Registers* DMAMUX = reinterpret_cast<Registers*>(DMAMUX_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t EDBG = (1U << 1);  ///< Enable Debug
        constexpr uint32_t ERCA = (1U << 2);  ///< Enable Round Robin Channel Arbitration
        constexpr uint32_t HOE = (1U << 4);  ///< Halt On Error
        constexpr uint32_t HALT = (1U << 5);  ///< Halt DMA Operations
        constexpr uint32_t CLM = (1U << 6);  ///< Continuous Link Mode
        constexpr uint32_t EMLM = (1U << 7);  ///< Enable Minor Loop Mapping
        constexpr uint32_t ECX = (1U << 16);  ///< Error Cancel Transfer
        constexpr uint32_t CX = (1U << 17);  ///< Cancel Transfer
        constexpr uint32_t ACTIVE = (1U << 31);  ///< DMA Active Status
    }

    /// ES Register bits
    namespace es_bits {
        constexpr uint32_t DBE = (1U << 0);  ///< Destination Bus Error
        constexpr uint32_t SBE = (1U << 1);  ///< Source Bus Error
        constexpr uint32_t SGE = (1U << 2);  ///< Scatter/Gather Configuration Error
        constexpr uint32_t NCE = (1U << 3);  ///< NBYTES/CITER Configuration Error
        constexpr uint32_t DOE = (1U << 4);  ///< Destination Offset Error
        constexpr uint32_t DAE = (1U << 5);  ///< Destination Address Error
        constexpr uint32_t SOE = (1U << 6);  ///< Source Offset Error
        constexpr uint32_t SAE = (1U << 7);  ///< Source Address Error
        constexpr uint32_t ERRCHN = (3 << 8);  ///< Error Channel Number or Canceled Channel Number
        constexpr uint32_t CPE = (1U << 14);  ///< Channel Priority Error
        constexpr uint32_t ECX = (1U << 16);  ///< Transfer Canceled
        constexpr uint32_t VLD = (1U << 31);  ///< Logical OR of all ERR status bits
    }

    /// ERQ Register bits
    namespace erq_bits {
        constexpr uint32_t ERQ0 = (1U << 0);  ///< Enable DMA Request 0
        constexpr uint32_t ERQ1 = (1U << 1);  ///< Enable DMA Request 1
        constexpr uint32_t ERQ2 = (1U << 2);  ///< Enable DMA Request 2
        constexpr uint32_t ERQ3 = (1U << 3);  ///< Enable DMA Request 3
        constexpr uint32_t ERQ4 = (1U << 4);  ///< Enable DMA Request 4
        constexpr uint32_t ERQ5 = (1U << 5);  ///< Enable DMA Request 5
        constexpr uint32_t ERQ6 = (1U << 6);  ///< Enable DMA Request 6
        constexpr uint32_t ERQ7 = (1U << 7);  ///< Enable DMA Request 7
    }

    /// EEI Register bits
    namespace eei_bits {
        constexpr uint32_t EEI0 = (1U << 0);  ///< Enable Error Interrupt 0
        constexpr uint32_t EEI1 = (1U << 1);  ///< Enable Error Interrupt 1
        constexpr uint32_t EEI2 = (1U << 2);  ///< Enable Error Interrupt 2
        constexpr uint32_t EEI3 = (1U << 3);  ///< Enable Error Interrupt 3
        constexpr uint32_t EEI4 = (1U << 4);  ///< Enable Error Interrupt 4
        constexpr uint32_t EEI5 = (1U << 5);  ///< Enable Error Interrupt 5
        constexpr uint32_t EEI6 = (1U << 6);  ///< Enable Error Interrupt 6
        constexpr uint32_t EEI7 = (1U << 7);  ///< Enable Error Interrupt 7
    }

    /// CEEI Register bits
    namespace ceei_bits {
        constexpr uint32_t CEEI = (3 << 0);  ///< Clear Enable Error Interrupt
        constexpr uint32_t CAEE = (1U << 6);  ///< Clear All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SEEI Register bits
    namespace seei_bits {
        constexpr uint32_t SEEI = (3 << 0);  ///< Set Enable Error Interrupt
        constexpr uint32_t SAEE = (1U << 6);  ///< Sets All Enable Error Interrupts
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERQ Register bits
    namespace cerq_bits {
        constexpr uint32_t CERQ = (3 << 0);  ///< Clear Enable Request
        constexpr uint32_t CAER = (1U << 6);  ///< Clear All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SERQ Register bits
    namespace serq_bits {
        constexpr uint32_t SERQ = (3 << 0);  ///< Set Enable Request
        constexpr uint32_t SAER = (1U << 6);  ///< Set All Enable Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CDNE Register bits
    namespace cdne_bits {
        constexpr uint32_t CDNE = (3 << 0);  ///< Clear DONE Bit
        constexpr uint32_t CADN = (1U << 6);  ///< Clears All DONE Bits
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// SSRT Register bits
    namespace ssrt_bits {
        constexpr uint32_t SSRT = (3 << 0);  ///< Set START Bit
        constexpr uint32_t SAST = (1U << 6);  ///< Set All START Bits (activates all channels)
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CERR Register bits
    namespace cerr_bits {
        constexpr uint32_t CERR = (3 << 0);  ///< Clear Error Indicator
        constexpr uint32_t CAEI = (1U << 6);  ///< Clear All Error Indicators
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// CINT Register bits
    namespace cint_bits {
        constexpr uint32_t CINT = (3 << 0);  ///< Clear Interrupt Request
        constexpr uint32_t CAIR = (1U << 6);  ///< Clear All Interrupt Requests
        constexpr uint32_t NOP = (1U << 7);  ///< No Op enable
    }

    /// INT_ Register bits
    namespace int__bits {
        constexpr uint32_t INT0 = (1U << 0);  ///< Interrupt Request 0
        constexpr uint32_t INT1 = (1U << 1);  ///< Interrupt Request 1
        constexpr uint32_t INT2 = (1U << 2);  ///< Interrupt Request 2
        constexpr uint32_t INT3 = (1U << 3);  ///< Interrupt Request 3
        constexpr uint32_t INT4 = (1U << 4);  ///< Interrupt Request 4
        constexpr uint32_t INT5 = (1U << 5);  ///< Interrupt Request 5
        constexpr uint32_t INT6 = (1U << 6);  ///< Interrupt Request 6
        constexpr uint32_t INT7 = (1U << 7);  ///< Interrupt Request 7
    }

    /// ERR Register bits
    namespace err_bits {
        constexpr uint32_t ERR0 = (1U << 0);  ///< Error In Channel 0
        constexpr uint32_t ERR1 = (1U << 1);  ///< Error In Channel 1
        constexpr uint32_t ERR2 = (1U << 2);  ///< Error In Channel 2
        constexpr uint32_t ERR3 = (1U << 3);  ///< Error In Channel 3
        constexpr uint32_t ERR4 = (1U << 4);  ///< Error In Channel 4
        constexpr uint32_t ERR5 = (1U << 5);  ///< Error In Channel 5
        constexpr uint32_t ERR6 = (1U << 6);  ///< Error In Channel 6
        constexpr uint32_t ERR7 = (1U << 7);  ///< Error In Channel 7
    }

    /// HRS Register bits
    namespace hrs_bits {
        constexpr uint32_t HRS0 = (1U << 0);  ///< Hardware Request Status Channel 0
        constexpr uint32_t HRS1 = (1U << 1);  ///< Hardware Request Status Channel 1
        constexpr uint32_t HRS2 = (1U << 2);  ///< Hardware Request Status Channel 2
        constexpr uint32_t HRS3 = (1U << 3);  ///< Hardware Request Status Channel 3
        constexpr uint32_t HRS4 = (1U << 4);  ///< Hardware Request Status Channel 4
        constexpr uint32_t HRS5 = (1U << 5);  ///< Hardware Request Status Channel 5
        constexpr uint32_t HRS6 = (1U << 6);  ///< Hardware Request Status Channel 6
        constexpr uint32_t HRS7 = (1U << 7);  ///< Hardware Request Status Channel 7
    }

    /// EARS Register bits
    namespace ears_bits {
        constexpr uint32_t EDREQ_0 = (1U << 0);  ///< Enable asynchronous DMA request in stop mode for channel 0.
        constexpr uint32_t EDREQ_1 = (1U << 1);  ///< Enable asynchronous DMA request in stop mode for channel 1.
        constexpr uint32_t EDREQ_2 = (1U << 2);  ///< Enable asynchronous DMA request in stop mode for channel 2.
        constexpr uint32_t EDREQ_3 = (1U << 3);  ///< Enable asynchronous DMA request in stop mode for channel 3.
        constexpr uint32_t EDREQ_4 = (1U << 4);  ///< Enable asynchronous DMA request in stop mode for channel 4
        constexpr uint32_t EDREQ_5 = (1U << 5);  ///< Enable asynchronous DMA request in stop mode for channel 5
        constexpr uint32_t EDREQ_6 = (1U << 6);  ///< Enable asynchronous DMA request in stop mode for channel 6
        constexpr uint32_t EDREQ_7 = (1U << 7);  ///< Enable asynchronous DMA request in stop mode for channel 7
    }

    /// DCHPRI Register bits
    namespace dchpri_bits {
        constexpr uint32_t CHPRI = (3 << 0);  ///< Channel n Arbitration Priority
        constexpr uint32_t DPA = (1U << 6);  ///< Disable Preempt Ability.
        constexpr uint32_t ECP = (1U << 7);  ///< Enable Channel Preemption.
    }

    /// TCD_SADDR Register bits
    namespace tcd_saddr_bits {
        constexpr uint32_t SADDR = (32 << 0);  ///< Source Address
    }

    /// TCD_SOFF Register bits
    namespace tcd_soff_bits {
        constexpr uint32_t SOFF = (16 << 0);  ///< Source address signed offset
    }

    /// TCD_ATTR Register bits
    namespace tcd_attr_bits {
        constexpr uint32_t DSIZE = (3 << 0);  ///< Destination data transfer size
        constexpr uint32_t DMOD = (5 << 3);  ///< Destination Address Modulo
        constexpr uint32_t SSIZE = (3 << 8);  ///< Source data transfer size
        constexpr uint32_t SMOD = (5 << 11);  ///< Source Address Modulo
    }

    /// TCD_NBYTES_MLNO Register bits
    namespace tcd_nbytes_mlno_bits {
        constexpr uint32_t NBYTES = (32 << 0);  ///< Minor Byte Transfer Count
    }

    /// TCD_NBYTES_MLOFFNO Register bits
    namespace tcd_nbytes_mloffno_bits {
        constexpr uint32_t NBYTES = (30 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_NBYTES_MLOFFYES Register bits
    namespace tcd_nbytes_mloffyes_bits {
        constexpr uint32_t NBYTES = (10 << 0);  ///< Minor Byte Transfer Count
        constexpr uint32_t MLOFF = (20 << 10);  ///< If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        constexpr uint32_t DMLOE = (1U << 30);  ///< Destination Minor Loop Offset enable
        constexpr uint32_t SMLOE = (1U << 31);  ///< Source Minor Loop Offset Enable
    }

    /// TCD_SLAST Register bits
    namespace tcd_slast_bits {
        constexpr uint32_t SLAST = (32 << 0);  ///< Last Source Address Adjustment
    }

    /// TCD_DADDR Register bits
    namespace tcd_daddr_bits {
        constexpr uint32_t DADDR = (32 << 0);  ///< Destination Address
    }

    /// TCD_DOFF Register bits
    namespace tcd_doff_bits {
        constexpr uint32_t DOFF = (16 << 0);  ///< Destination Address Signed Offset
    }

    /// TCD_CITER_ELINKNO Register bits
    namespace tcd_citer_elinkno_bits {
        constexpr uint32_t CITER = (15 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_CITER_ELINKYES Register bits
    namespace tcd_citer_elinkyes_bits {
        constexpr uint32_t CITER = (9 << 0);  ///< Current Major Iteration Count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Minor Loop Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enable channel-to-channel linking on minor-loop complete
    }

    /// TCD_DLASTSGA Register bits
    namespace tcd_dlastsga_bits {
        constexpr uint32_t DLASTSGA = (32 << 0);  ///< Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
    }

    /// TCD_CSR Register bits
    namespace tcd_csr_bits {
        constexpr uint32_t START = (1U << 0);  ///< Channel Start
        constexpr uint32_t INTMAJOR = (1U << 1);  ///< Enable an interrupt when major iteration count completes.
        constexpr uint32_t INTHALF = (1U << 2);  ///< Enable an interrupt when major counter is half complete.
        constexpr uint32_t DREQ = (1U << 3);  ///< Disable Request
        constexpr uint32_t ESG = (1U << 4);  ///< Enable Scatter/Gather Processing
        constexpr uint32_t MAJORELINK = (1U << 5);  ///< Enable channel-to-channel linking on major loop complete
        constexpr uint32_t ACTIVE = (1U << 6);  ///< Channel Active
        constexpr uint32_t DONE = (1U << 7);  ///< Channel Done
        constexpr uint32_t MAJORLINKCH = (3 << 8);  ///< Major Loop Link Channel Number
        constexpr uint32_t BWC = (2 << 14);  ///< Bandwidth Control
    }

    /// TCD_BITER_ELINKNO Register bits
    namespace tcd_biter_elinkno_bits {
        constexpr uint32_t BITER = (15 << 0);  ///< Starting Major Iteration Count
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

    /// TCD_BITER_ELINKYES Register bits
    namespace tcd_biter_elinkyes_bits {
        constexpr uint32_t BITER = (9 << 0);  ///< Starting major iteration count
        constexpr uint32_t LINKCH = (3 << 9);  ///< Link Channel Number
        constexpr uint32_t ELINK = (1U << 15);  ///< Enables channel-to-channel linking on minor loop complete
    }

}

// ============================================================================
// MPU Peripheral
// ============================================================================

namespace mpu {
    /// Base addresses
    constexpr uint32_t MPU_BASE = 0x4000D000;

    /// MPU Register structure
    struct Registers {
        volatile uint32_t CESR;  ///< Offset: 0x00 - Control/Error Status Register
        volatile uint32_t EAR;  ///< Offset: 0x10 - Error Address Register, slave port n (renamed from EAR)
        volatile uint32_t EDR;  ///< Offset: 0x14 - Error Detail Register, slave port n (renamed from EDR)
        volatile uint32_t RGD_WORD0;  ///< Offset: 0x400 - Region Descriptor n, Word 0 (renamed from RGD_WORD0)
        volatile uint32_t RGD_WORD1;  ///< Offset: 0x404 - Region Descriptor n, Word 1 (renamed from RGD_WORD1)
        volatile uint32_t RGD_WORD2;  ///< Offset: 0x408 - Region Descriptor n, Word 2 (renamed from RGD_WORD2)
        volatile uint32_t RGD_WORD3;  ///< Offset: 0x40C - Region Descriptor n, Word 3 (renamed from RGD_WORD3)
        volatile uint32_t RGDAAC;  ///< Offset: 0x800 - Region Descriptor Alternate Access Control n (renamed from RGDAAC)
    };

    /// Peripheral instances
    inline Registers* MPU = reinterpret_cast<Registers*>(MPU_BASE);

    // Bit definitions
    /// CESR Register bits
    namespace cesr_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t NRGD = (4 << 8);  ///< Number Of Region Descriptors
        constexpr uint32_t NSP = (4 << 12);  ///< Number Of Slave Ports
        constexpr uint32_t HRL = (4 << 16);  ///< Hardware Revision Level
        constexpr uint32_t SPERR = (5 << 27);  ///< Slave Port n Error
    }

    /// EAR Register bits
    namespace ear_bits {
        constexpr uint32_t EADDR = (32 << 0);  ///< Error Address
    }

    /// EDR Register bits
    namespace edr_bits {
        constexpr uint32_t ERW = (1U << 0);  ///< Error Read/Write
        constexpr uint32_t EATTR = (3 << 1);  ///< Error Attributes
        constexpr uint32_t EMN = (4 << 4);  ///< Error Master Number
        constexpr uint32_t EPID = (8 << 8);  ///< Error Process Identification
        constexpr uint32_t EACD = (16 << 16);  ///< Error Access Control Detail
    }

    /// RGD_WORD0 Register bits
    namespace rgd_word0_bits {
        constexpr uint32_t SRTADDR = (27 << 5);  ///< Start Address
    }

    /// RGD_WORD1 Register bits
    namespace rgd_word1_bits {
        constexpr uint32_t ENDADDR = (27 << 5);  ///< End Address
    }

    /// RGD_WORD2 Register bits
    namespace rgd_word2_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

    /// RGD_WORD3 Register bits
    namespace rgd_word3_bits {
        constexpr uint32_t VLD = (1U << 0);  ///< Valid
        constexpr uint32_t PIDMASK = (8 << 16);  ///< Process Identifier Mask
        constexpr uint32_t PID = (8 << 24);  ///< Process Identifier
    }

    /// RGDAAC Register bits
    namespace rgdaac_bits {
        constexpr uint32_t M0UM = (3 << 0);  ///< Bus Master 0 User Mode Access Control
        constexpr uint32_t M0SM = (2 << 3);  ///< Bus Master 0 Supervisor Mode Access Control
        constexpr uint32_t M0PE = (1U << 5);  ///< Bus Master 0 Process Identifier Enable
        constexpr uint32_t M1UM = (3 << 6);  ///< Bus Master 1 User Mode Access Control
        constexpr uint32_t M1SM = (2 << 9);  ///< Bus Master 1 Supervisor Mode Access Control
        constexpr uint32_t M1PE = (1U << 11);  ///< Bus Master 1 Process Identifier Enable
        constexpr uint32_t M2UM = (3 << 12);  ///< Bus Master 2 User Mode Access Control
        constexpr uint32_t M2SM = (2 << 15);  ///< Bus Master 2 Supervisor Mode Access Control
        constexpr uint32_t M2PE = (1U << 17);  ///< Bus Master 2 Process Identifier Enable
        constexpr uint32_t M3UM = (3 << 18);  ///< Bus Master 3 User Mode Access Control
        constexpr uint32_t M3SM = (2 << 21);  ///< Bus Master 3 Supervisor Mode Access Control
        constexpr uint32_t M3PE = (1U << 23);  ///< Bus Master 3 Process Identifier Enable
        constexpr uint32_t M4WE = (1U << 24);  ///< Bus Master 4 Write Enable
        constexpr uint32_t M4RE = (1U << 25);  ///< Bus Master 4 Read Enable
        constexpr uint32_t M5WE = (1U << 26);  ///< Bus Master 5 Write Enable
        constexpr uint32_t M5RE = (1U << 27);  ///< Bus Master 5 Read Enable
        constexpr uint32_t M6WE = (1U << 28);  ///< Bus Master 6 Write Enable
        constexpr uint32_t M6RE = (1U << 29);  ///< Bus Master 6 Read Enable
        constexpr uint32_t M7WE = (1U << 30);  ///< Bus Master 7 Write Enable
        constexpr uint32_t M7RE = (1U << 31);  ///< Bus Master 7 Read Enable
    }

}

// ============================================================================
// INTMUX0 Peripheral
// ============================================================================

namespace intmux0 {
    /// Base addresses
    constexpr uint32_t INTMUX0_BASE = 0x40024000;

    /// INTMUX0 Register structure
    struct Registers {
        volatile uint32_t CH_CSR;  ///< Offset: 0x00 - Channel n Control Status Register (renamed from CH_CSR)
        volatile uint32_t CH_VEC;  ///< Offset: 0x04 - Channel n Vector Number Register (renamed from CH_VEC)
        volatile uint32_t CH_IER_31_0;  ///< Offset: 0x10 - Channel n Interrupt Enable Register (renamed from CH_IER_31_0)
        volatile uint32_t CH_IPR_31_0;  ///< Offset: 0x20 - Channel n Interrupt Pending Register (renamed from CH_IPR_31_0)
    };

    /// Peripheral instances
    inline Registers* INTMUX0 = reinterpret_cast<Registers*>(INTMUX0_BASE);

    // Bit definitions
    /// CH_CSR Register bits
    namespace ch_csr_bits {
        constexpr uint32_t RST = (1U << 0);  ///< Software Reset
        constexpr uint32_t AND_ = (1U << 1);  ///< Logic AND (renamed from AND_)
        constexpr uint32_t IRQN = (2 << 4);  ///< Channel Input Number
        constexpr uint32_t CHIN = (4 << 8);  ///< Channel Instance Number
        constexpr uint32_t IRQP = (1U << 31);  ///< Channel Interrupt Request Pending
    }

    /// CH_VEC Register bits
    namespace ch_vec_bits {
        constexpr uint32_t VECN = (12 << 2);  ///< Vector Number
    }

    /// CH_IER_31_0 Register bits
    namespace ch_ier_31_0_bits {
        constexpr uint32_t INTE = (32 << 0);  ///< Interrupt Enable
    }

    /// CH_IPR_31_0 Register bits
    namespace ch_ipr_31_0_bits {
        constexpr uint32_t INTP = (32 << 0);  ///< Interrupt Pending
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t TRNG0_BASE = 0x40025000;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t TRNG0_MCTL;  ///< Offset: 0x00 - TRNG0 Miscellaneous Control Register
        volatile uint32_t TRNG0_SCMISC;  ///< Offset: 0x04 - TRNG0 Statistical Check Miscellaneous Register
        volatile uint32_t TRNG0_PKRRNG;  ///< Offset: 0x08 - TRNG0 Poker Range Register
        volatile uint32_t TRNG0_PKRMAX;  ///< Offset: 0x0C - TRNG0 Poker Maximum Limit Register
        volatile uint32_t TRNG0_PKRSQ;  ///< Offset: 0x0C - TRNG0 Poker Square Calculation Result Register
        volatile uint32_t TRNG0_SDCTL;  ///< Offset: 0x10 - TRNG0 Seed Control Register
        volatile uint32_t TRNG0_SBLIM;  ///< Offset: 0x14 - TRNG0 Sparse Bit Limit Register
        volatile uint32_t TRNG0_TOTSAM;  ///< Offset: 0x14 - TRNG0 Total Samples Register
        volatile uint32_t TRNG0_FRQMIN;  ///< Offset: 0x18 - TRNG0 Frequency Count Minimum Limit Register
        volatile uint32_t TRNG0_FRQCNT;  ///< Offset: 0x1C - TRNG0 Frequency Count Register
        volatile uint32_t TRNG0_FRQMAX;  ///< Offset: 0x1C - TRNG0 Frequency Count Maximum Limit Register
        volatile uint32_t TRNG0_SCMC;  ///< Offset: 0x20 - TRNG0 Statistical Check Monobit Count Register
        volatile uint32_t TRNG0_SCML;  ///< Offset: 0x20 - TRNG0 Statistical Check Monobit Limit Register
        volatile uint32_t TRNG0_SCR1C;  ///< Offset: 0x24 - TRNG0 Statistical Check Run Length 1 Count Register
        volatile uint32_t TRNG0_SCR1L;  ///< Offset: 0x24 - TRNG0 Statistical Check Run Length 1 Limit Register
        volatile uint32_t TRNG0_SCR2C;  ///< Offset: 0x28 - TRNG0 Statistical Check Run Length 2 Count Register
        volatile uint32_t TRNG0_SCR2L;  ///< Offset: 0x28 - TRNG0 Statistical Check Run Length 2 Limit Register
        volatile uint32_t TRNG0_SCR3C;  ///< Offset: 0x2C - TRNG0 Statistical Check Run Length 3 Count Register
        volatile uint32_t TRNG0_SCR3L;  ///< Offset: 0x2C - TRNG0 Statistical Check Run Length 3 Limit Register
        volatile uint32_t TRNG0_SCR4C;  ///< Offset: 0x30 - TRNG0 Statistical Check Run Length 4 Count Register
        volatile uint32_t TRNG0_SCR4L;  ///< Offset: 0x30 - TRNG0 Statistical Check Run Length 4 Limit Register
        volatile uint32_t TRNG0_SCR5C;  ///< Offset: 0x34 - TRNG0 Statistical Check Run Length 5 Count Register
        volatile uint32_t TRNG0_SCR5L;  ///< Offset: 0x34 - TRNG0 Statistical Check Run Length 5 Limit Register
        volatile uint32_t TRNG0_SCR6PC;  ///< Offset: 0x38 - TRNG0 Statistical Check Run Length 6+ Count Register
        volatile uint32_t TRNG0_SCR6PL;  ///< Offset: 0x38 - TRNG0 Statistical Check Run Length 6+ Limit Register
        volatile uint32_t TRNG0_STATUS;  ///< Offset: 0x3C - TRNG0 Status Register
        volatile uint32_t TRNG0_ENT0;  ///< Offset: 0x40 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT1;  ///< Offset: 0x44 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT2;  ///< Offset: 0x48 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT3;  ///< Offset: 0x4C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT4;  ///< Offset: 0x50 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT5;  ///< Offset: 0x54 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT6;  ///< Offset: 0x58 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT7;  ///< Offset: 0x5C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT8;  ///< Offset: 0x60 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT9;  ///< Offset: 0x64 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT10;  ///< Offset: 0x68 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT11;  ///< Offset: 0x6C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT12;  ///< Offset: 0x70 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT13;  ///< Offset: 0x74 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT14;  ///< Offset: 0x78 - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_ENT15;  ///< Offset: 0x7C - RNG TRNG Entropy Read Register
        volatile uint32_t TRNG0_PKRCNT10;  ///< Offset: 0x80 - TRNG0 Statistical Check Poker Count 1 and 0 Register
        volatile uint32_t TRNG0_PKRCNT32;  ///< Offset: 0x84 - TRNG0 Statistical Check Poker Count 3 and 2 Register
        volatile uint32_t TRNG0_PKRCNT54;  ///< Offset: 0x88 - TRNG0 Statistical Check Poker Count 5 and 4 Register
        volatile uint32_t TRNG0_PKRCNT76;  ///< Offset: 0x8C - TRNG0 Statistical Check Poker Count 7 and 6 Register
        volatile uint32_t TRNG0_PKRCNT98;  ///< Offset: 0x90 - TRNG0 Statistical Check Poker Count 9 and 8 Register
        volatile uint32_t TRNG0_PKRCNTBA;  ///< Offset: 0x94 - TRNG0 Statistical Check Poker Count B and A Register
        volatile uint32_t TRNG0_PKRCNTDC;  ///< Offset: 0x98 - TRNG0 Statistical Check Poker Count D and C Register
        volatile uint32_t TRNG0_PKRCNTFE;  ///< Offset: 0x9C - TRNG0 Statistical Check Poker Count F and E Register
        volatile uint32_t TRNG0_SEC_CFG;  ///< Offset: 0xA0 - TRNG0 Security Configuration Register
        volatile uint32_t TRNG0_INT_CTRL;  ///< Offset: 0xA4 - TRNG0 Interrupt Control Register
        volatile uint32_t TRNG0_INT_MASK;  ///< Offset: 0xA8 - TRNG0 Mask Register
        volatile uint32_t TRNG0_INT_STATUS;  ///< Offset: 0xAC - TRNG0 Interrupt Status Register
        volatile uint32_t TRNG0_VID1;  ///< Offset: 0xF0 - TRNG0 Version ID Register (MS)
        volatile uint32_t TRNG0_VID2;  ///< Offset: 0xF4 - TRNG0 Version ID Register (LS)
    };

    /// Peripheral instances
    inline Registers* TRNG0 = reinterpret_cast<Registers*>(TRNG0_BASE);

    // Bit definitions
    /// TRNG0_MCTL Register bits
    namespace trng0_mctl_bits {
        constexpr uint32_t SAMP_MODE = (2 << 0);  ///< Sample Mode
        constexpr uint32_t OSC_DIV = (2 << 2);  ///< Oscillator Divide
        constexpr uint32_t UNUSED = (1U << 4);  ///< This bit is unused but write-able. Must be left as zero.
        constexpr uint32_t TRNG_ACC = (1U << 5);  ///< TRNG Access Mode
        constexpr uint32_t RST_DEF = (1U << 6);  ///< Reset Defaults
        constexpr uint32_t FOR_SCLK = (1U << 7);  ///< Force System Clock
        constexpr uint32_t FCT_FAIL = (1U << 8);  ///< Read only: Frequency Count Fail
        constexpr uint32_t FCT_VAL = (1U << 9);  ///< Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
        constexpr uint32_t ENT_VAL = (1U << 10);  ///< Read only: Entropy Valid
        constexpr uint32_t TST_OUT = (1U << 11);  ///< Read only: Test point inside ring oscillator.
        constexpr uint32_t ERR = (1U << 12);  ///< Read: Error status
        constexpr uint32_t TSTOP_OK = (1U << 13);  ///< TRNG_OK_TO_STOP
        constexpr uint32_t PRGM = (1U << 16);  ///< Programming Mode Select
    }

    /// TRNG0_SCMISC Register bits
    namespace trng0_scmisc_bits {
        constexpr uint32_t LRUN_MAX = (8 << 0);  ///< LONG RUN MAX LIMIT
        constexpr uint32_t RTY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_PKRRNG Register bits
    namespace trng0_pkrrng_bits {
        constexpr uint32_t PKR_RNG = (16 << 0);  ///< Poker Range
    }

    /// TRNG0_PKRMAX Register bits
    namespace trng0_pkrmax_bits {
        constexpr uint32_t PKR_MAX = (24 << 0);  ///< Poker Maximum Limit
    }

    /// TRNG0_PKRSQ Register bits
    namespace trng0_pkrsq_bits {
        constexpr uint32_t PKR_SQ = (24 << 0);  ///< Poker Square Calculation Result
    }

    /// TRNG0_SDCTL Register bits
    namespace trng0_sdctl_bits {
        constexpr uint32_t SAMP_SIZE = (16 << 0);  ///< Sample Size
        constexpr uint32_t ENT_DLY = (16 << 16);  ///< Entropy Delay
    }

    /// TRNG0_SBLIM Register bits
    namespace trng0_sblim_bits {
        constexpr uint32_t SB_LIM = (10 << 0);  ///< Sparse Bit Limit
    }

    /// TRNG0_TOTSAM Register bits
    namespace trng0_totsam_bits {
        constexpr uint32_t TOT_SAM = (20 << 0);  ///< Total Samples
    }

    /// TRNG0_FRQMIN Register bits
    namespace trng0_frqmin_bits {
        constexpr uint32_t FRQ_MIN = (22 << 0);  ///< Frequency Count Minimum Limit
    }

    /// TRNG0_FRQCNT Register bits
    namespace trng0_frqcnt_bits {
        constexpr uint32_t FRQ_CT = (22 << 0);  ///< Frequency Count
    }

    /// TRNG0_FRQMAX Register bits
    namespace trng0_frqmax_bits {
        constexpr uint32_t FRQ_MAX = (22 << 0);  ///< Frequency Counter Maximum Limit
    }

    /// TRNG0_SCMC Register bits
    namespace trng0_scmc_bits {
        constexpr uint32_t MONO_CT = (16 << 0);  ///< Monobit Count
    }

    /// TRNG0_SCML Register bits
    namespace trng0_scml_bits {
        constexpr uint32_t MONO_MAX = (16 << 0);  ///< Monobit Maximum Limit
        constexpr uint32_t MONO_RNG = (16 << 16);  ///< Monobit Range
    }

    /// TRNG0_SCR1C Register bits
    namespace trng0_scr1c_bits {
        constexpr uint32_t R1_0_CT = (15 << 0);  ///< Runs of Zero, Length 1 Count
        constexpr uint32_t R1_1_CT = (15 << 16);  ///< Runs of One, Length 1 Count
    }

    /// TRNG0_SCR1L Register bits
    namespace trng0_scr1l_bits {
        constexpr uint32_t RUN1_MAX = (15 << 0);  ///< Run Length 1 Maximum Limit
        constexpr uint32_t RUN1_RNG = (15 << 16);  ///< Run Length 1 Range
    }

    /// TRNG0_SCR2C Register bits
    namespace trng0_scr2c_bits {
        constexpr uint32_t R2_0_CT = (14 << 0);  ///< Runs of Zero, Length 2 Count
        constexpr uint32_t R2_1_CT = (14 << 16);  ///< Runs of One, Length 2 Count
    }

    /// TRNG0_SCR2L Register bits
    namespace trng0_scr2l_bits {
        constexpr uint32_t RUN2_MAX = (14 << 0);  ///< Run Length 2 Maximum Limit
        constexpr uint32_t RUN2_RNG = (14 << 16);  ///< Run Length 2 Range
    }

    /// TRNG0_SCR3C Register bits
    namespace trng0_scr3c_bits {
        constexpr uint32_t R3_0_CT = (13 << 0);  ///< Runs of Zeroes, Length 3 Count
        constexpr uint32_t R3_1_CT = (13 << 16);  ///< Runs of Ones, Length 3 Count
    }

    /// TRNG0_SCR3L Register bits
    namespace trng0_scr3l_bits {
        constexpr uint32_t RUN3_MAX = (13 << 0);  ///< Run Length 3 Maximum Limit
        constexpr uint32_t RUN3_RNG = (13 << 16);  ///< Run Length 3 Range
    }

    /// TRNG0_SCR4C Register bits
    namespace trng0_scr4c_bits {
        constexpr uint32_t R4_0_CT = (12 << 0);  ///< Runs of Zero, Length 4 Count
        constexpr uint32_t R4_1_CT = (12 << 16);  ///< Runs of One, Length 4 Count
    }

    /// TRNG0_SCR4L Register bits
    namespace trng0_scr4l_bits {
        constexpr uint32_t RUN4_MAX = (12 << 0);  ///< Run Length 4 Maximum Limit
        constexpr uint32_t RUN4_RNG = (12 << 16);  ///< Run Length 4 Range
    }

    /// TRNG0_SCR5C Register bits
    namespace trng0_scr5c_bits {
        constexpr uint32_t R5_0_CT = (11 << 0);  ///< Runs of Zero, Length 5 Count
        constexpr uint32_t R5_1_CT = (11 << 16);  ///< Runs of One, Length 5 Count
    }

    /// TRNG0_SCR5L Register bits
    namespace trng0_scr5l_bits {
        constexpr uint32_t RUN5_MAX = (11 << 0);  ///< Run Length 5 Maximum Limit
        constexpr uint32_t RUN5_RNG = (11 << 16);  ///< Run Length 5 Range
    }

    /// TRNG0_SCR6PC Register bits
    namespace trng0_scr6pc_bits {
        constexpr uint32_t R6P_0_CT = (11 << 0);  ///< Runs of Zero, Length 6+ Count
        constexpr uint32_t R6P_1_CT = (11 << 16);  ///< Runs of One, Length 6+ Count
    }

    /// TRNG0_SCR6PL Register bits
    namespace trng0_scr6pl_bits {
        constexpr uint32_t RUN6P_MAX = (11 << 0);  ///< Run Length 6+ Maximum Limit
        constexpr uint32_t RUN6P_RNG = (11 << 16);  ///< Run Length 6+ Range
    }

    /// TRNG0_STATUS Register bits
    namespace trng0_status_bits {
        constexpr uint32_t TF1BR0 = (1U << 0);  ///< Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF1BR1 = (1U << 1);  ///< Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF2BR0 = (1U << 2);  ///< Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF2BR1 = (1U << 3);  ///< Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF3BR0 = (1U << 4);  ///< Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF3BR1 = (1U << 5);  ///< Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF4BR0 = (1U << 6);  ///< Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF4BR1 = (1U << 7);  ///< Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF5BR0 = (1U << 8);  ///< Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
        constexpr uint32_t TF5BR1 = (1U << 9);  ///< Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
        constexpr uint32_t TF6PBR0 = (1U << 10);  ///< Test Fail, 6 Plus Bit Run, Sampling 0s
        constexpr uint32_t TF6PBR1 = (1U << 11);  ///< Test Fail, 6 Plus Bit Run, Sampling 1s
        constexpr uint32_t TFSB = (1U << 12);  ///< Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
        constexpr uint32_t TFLR = (1U << 13);  ///< Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
        constexpr uint32_t TFP = (1U << 14);  ///< Test Fail, Poker. If TFP=1, the Poker Test has failed.
        constexpr uint32_t TFMB = (1U << 15);  ///< Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
        constexpr uint32_t RETRY_CT = (4 << 16);  ///< RETRY COUNT
    }

    /// TRNG0_ENT0 Register bits
    namespace trng0_ent0_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT1 Register bits
    namespace trng0_ent1_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT2 Register bits
    namespace trng0_ent2_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT3 Register bits
    namespace trng0_ent3_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT4 Register bits
    namespace trng0_ent4_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT5 Register bits
    namespace trng0_ent5_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT6 Register bits
    namespace trng0_ent6_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT7 Register bits
    namespace trng0_ent7_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT8 Register bits
    namespace trng0_ent8_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT9 Register bits
    namespace trng0_ent9_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT10 Register bits
    namespace trng0_ent10_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT11 Register bits
    namespace trng0_ent11_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT12 Register bits
    namespace trng0_ent12_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT13 Register bits
    namespace trng0_ent13_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT14 Register bits
    namespace trng0_ent14_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_ENT15 Register bits
    namespace trng0_ent15_bits {
        constexpr uint32_t ENT = (32 << 0);  ///< Entropy Value
    }

    /// TRNG0_PKRCNT10 Register bits
    namespace trng0_pkrcnt10_bits {
        constexpr uint32_t PKR_0_CT = (16 << 0);  ///< Poker 0h Count
        constexpr uint32_t PKR_1_CT = (16 << 16);  ///< Poker 1h Count
    }

    /// TRNG0_PKRCNT32 Register bits
    namespace trng0_pkrcnt32_bits {
        constexpr uint32_t PKR_2_CT = (16 << 0);  ///< Poker 2h Count
        constexpr uint32_t PKR_3_CT = (16 << 16);  ///< Poker 3h Count
    }

    /// TRNG0_PKRCNT54 Register bits
    namespace trng0_pkrcnt54_bits {
        constexpr uint32_t PKR_4_CT = (16 << 0);  ///< Poker 4h Count
        constexpr uint32_t PKR_5_CT = (16 << 16);  ///< Poker 5h Count
    }

    /// TRNG0_PKRCNT76 Register bits
    namespace trng0_pkrcnt76_bits {
        constexpr uint32_t PKR_6_CT = (16 << 0);  ///< Poker 6h Count
        constexpr uint32_t PKR_7_CT = (16 << 16);  ///< Poker 7h Count
    }

    /// TRNG0_PKRCNT98 Register bits
    namespace trng0_pkrcnt98_bits {
        constexpr uint32_t PKR_8_CT = (16 << 0);  ///< Poker 8h Count
        constexpr uint32_t PKR_9_CT = (16 << 16);  ///< Poker 9h Count
    }

    /// TRNG0_PKRCNTBA Register bits
    namespace trng0_pkrcntba_bits {
        constexpr uint32_t PKR_A_CT = (16 << 0);  ///< Poker Ah Count
        constexpr uint32_t PKR_B_CT = (16 << 16);  ///< Poker Bh Count
    }

    /// TRNG0_PKRCNTDC Register bits
    namespace trng0_pkrcntdc_bits {
        constexpr uint32_t PKR_C_CT = (16 << 0);  ///< Poker Ch Count
        constexpr uint32_t PKR_D_CT = (16 << 16);  ///< Poker Dh Count
    }

    /// TRNG0_PKRCNTFE Register bits
    namespace trng0_pkrcntfe_bits {
        constexpr uint32_t PKR_E_CT = (16 << 0);  ///< Poker Eh Count
        constexpr uint32_t PKR_F_CT = (16 << 16);  ///< Poker Fh Count
    }

    /// TRNG0_SEC_CFG Register bits
    namespace trng0_sec_cfg_bits {
        constexpr uint32_t SH0 = (1U << 0);  ///< Reserved. DRNG specific, not applicable to this version.
        constexpr uint32_t NO_PRGM = (1U << 1);  ///< If set the TRNG registers cannot be programmed
        constexpr uint32_t SK_VAL = (1U << 2);  ///< Reserved. DRNG-specific, not applicable to this version.
    }

    /// TRNG0_INT_CTRL Register bits
    namespace trng0_int_ctrl_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
        constexpr uint32_t UNUSED = (29 << 3);  ///< Reserved but writeable.
    }

    /// TRNG0_INT_MASK Register bits
    namespace trng0_int_mask_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Same behavior as bit 0 above.
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Same behavior as bit 0 above.
    }

    /// TRNG0_INT_STATUS Register bits
    namespace trng0_int_status_bits {
        constexpr uint32_t HW_ERR = (1U << 0);  ///< Read: Error status
        constexpr uint32_t ENT_VAL = (1U << 1);  ///< Read only: Entropy Valid
        constexpr uint32_t FRQ_CT_FAIL = (1U << 2);  ///< Read only: Frequency Count Fail
    }

    /// TRNG0_VID1 Register bits
    namespace trng0_vid1_bits {
        constexpr uint32_t TRNG0_MIN_REV = (8 << 0);  ///< Shows the Freescale IP's Minor revision of the TRNG.
        constexpr uint32_t TRNG0_MAJ_REV = (8 << 8);  ///< Shows the Freescale IP's Major revision of the TRNG.
        constexpr uint32_t TRNG0_IP_ID = (16 << 16);  ///< Shows the Freescale IP ID.
    }

    /// TRNG0_VID2 Register bits
    namespace trng0_vid2_bits {
        constexpr uint32_t TRNG0_CONFIG_OPT = (8 << 0);  ///< Shows the Freescale IP's Configuaration options for the TRNG.
        constexpr uint32_t TRNG0_ECO_REV = (8 << 8);  ///< Shows the Freescale IP's ECO revision of the TRNG.
        constexpr uint32_t TRNG0_INTG_OPT = (8 << 16);  ///< Shows the Freescale integration options for the TRNG.
        constexpr uint32_t TRNG0_ERA = (8 << 24);  ///< Shows the Freescale compile options for the TRNG.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI0_BASE = 0x4002C000;
    constexpr uint32_t SPI1_BASE = 0x4002D000;
    constexpr uint32_t QuadSPI0_BASE = 0x4005A000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - Module Configuration Register
        volatile uint32_t TCR;  ///< Offset: 0x08 - Transfer Count Register
        volatile uint32_t CTAR;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Master Mode) (renamed from CTAR)
        volatile uint32_t CTAR_SLAVE;  ///< Offset: 0x0C - Clock and Transfer Attributes Register (In Slave Mode)
        volatile uint32_t SR;  ///< Offset: 0x2C - Status Register
        volatile uint32_t RSER;  ///< Offset: 0x30 - DMA/Interrupt Request Select and Enable Register
        volatile uint32_t PUSHR;  ///< Offset: 0x34 - PUSH TX FIFO Register In Master Mode
        volatile uint32_t PUSHR_SLAVE;  ///< Offset: 0x34 - PUSH TX FIFO Register In Slave Mode
        volatile uint32_t POPR;  ///< Offset: 0x38 - POP RX FIFO Register
        volatile uint32_t TXFR;  ///< Offset: 0x3C - Transmit FIFO Registers (renamed from TXFR)
        volatile uint32_t RXFR;  ///< Offset: 0x7C - Receive FIFO Registers (renamed from RXFR)
    };

    /// Peripheral instances
    inline Registers* SPI0 = reinterpret_cast<Registers*>(SPI0_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* QuadSPI0 = reinterpret_cast<Registers*>(QuadSPI0_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t HALT = (1U << 0);  ///< Halt
        constexpr uint32_t SMPL_PT = (2 << 8);  ///< Sample Point
        constexpr uint32_t CLR_RXF = (1U << 10);  ///< CLR_RXF
        constexpr uint32_t CLR_TXF = (1U << 11);  ///< Clear TX FIFO
        constexpr uint32_t DIS_RXF = (1U << 12);  ///< Disable Receive FIFO
        constexpr uint32_t DIS_TXF = (1U << 13);  ///< Disable Transmit FIFO
        constexpr uint32_t MDIS = (1U << 14);  ///< Module Disable
        constexpr uint32_t DOZE = (1U << 15);  ///< Doze Enable
        constexpr uint32_t PCSIS = (6 << 16);  ///< Peripheral Chip Select x Inactive State
        constexpr uint32_t ROOE = (1U << 24);  ///< Receive FIFO Overflow Overwrite Enable
        constexpr uint32_t PCSSE = (1U << 25);  ///< Peripheral Chip Select Strobe Enable
        constexpr uint32_t MTFE = (1U << 26);  ///< Modified Transfer Format Enable
        constexpr uint32_t FRZ = (1U << 27);  ///< Freeze
        constexpr uint32_t DCONF = (2 << 28);  ///< SPI Configuration.
        constexpr uint32_t CONT_SCKE = (1U << 30);  ///< Continuous SCK Enable
        constexpr uint32_t MSTR = (1U << 31);  ///< Master/Slave Mode Select
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t SPI_TCNT = (16 << 16);  ///< SPI Transfer Counter
    }

    /// CTAR Register bits
    namespace ctar_bits {
        constexpr uint32_t BR = (4 << 0);  ///< Baud Rate Scaler
        constexpr uint32_t DT = (4 << 4);  ///< Delay After Transfer Scaler
        constexpr uint32_t ASC = (4 << 8);  ///< After SCK Delay Scaler
        constexpr uint32_t CSSCK = (4 << 12);  ///< PCS to SCK Delay Scaler
        constexpr uint32_t PBR = (2 << 16);  ///< Baud Rate Prescaler
        constexpr uint32_t PDT = (2 << 18);  ///< Delay after Transfer Prescaler
        constexpr uint32_t PASC = (2 << 20);  ///< After SCK Delay Prescaler
        constexpr uint32_t PCSSCK = (2 << 22);  ///< PCS to SCK Delay Prescaler
        constexpr uint32_t LSBFE = (1U << 24);  ///< LSB First
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
        constexpr uint32_t DBR = (1U << 31);  ///< Double Baud Rate
    }

    /// CTAR_SLAVE Register bits
    namespace ctar_slave_bits {
        constexpr uint32_t CPHA = (1U << 25);  ///< Clock Phase
        constexpr uint32_t CPOL = (1U << 26);  ///< Clock Polarity
        constexpr uint32_t FMSZ = (4 << 27);  ///< Frame Size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t POPNXTPTR = (4 << 0);  ///< Pop Next Pointer
        constexpr uint32_t RXCTR = (4 << 4);  ///< RX FIFO Counter
        constexpr uint32_t TXNXTPTR = (4 << 8);  ///< Transmit Next Pointer
        constexpr uint32_t TXCTR = (4 << 12);  ///< TX FIFO Counter
        constexpr uint32_t RFDF = (1U << 17);  ///< Receive FIFO Drain Flag
        constexpr uint32_t RFOF = (1U << 19);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t TFFF = (1U << 25);  ///< Transmit FIFO Fill Flag
        constexpr uint32_t TFUF = (1U << 27);  ///< Transmit FIFO Underflow Flag
        constexpr uint32_t EOQF = (1U << 28);  ///< End of Queue Flag
        constexpr uint32_t TXRXS = (1U << 30);  ///< TX and RX Status
        constexpr uint32_t TCF = (1U << 31);  ///< Transfer Complete Flag
    }

    /// RSER Register bits
    namespace rser_bits {
        constexpr uint32_t RFDF_DIRS = (1U << 16);  ///< Receive FIFO Drain DMA or Interrupt Request Select
        constexpr uint32_t RFDF_RE = (1U << 17);  ///< Receive FIFO Drain Request Enable
        constexpr uint32_t RFOF_RE = (1U << 19);  ///< Receive FIFO Overflow Request Enable
        constexpr uint32_t TFFF_DIRS = (1U << 24);  ///< Transmit FIFO Fill DMA or Interrupt Request Select
        constexpr uint32_t TFFF_RE = (1U << 25);  ///< Transmit FIFO Fill Request Enable
        constexpr uint32_t TFUF_RE = (1U << 27);  ///< Transmit FIFO Underflow Request Enable
        constexpr uint32_t EOQF_RE = (1U << 28);  ///< Finished Request Enable
        constexpr uint32_t TCF_RE = (1U << 31);  ///< Transmission Complete Request Enable
    }

    /// PUSHR Register bits
    namespace pushr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t PCS = (6 << 16);  ///< Select which PCS signals are to be asserted for the transfer
        constexpr uint32_t CTCNT = (1U << 26);  ///< Clear Transfer Counter
        constexpr uint32_t EOQ = (1U << 27);  ///< End Of Queue
        constexpr uint32_t CTAS = (3 << 28);  ///< Clock and Transfer Attributes Select
        constexpr uint32_t CONT = (1U << 31);  ///< Continuous Peripheral Chip Select Enable
    }

    /// PUSHR_SLAVE Register bits
    namespace pushr_slave_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
    }

    /// POPR Register bits
    namespace popr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Received Data
    }

    /// TXFR Register bits
    namespace txfr_bits {
        constexpr uint32_t TXDATA = (16 << 0);  ///< Transmit Data
        constexpr uint32_t TXCMD_TXDATA = (16 << 16);  ///< Transmit Command or Transmit Data
    }

    /// RXFR Register bits
    namespace rxfr_bits {
        constexpr uint32_t RXDATA = (32 << 0);  ///< Receive Data
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40032000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DATA;  ///< Offset: 0x00 - CRC Data register
        volatile uint32_t CRCL;  ///< Offset: 0x00 - CRC_CRCL register.
        volatile uint32_t CRCLL;  ///< Offset: 0x00 - CRC_CRCLL register.
        volatile uint32_t CRCLU;  ///< Offset: 0x01 - CRC_CRCLU register.
        volatile uint32_t CRCH;  ///< Offset: 0x02 - CRC_CRCH register.
        volatile uint32_t CRCHL;  ///< Offset: 0x02 - CRC_CRCHL register.
        volatile uint32_t CRCHU;  ///< Offset: 0x03 - CRC_CRCHU register.
        volatile uint32_t GPOLY;  ///< Offset: 0x04 - CRC Polynomial register
        volatile uint32_t GPOLYL;  ///< Offset: 0x04 - CRC_GPOLYL register.
        volatile uint32_t GPOLYLL;  ///< Offset: 0x04 - CRC_GPOLYLL register.
        volatile uint32_t GPOLYLU;  ///< Offset: 0x05 - CRC_GPOLYLU register.
        volatile uint32_t GPOLYH;  ///< Offset: 0x06 - CRC_GPOLYH register.
        volatile uint32_t GPOLYHL;  ///< Offset: 0x06 - CRC_GPOLYHL register.
        volatile uint32_t GPOLYHU;  ///< Offset: 0x07 - CRC_GPOLYHU register.
        volatile uint32_t CTRL;  ///< Offset: 0x08 - CRC Control register
        volatile uint32_t CTRLHU;  ///< Offset: 0x0B - CRC_CTRLHU register.
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t LL = (8 << 0);  ///< CRC Low Lower Byte
        constexpr uint32_t LU = (8 << 8);  ///< CRC Low Upper Byte
        constexpr uint32_t HL = (8 << 16);  ///< CRC High Lower Byte
        constexpr uint32_t HU = (8 << 24);  ///< CRC High Upper Byte
    }

    /// CRCL Register bits
    namespace crcl_bits {
        constexpr uint32_t CRCL = (16 << 0);  ///< CRCL stores the lower 16 bits of the 16/32 bit CRC
    }

    /// CRCLL Register bits
    namespace crcll_bits {
        constexpr uint32_t CRCLL = (8 << 0);  ///< CRCLL stores the first 8 bits of the 32 bit CRC
    }

    /// CRCLU Register bits
    namespace crclu_bits {
        constexpr uint32_t CRCLU = (8 << 0);  ///< CRCLL stores the second 8 bits of the 32 bit CRC
    }

    /// CRCH Register bits
    namespace crch_bits {
        constexpr uint32_t CRCH = (16 << 0);  ///< CRCH stores the high 16 bits of the 16/32 bit CRC
    }

    /// CRCHL Register bits
    namespace crchl_bits {
        constexpr uint32_t CRCHL = (8 << 0);  ///< CRCHL stores the third 8 bits of the 32 bit CRC
    }

    /// CRCHU Register bits
    namespace crchu_bits {
        constexpr uint32_t CRCHU = (8 << 0);  ///< CRCHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// GPOLY Register bits
    namespace gpoly_bits {
        constexpr uint32_t LOW = (16 << 0);  ///< Low Polynominal Half-word
        constexpr uint32_t HIGH = (16 << 16);  ///< High Polynominal Half-word
    }

    /// GPOLYL Register bits
    namespace gpolyl_bits {
        constexpr uint32_t GPOLYL = (16 << 0);  ///< POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYLL Register bits
    namespace gpolyll_bits {
        constexpr uint32_t GPOLYLL = (8 << 0);  ///< POLYLL stores the first 8 bits of the 32 bit CRC
    }

    /// GPOLYLU Register bits
    namespace gpolylu_bits {
        constexpr uint32_t GPOLYLU = (8 << 0);  ///< POLYLL stores the second 8 bits of the 32 bit CRC
    }

    /// GPOLYH Register bits
    namespace gpolyh_bits {
        constexpr uint32_t GPOLYH = (16 << 0);  ///< POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
    }

    /// GPOLYHL Register bits
    namespace gpolyhl_bits {
        constexpr uint32_t GPOLYHL = (8 << 0);  ///< POLYHL stores the third 8 bits of the 32 bit CRC
    }

    /// GPOLYHU Register bits
    namespace gpolyhu_bits {
        constexpr uint32_t GPOLYHU = (8 << 0);  ///< POLYHU stores the fourth 8 bits of the 32 bit CRC
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t TCRC = (1U << 24);  ///< Width of CRC protocol.
        constexpr uint32_t WAS = (1U << 25);  ///< Write CRC Data Register As Seed
        constexpr uint32_t FXOR = (1U << 26);  ///< Complement Read Of CRC Data Register
        constexpr uint32_t TOTR = (2 << 28);  ///< Type Of Transpose For Read
        constexpr uint32_t TOT = (2 << 30);  ///< Type Of Transpose For Writes
    }

    /// CTRLHU Register bits
    namespace ctrlhu_bits {
        constexpr uint32_t TCRC = (1U << 0);  ///< no description available
        constexpr uint32_t WAS = (1U << 1);  ///< no description available
        constexpr uint32_t FXOR = (1U << 2);  ///< no description available
        constexpr uint32_t TOTR = (2 << 4);  ///< no description available
        constexpr uint32_t TOT = (2 << 6);  ///< no description available
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t PIT0_BASE = 0x40037000;
    constexpr uint32_t TPM0_BASE = 0x40038000;
    constexpr uint32_t TPM1_BASE = 0x40039000;
    constexpr uint32_t TPM2_BASE = 0x4003A000;
    constexpr uint32_t LPTMR0_BASE = 0x40040000;
    constexpr uint32_t LPTMR1_BASE = 0x40044000;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t MCR;  ///< Offset: 0x00 - PIT Module Control Register
        volatile uint32_t LTMR64H;  ///< Offset: 0xE0 - PIT Upper Lifetime Timer Register
        volatile uint32_t LTMR64L;  ///< Offset: 0xE4 - PIT Lower Lifetime Timer Register
        volatile uint32_t LDVAL;  ///< Offset: 0x100 - Timer Load Value Register (renamed from LDVAL)
        volatile uint32_t CVAL;  ///< Offset: 0x104 - Current Timer Value Register (renamed from CVAL)
        volatile uint32_t TCTRL;  ///< Offset: 0x108 - Timer Control Register (renamed from TCTRL)
        volatile uint32_t TFLG;  ///< Offset: 0x10C - Timer Flag Register (renamed from TFLG)
    };

    /// Peripheral instances
    inline Registers* PIT0 = reinterpret_cast<Registers*>(PIT0_BASE);
    inline Registers* TPM0 = reinterpret_cast<Registers*>(TPM0_BASE);
    inline Registers* TPM1 = reinterpret_cast<Registers*>(TPM1_BASE);
    inline Registers* TPM2 = reinterpret_cast<Registers*>(TPM2_BASE);
    inline Registers* LPTMR0 = reinterpret_cast<Registers*>(LPTMR0_BASE);
    inline Registers* LPTMR1 = reinterpret_cast<Registers*>(LPTMR1_BASE);

    // Bit definitions
    /// MCR Register bits
    namespace mcr_bits {
        constexpr uint32_t FRZ = (1U << 0);  ///< Freeze
        constexpr uint32_t MDIS = (1U << 1);  ///< Module Disable - (PIT section)
    }

    /// LTMR64H Register bits
    namespace ltmr64h_bits {
        constexpr uint32_t LTH = (32 << 0);  ///< Life Timer value
    }

    /// LTMR64L Register bits
    namespace ltmr64l_bits {
        constexpr uint32_t LTL = (32 << 0);  ///< Life Timer value
    }

    /// LDVAL Register bits
    namespace ldval_bits {
        constexpr uint32_t TSV = (32 << 0);  ///< Timer Start Value
    }

    /// CVAL Register bits
    namespace cval_bits {
        constexpr uint32_t TVL = (32 << 0);  ///< Current Timer Value
    }

    /// TCTRL Register bits
    namespace tctrl_bits {
        constexpr uint32_t TEN = (1U << 0);  ///< Timer Enable
        constexpr uint32_t TIE = (1U << 1);  ///< Timer Interrupt Enable
        constexpr uint32_t CHN = (1U << 2);  ///< Chain Mode
    }

    /// TFLG Register bits
    namespace tflg_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Timer Interrupt Flag
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC0_BASE = 0x4003B000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t SC1;  ///< Offset: 0x00 - ADC Status and Control Registers 1 (renamed from SC1)
        volatile uint32_t CFG1;  ///< Offset: 0x08 - ADC Configuration Register 1
        volatile uint32_t CFG2;  ///< Offset: 0x0C - ADC Configuration Register 2
        volatile uint32_t R;  ///< Offset: 0x10 - ADC Data Result Register (renamed from R)
        volatile uint32_t CV;  ///< Offset: 0x18 - Compare Value Registers (renamed from CV)
        volatile uint32_t SC2;  ///< Offset: 0x20 - Status and Control Register 2
        volatile uint32_t SC3;  ///< Offset: 0x24 - Status and Control Register 3
        volatile uint32_t OFS;  ///< Offset: 0x28 - ADC Offset Correction Register
        volatile uint32_t PG;  ///< Offset: 0x2C - ADC Plus-Side Gain Register
        volatile uint32_t MG;  ///< Offset: 0x30 - ADC Minus-Side Gain Register
        volatile uint32_t CLPD;  ///< Offset: 0x34 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLPS;  ///< Offset: 0x38 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP4;  ///< Offset: 0x3C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP3;  ///< Offset: 0x40 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP2;  ///< Offset: 0x44 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP1;  ///< Offset: 0x48 - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLP0;  ///< Offset: 0x4C - ADC Plus-Side General Calibration Value Register
        volatile uint32_t CLMD;  ///< Offset: 0x54 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLMS;  ///< Offset: 0x58 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM4;  ///< Offset: 0x5C - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM3;  ///< Offset: 0x60 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM2;  ///< Offset: 0x64 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM1;  ///< Offset: 0x68 - ADC Minus-Side General Calibration Value Register
        volatile uint32_t CLM0;  ///< Offset: 0x6C - ADC Minus-Side General Calibration Value Register
    };

    /// Peripheral instances
    inline Registers* ADC0 = reinterpret_cast<Registers*>(ADC0_BASE);

    // Bit definitions
    /// SC1 Register bits
    namespace sc1_bits {
        constexpr uint32_t ADCH = (5 << 0);  ///< Input channel select
        constexpr uint32_t DIFF = (1U << 5);  ///< Differential Mode Enable
        constexpr uint32_t AIEN = (1U << 6);  ///< Interrupt Enable
        constexpr uint32_t COCO = (1U << 7);  ///< Conversion Complete Flag
    }

    /// CFG1 Register bits
    namespace cfg1_bits {
        constexpr uint32_t ADICLK = (2 << 0);  ///< Input Clock Select
        constexpr uint32_t MODE = (2 << 2);  ///< Conversion mode selection
        constexpr uint32_t ADLSMP = (1U << 4);  ///< Sample Time Configuration
        constexpr uint32_t ADIV = (2 << 5);  ///< Clock Divide Select
        constexpr uint32_t ADLPC = (1U << 7);  ///< Low-Power Configuration
    }

    /// CFG2 Register bits
    namespace cfg2_bits {
        constexpr uint32_t ADLSTS = (2 << 0);  ///< Long Sample Time Select
        constexpr uint32_t ADHSC = (1U << 2);  ///< High-Speed Configuration
        constexpr uint32_t ADACKEN = (1U << 3);  ///< Asynchronous Clock Output Enable
        constexpr uint32_t MUXSEL = (1U << 4);  ///< ADC Mux Select
    }

    /// R Register bits
    namespace r_bits {
        constexpr uint32_t D = (16 << 0);  ///< Data result
    }

    /// CV Register bits
    namespace cv_bits {
        constexpr uint32_t CV = (16 << 0);  ///< Compare Value.
    }

    /// SC2 Register bits
    namespace sc2_bits {
        constexpr uint32_t REFSEL = (2 << 0);  ///< Voltage Reference Selection
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA Enable
        constexpr uint32_t ACREN = (1U << 3);  ///< Compare Function Range Enable
        constexpr uint32_t ACFGT = (1U << 4);  ///< Compare Function Greater Than Enable
        constexpr uint32_t ACFE = (1U << 5);  ///< Compare Function Enable
        constexpr uint32_t ADTRG = (1U << 6);  ///< Conversion Trigger Select
        constexpr uint32_t ADACT = (1U << 7);  ///< Conversion Active
    }

    /// SC3 Register bits
    namespace sc3_bits {
        constexpr uint32_t AVGS = (2 << 0);  ///< Hardware Average Select
        constexpr uint32_t AVGE = (1U << 2);  ///< Hardware Average Enable
        constexpr uint32_t ADCO = (1U << 3);  ///< Continuous Conversion Enable
        constexpr uint32_t CALF = (1U << 6);  ///< Calibration Failed Flag
        constexpr uint32_t CAL = (1U << 7);  ///< Calibration
    }

    /// OFS Register bits
    namespace ofs_bits {
        constexpr uint32_t OFS = (16 << 0);  ///< Offset Error Correction Value
    }

    /// PG Register bits
    namespace pg_bits {
        constexpr uint32_t PG = (16 << 0);  ///< Plus-Side Gain
    }

    /// MG Register bits
    namespace mg_bits {
        constexpr uint32_t MG = (16 << 0);  ///< Minus-Side Gain
    }

    /// CLPD Register bits
    namespace clpd_bits {
        constexpr uint32_t CLPD = (6 << 0);  ///< Calibration Value
    }

    /// CLPS Register bits
    namespace clps_bits {
        constexpr uint32_t CLPS = (6 << 0);  ///< Calibration Value
    }

    /// CLP4 Register bits
    namespace clp4_bits {
        constexpr uint32_t CLP4 = (10 << 0);  ///< Calibration Value
    }

    /// CLP3 Register bits
    namespace clp3_bits {
        constexpr uint32_t CLP3 = (9 << 0);  ///< Calibration Value
    }

    /// CLP2 Register bits
    namespace clp2_bits {
        constexpr uint32_t CLP2 = (8 << 0);  ///< Calibration Value
    }

    /// CLP1 Register bits
    namespace clp1_bits {
        constexpr uint32_t CLP1 = (7 << 0);  ///< Calibration Value
    }

    /// CLP0 Register bits
    namespace clp0_bits {
        constexpr uint32_t CLP0 = (6 << 0);  ///< Calibration Value
    }

    /// CLMD Register bits
    namespace clmd_bits {
        constexpr uint32_t CLMD = (6 << 0);  ///< Calibration Value
    }

    /// CLMS Register bits
    namespace clms_bits {
        constexpr uint32_t CLMS = (6 << 0);  ///< Calibration Value
    }

    /// CLM4 Register bits
    namespace clm4_bits {
        constexpr uint32_t CLM4 = (10 << 0);  ///< Calibration Value
    }

    /// CLM3 Register bits
    namespace clm3_bits {
        constexpr uint32_t CLM3 = (9 << 0);  ///< Calibration Value
    }

    /// CLM2 Register bits
    namespace clm2_bits {
        constexpr uint32_t CLM2 = (8 << 0);  ///< Calibration Value
    }

    /// CLM1 Register bits
    namespace clm1_bits {
        constexpr uint32_t CLM1 = (7 << 0);  ///< Calibration Value
    }

    /// CLM0 Register bits
    namespace clm0_bits {
        constexpr uint32_t CLM0 = (6 << 0);  ///< Calibration Value
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x4003D000;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TSR;  ///< Offset: 0x00 - RTC Time Seconds Register
        volatile uint32_t TPR;  ///< Offset: 0x04 - RTC Time Prescaler Register
        volatile uint32_t TAR;  ///< Offset: 0x08 - RTC Time Alarm Register
        volatile uint32_t TCR;  ///< Offset: 0x0C - RTC Time Compensation Register
        volatile uint32_t CR;  ///< Offset: 0x10 - RTC Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - RTC Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - RTC Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - RTC Interrupt Enable Register
        volatile uint32_t TTSR;  ///< Offset: 0x20 - RTC Tamper Time Seconds Register
        volatile uint32_t MER;  ///< Offset: 0x24 - RTC Monotonic Enable Register
        volatile uint32_t MCLR;  ///< Offset: 0x28 - RTC Monotonic Counter Low Register
        volatile uint32_t MCHR;  ///< Offset: 0x2C - RTC Monotonic Counter High Register
        volatile uint32_t TER;  ///< Offset: 0x30 - RTC Tamper Enable Register
        volatile uint32_t TDR;  ///< Offset: 0x34 - RTC Tamper Detect Register
        volatile uint32_t TTR;  ///< Offset: 0x38 - RTC Tamper Trim Register
        volatile uint32_t TIR;  ///< Offset: 0x3C - RTC Tamper Interrupt Register
        volatile uint32_t WAR;  ///< Offset: 0x800 - RTC Write Access Register
        volatile uint32_t RAR;  ///< Offset: 0x804 - RTC Read Access Register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);

    // Bit definitions
    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TSR = (32 << 0);  ///< Time Seconds Register
    }

    /// TPR Register bits
    namespace tpr_bits {
        constexpr uint32_t TPR = (16 << 0);  ///< Time Prescaler Register
    }

    /// TAR Register bits
    namespace tar_bits {
        constexpr uint32_t TAR = (32 << 0);  ///< Time Alarm Register
    }

    /// TCR Register bits
    namespace tcr_bits {
        constexpr uint32_t TCR = (8 << 0);  ///< Time Compensation Register
        constexpr uint32_t CIR = (8 << 8);  ///< Compensation Interval Register
        constexpr uint32_t TCV = (8 << 16);  ///< Time Compensation Value
        constexpr uint32_t CIC = (8 << 24);  ///< Compensation Interval Counter
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t WPE = (1U << 1);  ///< Wakeup Pin Enable
        constexpr uint32_t SUP = (1U << 2);  ///< Supervisor Access
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t WPS = (1U << 4);  ///< Wakeup Pin Select
        constexpr uint32_t OSCE = (1U << 8);  ///< Oscillator Enable
        constexpr uint32_t CLKO = (1U << 9);  ///< Clock Output
        constexpr uint32_t SC16P = (1U << 10);  ///< Oscillator 16pF Load Configure
        constexpr uint32_t SC8P = (1U << 11);  ///< Oscillator 8pF Load Configure
        constexpr uint32_t SC4P = (1U << 12);  ///< Oscillator 4pF Load Configure
        constexpr uint32_t SC2P = (1U << 13);  ///< Oscillator 2pF Load Configure
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TIF = (1U << 0);  ///< Time Invalid Flag
        constexpr uint32_t TOF = (1U << 1);  ///< Time Overflow Flag
        constexpr uint32_t TAF = (1U << 2);  ///< Time Alarm Flag
        constexpr uint32_t MOF = (1U << 3);  ///< Monotonic Overflow Flag
        constexpr uint32_t TCE = (1U << 4);  ///< Time Counter Enable
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t TCL = (1U << 3);  ///< Time Compensation Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
        constexpr uint32_t TTSL = (1U << 8);  ///< Tamper Time Seconds Lock
        constexpr uint32_t MEL = (1U << 9);  ///< Monotonic Enable Lock
        constexpr uint32_t MCLL = (1U << 10);  ///< Monotonic Counter Low Lock
        constexpr uint32_t MCHL = (1U << 11);  ///< Monotonic Counter High Lock
        constexpr uint32_t TEL = (1U << 12);  ///< Tamper Enable Lock
        constexpr uint32_t TDL = (1U << 13);  ///< Tamper Detect Lock
        constexpr uint32_t TTL = (1U << 14);  ///< Tamper Trim Lock
        constexpr uint32_t TIL = (1U << 15);  ///< Tamper Interrupt Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TIIE = (1U << 0);  ///< Time Invalid Interrupt Enable
        constexpr uint32_t TOIE = (1U << 1);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t TAIE = (1U << 2);  ///< Time Alarm Interrupt Enable
        constexpr uint32_t MOIE = (1U << 3);  ///< Monotonic Overflow Interrupt Enable
        constexpr uint32_t TSIE = (1U << 4);  ///< Time Seconds Interrupt Enable
        constexpr uint32_t WPON = (1U << 7);  ///< Wakeup Pin On
    }

    /// TTSR Register bits
    namespace ttsr_bits {
        constexpr uint32_t TTS = (32 << 0);  ///< Tamper Time Seconds
    }

    /// MER Register bits
    namespace mer_bits {
        constexpr uint32_t MCE = (1U << 4);  ///< Monotonic Counter Enable
    }

    /// MCLR Register bits
    namespace mclr_bits {
        constexpr uint32_t MCL = (32 << 0);  ///< Monotonic Counter Low
    }

    /// MCHR Register bits
    namespace mchr_bits {
        constexpr uint32_t MCH = (32 << 0);  ///< Monotonic Counter High
    }

    /// TER Register bits
    namespace ter_bits {
        constexpr uint32_t VTE = (1U << 1);  ///< Voltage Tamper Enable
        constexpr uint32_t CTE = (1U << 2);  ///< Clock Tamper Enable
        constexpr uint32_t TTE = (1U << 3);  ///< Temperature Tamper Enable
        constexpr uint32_t FSE = (1U << 4);  ///< Flash Security Enable
        constexpr uint32_t TME = (1U << 5);  ///< Test Mode Enable
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t VTF = (1U << 1);  ///< Voltage Tamper Flag
        constexpr uint32_t CTF = (1U << 2);  ///< Clock Tamper Flag
        constexpr uint32_t TTF = (1U << 3);  ///< Temperature Tamper Flag
        constexpr uint32_t FSF = (1U << 4);  ///< Flash Security Flag
        constexpr uint32_t TMF = (1U << 5);  ///< Test Mode Flag
    }

    /// TTR Register bits
    namespace ttr_bits {
        constexpr uint32_t VDTL = (3 << 0);  ///< Voltage Detect Trim Low
        constexpr uint32_t VDTH = (3 << 3);  ///< Voltage Detect Trim High
        constexpr uint32_t CDTL = (3 << 6);  ///< Clock Detect Trim Low
        constexpr uint32_t CDTH = (3 << 9);  ///< Clock Detect Trim High
        constexpr uint32_t TDTL = (5 << 12);  ///< Temperature Detect Trim Low
        constexpr uint32_t TDTH = (5 << 17);  ///< Temperature Detect Trim High
    }

    /// TIR Register bits
    namespace tir_bits {
        constexpr uint32_t VTIE = (1U << 1);  ///< Voltage Tamper Interrupt Enable
        constexpr uint32_t CTIE = (1U << 2);  ///< Clock Tamper Interrupt Enable
        constexpr uint32_t TTIE = (1U << 3);  ///< Temperature Tamper Interrupt Enable
        constexpr uint32_t FSIE = (1U << 4);  ///< Flash Security Interrupt Enable
        constexpr uint32_t TMIE = (1U << 5);  ///< Test Mode Interrupt Enable
    }

    /// WAR Register bits
    namespace war_bits {
        constexpr uint32_t TSRW = (1U << 0);  ///< Time Seconds Register Write
        constexpr uint32_t TPRW = (1U << 1);  ///< Time Prescaler Register Write
        constexpr uint32_t TARW = (1U << 2);  ///< Time Alarm Register Write
        constexpr uint32_t TCRW = (1U << 3);  ///< Time Compensation Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IERW = (1U << 7);  ///< Interrupt Enable Register Write
        constexpr uint32_t TTSW = (1U << 8);  ///< Tamper Time Seconds Write
        constexpr uint32_t MERW = (1U << 9);  ///< Monotonic Enable Register Write
        constexpr uint32_t MCLW = (1U << 10);  ///< Monotonic Counter Low Write
        constexpr uint32_t MCHW = (1U << 11);  ///< Monotonic Counter High Write
        constexpr uint32_t TERW = (1U << 12);  ///< Tamper Enable Register Write
        constexpr uint32_t TDRW = (1U << 13);  ///< Tamper Detect Register Write
        constexpr uint32_t TTRW = (1U << 14);  ///< Tamper Trim Register Write
        constexpr uint32_t TIRW = (1U << 15);  ///< Tamper Interrupt Register Write
    }

    /// RAR Register bits
    namespace rar_bits {
        constexpr uint32_t TSRR = (1U << 0);  ///< Time Seconds Register Read
        constexpr uint32_t TPRR = (1U << 1);  ///< Time Prescaler Register Read
        constexpr uint32_t TARR = (1U << 2);  ///< Time Alarm Register Read
        constexpr uint32_t TCRR = (1U << 3);  ///< Time Compensation Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IERR = (1U << 7);  ///< Interrupt Enable Register Read
        constexpr uint32_t TTSR = (1U << 8);  ///< Tamper Time Seconds Read
        constexpr uint32_t MERR = (1U << 9);  ///< Monotonic Enable Register Read
        constexpr uint32_t MCLR = (1U << 10);  ///< Monotonic Counter Low Read
        constexpr uint32_t MCHR = (1U << 11);  ///< Monotonic Counter High Read
        constexpr uint32_t TERR = (1U << 12);  ///< Tamper Enable Register Read
        constexpr uint32_t TDRR = (1U << 13);  ///< Tamper Detect Register Read
        constexpr uint32_t TTRR = (1U << 14);  ///< Tamper Trim Register Read
        constexpr uint32_t TIRR = (1U << 15);  ///< Tamper Interrupt Register Read
    }

}

// ============================================================================
// RFVBAT Peripheral
// ============================================================================

namespace rfvbat {
    /// Base addresses
    constexpr uint32_t RFVBAT_BASE = 0x4003E000;

    /// RFVBAT Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - VBAT register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFVBAT = reinterpret_cast<Registers*>(RFVBAT_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC0_BASE = 0x4003F000;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DATL;  ///< Offset: 0x00 - DAC Data Low Register (renamed from DATL)
        volatile uint32_t DATH;  ///< Offset: 0x01 - DAC Data High Register (renamed from DATH)
        volatile uint32_t SR;  ///< Offset: 0x20 - DAC Status Register
        volatile uint32_t C0;  ///< Offset: 0x21 - DAC Control Register
        volatile uint32_t C1;  ///< Offset: 0x22 - DAC Control Register 1
        volatile uint32_t C2;  ///< Offset: 0x23 - DAC Control Register 2
    };

    /// Peripheral instances
    inline Registers* DAC0 = reinterpret_cast<Registers*>(DAC0_BASE);

    // Bit definitions
    /// DATL Register bits
    namespace datl_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< DATA0
    }

    /// DATH Register bits
    namespace dath_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< DATA1
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DACBFRPBF = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Position Flag
        constexpr uint32_t DACBFRPTF = (1U << 1);  ///< DAC Buffer Read Pointer Top Position Flag
        constexpr uint32_t DACBFWMF = (1U << 2);  ///< DAC Buffer Watermark Flag
    }

    /// C0 Register bits
    namespace c0_bits {
        constexpr uint32_t DACBBIEN = (1U << 0);  ///< DAC Buffer Read Pointer Bottom Flag Interrupt Enable
        constexpr uint32_t DACBTIEN = (1U << 1);  ///< DAC Buffer Read Pointer Top Flag Interrupt Enable
        constexpr uint32_t DACBWIEN = (1U << 2);  ///< DAC Buffer Watermark Interrupt Enable
        constexpr uint32_t LPEN = (1U << 3);  ///< DAC Low Power Control
        constexpr uint32_t DACSWTRG = (1U << 4);  ///< DAC Software Trigger
        constexpr uint32_t DACTRGSEL = (1U << 5);  ///< DAC Trigger Select
        constexpr uint32_t DACRFS = (1U << 6);  ///< DAC Reference Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DACBFEN = (1U << 0);  ///< DAC Buffer Enable
        constexpr uint32_t DACBFMD = (2 << 1);  ///< DAC Buffer Work Mode Select
        constexpr uint32_t DACBFWM = (2 << 3);  ///< DAC Buffer Watermark Select
        constexpr uint32_t DMAEN = (1U << 7);  ///< DMA Enable Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t DACBFUP = (4 << 0);  ///< DAC Buffer Upper Limit
        constexpr uint32_t DACBFRP = (4 << 4);  ///< DAC Buffer Read Pointer
    }

}

// ============================================================================
// RFSYS Peripheral
// ============================================================================

namespace rfsys {
    /// Base addresses
    constexpr uint32_t RFSYS_BASE = 0x40041000;

    /// RFSYS Register structure
    struct Registers {
        volatile uint32_t REG;  ///< Offset: 0x00 - Register file register (renamed from REG)
    };

    /// Peripheral instances
    inline Registers* RFSYS = reinterpret_cast<Registers*>(RFSYS_BASE);

    // Bit definitions
    /// REG Register bits
    namespace reg_bits {
        constexpr uint32_t LL = (8 << 0);  ///< Low lower byte
        constexpr uint32_t LH = (8 << 8);  ///< Low higher byte
        constexpr uint32_t HL = (8 << 16);  ///< High lower byte
        constexpr uint32_t HH = (8 << 24);  ///< High higher byte
    }

}

// ============================================================================
// DRY Peripheral
// ============================================================================

namespace dry {
    /// Base addresses
    constexpr uint32_t DRY_BASE = 0x40042000;

    /// DRY Register structure
    struct Registers {
        volatile uint32_t SKVR;  ///< Offset: 0x04 - DryIce Secure Key Valid Register
        volatile uint32_t SKWLR;  ///< Offset: 0x08 - DryIce Secure Key Write Lock Register
        volatile uint32_t SKRLR;  ///< Offset: 0x0C - DryIce Secure Key Read Lock Register
        volatile uint32_t CR;  ///< Offset: 0x10 - DryIce Control Register
        volatile uint32_t SR;  ///< Offset: 0x14 - DryIce Status Register
        volatile uint32_t LR;  ///< Offset: 0x18 - DryIce Lock Register
        volatile uint32_t IER;  ///< Offset: 0x1C - DryIce Interrupt Enable Register
        volatile uint32_t TSR;  ///< Offset: 0x20 - DryIce Tamper Seconds Register
        volatile uint32_t TER;  ///< Offset: 0x24 - DryIce Tamper Enable Register
        volatile uint32_t PDR;  ///< Offset: 0x28 - DryIce Pin Direction Register
        volatile uint32_t PPR;  ///< Offset: 0x2C - DryIce Pin Polarity Register
        volatile uint32_t ATR;  ///< Offset: 0x30 - DryIce Active Tamper Register (renamed from ATR)
        volatile uint32_t PGFR;  ///< Offset: 0x40 - DryIce Pin Glitch Filter Register (renamed from PGFR)
        volatile uint32_t WAC;  ///< Offset: 0x800 - DryIce Write Access Control Register
        volatile uint32_t RAC;  ///< Offset: 0x804 - DryIce Read Access Control Register
        volatile uint32_t SKR;  ///< Offset: 0x1000 - Secure Key Register (renamed from SKR)
        volatile uint32_t SWAC;  ///< Offset: 0x1800 - Secure Write Access Control
        volatile uint32_t SRAC;  ///< Offset: 0x1804 - Secure Read Access Control
    };

    /// Peripheral instances
    inline Registers* DRY = reinterpret_cast<Registers*>(DRY_BASE);

    // Bit definitions
    /// SKVR Register bits
    namespace skvr_bits {
        constexpr uint32_t SKV = (8 << 0);  ///< Secure Key Valid
    }

    /// SKWLR Register bits
    namespace skwlr_bits {
        constexpr uint32_t SKWL = (8 << 0);  ///< Secure Key Write Lock
    }

    /// SKRLR Register bits
    namespace skrlr_bits {
        constexpr uint32_t SKRL = (8 << 0);  ///< Secure Key Read Lock
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SWR = (1U << 0);  ///< Software Reset
        constexpr uint32_t DEN = (1U << 1);  ///< DryIce Enable
        constexpr uint32_t TFSR = (1U << 2);  ///< Tamper Force System Reset
        constexpr uint32_t UM = (1U << 3);  ///< Update Mode
        constexpr uint32_t ATCS = (2 << 4);  ///< Active Tamper Clock Source
        constexpr uint32_t THYS = (1U << 8);  ///< Tamper Hysteresis Select
        constexpr uint32_t TPFE = (1U << 9);  ///< Tamper Passive Filter Enable
        constexpr uint32_t TDSE = (1U << 10);  ///< Tamper Drive Strength Enable
        constexpr uint32_t TSRE = (1U << 11);  ///< Tamper Slew Rate Enable
        constexpr uint32_t SRF = (2 << 14);  ///< Secure Register File
        constexpr uint32_t DPR = (15 << 17);  ///< DryIce Prescaler Register
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t DTF = (1U << 0);  ///< DryIce Tamper Flag
        constexpr uint32_t TAF = (1U << 1);  ///< Tamper Acknowledge Flag
        constexpr uint32_t TOF = (1U << 2);  ///< Time Overflow Flag
        constexpr uint32_t MOF = (1U << 3);  ///< Monotonic Overflow Flag
        constexpr uint32_t VTF = (1U << 4);  ///< Voltage Tamper Flag
        constexpr uint32_t CTF = (1U << 5);  ///< Clock Tamper Flag
        constexpr uint32_t TTF = (1U << 6);  ///< Temperature Tamper Flag
        constexpr uint32_t STF = (1U << 7);  ///< Security Tamper Flag
        constexpr uint32_t FSF = (1U << 8);  ///< Flash Security Flag
        constexpr uint32_t TMF = (1U << 9);  ///< Test Mode Flag
        constexpr uint32_t TPF = (8 << 16);  ///< Tamper Pin Flag
    }

    /// LR Register bits
    namespace lr_bits {
        constexpr uint32_t KVL = (1U << 1);  ///< Key Valid Lock
        constexpr uint32_t KWL = (1U << 2);  ///< Key Write Lock
        constexpr uint32_t KRL = (1U << 3);  ///< Key Read Lock
        constexpr uint32_t CRL = (1U << 4);  ///< Control Register Lock
        constexpr uint32_t SRL = (1U << 5);  ///< Status Register Lock
        constexpr uint32_t LRL = (1U << 6);  ///< Lock Register Lock
        constexpr uint32_t IEL = (1U << 7);  ///< Interrupt Enable Lock
        constexpr uint32_t TSL = (1U << 8);  ///< Tamper Seconds Lock
        constexpr uint32_t TEL = (1U << 9);  ///< Tamper Enable Lock
        constexpr uint32_t PDL = (1U << 10);  ///< Pin Direction Lock
        constexpr uint32_t PPL = (1U << 11);  ///< Pin Polarity Lock
        constexpr uint32_t ATL = (2 << 12);  ///< Active Tamper Lock
        constexpr uint32_t GFL = (8 << 16);  ///< Glitch Filter Lock
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t DTIE = (1U << 0);  ///< DryIce Tamper Interrupt Enable
        constexpr uint32_t TOIE = (1U << 2);  ///< Time Overflow Interrupt Enable
        constexpr uint32_t MOIE = (1U << 3);  ///< Monotonic Overflow Interrupt Enable
        constexpr uint32_t VTIE = (1U << 4);  ///< Voltage Tamper Interrupt Enable
        constexpr uint32_t CTIE = (1U << 5);  ///< Clock Tamper Interrupt Enable
        constexpr uint32_t TTIE = (1U << 6);  ///< Temperature Tamper Interrupt Enable
        constexpr uint32_t STIE = (1U << 7);  ///< Security Tamper Interrupt Enable
        constexpr uint32_t FSIE = (1U << 8);  ///< Flash Security Interrupt Enable
        constexpr uint32_t TMIE = (1U << 9);  ///< Test Mode Interrupt Enable
        constexpr uint32_t TPIE = (8 << 16);  ///< Tamper Pin Interrupt Enable
    }

    /// TSR Register bits
    namespace tsr_bits {
        constexpr uint32_t TTS = (32 << 0);  ///< Tamper Time Seconds
    }

    /// TER Register bits
    namespace ter_bits {
        constexpr uint32_t TOE = (1U << 2);  ///< Time Overflow Enable
        constexpr uint32_t MOE = (1U << 3);  ///< Monotonic Overflow Enable
        constexpr uint32_t VTE = (1U << 4);  ///< Voltage Tamper Enable
        constexpr uint32_t CTE = (1U << 5);  ///< Clock Tamper Enable
        constexpr uint32_t TTE = (1U << 6);  ///< Temperature Tamper Enable
        constexpr uint32_t STE = (1U << 7);  ///< Security Tamper Enable
        constexpr uint32_t FSE = (1U << 8);  ///< Flash Security Enable
        constexpr uint32_t TME = (1U << 9);  ///< Test Mode Enable
        constexpr uint32_t TPE = (8 << 16);  ///< Tamper Pin Enable
    }

    /// PDR Register bits
    namespace pdr_bits {
        constexpr uint32_t TPD = (8 << 0);  ///< Tamper Pin Direction
        constexpr uint32_t TPOD = (8 << 16);  ///< Tamper Pin Output Data
    }

    /// PPR Register bits
    namespace ppr_bits {
        constexpr uint32_t TPP = (8 << 0);  ///< Tamper Pin Polarity
        constexpr uint32_t TPID = (8 << 16);  ///< Tamper Pin Input Data
    }

    /// ATR Register bits
    namespace atr_bits {
        constexpr uint32_t ATSR = (16 << 0);  ///< Active Tamper Shift Register
        constexpr uint32_t ATP = (16 << 16);  ///< Active Tamper Polynomial
    }

    /// PGFR Register bits
    namespace pgfr_bits {
        constexpr uint32_t GFW = (6 << 0);  ///< Glitch Filter Width
        constexpr uint32_t GFP = (1U << 6);  ///< Glitch Filter Prescaler
        constexpr uint32_t GFE = (1U << 7);  ///< Glitch Filter Enable
        constexpr uint32_t TPSW = (2 << 8);  ///< Tamper Pin Sample Width
        constexpr uint32_t TPSF = (2 << 10);  ///< Tamper Pin Sample Frequency
        constexpr uint32_t TPEX = (2 << 16);  ///< Tamper Pin Expected
        constexpr uint32_t TPE = (1U << 24);  ///< Tamper Pull Enable
        constexpr uint32_t TPS = (1U << 25);  ///< Tamper Pull Select
    }

    /// WAC Register bits
    namespace wac_bits {
        constexpr uint32_t SKVW = (1U << 1);  ///< Secure Key Valid Write
        constexpr uint32_t SKWRW = (1U << 2);  ///< Secure Key Write Lock Register Write
        constexpr uint32_t SKRRW = (1U << 3);  ///< Secure Key Read Lock Register Write
        constexpr uint32_t CRW = (1U << 4);  ///< Control Register Write
        constexpr uint32_t SRW = (1U << 5);  ///< Status Register Write
        constexpr uint32_t LRW = (1U << 6);  ///< Lock Register Write
        constexpr uint32_t IEW = (1U << 7);  ///< Interrupt Enable Write
        constexpr uint32_t TSRW = (1U << 8);  ///< Tamper Seconds Register Write
        constexpr uint32_t TEW = (1U << 9);  ///< Tamper Enable Write
        constexpr uint32_t PDW = (1U << 10);  ///< Pin Direction Write
        constexpr uint32_t PPW = (1U << 11);  ///< Pin Polarity Write
        constexpr uint32_t ATW = (2 << 12);  ///< Active Tamper Write
        constexpr uint32_t GFW = (8 << 16);  ///< Glitch Filter Write
    }

    /// RAC Register bits
    namespace rac_bits {
        constexpr uint32_t SKVR = (1U << 1);  ///< Secure Key Valid Read
        constexpr uint32_t SKWRR = (1U << 2);  ///< Secure Key Write Lock Register Read
        constexpr uint32_t SKRRR = (1U << 3);  ///< Secure Key Read Lock Register Read
        constexpr uint32_t CRR = (1U << 4);  ///< Control Register Read
        constexpr uint32_t SRR = (1U << 5);  ///< Status Register Read
        constexpr uint32_t LRR = (1U << 6);  ///< Lock Register Read
        constexpr uint32_t IER = (1U << 7);  ///< Interrupt Enable Read
        constexpr uint32_t TSRR = (1U << 8);  ///< Tamper Seconds Register Read
        constexpr uint32_t TER = (1U << 9);  ///< Tamper Enable Read
        constexpr uint32_t PDR = (1U << 10);  ///< Pin Direction Read
        constexpr uint32_t PPR = (1U << 11);  ///< Pin Polarity Read
        constexpr uint32_t ATR = (2 << 12);  ///< Active Tamper Read
        constexpr uint32_t GFR = (8 << 16);  ///< Glitch Filter Read
    }

    /// SKR Register bits
    namespace skr_bits {
        constexpr uint32_t SK = (32 << 0);  ///< Secure Key
    }

    /// SWAC Register bits
    namespace swac_bits {
        constexpr uint32_t SKRW = (8 << 0);  ///< Secure Key Register Write
    }

    /// SRAC Register bits
    namespace srac_bits {
        constexpr uint32_t SKRR = (8 << 0);  ///< Secure Key Register Read
    }

}

// ============================================================================
// TSI0 Peripheral
// ============================================================================

namespace tsi0 {
    /// Base addresses
    constexpr uint32_t TSI0_BASE = 0x40045000;

    /// TSI0 Register structure
    struct Registers {
        volatile uint32_t GENCS;  ///< Offset: 0x00 - TSI General Control and Status Register
        volatile uint32_t DATA;  ///< Offset: 0x04 - TSI DATA Register
        volatile uint32_t TSHD;  ///< Offset: 0x08 - TSI Threshold Register
    };

    /// Peripheral instances
    inline Registers* TSI0 = reinterpret_cast<Registers*>(TSI0_BASE);

    // Bit definitions
    /// GENCS Register bits
    namespace gencs_bits {
        constexpr uint32_t EOSDMEO = (1U << 0);  ///< End-of-Scan DMA Transfer Request Enable Only
        constexpr uint32_t CURSW = (1U << 1);  ///< CURSW
        constexpr uint32_t EOSF = (1U << 2);  ///< End of Scan Flag
        constexpr uint32_t SCNIP = (1U << 3);  ///< Scan In Progress Status
        constexpr uint32_t STM = (1U << 4);  ///< Scan Trigger Mode
        constexpr uint32_t STPE = (1U << 5);  ///< TSI STOP Enable
        constexpr uint32_t TSIIEN = (1U << 6);  ///< Touch Sensing Input Interrupt Enable
        constexpr uint32_t TSIEN = (1U << 7);  ///< Touch Sensing Input Module Enable
        constexpr uint32_t NSCN = (5 << 8);  ///< NSCN
        constexpr uint32_t PS = (3 << 13);  ///< PS
        constexpr uint32_t EXTCHRG = (3 << 16);  ///< EXTCHRG
        constexpr uint32_t DVOLT = (2 << 19);  ///< DVOLT
        constexpr uint32_t REFCHRG = (3 << 21);  ///< REFCHRG
        constexpr uint32_t MODE = (4 << 24);  ///< TSI analog modes setup and status bits.
        constexpr uint32_t ESOR = (1U << 28);  ///< End-of-scan or Out-of-Range Interrupt Selection
        constexpr uint32_t OUTRGF = (1U << 31);  ///< Out of Range Flag.
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t TSICNT = (16 << 0);  ///< TSI Conversion Counter Value
        constexpr uint32_t SWTS = (1U << 22);  ///< Software Trigger Start
        constexpr uint32_t DMAEN = (1U << 23);  ///< DMA Transfer Enabled
        constexpr uint32_t TSICH = (4 << 28);  ///< TSICH
    }

    /// TSHD Register bits
    namespace tshd_bits {
        constexpr uint32_t THRESL = (16 << 0);  ///< TSI Wakeup Channel Low-threshold
        constexpr uint32_t THRESH = (16 << 16);  ///< TSI Wakeup Channel High-threshold
    }

}

// ============================================================================
// SIM Peripheral
// ============================================================================

namespace sim {
    /// Base addresses
    constexpr uint32_t SIM_BASE = 0x40047000;

    /// SIM Register structure
    struct Registers {
        volatile uint32_t SOPT1;  ///< Offset: 0x00 - System Options Register 1
        volatile uint32_t SOPT2;  ///< Offset: 0x1004 - System Options Register 2
        volatile uint32_t SOPT5;  ///< Offset: 0x1010 - System Options Register 5
        volatile uint32_t SOPT7;  ///< Offset: 0x1018 - System Options Register 7
        volatile uint32_t SOPT9;  ///< Offset: 0x1020 - System Options Register 9
        volatile uint32_t SDID;  ///< Offset: 0x1024 - System Device Identification Register
        volatile uint32_t SCGC4;  ///< Offset: 0x1034 - System Clock Gating Control Register 4
        volatile uint32_t SCGC5;  ///< Offset: 0x1038 - System Clock Gating Control Register 5
        volatile uint32_t SCGC6;  ///< Offset: 0x103C - System Clock Gating Control Register 6
        volatile uint32_t SCGC7;  ///< Offset: 0x1040 - System Clock Gating Control Register 7
        volatile uint32_t CLKDIV1;  ///< Offset: 0x1044 - System Clock Divider Register 1
        volatile uint32_t CLKDIV2;  ///< Offset: 0x1048 - System Clock Divider Register 2
        volatile uint32_t FCFG1;  ///< Offset: 0x104C - Flash Configuration Register 1
        volatile uint32_t FCFG2;  ///< Offset: 0x1050 - Flash Configuration Register 2
        volatile uint32_t UIDH;  ///< Offset: 0x1054 - Unique Identification Register High
        volatile uint32_t UIDMH;  ///< Offset: 0x1058 - Unique Identification Register Mid-High
        volatile uint32_t UIDML;  ///< Offset: 0x105C - Unique Identification Register Mid Low
        volatile uint32_t UIDL;  ///< Offset: 0x1060 - Unique Identification Register Low
        volatile uint32_t CLKDIV3;  ///< Offset: 0x1064 - System Clock Divider Register 3
        volatile uint32_t MISCCTRL;  ///< Offset: 0x106C - Misc Control Register
        volatile uint32_t SECKEY0;  ///< Offset: 0x1090 - Secure Key Register 0
        volatile uint32_t SECKEY1;  ///< Offset: 0x1094 - Secure Key Register 1
        volatile uint32_t SECKEY2;  ///< Offset: 0x1098 - Secure Key Register 2
        volatile uint32_t SECKEY3;  ///< Offset: 0x109C - Secure Key Register 3
    };

    /// Peripheral instances
    inline Registers* SIM = reinterpret_cast<Registers*>(SIM_BASE);

    // Bit definitions
    /// SOPT1 Register bits
    namespace sopt1_bits {
        constexpr uint32_t RAMSIZE = (4 << 12);  ///< System RAM Size
        constexpr uint32_t OSC32KSEL = (2 << 18);  ///< 32K Oscillator Clock Select
    }

    /// SOPT2 Register bits
    namespace sopt2_bits {
        constexpr uint32_t RTCCLKOUTS = (1U << 4);  ///< RTC clock out select
        constexpr uint32_t CLKOUT = (3 << 5);  ///< CLKOUT select
        constexpr uint32_t PLLFLLSEL = (2 << 16);  ///< PLL/FLL clock select
        constexpr uint32_t USBSRC = (1U << 18);  ///< USB clock source select
        constexpr uint32_t FLEXIOSRC = (2 << 22);  ///< FlexIO Module Clock Source Select
        constexpr uint32_t TPMSRC = (2 << 24);  ///< TPM clock source select
        constexpr uint32_t LPUARTSRC = (2 << 26);  ///< LPUART clock source select
        constexpr uint32_t EMVSIMSRC = (2 << 30);  ///< EMVSIM Module Clock Source Select
    }

    /// SOPT5 Register bits
    namespace sopt5_bits {
        constexpr uint32_t LPUART0TXSRC = (2 << 16);  ///< LPUART0 transmit data source select
        constexpr uint32_t LPUART0RXSRC = (2 << 18);  ///< LPUART 0 receive data source select
        constexpr uint32_t LPUART1TXSRC = (2 << 20);  ///< LPUART1 transmit data source select
        constexpr uint32_t LPUART1RXSRC = (2 << 22);  ///< LPUART1 receive data source select
    }

    /// SOPT7 Register bits
    namespace sopt7_bits {
        constexpr uint32_t ADC0TRGSEL = (4 << 0);  ///< ADC0 trigger select
        constexpr uint32_t ADC0PRETRGSEL = (1U << 4);  ///< ADC0 pretrigger select
    }

    /// SOPT9 Register bits
    namespace sopt9_bits {
        constexpr uint32_t TPM1CH0SRC = (2 << 18);  ///< TPM1 channel 0 input capture source select
        constexpr uint32_t TPM2CH0SRC = (2 << 20);  ///< TPM2 channel 0 input capture source select
        constexpr uint32_t TPM0CLKSEL = (1U << 24);  ///< TPM0 External Clock Pin Select
        constexpr uint32_t TPM1CLKSEL = (1U << 25);  ///< TPM1 External Clock Pin Select
        constexpr uint32_t TPM2CLKSEL = (1U << 26);  ///< TPM2 External Clock Pin Select
    }

    /// SDID Register bits
    namespace sdid_bits {
        constexpr uint32_t PINID = (4 << 0);  ///< Pincount identification
        constexpr uint32_t FAMID = (3 << 4);  ///< Kinetis family ID
        constexpr uint32_t DIEID = (5 << 7);  ///< Device die number
        constexpr uint32_t REVID = (4 << 12);  ///< Device Revision Number
        constexpr uint32_t SUBFAMID = (4 << 24);  ///< Kinetis Sub-Family ID
        constexpr uint32_t FAMILYID = (4 << 28);  ///< Kinetis L family ID
    }

    /// SCGC4 Register bits
    namespace scgc4_bits {
        constexpr uint32_t EWM = (1U << 1);  ///< EWM Clock Gate Control
        constexpr uint32_t I2C0 = (1U << 6);  ///< I2C0 Clock Gate Control
        constexpr uint32_t I2C1 = (1U << 7);  ///< I2C1 Clock Gate Control
        constexpr uint32_t USBOTG = (1U << 18);  ///< USB_OTG Clock Gate Control
        constexpr uint32_t CMP = (1U << 19);  ///< CMP Clock Gate Control
        constexpr uint32_t VREF = (1U << 20);  ///< VREF Clock Gate Control
    }

    /// SCGC5 Register bits
    namespace scgc5_bits {
        constexpr uint32_t LPTMR0 = (1U << 0);  ///< LPTMR0 Clock Gate Control
        constexpr uint32_t DRYICE = (1U << 2);  ///< DRYICE Clock Gate Control
        constexpr uint32_t SECREG = (1U << 3);  ///< SECREG Clock Gate Control
        constexpr uint32_t LPTMR1 = (1U << 4);  ///< LPTMR1 Clock Gate Control
        constexpr uint32_t TSI = (1U << 5);  ///< TSI Access Control
        constexpr uint32_t PTA = (1U << 9);  ///< PTA Clock Gate Control
        constexpr uint32_t PTB = (1U << 10);  ///< PTB Clock Gate Control
        constexpr uint32_t PTC = (1U << 11);  ///< PTC Clock Gate Control
        constexpr uint32_t PTD = (1U << 12);  ///< PTD Clock Gate Control
        constexpr uint32_t PTE = (1U << 13);  ///< PTE Clock Gate Control
        constexpr uint32_t EMVSIM0 = (1U << 14);  ///< EMVSIM0 Clock Gate Control
        constexpr uint32_t EMVSIM1 = (1U << 15);  ///< EMVSIM1 Clock Gate Control
        constexpr uint32_t LTC = (1U << 17);  ///< LTC Clock Gate Control
        constexpr uint32_t LPUART0 = (1U << 20);  ///< LPUART0 Clock Gate Control
        constexpr uint32_t LPUART1 = (1U << 21);  ///< LPUART1 Clock Gate Control
        constexpr uint32_t LPUART2 = (1U << 22);  ///< LPUART2 Clock Gate Control
        constexpr uint32_t QSPI0 = (1U << 26);  ///< QSPI0 Clock Gate Control
        constexpr uint32_t FLEXIO0 = (1U << 31);  ///< FLEXIO0 Clock Gate Control
    }

    /// SCGC6 Register bits
    namespace scgc6_bits {
        constexpr uint32_t NVM = (1U << 0);  ///< NVM Clock Gate Control
        constexpr uint32_t DMACHMUX = (1U << 1);  ///< DMACHMUX Clock Gate Control
        constexpr uint32_t INTMUX0 = (1U << 4);  ///< INTMUX0 Clock Gate Control
        constexpr uint32_t TRNG = (1U << 5);  ///< TRNG Clock Gate Control
        constexpr uint32_t SPI0 = (1U << 12);  ///< SPI0 Clock Gate Control
        constexpr uint32_t SPI1 = (1U << 13);  ///< SPI1 Clock Gate Control
        constexpr uint32_t CRC = (1U << 18);  ///< CRC Clock Gate Control
        constexpr uint32_t PIT0 = (1U << 23);  ///< PIT0 Clock Gate Control
        constexpr uint32_t TPM0 = (1U << 24);  ///< TPM0 Clock Gate Control
        constexpr uint32_t TPM1 = (1U << 25);  ///< TPM1 Clock Gate Control
        constexpr uint32_t TPM2 = (1U << 26);  ///< TPM2 Clock Gate Control
        constexpr uint32_t ADC0 = (1U << 27);  ///< ADC0 Clock Gate Control
        constexpr uint32_t RTC = (1U << 29);  ///< RTC Clock Gate Control
        constexpr uint32_t RTC_RF = (1U << 30);  ///< RTC_RF Clock Gate Control
        constexpr uint32_t DAC0 = (1U << 31);  ///< DAC0 Clock Gate Control
    }

    /// SCGC7 Register bits
    namespace scgc7_bits {
        constexpr uint32_t DMA = (1U << 1);  ///< DMA Clock Gate Control
        constexpr uint32_t MPU = (1U << 2);  ///< MPU Clock Gate Control
    }

    /// CLKDIV1 Register bits
    namespace clkdiv1_bits {
        constexpr uint32_t OUTDIV5 = (4 << 12);  ///< Clock 5 output divider value
        constexpr uint32_t OUTDIV4 = (4 << 16);  ///< Clock 4 output divider value
        constexpr uint32_t OUTDIV2 = (4 << 24);  ///< Clock 2 output divider value
        constexpr uint32_t OUTDIV1 = (4 << 28);  ///< Clock 1 output divider value
    }

    /// CLKDIV2 Register bits
    namespace clkdiv2_bits {
        constexpr uint32_t USBFRAC = (1U << 0);  ///< USB clock divider fraction
        constexpr uint32_t USBDIV = (3 << 1);  ///< USB clock divider divisor
    }

    /// FCFG1 Register bits
    namespace fcfg1_bits {
        constexpr uint32_t FLASHDIS = (1U << 0);  ///< Flash Disable
        constexpr uint32_t FLASHDOZE = (1U << 1);  ///< Flash Doze
        constexpr uint32_t PFSIZE = (4 << 24);  ///< Program flash size
    }

    /// FCFG2 Register bits
    namespace fcfg2_bits {
        constexpr uint32_t MAXADDR0 = (7 << 24);  ///< Max address block 0
    }

    /// UIDH Register bits
    namespace uidh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDMH Register bits
    namespace uidmh_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDML Register bits
    namespace uidml_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// UIDL Register bits
    namespace uidl_bits {
        constexpr uint32_t UID = (32 << 0);  ///< Unique Identification
    }

    /// CLKDIV3 Register bits
    namespace clkdiv3_bits {
        constexpr uint32_t PLLFLLFRAC = (1U << 0);  ///< PLLFLL clock divider fraction
        constexpr uint32_t PLLFLLDIV = (3 << 1);  ///< PLLFLL clock divider divisor
    }

    /// MISCCTRL Register bits
    namespace miscctrl_bits {
        constexpr uint32_t DMAINTSEL0 = (1U << 0);  ///< DMA Channel Interrupts Select 0
        constexpr uint32_t DMAINTSEL1 = (1U << 1);  ///< DMA Channel Interrupts Select 1
        constexpr uint32_t DMAINTSEL2 = (1U << 2);  ///< DMA Channel Interrupts Select 2
        constexpr uint32_t DMAINTSEL3 = (1U << 3);  ///< DMA Channel Interrupts Select 3
        constexpr uint32_t LTCEN = (1U << 16);  ///< LTC Status
    }

    /// SECKEY0 Register bits
    namespace seckey0_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Secure Key 31:0
    }

    /// SECKEY1 Register bits
    namespace seckey1_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Secure Key 31:0
    }

    /// SECKEY2 Register bits
    namespace seckey2_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Secure Key 31:0
    }

    /// SECKEY3 Register bits
    namespace seckey3_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Secure Key 31:0
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t PORTA_BASE = 0x40049000;
    constexpr uint32_t PORTB_BASE = 0x4004A000;
    constexpr uint32_t PORTC_BASE = 0x4004B000;
    constexpr uint32_t PORTD_BASE = 0x4004C000;
    constexpr uint32_t PORTE_BASE = 0x4004D000;
    constexpr uint32_t GPIOA_BASE = 0x400FF000;
    constexpr uint32_t GPIOB_BASE = 0x400FF040;
    constexpr uint32_t GPIOC_BASE = 0x400FF080;
    constexpr uint32_t GPIOD_BASE = 0x400FF0C0;
    constexpr uint32_t GPIOE_BASE = 0x400FF100;
    constexpr uint32_t FGPIOA_BASE = 0xF8000000;
    constexpr uint32_t FGPIOB_BASE = 0xF8000040;
    constexpr uint32_t FGPIOC_BASE = 0xF8000080;
    constexpr uint32_t FGPIOD_BASE = 0xF80000C0;
    constexpr uint32_t FGPIOE_BASE = 0xF8000100;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t PCR0;  ///< Offset: 0x00 - Pin Control Register n
        volatile uint32_t PCR1;  ///< Offset: 0x04 - Pin Control Register n
        volatile uint32_t PCR2;  ///< Offset: 0x08 - Pin Control Register n
        volatile uint32_t PCR3;  ///< Offset: 0x0C - Pin Control Register n
        volatile uint32_t PCR4;  ///< Offset: 0x10 - Pin Control Register n
        volatile uint32_t PCR5;  ///< Offset: 0x14 - Pin Control Register n
        volatile uint32_t PCR6;  ///< Offset: 0x18 - Pin Control Register n
        volatile uint32_t PCR7;  ///< Offset: 0x1C - Pin Control Register n
        volatile uint32_t PCR8;  ///< Offset: 0x20 - Pin Control Register n
        volatile uint32_t PCR9;  ///< Offset: 0x24 - Pin Control Register n
        volatile uint32_t PCR10;  ///< Offset: 0x28 - Pin Control Register n
        volatile uint32_t PCR11;  ///< Offset: 0x2C - Pin Control Register n
        volatile uint32_t PCR12;  ///< Offset: 0x30 - Pin Control Register n
        volatile uint32_t PCR13;  ///< Offset: 0x34 - Pin Control Register n
        volatile uint32_t PCR14;  ///< Offset: 0x38 - Pin Control Register n
        volatile uint32_t PCR15;  ///< Offset: 0x3C - Pin Control Register n
        volatile uint32_t PCR16;  ///< Offset: 0x40 - Pin Control Register n
        volatile uint32_t PCR17;  ///< Offset: 0x44 - Pin Control Register n
        volatile uint32_t PCR18;  ///< Offset: 0x48 - Pin Control Register n
        volatile uint32_t PCR19;  ///< Offset: 0x4C - Pin Control Register n
        volatile uint32_t PCR20;  ///< Offset: 0x50 - Pin Control Register n
        volatile uint32_t PCR21;  ///< Offset: 0x54 - Pin Control Register n
        volatile uint32_t PCR22;  ///< Offset: 0x58 - Pin Control Register n
        volatile uint32_t PCR23;  ///< Offset: 0x5C - Pin Control Register n
        volatile uint32_t PCR24;  ///< Offset: 0x60 - Pin Control Register n
        volatile uint32_t PCR25;  ///< Offset: 0x64 - Pin Control Register n
        volatile uint32_t PCR26;  ///< Offset: 0x68 - Pin Control Register n
        volatile uint32_t PCR27;  ///< Offset: 0x6C - Pin Control Register n
        volatile uint32_t PCR28;  ///< Offset: 0x70 - Pin Control Register n
        volatile uint32_t PCR29;  ///< Offset: 0x74 - Pin Control Register n
        volatile uint32_t PCR30;  ///< Offset: 0x78 - Pin Control Register n
        volatile uint32_t PCR31;  ///< Offset: 0x7C - Pin Control Register n
        volatile uint32_t GPCLR;  ///< Offset: 0x80 - Global Pin Control Low Register
        volatile uint32_t GPCHR;  ///< Offset: 0x84 - Global Pin Control High Register
        volatile uint32_t GICLR;  ///< Offset: 0x88 - Global Interrupt Control Low Register
        volatile uint32_t GICHR;  ///< Offset: 0x8C - Global Interrupt Control High Register
        volatile uint32_t ISFR;  ///< Offset: 0xA0 - Interrupt Status Flag Register
    };

    /// Peripheral instances
    inline Registers* PORTA = reinterpret_cast<Registers*>(PORTA_BASE);
    inline Registers* PORTB = reinterpret_cast<Registers*>(PORTB_BASE);
    inline Registers* PORTC = reinterpret_cast<Registers*>(PORTC_BASE);
    inline Registers* PORTD = reinterpret_cast<Registers*>(PORTD_BASE);
    inline Registers* PORTE = reinterpret_cast<Registers*>(PORTE_BASE);
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* FGPIOA = reinterpret_cast<Registers*>(FGPIOA_BASE);
    inline Registers* FGPIOB = reinterpret_cast<Registers*>(FGPIOB_BASE);
    inline Registers* FGPIOC = reinterpret_cast<Registers*>(FGPIOC_BASE);
    inline Registers* FGPIOD = reinterpret_cast<Registers*>(FGPIOD_BASE);
    inline Registers* FGPIOE = reinterpret_cast<Registers*>(FGPIOE_BASE);

    // Bit definitions
    /// PCR0 Register bits
    namespace pcr0_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR1 Register bits
    namespace pcr1_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR2 Register bits
    namespace pcr2_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR3 Register bits
    namespace pcr3_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR4 Register bits
    namespace pcr4_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR5 Register bits
    namespace pcr5_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR6 Register bits
    namespace pcr6_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR7 Register bits
    namespace pcr7_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR8 Register bits
    namespace pcr8_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR9 Register bits
    namespace pcr9_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR10 Register bits
    namespace pcr10_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR11 Register bits
    namespace pcr11_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR12 Register bits
    namespace pcr12_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR13 Register bits
    namespace pcr13_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR14 Register bits
    namespace pcr14_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR15 Register bits
    namespace pcr15_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR16 Register bits
    namespace pcr16_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR17 Register bits
    namespace pcr17_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR18 Register bits
    namespace pcr18_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR19 Register bits
    namespace pcr19_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR20 Register bits
    namespace pcr20_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR21 Register bits
    namespace pcr21_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR22 Register bits
    namespace pcr22_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR23 Register bits
    namespace pcr23_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR24 Register bits
    namespace pcr24_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR25 Register bits
    namespace pcr25_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR26 Register bits
    namespace pcr26_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR27 Register bits
    namespace pcr27_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR28 Register bits
    namespace pcr28_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR29 Register bits
    namespace pcr29_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR30 Register bits
    namespace pcr30_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// PCR31 Register bits
    namespace pcr31_bits {
        constexpr uint32_t PS = (1U << 0);  ///< Pull Select
        constexpr uint32_t PE = (1U << 1);  ///< Pull Enable
        constexpr uint32_t SRE = (1U << 2);  ///< Slew Rate Enable
        constexpr uint32_t PFE = (1U << 4);  ///< Passive Filter Enable
        constexpr uint32_t ODE = (1U << 5);  ///< Open Drain Enable
        constexpr uint32_t MUX = (3 << 8);  ///< Pin Mux Control
        constexpr uint32_t LK = (1U << 15);  ///< Lock Register
        constexpr uint32_t IRQC = (4 << 16);  ///< Interrupt Configuration
        constexpr uint32_t ISF = (1U << 24);  ///< Interrupt Status Flag
    }

    /// GPCLR Register bits
    namespace gpclr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GPCHR Register bits
    namespace gpchr_bits {
        constexpr uint32_t GPWD = (16 << 0);  ///< Global Pin Write Data
        constexpr uint32_t GPWE = (16 << 16);  ///< Global Pin Write Enable
    }

    /// GICLR Register bits
    namespace giclr_bits {
        constexpr uint32_t GIWE = (16 << 0);  ///< Global Interrupt Write Enable
        constexpr uint32_t GIWD = (16 << 16);  ///< Global Interrupt Write Data
    }

    /// GICHR Register bits
    namespace gichr_bits {
        constexpr uint32_t GIWE = (16 << 0);  ///< Global Interrupt Write Enable
        constexpr uint32_t GIWD = (16 << 16);  ///< Global Interrupt Write Data
    }

    /// ISFR Register bits
    namespace isfr_bits {
        constexpr uint32_t ISF = (32 << 0);  ///< Interrupt Status Flag
    }

}

// ============================================================================
// EMVSIM0 Peripheral
// ============================================================================

namespace emvsim0 {
    /// Base addresses
    constexpr uint32_t EMVSIM0_BASE = 0x4004E000;

    /// EMVSIM0 Register structure
    struct Registers {
        volatile uint32_t VER_ID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CLKCFG;  ///< Offset: 0x08 - Clock Configuration Register
        volatile uint32_t DIVISOR;  ///< Offset: 0x0C - Baud Rate Divisor Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0x14 - Interrupt Mask Register
        volatile uint32_t RX_THD;  ///< Offset: 0x18 - Receiver Threshold Register
        volatile uint32_t TX_THD;  ///< Offset: 0x1C - Transmitter Threshold Register
        volatile uint32_t RX_STATUS;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t TX_STATUS;  ///< Offset: 0x24 - Transmitter Status Register
        volatile uint32_t PCSR;  ///< Offset: 0x28 - Port Control and Status Register
        volatile uint32_t RX_BUF;  ///< Offset: 0x2C - Receive Data Read Buffer
        volatile uint32_t TX_BUF;  ///< Offset: 0x30 - Transmit Data Buffer
        volatile uint32_t TX_GETU;  ///< Offset: 0x34 - Transmitter Guard ETU Value Register
        volatile uint32_t CWT_VAL;  ///< Offset: 0x38 - Character Wait Time Value Register
        volatile uint32_t BWT_VAL;  ///< Offset: 0x3C - Block Wait Time Value Register
        volatile uint32_t BGT_VAL;  ///< Offset: 0x40 - Block Guard Time Value Register
        volatile uint32_t GPCNT0_VAL;  ///< Offset: 0x44 - General Purpose Counter 0 Timeout Value Register
        volatile uint32_t GPCNT1_VAL;  ///< Offset: 0x48 - General Purpose Counter 1 Timeout Value
    };

    /// Peripheral instances
    inline Registers* EMVSIM0 = reinterpret_cast<Registers*>(EMVSIM0_BASE);

    // Bit definitions
    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t VER = (32 << 0);  ///< Version ID of the module
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RX_FIFO_DEPTH = (8 << 0);  ///< Receive FIFO Depth
        constexpr uint32_t TX_FIFO_DEPTH = (8 << 8);  ///< Transmit FIFO Depth
    }

    /// CLKCFG Register bits
    namespace clkcfg_bits {
        constexpr uint32_t CLK_PRSC = (8 << 0);  ///< Clock Prescaler Value
        constexpr uint32_t GPCNT1_CLK_SEL = (2 << 8);  ///< General Purpose Counter 1 Clock Select
        constexpr uint32_t GPCNT0_CLK_SEL = (2 << 10);  ///< General Purpose Counter 0 Clock Select
    }

    /// DIVISOR Register bits
    namespace divisor_bits {
        constexpr uint32_t DIVISOR_VALUE = (9 << 0);  ///< Divisor (F/D) Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t IC = (1U << 0);  ///< Inverse Convention
        constexpr uint32_t ICM = (1U << 1);  ///< Initial Character Mode
        constexpr uint32_t ANACK = (1U << 2);  ///< Auto NACK Enable
        constexpr uint32_t ONACK = (1U << 3);  ///< Overrun NACK Enable
        constexpr uint32_t FLSH_RX = (1U << 8);  ///< Flush Receiver Bit
        constexpr uint32_t FLSH_TX = (1U << 9);  ///< Flush Transmitter Bit
        constexpr uint32_t SW_RST = (1U << 10);  ///< Software Reset Bit
        constexpr uint32_t KILL_CLOCKS = (1U << 11);  ///< Kill all internal clocks
        constexpr uint32_t DOZE_EN = (1U << 12);  ///< Doze Enable
        constexpr uint32_t STOP_EN = (1U << 13);  ///< STOP Enable
        constexpr uint32_t RCV_EN = (1U << 16);  ///< Receiver Enable
        constexpr uint32_t XMT_EN = (1U << 17);  ///< Transmitter Enable
        constexpr uint32_t RCVR_11 = (1U << 18);  ///< Receiver 11 ETU Mode Enable
        constexpr uint32_t RX_DMA_EN = (1U << 19);  ///< Receive DMA Enable
        constexpr uint32_t TX_DMA_EN = (1U << 20);  ///< Transmit DMA Enable
        constexpr uint32_t INV_CRC_VAL = (1U << 24);  ///< Invert bits in the CRC Output Value
        constexpr uint32_t CRC_OUT_FLIP = (1U << 25);  ///< CRC Output Value Bit Reversal or Flip
        constexpr uint32_t CRC_IN_FLIP = (1U << 26);  ///< CRC Input Byte's Bit Reversal or Flip Control
        constexpr uint32_t CWT_EN = (1U << 27);  ///< Character Wait Time Counter Enable
        constexpr uint32_t LRC_EN = (1U << 28);  ///< LRC Enable
        constexpr uint32_t CRC_EN = (1U << 29);  ///< CRC Enable
        constexpr uint32_t XMT_CRC_LRC = (1U << 30);  ///< Transmit CRC or LRC Enable
        constexpr uint32_t BWT_EN = (1U << 31);  ///< Block Wait Time Counter Enable
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t RDT_IM = (1U << 0);  ///< Receive Data Threshold Interrupt Mask
        constexpr uint32_t TC_IM = (1U << 1);  ///< Transmit Complete Interrupt Mask
        constexpr uint32_t RFO_IM = (1U << 2);  ///< Receive FIFO Overflow Interrupt Mask
        constexpr uint32_t ETC_IM = (1U << 3);  ///< Early Transmit Complete Interrupt Mask
        constexpr uint32_t TFE_IM = (1U << 4);  ///< Transmit FIFO Empty Interrupt Mask
        constexpr uint32_t TNACK_IM = (1U << 5);  ///< Transmit NACK Threshold Interrupt Mask
        constexpr uint32_t TFF_IM = (1U << 6);  ///< Transmit FIFO Full Interrupt Mask
        constexpr uint32_t TDT_IM = (1U << 7);  ///< Transmit Data Threshold Interrupt Mask
        constexpr uint32_t GPCNT0_IM = (1U << 8);  ///< General Purpose Timer 0 Timeout Interrupt Mask
        constexpr uint32_t CWT_ERR_IM = (1U << 9);  ///< Character Wait Time Error Interrupt Mask
        constexpr uint32_t RNACK_IM = (1U << 10);  ///< Receiver NACK Threshold Interrupt Mask
        constexpr uint32_t BWT_ERR_IM = (1U << 11);  ///< Block Wait Time Error Interrupt Mask
        constexpr uint32_t BGT_ERR_IM = (1U << 12);  ///< Block Guard Time Error Interrupt
        constexpr uint32_t GPCNT1_IM = (1U << 13);  ///< General Purpose Counter 1 Timeout Interrupt Mask
        constexpr uint32_t RX_DATA_IM = (1U << 14);  ///< Receive Data Interrupt Mask
        constexpr uint32_t PEF_IM = (1U << 15);  ///< Parity Error Interrupt Mask
    }

    /// RX_THD Register bits
    namespace rx_thd_bits {
        constexpr uint32_t RDT = (4 << 0);  ///< Receiver Data Threshold Value
        constexpr uint32_t RNCK_THD = (4 << 8);  ///< Receiver NACK Threshold Value
    }

    /// TX_THD Register bits
    namespace tx_thd_bits {
        constexpr uint32_t TDT = (4 << 0);  ///< Transmitter Data Threshold Value
        constexpr uint32_t TNCK_THD = (4 << 8);  ///< Transmitter NACK Threshold Value
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t RFO = (1U << 0);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t RX_DATA = (1U << 4);  ///< Receive Data Interrupt Flag
        constexpr uint32_t RDTF = (1U << 5);  ///< Receive Data Threshold Interrupt Flag
        constexpr uint32_t LRC_OK = (1U << 6);  ///< LRC Check OK Flag
        constexpr uint32_t CRC_OK = (1U << 7);  ///< CRC Check OK Flag
        constexpr uint32_t CWT_ERR = (1U << 8);  ///< Character Wait Time Error Flag
        constexpr uint32_t RTE = (1U << 9);  ///< Received NACK Threshold Error Flag
        constexpr uint32_t BWT_ERR = (1U << 10);  ///< Block Wait Time Error Flag
        constexpr uint32_t BGT_ERR = (1U << 11);  ///< Block Guard Time Error Flag
        constexpr uint32_t PEF = (1U << 12);  ///< Parity Error Flag
        constexpr uint32_t FEF = (1U << 13);  ///< Frame Error Flag
        constexpr uint32_t RX_WPTR = (4 << 16);  ///< Receive FIFO Write Pointer Value
        constexpr uint32_t RX_CNT = (8 << 24);  ///< Receive FIFO Byte Count
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t TNTE = (1U << 0);  ///< Transmit NACK Threshold Error Flag
        constexpr uint32_t TFE = (1U << 3);  ///< Transmit FIFO Empty Flag
        constexpr uint32_t ETCF = (1U << 4);  ///< Early Transmit Complete Flag
        constexpr uint32_t TCF = (1U << 5);  ///< Transmit Complete Flag
        constexpr uint32_t TFF = (1U << 6);  ///< Transmit FIFO Full Flag
        constexpr uint32_t TDTF = (1U << 7);  ///< Transmit Data Threshold Flag
        constexpr uint32_t GPCNT0_TO = (1U << 8);  ///< General Purpose Counter 0 Timeout Flag
        constexpr uint32_t GPCNT1_TO = (1U << 9);  ///< General Purpose Counter 1 Timeout Flag
        constexpr uint32_t TX_RPTR = (4 << 16);  ///< Transmit FIFO Read Pointer
        constexpr uint32_t TX_CNT = (8 << 24);  ///< Transmit FIFO Byte Count
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t SAPD = (1U << 0);  ///< Auto Power Down Enable
        constexpr uint32_t SVCC_EN = (1U << 1);  ///< Vcc Enable for Smart Card
        constexpr uint32_t VCCENP = (1U << 2);  ///< VCC Enable Polarity Control
        constexpr uint32_t SRST = (1U << 3);  ///< Reset to Smart Card
        constexpr uint32_t SCEN = (1U << 4);  ///< Clock Enable for Smart Card
        constexpr uint32_t SCSP = (1U << 5);  ///< Smart Card Clock Stop Polarity
        constexpr uint32_t SPD = (1U << 7);  ///< Auto Power Down Control
        constexpr uint32_t SPDIM = (1U << 24);  ///< Smart Card Presence Detect Interrupt Mask
        constexpr uint32_t SPDIF = (1U << 25);  ///< Smart Card Presence Detect Interrupt Flag
        constexpr uint32_t SPDP = (1U << 26);  ///< Smart Card Presence Detect Pin Status
        constexpr uint32_t SPDES = (1U << 27);  ///< SIM Presence Detect Edge Select
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BYTE = (8 << 0);  ///< Receive Data Byte Read
    }

    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BYTE = (8 << 0);  ///< Transmit Data Byte
    }

    /// TX_GETU Register bits
    namespace tx_getu_bits {
        constexpr uint32_t GETU = (8 << 0);  ///< Transmitter Guard Time Value in ETU
    }

    /// CWT_VAL Register bits
    namespace cwt_val_bits {
        constexpr uint32_t CWT = (16 << 0);  ///< Character Wait Time Value
    }

    /// BWT_VAL Register bits
    namespace bwt_val_bits {
        constexpr uint32_t BWT = (32 << 0);  ///< Block Wait Time Value
    }

    /// BGT_VAL Register bits
    namespace bgt_val_bits {
        constexpr uint32_t BGT = (16 << 0);  ///< Block Guard Time Value
    }

    /// GPCNT0_VAL Register bits
    namespace gpcnt0_val_bits {
        constexpr uint32_t GPCNT0 = (16 << 0);  ///< General Purpose Counter 0 Timeout Value
    }

    /// GPCNT1_VAL Register bits
    namespace gpcnt1_val_bits {
        constexpr uint32_t GPCNT1 = (16 << 0);  ///< General Purpose Counter 1 Timeout Value
    }

}

// ============================================================================
// EMVSIM1 Peripheral
// ============================================================================

namespace emvsim1 {
    /// Base addresses
    constexpr uint32_t EMVSIM1_BASE = 0x4004F000;

    /// EMVSIM1 Register structure
    struct Registers {
        volatile uint32_t VER_ID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CLKCFG;  ///< Offset: 0x08 - Clock Configuration Register
        volatile uint32_t DIVISOR;  ///< Offset: 0x0C - Baud Rate Divisor Register
        volatile uint32_t CTRL;  ///< Offset: 0x10 - Control Register
        volatile uint32_t INT_MASK;  ///< Offset: 0x14 - Interrupt Mask Register
        volatile uint32_t RX_THD;  ///< Offset: 0x18 - Receiver Threshold Register
        volatile uint32_t TX_THD;  ///< Offset: 0x1C - Transmitter Threshold Register
        volatile uint32_t RX_STATUS;  ///< Offset: 0x20 - Receive Status Register
        volatile uint32_t TX_STATUS;  ///< Offset: 0x24 - Transmitter Status Register
        volatile uint32_t PCSR;  ///< Offset: 0x28 - Port Control and Status Register
        volatile uint32_t RX_BUF;  ///< Offset: 0x2C - Receive Data Read Buffer
        volatile uint32_t TX_BUF;  ///< Offset: 0x30 - Transmit Data Buffer
        volatile uint32_t TX_GETU;  ///< Offset: 0x34 - Transmitter Guard ETU Value Register
        volatile uint32_t CWT_VAL;  ///< Offset: 0x38 - Character Wait Time Value Register
        volatile uint32_t BWT_VAL;  ///< Offset: 0x3C - Block Wait Time Value Register
        volatile uint32_t BGT_VAL;  ///< Offset: 0x40 - Block Guard Time Value Register
        volatile uint32_t GPCNT0_VAL;  ///< Offset: 0x44 - General Purpose Counter 0 Timeout Value Register
        volatile uint32_t GPCNT1_VAL;  ///< Offset: 0x48 - General Purpose Counter 1 Timeout Value
    };

    /// Peripheral instances
    inline Registers* EMVSIM1 = reinterpret_cast<Registers*>(EMVSIM1_BASE);

    // Bit definitions
    /// VER_ID Register bits
    namespace ver_id_bits {
        constexpr uint32_t VER = (32 << 0);  ///< Version ID of the module
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t RX_FIFO_DEPTH = (8 << 0);  ///< Receive FIFO Depth
        constexpr uint32_t TX_FIFO_DEPTH = (8 << 8);  ///< Transmit FIFO Depth
    }

    /// CLKCFG Register bits
    namespace clkcfg_bits {
        constexpr uint32_t CLK_PRSC = (8 << 0);  ///< Clock Prescaler Value
        constexpr uint32_t GPCNT1_CLK_SEL = (2 << 8);  ///< General Purpose Counter 1 Clock Select
        constexpr uint32_t GPCNT0_CLK_SEL = (2 << 10);  ///< General Purpose Counter 0 Clock Select
    }

    /// DIVISOR Register bits
    namespace divisor_bits {
        constexpr uint32_t DIVISOR_VALUE = (9 << 0);  ///< Divisor (F/D) Value
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t IC = (1U << 0);  ///< Inverse Convention
        constexpr uint32_t ICM = (1U << 1);  ///< Initial Character Mode
        constexpr uint32_t ANACK = (1U << 2);  ///< Auto NACK Enable
        constexpr uint32_t ONACK = (1U << 3);  ///< Overrun NACK Enable
        constexpr uint32_t FLSH_RX = (1U << 8);  ///< Flush Receiver Bit
        constexpr uint32_t FLSH_TX = (1U << 9);  ///< Flush Transmitter Bit
        constexpr uint32_t SW_RST = (1U << 10);  ///< Software Reset Bit
        constexpr uint32_t KILL_CLOCKS = (1U << 11);  ///< Kill all internal clocks
        constexpr uint32_t DOZE_EN = (1U << 12);  ///< Doze Enable
        constexpr uint32_t STOP_EN = (1U << 13);  ///< STOP Enable
        constexpr uint32_t RCV_EN = (1U << 16);  ///< Receiver Enable
        constexpr uint32_t XMT_EN = (1U << 17);  ///< Transmitter Enable
        constexpr uint32_t RCVR_11 = (1U << 18);  ///< Receiver 11 ETU Mode Enable
        constexpr uint32_t RX_DMA_EN = (1U << 19);  ///< Receive DMA Enable
        constexpr uint32_t TX_DMA_EN = (1U << 20);  ///< Transmit DMA Enable
        constexpr uint32_t INV_CRC_VAL = (1U << 24);  ///< Invert bits in the CRC Output Value
        constexpr uint32_t CRC_OUT_FLIP = (1U << 25);  ///< CRC Output Value Bit Reversal or Flip
        constexpr uint32_t CRC_IN_FLIP = (1U << 26);  ///< CRC Input Byte's Bit Reversal or Flip Control
        constexpr uint32_t CWT_EN = (1U << 27);  ///< Character Wait Time Counter Enable
        constexpr uint32_t LRC_EN = (1U << 28);  ///< LRC Enable
        constexpr uint32_t CRC_EN = (1U << 29);  ///< CRC Enable
        constexpr uint32_t XMT_CRC_LRC = (1U << 30);  ///< Transmit CRC or LRC Enable
        constexpr uint32_t BWT_EN = (1U << 31);  ///< Block Wait Time Counter Enable
    }

    /// INT_MASK Register bits
    namespace int_mask_bits {
        constexpr uint32_t RDT_IM = (1U << 0);  ///< Receive Data Threshold Interrupt Mask
        constexpr uint32_t TC_IM = (1U << 1);  ///< Transmit Complete Interrupt Mask
        constexpr uint32_t RFO_IM = (1U << 2);  ///< Receive FIFO Overflow Interrupt Mask
        constexpr uint32_t ETC_IM = (1U << 3);  ///< Early Transmit Complete Interrupt Mask
        constexpr uint32_t TFE_IM = (1U << 4);  ///< Transmit FIFO Empty Interrupt Mask
        constexpr uint32_t TNACK_IM = (1U << 5);  ///< Transmit NACK Threshold Interrupt Mask
        constexpr uint32_t TFF_IM = (1U << 6);  ///< Transmit FIFO Full Interrupt Mask
        constexpr uint32_t TDT_IM = (1U << 7);  ///< Transmit Data Threshold Interrupt Mask
        constexpr uint32_t GPCNT0_IM = (1U << 8);  ///< General Purpose Timer 0 Timeout Interrupt Mask
        constexpr uint32_t CWT_ERR_IM = (1U << 9);  ///< Character Wait Time Error Interrupt Mask
        constexpr uint32_t RNACK_IM = (1U << 10);  ///< Receiver NACK Threshold Interrupt Mask
        constexpr uint32_t BWT_ERR_IM = (1U << 11);  ///< Block Wait Time Error Interrupt Mask
        constexpr uint32_t BGT_ERR_IM = (1U << 12);  ///< Block Guard Time Error Interrupt
        constexpr uint32_t GPCNT1_IM = (1U << 13);  ///< General Purpose Counter 1 Timeout Interrupt Mask
        constexpr uint32_t RX_DATA_IM = (1U << 14);  ///< Receive Data Interrupt Mask
        constexpr uint32_t PEF_IM = (1U << 15);  ///< Parity Error Interrupt Mask
    }

    /// RX_THD Register bits
    namespace rx_thd_bits {
        constexpr uint32_t RDT = (4 << 0);  ///< Receiver Data Threshold Value
        constexpr uint32_t RNCK_THD = (4 << 8);  ///< Receiver NACK Threshold Value
    }

    /// TX_THD Register bits
    namespace tx_thd_bits {
        constexpr uint32_t TDT = (4 << 0);  ///< Transmitter Data Threshold Value
        constexpr uint32_t TNCK_THD = (4 << 8);  ///< Transmitter NACK Threshold Value
    }

    /// RX_STATUS Register bits
    namespace rx_status_bits {
        constexpr uint32_t RFO = (1U << 0);  ///< Receive FIFO Overflow Flag
        constexpr uint32_t RX_DATA = (1U << 4);  ///< Receive Data Interrupt Flag
        constexpr uint32_t RDTF = (1U << 5);  ///< Receive Data Threshold Interrupt Flag
        constexpr uint32_t LRC_OK = (1U << 6);  ///< LRC Check OK Flag
        constexpr uint32_t CRC_OK = (1U << 7);  ///< CRC Check OK Flag
        constexpr uint32_t CWT_ERR = (1U << 8);  ///< Character Wait Time Error Flag
        constexpr uint32_t RTE = (1U << 9);  ///< Received NACK Threshold Error Flag
        constexpr uint32_t BWT_ERR = (1U << 10);  ///< Block Wait Time Error Flag
        constexpr uint32_t BGT_ERR = (1U << 11);  ///< Block Guard Time Error Flag
        constexpr uint32_t PEF = (1U << 12);  ///< Parity Error Flag
        constexpr uint32_t FEF = (1U << 13);  ///< Frame Error Flag
        constexpr uint32_t RX_WPTR = (4 << 16);  ///< Receive FIFO Write Pointer Value
        constexpr uint32_t RX_CNT = (8 << 24);  ///< Receive FIFO Byte Count
    }

    /// TX_STATUS Register bits
    namespace tx_status_bits {
        constexpr uint32_t TNTE = (1U << 0);  ///< Transmit NACK Threshold Error Flag
        constexpr uint32_t TFE = (1U << 3);  ///< Transmit FIFO Empty Flag
        constexpr uint32_t ETCF = (1U << 4);  ///< Early Transmit Complete Flag
        constexpr uint32_t TCF = (1U << 5);  ///< Transmit Complete Flag
        constexpr uint32_t TFF = (1U << 6);  ///< Transmit FIFO Full Flag
        constexpr uint32_t TDTF = (1U << 7);  ///< Transmit Data Threshold Flag
        constexpr uint32_t GPCNT0_TO = (1U << 8);  ///< General Purpose Counter 0 Timeout Flag
        constexpr uint32_t GPCNT1_TO = (1U << 9);  ///< General Purpose Counter 1 Timeout Flag
        constexpr uint32_t TX_RPTR = (4 << 16);  ///< Transmit FIFO Read Pointer
        constexpr uint32_t TX_CNT = (8 << 24);  ///< Transmit FIFO Byte Count
    }

    /// PCSR Register bits
    namespace pcsr_bits {
        constexpr uint32_t SAPD = (1U << 0);  ///< Auto Power Down Enable
        constexpr uint32_t SVCC_EN = (1U << 1);  ///< Vcc Enable for Smart Card
        constexpr uint32_t VCCENP = (1U << 2);  ///< VCC Enable Polarity Control
        constexpr uint32_t SRST = (1U << 3);  ///< Reset to Smart Card
        constexpr uint32_t SCEN = (1U << 4);  ///< Clock Enable for Smart Card
        constexpr uint32_t SCSP = (1U << 5);  ///< Smart Card Clock Stop Polarity
        constexpr uint32_t SPD = (1U << 7);  ///< Auto Power Down Control
        constexpr uint32_t SPDIM = (1U << 24);  ///< Smart Card Presence Detect Interrupt Mask
        constexpr uint32_t SPDIF = (1U << 25);  ///< Smart Card Presence Detect Interrupt Flag
        constexpr uint32_t SPDP = (1U << 26);  ///< Smart Card Presence Detect Pin Status
        constexpr uint32_t SPDES = (1U << 27);  ///< SIM Presence Detect Edge Select
    }

    /// RX_BUF Register bits
    namespace rx_buf_bits {
        constexpr uint32_t RX_BYTE = (8 << 0);  ///< Receive Data Byte Read
    }

    /// TX_BUF Register bits
    namespace tx_buf_bits {
        constexpr uint32_t TX_BYTE = (8 << 0);  ///< Transmit Data Byte
    }

    /// TX_GETU Register bits
    namespace tx_getu_bits {
        constexpr uint32_t GETU = (8 << 0);  ///< Transmitter Guard Time Value in ETU
    }

    /// CWT_VAL Register bits
    namespace cwt_val_bits {
        constexpr uint32_t CWT = (16 << 0);  ///< Character Wait Time Value
    }

    /// BWT_VAL Register bits
    namespace bwt_val_bits {
        constexpr uint32_t BWT = (32 << 0);  ///< Block Wait Time Value
    }

    /// BGT_VAL Register bits
    namespace bgt_val_bits {
        constexpr uint32_t BGT = (16 << 0);  ///< Block Guard Time Value
    }

    /// GPCNT0_VAL Register bits
    namespace gpcnt0_val_bits {
        constexpr uint32_t GPCNT0 = (16 << 0);  ///< General Purpose Counter 0 Timeout Value
    }

    /// GPCNT1_VAL Register bits
    namespace gpcnt1_val_bits {
        constexpr uint32_t GPCNT1 = (16 << 0);  ///< General Purpose Counter 1 Timeout Value
    }

}

// ============================================================================
// LTC0 Peripheral
// ============================================================================

namespace ltc0 {
    /// Base addresses
    constexpr uint32_t LTC0_BASE = 0x40051000;

    /// LTC0 Register structure
    struct Registers {
        volatile uint32_t LTC0_MD;  ///< Offset: 0x00 - LTC Mode Register (non-PKHA/non-RNG use)
        volatile uint32_t LTC0_MDPK;  ///< Offset: 0x00 - LTC Mode Register (PublicKey)
        volatile uint32_t LTC0_KS;  ///< Offset: 0x08 - LTC Key Size Register
        volatile uint32_t LTC0_DS;  ///< Offset: 0x10 - LTC Data Size Register
        volatile uint32_t LTC0_ICVS;  ///< Offset: 0x18 - LTC ICV Size Register
        volatile uint32_t LTC0_COM;  ///< Offset: 0x30 - LTC Command Register
        volatile uint32_t LTC0_CTL;  ///< Offset: 0x34 - LTC Control Register
        volatile uint32_t LTC0_CW;  ///< Offset: 0x40 - LTC Clear Written Register
        volatile uint32_t LTC0_STA;  ///< Offset: 0x48 - LTC Status Register
        volatile uint32_t LTC0_ESTA;  ///< Offset: 0x4C - LTC Error Status Register
        volatile uint32_t LTC0_AADSZ;  ///< Offset: 0x58 - LTC AAD Size Register
        volatile uint32_t LTC0_IVSZ;  ///< Offset: 0x60 - LTC IV Size Register
        volatile uint32_t LTC0_DPAMS;  ///< Offset: 0x68 - LTC DPA Mask Seed Register
        volatile uint32_t LTC0_PKASZ;  ///< Offset: 0x80 - LTC PKHA A Size Register
        volatile uint32_t LTC0_PKBSZ;  ///< Offset: 0x88 - LTC PKHA B Size Register
        volatile uint32_t LTC0_PKNSZ;  ///< Offset: 0x90 - LTC PKHA N Size Register
        volatile uint32_t LTC0_PKESZ;  ///< Offset: 0x98 - LTC PKHA E Size Register
        volatile uint32_t LTC0_CTX_0;  ///< Offset: 0x100 - LTC Context Register
        volatile uint32_t LTC0_CTX_1;  ///< Offset: 0x104 - LTC Context Register
        volatile uint32_t LTC0_CTX_2;  ///< Offset: 0x108 - LTC Context Register
        volatile uint32_t LTC0_CTX_3;  ///< Offset: 0x10C - LTC Context Register
        volatile uint32_t LTC0_CTX_4;  ///< Offset: 0x110 - LTC Context Register
        volatile uint32_t LTC0_CTX_5;  ///< Offset: 0x114 - LTC Context Register
        volatile uint32_t LTC0_CTX_6;  ///< Offset: 0x118 - LTC Context Register
        volatile uint32_t LTC0_CTX_7;  ///< Offset: 0x11C - LTC Context Register
        volatile uint32_t LTC0_CTX_8;  ///< Offset: 0x120 - LTC Context Register
        volatile uint32_t LTC0_CTX_9;  ///< Offset: 0x124 - LTC Context Register
        volatile uint32_t LTC0_CTX_10;  ///< Offset: 0x128 - LTC Context Register
        volatile uint32_t LTC0_CTX_11;  ///< Offset: 0x12C - LTC Context Register
        volatile uint32_t LTC0_CTX_12;  ///< Offset: 0x130 - LTC Context Register
        volatile uint32_t LTC0_CTX_13;  ///< Offset: 0x134 - LTC Context Register
        volatile uint32_t LTC0_CTX_14;  ///< Offset: 0x138 - LTC Context Register
        volatile uint32_t LTC0_CTX_15;  ///< Offset: 0x13C - LTC Context Register
        volatile uint32_t LTC0_KEY_0;  ///< Offset: 0x200 - LTC Key Registers
        volatile uint32_t LTC0_KEY_1;  ///< Offset: 0x204 - LTC Key Registers
        volatile uint32_t LTC0_KEY_2;  ///< Offset: 0x208 - LTC Key Registers
        volatile uint32_t LTC0_KEY_3;  ///< Offset: 0x20C - LTC Key Registers
        volatile uint32_t LTC0_KEY_4;  ///< Offset: 0x210 - LTC Key Registers
        volatile uint32_t LTC0_KEY_5;  ///< Offset: 0x214 - LTC Key Registers
        volatile uint32_t LTC0_KEY_6;  ///< Offset: 0x218 - LTC Key Registers
        volatile uint32_t LTC0_KEY_7;  ///< Offset: 0x21C - LTC Key Registers
        volatile uint32_t LTC0_VID1;  ///< Offset: 0x4F0 - LTC Version ID Register
        volatile uint32_t LTC0_VID2;  ///< Offset: 0x4F4 - LTC Version ID 2 Register
        volatile uint32_t LTC0_CHAVID;  ///< Offset: 0x4F8 - LTC CHA Version ID Register
        volatile uint32_t LTC0_FIFOSTA;  ///< Offset: 0x7C0 - LTC FIFO Status Register
        volatile uint32_t LTC0_IFIFO;  ///< Offset: 0x7E0 - LTC Input Data FIFO
        volatile uint32_t LTC0_OFIFO;  ///< Offset: 0x7F0 - LTC Output Data FIFO
        volatile uint32_t LTC0_PKA0_0;  ///< Offset: 0x800 - LTC PKHA A0 0 Register
        volatile uint32_t LTC0_PKA_0;  ///< Offset: 0x800 - LTC PKHA A 0 Register
        volatile uint32_t LTC0_PKA0_1;  ///< Offset: 0x804 - LTC PKHA A0 1 Register
        volatile uint32_t LTC0_PKA_1;  ///< Offset: 0x804 - LTC PKHA A 1 Register
        volatile uint32_t LTC0_PKA0_2;  ///< Offset: 0x808 - LTC PKHA A0 2 Register
        volatile uint32_t LTC0_PKA_2;  ///< Offset: 0x808 - LTC PKHA A 2 Register
        volatile uint32_t LTC0_PKA0_3;  ///< Offset: 0x80C - LTC PKHA A0 3 Register
        volatile uint32_t LTC0_PKA_3;  ///< Offset: 0x80C - LTC PKHA A 3 Register
        volatile uint32_t LTC0_PKA0_4;  ///< Offset: 0x810 - LTC PKHA A0 4 Register
        volatile uint32_t LTC0_PKA_4;  ///< Offset: 0x810 - LTC PKHA A 4 Register
        volatile uint32_t LTC0_PKA0_5;  ///< Offset: 0x814 - LTC PKHA A0 5 Register
        volatile uint32_t LTC0_PKA_5;  ///< Offset: 0x814 - LTC PKHA A 5 Register
        volatile uint32_t LTC0_PKA0_6;  ///< Offset: 0x818 - LTC PKHA A0 6 Register
        volatile uint32_t LTC0_PKA_6;  ///< Offset: 0x818 - LTC PKHA A 6 Register
        volatile uint32_t LTC0_PKA0_7;  ///< Offset: 0x81C - LTC PKHA A0 7 Register
        volatile uint32_t LTC0_PKA_7;  ///< Offset: 0x81C - LTC PKHA A 7 Register
        volatile uint32_t LTC0_PKA0_8;  ///< Offset: 0x820 - LTC PKHA A0 8 Register
        volatile uint32_t LTC0_PKA_8;  ///< Offset: 0x820 - LTC PKHA A 8 Register
        volatile uint32_t LTC0_PKA0_9;  ///< Offset: 0x824 - LTC PKHA A0 9 Register
        volatile uint32_t LTC0_PKA_9;  ///< Offset: 0x824 - LTC PKHA A 9 Register
        volatile uint32_t LTC0_PKA0_10;  ///< Offset: 0x828 - LTC PKHA A0 10 Register
        volatile uint32_t LTC0_PKA_10;  ///< Offset: 0x828 - LTC PKHA A 10 Register
        volatile uint32_t LTC0_PKA0_11;  ///< Offset: 0x82C - LTC PKHA A0 11 Register
        volatile uint32_t LTC0_PKA_11;  ///< Offset: 0x82C - LTC PKHA A 11 Register
        volatile uint32_t LTC0_PKA0_12;  ///< Offset: 0x830 - LTC PKHA A0 12 Register
        volatile uint32_t LTC0_PKA_12;  ///< Offset: 0x830 - LTC PKHA A 12 Register
        volatile uint32_t LTC0_PKA0_13;  ///< Offset: 0x834 - LTC PKHA A0 13 Register
        volatile uint32_t LTC0_PKA_13;  ///< Offset: 0x834 - LTC PKHA A 13 Register
        volatile uint32_t LTC0_PKA0_14;  ///< Offset: 0x838 - LTC PKHA A0 14 Register
        volatile uint32_t LTC0_PKA_14;  ///< Offset: 0x838 - LTC PKHA A 14 Register
        volatile uint32_t LTC0_PKA0_15;  ///< Offset: 0x83C - LTC PKHA A0 15 Register
        volatile uint32_t LTC0_PKA_15;  ///< Offset: 0x83C - LTC PKHA A 15 Register
        volatile uint32_t LTC0_PKA1_0;  ///< Offset: 0x840 - LTC PKHA A1 0 Register
        volatile uint32_t LTC0_PKA_16;  ///< Offset: 0x840 - LTC PKHA A 16 Register
        volatile uint32_t LTC0_PKA1_1;  ///< Offset: 0x844 - LTC PKHA A1 1 Register
        volatile uint32_t LTC0_PKA_17;  ///< Offset: 0x844 - LTC PKHA A 17 Register
        volatile uint32_t LTC0_PKA1_2;  ///< Offset: 0x848 - LTC PKHA A1 2 Register
        volatile uint32_t LTC0_PKA_18;  ///< Offset: 0x848 - LTC PKHA A 18 Register
        volatile uint32_t LTC0_PKA1_3;  ///< Offset: 0x84C - LTC PKHA A1 3 Register
        volatile uint32_t LTC0_PKA_19;  ///< Offset: 0x84C - LTC PKHA A 19 Register
        volatile uint32_t LTC0_PKA1_4;  ///< Offset: 0x850 - LTC PKHA A1 4 Register
        volatile uint32_t LTC0_PKA_20;  ///< Offset: 0x850 - LTC PKHA A 20 Register
        volatile uint32_t LTC0_PKA1_5;  ///< Offset: 0x854 - LTC PKHA A1 5 Register
        volatile uint32_t LTC0_PKA_21;  ///< Offset: 0x854 - LTC PKHA A 21 Register
        volatile uint32_t LTC0_PKA1_6;  ///< Offset: 0x858 - LTC PKHA A1 6 Register
        volatile uint32_t LTC0_PKA_22;  ///< Offset: 0x858 - LTC PKHA A 22 Register
        volatile uint32_t LTC0_PKA1_7;  ///< Offset: 0x85C - LTC PKHA A1 7 Register
        volatile uint32_t LTC0_PKA_23;  ///< Offset: 0x85C - LTC PKHA A 23 Register
        volatile uint32_t LTC0_PKA1_8;  ///< Offset: 0x860 - LTC PKHA A1 8 Register
        volatile uint32_t LTC0_PKA_24;  ///< Offset: 0x860 - LTC PKHA A 24 Register
        volatile uint32_t LTC0_PKA1_9;  ///< Offset: 0x864 - LTC PKHA A1 9 Register
        volatile uint32_t LTC0_PKA_25;  ///< Offset: 0x864 - LTC PKHA A 25 Register
        volatile uint32_t LTC0_PKA1_10;  ///< Offset: 0x868 - LTC PKHA A1 10 Register
        volatile uint32_t LTC0_PKA_26;  ///< Offset: 0x868 - LTC PKHA A 26 Register
        volatile uint32_t LTC0_PKA1_11;  ///< Offset: 0x86C - LTC PKHA A1 11 Register
        volatile uint32_t LTC0_PKA_27;  ///< Offset: 0x86C - LTC PKHA A 27 Register
        volatile uint32_t LTC0_PKA1_12;  ///< Offset: 0x870 - LTC PKHA A1 12 Register
        volatile uint32_t LTC0_PKA_28;  ///< Offset: 0x870 - LTC PKHA A 28 Register
        volatile uint32_t LTC0_PKA1_13;  ///< Offset: 0x874 - LTC PKHA A1 13 Register
        volatile uint32_t LTC0_PKA_29;  ///< Offset: 0x874 - LTC PKHA A 29 Register
        volatile uint32_t LTC0_PKA1_14;  ///< Offset: 0x878 - LTC PKHA A1 14 Register
        volatile uint32_t LTC0_PKA_30;  ///< Offset: 0x878 - LTC PKHA A 30 Register
        volatile uint32_t LTC0_PKA1_15;  ///< Offset: 0x87C - LTC PKHA A1 15 Register
        volatile uint32_t LTC0_PKA_31;  ///< Offset: 0x87C - LTC PKHA A 31 Register
        volatile uint32_t LTC0_PKA2_0;  ///< Offset: 0x880 - LTC PKHA A2 0 Register
        volatile uint32_t LTC0_PKA_32;  ///< Offset: 0x880 - LTC PKHA A 32 Register
        volatile uint32_t LTC0_PKA2_1;  ///< Offset: 0x884 - LTC PKHA A2 1 Register
        volatile uint32_t LTC0_PKA_33;  ///< Offset: 0x884 - LTC PKHA A 33 Register
        volatile uint32_t LTC0_PKA2_2;  ///< Offset: 0x888 - LTC PKHA A2 2 Register
        volatile uint32_t LTC0_PKA_34;  ///< Offset: 0x888 - LTC PKHA A 34 Register
        volatile uint32_t LTC0_PKA2_3;  ///< Offset: 0x88C - LTC PKHA A2 3 Register
        volatile uint32_t LTC0_PKA_35;  ///< Offset: 0x88C - LTC PKHA A 35 Register
        volatile uint32_t LTC0_PKA2_4;  ///< Offset: 0x890 - LTC PKHA A2 4 Register
        volatile uint32_t LTC0_PKA_36;  ///< Offset: 0x890 - LTC PKHA A 36 Register
        volatile uint32_t LTC0_PKA2_5;  ///< Offset: 0x894 - LTC PKHA A2 5 Register
        volatile uint32_t LTC0_PKA_37;  ///< Offset: 0x894 - LTC PKHA A 37 Register
        volatile uint32_t LTC0_PKA2_6;  ///< Offset: 0x898 - LTC PKHA A2 6 Register
        volatile uint32_t LTC0_PKA_38;  ///< Offset: 0x898 - LTC PKHA A 38 Register
        volatile uint32_t LTC0_PKA2_7;  ///< Offset: 0x89C - LTC PKHA A2 7 Register
        volatile uint32_t LTC0_PKA_39;  ///< Offset: 0x89C - LTC PKHA A 39 Register
        volatile uint32_t LTC0_PKA2_8;  ///< Offset: 0x8A0 - LTC PKHA A2 8 Register
        volatile uint32_t LTC0_PKA_40;  ///< Offset: 0x8A0 - LTC PKHA A 40 Register
        volatile uint32_t LTC0_PKA2_9;  ///< Offset: 0x8A4 - LTC PKHA A2 9 Register
        volatile uint32_t LTC0_PKA_41;  ///< Offset: 0x8A4 - LTC PKHA A 41 Register
        volatile uint32_t LTC0_PKA2_10;  ///< Offset: 0x8A8 - LTC PKHA A2 10 Register
        volatile uint32_t LTC0_PKA_42;  ///< Offset: 0x8A8 - LTC PKHA A 42 Register
        volatile uint32_t LTC0_PKA2_11;  ///< Offset: 0x8AC - LTC PKHA A2 11 Register
        volatile uint32_t LTC0_PKA_43;  ///< Offset: 0x8AC - LTC PKHA A 43 Register
        volatile uint32_t LTC0_PKA2_12;  ///< Offset: 0x8B0 - LTC PKHA A2 12 Register
        volatile uint32_t LTC0_PKA_44;  ///< Offset: 0x8B0 - LTC PKHA A 44 Register
        volatile uint32_t LTC0_PKA2_13;  ///< Offset: 0x8B4 - LTC PKHA A2 13 Register
        volatile uint32_t LTC0_PKA_45;  ///< Offset: 0x8B4 - LTC PKHA A 45 Register
        volatile uint32_t LTC0_PKA2_14;  ///< Offset: 0x8B8 - LTC PKHA A2 14 Register
        volatile uint32_t LTC0_PKA_46;  ///< Offset: 0x8B8 - LTC PKHA A 46 Register
        volatile uint32_t LTC0_PKA2_15;  ///< Offset: 0x8BC - LTC PKHA A2 15 Register
        volatile uint32_t LTC0_PKA_47;  ///< Offset: 0x8BC - LTC PKHA A 47 Register
        volatile uint32_t LTC0_PKA3_0;  ///< Offset: 0x8C0 - LTC PKHA A3 0 Register
        volatile uint32_t LTC0_PKA_48;  ///< Offset: 0x8C0 - LTC PKHA A 48 Register
        volatile uint32_t LTC0_PKA3_1;  ///< Offset: 0x8C4 - LTC PKHA A3 1 Register
        volatile uint32_t LTC0_PKA_49;  ///< Offset: 0x8C4 - LTC PKHA A 49 Register
        volatile uint32_t LTC0_PKA3_2;  ///< Offset: 0x8C8 - LTC PKHA A3 2 Register
        volatile uint32_t LTC0_PKA_50;  ///< Offset: 0x8C8 - LTC PKHA A 50 Register
        volatile uint32_t LTC0_PKA3_3;  ///< Offset: 0x8CC - LTC PKHA A3 3 Register
        volatile uint32_t LTC0_PKA_51;  ///< Offset: 0x8CC - LTC PKHA A 51 Register
        volatile uint32_t LTC0_PKA3_4;  ///< Offset: 0x8D0 - LTC PKHA A3 4 Register
        volatile uint32_t LTC0_PKA_52;  ///< Offset: 0x8D0 - LTC PKHA A 52 Register
        volatile uint32_t LTC0_PKA3_5;  ///< Offset: 0x8D4 - LTC PKHA A3 5 Register
        volatile uint32_t LTC0_PKA_53;  ///< Offset: 0x8D4 - LTC PKHA A 53 Register
        volatile uint32_t LTC0_PKA3_6;  ///< Offset: 0x8D8 - LTC PKHA A3 6 Register
        volatile uint32_t LTC0_PKA_54;  ///< Offset: 0x8D8 - LTC PKHA A 54 Register
        volatile uint32_t LTC0_PKA3_7;  ///< Offset: 0x8DC - LTC PKHA A3 7 Register
        volatile uint32_t LTC0_PKA_55;  ///< Offset: 0x8DC - LTC PKHA A 55 Register
        volatile uint32_t LTC0_PKA3_8;  ///< Offset: 0x8E0 - LTC PKHA A3 8 Register
        volatile uint32_t LTC0_PKA_56;  ///< Offset: 0x8E0 - LTC PKHA A 56 Register
        volatile uint32_t LTC0_PKA3_9;  ///< Offset: 0x8E4 - LTC PKHA A3 9 Register
        volatile uint32_t LTC0_PKA_57;  ///< Offset: 0x8E4 - LTC PKHA A 57 Register
        volatile uint32_t LTC0_PKA3_10;  ///< Offset: 0x8E8 - LTC PKHA A3 10 Register
        volatile uint32_t LTC0_PKA_58;  ///< Offset: 0x8E8 - LTC PKHA A 58 Register
        volatile uint32_t LTC0_PKA3_11;  ///< Offset: 0x8EC - LTC PKHA A3 11 Register
        volatile uint32_t LTC0_PKA_59;  ///< Offset: 0x8EC - LTC PKHA A 59 Register
        volatile uint32_t LTC0_PKA3_12;  ///< Offset: 0x8F0 - LTC PKHA A3 12 Register
        volatile uint32_t LTC0_PKA_60;  ///< Offset: 0x8F0 - LTC PKHA A 60 Register
        volatile uint32_t LTC0_PKA3_13;  ///< Offset: 0x8F4 - LTC PKHA A3 13 Register
        volatile uint32_t LTC0_PKA_61;  ///< Offset: 0x8F4 - LTC PKHA A 61 Register
        volatile uint32_t LTC0_PKA3_14;  ///< Offset: 0x8F8 - LTC PKHA A3 14 Register
        volatile uint32_t LTC0_PKA_62;  ///< Offset: 0x8F8 - LTC PKHA A 62 Register
        volatile uint32_t LTC0_PKA3_15;  ///< Offset: 0x8FC - LTC PKHA A3 15 Register
        volatile uint32_t LTC0_PKA_63;  ///< Offset: 0x8FC - LTC PKHA A 63 Register
        volatile uint32_t LTC0_PKB0_0;  ///< Offset: 0xA00 - LTC PKHA B0 0 Register
        volatile uint32_t LTC0_PKB_0;  ///< Offset: 0xA00 - LTC PKHA B 0 Register
        volatile uint32_t LTC0_PKB0_1;  ///< Offset: 0xA04 - LTC PKHA B0 1 Register
        volatile uint32_t LTC0_PKB_1;  ///< Offset: 0xA04 - LTC PKHA B 1 Register
        volatile uint32_t LTC0_PKB0_2;  ///< Offset: 0xA08 - LTC PKHA B0 2 Register
        volatile uint32_t LTC0_PKB_2;  ///< Offset: 0xA08 - LTC PKHA B 2 Register
        volatile uint32_t LTC0_PKB0_3;  ///< Offset: 0xA0C - LTC PKHA B0 3 Register
        volatile uint32_t LTC0_PKB_3;  ///< Offset: 0xA0C - LTC PKHA B 3 Register
        volatile uint32_t LTC0_PKB0_4;  ///< Offset: 0xA10 - LTC PKHA B0 4 Register
        volatile uint32_t LTC0_PKB_4;  ///< Offset: 0xA10 - LTC PKHA B 4 Register
        volatile uint32_t LTC0_PKB0_5;  ///< Offset: 0xA14 - LTC PKHA B0 5 Register
        volatile uint32_t LTC0_PKB_5;  ///< Offset: 0xA14 - LTC PKHA B 5 Register
        volatile uint32_t LTC0_PKB0_6;  ///< Offset: 0xA18 - LTC PKHA B0 6 Register
        volatile uint32_t LTC0_PKB_6;  ///< Offset: 0xA18 - LTC PKHA B 6 Register
        volatile uint32_t LTC0_PKB0_7;  ///< Offset: 0xA1C - LTC PKHA B0 7 Register
        volatile uint32_t LTC0_PKB_7;  ///< Offset: 0xA1C - LTC PKHA B 7 Register
        volatile uint32_t LTC0_PKB0_8;  ///< Offset: 0xA20 - LTC PKHA B0 8 Register
        volatile uint32_t LTC0_PKB_8;  ///< Offset: 0xA20 - LTC PKHA B 8 Register
        volatile uint32_t LTC0_PKB0_9;  ///< Offset: 0xA24 - LTC PKHA B0 9 Register
        volatile uint32_t LTC0_PKB_9;  ///< Offset: 0xA24 - LTC PKHA B 9 Register
        volatile uint32_t LTC0_PKB0_10;  ///< Offset: 0xA28 - LTC PKHA B0 10 Register
        volatile uint32_t LTC0_PKB_10;  ///< Offset: 0xA28 - LTC PKHA B 10 Register
        volatile uint32_t LTC0_PKB0_11;  ///< Offset: 0xA2C - LTC PKHA B0 11 Register
        volatile uint32_t LTC0_PKB_11;  ///< Offset: 0xA2C - LTC PKHA B 11 Register
        volatile uint32_t LTC0_PKB0_12;  ///< Offset: 0xA30 - LTC PKHA B0 12 Register
        volatile uint32_t LTC0_PKB_12;  ///< Offset: 0xA30 - LTC PKHA B 12 Register
        volatile uint32_t LTC0_PKB0_13;  ///< Offset: 0xA34 - LTC PKHA B0 13 Register
        volatile uint32_t LTC0_PKB_13;  ///< Offset: 0xA34 - LTC PKHA B 13 Register
        volatile uint32_t LTC0_PKB0_14;  ///< Offset: 0xA38 - LTC PKHA B0 14 Register
        volatile uint32_t LTC0_PKB_14;  ///< Offset: 0xA38 - LTC PKHA B 14 Register
        volatile uint32_t LTC0_PKB0_15;  ///< Offset: 0xA3C - LTC PKHA B0 15 Register
        volatile uint32_t LTC0_PKB_15;  ///< Offset: 0xA3C - LTC PKHA B 15 Register
        volatile uint32_t LTC0_PKB1_0;  ///< Offset: 0xA40 - LTC PKHA B1 0 Register
        volatile uint32_t LTC0_PKB_16;  ///< Offset: 0xA40 - LTC PKHA B 16 Register
        volatile uint32_t LTC0_PKB1_1;  ///< Offset: 0xA44 - LTC PKHA B1 1 Register
        volatile uint32_t LTC0_PKB_17;  ///< Offset: 0xA44 - LTC PKHA B 17 Register
        volatile uint32_t LTC0_PKB1_2;  ///< Offset: 0xA48 - LTC PKHA B1 2 Register
        volatile uint32_t LTC0_PKB_18;  ///< Offset: 0xA48 - LTC PKHA B 18 Register
        volatile uint32_t LTC0_PKB1_3;  ///< Offset: 0xA4C - LTC PKHA B1 3 Register
        volatile uint32_t LTC0_PKB_19;  ///< Offset: 0xA4C - LTC PKHA B 19 Register
        volatile uint32_t LTC0_PKB1_4;  ///< Offset: 0xA50 - LTC PKHA B1 4 Register
        volatile uint32_t LTC0_PKB_20;  ///< Offset: 0xA50 - LTC PKHA B 20 Register
        volatile uint32_t LTC0_PKB1_5;  ///< Offset: 0xA54 - LTC PKHA B1 5 Register
        volatile uint32_t LTC0_PKB_21;  ///< Offset: 0xA54 - LTC PKHA B 21 Register
        volatile uint32_t LTC0_PKB1_6;  ///< Offset: 0xA58 - LTC PKHA B1 6 Register
        volatile uint32_t LTC0_PKB_22;  ///< Offset: 0xA58 - LTC PKHA B 22 Register
        volatile uint32_t LTC0_PKB1_7;  ///< Offset: 0xA5C - LTC PKHA B1 7 Register
        volatile uint32_t LTC0_PKB_23;  ///< Offset: 0xA5C - LTC PKHA B 23 Register
        volatile uint32_t LTC0_PKB1_8;  ///< Offset: 0xA60 - LTC PKHA B1 8 Register
        volatile uint32_t LTC0_PKB_24;  ///< Offset: 0xA60 - LTC PKHA B 24 Register
        volatile uint32_t LTC0_PKB1_9;  ///< Offset: 0xA64 - LTC PKHA B1 9 Register
        volatile uint32_t LTC0_PKB_25;  ///< Offset: 0xA64 - LTC PKHA B 25 Register
        volatile uint32_t LTC0_PKB1_10;  ///< Offset: 0xA68 - LTC PKHA B1 10 Register
        volatile uint32_t LTC0_PKB_26;  ///< Offset: 0xA68 - LTC PKHA B 26 Register
        volatile uint32_t LTC0_PKB1_11;  ///< Offset: 0xA6C - LTC PKHA B1 11 Register
        volatile uint32_t LTC0_PKB_27;  ///< Offset: 0xA6C - LTC PKHA B 27 Register
        volatile uint32_t LTC0_PKB1_12;  ///< Offset: 0xA70 - LTC PKHA B1 12 Register
        volatile uint32_t LTC0_PKB_28;  ///< Offset: 0xA70 - LTC PKHA B 28 Register
        volatile uint32_t LTC0_PKB1_13;  ///< Offset: 0xA74 - LTC PKHA B1 13 Register
        volatile uint32_t LTC0_PKB_29;  ///< Offset: 0xA74 - LTC PKHA B 29 Register
        volatile uint32_t LTC0_PKB1_14;  ///< Offset: 0xA78 - LTC PKHA B1 14 Register
        volatile uint32_t LTC0_PKB_30;  ///< Offset: 0xA78 - LTC PKHA B 30 Register
        volatile uint32_t LTC0_PKB1_15;  ///< Offset: 0xA7C - LTC PKHA B1 15 Register
        volatile uint32_t LTC0_PKB_31;  ///< Offset: 0xA7C - LTC PKHA B 31 Register
        volatile uint32_t LTC0_PKB2_0;  ///< Offset: 0xA80 - LTC PKHA B2 0 Register
        volatile uint32_t LTC0_PKB_32;  ///< Offset: 0xA80 - LTC PKHA B 32 Register
        volatile uint32_t LTC0_PKB2_1;  ///< Offset: 0xA84 - LTC PKHA B2 1 Register
        volatile uint32_t LTC0_PKB_33;  ///< Offset: 0xA84 - LTC PKHA B 33 Register
        volatile uint32_t LTC0_PKB2_2;  ///< Offset: 0xA88 - LTC PKHA B2 2 Register
        volatile uint32_t LTC0_PKB_34;  ///< Offset: 0xA88 - LTC PKHA B 34 Register
        volatile uint32_t LTC0_PKB2_3;  ///< Offset: 0xA8C - LTC PKHA B2 3 Register
        volatile uint32_t LTC0_PKB_35;  ///< Offset: 0xA8C - LTC PKHA B 35 Register
        volatile uint32_t LTC0_PKB2_4;  ///< Offset: 0xA90 - LTC PKHA B2 4 Register
        volatile uint32_t LTC0_PKB_36;  ///< Offset: 0xA90 - LTC PKHA B 36 Register
        volatile uint32_t LTC0_PKB2_5;  ///< Offset: 0xA94 - LTC PKHA B2 5 Register
        volatile uint32_t LTC0_PKB_37;  ///< Offset: 0xA94 - LTC PKHA B 37 Register
        volatile uint32_t LTC0_PKB2_6;  ///< Offset: 0xA98 - LTC PKHA B2 6 Register
        volatile uint32_t LTC0_PKB_38;  ///< Offset: 0xA98 - LTC PKHA B 38 Register
        volatile uint32_t LTC0_PKB2_7;  ///< Offset: 0xA9C - LTC PKHA B2 7 Register
        volatile uint32_t LTC0_PKB_39;  ///< Offset: 0xA9C - LTC PKHA B 39 Register
        volatile uint32_t LTC0_PKB2_8;  ///< Offset: 0xAA0 - LTC PKHA B2 8 Register
        volatile uint32_t LTC0_PKB_40;  ///< Offset: 0xAA0 - LTC PKHA B 40 Register
        volatile uint32_t LTC0_PKB2_9;  ///< Offset: 0xAA4 - LTC PKHA B2 9 Register
        volatile uint32_t LTC0_PKB_41;  ///< Offset: 0xAA4 - LTC PKHA B 41 Register
        volatile uint32_t LTC0_PKB2_10;  ///< Offset: 0xAA8 - LTC PKHA B2 10 Register
        volatile uint32_t LTC0_PKB_42;  ///< Offset: 0xAA8 - LTC PKHA B 42 Register
        volatile uint32_t LTC0_PKB2_11;  ///< Offset: 0xAAC - LTC PKHA B2 11 Register
        volatile uint32_t LTC0_PKB_43;  ///< Offset: 0xAAC - LTC PKHA B 43 Register
        volatile uint32_t LTC0_PKB2_12;  ///< Offset: 0xAB0 - LTC PKHA B2 12 Register
        volatile uint32_t LTC0_PKB_44;  ///< Offset: 0xAB0 - LTC PKHA B 44 Register
        volatile uint32_t LTC0_PKB2_13;  ///< Offset: 0xAB4 - LTC PKHA B2 13 Register
        volatile uint32_t LTC0_PKB_45;  ///< Offset: 0xAB4 - LTC PKHA B 45 Register
        volatile uint32_t LTC0_PKB2_14;  ///< Offset: 0xAB8 - LTC PKHA B2 14 Register
        volatile uint32_t LTC0_PKB_46;  ///< Offset: 0xAB8 - LTC PKHA B 46 Register
        volatile uint32_t LTC0_PKB2_15;  ///< Offset: 0xABC - LTC PKHA B2 15 Register
        volatile uint32_t LTC0_PKB_47;  ///< Offset: 0xABC - LTC PKHA B 47 Register
        volatile uint32_t LTC0_PKB3_0;  ///< Offset: 0xAC0 - LTC PKHA B3 0 Register
        volatile uint32_t LTC0_PKB_48;  ///< Offset: 0xAC0 - LTC PKHA B 48 Register
        volatile uint32_t LTC0_PKB3_1;  ///< Offset: 0xAC4 - LTC PKHA B3 1 Register
        volatile uint32_t LTC0_PKB_49;  ///< Offset: 0xAC4 - LTC PKHA B 49 Register
        volatile uint32_t LTC0_PKB3_2;  ///< Offset: 0xAC8 - LTC PKHA B3 2 Register
        volatile uint32_t LTC0_PKB_50;  ///< Offset: 0xAC8 - LTC PKHA B 50 Register
        volatile uint32_t LTC0_PKB3_3;  ///< Offset: 0xACC - LTC PKHA B3 3 Register
        volatile uint32_t LTC0_PKB_51;  ///< Offset: 0xACC - LTC PKHA B 51 Register
        volatile uint32_t LTC0_PKB3_4;  ///< Offset: 0xAD0 - LTC PKHA B3 4 Register
        volatile uint32_t LTC0_PKB_52;  ///< Offset: 0xAD0 - LTC PKHA B 52 Register
        volatile uint32_t LTC0_PKB3_5;  ///< Offset: 0xAD4 - LTC PKHA B3 5 Register
        volatile uint32_t LTC0_PKB_53;  ///< Offset: 0xAD4 - LTC PKHA B 53 Register
        volatile uint32_t LTC0_PKB3_6;  ///< Offset: 0xAD8 - LTC PKHA B3 6 Register
        volatile uint32_t LTC0_PKB_54;  ///< Offset: 0xAD8 - LTC PKHA B 54 Register
        volatile uint32_t LTC0_PKB3_7;  ///< Offset: 0xADC - LTC PKHA B3 7 Register
        volatile uint32_t LTC0_PKB_55;  ///< Offset: 0xADC - LTC PKHA B 55 Register
        volatile uint32_t LTC0_PKB3_8;  ///< Offset: 0xAE0 - LTC PKHA B3 8 Register
        volatile uint32_t LTC0_PKB_56;  ///< Offset: 0xAE0 - LTC PKHA B 56 Register
        volatile uint32_t LTC0_PKB3_9;  ///< Offset: 0xAE4 - LTC PKHA B3 9 Register
        volatile uint32_t LTC0_PKB_57;  ///< Offset: 0xAE4 - LTC PKHA B 57 Register
        volatile uint32_t LTC0_PKB3_10;  ///< Offset: 0xAE8 - LTC PKHA B3 10 Register
        volatile uint32_t LTC0_PKB_58;  ///< Offset: 0xAE8 - LTC PKHA B 58 Register
        volatile uint32_t LTC0_PKB3_11;  ///< Offset: 0xAEC - LTC PKHA B3 11 Register
        volatile uint32_t LTC0_PKB_59;  ///< Offset: 0xAEC - LTC PKHA B 59 Register
        volatile uint32_t LTC0_PKB3_12;  ///< Offset: 0xAF0 - LTC PKHA B3 12 Register
        volatile uint32_t LTC0_PKB_60;  ///< Offset: 0xAF0 - LTC PKHA B 60 Register
        volatile uint32_t LTC0_PKB3_13;  ///< Offset: 0xAF4 - LTC PKHA B3 13 Register
        volatile uint32_t LTC0_PKB_61;  ///< Offset: 0xAF4 - LTC PKHA B 61 Register
        volatile uint32_t LTC0_PKB3_14;  ///< Offset: 0xAF8 - LTC PKHA B3 14 Register
        volatile uint32_t LTC0_PKB_62;  ///< Offset: 0xAF8 - LTC PKHA B 62 Register
        volatile uint32_t LTC0_PKB3_15;  ///< Offset: 0xAFC - LTC PKHA B3 15 Register
        volatile uint32_t LTC0_PKB_63;  ///< Offset: 0xAFC - LTC PKHA B 63 Register
        volatile uint32_t LTC0_PKN0_0;  ///< Offset: 0xC00 - LTC PKHA N0 0 Register
        volatile uint32_t LTC0_PKN_0;  ///< Offset: 0xC00 - LTC PKHA N 0 Register
        volatile uint32_t LTC0_PKN0_1;  ///< Offset: 0xC04 - LTC PKHA N0 1 Register
        volatile uint32_t LTC0_PKN_1;  ///< Offset: 0xC04 - LTC PKHA N 1 Register
        volatile uint32_t LTC0_PKN0_2;  ///< Offset: 0xC08 - LTC PKHA N0 2 Register
        volatile uint32_t LTC0_PKN_2;  ///< Offset: 0xC08 - LTC PKHA N 2 Register
        volatile uint32_t LTC0_PKN0_3;  ///< Offset: 0xC0C - LTC PKHA N0 3 Register
        volatile uint32_t LTC0_PKN_3;  ///< Offset: 0xC0C - LTC PKHA N 3 Register
        volatile uint32_t LTC0_PKN0_4;  ///< Offset: 0xC10 - LTC PKHA N0 4 Register
        volatile uint32_t LTC0_PKN_4;  ///< Offset: 0xC10 - LTC PKHA N 4 Register
        volatile uint32_t LTC0_PKN0_5;  ///< Offset: 0xC14 - LTC PKHA N0 5 Register
        volatile uint32_t LTC0_PKN_5;  ///< Offset: 0xC14 - LTC PKHA N 5 Register
        volatile uint32_t LTC0_PKN0_6;  ///< Offset: 0xC18 - LTC PKHA N0 6 Register
        volatile uint32_t LTC0_PKN_6;  ///< Offset: 0xC18 - LTC PKHA N 6 Register
        volatile uint32_t LTC0_PKN0_7;  ///< Offset: 0xC1C - LTC PKHA N0 7 Register
        volatile uint32_t LTC0_PKN_7;  ///< Offset: 0xC1C - LTC PKHA N 7 Register
        volatile uint32_t LTC0_PKN0_8;  ///< Offset: 0xC20 - LTC PKHA N0 8 Register
        volatile uint32_t LTC0_PKN_8;  ///< Offset: 0xC20 - LTC PKHA N 8 Register
        volatile uint32_t LTC0_PKN0_9;  ///< Offset: 0xC24 - LTC PKHA N0 9 Register
        volatile uint32_t LTC0_PKN_9;  ///< Offset: 0xC24 - LTC PKHA N 9 Register
        volatile uint32_t LTC0_PKN0_10;  ///< Offset: 0xC28 - LTC PKHA N0 10 Register
        volatile uint32_t LTC0_PKN_10;  ///< Offset: 0xC28 - LTC PKHA N 10 Register
        volatile uint32_t LTC0_PKN0_11;  ///< Offset: 0xC2C - LTC PKHA N0 11 Register
        volatile uint32_t LTC0_PKN_11;  ///< Offset: 0xC2C - LTC PKHA N 11 Register
        volatile uint32_t LTC0_PKN0_12;  ///< Offset: 0xC30 - LTC PKHA N0 12 Register
        volatile uint32_t LTC0_PKN_12;  ///< Offset: 0xC30 - LTC PKHA N 12 Register
        volatile uint32_t LTC0_PKN0_13;  ///< Offset: 0xC34 - LTC PKHA N0 13 Register
        volatile uint32_t LTC0_PKN_13;  ///< Offset: 0xC34 - LTC PKHA N 13 Register
        volatile uint32_t LTC0_PKN0_14;  ///< Offset: 0xC38 - LTC PKHA N0 14 Register
        volatile uint32_t LTC0_PKN_14;  ///< Offset: 0xC38 - LTC PKHA N 14 Register
        volatile uint32_t LTC0_PKN0_15;  ///< Offset: 0xC3C - LTC PKHA N0 15 Register
        volatile uint32_t LTC0_PKN_15;  ///< Offset: 0xC3C - LTC PKHA N 15 Register
        volatile uint32_t LTC0_PKN1_0;  ///< Offset: 0xC40 - LTC PKHA N1 0 Register
        volatile uint32_t LTC0_PKN_16;  ///< Offset: 0xC40 - LTC PKHA N 16 Register
        volatile uint32_t LTC0_PKN1_1;  ///< Offset: 0xC44 - LTC PKHA N1 1 Register
        volatile uint32_t LTC0_PKN_17;  ///< Offset: 0xC44 - LTC PKHA N 17 Register
        volatile uint32_t LTC0_PKN1_2;  ///< Offset: 0xC48 - LTC PKHA N1 2 Register
        volatile uint32_t LTC0_PKN_18;  ///< Offset: 0xC48 - LTC PKHA N 18 Register
        volatile uint32_t LTC0_PKN1_3;  ///< Offset: 0xC4C - LTC PKHA N1 3 Register
        volatile uint32_t LTC0_PKN_19;  ///< Offset: 0xC4C - LTC PKHA N 19 Register
        volatile uint32_t LTC0_PKN1_4;  ///< Offset: 0xC50 - LTC PKHA N1 4 Register
        volatile uint32_t LTC0_PKN_20;  ///< Offset: 0xC50 - LTC PKHA N 20 Register
        volatile uint32_t LTC0_PKN1_5;  ///< Offset: 0xC54 - LTC PKHA N1 5 Register
        volatile uint32_t LTC0_PKN_21;  ///< Offset: 0xC54 - LTC PKHA N 21 Register
        volatile uint32_t LTC0_PKN1_6;  ///< Offset: 0xC58 - LTC PKHA N1 6 Register
        volatile uint32_t LTC0_PKN_22;  ///< Offset: 0xC58 - LTC PKHA N 22 Register
        volatile uint32_t LTC0_PKN1_7;  ///< Offset: 0xC5C - LTC PKHA N1 7 Register
        volatile uint32_t LTC0_PKN_23;  ///< Offset: 0xC5C - LTC PKHA N 23 Register
        volatile uint32_t LTC0_PKN1_8;  ///< Offset: 0xC60 - LTC PKHA N1 8 Register
        volatile uint32_t LTC0_PKN_24;  ///< Offset: 0xC60 - LTC PKHA N 24 Register
        volatile uint32_t LTC0_PKN1_9;  ///< Offset: 0xC64 - LTC PKHA N1 9 Register
        volatile uint32_t LTC0_PKN_25;  ///< Offset: 0xC64 - LTC PKHA N 25 Register
        volatile uint32_t LTC0_PKN1_10;  ///< Offset: 0xC68 - LTC PKHA N1 10 Register
        volatile uint32_t LTC0_PKN_26;  ///< Offset: 0xC68 - LTC PKHA N 26 Register
        volatile uint32_t LTC0_PKN1_11;  ///< Offset: 0xC6C - LTC PKHA N1 11 Register
        volatile uint32_t LTC0_PKN_27;  ///< Offset: 0xC6C - LTC PKHA N 27 Register
        volatile uint32_t LTC0_PKN1_12;  ///< Offset: 0xC70 - LTC PKHA N1 12 Register
        volatile uint32_t LTC0_PKN_28;  ///< Offset: 0xC70 - LTC PKHA N 28 Register
        volatile uint32_t LTC0_PKN1_13;  ///< Offset: 0xC74 - LTC PKHA N1 13 Register
        volatile uint32_t LTC0_PKN_29;  ///< Offset: 0xC74 - LTC PKHA N 29 Register
        volatile uint32_t LTC0_PKN1_14;  ///< Offset: 0xC78 - LTC PKHA N1 14 Register
        volatile uint32_t LTC0_PKN_30;  ///< Offset: 0xC78 - LTC PKHA N 30 Register
        volatile uint32_t LTC0_PKN1_15;  ///< Offset: 0xC7C - LTC PKHA N1 15 Register
        volatile uint32_t LTC0_PKN_31;  ///< Offset: 0xC7C - LTC PKHA N 31 Register
        volatile uint32_t LTC0_PKN2_0;  ///< Offset: 0xC80 - LTC PKHA N2 0 Register
        volatile uint32_t LTC0_PKN_32;  ///< Offset: 0xC80 - LTC PKHA N 32 Register
        volatile uint32_t LTC0_PKN2_1;  ///< Offset: 0xC84 - LTC PKHA N2 1 Register
        volatile uint32_t LTC0_PKN_33;  ///< Offset: 0xC84 - LTC PKHA N 33 Register
        volatile uint32_t LTC0_PKN2_2;  ///< Offset: 0xC88 - LTC PKHA N2 2 Register
        volatile uint32_t LTC0_PKN_34;  ///< Offset: 0xC88 - LTC PKHA N 34 Register
        volatile uint32_t LTC0_PKN2_3;  ///< Offset: 0xC8C - LTC PKHA N2 3 Register
        volatile uint32_t LTC0_PKN_35;  ///< Offset: 0xC8C - LTC PKHA N 35 Register
        volatile uint32_t LTC0_PKN2_4;  ///< Offset: 0xC90 - LTC PKHA N2 4 Register
        volatile uint32_t LTC0_PKN_36;  ///< Offset: 0xC90 - LTC PKHA N 36 Register
        volatile uint32_t LTC0_PKN2_5;  ///< Offset: 0xC94 - LTC PKHA N2 5 Register
        volatile uint32_t LTC0_PKN_37;  ///< Offset: 0xC94 - LTC PKHA N 37 Register
        volatile uint32_t LTC0_PKN2_6;  ///< Offset: 0xC98 - LTC PKHA N2 6 Register
        volatile uint32_t LTC0_PKN_38;  ///< Offset: 0xC98 - LTC PKHA N 38 Register
        volatile uint32_t LTC0_PKN2_7;  ///< Offset: 0xC9C - LTC PKHA N2 7 Register
        volatile uint32_t LTC0_PKN_39;  ///< Offset: 0xC9C - LTC PKHA N 39 Register
        volatile uint32_t LTC0_PKN2_8;  ///< Offset: 0xCA0 - LTC PKHA N2 8 Register
        volatile uint32_t LTC0_PKN_40;  ///< Offset: 0xCA0 - LTC PKHA N 40 Register
        volatile uint32_t LTC0_PKN2_9;  ///< Offset: 0xCA4 - LTC PKHA N2 9 Register
        volatile uint32_t LTC0_PKN_41;  ///< Offset: 0xCA4 - LTC PKHA N 41 Register
        volatile uint32_t LTC0_PKN2_10;  ///< Offset: 0xCA8 - LTC PKHA N2 10 Register
        volatile uint32_t LTC0_PKN_42;  ///< Offset: 0xCA8 - LTC PKHA N 42 Register
        volatile uint32_t LTC0_PKN2_11;  ///< Offset: 0xCAC - LTC PKHA N2 11 Register
        volatile uint32_t LTC0_PKN_43;  ///< Offset: 0xCAC - LTC PKHA N 43 Register
        volatile uint32_t LTC0_PKN2_12;  ///< Offset: 0xCB0 - LTC PKHA N2 12 Register
        volatile uint32_t LTC0_PKN_44;  ///< Offset: 0xCB0 - LTC PKHA N 44 Register
        volatile uint32_t LTC0_PKN2_13;  ///< Offset: 0xCB4 - LTC PKHA N2 13 Register
        volatile uint32_t LTC0_PKN_45;  ///< Offset: 0xCB4 - LTC PKHA N 45 Register
        volatile uint32_t LTC0_PKN2_14;  ///< Offset: 0xCB8 - LTC PKHA N2 14 Register
        volatile uint32_t LTC0_PKN_46;  ///< Offset: 0xCB8 - LTC PKHA N 46 Register
        volatile uint32_t LTC0_PKN2_15;  ///< Offset: 0xCBC - LTC PKHA N2 15 Register
        volatile uint32_t LTC0_PKN_47;  ///< Offset: 0xCBC - LTC PKHA N 47 Register
        volatile uint32_t LTC0_PKN3_0;  ///< Offset: 0xCC0 - LTC PKHA N3 0 Register
        volatile uint32_t LTC0_PKN_48;  ///< Offset: 0xCC0 - LTC PKHA N 48 Register
        volatile uint32_t LTC0_PKN3_1;  ///< Offset: 0xCC4 - LTC PKHA N3 1 Register
        volatile uint32_t LTC0_PKN_49;  ///< Offset: 0xCC4 - LTC PKHA N 49 Register
        volatile uint32_t LTC0_PKN3_2;  ///< Offset: 0xCC8 - LTC PKHA N3 2 Register
        volatile uint32_t LTC0_PKN_50;  ///< Offset: 0xCC8 - LTC PKHA N 50 Register
        volatile uint32_t LTC0_PKN3_3;  ///< Offset: 0xCCC - LTC PKHA N3 3 Register
        volatile uint32_t LTC0_PKN_51;  ///< Offset: 0xCCC - LTC PKHA N 51 Register
        volatile uint32_t LTC0_PKN3_4;  ///< Offset: 0xCD0 - LTC PKHA N3 4 Register
        volatile uint32_t LTC0_PKN_52;  ///< Offset: 0xCD0 - LTC PKHA N 52 Register
        volatile uint32_t LTC0_PKN3_5;  ///< Offset: 0xCD4 - LTC PKHA N3 5 Register
        volatile uint32_t LTC0_PKN_53;  ///< Offset: 0xCD4 - LTC PKHA N 53 Register
        volatile uint32_t LTC0_PKN3_6;  ///< Offset: 0xCD8 - LTC PKHA N3 6 Register
        volatile uint32_t LTC0_PKN_54;  ///< Offset: 0xCD8 - LTC PKHA N 54 Register
        volatile uint32_t LTC0_PKN3_7;  ///< Offset: 0xCDC - LTC PKHA N3 7 Register
        volatile uint32_t LTC0_PKN_55;  ///< Offset: 0xCDC - LTC PKHA N 55 Register
        volatile uint32_t LTC0_PKN3_8;  ///< Offset: 0xCE0 - LTC PKHA N3 8 Register
        volatile uint32_t LTC0_PKN_56;  ///< Offset: 0xCE0 - LTC PKHA N 56 Register
        volatile uint32_t LTC0_PKN3_9;  ///< Offset: 0xCE4 - LTC PKHA N3 9 Register
        volatile uint32_t LTC0_PKN_57;  ///< Offset: 0xCE4 - LTC PKHA N 57 Register
        volatile uint32_t LTC0_PKN3_10;  ///< Offset: 0xCE8 - LTC PKHA N3 10 Register
        volatile uint32_t LTC0_PKN_58;  ///< Offset: 0xCE8 - LTC PKHA N 58 Register
        volatile uint32_t LTC0_PKN3_11;  ///< Offset: 0xCEC - LTC PKHA N3 11 Register
        volatile uint32_t LTC0_PKN_59;  ///< Offset: 0xCEC - LTC PKHA N 59 Register
        volatile uint32_t LTC0_PKN3_12;  ///< Offset: 0xCF0 - LTC PKHA N3 12 Register
        volatile uint32_t LTC0_PKN_60;  ///< Offset: 0xCF0 - LTC PKHA N 60 Register
        volatile uint32_t LTC0_PKN3_13;  ///< Offset: 0xCF4 - LTC PKHA N3 13 Register
        volatile uint32_t LTC0_PKN_61;  ///< Offset: 0xCF4 - LTC PKHA N 61 Register
        volatile uint32_t LTC0_PKN3_14;  ///< Offset: 0xCF8 - LTC PKHA N3 14 Register
        volatile uint32_t LTC0_PKN_62;  ///< Offset: 0xCF8 - LTC PKHA N 62 Register
        volatile uint32_t LTC0_PKN3_15;  ///< Offset: 0xCFC - LTC PKHA N3 15 Register
        volatile uint32_t LTC0_PKN_63;  ///< Offset: 0xCFC - LTC PKHA N 63 Register
        volatile uint32_t LTC0_PKE0_0;  ///< Offset: 0xE00 - LTC PKHA E0 0 Register
        volatile uint32_t LTC0_PKE_0;  ///< Offset: 0xE00 - LTC PKHA E 0 Register
        volatile uint32_t LTC0_PKE0_1;  ///< Offset: 0xE04 - LTC PKHA E0 1 Register
        volatile uint32_t LTC0_PKE_1;  ///< Offset: 0xE04 - LTC PKHA E 1 Register
        volatile uint32_t LTC0_PKE0_2;  ///< Offset: 0xE08 - LTC PKHA E0 2 Register
        volatile uint32_t LTC0_PKE_2;  ///< Offset: 0xE08 - LTC PKHA E 2 Register
        volatile uint32_t LTC0_PKE0_3;  ///< Offset: 0xE0C - LTC PKHA E0 3 Register
        volatile uint32_t LTC0_PKE_3;  ///< Offset: 0xE0C - LTC PKHA E 3 Register
        volatile uint32_t LTC0_PKE0_4;  ///< Offset: 0xE10 - LTC PKHA E0 4 Register
        volatile uint32_t LTC0_PKE_4;  ///< Offset: 0xE10 - LTC PKHA E 4 Register
        volatile uint32_t LTC0_PKE0_5;  ///< Offset: 0xE14 - LTC PKHA E0 5 Register
        volatile uint32_t LTC0_PKE_5;  ///< Offset: 0xE14 - LTC PKHA E 5 Register
        volatile uint32_t LTC0_PKE0_6;  ///< Offset: 0xE18 - LTC PKHA E0 6 Register
        volatile uint32_t LTC0_PKE_6;  ///< Offset: 0xE18 - LTC PKHA E 6 Register
        volatile uint32_t LTC0_PKE0_7;  ///< Offset: 0xE1C - LTC PKHA E0 7 Register
        volatile uint32_t LTC0_PKE_7;  ///< Offset: 0xE1C - LTC PKHA E 7 Register
        volatile uint32_t LTC0_PKE0_8;  ///< Offset: 0xE20 - LTC PKHA E0 8 Register
        volatile uint32_t LTC0_PKE_8;  ///< Offset: 0xE20 - LTC PKHA E 8 Register
        volatile uint32_t LTC0_PKE0_9;  ///< Offset: 0xE24 - LTC PKHA E0 9 Register
        volatile uint32_t LTC0_PKE_9;  ///< Offset: 0xE24 - LTC PKHA E 9 Register
        volatile uint32_t LTC0_PKE0_10;  ///< Offset: 0xE28 - LTC PKHA E0 10 Register
        volatile uint32_t LTC0_PKE_10;  ///< Offset: 0xE28 - LTC PKHA E 10 Register
        volatile uint32_t LTC0_PKE0_11;  ///< Offset: 0xE2C - LTC PKHA E0 11 Register
        volatile uint32_t LTC0_PKE_11;  ///< Offset: 0xE2C - LTC PKHA E 11 Register
        volatile uint32_t LTC0_PKE0_12;  ///< Offset: 0xE30 - LTC PKHA E0 12 Register
        volatile uint32_t LTC0_PKE_12;  ///< Offset: 0xE30 - LTC PKHA E 12 Register
        volatile uint32_t LTC0_PKE0_13;  ///< Offset: 0xE34 - LTC PKHA E0 13 Register
        volatile uint32_t LTC0_PKE_13;  ///< Offset: 0xE34 - LTC PKHA E 13 Register
        volatile uint32_t LTC0_PKE0_14;  ///< Offset: 0xE38 - LTC PKHA E0 14 Register
        volatile uint32_t LTC0_PKE_14;  ///< Offset: 0xE38 - LTC PKHA E 14 Register
        volatile uint32_t LTC0_PKE0_15;  ///< Offset: 0xE3C - LTC PKHA E0 15 Register
        volatile uint32_t LTC0_PKE_15;  ///< Offset: 0xE3C - LTC PKHA E 15 Register
        volatile uint32_t LTC0_PKE1_0;  ///< Offset: 0xE40 - LTC PKHA E1 0 Register
        volatile uint32_t LTC0_PKE_16;  ///< Offset: 0xE40 - LTC PKHA E 16 Register
        volatile uint32_t LTC0_PKE1_1;  ///< Offset: 0xE44 - LTC PKHA E1 1 Register
        volatile uint32_t LTC0_PKE_17;  ///< Offset: 0xE44 - LTC PKHA E 17 Register
        volatile uint32_t LTC0_PKE1_2;  ///< Offset: 0xE48 - LTC PKHA E1 2 Register
        volatile uint32_t LTC0_PKE_18;  ///< Offset: 0xE48 - LTC PKHA E 18 Register
        volatile uint32_t LTC0_PKE1_3;  ///< Offset: 0xE4C - LTC PKHA E1 3 Register
        volatile uint32_t LTC0_PKE_19;  ///< Offset: 0xE4C - LTC PKHA E 19 Register
        volatile uint32_t LTC0_PKE1_4;  ///< Offset: 0xE50 - LTC PKHA E1 4 Register
        volatile uint32_t LTC0_PKE_20;  ///< Offset: 0xE50 - LTC PKHA E 20 Register
        volatile uint32_t LTC0_PKE1_5;  ///< Offset: 0xE54 - LTC PKHA E1 5 Register
        volatile uint32_t LTC0_PKE_21;  ///< Offset: 0xE54 - LTC PKHA E 21 Register
        volatile uint32_t LTC0_PKE1_6;  ///< Offset: 0xE58 - LTC PKHA E1 6 Register
        volatile uint32_t LTC0_PKE_22;  ///< Offset: 0xE58 - LTC PKHA E 22 Register
        volatile uint32_t LTC0_PKE1_7;  ///< Offset: 0xE5C - LTC PKHA E1 7 Register
        volatile uint32_t LTC0_PKE_23;  ///< Offset: 0xE5C - LTC PKHA E 23 Register
        volatile uint32_t LTC0_PKE1_8;  ///< Offset: 0xE60 - LTC PKHA E1 8 Register
        volatile uint32_t LTC0_PKE_24;  ///< Offset: 0xE60 - LTC PKHA E 24 Register
        volatile uint32_t LTC0_PKE1_9;  ///< Offset: 0xE64 - LTC PKHA E1 9 Register
        volatile uint32_t LTC0_PKE_25;  ///< Offset: 0xE64 - LTC PKHA E 25 Register
        volatile uint32_t LTC0_PKE1_10;  ///< Offset: 0xE68 - LTC PKHA E1 10 Register
        volatile uint32_t LTC0_PKE_26;  ///< Offset: 0xE68 - LTC PKHA E 26 Register
        volatile uint32_t LTC0_PKE1_11;  ///< Offset: 0xE6C - LTC PKHA E1 11 Register
        volatile uint32_t LTC0_PKE_27;  ///< Offset: 0xE6C - LTC PKHA E 27 Register
        volatile uint32_t LTC0_PKE1_12;  ///< Offset: 0xE70 - LTC PKHA E1 12 Register
        volatile uint32_t LTC0_PKE_28;  ///< Offset: 0xE70 - LTC PKHA E 28 Register
        volatile uint32_t LTC0_PKE1_13;  ///< Offset: 0xE74 - LTC PKHA E1 13 Register
        volatile uint32_t LTC0_PKE_29;  ///< Offset: 0xE74 - LTC PKHA E 29 Register
        volatile uint32_t LTC0_PKE1_14;  ///< Offset: 0xE78 - LTC PKHA E1 14 Register
        volatile uint32_t LTC0_PKE_30;  ///< Offset: 0xE78 - LTC PKHA E 30 Register
        volatile uint32_t LTC0_PKE1_15;  ///< Offset: 0xE7C - LTC PKHA E1 15 Register
        volatile uint32_t LTC0_PKE_31;  ///< Offset: 0xE7C - LTC PKHA E 31 Register
        volatile uint32_t LTC0_PKE2_0;  ///< Offset: 0xE80 - LTC PKHA E2 0 Register
        volatile uint32_t LTC0_PKE_32;  ///< Offset: 0xE80 - LTC PKHA E 32 Register
        volatile uint32_t LTC0_PKE2_1;  ///< Offset: 0xE84 - LTC PKHA E2 1 Register
        volatile uint32_t LTC0_PKE_33;  ///< Offset: 0xE84 - LTC PKHA E 33 Register
        volatile uint32_t LTC0_PKE2_2;  ///< Offset: 0xE88 - LTC PKHA E2 2 Register
        volatile uint32_t LTC0_PKE_34;  ///< Offset: 0xE88 - LTC PKHA E 34 Register
        volatile uint32_t LTC0_PKE2_3;  ///< Offset: 0xE8C - LTC PKHA E2 3 Register
        volatile uint32_t LTC0_PKE_35;  ///< Offset: 0xE8C - LTC PKHA E 35 Register
        volatile uint32_t LTC0_PKE2_4;  ///< Offset: 0xE90 - LTC PKHA E2 4 Register
        volatile uint32_t LTC0_PKE_36;  ///< Offset: 0xE90 - LTC PKHA E 36 Register
        volatile uint32_t LTC0_PKE2_5;  ///< Offset: 0xE94 - LTC PKHA E2 5 Register
        volatile uint32_t LTC0_PKE_37;  ///< Offset: 0xE94 - LTC PKHA E 37 Register
        volatile uint32_t LTC0_PKE2_6;  ///< Offset: 0xE98 - LTC PKHA E2 6 Register
        volatile uint32_t LTC0_PKE_38;  ///< Offset: 0xE98 - LTC PKHA E 38 Register
        volatile uint32_t LTC0_PKE2_7;  ///< Offset: 0xE9C - LTC PKHA E2 7 Register
        volatile uint32_t LTC0_PKE_39;  ///< Offset: 0xE9C - LTC PKHA E 39 Register
        volatile uint32_t LTC0_PKE2_8;  ///< Offset: 0xEA0 - LTC PKHA E2 8 Register
        volatile uint32_t LTC0_PKE_40;  ///< Offset: 0xEA0 - LTC PKHA E 40 Register
        volatile uint32_t LTC0_PKE2_9;  ///< Offset: 0xEA4 - LTC PKHA E2 9 Register
        volatile uint32_t LTC0_PKE_41;  ///< Offset: 0xEA4 - LTC PKHA E 41 Register
        volatile uint32_t LTC0_PKE2_10;  ///< Offset: 0xEA8 - LTC PKHA E2 10 Register
        volatile uint32_t LTC0_PKE_42;  ///< Offset: 0xEA8 - LTC PKHA E 42 Register
        volatile uint32_t LTC0_PKE2_11;  ///< Offset: 0xEAC - LTC PKHA E2 11 Register
        volatile uint32_t LTC0_PKE_43;  ///< Offset: 0xEAC - LTC PKHA E 43 Register
        volatile uint32_t LTC0_PKE2_12;  ///< Offset: 0xEB0 - LTC PKHA E2 12 Register
        volatile uint32_t LTC0_PKE_44;  ///< Offset: 0xEB0 - LTC PKHA E 44 Register
        volatile uint32_t LTC0_PKE2_13;  ///< Offset: 0xEB4 - LTC PKHA E2 13 Register
        volatile uint32_t LTC0_PKE_45;  ///< Offset: 0xEB4 - LTC PKHA E 45 Register
        volatile uint32_t LTC0_PKE2_14;  ///< Offset: 0xEB8 - LTC PKHA E2 14 Register
        volatile uint32_t LTC0_PKE_46;  ///< Offset: 0xEB8 - LTC PKHA E 46 Register
        volatile uint32_t LTC0_PKE2_15;  ///< Offset: 0xEBC - LTC PKHA E2 15 Register
        volatile uint32_t LTC0_PKE_47;  ///< Offset: 0xEBC - LTC PKHA E 47 Register
        volatile uint32_t LTC0_PKE3_0;  ///< Offset: 0xEC0 - LTC PKHA E3 0 Register
        volatile uint32_t LTC0_PKE_48;  ///< Offset: 0xEC0 - LTC PKHA E 48 Register
        volatile uint32_t LTC0_PKE3_1;  ///< Offset: 0xEC4 - LTC PKHA E3 1 Register
        volatile uint32_t LTC0_PKE_49;  ///< Offset: 0xEC4 - LTC PKHA E 49 Register
        volatile uint32_t LTC0_PKE3_2;  ///< Offset: 0xEC8 - LTC PKHA E3 2 Register
        volatile uint32_t LTC0_PKE_50;  ///< Offset: 0xEC8 - LTC PKHA E 50 Register
        volatile uint32_t LTC0_PKE3_3;  ///< Offset: 0xECC - LTC PKHA E3 3 Register
        volatile uint32_t LTC0_PKE_51;  ///< Offset: 0xECC - LTC PKHA E 51 Register
        volatile uint32_t LTC0_PKE3_4;  ///< Offset: 0xED0 - LTC PKHA E3 4 Register
        volatile uint32_t LTC0_PKE_52;  ///< Offset: 0xED0 - LTC PKHA E 52 Register
        volatile uint32_t LTC0_PKE3_5;  ///< Offset: 0xED4 - LTC PKHA E3 5 Register
        volatile uint32_t LTC0_PKE_53;  ///< Offset: 0xED4 - LTC PKHA E 53 Register
        volatile uint32_t LTC0_PKE3_6;  ///< Offset: 0xED8 - LTC PKHA E3 6 Register
        volatile uint32_t LTC0_PKE_54;  ///< Offset: 0xED8 - LTC PKHA E 54 Register
        volatile uint32_t LTC0_PKE3_7;  ///< Offset: 0xEDC - LTC PKHA E3 7 Register
        volatile uint32_t LTC0_PKE_55;  ///< Offset: 0xEDC - LTC PKHA E 55 Register
        volatile uint32_t LTC0_PKE3_8;  ///< Offset: 0xEE0 - LTC PKHA E3 8 Register
        volatile uint32_t LTC0_PKE_56;  ///< Offset: 0xEE0 - LTC PKHA E 56 Register
        volatile uint32_t LTC0_PKE3_9;  ///< Offset: 0xEE4 - LTC PKHA E3 9 Register
        volatile uint32_t LTC0_PKE_57;  ///< Offset: 0xEE4 - LTC PKHA E 57 Register
        volatile uint32_t LTC0_PKE3_10;  ///< Offset: 0xEE8 - LTC PKHA E3 10 Register
        volatile uint32_t LTC0_PKE_58;  ///< Offset: 0xEE8 - LTC PKHA E 58 Register
        volatile uint32_t LTC0_PKE3_11;  ///< Offset: 0xEEC - LTC PKHA E3 11 Register
        volatile uint32_t LTC0_PKE_59;  ///< Offset: 0xEEC - LTC PKHA E 59 Register
        volatile uint32_t LTC0_PKE3_12;  ///< Offset: 0xEF0 - LTC PKHA E3 12 Register
        volatile uint32_t LTC0_PKE_60;  ///< Offset: 0xEF0 - LTC PKHA E 60 Register
        volatile uint32_t LTC0_PKE3_13;  ///< Offset: 0xEF4 - LTC PKHA E3 13 Register
        volatile uint32_t LTC0_PKE_61;  ///< Offset: 0xEF4 - LTC PKHA E 61 Register
        volatile uint32_t LTC0_PKE3_14;  ///< Offset: 0xEF8 - LTC PKHA E3 14 Register
        volatile uint32_t LTC0_PKE_62;  ///< Offset: 0xEF8 - LTC PKHA E 62 Register
        volatile uint32_t LTC0_PKE3_15;  ///< Offset: 0xEFC - LTC PKHA E3 15 Register
        volatile uint32_t LTC0_PKE_63;  ///< Offset: 0xEFC - LTC PKHA E 63 Register
    };

    /// Peripheral instances
    inline Registers* LTC0 = reinterpret_cast<Registers*>(LTC0_BASE);

    // Bit definitions
    /// LTC0_MD Register bits
    namespace ltc0_md_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encrypt/Decrypt. This bit selects encryption or decryption.
        constexpr uint32_t ICV_TEST = (1U << 1);  ///< ICV Checking / Test AES fault detection
        constexpr uint32_t AS = (2 << 2);  ///< Algorithm State
        constexpr uint32_t AAI = (9 << 4);  ///< Additional Algorithm information
        constexpr uint32_t ALG = (8 << 16);  ///< Algorithm. This field specifies which algorithm is being selected.
    }

    /// LTC0_MDPK Register bits
    namespace ltc0_mdpk_bits {
        constexpr uint32_t PKHA_MODE_LS = (12 << 0);  ///< PKHA_MODE least significant 12 bits
        constexpr uint32_t PKHA_MODE_MS = (4 << 16);  ///< PKHA_MODE most-significant 4 bits
        constexpr uint32_t ALG = (4 << 20);  ///< Algorithm. This field specifies which algorithm is being selected.
    }

    /// LTC0_KS Register bits
    namespace ltc0_ks_bits {
        constexpr uint32_t KS = (6 << 0);  ///< Key Size. This is the size of a Key measured in bytes
    }

    /// LTC0_DS Register bits
    namespace ltc0_ds_bits {
        constexpr uint32_t DS = (12 << 0);  ///< Data Size
    }

    /// LTC0_ICVS Register bits
    namespace ltc0_icvs_bits {
        constexpr uint32_t ICVS = (5 << 0);  ///< ICV Size, in Bytes.
    }

    /// LTC0_COM Register bits
    namespace ltc0_com_bits {
        constexpr uint32_t ALL = (1U << 0);  ///< Reset All Internal Logic
        constexpr uint32_t AES = (1U << 1);  ///< Reset AESA. Writing a 1 to this bit resets the AES Accelerator core engine.
        constexpr uint32_t DES = (1U << 2);  ///< Reset DESA. Writing a 1 to this bit resets the DES Accelerator.
        constexpr uint32_t PK = (1U << 6);  ///< Reset PKHA. Writing a 1 to this bit resets the Public Key Hardware Accelerator.
        constexpr uint32_t MD = (1U << 7);  ///< Reset MDHA. Writing a 1 to this bit resets the Message Digest Hardware Accelerator.
    }

    /// LTC0_CTL Register bits
    namespace ltc0_ctl_bits {
        constexpr uint32_t IM = (1U << 0);  ///< Interrupt Mask. Once this bit is set, it can only be cleared by hard reset.
        constexpr uint32_t PDE = (1U << 4);  ///< PKHA Register DMA Enable.
        constexpr uint32_t IFE = (1U << 8);  ///< Input FIFO DMA Enable.
        constexpr uint32_t IFR = (1U << 9);  ///< Input FIFO DMA Request Size
        constexpr uint32_t OFE = (1U << 12);  ///< Output FIFO DMA Enable.
        constexpr uint32_t OFR = (1U << 13);  ///< Output FIFO DMA Request Size
        constexpr uint32_t IFS = (1U << 16);  ///< Input FIFO Byte Swap. Byte swap all data that is written to the Input FIFO.
        constexpr uint32_t OFS = (1U << 17);  ///< Output FIFO Byte Swap. Byte swap all data that is read from the Onput FIFO.
        constexpr uint32_t KIS = (1U << 20);  ///< Key Register Input Byte Swap
        constexpr uint32_t KOS = (1U << 21);  ///< Key Register Output Byte Swap
        constexpr uint32_t CIS = (1U << 22);  ///< Context Register Input Byte Swap
        constexpr uint32_t COS = (1U << 23);  ///< Context Register Output Byte Swap
        constexpr uint32_t KAL = (1U << 31);  ///< Key Register Access Lock
    }

    /// LTC0_CW Register bits
    namespace ltc0_cw_bits {
        constexpr uint32_t CM = (1U << 0);  ///< Clear the Mode Register. Writing a one to this bit causes the Mode Register to be cleared.
        constexpr uint32_t CDS = (1U << 2);  ///< Clear the Data Size Register
        constexpr uint32_t CICV = (1U << 3);  ///< Clear the ICV Size Register. Writing a one to this bit causes the ICV Size Register to be cleared.
        constexpr uint32_t CCR = (1U << 5);  ///< Clear the Context Register. Writing a one to this bit causes the Context Register to be cleared.
        constexpr uint32_t CKR = (1U << 6);  ///< Clear the Key Register
        constexpr uint32_t CPKA = (1U << 12);  ///< Clear the PKHA A Size Register
        constexpr uint32_t CPKB = (1U << 13);  ///< Clear the PKHA B Size Register
        constexpr uint32_t CPKN = (1U << 14);  ///< Clear the PKHA N Size Register
        constexpr uint32_t CPKE = (1U << 15);  ///< Clear the PKHA E Size Register
        constexpr uint32_t COF = (1U << 30);  ///< Clear Output FIFO. Writing a 1 to this bit causes the Output FIFO to be cleared.
        constexpr uint32_t CIF = (1U << 31);  ///< Clear Input FIFO. Writing a 1 to this bit causes the Input Data FIFO.
    }

    /// LTC0_STA Register bits
    namespace ltc0_sta_bits {
        constexpr uint32_t AB = (1U << 1);  ///< AESA Busy
        constexpr uint32_t DB = (1U << 2);  ///< DESA Busy
        constexpr uint32_t PB = (1U << 6);  ///< PKHA Busy
        constexpr uint32_t MB = (1U << 7);  ///< MDHA Busy
        constexpr uint32_t DI = (1U << 16);  ///< Done Interrupt
        constexpr uint32_t EI = (1U << 20);  ///< Error Interrupt
        constexpr uint32_t DPARRN = (1U << 24);  ///< This bit is asserted after POR and after every 50K blocks processed by AESA to indicate it is advisable for added security to write a new seed to
        constexpr uint32_t PKP = (1U << 28);  ///< Public Key is Prime
        constexpr uint32_t PKO = (1U << 29);  ///< Public Key Operation is One
        constexpr uint32_t PKZ = (1U << 30);  ///< Public Key Operation is Zero
    }

    /// LTC0_ESTA Register bits
    namespace ltc0_esta_bits {
        constexpr uint32_t ERRID1 = (4 << 0);  ///< Error ID 1
        constexpr uint32_t CL1 = (4 << 8);  ///< algorithms. The algorithms field indicates which algorithm is asserting an error. Others reserved
    }

    /// LTC0_AADSZ Register bits
    namespace ltc0_aadsz_bits {
        constexpr uint32_t AADSZ = (4 << 0);  ///< AAD size in Bytes, mod 16.
        constexpr uint32_t AL = (1U << 31);  ///< AAD Last. Only AAD data will be written into the Input FIFO.
    }

    /// LTC0_IVSZ Register bits
    namespace ltc0_ivsz_bits {
        constexpr uint32_t IVSZ = (4 << 0);  ///< IV size in Bytes, mod 16.
        constexpr uint32_t IL = (1U << 31);  ///< IV Last. Only IV data will be written into the Input FIFO.
    }

    /// LTC0_DPAMS Register bits
    namespace ltc0_dpams_bits {
        constexpr uint32_t DPAMS = (32 << 0);  ///< Differential Power Analysis Mask Seed
    }

    /// LTC0_PKASZ Register bits
    namespace ltc0_pkasz_bits {
        constexpr uint32_t PKASZ = (9 << 0);  ///< PKHA A Size. This is the size of the numeric value, in bytes, contained within the PKHA A Register.
    }

    /// LTC0_PKBSZ Register bits
    namespace ltc0_pkbsz_bits {
        constexpr uint32_t PKBSZ = (9 << 0);  ///< PKHA B Size. This is the size of the numeric value, in bytes, contained within the PKHA B Register.
    }

    /// LTC0_PKNSZ Register bits
    namespace ltc0_pknsz_bits {
        constexpr uint32_t PKNSZ = (9 << 0);  ///< PKHA N Size. This is the size of the numeric value, in bytes, contained within the PKHA N Register.
    }

    /// LTC0_PKESZ Register bits
    namespace ltc0_pkesz_bits {
        constexpr uint32_t PKESZ = (9 << 0);  ///< PKHA E Size. This is the size of the numeric value, in bytes, contained within the PKHA E Register.
    }

    /// LTC0_CTX_0 Register bits
    namespace ltc0_ctx_0_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_1 Register bits
    namespace ltc0_ctx_1_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_2 Register bits
    namespace ltc0_ctx_2_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_3 Register bits
    namespace ltc0_ctx_3_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_4 Register bits
    namespace ltc0_ctx_4_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_5 Register bits
    namespace ltc0_ctx_5_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_6 Register bits
    namespace ltc0_ctx_6_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_7 Register bits
    namespace ltc0_ctx_7_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_8 Register bits
    namespace ltc0_ctx_8_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_9 Register bits
    namespace ltc0_ctx_9_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_10 Register bits
    namespace ltc0_ctx_10_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_11 Register bits
    namespace ltc0_ctx_11_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_12 Register bits
    namespace ltc0_ctx_12_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_13 Register bits
    namespace ltc0_ctx_13_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_14 Register bits
    namespace ltc0_ctx_14_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_CTX_15 Register bits
    namespace ltc0_ctx_15_bits {
        constexpr uint32_t CTX = (32 << 0);  ///< CTX
    }

    /// LTC0_KEY_0 Register bits
    namespace ltc0_key_0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_1 Register bits
    namespace ltc0_key_1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_2 Register bits
    namespace ltc0_key_2_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_3 Register bits
    namespace ltc0_key_3_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_4 Register bits
    namespace ltc0_key_4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_5 Register bits
    namespace ltc0_key_5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_6 Register bits
    namespace ltc0_key_6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_KEY_7 Register bits
    namespace ltc0_key_7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< KEY
    }

    /// LTC0_VID1 Register bits
    namespace ltc0_vid1_bits {
        constexpr uint32_t MIN_REV = (8 << 0);  ///< Minor revision number.
        constexpr uint32_t MAJ_REV = (8 << 8);  ///< Major revision number.
        constexpr uint32_t IP_ID = (16 << 16);  ///< ID(0x0038).
    }

    /// LTC0_VID2 Register bits
    namespace ltc0_vid2_bits {
        constexpr uint32_t ECO_REV = (8 << 0);  ///< ECO revision number.
        constexpr uint32_t ARCH_ERA = (8 << 8);  ///< Architectural ERA.
    }

    /// LTC0_CHAVID Register bits
    namespace ltc0_chavid_bits {
        constexpr uint32_t AESREV = (4 << 0);  ///< AES Revision Number
        constexpr uint32_t AESVID = (4 << 4);  ///< AES Version ID
        constexpr uint32_t DESREV = (4 << 8);  ///< DES Revision Number
        constexpr uint32_t DESVID = (4 << 12);  ///< DES Version ID(0x0). 0000 - High-performance DESA 0001 - Low-performance DESA
        constexpr uint32_t PKHAREV = (4 << 16);  ///< PK Revision Number
        constexpr uint32_t PKHAVID = (4 << 20);  ///< PK Version ID 0001 - 32-bit PKHA-SD 0010 - 64-bit PKHA-SD 0011 - 128-bit PKHA-SD 0100 - 16-bit PKHA-SD
        constexpr uint32_t MDHAREV = (4 << 24);  ///< MDHA Revision Number
        constexpr uint32_t MDHAVID = (4 << 28);  ///< MDHA Hashing Version ID
    }

    /// LTC0_FIFOSTA Register bits
    namespace ltc0_fifosta_bits {
        constexpr uint32_t IFL = (7 << 0);  ///< Input FIFO Level. These bits indicate the current number of entries in the Input FIFO.
        constexpr uint32_t IFF = (1U << 15);  ///< Input FIFO Full. The Input FIFO is full and should not be written to.
        constexpr uint32_t OFL = (7 << 16);  ///< Output FIFO Level. These bits indicate the current number of entries in the Output FIFO.
        constexpr uint32_t OFF = (1U << 31);  ///< Output FIFO Full. The Output FIFO is full and should not be written to.
    }

    /// LTC0_IFIFO Register bits
    namespace ltc0_ififo_bits {
        constexpr uint32_t IFIFO = (32 << 0);  ///< IFIFO
    }

    /// LTC0_OFIFO Register bits
    namespace ltc0_ofifo_bits {
        constexpr uint32_t OFIFO = (32 << 0);  ///< Output FIFO
    }

    /// LTC0_PKA0_0 Register bits
    namespace ltc0_pka0_0_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_1 Register bits
    namespace ltc0_pka0_1_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_2 Register bits
    namespace ltc0_pka0_2_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_3 Register bits
    namespace ltc0_pka0_3_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_4 Register bits
    namespace ltc0_pka0_4_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_5 Register bits
    namespace ltc0_pka0_5_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_6 Register bits
    namespace ltc0_pka0_6_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_7 Register bits
    namespace ltc0_pka0_7_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_8 Register bits
    namespace ltc0_pka0_8_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_9 Register bits
    namespace ltc0_pka0_9_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_10 Register bits
    namespace ltc0_pka0_10_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_11 Register bits
    namespace ltc0_pka0_11_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_12 Register bits
    namespace ltc0_pka0_12_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_13 Register bits
    namespace ltc0_pka0_13_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_14 Register bits
    namespace ltc0_pka0_14_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA0_15 Register bits
    namespace ltc0_pka0_15_bits {
        constexpr uint32_t PKHA_A0 = (32 << 0);  ///< A0 VALUE
    }

    /// LTC0_PKA1_0 Register bits
    namespace ltc0_pka1_0_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_1 Register bits
    namespace ltc0_pka1_1_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_2 Register bits
    namespace ltc0_pka1_2_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_3 Register bits
    namespace ltc0_pka1_3_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_4 Register bits
    namespace ltc0_pka1_4_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_5 Register bits
    namespace ltc0_pka1_5_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_6 Register bits
    namespace ltc0_pka1_6_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_7 Register bits
    namespace ltc0_pka1_7_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_8 Register bits
    namespace ltc0_pka1_8_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_9 Register bits
    namespace ltc0_pka1_9_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_10 Register bits
    namespace ltc0_pka1_10_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_11 Register bits
    namespace ltc0_pka1_11_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_12 Register bits
    namespace ltc0_pka1_12_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_13 Register bits
    namespace ltc0_pka1_13_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_14 Register bits
    namespace ltc0_pka1_14_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA1_15 Register bits
    namespace ltc0_pka1_15_bits {
        constexpr uint32_t PKHA_A1 = (32 << 0);  ///< A1 VALUE
    }

    /// LTC0_PKA2_0 Register bits
    namespace ltc0_pka2_0_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_1 Register bits
    namespace ltc0_pka2_1_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_2 Register bits
    namespace ltc0_pka2_2_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_3 Register bits
    namespace ltc0_pka2_3_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_4 Register bits
    namespace ltc0_pka2_4_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_5 Register bits
    namespace ltc0_pka2_5_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_6 Register bits
    namespace ltc0_pka2_6_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_7 Register bits
    namespace ltc0_pka2_7_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_8 Register bits
    namespace ltc0_pka2_8_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_9 Register bits
    namespace ltc0_pka2_9_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_10 Register bits
    namespace ltc0_pka2_10_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_11 Register bits
    namespace ltc0_pka2_11_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_12 Register bits
    namespace ltc0_pka2_12_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_13 Register bits
    namespace ltc0_pka2_13_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_14 Register bits
    namespace ltc0_pka2_14_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA2_15 Register bits
    namespace ltc0_pka2_15_bits {
        constexpr uint32_t PKHA_A2 = (32 << 0);  ///< A2 VALUE
    }

    /// LTC0_PKA3_0 Register bits
    namespace ltc0_pka3_0_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_1 Register bits
    namespace ltc0_pka3_1_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_2 Register bits
    namespace ltc0_pka3_2_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_3 Register bits
    namespace ltc0_pka3_3_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_4 Register bits
    namespace ltc0_pka3_4_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_5 Register bits
    namespace ltc0_pka3_5_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_6 Register bits
    namespace ltc0_pka3_6_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_7 Register bits
    namespace ltc0_pka3_7_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_8 Register bits
    namespace ltc0_pka3_8_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_9 Register bits
    namespace ltc0_pka3_9_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_10 Register bits
    namespace ltc0_pka3_10_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_11 Register bits
    namespace ltc0_pka3_11_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_12 Register bits
    namespace ltc0_pka3_12_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_13 Register bits
    namespace ltc0_pka3_13_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_14 Register bits
    namespace ltc0_pka3_14_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKA3_15 Register bits
    namespace ltc0_pka3_15_bits {
        constexpr uint32_t PKHA_A3 = (32 << 0);  ///< A3 VALUE
    }

    /// LTC0_PKB0_0 Register bits
    namespace ltc0_pkb0_0_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_1 Register bits
    namespace ltc0_pkb0_1_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_2 Register bits
    namespace ltc0_pkb0_2_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_3 Register bits
    namespace ltc0_pkb0_3_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_4 Register bits
    namespace ltc0_pkb0_4_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_5 Register bits
    namespace ltc0_pkb0_5_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_6 Register bits
    namespace ltc0_pkb0_6_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_7 Register bits
    namespace ltc0_pkb0_7_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_8 Register bits
    namespace ltc0_pkb0_8_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_9 Register bits
    namespace ltc0_pkb0_9_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_10 Register bits
    namespace ltc0_pkb0_10_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_11 Register bits
    namespace ltc0_pkb0_11_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_12 Register bits
    namespace ltc0_pkb0_12_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_13 Register bits
    namespace ltc0_pkb0_13_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_14 Register bits
    namespace ltc0_pkb0_14_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB0_15 Register bits
    namespace ltc0_pkb0_15_bits {
        constexpr uint32_t PKHA_B0 = (32 << 0);  ///< B0 VALUE
    }

    /// LTC0_PKB1_0 Register bits
    namespace ltc0_pkb1_0_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_1 Register bits
    namespace ltc0_pkb1_1_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_2 Register bits
    namespace ltc0_pkb1_2_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_3 Register bits
    namespace ltc0_pkb1_3_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_4 Register bits
    namespace ltc0_pkb1_4_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_5 Register bits
    namespace ltc0_pkb1_5_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_6 Register bits
    namespace ltc0_pkb1_6_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_7 Register bits
    namespace ltc0_pkb1_7_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_8 Register bits
    namespace ltc0_pkb1_8_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_9 Register bits
    namespace ltc0_pkb1_9_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_10 Register bits
    namespace ltc0_pkb1_10_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_11 Register bits
    namespace ltc0_pkb1_11_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_12 Register bits
    namespace ltc0_pkb1_12_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_13 Register bits
    namespace ltc0_pkb1_13_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_14 Register bits
    namespace ltc0_pkb1_14_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB1_15 Register bits
    namespace ltc0_pkb1_15_bits {
        constexpr uint32_t PKHA_B1 = (32 << 0);  ///< B1 VALUE
    }

    /// LTC0_PKB2_0 Register bits
    namespace ltc0_pkb2_0_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_1 Register bits
    namespace ltc0_pkb2_1_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_2 Register bits
    namespace ltc0_pkb2_2_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_3 Register bits
    namespace ltc0_pkb2_3_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_4 Register bits
    namespace ltc0_pkb2_4_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_5 Register bits
    namespace ltc0_pkb2_5_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_6 Register bits
    namespace ltc0_pkb2_6_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_7 Register bits
    namespace ltc0_pkb2_7_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_8 Register bits
    namespace ltc0_pkb2_8_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_9 Register bits
    namespace ltc0_pkb2_9_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_10 Register bits
    namespace ltc0_pkb2_10_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_11 Register bits
    namespace ltc0_pkb2_11_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_12 Register bits
    namespace ltc0_pkb2_12_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_13 Register bits
    namespace ltc0_pkb2_13_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_14 Register bits
    namespace ltc0_pkb2_14_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB2_15 Register bits
    namespace ltc0_pkb2_15_bits {
        constexpr uint32_t PKHA_B2 = (32 << 0);  ///< B2 VALUE
    }

    /// LTC0_PKB3_0 Register bits
    namespace ltc0_pkb3_0_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_1 Register bits
    namespace ltc0_pkb3_1_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_2 Register bits
    namespace ltc0_pkb3_2_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_3 Register bits
    namespace ltc0_pkb3_3_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_4 Register bits
    namespace ltc0_pkb3_4_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_5 Register bits
    namespace ltc0_pkb3_5_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_6 Register bits
    namespace ltc0_pkb3_6_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_7 Register bits
    namespace ltc0_pkb3_7_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_8 Register bits
    namespace ltc0_pkb3_8_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_9 Register bits
    namespace ltc0_pkb3_9_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_10 Register bits
    namespace ltc0_pkb3_10_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_11 Register bits
    namespace ltc0_pkb3_11_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_12 Register bits
    namespace ltc0_pkb3_12_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_13 Register bits
    namespace ltc0_pkb3_13_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_14 Register bits
    namespace ltc0_pkb3_14_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKB3_15 Register bits
    namespace ltc0_pkb3_15_bits {
        constexpr uint32_t PKHA_B3 = (32 << 0);  ///< B3 VALUE
    }

    /// LTC0_PKN0_0 Register bits
    namespace ltc0_pkn0_0_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_1 Register bits
    namespace ltc0_pkn0_1_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_2 Register bits
    namespace ltc0_pkn0_2_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_3 Register bits
    namespace ltc0_pkn0_3_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_4 Register bits
    namespace ltc0_pkn0_4_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_5 Register bits
    namespace ltc0_pkn0_5_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_6 Register bits
    namespace ltc0_pkn0_6_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_7 Register bits
    namespace ltc0_pkn0_7_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_8 Register bits
    namespace ltc0_pkn0_8_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_9 Register bits
    namespace ltc0_pkn0_9_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_10 Register bits
    namespace ltc0_pkn0_10_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_11 Register bits
    namespace ltc0_pkn0_11_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_12 Register bits
    namespace ltc0_pkn0_12_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_13 Register bits
    namespace ltc0_pkn0_13_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_14 Register bits
    namespace ltc0_pkn0_14_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN0_15 Register bits
    namespace ltc0_pkn0_15_bits {
        constexpr uint32_t PKHA_N0 = (32 << 0);  ///< N0 VALUE
    }

    /// LTC0_PKN1_0 Register bits
    namespace ltc0_pkn1_0_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_1 Register bits
    namespace ltc0_pkn1_1_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_2 Register bits
    namespace ltc0_pkn1_2_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_3 Register bits
    namespace ltc0_pkn1_3_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_4 Register bits
    namespace ltc0_pkn1_4_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_5 Register bits
    namespace ltc0_pkn1_5_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_6 Register bits
    namespace ltc0_pkn1_6_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_7 Register bits
    namespace ltc0_pkn1_7_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_8 Register bits
    namespace ltc0_pkn1_8_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_9 Register bits
    namespace ltc0_pkn1_9_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_10 Register bits
    namespace ltc0_pkn1_10_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_11 Register bits
    namespace ltc0_pkn1_11_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_12 Register bits
    namespace ltc0_pkn1_12_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_13 Register bits
    namespace ltc0_pkn1_13_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_14 Register bits
    namespace ltc0_pkn1_14_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN1_15 Register bits
    namespace ltc0_pkn1_15_bits {
        constexpr uint32_t PKHA_N1 = (32 << 0);  ///< N1 VALUE
    }

    /// LTC0_PKN2_0 Register bits
    namespace ltc0_pkn2_0_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_1 Register bits
    namespace ltc0_pkn2_1_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_2 Register bits
    namespace ltc0_pkn2_2_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_3 Register bits
    namespace ltc0_pkn2_3_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_4 Register bits
    namespace ltc0_pkn2_4_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_5 Register bits
    namespace ltc0_pkn2_5_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_6 Register bits
    namespace ltc0_pkn2_6_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_7 Register bits
    namespace ltc0_pkn2_7_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_8 Register bits
    namespace ltc0_pkn2_8_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_9 Register bits
    namespace ltc0_pkn2_9_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_10 Register bits
    namespace ltc0_pkn2_10_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_11 Register bits
    namespace ltc0_pkn2_11_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_12 Register bits
    namespace ltc0_pkn2_12_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_13 Register bits
    namespace ltc0_pkn2_13_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_14 Register bits
    namespace ltc0_pkn2_14_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN2_15 Register bits
    namespace ltc0_pkn2_15_bits {
        constexpr uint32_t PKHA_N2 = (32 << 0);  ///< N2 VALUE
    }

    /// LTC0_PKN3_0 Register bits
    namespace ltc0_pkn3_0_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_1 Register bits
    namespace ltc0_pkn3_1_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_2 Register bits
    namespace ltc0_pkn3_2_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_3 Register bits
    namespace ltc0_pkn3_3_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_4 Register bits
    namespace ltc0_pkn3_4_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_5 Register bits
    namespace ltc0_pkn3_5_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_6 Register bits
    namespace ltc0_pkn3_6_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_7 Register bits
    namespace ltc0_pkn3_7_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_8 Register bits
    namespace ltc0_pkn3_8_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_9 Register bits
    namespace ltc0_pkn3_9_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_10 Register bits
    namespace ltc0_pkn3_10_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_11 Register bits
    namespace ltc0_pkn3_11_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_12 Register bits
    namespace ltc0_pkn3_12_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_13 Register bits
    namespace ltc0_pkn3_13_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_14 Register bits
    namespace ltc0_pkn3_14_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKN3_15 Register bits
    namespace ltc0_pkn3_15_bits {
        constexpr uint32_t PKHA_N3 = (32 << 0);  ///< N3 VALUE
    }

    /// LTC0_PKE0_0 Register bits
    namespace ltc0_pke0_0_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_1 Register bits
    namespace ltc0_pke0_1_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_2 Register bits
    namespace ltc0_pke0_2_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_3 Register bits
    namespace ltc0_pke0_3_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_4 Register bits
    namespace ltc0_pke0_4_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_5 Register bits
    namespace ltc0_pke0_5_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_6 Register bits
    namespace ltc0_pke0_6_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_7 Register bits
    namespace ltc0_pke0_7_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_8 Register bits
    namespace ltc0_pke0_8_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_9 Register bits
    namespace ltc0_pke0_9_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_10 Register bits
    namespace ltc0_pke0_10_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_11 Register bits
    namespace ltc0_pke0_11_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_12 Register bits
    namespace ltc0_pke0_12_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_13 Register bits
    namespace ltc0_pke0_13_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_14 Register bits
    namespace ltc0_pke0_14_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE0_15 Register bits
    namespace ltc0_pke0_15_bits {
        constexpr uint32_t PKHA_E0 = (32 << 0);  ///< E0 VALUE
    }

    /// LTC0_PKE1_0 Register bits
    namespace ltc0_pke1_0_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_1 Register bits
    namespace ltc0_pke1_1_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_2 Register bits
    namespace ltc0_pke1_2_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_3 Register bits
    namespace ltc0_pke1_3_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_4 Register bits
    namespace ltc0_pke1_4_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_5 Register bits
    namespace ltc0_pke1_5_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_6 Register bits
    namespace ltc0_pke1_6_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_7 Register bits
    namespace ltc0_pke1_7_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_8 Register bits
    namespace ltc0_pke1_8_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_9 Register bits
    namespace ltc0_pke1_9_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_10 Register bits
    namespace ltc0_pke1_10_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_11 Register bits
    namespace ltc0_pke1_11_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_12 Register bits
    namespace ltc0_pke1_12_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_13 Register bits
    namespace ltc0_pke1_13_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_14 Register bits
    namespace ltc0_pke1_14_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE1_15 Register bits
    namespace ltc0_pke1_15_bits {
        constexpr uint32_t PKHA_E1 = (32 << 0);  ///< E1 VALUE
    }

    /// LTC0_PKE2_0 Register bits
    namespace ltc0_pke2_0_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_1 Register bits
    namespace ltc0_pke2_1_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_2 Register bits
    namespace ltc0_pke2_2_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_3 Register bits
    namespace ltc0_pke2_3_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_4 Register bits
    namespace ltc0_pke2_4_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_5 Register bits
    namespace ltc0_pke2_5_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_6 Register bits
    namespace ltc0_pke2_6_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_7 Register bits
    namespace ltc0_pke2_7_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_8 Register bits
    namespace ltc0_pke2_8_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_9 Register bits
    namespace ltc0_pke2_9_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_10 Register bits
    namespace ltc0_pke2_10_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_11 Register bits
    namespace ltc0_pke2_11_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_12 Register bits
    namespace ltc0_pke2_12_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_13 Register bits
    namespace ltc0_pke2_13_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_14 Register bits
    namespace ltc0_pke2_14_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE2_15 Register bits
    namespace ltc0_pke2_15_bits {
        constexpr uint32_t PKHA_E2 = (32 << 0);  ///< E2 VALUE
    }

    /// LTC0_PKE3_0 Register bits
    namespace ltc0_pke3_0_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_1 Register bits
    namespace ltc0_pke3_1_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_2 Register bits
    namespace ltc0_pke3_2_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_3 Register bits
    namespace ltc0_pke3_3_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_4 Register bits
    namespace ltc0_pke3_4_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_5 Register bits
    namespace ltc0_pke3_5_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_6 Register bits
    namespace ltc0_pke3_6_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_7 Register bits
    namespace ltc0_pke3_7_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_8 Register bits
    namespace ltc0_pke3_8_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_9 Register bits
    namespace ltc0_pke3_9_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_10 Register bits
    namespace ltc0_pke3_10_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_11 Register bits
    namespace ltc0_pke3_11_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_12 Register bits
    namespace ltc0_pke3_12_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_13 Register bits
    namespace ltc0_pke3_13_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_14 Register bits
    namespace ltc0_pke3_14_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

    /// LTC0_PKE3_15 Register bits
    namespace ltc0_pke3_15_bits {
        constexpr uint32_t PKHA_E3 = (32 << 0);  ///< E3 VALUE
    }

}

// ============================================================================
// WDOG Peripheral
// ============================================================================

namespace wdog {
    /// Base addresses
    constexpr uint32_t WDOG_BASE = 0x40052000;

    /// WDOG Register structure
    struct Registers {
        volatile uint32_t STCTRLH;  ///< Offset: 0x00 - Watchdog Status and Control Register High
        volatile uint32_t STCTRLL;  ///< Offset: 0x02 - Watchdog Status and Control Register Low
        volatile uint32_t TOVALH;  ///< Offset: 0x04 - Watchdog Time-out Value Register High
        volatile uint32_t TOVALL;  ///< Offset: 0x06 - Watchdog Time-out Value Register Low
        volatile uint32_t WINH;  ///< Offset: 0x08 - Watchdog Window Register High
        volatile uint32_t WINL;  ///< Offset: 0x0A - Watchdog Window Register Low
        volatile uint32_t REFRESH;  ///< Offset: 0x0C - Watchdog Refresh register
        volatile uint32_t UNLOCK;  ///< Offset: 0x0E - Watchdog Unlock register
        volatile uint32_t TMROUTH;  ///< Offset: 0x10 - Watchdog Timer Output Register High
        volatile uint32_t TMROUTL;  ///< Offset: 0x12 - Watchdog Timer Output Register Low
        volatile uint32_t RSTCNT;  ///< Offset: 0x14 - Watchdog Reset Count register
        volatile uint32_t PRESC;  ///< Offset: 0x16 - Watchdog Prescaler register
    };

    /// Peripheral instances
    inline Registers* WDOG = reinterpret_cast<Registers*>(WDOG_BASE);

    // Bit definitions
    /// STCTRLH Register bits
    namespace stctrlh_bits {
        constexpr uint32_t WDOGEN = (1U << 0);  ///< Enables or disables the WDOG's operation
        constexpr uint32_t CLKSRC = (1U << 1);  ///< Selects clock source for the WDOG timer and other internal timing operations.
        constexpr uint32_t IRQRSTEN = (1U << 2);  ///< Used to enable the debug breadcrumbs feature
        constexpr uint32_t WINEN = (1U << 3);  ///< Enables Windowing mode.
        constexpr uint32_t ALLOWUPDATE = (1U << 4);  ///< Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
        constexpr uint32_t DBGEN = (1U << 5);  ///< Enables or disables WDOG in Debug mode.
        constexpr uint32_t STOPEN = (1U << 6);  ///< Enables or disables WDOG in Stop mode.
        constexpr uint32_t WAITEN = (1U << 7);  ///< Enables or disables WDOG in Wait mode.
        constexpr uint32_t TESTWDOG = (1U << 10);  ///< Puts the watchdog in the functional test mode
        constexpr uint32_t TESTSEL = (1U << 11);  ///< Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
        constexpr uint32_t BYTESEL = (2 << 12);  ///< This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
        constexpr uint32_t DISTESTWDOG = (1U << 14);  ///< Allows the WDOG's functional test mode to be disabled permanently
    }

    /// STCTRLL Register bits
    namespace stctrll_bits {
        constexpr uint32_t INTFLG = (1U << 15);  ///< Interrupt flag
    }

    /// TOVALH Register bits
    namespace tovalh_bits {
        constexpr uint32_t TOVALHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// TOVALL Register bits
    namespace tovall_bits {
        constexpr uint32_t TOVALLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
    }

    /// WINH Register bits
    namespace winh_bits {
        constexpr uint32_t WINHIGH = (16 << 0);  ///< Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// WINL Register bits
    namespace winl_bits {
        constexpr uint32_t WINLOW = (16 << 0);  ///< Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
    }

    /// REFRESH Register bits
    namespace refresh_bits {
        constexpr uint32_t WDOGREFRESH = (16 << 0);  ///< Watchdog refresh register
    }

    /// UNLOCK Register bits
    namespace unlock_bits {
        constexpr uint32_t WDOGUNLOCK = (16 << 0);  ///< Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
    }

    /// TMROUTH Register bits
    namespace tmrouth_bits {
        constexpr uint32_t TIMEROUTHIGH = (16 << 0);  ///< Shows the value of the upper 16 bits of the watchdog timer.
    }

    /// TMROUTL Register bits
    namespace tmroutl_bits {
        constexpr uint32_t TIMEROUTLOW = (16 << 0);  ///< Shows the value of the lower 16 bits of the watchdog timer.
    }

    /// RSTCNT Register bits
    namespace rstcnt_bits {
        constexpr uint32_t RSTCNT = (16 << 0);  ///< Counts the number of times the watchdog resets the system
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCVAL = (3 << 8);  ///< 3-bit prescaler for the watchdog clock source
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART0_BASE = 0x40054000;
    constexpr uint32_t LPUART1_BASE = 0x40055000;
    constexpr uint32_t LPUART2_BASE = 0x40056000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t BAUD;  ///< Offset: 0x00 - LPUART Baud Rate Register
        volatile uint32_t STAT;  ///< Offset: 0x04 - LPUART Status Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - LPUART Control Register
        volatile uint32_t DATA;  ///< Offset: 0x0C - LPUART Data Register
        volatile uint32_t MATCH;  ///< Offset: 0x10 - LPUART Match Address Register
        volatile uint32_t MODIR;  ///< Offset: 0x14 - LPUART Modem IrDA Register
        volatile uint32_t FIFO;  ///< Offset: 0x18 - LPUART FIFO Register
        volatile uint32_t WATER;  ///< Offset: 0x1C - LPUART Watermark Register
    };

    /// Peripheral instances
    inline Registers* LPUART0 = reinterpret_cast<Registers*>(LPUART0_BASE);
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* LPUART2 = reinterpret_cast<Registers*>(LPUART2_BASE);

    // Bit definitions
    /// BAUD Register bits
    namespace baud_bits {
        constexpr uint32_t SBR = (13 << 0);  ///< Baud Rate Modulo Divisor.
        constexpr uint32_t SBNS = (1U << 13);  ///< Stop Bit Number Select
        constexpr uint32_t RXEDGIE = (1U << 14);  ///< RX Input Active Edge Interrupt Enable
        constexpr uint32_t LBKDIE = (1U << 15);  ///< LIN Break Detect Interrupt Enable
        constexpr uint32_t RESYNCDIS = (1U << 16);  ///< Resynchronization Disable
        constexpr uint32_t BOTHEDGE = (1U << 17);  ///< Both Edge Sampling
        constexpr uint32_t MATCFG = (2 << 18);  ///< Match Configuration
        constexpr uint32_t RDMAE = (1U << 21);  ///< Receiver Full DMA Enable
        constexpr uint32_t TDMAE = (1U << 23);  ///< Transmitter DMA Enable
        constexpr uint32_t OSR = (5 << 24);  ///< Oversampling Ratio
        constexpr uint32_t M10 = (1U << 29);  ///< 10-bit Mode select
        constexpr uint32_t MAEN2 = (1U << 30);  ///< Match Address Mode Enable 2
        constexpr uint32_t MAEN1 = (1U << 31);  ///< Match Address Mode Enable 1
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t MA2F = (1U << 14);  ///< Match 2 Flag
        constexpr uint32_t MA1F = (1U << 15);  ///< Match 1 Flag
        constexpr uint32_t PF = (1U << 16);  ///< Parity Error Flag
        constexpr uint32_t FE = (1U << 17);  ///< Framing Error Flag
        constexpr uint32_t NF = (1U << 18);  ///< Noise Flag
        constexpr uint32_t OR_ = (1U << 19);  ///< Receiver Overrun Flag (renamed from OR_)
        constexpr uint32_t IDLE = (1U << 20);  ///< Idle Line Flag
        constexpr uint32_t RDRF = (1U << 21);  ///< Receive Data Register Full Flag
        constexpr uint32_t TC = (1U << 22);  ///< Transmission Complete Flag
        constexpr uint32_t TDRE = (1U << 23);  ///< Transmit Data Register Empty Flag
        constexpr uint32_t RAF = (1U << 24);  ///< Receiver Active Flag
        constexpr uint32_t LBKDE = (1U << 25);  ///< LIN Break Detection Enable
        constexpr uint32_t BRK13 = (1U << 26);  ///< Break Character Generation Length
        constexpr uint32_t RWUID = (1U << 27);  ///< Receive Wake Up Idle Detect
        constexpr uint32_t RXINV = (1U << 28);  ///< Receive Data Inversion
        constexpr uint32_t MSBF = (1U << 29);  ///< MSB First
        constexpr uint32_t RXEDGIF = (1U << 30);  ///< LPUART_RX Pin Active Edge Interrupt Flag
        constexpr uint32_t LBKDIF = (1U << 31);  ///< LIN Break Detect Interrupt Flag
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t PT = (1U << 0);  ///< Parity Type
        constexpr uint32_t PE = (1U << 1);  ///< Parity Enable
        constexpr uint32_t ILT = (1U << 2);  ///< Idle Line Type Select
        constexpr uint32_t WAKE = (1U << 3);  ///< Receiver Wakeup Method Select
        constexpr uint32_t M = (1U << 4);  ///< 9-Bit or 8-Bit Mode Select
        constexpr uint32_t RSRC = (1U << 5);  ///< Receiver Source Select
        constexpr uint32_t DOZEEN = (1U << 6);  ///< Doze Enable
        constexpr uint32_t LOOPS = (1U << 7);  ///< Loop Mode Select
        constexpr uint32_t IDLECFG = (3 << 8);  ///< Idle Configuration
        constexpr uint32_t MA2IE = (1U << 14);  ///< Match 2 Interrupt Enable
        constexpr uint32_t MA1IE = (1U << 15);  ///< Match 1 Interrupt Enable
        constexpr uint32_t SBK = (1U << 16);  ///< Send Break
        constexpr uint32_t RWU = (1U << 17);  ///< Receiver Wakeup Control
        constexpr uint32_t RE = (1U << 18);  ///< Receiver Enable
        constexpr uint32_t TE = (1U << 19);  ///< Transmitter Enable
        constexpr uint32_t ILIE = (1U << 20);  ///< Idle Line Interrupt Enable
        constexpr uint32_t RIE = (1U << 21);  ///< Receiver Interrupt Enable
        constexpr uint32_t TCIE = (1U << 22);  ///< Transmission Complete Interrupt Enable for
        constexpr uint32_t TIE = (1U << 23);  ///< Transmit Interrupt Enable
        constexpr uint32_t PEIE = (1U << 24);  ///< Parity Error Interrupt Enable
        constexpr uint32_t FEIE = (1U << 25);  ///< Framing Error Interrupt Enable
        constexpr uint32_t NEIE = (1U << 26);  ///< Noise Error Interrupt Enable
        constexpr uint32_t ORIE = (1U << 27);  ///< Overrun Interrupt Enable
        constexpr uint32_t TXINV = (1U << 28);  ///< Transmit Data Inversion
        constexpr uint32_t TXDIR = (1U << 29);  ///< LPUART_TX Pin Direction in Single-Wire Mode
        constexpr uint32_t R9T8 = (1U << 30);  ///< Receive Bit 9 / Transmit Bit 8
        constexpr uint32_t R8T9 = (1U << 31);  ///< Receive Bit 8 / Transmit Bit 9
    }

    /// DATA Register bits
    namespace data_bits {
        constexpr uint32_t R0T0 = (1U << 0);  ///< Read receive data buffer 0 or write transmit data buffer 0.
        constexpr uint32_t R1T1 = (1U << 1);  ///< Read receive data buffer 1 or write transmit data buffer 1.
        constexpr uint32_t R2T2 = (1U << 2);  ///< Read receive data buffer 2 or write transmit data buffer 2.
        constexpr uint32_t R3T3 = (1U << 3);  ///< Read receive data buffer 3 or write transmit data buffer 3.
        constexpr uint32_t R4T4 = (1U << 4);  ///< Read receive data buffer 4 or write transmit data buffer 4.
        constexpr uint32_t R5T5 = (1U << 5);  ///< Read receive data buffer 5 or write transmit data buffer 5.
        constexpr uint32_t R6T6 = (1U << 6);  ///< Read receive data buffer 6 or write transmit data buffer 6.
        constexpr uint32_t R7T7 = (1U << 7);  ///< Read receive data buffer 7 or write transmit data buffer 7.
        constexpr uint32_t R8T8 = (1U << 8);  ///< Read receive data buffer 8 or write transmit data buffer 8.
        constexpr uint32_t R9T9 = (1U << 9);  ///< Read receive data buffer 9 or write transmit data buffer 9.
        constexpr uint32_t IDLINE = (1U << 11);  ///< Idle Line
        constexpr uint32_t RXEMPT = (1U << 12);  ///< Receive Buffer Empty
        constexpr uint32_t FRETSC = (1U << 13);  ///< Frame Error / Transmit Special Character
        constexpr uint32_t PARITYE = (1U << 14);  ///< The current received dataword contained in DATA[R9:R0] was received with a parity error.
        constexpr uint32_t NOISY = (1U << 15);  ///< The current received dataword contained in DATA[R9:R0] was received with noise.
    }

    /// MATCH Register bits
    namespace match_bits {
        constexpr uint32_t MA1 = (10 << 0);  ///< Match Address 1
        constexpr uint32_t MA2 = (10 << 16);  ///< Match Address 2
    }

    /// MODIR Register bits
    namespace modir_bits {
        constexpr uint32_t TXCTSE = (1U << 0);  ///< Transmitter clear-to-send enable
        constexpr uint32_t TXRTSE = (1U << 1);  ///< Transmitter request-to-send enable
        constexpr uint32_t TXRTSPOL = (1U << 2);  ///< Transmitter request-to-send polarity
        constexpr uint32_t RXRTSE = (1U << 3);  ///< Receiver request-to-send enable
        constexpr uint32_t TXCTSC = (1U << 4);  ///< Transmit CTS Configuration
        constexpr uint32_t TXCTSSRC = (1U << 5);  ///< Transmit CTS Source
        constexpr uint32_t RTSWATER = (8 << 8);  ///< Receive RTS Configuration
        constexpr uint32_t TNP = (2 << 16);  ///< Transmitter narrow pulse
        constexpr uint32_t IREN = (1U << 18);  ///< Infrared enable
    }

    /// FIFO Register bits
    namespace fifo_bits {
        constexpr uint32_t RXFIFOSIZE = (3 << 0);  ///< Receive FIFO. Buffer Depth
        constexpr uint32_t RXFE = (1U << 3);  ///< Receive FIFO Enable
        constexpr uint32_t TXFIFOSIZE = (3 << 4);  ///< Transmit FIFO. Buffer Depth
        constexpr uint32_t TXFE = (1U << 7);  ///< Transmit FIFO Enable
        constexpr uint32_t RXUFE = (1U << 8);  ///< Receive FIFO Underflow Interrupt Enable
        constexpr uint32_t TXOFE = (1U << 9);  ///< Transmit FIFO Overflow Interrupt Enable
        constexpr uint32_t RXIDEN = (3 << 10);  ///< Receiver Idle Empty Enable
        constexpr uint32_t RXFLUSH = (1U << 14);  ///< Receive FIFO/Buffer Flush
        constexpr uint32_t TXFLUSH = (1U << 15);  ///< Transmit FIFO/Buffer Flush
        constexpr uint32_t RXUF = (1U << 16);  ///< Receiver Buffer Underflow Flag
        constexpr uint32_t TXOF = (1U << 17);  ///< Transmitter Buffer Overflow Flag
        constexpr uint32_t RXEMPT = (1U << 22);  ///< Receive Buffer/FIFO Empty
        constexpr uint32_t TXEMPT = (1U << 23);  ///< Transmit Buffer/FIFO Empty
    }

    /// WATER Register bits
    namespace water_bits {
        constexpr uint32_t TXWATER = (8 << 0);  ///< Transmit Watermark
        constexpr uint32_t TXCOUNT = (8 << 8);  ///< Transmit Counter
        constexpr uint32_t RXWATER = (8 << 16);  ///< Receive Watermark
        constexpr uint32_t RXCOUNT = (8 << 24);  ///< Receive Counter
    }

}

// ============================================================================
// FLEXIO0 Peripheral
// ============================================================================

namespace flexio0 {
    /// Base addresses
    constexpr uint32_t FLEXIO0_BASE = 0x4005F000;

    /// FLEXIO0 Register structure
    struct Registers {
        volatile uint32_t VERID;  ///< Offset: 0x00 - Version ID Register
        volatile uint32_t PARAM;  ///< Offset: 0x04 - Parameter Register
        volatile uint32_t CTRL;  ///< Offset: 0x08 - FlexIO Control Register
        volatile uint32_t PIN;  ///< Offset: 0x0C - Pin State Register
        volatile uint32_t SHIFTSTAT;  ///< Offset: 0x10 - Shifter Status Register
        volatile uint32_t SHIFTERR;  ///< Offset: 0x14 - Shifter Error Register
        volatile uint32_t TIMSTAT;  ///< Offset: 0x18 - Timer Status Register
        volatile uint32_t SHIFTSIEN;  ///< Offset: 0x20 - Shifter Status Interrupt Enable
        volatile uint32_t SHIFTEIEN;  ///< Offset: 0x24 - Shifter Error Interrupt Enable
        volatile uint32_t TIMIEN;  ///< Offset: 0x28 - Timer Interrupt Enable Register
        volatile uint32_t SHIFTSDEN;  ///< Offset: 0x30 - Shifter Status DMA Enable
        volatile uint32_t SHIFTSTATE;  ///< Offset: 0x40 - Shifter State Register
        volatile uint32_t SHIFTCTL;  ///< Offset: 0x80 - Shifter Control N Register (renamed from SHIFTCTL)
        volatile uint32_t SHIFTCFG;  ///< Offset: 0x100 - Shifter Configuration N Register (renamed from SHIFTCFG)
        volatile uint32_t SHIFTBUF;  ///< Offset: 0x200 - Shifter Buffer N Register (renamed from SHIFTBUF)
        volatile uint32_t SHIFTBUFBIS;  ///< Offset: 0x280 - Shifter Buffer N Bit Swapped Register (renamed from SHIFTBUFBIS)
        volatile uint32_t SHIFTBUFBYS;  ///< Offset: 0x300 - Shifter Buffer N Byte Swapped Register (renamed from SHIFTBUFBYS)
        volatile uint32_t SHIFTBUFBBS;  ///< Offset: 0x380 - Shifter Buffer N Bit Byte Swapped Register (renamed from SHIFTBUFBBS)
        volatile uint32_t TIMCTL;  ///< Offset: 0x400 - Timer Control N Register (renamed from TIMCTL)
        volatile uint32_t TIMCFG;  ///< Offset: 0x480 - Timer Configuration N Register (renamed from TIMCFG)
        volatile uint32_t TIMCMP;  ///< Offset: 0x500 - Timer Compare N Register (renamed from TIMCMP)
        volatile uint32_t SHIFTBUFNBS;  ///< Offset: 0x680 - Shifter Buffer N Nibble Byte Swapped Register (renamed from SHIFTBUFNBS)
        volatile uint32_t SHIFTBUFHWS;  ///< Offset: 0x700 - Shifter Buffer N Half Word Swapped Register (renamed from SHIFTBUFHWS)
        volatile uint32_t SHIFTBUFNIS;  ///< Offset: 0x780 - Shifter Buffer N Nibble Swapped Register (renamed from SHIFTBUFNIS)
    };

    /// Peripheral instances
    inline Registers* FLEXIO0 = reinterpret_cast<Registers*>(FLEXIO0_BASE);

    // Bit definitions
    /// VERID Register bits
    namespace verid_bits {
        constexpr uint32_t FEATURE = (16 << 0);  ///< Feature Specification Number
        constexpr uint32_t MINOR = (8 << 16);  ///< Minor Version Number
        constexpr uint32_t MAJOR = (8 << 24);  ///< Major Version Number
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t SHIFTER = (8 << 0);  ///< Shifter Number
        constexpr uint32_t TIMER = (8 << 8);  ///< Timer Number
        constexpr uint32_t PIN = (8 << 16);  ///< Pin Number
        constexpr uint32_t TRIGGER = (8 << 24);  ///< Trigger Number
    }

    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t FLEXEN = (1U << 0);  ///< FlexIO Enable
        constexpr uint32_t SWRST = (1U << 1);  ///< Software Reset
        constexpr uint32_t FASTACC = (1U << 2);  ///< Fast Access
        constexpr uint32_t DBGE = (1U << 30);  ///< Debug Enable
        constexpr uint32_t DOZEN = (1U << 31);  ///< Doze Enable
    }

    /// PIN Register bits
    namespace pin_bits {
        constexpr uint32_t PDI = (32 << 0);  ///< Pin Data Input
    }

    /// SHIFTSTAT Register bits
    namespace shiftstat_bits {
        constexpr uint32_t SSF = (8 << 0);  ///< Shifter Status Flag
    }

    /// SHIFTERR Register bits
    namespace shifterr_bits {
        constexpr uint32_t SEF = (8 << 0);  ///< Shifter Error Flags
    }

    /// TIMSTAT Register bits
    namespace timstat_bits {
        constexpr uint32_t TSF = (8 << 0);  ///< Timer Status Flags
    }

    /// SHIFTSIEN Register bits
    namespace shiftsien_bits {
        constexpr uint32_t SSIE = (8 << 0);  ///< Shifter Status Interrupt Enable
    }

    /// SHIFTEIEN Register bits
    namespace shifteien_bits {
        constexpr uint32_t SEIE = (8 << 0);  ///< Shifter Error Interrupt Enable
    }

    /// TIMIEN Register bits
    namespace timien_bits {
        constexpr uint32_t TEIE = (8 << 0);  ///< Timer Status Interrupt Enable
    }

    /// SHIFTSDEN Register bits
    namespace shiftsden_bits {
        constexpr uint32_t SSDE = (8 << 0);  ///< Shifter Status DMA Enable
    }

    /// SHIFTSTATE Register bits
    namespace shiftstate_bits {
        constexpr uint32_t STATE = (3 << 0);  ///< Current State Pointer
    }

    /// SHIFTCTL Register bits
    namespace shiftctl_bits {
        constexpr uint32_t SMOD = (3 << 0);  ///< Shifter Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Shifter Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Shifter Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Shifter Pin Configuration
        constexpr uint32_t TIMPOL = (1U << 23);  ///< Timer Polarity
        constexpr uint32_t TIMSEL = (3 << 24);  ///< Timer Select
    }

    /// SHIFTCFG Register bits
    namespace shiftcfg_bits {
        constexpr uint32_t SSTART = (2 << 0);  ///< Shifter Start bit
        constexpr uint32_t SSTOP = (2 << 4);  ///< Shifter Stop bit
        constexpr uint32_t INSRC = (1U << 8);  ///< Input Source
        constexpr uint32_t PWIDTH = (5 << 16);  ///< Parallel Width
    }

    /// SHIFTBUF Register bits
    namespace shiftbuf_bits {
        constexpr uint32_t SHIFTBUF = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBIS Register bits
    namespace shiftbufbis_bits {
        constexpr uint32_t SHIFTBUFBIS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBYS Register bits
    namespace shiftbufbys_bits {
        constexpr uint32_t SHIFTBUFBYS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFBBS Register bits
    namespace shiftbufbbs_bits {
        constexpr uint32_t SHIFTBUFBBS = (32 << 0);  ///< Shift Buffer
    }

    /// TIMCTL Register bits
    namespace timctl_bits {
        constexpr uint32_t TIMOD = (2 << 0);  ///< Timer Mode
        constexpr uint32_t PINPOL = (1U << 7);  ///< Timer Pin Polarity
        constexpr uint32_t PINSEL = (5 << 8);  ///< Timer Pin Select
        constexpr uint32_t PINCFG = (2 << 16);  ///< Timer Pin Configuration
        constexpr uint32_t TRGSRC = (1U << 22);  ///< Trigger Source
        constexpr uint32_t TRGPOL = (1U << 23);  ///< Trigger Polarity
        constexpr uint32_t TRGSEL = (6 << 24);  ///< Trigger Select
    }

    /// TIMCFG Register bits
    namespace timcfg_bits {
        constexpr uint32_t TSTART = (1U << 1);  ///< Timer Start Bit
        constexpr uint32_t TSTOP = (2 << 4);  ///< Timer Stop Bit
        constexpr uint32_t TIMENA = (3 << 8);  ///< Timer Enable
        constexpr uint32_t TIMDIS = (3 << 12);  ///< Timer Disable
        constexpr uint32_t TIMRST = (3 << 16);  ///< Timer Reset
        constexpr uint32_t TIMDEC = (2 << 20);  ///< Timer Decrement
        constexpr uint32_t TIMOUT = (2 << 24);  ///< Timer Output
    }

    /// TIMCMP Register bits
    namespace timcmp_bits {
        constexpr uint32_t CMP = (16 << 0);  ///< Timer Compare Value
    }

    /// SHIFTBUFNBS Register bits
    namespace shiftbufnbs_bits {
        constexpr uint32_t SHIFTBUFNBS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFHWS Register bits
    namespace shiftbufhws_bits {
        constexpr uint32_t SHIFTBUFHWS = (32 << 0);  ///< Shift Buffer
    }

    /// SHIFTBUFNIS Register bits
    namespace shiftbufnis_bits {
        constexpr uint32_t SHIFTBUFNIS = (32 << 0);  ///< Shift Buffer
    }

}

// ============================================================================
// EWM Peripheral
// ============================================================================

namespace ewm {
    /// Base addresses
    constexpr uint32_t EWM_BASE = 0x40061000;

    /// EWM Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - Control Register
        volatile uint32_t SERV;  ///< Offset: 0x01 - Service Register
        volatile uint32_t CMPL;  ///< Offset: 0x02 - Compare Low Register
        volatile uint32_t CMPH;  ///< Offset: 0x03 - Compare High Register
        volatile uint32_t CLKPRESCALER;  ///< Offset: 0x05 - Clock Prescaler Register
    };

    /// Peripheral instances
    inline Registers* EWM = reinterpret_cast<Registers*>(EWM_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t EWMEN = (1U << 0);  ///< EWM enable.
        constexpr uint32_t ASSIN = (1U << 1);  ///< EWM_in's Assertion State Select.
        constexpr uint32_t INEN = (1U << 2);  ///< Input Enable.
        constexpr uint32_t INTEN = (1U << 3);  ///< Interrupt Enable.
    }

    /// SERV Register bits
    namespace serv_bits {
        constexpr uint32_t SERVICE = (8 << 0);  ///< The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
    }

    /// CMPL Register bits
    namespace cmpl_bits {
        constexpr uint32_t COMPAREL = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
    }

    /// CMPH Register bits
    namespace cmph_bits {
        constexpr uint32_t COMPAREH = (8 << 0);  ///< To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
    }

    /// CLKPRESCALER Register bits
    namespace clkprescaler_bits {
        constexpr uint32_t CLK_DIV = (8 << 0);  ///< Selected low power clock source for running the EWM counter can be prescaled as below
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t MCG_BASE = 0x40064000;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t C1;  ///< Offset: 0x00 - MCG Control 1 Register
        volatile uint32_t C2;  ///< Offset: 0x01 - MCG Control 2 Register
        volatile uint32_t C3;  ///< Offset: 0x02 - MCG Control 3 Register
        volatile uint32_t C4;  ///< Offset: 0x03 - MCG Control 4 Register
        volatile uint32_t C5;  ///< Offset: 0x04 - MCG Control 5 Register
        volatile uint32_t C6;  ///< Offset: 0x05 - MCG Control 6 Register
        volatile uint32_t S;  ///< Offset: 0x06 - MCG Status Register
        volatile uint32_t SC;  ///< Offset: 0x08 - MCG Status and Control Register
        volatile uint32_t ATCVH;  ///< Offset: 0x0A - MCG Auto Trim Compare Value High Register
        volatile uint32_t ATCVL;  ///< Offset: 0x0B - MCG Auto Trim Compare Value Low Register
        volatile uint32_t C7;  ///< Offset: 0x0C - MCG Control 7 Register
        volatile uint32_t C8;  ///< Offset: 0x0D - MCG Control 8 Register
    };

    /// Peripheral instances
    inline Registers* MCG = reinterpret_cast<Registers*>(MCG_BASE);

    // Bit definitions
    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t IREFSTEN = (1U << 0);  ///< Internal Reference Stop Enable
        constexpr uint32_t IRCLKEN = (1U << 1);  ///< Internal Reference Clock Enable
        constexpr uint32_t IREFS = (1U << 2);  ///< Internal Reference Select
        constexpr uint32_t FRDIV = (3 << 3);  ///< FLL External Reference Divider
        constexpr uint32_t CLKS = (2 << 6);  ///< Clock Source Select
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t IRCS = (1U << 0);  ///< Internal Reference Clock Select
        constexpr uint32_t LP = (1U << 1);  ///< Low Power Select
        constexpr uint32_t EREFS = (1U << 2);  ///< External Reference Select
        constexpr uint32_t HGO = (1U << 3);  ///< High Gain Oscillator Select
        constexpr uint32_t RANGE = (2 << 4);  ///< Frequency Range Select
        constexpr uint32_t FCFTRIM = (1U << 6);  ///< Fast Internal Reference Clock Fine Trim
        constexpr uint32_t LOCRE0 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

    /// C3 Register bits
    namespace c3_bits {
        constexpr uint32_t SCTRIM = (8 << 0);  ///< Slow Internal Reference Clock Trim Setting
    }

    /// C4 Register bits
    namespace c4_bits {
        constexpr uint32_t SCFTRIM = (1U << 0);  ///< Slow Internal Reference Clock Fine Trim
        constexpr uint32_t FCTRIM = (4 << 1);  ///< Fast Internal Reference Clock Trim Setting
        constexpr uint32_t DRST_DRS = (2 << 5);  ///< DCO Range Select
        constexpr uint32_t DMX32 = (1U << 7);  ///< DCO Maximum Frequency with 32.768 kHz Reference
    }

    /// C5 Register bits
    namespace c5_bits {
        constexpr uint32_t PRDIV = (3 << 0);  ///< PLL External Reference Divider
        constexpr uint32_t PLLSTEN = (1U << 5);  ///< PLL Stop Enable
        constexpr uint32_t PLLCLKEN = (1U << 6);  ///< PLL Clock Enable
    }

    /// C6 Register bits
    namespace c6_bits {
        constexpr uint32_t VDIV = (5 << 0);  ///< VCO Divider
        constexpr uint32_t CME0 = (1U << 5);  ///< Clock Monitor Enable
        constexpr uint32_t PLLS = (1U << 6);  ///< PLL Select
        constexpr uint32_t LOLIE0 = (1U << 7);  ///< Loss of Lock Interrrupt Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t IRCST = (1U << 0);  ///< Internal Reference Clock Status
        constexpr uint32_t OSCINIT0 = (1U << 1);  ///< OSC Initialization
        constexpr uint32_t CLKST = (2 << 2);  ///< Clock Mode Status
        constexpr uint32_t IREFST = (1U << 4);  ///< Internal Reference Status
        constexpr uint32_t PLLST = (1U << 5);  ///< PLL Select Status
        constexpr uint32_t LOCK0 = (1U << 6);  ///< Lock Status
        constexpr uint32_t LOLS0 = (1U << 7);  ///< Loss of Lock Status
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t LOCS0 = (1U << 0);  ///< OSC0 Loss of Clock Status
        constexpr uint32_t FCRDIV = (3 << 1);  ///< Fast Clock Internal Reference Divider
        constexpr uint32_t FLTPRSRV = (1U << 4);  ///< FLL Filter Preserve Enable
        constexpr uint32_t ATMF = (1U << 5);  ///< Automatic Trim Machine Fail Flag
        constexpr uint32_t ATMS = (1U << 6);  ///< Automatic Trim Machine Select
        constexpr uint32_t ATME = (1U << 7);  ///< Automatic Trim Machine Enable
    }

    /// ATCVH Register bits
    namespace atcvh_bits {
        constexpr uint32_t ATCVH = (8 << 0);  ///< ATM Compare Value High
    }

    /// ATCVL Register bits
    namespace atcvl_bits {
        constexpr uint32_t ATCVL = (8 << 0);  ///< ATM Compare Value Low
    }

    /// C7 Register bits
    namespace c7_bits {
        constexpr uint32_t OSCSEL = (2 << 0);  ///< MCG OSC Clock Select
    }

    /// C8 Register bits
    namespace c8_bits {
        constexpr uint32_t LOCS1 = (1U << 0);  ///< RTC Loss of Clock Status
        constexpr uint32_t CME1 = (1U << 5);  ///< Clock Monitor Enable1
        constexpr uint32_t LOLRE = (1U << 6);  ///< PLL Loss of Lock Reset Enable
        constexpr uint32_t LOCRE1 = (1U << 7);  ///< Loss of Clock Reset Enable
    }

}

// ============================================================================
// OSC Peripheral
// ============================================================================

namespace osc {
    /// Base addresses
    constexpr uint32_t OSC_BASE = 0x40065000;

    /// OSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OSC Control Register
        volatile uint32_t DIV;  ///< Offset: 0x02 - OSC_DIV
    };

    /// Peripheral instances
    inline Registers* OSC = reinterpret_cast<Registers*>(OSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t SC16P = (1U << 0);  ///< Oscillator 16 pF Capacitor Load Configure
        constexpr uint32_t SC8P = (1U << 1);  ///< Oscillator 8 pF Capacitor Load Configure
        constexpr uint32_t SC4P = (1U << 2);  ///< Oscillator 4 pF Capacitor Load Configure
        constexpr uint32_t SC2P = (1U << 3);  ///< Oscillator 2 pF Capacitor Load Configure
        constexpr uint32_t EREFSTEN = (1U << 5);  ///< External Reference Stop Enable
        constexpr uint32_t ERCLKEN = (1U << 7);  ///< External Reference Enable
    }

    /// DIV Register bits
    namespace div_bits {
        constexpr uint32_t ERPS = (2 << 6);  ///< ERCLK prescaler
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C0_BASE = 0x40066000;
    constexpr uint32_t I2C1_BASE = 0x40067000;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t A1;  ///< Offset: 0x00 - I2C Address Register 1
        volatile uint32_t F;  ///< Offset: 0x01 - I2C Frequency Divider register
        volatile uint32_t C1;  ///< Offset: 0x02 - I2C Control Register 1
        volatile uint32_t S;  ///< Offset: 0x03 - I2C Status register
        volatile uint32_t D;  ///< Offset: 0x04 - I2C Data I/O register
        volatile uint32_t C2;  ///< Offset: 0x05 - I2C Control Register 2
        volatile uint32_t FLT;  ///< Offset: 0x06 - I2C Programmable Input Glitch Filter Register
        volatile uint32_t RA;  ///< Offset: 0x07 - I2C Range Address register
        volatile uint32_t SMB;  ///< Offset: 0x08 - I2C SMBus Control and Status register
        volatile uint32_t A2;  ///< Offset: 0x09 - I2C Address Register 2
        volatile uint32_t SLTH;  ///< Offset: 0x0A - I2C SCL Low Timeout Register High
        volatile uint32_t SLTL;  ///< Offset: 0x0B - I2C SCL Low Timeout Register Low
        volatile uint32_t S2;  ///< Offset: 0x0C - I2C Status register 2
    };

    /// Peripheral instances
    inline Registers* I2C0 = reinterpret_cast<Registers*>(I2C0_BASE);
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);

    // Bit definitions
    /// A1 Register bits
    namespace a1_bits {
        constexpr uint32_t AD = (7 << 1);  ///< Address
    }

    /// F Register bits
    namespace f_bits {
        constexpr uint32_t ICR = (6 << 0);  ///< ClockRate
        constexpr uint32_t MULT = (2 << 6);  ///< Multiplier Factor
    }

    /// C1 Register bits
    namespace c1_bits {
        constexpr uint32_t DMAEN = (1U << 0);  ///< DMA Enable
        constexpr uint32_t WUEN = (1U << 1);  ///< Wakeup Enable
        constexpr uint32_t RSTA = (1U << 2);  ///< Repeat START
        constexpr uint32_t TXAK = (1U << 3);  ///< Transmit Acknowledge Enable
        constexpr uint32_t TX = (1U << 4);  ///< Transmit Mode Select
        constexpr uint32_t MST = (1U << 5);  ///< Master Mode Select
        constexpr uint32_t IICIE = (1U << 6);  ///< I2C Interrupt Enable
        constexpr uint32_t IICEN = (1U << 7);  ///< I2C Enable
    }

    /// S Register bits
    namespace s_bits {
        constexpr uint32_t RXAK = (1U << 0);  ///< Receive Acknowledge
        constexpr uint32_t IICIF = (1U << 1);  ///< Interrupt Flag
        constexpr uint32_t SRW = (1U << 2);  ///< Slave Read/Write
        constexpr uint32_t RAM = (1U << 3);  ///< Range Address Match
        constexpr uint32_t ARBL = (1U << 4);  ///< Arbitration Lost
        constexpr uint32_t BUSY = (1U << 5);  ///< Bus Busy
        constexpr uint32_t IAAS = (1U << 6);  ///< Addressed As A Slave
        constexpr uint32_t TCF = (1U << 7);  ///< Transfer Complete Flag
    }

    /// D Register bits
    namespace d_bits {
        constexpr uint32_t DATA = (8 << 0);  ///< Data
    }

    /// C2 Register bits
    namespace c2_bits {
        constexpr uint32_t AD = (3 << 0);  ///< Slave Address
        constexpr uint32_t RMEN = (1U << 3);  ///< Range Address Matching Enable
        constexpr uint32_t SBRC = (1U << 4);  ///< Slave Baud Rate Control
        constexpr uint32_t HDRS = (1U << 5);  ///< High Drive Select
        constexpr uint32_t ADEXT = (1U << 6);  ///< Address Extension
        constexpr uint32_t GCAEN = (1U << 7);  ///< General Call Address Enable
    }

    /// FLT Register bits
    namespace flt_bits {
        constexpr uint32_t FLT = (4 << 0);  ///< I2C Programmable Filter Factor
        constexpr uint32_t STARTF = (1U << 4);  ///< I2C Bus Start Detect Flag
        constexpr uint32_t SSIE = (1U << 5);  ///< I2C Bus Stop or Start Interrupt Enable
        constexpr uint32_t STOPF = (1U << 6);  ///< I2C Bus Stop Detect Flag
        constexpr uint32_t SHEN = (1U << 7);  ///< Stop Hold Enable
    }

    /// RA Register bits
    namespace ra_bits {
        constexpr uint32_t RAD = (7 << 1);  ///< Range Slave Address
    }

    /// SMB Register bits
    namespace smb_bits {
        constexpr uint32_t SHTF2IE = (1U << 0);  ///< SHTF2 Interrupt Enable
        constexpr uint32_t SHTF2 = (1U << 1);  ///< SCL High Timeout Flag 2
        constexpr uint32_t SHTF1 = (1U << 2);  ///< SCL High Timeout Flag 1
        constexpr uint32_t SLTF = (1U << 3);  ///< SCL Low Timeout Flag
        constexpr uint32_t TCKSEL = (1U << 4);  ///< Timeout Counter Clock Select
        constexpr uint32_t SIICAEN = (1U << 5);  ///< Second I2C Address Enable
        constexpr uint32_t ALERTEN = (1U << 6);  ///< SMBus Alert Response Address Enable
        constexpr uint32_t FACK = (1U << 7);  ///< Fast NACK/ACK Enable
    }

    /// A2 Register bits
    namespace a2_bits {
        constexpr uint32_t SAD = (7 << 1);  ///< SMBus Address
    }

    /// SLTH Register bits
    namespace slth_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[15:8]
    }

    /// SLTL Register bits
    namespace sltl_bits {
        constexpr uint32_t SSLT = (8 << 0);  ///< SSLT[7:0]
    }

    /// S2 Register bits
    namespace s2_bits {
        constexpr uint32_t EMPTY = (1U << 0);  ///< Empty flag
        constexpr uint32_t ERROR = (1U << 1);  ///< Error flag
        constexpr uint32_t DFEN = (1U << 2);  ///< Double Buffer Enable
    }

}

// ============================================================================
// USB Peripheral
// ============================================================================

namespace usb {
    /// Base addresses
    constexpr uint32_t USB0_BASE = 0x40072000;

    /// USB Register structure
    struct Registers {
        volatile uint32_t PERID;  ///< Offset: 0x00 - Peripheral ID register
        volatile uint32_t IDCOMP;  ///< Offset: 0x04 - Peripheral ID Complement register
        volatile uint32_t REV;  ///< Offset: 0x08 - Peripheral Revision register
        volatile uint32_t ADDINFO;  ///< Offset: 0x0C - Peripheral Additional Info register
        volatile uint32_t OTGISTAT;  ///< Offset: 0x10 - OTG Interrupt Status register
        volatile uint32_t OTGICR;  ///< Offset: 0x14 - OTG Interrupt Control register
        volatile uint32_t OTGSTAT;  ///< Offset: 0x18 - OTG Status register
        volatile uint32_t OTGCTL;  ///< Offset: 0x1C - OTG Control register
        volatile uint32_t ISTAT;  ///< Offset: 0x80 - Interrupt Status register
        volatile uint32_t INTEN;  ///< Offset: 0x84 - Interrupt Enable register
        volatile uint32_t ERRSTAT;  ///< Offset: 0x88 - Error Interrupt Status register
        volatile uint32_t ERREN;  ///< Offset: 0x8C - Error Interrupt Enable register
        volatile uint32_t STAT;  ///< Offset: 0x90 - Status register
        volatile uint32_t CTL;  ///< Offset: 0x94 - Control register
        volatile uint32_t ADDR;  ///< Offset: 0x98 - Address register
        volatile uint32_t BDTPAGE1;  ///< Offset: 0x9C - BDT Page register 1
        volatile uint32_t FRMNUML;  ///< Offset: 0xA0 - Frame Number register Low
        volatile uint32_t FRMNUMH;  ///< Offset: 0xA4 - Frame Number register High
        volatile uint32_t TOKEN;  ///< Offset: 0xA8 - Token register
        volatile uint32_t SOFTHLD;  ///< Offset: 0xAC - SOF Threshold register
        volatile uint32_t BDTPAGE2;  ///< Offset: 0xB0 - BDT Page Register 2
        volatile uint32_t BDTPAGE3;  ///< Offset: 0xB4 - BDT Page Register 3
        volatile uint32_t ENDPT;  ///< Offset: 0xC0 - Endpoint Control register (renamed from ENDPT)
        volatile uint32_t USBCTRL;  ///< Offset: 0x100 - USB Control register
        volatile uint32_t OBSERVE;  ///< Offset: 0x104 - USB OTG Observe register
        volatile uint32_t CONTROL;  ///< Offset: 0x108 - USB OTG Control register
        volatile uint32_t USBTRC0;  ///< Offset: 0x10C - USB Transceiver Control register 0
        volatile uint32_t USBFRMADJUST;  ///< Offset: 0x114 - Frame Adjust Register
        volatile uint32_t KEEP_ALIVE_CTRL;  ///< Offset: 0x124 - Keep Alive mode control
        volatile uint32_t KEEP_ALIVE_WKCTRL;  ///< Offset: 0x128 - Keep Alive mode wakeup control
        volatile uint32_t MISCCTRL;  ///< Offset: 0x12C - Miscellaneous Control register
        volatile uint32_t STALL_IL_DIS;  ///< Offset: 0x130 - Peripheral mode stall disable for endpoints 7 to 0 in IN...
        volatile uint32_t STALL_IH_DIS;  ///< Offset: 0x134 - Peripheral mode stall disable for endpoints 15 to 8 in...
        volatile uint32_t STALL_OL_DIS;  ///< Offset: 0x138 - Peripheral mode stall disable for endpoints 7 to 0 in...
        volatile uint32_t STALL_OH_DIS;  ///< Offset: 0x13C - Peripheral mode stall disable for endpoints 15 to 8 in...
        volatile uint32_t CLK_RECOVER_CTRL;  ///< Offset: 0x140 - USB Clock recovery control
        volatile uint32_t CLK_RECOVER_IRC_EN;  ///< Offset: 0x144 - IRC48M oscillator enable register
        volatile uint32_t CLK_RECOVER_INT_EN;  ///< Offset: 0x154 - Clock recovery combined interrupt enable
        volatile uint32_t CLK_RECOVER_INT_STATUS;  ///< Offset: 0x15C - Clock recovery separated interrupt status
    };

    /// Peripheral instances
    inline Registers* USB0 = reinterpret_cast<Registers*>(USB0_BASE);

    // Bit definitions
    /// PERID Register bits
    namespace perid_bits {
        constexpr uint32_t ID = (6 << 0);  ///< Peripheral Identification
    }

    /// IDCOMP Register bits
    namespace idcomp_bits {
        constexpr uint32_t NID = (6 << 0);  ///< Ones' complement of PERID[ID] bits.
    }

    /// REV Register bits
    namespace rev_bits {
        constexpr uint32_t REV = (8 << 0);  ///< Revision
    }

    /// ADDINFO Register bits
    namespace addinfo_bits {
        constexpr uint32_t IEHOST = (1U << 0);  ///< This bit is set if host mode is enabled.
    }

    /// OTGISTAT Register bits
    namespace otgistat_bits {
        constexpr uint32_t LINE_STATE_CHG = (1U << 5);  ///< This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable
        constexpr uint32_t ONEMSEC = (1U << 6);  ///< This bit is set when the 1 millisecond timer expires
    }

    /// OTGICR Register bits
    namespace otgicr_bits {
        constexpr uint32_t LINESTATEEN = (1U << 5);  ///< Line State Change Interrupt Enable
        constexpr uint32_t ONEMSECEN = (1U << 6);  ///< One Millisecond Interrupt Enable
    }

    /// OTGSTAT Register bits
    namespace otgstat_bits {
        constexpr uint32_t LINESTATESTABLE = (1U << 5);  ///< Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 ms
        constexpr uint32_t ONEMSECEN = (1U << 6);  ///< This bit is reserved for the 1ms count, but it is not useful to software.
    }

    /// OTGCTL Register bits
    namespace otgctl_bits {
        constexpr uint32_t OTGEN = (1U << 2);  ///< On-The-Go pullup/pulldown resistor enable
        constexpr uint32_t DMLOW = (1U << 4);  ///< D- Data Line pull-down resistor enable
        constexpr uint32_t DPLOW = (1U << 5);  ///< D+ Data Line pull-down resistor enable
        constexpr uint32_t DPHIGH = (1U << 7);  ///< D+ Data Line pullup resistor enable
    }

    /// ISTAT Register bits
    namespace istat_bits {
        constexpr uint32_t USBRST = (1U << 0);  ///< This bit is set when the USB Module has decoded a valid USB reset
        constexpr uint32_t ERROR = (1U << 1);  ///< This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
        constexpr uint32_t SOFTOK = (1U << 2);  ///< This bit is set when the USB Module receives a Start Of Frame (SOF) token
        constexpr uint32_t TOKDNE = (1U << 3);  ///< This bit is set when the current token being processed has completed
        constexpr uint32_t SLEEP = (1U << 4);  ///< This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
        constexpr uint32_t RESUME = (1U << 5);  ///< This bit is set when a K-state is observed on the DP/DM signals for 2
        constexpr uint32_t ATTACH = (1U << 6);  ///< Attach Interrupt
        constexpr uint32_t STALL = (1U << 7);  ///< Stall Interrupt
    }

    /// INTEN Register bits
    namespace inten_bits {
        constexpr uint32_t USBRSTEN = (1U << 0);  ///< USBRST Interrupt Enable
        constexpr uint32_t ERROREN = (1U << 1);  ///< ERROR Interrupt Enable
        constexpr uint32_t SOFTOKEN = (1U << 2);  ///< SOFTOK Interrupt Enable
        constexpr uint32_t TOKDNEEN = (1U << 3);  ///< TOKDNE Interrupt Enable
        constexpr uint32_t SLEEPEN = (1U << 4);  ///< SLEEP Interrupt Enable
        constexpr uint32_t RESUMEEN = (1U << 5);  ///< RESUME Interrupt Enable
        constexpr uint32_t ATTACHEN = (1U << 6);  ///< ATTACH Interrupt Enable
        constexpr uint32_t STALLEN = (1U << 7);  ///< STALL Interrupt Enable
    }

    /// ERRSTAT Register bits
    namespace errstat_bits {
        constexpr uint32_t PIDERR = (1U << 0);  ///< This bit is set when the PID check field fails.
        constexpr uint32_t CRC5EOF = (1U << 1);  ///< This error interrupt has two functions
        constexpr uint32_t CRC16 = (1U << 2);  ///< This bit is set when a data packet is rejected due to a CRC16 error.
        constexpr uint32_t DFN8 = (1U << 3);  ///< This bit is set if the data field received was not 8 bits in length
        constexpr uint32_t BTOERR = (1U << 4);  ///< This bit is set when a bus turnaround timeout error occurs
        constexpr uint32_t DMAERR = (1U << 5);  ///< This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
        constexpr uint32_t OWNERR = (1U << 6);  ///< This field is valid when the USB Module is operating in peripheral mode (CTL[HOSTMODEEN]=0)
        constexpr uint32_t BTSERR = (1U << 7);  ///< This bit is set when a bit stuff error is detected
    }

    /// ERREN Register bits
    namespace erren_bits {
        constexpr uint32_t PIDERREN = (1U << 0);  ///< PIDERR Interrupt Enable
        constexpr uint32_t CRC5EOFEN = (1U << 1);  ///< CRC5/EOF Interrupt Enable
        constexpr uint32_t CRC16EN = (1U << 2);  ///< CRC16 Interrupt Enable
        constexpr uint32_t DFN8EN = (1U << 3);  ///< DFN8 Interrupt Enable
        constexpr uint32_t BTOERREN = (1U << 4);  ///< BTOERR Interrupt Enable
        constexpr uint32_t DMAERREN = (1U << 5);  ///< DMAERR Interrupt Enable
        constexpr uint32_t OWNERREN = (1U << 6);  ///< OWNERR Interrupt Enable
        constexpr uint32_t BTSERREN = (1U << 7);  ///< BTSERR Interrupt Enable
    }

    /// STAT Register bits
    namespace stat_bits {
        constexpr uint32_t ODD = (1U << 2);  ///< This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
        constexpr uint32_t TX = (1U << 3);  ///< Transmit Indicator
        constexpr uint32_t ENDP = (4 << 4);  ///< This four-bit field encodes the endpoint address that received or transmitted the previous token
    }

    /// CTL Register bits
    namespace ctl_bits {
        constexpr uint32_t USBENSOFEN = (1U << 0);  ///< USB Enable
        constexpr uint32_t ODDRST = (1U << 1);  ///< Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
        constexpr uint32_t RESUME = (1U << 2);  ///< When set to 1 this bit enables the USB Module to execute resume signaling
        constexpr uint32_t HOSTMODEEN = (1U << 3);  ///< When set to 1, this bit enables the USB Module to operate in Host mode
        constexpr uint32_t RESET = (1U << 4);  ///< Setting this bit enables the USB Module to generate USB reset signaling
        constexpr uint32_t TXSUSPENDTOKENBUSY = (1U << 5);  ///< In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token
        constexpr uint32_t SE0 = (1U << 6);  ///< Live USB Single Ended Zero signal
        constexpr uint32_t JSTATE = (1U << 7);  ///< Live USB differential receiver JSTATE signal
    }

    /// ADDR Register bits
    namespace addr_bits {
        constexpr uint32_t ADDR = (7 << 0);  ///< USB Address
        constexpr uint32_t LSEN = (1U << 7);  ///< Low Speed Enable bit
    }

    /// BDTPAGE1 Register bits
    namespace bdtpage1_bits {
        constexpr uint32_t BDTBA = (7 << 1);  ///< Provides address bits 15 through 9 of the BDT base address.
    }

    /// FRMNUML Register bits
    namespace frmnuml_bits {
        constexpr uint32_t FRM = (8 << 0);  ///< This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// FRMNUMH Register bits
    namespace frmnumh_bits {
        constexpr uint32_t FRM = (3 << 0);  ///< This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
    }

    /// TOKEN Register bits
    namespace token_bits {
        constexpr uint32_t TOKENENDPT = (4 << 0);  ///< Holds the Endpoint address for the token command
        constexpr uint32_t TOKENPID = (4 << 4);  ///< Contains the token type executed by the USB module.
    }

    /// SOFTHLD Register bits
    namespace softhld_bits {
        constexpr uint32_t CNT = (8 << 0);  ///< Represents the SOF count threshold in byte times when SOFDYNTHLD=0 or 8 byte times when SOFDYNTHLD=1
    }

    /// BDTPAGE2 Register bits
    namespace bdtpage2_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// BDTPAGE3 Register bits
    namespace bdtpage3_bits {
        constexpr uint32_t BDTBA = (8 << 0);  ///< Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
    }

    /// ENDPT Register bits
    namespace endpt_bits {
        constexpr uint32_t EPHSHK = (1U << 0);  ///< When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
        constexpr uint32_t EPSTALL = (1U << 1);  ///< When set, this bit indicates that the endpoint is stalled
        constexpr uint32_t EPTXEN = (1U << 2);  ///< This bit, when set, enables the endpoint for TX transfers. See
        constexpr uint32_t EPRXEN = (1U << 3);  ///< This bit, when set, enables the endpoint for RX transfers. See
        constexpr uint32_t EPCTLDIS = (1U << 4);  ///< This bit, when set, disables control (SETUP) transfers
        constexpr uint32_t RETRYDIS = (1U << 6);  ///< This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only
        constexpr uint32_t HOSTWOHUB = (1U << 7);  ///< Host without a hub This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only
    }

    /// USBCTRL Register bits
    namespace usbctrl_bits {
        constexpr uint32_t UARTSEL = (1U << 4);  ///< Selects USB signals to be used as UART signals.
        constexpr uint32_t UARTCHLS = (1U << 5);  ///< UART Signal Channel Select
        constexpr uint32_t PDE = (1U << 6);  ///< Enables the weak pulldowns on the USB transceiver.
        constexpr uint32_t SUSP = (1U << 7);  ///< Places the USB transceiver into the suspend state.
    }

    /// OBSERVE Register bits
    namespace observe_bits {
        constexpr uint32_t DMPD = (1U << 4);  ///< Provides observability of the D- Pulldown enable at the USB transceiver.
        constexpr uint32_t DPPD = (1U << 6);  ///< Provides observability of the D+ Pulldown enable at the USB transceiver.
        constexpr uint32_t DPPU = (1U << 7);  ///< Provides observability of the D+ Pullup enable at the USB transceiver.
    }

    /// CONTROL Register bits
    namespace control_bits {
        constexpr uint32_t DPPULLUPNONOTG = (1U << 4);  ///< Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.
    }

    /// USBTRC0 Register bits
    namespace usbtrc0_bits {
        constexpr uint32_t USB_RESUME_INT = (1U << 0);  ///< USB Asynchronous Interrupt
        constexpr uint32_t SYNC_DET = (1U << 1);  ///< Synchronous USB Interrupt Detect
        constexpr uint32_t USB_CLK_RECOVERY_INT = (1U << 2);  ///< Combined USB Clock Recovery interrupt status
        constexpr uint32_t VREDG_DET = (1U << 3);  ///< VREGIN Rising Edge Interrupt Detect
        constexpr uint32_t VFEDG_DET = (1U << 4);  ///< VREGIN Falling Edge Interrupt Detect
        constexpr uint32_t USBRESMEN = (1U << 5);  ///< Asynchronous Resume Interrupt Enable
        constexpr uint32_t USBRESET = (1U << 7);  ///< USB Reset
    }

    /// USBFRMADJUST Register bits
    namespace usbfrmadjust_bits {
        constexpr uint32_t ADJ = (8 << 0);  ///< Frame Adjustment
    }

    /// KEEP_ALIVE_CTRL Register bits
    namespace keep_alive_ctrl_bits {
        constexpr uint32_t KEEP_ALIVE_EN = (1U << 0);  ///< Global enable for USB_KEEP_ALIVE mode
        constexpr uint32_t OWN_OVERRD_EN = (1U << 1);  ///< When set to 1, during KEEP_ALIVE mode, if received token is not SETUP, the OWN bit of current BD will be forced to 0, so usb core will respond with NAK
        constexpr uint32_t WAKE_REQ_EN = (1U << 3);  ///< During KEEP_ALIVE mode, a bus access by the USB controller to a memory location outside the USB SRAM will cause the bus access to stall until KEEP_ALIVE mode is exited
        constexpr uint32_t WAKE_INT_EN = (1U << 4);  ///< Wakeup Interrupt Enable.
        constexpr uint32_t WAKE_INT_STS = (1U << 7);  ///< Wakeup Interrupt Status.
    }

    /// KEEP_ALIVE_WKCTRL Register bits
    namespace keep_alive_wkctrl_bits {
        constexpr uint32_t WAKE_ON_THIS = (4 << 0);  ///< Software configure it to which token can wakeup usb during KEEP_ALIVE mode
        constexpr uint32_t WAKE_ENDPT = (4 << 4);  ///< Indicates which endpoint causes the wakeup interrupt. Reset to 0, software read only.
    }

    /// MISCCTRL Register bits
    namespace miscctrl_bits {
        constexpr uint32_t SOFDYNTHLD = (1U << 0);  ///< Dynamic SOF Threshold Compare mode
        constexpr uint32_t SOFBUSSET = (1U << 1);  ///< SOF_TOK Interrupt Generation Mode Select
        constexpr uint32_t OWNERRISODIS = (1U << 2);  ///< OWN Error Detect for ISO IN / ISO OUT Disable
        constexpr uint32_t VREDG_EN = (1U << 3);  ///< VREGIN Rising Edge Interrupt Enable
        constexpr uint32_t VFEDG_EN = (1U << 4);  ///< VREGIN Falling Edge Interrupt Enable
        constexpr uint32_t STL_ADJ_EN = (1U << 7);  ///< USB Peripheral mode Stall Adjust Enable
    }

    /// STALL_IL_DIS Register bits
    namespace stall_il_dis_bits {
        constexpr uint32_t STALL_I_DIS0 = (1U << 0);  ///< Disable endpoint 0 IN direction.
        constexpr uint32_t STALL_I_DIS1 = (1U << 1);  ///< Disable endpoint 1 IN direction.
        constexpr uint32_t STALL_I_DIS2 = (1U << 2);  ///< Disable endpoint 2 IN direction.
        constexpr uint32_t STALL_I_DIS3 = (1U << 3);  ///< Disable endpoint 3 IN direction.
        constexpr uint32_t STALL_I_DIS4 = (1U << 4);  ///< Disable endpoint 4 IN direction.
        constexpr uint32_t STALL_I_DIS5 = (1U << 5);  ///< Disable endpoint 5 IN direction.
        constexpr uint32_t STALL_I_DIS6 = (1U << 6);  ///< Disable endpoint 6 IN direction.
        constexpr uint32_t STALL_I_DIS7 = (1U << 7);  ///< Disable endpoint 7 IN direction.
    }

    /// STALL_IH_DIS Register bits
    namespace stall_ih_dis_bits {
        constexpr uint32_t STALL_I_DIS8 = (1U << 0);  ///< Disable endpoint 8 IN direction.
        constexpr uint32_t STALL_I_DIS9 = (1U << 1);  ///< Disable endpoint 9 IN direction.
        constexpr uint32_t STALL_I_DIS10 = (1U << 2);  ///< Disable endpoint 10 IN direction.
        constexpr uint32_t STALL_I_DIS11 = (1U << 3);  ///< Disable endpoint 11 IN direction.
        constexpr uint32_t STALL_I_DIS12 = (1U << 4);  ///< Disable endpoint 12 IN direction.
        constexpr uint32_t STALL_I_DIS13 = (1U << 5);  ///< Disable endpoint 13 IN direction.
        constexpr uint32_t STALL_I_DIS14 = (1U << 6);  ///< Disable endpoint 14 IN direction.
        constexpr uint32_t STALL_I_DIS15 = (1U << 7);  ///< Disable endpoint 15 IN direction.
    }

    /// STALL_OL_DIS Register bits
    namespace stall_ol_dis_bits {
        constexpr uint32_t STALL_O_DIS0 = (1U << 0);  ///< Disable endpoint 0 OUT direction.
        constexpr uint32_t STALL_O_DIS1 = (1U << 1);  ///< Disable endpoint 1 OUT direction.
        constexpr uint32_t STALL_O_DIS2 = (1U << 2);  ///< Disable endpoint 2 OUT direction.
        constexpr uint32_t STALL_O_DIS3 = (1U << 3);  ///< Disable endpoint 3 OUT direction.
        constexpr uint32_t STALL_O_DIS4 = (1U << 4);  ///< Disable endpoint 4 OUT direction.
        constexpr uint32_t STALL_O_DIS5 = (1U << 5);  ///< Disable endpoint 5 OUT direction.
        constexpr uint32_t STALL_O_DIS6 = (1U << 6);  ///< Disable endpoint 6 OUT direction.
        constexpr uint32_t STALL_O_DIS7 = (1U << 7);  ///< Disable endpoint 7 OUT direction.
    }

    /// STALL_OH_DIS Register bits
    namespace stall_oh_dis_bits {
        constexpr uint32_t STALL_O_DIS8 = (1U << 0);  ///< Disable endpoint 8 OUT direction.
        constexpr uint32_t STALL_O_DIS9 = (1U << 1);  ///< Disable endpoint 9 OUT direction.
        constexpr uint32_t STALL_O_DIS10 = (1U << 2);  ///< Disable endpoint 10 OUT direction.
        constexpr uint32_t STALL_O_DIS11 = (1U << 3);  ///< Disable endpoint 11 OUT direction.
        constexpr uint32_t STALL_O_DIS12 = (1U << 4);  ///< Disable endpoint 12 OUT direction.
        constexpr uint32_t STALL_O_DIS13 = (1U << 5);  ///< Disable endpoint 13 OUT direction.
        constexpr uint32_t STALL_O_DIS14 = (1U << 6);  ///< Disable endpoint 14 OUT direction.
        constexpr uint32_t STALL_O_DIS15 = (1U << 7);  ///< Disable endpoint 15 OUT direction.
    }

    /// CLK_RECOVER_CTRL Register bits
    namespace clk_recover_ctrl_bits {
        constexpr uint32_t RESTART_IFRTRIM_EN = (1U << 5);  ///< Restart from IFR trim value
        constexpr uint32_t RESET_RESUME_ROUGH_EN = (1U << 6);  ///< Reset/resume to rough phase enable
        constexpr uint32_t CLOCK_RECOVER_EN = (1U << 7);  ///< Crystal-less USB enable
    }

    /// CLK_RECOVER_IRC_EN Register bits
    namespace clk_recover_irc_en_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< IRC48M regulator enable This bit is used to enable the local analog regulator for IRC48M module
        constexpr uint32_t IRC_EN = (1U << 1);  ///< IRC48M enable This bit is used to enable the on-chip IRC48M module to generate clocks for crystal-less USB
    }

    /// CLK_RECOVER_INT_EN Register bits
    namespace clk_recover_int_en_bits {
        constexpr uint32_t OVF_ERROR_EN = (1U << 4);  ///< Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.
    }

    /// CLK_RECOVER_INT_STATUS Register bits
    namespace clk_recover_int_status_bits {
        constexpr uint32_t OVF_ERROR = (1U << 4);  ///< Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module
    }

}

// ============================================================================
// CMP0 Peripheral
// ============================================================================

namespace cmp0 {
    /// Base addresses
    constexpr uint32_t CMP0_BASE = 0x40073000;

    /// CMP0 Register structure
    struct Registers {
        volatile uint32_t CR0;  ///< Offset: 0x00 - CMP Control Register 0
        volatile uint32_t CR1;  ///< Offset: 0x01 - CMP Control Register 1
        volatile uint32_t FPR;  ///< Offset: 0x02 - CMP Filter Period Register
        volatile uint32_t SCR;  ///< Offset: 0x03 - CMP Status and Control Register
        volatile uint32_t DACCR;  ///< Offset: 0x04 - DAC Control Register
        volatile uint32_t MUXCR;  ///< Offset: 0x05 - MUX Control Register
    };

    /// Peripheral instances
    inline Registers* CMP0 = reinterpret_cast<Registers*>(CMP0_BASE);

    // Bit definitions
    /// CR0 Register bits
    namespace cr0_bits {
        constexpr uint32_t HYSTCTR = (2 << 0);  ///< Comparator hard block hysteresis control
        constexpr uint32_t FILTER_CNT = (3 << 4);  ///< Filter Sample Count
    }

    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Comparator Module Enable
        constexpr uint32_t OPE = (1U << 1);  ///< Comparator Output Pin Enable
        constexpr uint32_t COS = (1U << 2);  ///< Comparator Output Select
        constexpr uint32_t INV = (1U << 3);  ///< Comparator INVERT
        constexpr uint32_t PMODE = (1U << 4);  ///< Power Mode Select
        constexpr uint32_t TRIGM = (1U << 5);  ///< Trigger Mode Enable
        constexpr uint32_t WE = (1U << 6);  ///< Windowing Enable
        constexpr uint32_t SE = (1U << 7);  ///< Sample Enable
    }

    /// FPR Register bits
    namespace fpr_bits {
        constexpr uint32_t FILT_PER = (8 << 0);  ///< Filter Sample Period
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t COUT = (1U << 0);  ///< Analog Comparator Output
        constexpr uint32_t CFF = (1U << 1);  ///< Analog Comparator Flag Falling
        constexpr uint32_t CFR = (1U << 2);  ///< Analog Comparator Flag Rising
        constexpr uint32_t IEF = (1U << 3);  ///< Comparator Interrupt Enable Falling
        constexpr uint32_t IER = (1U << 4);  ///< Comparator Interrupt Enable Rising
        constexpr uint32_t DMAEN = (1U << 6);  ///< DMA Enable Control
    }

    /// DACCR Register bits
    namespace daccr_bits {
        constexpr uint32_t VOSEL = (6 << 0);  ///< DAC Output Voltage Select
        constexpr uint32_t VRSEL = (1U << 6);  ///< Supply Voltage Reference Source Select
        constexpr uint32_t DACEN = (1U << 7);  ///< DAC Enable
    }

    /// MUXCR Register bits
    namespace muxcr_bits {
        constexpr uint32_t MSEL = (3 << 0);  ///< Minus Input Mux Control
        constexpr uint32_t PSEL = (3 << 3);  ///< Plus Input Mux Control
    }

}

// ============================================================================
// VREF Peripheral
// ============================================================================

namespace vref {
    /// Base addresses
    constexpr uint32_t VREF_BASE = 0x40074000;

    /// VREF Register structure
    struct Registers {
        volatile uint32_t TRM;  ///< Offset: 0x00 - VREF Trim Register
        volatile uint32_t SC;  ///< Offset: 0x01 - VREF Status and Control Register
    };

    /// Peripheral instances
    inline Registers* VREF = reinterpret_cast<Registers*>(VREF_BASE);

    // Bit definitions
    /// TRM Register bits
    namespace trm_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< Trim bits
        constexpr uint32_t CHOPEN = (1U << 6);  ///< Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    }

    /// SC Register bits
    namespace sc_bits {
        constexpr uint32_t MODE_LV = (2 << 0);  ///< Buffer Mode selection
        constexpr uint32_t VREFST = (1U << 2);  ///< Internal Voltage Reference stable
        constexpr uint32_t ICOMPEN = (1U << 5);  ///< Second order curvature compensation enable
        constexpr uint32_t REGEN = (1U << 6);  ///< Regulator enable
        constexpr uint32_t VREFEN = (1U << 7);  ///< Internal Voltage Reference enable
    }

}

// ============================================================================
// LLWU Peripheral
// ============================================================================

namespace llwu {
    /// Base addresses
    constexpr uint32_t LLWU_BASE = 0x4007C000;

    /// LLWU Register structure
    struct Registers {
        volatile uint32_t PE1;  ///< Offset: 0x00 - LLWU Pin Enable 1 register
        volatile uint32_t PE2;  ///< Offset: 0x01 - LLWU Pin Enable 2 register
        volatile uint32_t PE3;  ///< Offset: 0x02 - LLWU Pin Enable 3 register
        volatile uint32_t PE4;  ///< Offset: 0x03 - LLWU Pin Enable 4 register
        volatile uint32_t PE5;  ///< Offset: 0x04 - LLWU Pin Enable 5 register
        volatile uint32_t PE6;  ///< Offset: 0x05 - LLWU Pin Enable 6 register
        volatile uint32_t PE7;  ///< Offset: 0x06 - LLWU Pin Enable 7 register
        volatile uint32_t PE8;  ///< Offset: 0x07 - LLWU Pin Enable 8 register
        volatile uint32_t ME;  ///< Offset: 0x08 - LLWU Module Enable register
        volatile uint32_t PF1;  ///< Offset: 0x09 - LLWU Pin Flag 1 register
        volatile uint32_t PF2;  ///< Offset: 0x0A - LLWU Pin Flag 2 register
        volatile uint32_t PF3;  ///< Offset: 0x0B - LLWU Pin Flag 3 register
        volatile uint32_t PF4;  ///< Offset: 0x0C - LLWU Pin Flag 4 register
        volatile uint32_t MF5;  ///< Offset: 0x0D - LLWU Module Flag 5 register
        volatile uint32_t FILT1;  ///< Offset: 0x0E - LLWU Pin Filter 1 register
        volatile uint32_t FILT2;  ///< Offset: 0x0F - LLWU Pin Filter 2 register
        volatile uint32_t FILT3;  ///< Offset: 0x10 - LLWU Pin Filter 3 register
        volatile uint32_t FILT4;  ///< Offset: 0x11 - LLWU Pin Filter 4 register
    };

    /// Peripheral instances
    inline Registers* LLWU = reinterpret_cast<Registers*>(LLWU_BASE);

    // Bit definitions
    /// PE1 Register bits
    namespace pe1_bits {
        constexpr uint32_t WUPE0 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P0
        constexpr uint32_t WUPE1 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P1
        constexpr uint32_t WUPE2 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P2
        constexpr uint32_t WUPE3 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P3
    }

    /// PE2 Register bits
    namespace pe2_bits {
        constexpr uint32_t WUPE4 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P4
        constexpr uint32_t WUPE5 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P5
        constexpr uint32_t WUPE6 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P6
        constexpr uint32_t WUPE7 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P7
    }

    /// PE3 Register bits
    namespace pe3_bits {
        constexpr uint32_t WUPE8 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P8
        constexpr uint32_t WUPE9 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P9
        constexpr uint32_t WUPE10 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P10
        constexpr uint32_t WUPE11 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P11
    }

    /// PE4 Register bits
    namespace pe4_bits {
        constexpr uint32_t WUPE12 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P12
        constexpr uint32_t WUPE13 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P13
        constexpr uint32_t WUPE14 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P14
        constexpr uint32_t WUPE15 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P15
    }

    /// PE5 Register bits
    namespace pe5_bits {
        constexpr uint32_t WUPE16 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P16
        constexpr uint32_t WUPE17 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P17
        constexpr uint32_t WUPE18 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P18
        constexpr uint32_t WUPE19 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P19
    }

    /// PE6 Register bits
    namespace pe6_bits {
        constexpr uint32_t WUPE20 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P20
        constexpr uint32_t WUPE21 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P21
        constexpr uint32_t WUPE22 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P22
        constexpr uint32_t WUPE23 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P23
    }

    /// PE7 Register bits
    namespace pe7_bits {
        constexpr uint32_t WUPE24 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P24
        constexpr uint32_t WUPE25 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P25
        constexpr uint32_t WUPE26 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P26
        constexpr uint32_t WUPE27 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P27
    }

    /// PE8 Register bits
    namespace pe8_bits {
        constexpr uint32_t WUPE28 = (2 << 0);  ///< Wakeup Pin Enable For LLWU_P28
        constexpr uint32_t WUPE29 = (2 << 2);  ///< Wakeup Pin Enable For LLWU_P29
        constexpr uint32_t WUPE30 = (2 << 4);  ///< Wakeup Pin Enable For LLWU_P30
        constexpr uint32_t WUPE31 = (2 << 6);  ///< Wakeup Pin Enable For LLWU_P31
    }

    /// ME Register bits
    namespace me_bits {
        constexpr uint32_t WUME0 = (1U << 0);  ///< Wakeup Module Enable For Module 0
        constexpr uint32_t WUME1 = (1U << 1);  ///< Wakeup Module Enable for Module 1
        constexpr uint32_t WUME2 = (1U << 2);  ///< Wakeup Module Enable For Module 2
        constexpr uint32_t WUME3 = (1U << 3);  ///< Wakeup Module Enable For Module 3
        constexpr uint32_t WUME4 = (1U << 4);  ///< Wakeup Module Enable For Module 4
        constexpr uint32_t WUME5 = (1U << 5);  ///< Wakeup Module Enable For Module 5
        constexpr uint32_t WUME6 = (1U << 6);  ///< Wakeup Module Enable For Module 6
        constexpr uint32_t WUME7 = (1U << 7);  ///< Wakeup Module Enable For Module 7
    }

    /// PF1 Register bits
    namespace pf1_bits {
        constexpr uint32_t WUF0 = (1U << 0);  ///< Wakeup Flag For LLWU_P0
        constexpr uint32_t WUF1 = (1U << 1);  ///< Wakeup Flag For LLWU_P1
        constexpr uint32_t WUF2 = (1U << 2);  ///< Wakeup Flag For LLWU_P2
        constexpr uint32_t WUF3 = (1U << 3);  ///< Wakeup Flag For LLWU_P3
        constexpr uint32_t WUF4 = (1U << 4);  ///< Wakeup Flag For LLWU_P4
        constexpr uint32_t WUF5 = (1U << 5);  ///< Wakeup Flag For LLWU_P5
        constexpr uint32_t WUF6 = (1U << 6);  ///< Wakeup Flag For LLWU_P6
        constexpr uint32_t WUF7 = (1U << 7);  ///< Wakeup Flag For LLWU_P7
    }

    /// PF2 Register bits
    namespace pf2_bits {
        constexpr uint32_t WUF8 = (1U << 0);  ///< Wakeup Flag For LLWU_P8
        constexpr uint32_t WUF9 = (1U << 1);  ///< Wakeup Flag For LLWU_P9
        constexpr uint32_t WUF10 = (1U << 2);  ///< Wakeup Flag For LLWU_P10
        constexpr uint32_t WUF11 = (1U << 3);  ///< Wakeup Flag For LLWU_P11
        constexpr uint32_t WUF12 = (1U << 4);  ///< Wakeup Flag For LLWU_P12
        constexpr uint32_t WUF13 = (1U << 5);  ///< Wakeup Flag For LLWU_P13
        constexpr uint32_t WUF14 = (1U << 6);  ///< Wakeup Flag For LLWU_P14
        constexpr uint32_t WUF15 = (1U << 7);  ///< Wakeup Flag For LLWU_P15
    }

    /// PF3 Register bits
    namespace pf3_bits {
        constexpr uint32_t WUF16 = (1U << 0);  ///< Wakeup Flag For LLWU_P16
        constexpr uint32_t WUF17 = (1U << 1);  ///< Wakeup Flag For LLWU_P17
        constexpr uint32_t WUF18 = (1U << 2);  ///< Wakeup Flag For LLWU_P18
        constexpr uint32_t WUF19 = (1U << 3);  ///< Wakeup Flag For LLWU_P19
        constexpr uint32_t WUF20 = (1U << 4);  ///< Wakeup Flag For LLWU_P20
        constexpr uint32_t WUF21 = (1U << 5);  ///< Wakeup Flag For LLWU_P21
        constexpr uint32_t WUF22 = (1U << 6);  ///< Wakeup Flag For LLWU_P22
        constexpr uint32_t WUF23 = (1U << 7);  ///< Wakeup Flag For LLWU_P23
    }

    /// PF4 Register bits
    namespace pf4_bits {
        constexpr uint32_t WUF24 = (1U << 0);  ///< Wakeup Flag For LLWU_P24
        constexpr uint32_t WUF25 = (1U << 1);  ///< Wakeup Flag For LLWU_P25
        constexpr uint32_t WUF26 = (1U << 2);  ///< Wakeup Flag For LLWU_P26
        constexpr uint32_t WUF27 = (1U << 3);  ///< Wakeup Flag For LLWU_P27
        constexpr uint32_t WUF28 = (1U << 4);  ///< Wakeup Flag For LLWU_P28
        constexpr uint32_t WUF29 = (1U << 5);  ///< Wakeup Flag For LLWU_P29
        constexpr uint32_t WUF30 = (1U << 6);  ///< Wakeup Flag For LLWU_P30
        constexpr uint32_t WUF31 = (1U << 7);  ///< Wakeup Flag For LLWU_P31
    }

    /// MF5 Register bits
    namespace mf5_bits {
        constexpr uint32_t MWUF0 = (1U << 0);  ///< Wakeup flag For module 0
        constexpr uint32_t MWUF1 = (1U << 1);  ///< Wakeup flag For module 1
        constexpr uint32_t MWUF2 = (1U << 2);  ///< Wakeup flag For module 2
        constexpr uint32_t MWUF3 = (1U << 3);  ///< Wakeup flag For module 3
        constexpr uint32_t MWUF4 = (1U << 4);  ///< Wakeup flag For module 4
        constexpr uint32_t MWUF5 = (1U << 5);  ///< Wakeup flag For module 5
        constexpr uint32_t MWUF6 = (1U << 6);  ///< Wakeup flag For module 6
        constexpr uint32_t MWUF7 = (1U << 7);  ///< Wakeup flag For module 7
    }

    /// FILT1 Register bits
    namespace filt1_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT2 Register bits
    namespace filt2_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT3 Register bits
    namespace filt3_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

    /// FILT4 Register bits
    namespace filt4_bits {
        constexpr uint32_t FILTSEL = (5 << 0);  ///< Filter Pin Select
        constexpr uint32_t FILTE = (2 << 5);  ///< Digital Filter On External Pin
        constexpr uint32_t FILTF = (1U << 7);  ///< Filter Detect Flag
    }

}

// ============================================================================
// PMC Peripheral
// ============================================================================

namespace pmc {
    /// Base addresses
    constexpr uint32_t PMC_BASE = 0x4007D000;

    /// PMC Register structure
    struct Registers {
        volatile uint32_t LVDSC1;  ///< Offset: 0x00 - Low Voltage Detect Status And Control 1 register
        volatile uint32_t LVDSC2;  ///< Offset: 0x01 - Low Voltage Detect Status And Control 2 register
        volatile uint32_t REGSC;  ///< Offset: 0x02 - Regulator Status And Control register
        volatile uint32_t HVDSC1;  ///< Offset: 0x0B - High Voltage Detect Status And Control 1 register
    };

    /// Peripheral instances
    inline Registers* PMC = reinterpret_cast<Registers*>(PMC_BASE);

    // Bit definitions
    /// LVDSC1 Register bits
    namespace lvdsc1_bits {
        constexpr uint32_t LVDV = (2 << 0);  ///< Low-Voltage Detect Voltage Select
        constexpr uint32_t LVDRE = (1U << 4);  ///< Low-Voltage Detect Reset Enable
        constexpr uint32_t LVDIE = (1U << 5);  ///< Low-Voltage Detect Interrupt Enable
        constexpr uint32_t LVDACK = (1U << 6);  ///< Low-Voltage Detect Acknowledge
        constexpr uint32_t LVDF = (1U << 7);  ///< Low-Voltage Detect Flag
    }

    /// LVDSC2 Register bits
    namespace lvdsc2_bits {
        constexpr uint32_t LVWV = (2 << 0);  ///< Low-Voltage Warning Voltage Select
        constexpr uint32_t LVWIE = (1U << 5);  ///< Low-Voltage Warning Interrupt Enable
        constexpr uint32_t LVWACK = (1U << 6);  ///< Low-Voltage Warning Acknowledge
        constexpr uint32_t LVWF = (1U << 7);  ///< Low-Voltage Warning Flag
    }

    /// REGSC Register bits
    namespace regsc_bits {
        constexpr uint32_t BGBE = (1U << 0);  ///< Bandgap Buffer Enable
        constexpr uint32_t REGONS = (1U << 2);  ///< Regulator In Run Regulation Status
        constexpr uint32_t ACKISO = (1U << 3);  ///< Acknowledge Isolation
        constexpr uint32_t BGEN = (1U << 4);  ///< Bandgap Enable In VLPx Operation
        constexpr uint32_t VLPO = (1U << 6);  ///< VLPx Option
    }

    /// HVDSC1 Register bits
    namespace hvdsc1_bits {
        constexpr uint32_t HVDV = (1U << 0);  ///< High-Voltage Detect Voltage Select
        constexpr uint32_t HVDRE = (1U << 4);  ///< High-Voltage Detect Reset Enable
        constexpr uint32_t HVDIE = (1U << 5);  ///< High-Voltage Detect Interrupt Enable
        constexpr uint32_t HVDACK = (1U << 6);  ///< High-Voltage Detect Acknowledge
        constexpr uint32_t HVDF = (1U << 7);  ///< High-Voltage Detect Flag
    }

}

// ============================================================================
// SMC Peripheral
// ============================================================================

namespace smc {
    /// Base addresses
    constexpr uint32_t SMC_BASE = 0x4007E000;

    /// SMC Register structure
    struct Registers {
        volatile uint32_t PMPROT;  ///< Offset: 0x00 - Power Mode Protection register
        volatile uint32_t PMCTRL;  ///< Offset: 0x01 - Power Mode Control register
        volatile uint32_t STOPCTRL;  ///< Offset: 0x02 - Stop Control Register
        volatile uint32_t PMSTAT;  ///< Offset: 0x03 - Power Mode Status register
    };

    /// Peripheral instances
    inline Registers* SMC = reinterpret_cast<Registers*>(SMC_BASE);

    // Bit definitions
    /// PMPROT Register bits
    namespace pmprot_bits {
        constexpr uint32_t AVLLS = (1U << 1);  ///< Allow Very-Low-Leakage Stop Mode
        constexpr uint32_t ALLS = (1U << 3);  ///< Allow Low-Leakage Stop Mode
        constexpr uint32_t AVLP = (1U << 5);  ///< Allow Very-Low-Power Modes
        constexpr uint32_t AHSRUN = (1U << 7);  ///< Allow High Speed Run mode
    }

    /// PMCTRL Register bits
    namespace pmctrl_bits {
        constexpr uint32_t STOPM = (3 << 0);  ///< Stop Mode Control
        constexpr uint32_t STOPA = (1U << 3);  ///< Stop Aborted
        constexpr uint32_t RUNM = (2 << 5);  ///< Run Mode Control
    }

    /// STOPCTRL Register bits
    namespace stopctrl_bits {
        constexpr uint32_t LLSM = (3 << 0);  ///< LLS or VLLS Mode Control
        constexpr uint32_t LPOPO = (1U << 3);  ///< LPO Power Option
        constexpr uint32_t PORPO = (1U << 5);  ///< POR Power Option
        constexpr uint32_t PSTOPO = (2 << 6);  ///< Partial Stop Option
    }

    /// PMSTAT Register bits
    namespace pmstat_bits {
        constexpr uint32_t PMSTAT = (8 << 0);  ///< Power Mode Status
    }

}

// ============================================================================
// RCM Peripheral
// ============================================================================

namespace rcm {
    /// Base addresses
    constexpr uint32_t RCM_BASE = 0x4007F000;

    /// RCM Register structure
    struct Registers {
        volatile uint32_t SRS0;  ///< Offset: 0x00 - System Reset Status Register 0
        volatile uint32_t SRS1;  ///< Offset: 0x01 - System Reset Status Register 1
        volatile uint32_t RPFC;  ///< Offset: 0x04 - Reset Pin Filter Control register
        volatile uint32_t RPFW;  ///< Offset: 0x05 - Reset Pin Filter Width register
        volatile uint32_t FM;  ///< Offset: 0x06 - Force Mode Register
        volatile uint32_t MR;  ///< Offset: 0x07 - Mode Register
        volatile uint32_t SSRS0;  ///< Offset: 0x08 - Sticky System Reset Status Register 0
        volatile uint32_t SSRS1;  ///< Offset: 0x09 - Sticky System Reset Status Register 1
    };

    /// Peripheral instances
    inline Registers* RCM = reinterpret_cast<Registers*>(RCM_BASE);

    // Bit definitions
    /// SRS0 Register bits
    namespace srs0_bits {
        constexpr uint32_t WAKEUP = (1U << 0);  ///< Low Leakage Wakeup Reset
        constexpr uint32_t LVD = (1U << 1);  ///< Low-Voltage Detect Reset
        constexpr uint32_t LOC = (1U << 2);  ///< Loss-of-Clock Reset
        constexpr uint32_t LOL = (1U << 3);  ///< Loss-of-Lock Reset
        constexpr uint32_t WDOG = (1U << 5);  ///< Watchdog
        constexpr uint32_t PIN = (1U << 6);  ///< External Reset Pin
        constexpr uint32_t POR = (1U << 7);  ///< Power-On Reset
    }

    /// SRS1 Register bits
    namespace srs1_bits {
        constexpr uint32_t LOCKUP = (1U << 1);  ///< Core Lockup
        constexpr uint32_t SW = (1U << 2);  ///< Software
        constexpr uint32_t MDM_AP = (1U << 3);  ///< MDM-AP System Reset Request
        constexpr uint32_t SACKERR = (1U << 5);  ///< Stop Mode Acknowledge Error Reset
        constexpr uint32_t TAMPER = (1U << 7);  ///< Tamper detect
    }

    /// RPFC Register bits
    namespace rpfc_bits {
        constexpr uint32_t RSTFLTSRW = (2 << 0);  ///< Reset Pin Filter Select in Run and Wait Modes
        constexpr uint32_t RSTFLTSS = (1U << 2);  ///< Reset Pin Filter Select in Stop Mode
    }

    /// RPFW Register bits
    namespace rpfw_bits {
        constexpr uint32_t RSTFLTSEL = (5 << 0);  ///< Reset Pin Filter Bus Clock Select
    }

    /// FM Register bits
    namespace fm_bits {
        constexpr uint32_t FORCEROM = (2 << 1);  ///< Force ROM Boot
    }

    /// MR Register bits
    namespace mr_bits {
        constexpr uint32_t BOOTROM = (2 << 1);  ///< Boot ROM Configuration
    }

    /// SSRS0 Register bits
    namespace ssrs0_bits {
        constexpr uint32_t SWAKEUP = (1U << 0);  ///< Sticky Low Leakage Wakeup Reset
        constexpr uint32_t SLVD = (1U << 1);  ///< Sticky Low-Voltage Detect Reset
        constexpr uint32_t SLOC = (1U << 2);  ///< Sticky Loss-of-Clock Reset
        constexpr uint32_t SLOL = (1U << 3);  ///< Sticky Loss-of-Lock Reset
        constexpr uint32_t SWDOG = (1U << 5);  ///< Sticky Watchdog
        constexpr uint32_t SPIN = (1U << 6);  ///< Sticky External Reset Pin
        constexpr uint32_t SPOR = (1U << 7);  ///< Sticky Power-On Reset
    }

    /// SSRS1 Register bits
    namespace ssrs1_bits {
        constexpr uint32_t SLOCKUP = (1U << 1);  ///< Sticky Core Lockup
        constexpr uint32_t SSW = (1U << 2);  ///< Sticky Software
        constexpr uint32_t SMDM_AP = (1U << 3);  ///< Sticky MDM-AP System Reset Request
        constexpr uint32_t SSACKERR = (1U << 5);  ///< Sticky Stop Mode Acknowledge Error Reset
        constexpr uint32_t STAMPER = (1U << 7);  ///< Sticky Tamper detect
    }

}

// ============================================================================
// MTB Peripheral
// ============================================================================

namespace mtb {
    /// Base addresses
    constexpr uint32_t MTB_BASE = 0xF0000000;

    /// MTB Register structure
    struct Registers {
        volatile uint32_t POSITION;  ///< Offset: 0x00 - MTB Position Register
        volatile uint32_t MASTER;  ///< Offset: 0x04 - MTB Master Register
        volatile uint32_t FLOW;  ///< Offset: 0x08 - MTB Flow Register
        volatile uint32_t BASE;  ///< Offset: 0x0C - MTB Base Register
        volatile uint32_t MODECTRL;  ///< Offset: 0xF00 - Integration Mode Control Register
        volatile uint32_t TAGSET;  ///< Offset: 0xFA0 - Claim TAG Set Register
        volatile uint32_t TAGCLEAR;  ///< Offset: 0xFA4 - Claim TAG Clear Register
        volatile uint32_t LOCKACCESS;  ///< Offset: 0xFB0 - Lock Access Register
        volatile uint32_t LOCKSTAT;  ///< Offset: 0xFB4 - Lock Status Register
        volatile uint32_t AUTHSTAT;  ///< Offset: 0xFB8 - Authentication Status Register
        volatile uint32_t DEVICEARCH;  ///< Offset: 0xFBC - Device Architecture Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTB = reinterpret_cast<Registers*>(MTB_BASE);

    // Bit definitions
    /// POSITION Register bits
    namespace position_bits {
        constexpr uint32_t WRAP = (1U << 2);  ///< WRAP
        constexpr uint32_t POINTER = (29 << 3);  ///< Trace Packet Address Pointer[28:0]
    }

    /// MASTER Register bits
    namespace master_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< Mask
        constexpr uint32_t TSTARTEN = (1U << 5);  ///< Trace Start Input Enable
        constexpr uint32_t TSTOPEN = (1U << 6);  ///< Trace Stop Input Enable
        constexpr uint32_t SFRWPRIV = (1U << 7);  ///< Special Function Register Write Privilege
        constexpr uint32_t RAMPRIV = (1U << 8);  ///< RAM Privilege
        constexpr uint32_t HALTREQ = (1U << 9);  ///< Halt Request
        constexpr uint32_t EN = (1U << 31);  ///< Main Trace Enable
    }

    /// FLOW Register bits
    namespace flow_bits {
        constexpr uint32_t AUTOSTOP = (1U << 0);  ///< AUTOSTOP
        constexpr uint32_t AUTOHALT = (1U << 1);  ///< AUTOHALT
        constexpr uint32_t WATERMARK = (29 << 3);  ///< WATERMARK[28:0]
    }

    /// BASE Register bits
    namespace base_bits {
        constexpr uint32_t BASEADDR = (32 << 0);  ///< BASEADDR
    }

    /// MODECTRL Register bits
    namespace modectrl_bits {
        constexpr uint32_t MODECTRL = (32 << 0);  ///< MODECTRL
    }

    /// TAGSET Register bits
    namespace tagset_bits {
        constexpr uint32_t TAGSET = (32 << 0);  ///< TAGSET
    }

    /// TAGCLEAR Register bits
    namespace tagclear_bits {
        constexpr uint32_t TAGCLEAR = (32 << 0);  ///< TAGCLEAR
    }

    /// LOCKACCESS Register bits
    namespace lockaccess_bits {
        constexpr uint32_t LOCKACCESS = (32 << 0);  ///< Hardwired to 0x0000_0000
    }

    /// LOCKSTAT Register bits
    namespace lockstat_bits {
        constexpr uint32_t LOCKSTAT = (32 << 0);  ///< LOCKSTAT
    }

    /// AUTHSTAT Register bits
    namespace authstat_bits {
        constexpr uint32_t BIT0 = (1U << 0);  ///< Connected to DBGEN.
        constexpr uint32_t BIT2 = (1U << 2);  ///< BIT2
    }

    /// DEVICEARCH Register bits
    namespace devicearch_bits {
        constexpr uint32_t DEVICEARCH = (32 << 0);  ///< DEVICEARCH
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MTBDWT Peripheral
// ============================================================================

namespace mtbdwt {
    /// Base addresses
    constexpr uint32_t MTBDWT_BASE = 0xF0001000;

    /// MTBDWT Register structure
    struct Registers {
        volatile uint32_t CTRL;  ///< Offset: 0x00 - MTB DWT Control Register
        volatile uint32_t COMP;  ///< Offset: 0x20 - MTB_DWT Comparator Register (renamed from COMP)
        volatile uint32_t MASK;  ///< Offset: 0x24 - MTB_DWT Comparator Mask Register (renamed from MASK)
        volatile uint32_t FCT0;  ///< Offset: 0x28 - MTB_DWT Comparator Function Register 0
        volatile uint32_t FCT1;  ///< Offset: 0x38 - MTB_DWT Comparator Function Register 1
        volatile uint32_t TBCTRL;  ///< Offset: 0x200 - MTB_DWT Trace Buffer Control Register
        volatile uint32_t DEVICECFG;  ///< Offset: 0xFC8 - Device Configuration Register
        volatile uint32_t DEVICETYPID;  ///< Offset: 0xFCC - Device Type Identifier Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* MTBDWT = reinterpret_cast<Registers*>(MTBDWT_BASE);

    // Bit definitions
    /// CTRL Register bits
    namespace ctrl_bits {
        constexpr uint32_t DWTCFGCTRL = (28 << 0);  ///< DWT configuration controls
        constexpr uint32_t NUMCMP = (4 << 28);  ///< Number of comparators
    }

    /// COMP Register bits
    namespace comp_bits {
        constexpr uint32_t COMP = (32 << 0);  ///< Reference value for comparison
    }

    /// MASK Register bits
    namespace mask_bits {
        constexpr uint32_t MASK = (5 << 0);  ///< MASK
    }

    /// FCT0 Register bits
    namespace fct0_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t DATAVMATCH = (1U << 8);  ///< Data Value Match
        constexpr uint32_t DATAVSIZE = (2 << 10);  ///< Data Value Size
        constexpr uint32_t DATAVADDR0 = (4 << 12);  ///< Data Value Address 0
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// FCT1 Register bits
    namespace fct1_bits {
        constexpr uint32_t FUNCTION = (4 << 0);  ///< Function
        constexpr uint32_t MATCHED = (1U << 24);  ///< Comparator match
    }

    /// TBCTRL Register bits
    namespace tbctrl_bits {
        constexpr uint32_t ACOMP0 = (1U << 0);  ///< Action based on Comparator 0 match
        constexpr uint32_t ACOMP1 = (1U << 1);  ///< Action based on Comparator 1 match
        constexpr uint32_t NUMCOMP = (4 << 28);  ///< Number of Comparators
    }

    /// DEVICECFG Register bits
    namespace devicecfg_bits {
        constexpr uint32_t DEVICECFG = (32 << 0);  ///< DEVICECFG
    }

    /// DEVICETYPID Register bits
    namespace devicetypid_bits {
        constexpr uint32_t DEVICETYPID = (32 << 0);  ///< DEVICETYPID
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// ROM Peripheral
// ============================================================================

namespace rom {
    /// Base addresses
    constexpr uint32_t ROM_BASE = 0xF0002000;

    /// ROM Register structure
    struct Registers {
        volatile uint32_t ENTRY;  ///< Offset: 0x00 - Entry (renamed from ENTRY)
        volatile uint32_t TABLEMARK;  ///< Offset: 0x0C - End of Table Marker Register
        volatile uint32_t SYSACCESS;  ///< Offset: 0xFCC - System Access Register
        volatile uint32_t PERIPHID;  ///< Offset: 0xFD0 - Peripheral ID Register (renamed from PERIPHID)
        volatile uint32_t COMPID;  ///< Offset: 0xFF0 - Component ID Register (renamed from COMPID)
    };

    /// Peripheral instances
    inline Registers* ROM = reinterpret_cast<Registers*>(ROM_BASE);

    // Bit definitions
    /// ENTRY Register bits
    namespace entry_bits {
        constexpr uint32_t ENTRY = (32 << 0);  ///< ENTRY
    }

    /// TABLEMARK Register bits
    namespace tablemark_bits {
        constexpr uint32_t MARK = (32 << 0);  ///< MARK
    }

    /// SYSACCESS Register bits
    namespace sysaccess_bits {
        constexpr uint32_t SYSACCESS = (32 << 0);  ///< SYSACCESS
    }

    /// PERIPHID Register bits
    namespace periphid_bits {
        constexpr uint32_t PERIPHID = (32 << 0);  ///< PERIPHID
    }

    /// COMPID Register bits
    namespace compid_bits {
        constexpr uint32_t COMPID = (32 << 0);  ///< Component ID
    }

}

// ============================================================================
// MCM Peripheral
// ============================================================================

namespace mcm {
    /// Base addresses
    constexpr uint32_t MCM_BASE = 0xF0003000;

    /// MCM Register structure
    struct Registers {
        volatile uint32_t PLASC;  ///< Offset: 0x08 - Crossbar Switch (AXBS) Slave Configuration
        volatile uint32_t PLAMC;  ///< Offset: 0x0A - Crossbar Switch (AXBS) Master Configuration
        volatile uint32_t PLACR;  ///< Offset: 0x0C - Platform Control Register
        volatile uint32_t CPO;  ///< Offset: 0x40 - Compute Operation Control Register
    };

    /// Peripheral instances
    inline Registers* MCM = reinterpret_cast<Registers*>(MCM_BASE);

    // Bit definitions
    /// PLASC Register bits
    namespace plasc_bits {
        constexpr uint32_t ASC = (8 << 0);  ///< Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
    }

    /// PLAMC Register bits
    namespace plamc_bits {
        constexpr uint32_t AMC = (8 << 0);  ///< Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
    }

    /// PLACR Register bits
    namespace placr_bits {
        constexpr uint32_t ARB = (1U << 9);  ///< Arbitration select
        constexpr uint32_t CFCC = (1U << 10);  ///< Clear Flash Controller Cache
        constexpr uint32_t DFCDA = (1U << 11);  ///< Disable Flash Controller Data Caching
        constexpr uint32_t DFCIC = (1U << 12);  ///< Disable Flash Controller Instruction Caching
        constexpr uint32_t DFCC = (1U << 13);  ///< Disable Flash Controller Cache
        constexpr uint32_t EFDS = (1U << 14);  ///< Enable Flash Data Speculation
        constexpr uint32_t DFCS = (1U << 15);  ///< Disable Flash Controller Speculation
        constexpr uint32_t ESFC = (1U << 16);  ///< Enable Stalling Flash Controller
    }

    /// CPO Register bits
    namespace cpo_bits {
        constexpr uint32_t CPOREQ = (1U << 0);  ///< Compute Operation Request
        constexpr uint32_t CPOACK = (1U << 1);  ///< Compute Operation Acknowledge
        constexpr uint32_t CPOWOI = (1U << 2);  ///< Compute Operation Wake-up on Interrupt
    }

}


} // namespace alloy::generated::mkl81z7

#endif // ALLOY_GENERATED_MKL81Z7_PERIPHERALS_HPP